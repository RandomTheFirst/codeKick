[[{"term": "def", "name": "__init__", "data": "  def __init__(self):\n\t  self.frames = {\n\t\t'flame': import_folder('../graphics/particles/flame/frames'),\n\t\t'aura': import_folder('../graphics/particles/aura'),\n\t\t'heal': import_folder('../graphics/particles/heal/frames'),\n\t\t\n\t\t'claw': import_folder('../graphics/particles/claw'),\n\t\t'slash': import_folder('../graphics/particles/slash'),\n\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\n\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\n\t\t'thunder': import_folder('../graphics/particles/thunder'),\n\t\t\n\t\t'squid': import_folder('../graphics/particles/squid'),\n\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\n\t\t'spirit': import_folder('../graphics/particles/spirit'),\n\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\n\t\t\n\t\t'leaf': (\n\t\t  import_folder('../graphics/particles/leaf1'),\n\t\t  import_folder('../graphics/particles/leaf2'),\n\t\t  import_folder('../graphics/particles/leaf3'),\n\t\t  import_folder('../graphics/particles/leaf4'),\n\t\t  import_folder('../graphics/particles/leaf5'),\n\t\t  import_folder('../graphics/particles/leaf6'),\n\t\t  self.reflect_images(import_folder('../graphics/particles/leaf1')),\n\t\t  self.reflect_images(import_folder('../graphics/particles/leaf2')),\n\t\t  self.reflect_images(import_folder('../graphics/particles/leaf3')),\n\t\t  self.reflect_images(import_folder('../graphics/particles/leaf4')),\n\t\t  self.reflect_images(import_folder('../graphics/particles/leaf5')),\n\t\t  self.reflect_images(import_folder('../graphics/particles/leaf6')),\n\t\t)\n\t  }\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t'squid': import_folder('../graphics/particles/squid'),", "\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t'spirit': import_folder('../graphics/particles/spirit'),", "\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t  import_folder('../graphics/particles/leaf1'),", "\t\t  import_folder('../graphics/particles/leaf2'),", "\t\t  import_folder('../graphics/particles/leaf3'),", "\t\t  import_folder('../graphics/particles/leaf4'),", "\t\t  import_folder('../graphics/particles/leaf5'),", "\t\t  import_folder('../graphics/particles/leaf6'),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf6')),"]}, {"term": "def", "name": "reflect_images", "data": "  def reflect_images(self, frames):\n\tnew_frames = []\n\n\tfor frame in frames:\n\t  flipped_frame = pygame.transform.flip(frame, True, False)\n\t  new_frames.append(flipped_frame)\n\treturn new_frames\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t'squid': import_folder('../graphics/particles/squid'),", "\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t'spirit': import_folder('../graphics/particles/spirit'),", "\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t  import_folder('../graphics/particles/leaf1'),", "\t\t  import_folder('../graphics/particles/leaf2'),", "\t\t  import_folder('../graphics/particles/leaf3'),", "\t\t  import_folder('../graphics/particles/leaf4'),", "\t\t  import_folder('../graphics/particles/leaf5'),", "\t\t  import_folder('../graphics/particles/leaf6'),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf6')),"]}, {"term": "def", "name": "create_grass_particles", "data": "  def create_grass_particles(self, pos, groups):\n\tanimation_frames = choice(self.frames['leaf'])\n\tParticleEffect(pos, animation_frames, groups)\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t'squid': import_folder('../graphics/particles/squid'),", "\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t'spirit': import_folder('../graphics/particles/spirit'),", "\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t  import_folder('../graphics/particles/leaf1'),", "\t\t  import_folder('../graphics/particles/leaf2'),", "\t\t  import_folder('../graphics/particles/leaf3'),", "\t\t  import_folder('../graphics/particles/leaf4'),", "\t\t  import_folder('../graphics/particles/leaf5'),", "\t\t  import_folder('../graphics/particles/leaf6'),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf6')),"]}, {"term": "def", "name": "create_particles", "data": "  def create_particles(self, animation_type, pos, groups):\n\tanimation_frames = self.frames[animation_type]\n\tParticleEffect(pos, animation_frames, groups)\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t'squid': import_folder('../graphics/particles/squid'),", "\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t'spirit': import_folder('../graphics/particles/spirit'),", "\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t  import_folder('../graphics/particles/leaf1'),", "\t\t  import_folder('../graphics/particles/leaf2'),", "\t\t  import_folder('../graphics/particles/leaf3'),", "\t\t  import_folder('../graphics/particles/leaf4'),", "\t\t  import_folder('../graphics/particles/leaf5'),", "\t\t  import_folder('../graphics/particles/leaf6'),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf6')),"]}, {"term": "def", "name": "__init__", "data": "  def __init__(self, pos, animation_frames, groups):\n\tsuper().__init__(groups)\n\tself.sprite_type = 'magic'\n\tself.frame_index = 0\n\tself.animation_speed = 0.15\n\tself.frames = animation_frames\n\tself.image = self.frames[self.frame_index]\n\tself.rect = self.image.get_rect(center = pos)\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t'squid': import_folder('../graphics/particles/squid'),", "\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t'spirit': import_folder('../graphics/particles/spirit'),", "\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t  import_folder('../graphics/particles/leaf1'),", "\t\t  import_folder('../graphics/particles/leaf2'),", "\t\t  import_folder('../graphics/particles/leaf3'),", "\t\t  import_folder('../graphics/particles/leaf4'),", "\t\t  import_folder('../graphics/particles/leaf5'),", "\t\t  import_folder('../graphics/particles/leaf6'),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf6')),"]}, {"term": "def", "name": "animate", "data": "  def animate(self):\n\tself.frame_index += self.animation_speed\n\tif self.frame_index >= len(self.frames):\n\t  self.kill()\n\telse:\n\t  self.image = self.frames[int(self.frame_index)]\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t'squid': import_folder('../graphics/particles/squid'),", "\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t'spirit': import_folder('../graphics/particles/spirit'),", "\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t  import_folder('../graphics/particles/leaf1'),", "\t\t  import_folder('../graphics/particles/leaf2'),", "\t\t  import_folder('../graphics/particles/leaf3'),", "\t\t  import_folder('../graphics/particles/leaf4'),", "\t\t  import_folder('../graphics/particles/leaf5'),", "\t\t  import_folder('../graphics/particles/leaf6'),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf6')),"]}, {"term": "def", "name": "update", "data": "  def update(self):\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t'squid': import_folder('../graphics/particles/squid'),", "\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t'spirit': import_folder('../graphics/particles/spirit'),", "\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t  import_folder('../graphics/particles/leaf1'),", "\t\t  import_folder('../graphics/particles/leaf2'),", "\t\t  import_folder('../graphics/particles/leaf3'),", "\t\t  import_folder('../graphics/particles/leaf4'),", "\t\t  import_folder('../graphics/particles/leaf5'),", "\t\t  import_folder('../graphics/particles/leaf6'),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t  self.reflect_images(import_folder('../graphics/particles/leaf6')),"]}], [], [], [{"term": "def", "name": "main", "data": "def main():\n\tlayer = Sprite()\n\tlayer.x = layer.y = 50\n\taddChild(layer)\n\n\tlayer.graphics.beginFill()\n\tlayer.graphics.lineStyle(5, \"green\", 0.2)\n\tlayer.graphics.drawRect(0, 0, 150, 150)\n\tlayer.graphics.endFill()\n\n\tlayer.graphics.beginFill()\n\tlayer.graphics.lineStyle(5, \"green\", 0.8)\n\tlayer.graphics.drawRect(200, 0, 150, 150)\n\tlayer.graphics.endFill()\n\n\tlayer.graphics.beginFill(\"lightgreen\")\n\tlayer.graphics.lineStyle(5, \"green\", 0.5)\n\tlayer.graphics.drawRect(400, 0, 150, 150)\n\tlayer.graphics.endFill()\n\n\n\tlayer.graphics.beginFill()\n\tlayer.graphics.lineStyle(5, \"green\", 0.2)\n\tlayer.graphics.drawCircle(75, 275, 75)\n\tlayer.graphics.endFill()\n\n\tlayer.graphics.beginFill()\n\tlayer.graphics.lineStyle(5, \"green\", 0.8)\n\tlayer.graphics.drawCircle(275, 275, 75)\n\tlayer.graphics.endFill()\n\n\tlayer.graphics.beginFill(\"lightgreen\")\n\tlayer.graphics.lineStyle(5, \"green\", 0.5)\n\tlayer.graphics.drawCircle(475, 275, 75)\n\tlayer.graphics.endFill()\n\n\n\tlayer.graphics.beginFill()\n\tlayer.graphics.lineStyle(5, \"green\", 0.2)\n\tlayer.graphics.moveTo(0, 498)\n\tlayer.graphics.lineTo(75, 400)\n\tlayer.graphics.lineTo(150, 498)\n\tlayer.graphics.lineTo(0, 498)\n\tlayer.graphics.endFill()\n\n\tlayer.graphics.beginFill()\n\tlayer.graphics.lineStyle(5, \"green\", 0.8)\n\tlayer.graphics.moveTo(200, 498)\n\tlayer.graphics.lineTo(275, 400)\n\tlayer.graphics.lineTo(350, 498)\n\tlayer.graphics.lineTo(200, 498)\n\tlayer.graphics.endFill()\n\n\tlayer.graphics.beginFill(\"lightgreen\")\n\tlayer.graphics.lineStyle(5, \"green\", 0.5)\n\tlayer.graphics.moveTo(400, 498)\n\tlayer.graphics.lineTo(475, 400)\n\tlayer.graphics.lineTo(550, 498)\n\tlayer.graphics.lineTo(400, 498)\n\tlayer.graphics.endFill()\n", "description": null, "category": "graphics", "imports": ["from pylash.core import init, addChild", "from pylash.display import Sprite, Graphics"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\n\t# Add animation loop here!\n   \n\t_dx = graphics.get_dx()\n\t_dy = graphics.get_dy()\n\tbrick_falling_speed = graphics.get_dy()\n\n\twhile(True):\n\n\t\tpause(FRAME_RATE)\n\n\t\tif graphics.started_or_not == 1:\n\n\t\t\tgraphics.ball.move(_dx, _dy)\n\n\t\t\tif graphics.ball.x <= 0 or graphics.ball.x+graphics.ball_radius*2 >= graphics.window.width:\n\t\t\t\t_dx *= -1\n\n\t\t\tif graphics.ball.y <= 0:\n\t\t\t\t_dy *= -1\n\n\t\t\tobj = graphics.detect_object()\n\n\t\t\tif obj is not None:\n\n\t\t\t\tif (obj is not graphics.paddle) and (obj is not graphics.score_board) and (obj is not graphics.lives) and (obj not in graphics.falling_bricks):\n\t\t\t\t\tgraphics.remove_bricks(obj)\n\t\t\t\t\t_dy *= -1\n\t\t\t\t\t#speed up the ball\n\t\t\t\t\tif abs(_dy) <= 15:\n\t\t\t\t\t\tif _dy < 0:\n\t\t\t\t\t\t\t_dy-=0.2\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t_dy+=0.2\n\t\t\t\t\t\n\t\t\t\telif obj is graphics.paddle:\n\t\t\t\t\t_dy *= -1\n\t\t\t\telse:\n\t\t\t\t\tpass\n\n\t\t\tif (graphics.ball.y > graphics.window.height) or graphics.paddle_collision() == True:\n\t\t\t\tgraphics.lost_lives()\n\t\t\t\tgraphics.reset()\n\n\t\t\tfor brick in graphics.falling_bricks:\n\t\t\t\tif brick.y > graphics.window_height:\n\t\t\t\t\tgraphics.remove_falling_bricks(brick)\n\t\t\t\tbrick.move(0,brick_falling_speed)\n\n\t\t\tif graphics.num_lives == 0:\n\t\t\t\tresult = graphics.message(\"You Lose!\")\n\t\t\t\tgraphics.window.add(result)\n\t\t\t\tbreak\n\t\t\t\n\t\t\tif graphics.bricks_num == 0:\n\t\t\t\tresult = graphics.message(\"You Win!\")\n\t\t\t\tgraphics.window.add(result)\n\t\t\t\tbreak\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "import time"]}], [], [{"term": "class", "name": "Display", "data": "class Display(object):\n\t\n\tWHITE = graphicsUtils.formatColor(1.0, 1.0, 1.0)\n\tRED = graphicsUtils.formatColor(1.0, 0.0, 0.0)\n\tGREEN = graphicsUtils.formatColor(0.16, 0.49, 0.31)\n\tBLUE = graphicsUtils.formatColor(0.0, 0.0, 1.0)\n\tBLACK = graphicsUtils.formatColor(0.0, 0.0, 0.0)\n\tGREY = graphicsUtils.formatColor(0.5, .5, 0.5)\n\t\n\tVISIBLE_CUTTOFF = 0.001\n\t\n\t\n\tpartDict = {}\n\tbeliefParts = []\n\tbeliefValue = []\n\tbeliefColor = []\n\tobservations = []\n\t\n\tgraphicsLock = threading.Lock()\n\t\n\tCOLORS = [\n\t\t'purple',\n\t\t'green',\n\t\t'teal',\n\t\t'red',\n\t\t'orange',\n\t\t'yellow'\n\t]\n\tCOLOR_HUES = {\n\t\t'purple' : 0.8,\n\t\t'green' : 0.3,\n\t\t'teal' : 0.49,\n\t\t'red' : 0.0,\n\t\t'orange' : 0.125,\n\t\t'yellow' : 0.21\n\t}\n\t\n\t@staticmethod\n\tdef initGraphics(layout):\n\t\tgraphicsUtils.begin_graphics(\n\t\t\twidth=layout.getWidth(), \n\t\t\theight=layout.getHeight(), \n\t\t\tcolor = Display.WHITE,\n\t\t\ttitle = Const.TITLE\n\t\t);\n\t\t\n\t@staticmethod\n\tdef endGraphics():\n\t\tgraphicsUtils.end_graphics()\n\n\t@staticmethod\n\tdef raiseEndGraphics():\n\t\tgraphicsUtils.raiseEndGraphics()\n\t\n\t@staticmethod\n\tdef drawCar(car):\n\t\tif car in Display.partDict:\n\t\t\tDisplay._remove(car)\n\t\tcolor = Display.GREY\n\t\tif car.isJunior():\n\t\t\tcolor = Display.BLACK\n\t\tparts = graphicsUtils.rectangle(\n\t\t\tcar.pos, Car.LENGTH, \n\t\t\tCar.WIDTH, \n\t\t\tcolor, \n\t\t\tcar.dir\n\t\t)\n\t\tDisplay.partDict[car] = parts\n\t\t\n\t@staticmethod\n\tdef drawObservation(obs):\n\t\tparts = Display.drawCircle(obs.pos, Observation.RADIUS)\n\t\tDisplay.partDict[obs] = parts\n\t\n\t@staticmethod\n\tdef drawSquare(pos, size, color):\n\t\treturn graphicsUtils.square(pos, size, color)\n\t\n\t@staticmethod\n\tdef drawFinish(block):\n\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.GREEN, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\n\t@staticmethod\n\tdef drawBlocks(blocks):\n\t\tfor block in blocks:\n\t\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.BLUE, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\t\n\t@staticmethod\n\tdef drawCircle(pos, radius):\n\t\treturn graphicsUtils.circle(pos, radius, Display.RED, Display.RED)\n\t\n\t@staticmethod\n\tdef drawBelief(model):\n\t\tDisplay.beliefVisible = []\n\t\tfor r in range(model.getBeliefRows()):\n\t\t\tbeliefValueRow = []\n\t\t\tbeliefPartRow = []\n\t\t\tbeliefColorRow = []\n\t\t\tfor c in range(model.getBeliefCols()):\n\t\t\t\tsquare = Display.drawBeliefSquare(r, c, 'purple', 0.0, model)\n\t\t\t\tbeliefPartRow.append(square)\n\t\t\t\tbeliefValueRow.append(0.0)\n\t\t\t\tbeliefColorRow.append(None)\n\t\t\tDisplay.beliefParts.append(beliefPartRow)\n\t\t\tDisplay.beliefValue.append(beliefValueRow)\n\t\t\tDisplay.beliefColor.append(beliefColorRow)\n\t\t\t\t\n\t@staticmethod\n\tdef drawBeliefSquare(row, col, color, value, model):\n\t\ttileSize = Const.BELIEF_TILE_SIZE\n\t\tx = col * tileSize + tileSize / 2.0\n\t\ty = row * tileSize + tileSize / 2.0\n\t\tif not model.inBounds(x, y): return None\n\t\tcolor = Display._getBeliefSquareColor(color, value)\n\t\treturn Display.drawSquare(Vec2d(x, y), tileSize, color)\n\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef getKeys():\n\t\t#print 'attempt get keys'\n\t\tDisplay._acquireLock()\n\t\t#print 'get keys'\n\t\tkeys = graphicsUtils.keys_waiting() + graphicsUtils.keys_pressed()\n\t\tDisplay._releaseLock()\n\t\treturn keys\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef graphicsSleep(timeToSleep):\n\t\tgraphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''for _ in range(int(timeToSleep / 0.005)):\n\t\t\t#print 'attempt sleep'\n\t\t\tDisplay._acquireLock()\n\t\t\t#print 'sleep'\n\t\t\tgraphicsUtils.sleep(0.001)\n\t\t\tDisplay._releaseLock()\n\t\t\ttime.sleep(0.004)'''\n\t\t\n\t\t#graphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''startWait = time.time()\n\t\tDisplay._acquireLock()\n\t\ttimeToSleep -= time.time() - startWait\n\t\tgraphicsUtils.refresh()\n\t\tif timeToSleep > 0:\n\t\t\tgraphicsUtils.sleep(timeToSleep)\n\t\tDisplay._releaseLock()'''\n\t\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef updateBelief(color, belief):\n\t\tDisplay._acquireLock()\n\t\ttotal = belief.getSum()\n\t\tif abs(total - 1.0) > 0.001:\n\t\t\traise Exception('belief does not sum to 1 ('+str(total)+'). Use the normalize method.')\n\t\tfor r in range(belief.getNumRows()):\n\t\t\tfor c in range(belief.getNumCols()):\n\t\t\t\tvalue = belief.getProb(r, c)\n\t\t\t\tDisplay._updateBeliefSquare(r, c, value, color)\n\t\tDisplay._releaseLock()\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef move(obj, delta):\n\t\t#print 'attempt move'\n\t\tDisplay._acquireLock()\n\t\t#print 'move'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.move_by(parts, delta.x, delta.y)\n\t\t#print 'end move'\n\t\tDisplay._releaseLock()\n\t\t\n\t# make thread safe\n\t@staticmethod\n\tdef rotate(obj, angle):\n\t\tif angle == 0: return\n\t\t#print 'attempt rotate'\n\t\tDisplay._acquireLock()\n\t\t#print 'rotate'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.rotate_by(parts, angle)\n\t\tDisplay._releaseLock()\n\t\t\t\t\n\t@staticmethod\n\tdef _getBeliefSquareColor(color, value):\n\t\tvalue = min(1.0, value * 15)\n\t\tsaturation = value\n\t\thue = Display.COLOR_HUES[color]\n\t\tr, g, b = colorsys.hsv_to_rgb(hue, saturation, 1.0)\n\t\tcolor = graphicsUtils.formatColor(r, g, b)\n\t\treturn color\t\t\n\t\n\t@staticmethod\n\tdef _isVisible(value):\n\t\treturn value >= Display.VISIBLE_CUTTOFF\n\t\n\t@staticmethod\n\tdef _updateBeliefSquare(r, c, value, colorName):\n\t\tpart = Display.beliefParts[r][c]\n\t\tif part == None: return\n\t\toldValue = Display.beliefValue[r][c]\n\t\toldColor = Display.beliefColor[r][c]\n\t\twasVisible = Display._isVisible(oldValue)\n\t\tisVisible = Display._isVisible(value) \n\t\tif not isVisible: value = 0.0\n\t\tif oldColor != colorName and oldValue >= value: return\n\t\tif not isVisible and not wasVisible: return\n\t\tcolor = Display._getBeliefSquareColor(colorName, value)\n\t\tgraphicsUtils.changeColor(part, color)\n\t\tDisplay.beliefValue[r][c] = value\n\t\tDisplay.beliefColor[r][c] = colorName\n\t\t\n\t@staticmethod\n\tdef _acquireLock():\n\t\treturn\n\t\t#print 'acquire'\n\t\treturn Display.graphicsLock.acquire()\n\t\n\t@staticmethod\n\tdef _releaseLock():\n\t\treturn\n\t\t#print 'release'\n\t\treturn Display.graphicsLock.release()\n\t \n\t####################################\n\t# Depreicated\n\t####################################\n\t\t\n\t@staticmethod\n\tdef _remove(obj):\n\t\tparts = Display.partDict[obj]\n\t\tgraphicsUtils.remove_from_screen(parts);\n\t\t\n\t@staticmethod\n\tdef redrawObservations(observations):\n\t\traise Exception('depreicated')\n\t\tfor obs in Display.observations:\n\t\t\tDisplay._remove(obs)\n\t\tfor obs in observations:\n\t\t\tDisplay.drawObservation(obs)\n\t\tDisplay.observations = observations\n", "description": null, "category": "graphics", "imports": ["import graphicsUtils", "from engine.model.car.car import Car", "from engine.const import Const", "from engine.model.observation import Observation", "from engine.vector import Vec2d", "import colorsys", "import threading"]}], [{"term": "class", "name": "Display", "data": "class Display(object):\n\t\n\tWHITE = graphicsUtils.formatColor(1.0, 1.0, 1.0)\n\tRED = graphicsUtils.formatColor(1.0, 0.0, 0.0)\n\tGREEN = graphicsUtils.formatColor(0.16, 0.49, 0.31)\n\tBLUE = graphicsUtils.formatColor(0.0, 0.0, 1.0)\n\tBLACK = graphicsUtils.formatColor(0.0, 0.0, 0.0)\n\tGREY = graphicsUtils.formatColor(0.5, .5, 0.5)\n\t\n\tVISIBLE_CUTTOFF = 0.001\n\t\n\t\n\tpartDict = {}\n\tbeliefParts = []\n\tbeliefValue = []\n\tbeliefColor = []\n\tobservations = []\n\t\n\tgraphicsLock = threading.Lock()\n\t\n\tCOLORS = [\n\t\t'purple',\n\t\t'green',\n\t\t'teal',\n\t\t'red',\n\t\t'orange',\n\t\t'yellow'\n\t]\n\tCOLOR_HUES = {\n\t\t'purple' : 0.8,\n\t\t'green' : 0.3,\n\t\t'teal' : 0.49,\n\t\t'red' : 0.0,\n\t\t'orange' : 0.125,\n\t\t'yellow' : 0.21\n\t}\n\t\n\t@staticmethod\n\tdef initGraphics(layout):\n\t\tgraphicsUtils.begin_graphics(\n\t\t\twidth=layout.getWidth(), \n\t\t\theight=layout.getHeight(), \n\t\t\tcolor = Display.WHITE,\n\t\t\ttitle = Const.TITLE\n\t\t);\n\t\t\n\t@staticmethod\n\tdef endGraphics():\n\t\tgraphicsUtils.end_graphics()\n\n\t@staticmethod\n\tdef raiseEndGraphics():\n\t\tgraphicsUtils.raiseEndGraphics()\n\t\n\t@staticmethod\n\tdef drawCar(car):\n\t\tif car in Display.partDict:\n\t\t\tDisplay._remove(car)\n\t\tcolor = Display.GREY\n\t\tif car.isJunior():\n\t\t\tcolor = Display.BLACK\n\t\tparts = graphicsUtils.rectangle(\n\t\t\tcar.pos, Car.LENGTH, \n\t\t\tCar.WIDTH, \n\t\t\tcolor, \n\t\t\tcar.dir\n\t\t)\n\t\tDisplay.partDict[car] = parts\n\t\t\n\t@staticmethod\n\tdef drawObservation(obs):\n\t\tparts = Display.drawCircle(obs.pos, Observation.RADIUS)\n\t\tDisplay.partDict[obs] = parts\n\t\n\t@staticmethod\n\tdef drawSquare(pos, size, color):\n\t\treturn graphicsUtils.square(pos, size, color)\n\t\n\t@staticmethod\n\tdef drawFinish(block):\n\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.GREEN, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\n\t@staticmethod\n\tdef drawBlocks(blocks):\n\t\tfor block in blocks:\n\t\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.BLUE, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\t\n\t@staticmethod\n\tdef drawCircle(pos, radius):\n\t\treturn graphicsUtils.circle(pos, radius, Display.RED, Display.RED)\n\t\n\t@staticmethod\n\tdef drawBelief(model):\n\t\tDisplay.beliefVisible = []\n\t\tfor r in range(model.getBeliefRows()):\n\t\t\tbeliefValueRow = []\n\t\t\tbeliefPartRow = []\n\t\t\tbeliefColorRow = []\n\t\t\tfor c in range(model.getBeliefCols()):\n\t\t\t\tsquare = Display.drawBeliefSquare(r, c, 'purple', 0.0, model)\n\t\t\t\tbeliefPartRow.append(square)\n\t\t\t\tbeliefValueRow.append(0.0)\n\t\t\t\tbeliefColorRow.append(None)\n\t\t\tDisplay.beliefParts.append(beliefPartRow)\n\t\t\tDisplay.beliefValue.append(beliefValueRow)\n\t\t\tDisplay.beliefColor.append(beliefColorRow)\n\t\t\t\t\n\t@staticmethod\n\tdef drawBeliefSquare(row, col, color, value, model):\n\t\ttileSize = Const.BELIEF_TILE_SIZE\n\t\tx = col * tileSize + tileSize / 2.0\n\t\ty = row * tileSize + tileSize / 2.0\n\t\tif not model.inBounds(x, y): return None\n\t\tcolor = Display._getBeliefSquareColor(color, value)\n\t\treturn Display.drawSquare(Vec2d(x, y), tileSize, color)\n\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef getKeys():\n\t\t#print 'attempt get keys'\n\t\tDisplay._acquireLock()\n\t\t#print 'get keys'\n\t\tkeys = graphicsUtils.keys_waiting() + graphicsUtils.keys_pressed()\n\t\tDisplay._releaseLock()\n\t\treturn keys\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef graphicsSleep(timeToSleep):\n\t\tgraphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''for _ in range(int(timeToSleep / 0.005)):\n\t\t\t#print 'attempt sleep'\n\t\t\tDisplay._acquireLock()\n\t\t\t#print 'sleep'\n\t\t\tgraphicsUtils.sleep(0.001)\n\t\t\tDisplay._releaseLock()\n\t\t\ttime.sleep(0.004)'''\n\t\t\n\t\t#graphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''startWait = time.time()\n\t\tDisplay._acquireLock()\n\t\ttimeToSleep -= time.time() - startWait\n\t\tgraphicsUtils.refresh()\n\t\tif timeToSleep > 0:\n\t\t\tgraphicsUtils.sleep(timeToSleep)\n\t\tDisplay._releaseLock()'''\n\t\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef updateBelief(color, belief):\n\t\tDisplay._acquireLock()\n\t\ttotal = belief.getSum()\n\t\tif abs(total - 1.0) > 0.001:\n\t\t\traise Exception('belief does not sum to 1 ('+str(total)+'). Use the normalize method.')\n\t\tfor r in range(belief.getNumRows()):\n\t\t\tfor c in range(belief.getNumCols()):\n\t\t\t\tvalue = belief.getProb(r, c)\n\t\t\t\tDisplay._updateBeliefSquare(r, c, value, color)\n\t\tDisplay._releaseLock()\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef move(obj, delta):\n\t\t#print 'attempt move'\n\t\tDisplay._acquireLock()\n\t\t#print 'move'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.move_by(parts, delta.x, delta.y)\n\t\t#print 'end move'\n\t\tDisplay._releaseLock()\n\t\t\n\t# make thread safe\n\t@staticmethod\n\tdef rotate(obj, angle):\n\t\tif angle == 0: return\n\t\t#print 'attempt rotate'\n\t\tDisplay._acquireLock()\n\t\t#print 'rotate'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.rotate_by(parts, angle)\n\t\tDisplay._releaseLock()\n\t\t\t\t\n\t@staticmethod\n\tdef _getBeliefSquareColor(color, value):\n\t\tvalue = min(1.0, value * 15)\n\t\tsaturation = value\n\t\thue = Display.COLOR_HUES[color]\n\t\tr, g, b = colorsys.hsv_to_rgb(hue, saturation, 1.0)\n\t\tcolor = graphicsUtils.formatColor(r, g, b)\n\t\treturn color\t\t\n\t\n\t@staticmethod\n\tdef _isVisible(value):\n\t\treturn value >= Display.VISIBLE_CUTTOFF\n\t\n\t@staticmethod\n\tdef _updateBeliefSquare(r, c, value, colorName):\n\t\tpart = Display.beliefParts[r][c]\n\t\tif part == None: return\n\t\toldValue = Display.beliefValue[r][c]\n\t\toldColor = Display.beliefColor[r][c]\n\t\twasVisible = Display._isVisible(oldValue)\n\t\tisVisible = Display._isVisible(value) \n\t\tif not isVisible: value = 0.0\n\t\tif oldColor != colorName and oldValue >= value: return\n\t\tif not isVisible and not wasVisible: return\n\t\tcolor = Display._getBeliefSquareColor(colorName, value)\n\t\tgraphicsUtils.changeColor(part, color)\n\t\tDisplay.beliefValue[r][c] = value\n\t\tDisplay.beliefColor[r][c] = colorName\n\t\t\n\t@staticmethod\n\tdef _acquireLock():\n\t\treturn\n\t\t#print 'acquire'\n\t\treturn Display.graphicsLock.acquire()\n\t\n\t@staticmethod\n\tdef _releaseLock():\n\t\treturn\n\t\t#print 'release'\n\t\treturn Display.graphicsLock.release()\n\t \n\t####################################\n\t# Depreicated\n\t####################################\n\t\t\n\t@staticmethod\n\tdef _remove(obj):\n\t\tparts = Display.partDict[obj]\n\t\tgraphicsUtils.remove_from_screen(parts);\n\t\t\n\t@staticmethod\n\tdef redrawObservations(observations):\n\t\traise Exception('depreicated')\n\t\tfor obs in Display.observations:\n\t\t\tDisplay._remove(obs)\n\t\tfor obs in observations:\n\t\t\tDisplay.drawObservation(obs)\n\t\tDisplay.observations = observations\n", "description": null, "category": "graphics", "imports": ["import graphicsUtils", "from engine.model.car.car import Car", "from engine.const import Const", "from engine.model.observation import Observation", "from engine.vector import Vec2d", "import colorsys", "import threading"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tgraphics.window.add(score_label, 0, score_label.height+10)  # add the score in the window\n\tlives = NUM_LIVES\n\t# Add animation loop here!\n\tdx = graphics.get_dx()\n\tdy = graphics.get_dy()\n\twhile True:\n\t\tglobal score\n\t\tpause(FRAME_RATE)\n\t\t# find 4 coordinates around the ball\n\t\ta = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y)\n\t\tb = graphics.window.get_object_at(graphics.ball.x + graphics.ball_radius * 2, graphics.ball.y)\n\t\tc = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y + graphics.ball_radius * 2)\n\t\td = graphics.window.get_object_at(graphics.ball.x + graphics.ball_radius * 2, graphics.ball.y + graphics.ball_radius * 2)\n\t\tif dx == 0 and dy == 0:\n\t\t\tdx = graphics.get_dx()\n\t\t\tdy = graphics.get_dy()\n\t\t# move the ball\n\t\tgraphics.ball.move(dx, dy)\n\t\tif graphics.ball.x <= 0 or graphics.ball.x >= graphics.window.width - graphics.ball.width:\n\t\t\tdx = -dx\n\t\tif graphics.ball.y >= graphics.window.height:\n\t\t\tlives -= 1\n\t\t\tgraphics.zero()\t # if the ball falls under the window height, turn the velocity to 0\n\t\t\tdx = graphics.get_dx()\n\t\t\tdy = graphics.get_dy()\n\t\t\t# add the ball on the window again\n\t\t\tgraphics.window.add(graphics.ball, x=(graphics.window.width-graphics.ball_radius*2)/2, y=(graphics.window.height-graphics.ball_radius*2)/2)\n\t\tif graphics.ball.y <= 0:\n\t\t\tdy = -dy\n\n\t\tif a is not None and a is not score_label:\n\t\t\tif a == graphics.paddle:\n\t\t\t\tif dy > 0:\n\t\t\t\t\tdy = -dy\n\t\t\telse:\n\t\t\t\tdy = -dy\n\t\t\t\tgraphics.window.remove(a)\n\t\t\t\tscore += 1\n\t\t\t\tscore_label.text = 'Score: ' + str(score)\n\n\t\telif b is not None and b is not score_label:\n\t\t\tif b == graphics.paddle:\n\t\t\t\tif dy > 0:\n\t\t\t\t\tdy = -dy\n\t\t\telse:\n\t\t\t\tdy = -dy\n\t\t\t\tgraphics.window.remove(b)\n\t\t\t\tscore += 1\n\t\t\t\tscore_label.text = 'Score: ' + str(score)\n\t\telif c is not None and c is not score_label:\n\t\t\tif c == graphics.paddle:\n\t\t\t\tif dy > 0:\n\t\t\t\t\tdy = -dy\n\t\t\telse:\n\t\t\t\tdy = -dy\n\t\t\t\tgraphics.window.remove(c)\n\t\t\t\tscore += 1\n\t\t\t\tscore_label.text = 'Score: ' + str(score)\n\n\t\telif d is not None and c is not score_label:\n\t\t\tif d == graphics.paddle:\n\t\t\t\tif dy > 0:\n\t\t\t\t\tdx = dx\n\t\t\t\t\tdy = -dy\n\t\t\telse:\n\t\t\t\tdx = -dx\n\t\t\t\tdy = -dy\n\t\t\t\tgraphics.window.remove(d)\n\t\t\t\tscore += 1\n\t\t\t\tscore_label.text = 'Score: ' + str(score)\n\n\t\tif lives == 0:\n\t\t\tbreak\n\tlose_label = GLabel('You lost:( ')\n\tlose_label.font = '-40'\n\tgraphics.window.add(lose_label, 150, 500)\n\n\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.graphics.gobjects import GOval, GRect, GLabel"]}], [{"term": "def", "name": "savepicker", "data": "def savepicker():\r\n\tpat = os.listdir()\r\n\tfiles = []\r\n\tfor i in pat:\r\n\t\tif i.endswith(\".dat\"):\r\n\t\t  files.append(i)\r\n\t\t  \r\n\twhile True:\r\n\t\tgraphics.floppy()\r\n\t\tgraphics.print_centre(\"-- SAVE MANAGER --\")\r\n\t\tgraphics.print_centre(\"1: load save\")\r\n\t\tgraphics.print_centre(\" 2: list saves\")\r\n\t\tgraphics.print_centre(\"3: Exit Menu\")\r\n\t\tcho = input(\"Enter choice: \")\r\n\t\tgraphics.spacer()\r\n\t  \r\n\t\tif cho == '1':\r\n\t\t  filename = input(\"Enter save name: \")\r\n\t\t  filename = filename+'.dat'\r\n\t\t  if filename in files:\r\n\t\t\tprint(f\"Loading {filename}...\")\r\n\t\t\tsleep(1)\r\n\t\t\tload(filename)\r\n\t\t\tglobal key\r\n\t\t\tkey = 1\r\n\t\t\tbreak\r\n\t\t\t\r\n\t\t  else:\r\n\t\t\tprint(\"Invalid Save!\")\r\n\t\t\tsleep(1)\r\n\t\t\tgraphics.clrscrn()\r\n\t\t\t\r\n\t\telif cho == '2':\r\n\t\t  print('-- Save List --')\r\n\t\t  for i in files:\r\n\t\t\tprint(i[:-4:])\r\n\t\t  input(\"Press any key to go back to save menu!\")\r\n\t\t  graphics.clrscrn()\r\n\t\t  \r\n\t\telif cho == '3':\r\n\t\t  graphics.clrscrn()\r\n\t\t  break\r\n\r\n\t\telse:\r\n\t\t  print(\"Invalid Choice!\")\r\n\t\t  sleep(1)\r\n\t\t  graphics.clrscrn()\r\n", "description": null, "category": "graphics", "imports": ["import graphics\r", "import os\r", "from os.path import exists\r", "from random import choice\r", "from variables import load\r", "from time import sleep\r", "  import variables\r", "  import messages\r", "\t\tfrom grid import gridB,currentpos\r", "\t\tfrom grid import gridB,currentpos\r", "\t\timport variables\r", "\tfrom grid import gridB,currentpos\r"]}, {"term": "def", "name": "startmenu", "data": "def startmenu():\r\n\twhile True:\r\n\t  graphics.logo()\r\n\t  graphics.print_centre(\"|  1) New Game   |\")\r\n\t  graphics.print_centre(\"|  2) Load Game  |\")\r\n\t  graphics.print_centre(\"|  3) Quit Game  |\")\r\n\t  x=input(\": \")\r\n\t  if x=='1':\r\n\t\tgraphics.clrscrn()\r\n\t\tstory()\r\n\t\tcharpicker()\r\n\t\tgraphics.clrscrn()\r\n\t\tgraphics.dungeon()\r\n\t\tfrom grid import gridB,currentpos\r\n\t\tprint(gridB[currentpos['pos']])\r\n\t\tbreak\r\n\t\t\r\n\t  elif x=='2':\r\n\t\tgraphics.clrscrn()\r\n\t\tsavepicker()\r\n\t\tif key == 1:\r\n\t\t  break\r\n\r\n\t  elif x=='3':\r\n\t\tgraphics.clrscrn()\r\n\t\tos._exit(0)\r\n\t  else:\r\n\t\tgraphics.clrscrn()\r\n", "description": null, "category": "graphics", "imports": ["import graphics\r", "import os\r", "from os.path import exists\r", "from random import choice\r", "from variables import load\r", "from time import sleep\r", "  import variables\r", "  import messages\r", "\t\tfrom grid import gridB,currentpos\r", "\t\tfrom grid import gridB,currentpos\r", "\t\timport variables\r", "\tfrom grid import gridB,currentpos\r"]}, {"term": "def", "name": "pausemenu", "data": "def pausemenu():\r\n\twhile True:\r\n\t  graphics.logo()\r\n\t  x=input(\"-- PAUSE MENU --\\n\\n1) New Game\\n2) Load Game\\n3) Save Game\\n4) Back to Game\\n5) Quit Game\\n: \")\r\n\t  if x=='1':\r\n\t\tgraphics.clrscrn()\r\n\t\tstory()\r\n\t\tgraphics.clrscrn()\r\n\t\tgraphics.dungeon()\r\n\t\tfrom grid import gridB,currentpos\r\n\t\tprint(gridB[currentpos['pos']])\r\n\t\tbreak\r\n\t\t\r\n\t  elif x=='2':\r\n\t\tgraphics.clrscrn()\r\n\t\tsavepicker()\r\n\t\tif key == 1:\r\n\t\t  break\r\n\r\n\t  elif x=='5':\r\n\t\tgraphics.clrscrn()\r\n\t\tos._exit(0)\r\n\t  elif x=='4':\r\n\t\tbreak\r\n\t  elif x=='3':\r\n\t\timport variables\r\n\t\tvariables.save()\r\n\t\tsleep(1)\r\n\t\tgraphics.clrscrn()\r\n\t\t\r\n\t  else:\r\n\t\tprint(\"Invalid Choice!\")\r\n\t\tsleep(1)\r\n\t\tgraphics.clrscrn()\r\n", "description": null, "category": "graphics", "imports": ["import graphics\r", "import os\r", "from os.path import exists\r", "from random import choice\r", "from variables import load\r", "from time import sleep\r", "  import variables\r", "  import messages\r", "\t\tfrom grid import gridB,currentpos\r", "\t\tfrom grid import gridB,currentpos\r", "\t\timport variables\r", "\tfrom grid import gridB,currentpos\r"]}, {"term": "def", "name": "startsequence", "data": "def startsequence():\r\n\tgraphics.logo()\r\n\tprint()\r\n\tgraphics.print_centre(\"Credits: Scottminer22 Gaming#2306\")\r\n\tgraphics.print_centre(\"Press any key to start!\")\r\n\tinput()\r\n\tgraphics.clrscrn()\r\n\tstartmenu()\r\n\tgraphics.clrscrn()\r\n\tgraphics.dungeon()\r\n\tfrom grid import gridB,currentpos\r\n\tprint(\"\\nCurrent Position:\\n\")\r\n\tprint(gridB[currentpos['pos']])\r\n\t\t\r\n\r\n", "description": null, "category": "graphics", "imports": ["import graphics\r", "import os\r", "from os.path import exists\r", "from random import choice\r", "from variables import load\r", "from time import sleep\r", "  import variables\r", "  import messages\r", "\t\tfrom grid import gridB,currentpos\r", "\t\tfrom grid import gridB,currentpos\r", "\t\timport variables\r", "\tfrom grid import gridB,currentpos\r"]}], [], [{"term": "class", "name": "classAnimationPlayer:", "data": "class AnimationPlayer:\n\tdef __init__(self):\n\t\tself.frames = {\n\t\t\t# magic\n\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\n\t\t\t'aura': import_folder('../graphics/particles/aura'),\n\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\n\t\t\t'smoke': import_folder('../graphics/particles/smoke'),\n\t\t\t\n\t\t\t# attacks \n\t\t\t'claw': import_folder('../graphics/particles/claw'),\n\t\t\t'slash': import_folder('../graphics/particles/slash'),\n\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\n\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\n\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\n\n\t\t\t# monster deaths\n\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\n\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\n\t\t\t'spirit': import_folder('../graphics/particles/nova'),\n\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\n\t\t\t\n\t\t\t# leafs \n\t\t\t'leaf': (\n\t\t\t\timport_folder('../graphics/particles/leaf1'),\n\t\t\t\timport_folder('../graphics/particles/leaf2'),\n\t\t\t\timport_folder('../graphics/particles/leaf3'),\n\t\t\t\timport_folder('../graphics/particles/leaf4'),\n\t\t\t\timport_folder('../graphics/particles/leaf5'),\n\t\t\t\timport_folder('../graphics/particles/leaf6'),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\n\t\t\t\t)\n\t\t\t}\n\n\tdef reflect_images(self,frames):\n\t\tnew_frames = []\n\n\t\tfor frame in frames:\n\t\t\tflipped_frame = pygame.transform.flip(frame, True, False)\n\t\t\tnew_frames.append(flipped_frame)\n\t\treturn new_frames\n\n\tdef create_grass_particle(self, pos, groups):\n\t\tanimation_frames = choice(self.frames['leaf'])\n\t\tParticleEffect(pos, animation_frames, groups)\n\n\tdef generate_particle(self, pos, groups, attack_type):\n\t\tanimation_frames = self.frames[attack_type]\n\t\tParticleEffect(pos, animation_frames, groups)\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import *", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'smoke': import_folder('../graphics/particles/smoke'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\n\tdef __init__(self, pos, anim_frames, groups):\n\t\tsuper().__init__(groups)\n\t\tself.sprite_type = 'particle'\n\t\tself.frame_indx = 0\n\t\tself.anim_speed = 0.15\n\t\tself.frames = anim_frames\n\t\tself.image = self.frames[self.frame_indx]\n\t\tself.rect = self.image.get_rect(center = pos)\n\n\tdef animate(self):\n\t\tself.frame_indx += self.anim_speed\n\t\tif self.frame_indx >= len(self.frames):\n\t\t\tself.kill()\n\t\telse:\n\t\t\tself.image = self.frames[int(self.frame_indx)]\n\n\tdef update(self):\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import *", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'smoke': import_folder('../graphics/particles/smoke'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}], [{"term": "def", "name": "darken", "data": "def darken(color, factor=0.7):\n\t\"\"\"Returns darkened color as a ReportLab RGB color.\n\n\tTake a passed color and returns a Reportlab color that is darker by the\n\tfactor indicated in the parameter.\n\t\"\"\"\n\tnewcol = color_to_reportlab(color)\n\tfor a in ['red', 'green', 'blue']:\n\t\tsetattr(newcol, a, factor * getattr(newcol, a))\n\treturn newcol\n\n", "description": "Returns darkened color as a ReportLab RGB color.\n\n\tTake a passed color and returns a Reportlab color that is darker by the\n\tfactor indicated in the parameter.\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "from reportlab.lib import colors", "from reportlab.pdfgen import canvas", "from PIL import Image", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "def", "name": "color_to_reportlab", "data": "def color_to_reportlab(color):\n\t\"\"\"Returns the passed color in Reportlab Color format.\n\n\tWe allow colors to be specified as hex values, tuples, or Reportlab Color\n\tobjects, and with or without an alpha channel. This function acts as a\n\tRosetta stone for conversion of those formats to a Reportlab Color\n\tobject, with alpha value.\n\n\tAny other color specification is returned directly\n\t\"\"\"\n\t# Reportlab Color objects are in the format we want already\n\tif isinstance(color, colors.Color):\n\t\treturn color\n\telif isinstance(color, str):  # String implies hex color\n\t\tif color.startswith(\"0x\"):  # Standardise to octothorpe\n\t\t\tcolor.replace(\"0x\", \"#\")\n\t\tif len(color) == 7:\n\t\t\treturn colors.HexColor(color)\n\t\telse:\n\t\t\ttry:\n\t\t\t\treturn colors.HexColor(color, hasAlpha=True)\n\t\t\texcept TypeError:  # Catch pre-2.7 Reportlab\n\t\t\t\traise RuntimeError(\"Your reportlab seems to be too old, try 2.7 onwards\")\n\telif isinstance(color, tuple):  # Tuple implies RGB(alpha) tuple\n\t\treturn colors.Color(*color)\n\treturn color\n\n", "description": "Returns the passed color in Reportlab Color format.\n\n\tWe allow colors to be specified as hex values, tuples, or Reportlab Color\n\tobjects, and with or without an alpha channel. This function acts as a\n\tRosetta stone for conversion of those formats to a Reportlab Color\n\tobject, with alpha value.\n\n\tAny other color specification is returned directly\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "from reportlab.lib import colors", "from reportlab.pdfgen import canvas", "from PIL import Image", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "def", "name": "get_temp_imagefilename", "data": "def get_temp_imagefilename(url):\n\t\"\"\"Returns filename of temporary file containing downloaded image.\n\n\tCreate a new temporary file to hold the image file at the passed URL\n\tand return the filename.\n\t\"\"\"\n\timg = _urlopen(url).read()\n\tim = Image.open(BytesIO(img))\n\t# im.transpose(Image.FLIP_TOP_BOTTOM)\n\tf = tempfile.NamedTemporaryFile(delete=False, suffix='.png')\n\tfname = f.name\n\tf.close()\n\tim.save(fname, 'PNG')\n\treturn fname\n\n", "description": "Returns filename of temporary file containing downloaded image.\n\n\tCreate a new temporary file to hold the image file at the passed URL\n\tand return the filename.\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "from reportlab.lib import colors", "from reportlab.pdfgen import canvas", "from PIL import Image", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "class", "name": "KGMLCanvas", "data": "class KGMLCanvas(object):\n\t\"\"\"Reportlab Canvas-based representation of a KGML pathway map.\"\"\"\n\n\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,\n\t\t\t\t label_orthologs=True, label_reaction_entries=True,\n\t\t\t\t label_maps=True, show_maps=False, fontname='Helvetica',\n\t\t\t\t fontsize=6, draw_relations=True, show_orthologs=True,\n\t\t\t\t show_compounds=True, show_genes=True,\n\t\t\t\t show_reaction_entries=True, margins=(0.02, 0.02)):\n\t\tself.pathway = pathway\n\t\tself.show_maps = show_maps\n\t\tself.show_orthologs = show_orthologs\n\t\tself.show_compounds = show_compounds\n\t\tself.show_genes = show_genes\n\t\tself.show_reaction_entries = show_reaction_entries\n\t\tself.label_compounds = label_compounds\n\t\tself.label_orthologs = label_orthologs\n\t\tself.label_reaction_entries = label_reaction_entries\n\t\tself.label_maps = label_maps\n\t\tself.fontname = fontname\n\t\tself.fontsize = fontsize\n\t\tself.draw_relations = draw_relations\n\t\tself.non_reactant_transparency = 0.3\n\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL\n\t\t# percentage of canvas that will be margin in on either side in the\n\t\t# X and Y directions\n\t\tself.margins = margins\n\n\tdef draw(self, filename):\n\t\t\"\"\"Add the map elements to the drawing.\"\"\"\n\t\t# Instantiate the drawing, first\n\t\t# size x_max, y_max for now - we can add margins, later\n\t\tif self.import_imagemap:\n\t\t\t# We're drawing directly on the image, so we set the canvas to the\n\t\t\t# same size as the image\n\t\t\tif os.path.isfile(self.pathway.image):\n\t\t\t\timfilename = self.pathway.image\n\t\t\telse:\n\t\t\t\timfilename = get_temp_imagefilename(self.pathway.image)\n\t\t\tim = Image.open(imfilename)\n\t\t\tcwidth, cheight = im.size\n\t\telse:\n\t\t\t# No image, so we set the canvas size to accommodate visible\n\t\t\t# elements\n\t\t\tcwidth, cheight = (self.pathway.bounds[1][0],\n\t\t\t\t\t\t\t   self.pathway.bounds[1][1])\n\t\t# Instantiate canvas\n\t\tself.drawing = \\\n\t\t\tcanvas.Canvas(filename, bottomup=0,\n\t\t\t\t\t\t  pagesize=(cwidth *\n\t\t\t\t\t\t\t\t\t\t(1 + 2 * self.margins[0]),\n\t\t\t\t\t\t\t\t\tcheight *\n\t\t\t\t\t\t\t\t\t\t(1 + 2 * self.margins[1])))\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\t\t# Transform the canvas to add the margins\n\t\tself.drawing.translate(self.margins[0] * self.pathway.bounds[1][0],\n\t\t\t\t\t\t\t   self.margins[1] * self.pathway.bounds[1][1])\n\t\t# Add the map image, if required\n\t\tif self.import_imagemap:\n\t\t\tself.drawing.saveState()\n\t\t\tself.drawing.scale(1, -1)\n\t\t\tself.drawing.translate(0, -cheight)\n\t\t\tself.drawing.drawImage(imfilename, 0, 0)\n\t\t\tself.drawing.restoreState()\n\t\t# Add the reactions, compounds and maps\n\t\t# Maps go on first, to be overlaid by more information.\n\t\t# By default, they're slightly transparent.\n\t\tif self.show_maps:\n\t\t\tself.__add_maps()\n\t\tif self.show_reaction_entries:\n\t\t\tself.__add_reaction_entries()\n\t\tif self.show_orthologs:\n\t\t\tself.__add_orthologs()\n\t\tif self.show_compounds:\n\t\t\tself.__add_compounds()\n\t\tif self.show_genes:\n\t\t\tself.__add_genes()\n\t\t# TODO: complete draw_relations code\n\t\t# if self.draw_relations:\n\t\t#\tself.__add_relations()\n\t\t# Write the pathway map to PDF\n\t\tself.drawing.save()\n\n\tdef __add_maps(self):\n\t\t\"\"\"Adds maps to the drawing of the map.\n\n\t\tWe do this first, as they're regional labels to be overlaid by\n\t\tinformation.  Also, we want to set the color to something subtle.\n\n\t\tWe're using Hex colors because that's what KGML uses, and\n\t\tReportlab doesn't mind.\n\t\t\"\"\"\n\t\tfor m in self.pathway.maps:\n\t\t\tfor g in m.graphics:\n\t\t\t\tself.drawing.setStrokeColor('#888888')\n\t\t\t\tself.drawing.setFillColor('#DDDDDD')\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_maps:\n\t\t\t\t\tself.drawing.setFillColor('#888888')\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_graphics(self, graphics):\n\t\t\"\"\"Adds the passed graphics object to the map.\n\n\t\tAdd text, add after the graphics object, for sane Z-ordering.\n\t\t\"\"\"\n\t\tif graphics.type == 'line':\n\t\t\tp = self.drawing.beginPath()\n\t\t\tx, y = graphics.coords[0]\n\t\t\t# There are optional settings for lines that aren't necessarily\n\t\t\t# part of the KGML DTD\n\t\t\tif graphics.width is not None:\n\t\t\t\tself.drawing.setLineWidth(graphics.width)\n\t\t\telse:\n\t\t\t\tself.drawing.setLineWidth(1)\n\t\t\tp.moveTo(x, y)\n\t\t\tfor (x, y) in graphics.coords:\n\t\t\t\tp.lineTo(x, y)\n\t\t\tself.drawing.drawPath(p)\n\t\t\tself.drawing.setLineWidth(1)\t\t# Return to default\n\t\t# KGML defines the (x, y) coordinates as the centre of the circle/\n\t\t# rectangle/roundrectangle, but Reportlab uses the co-ordinates of the\n\t\t# lower-left corner for rectangle/elif.\n\t\tif graphics.type == 'circle':\n\t\t\tself.drawing.circle(graphics.x, graphics.y, graphics.width * 0.5,\n\t\t\t\t\t\t\t\tstroke=1, fill=1)\n\t\telif graphics.type == 'roundrectangle':\n\t\t\tself.drawing.roundRect(graphics.x - graphics.width * 0.5,\n\t\t\t\t\t\t\t\t   graphics.y - graphics.height * 0.5,\n\t\t\t\t\t\t\t\t   graphics.width, graphics.height,\n\t\t\t\t\t\t\t\t   min(graphics.width, graphics.height) * 0.1,\n\t\t\t\t\t\t\t\t   stroke=1, fill=1)\n\t\telif graphics.type == 'rectangle':\n\t\t\tself.drawing.rect(graphics.x - graphics.width * 0.5,\n\t\t\t\t\t\t\t  graphics.y - graphics.height * 0.5,\n\t\t\t\t\t\t\t  graphics.width, graphics.height,\n\t\t\t\t\t\t\t  stroke=1, fill=1)\n\n\tdef __add_labels(self, graphics):\n\t\t\"\"\"Adds labels for the passed graphics objects to the map (PRIVATE).\n\n\t\tWe don't check that the labels fit inside objects such as circles/\n\t\trectangles/roundrectangles.\n\t\t\"\"\"\n\t\tif graphics.type == 'line':\n\t\t\t# We use the midpoint of the line - sort of - we take the median\n\t\t\t# line segment (list-wise, not in terms of length), and use the\n\t\t\t# midpoint of that line.  We could have other options here,\n\t\t\t# maybe even parameterising it to a proportion of the total line\n\t\t\t# length.\n\t\t\tmid_idx = len(graphics.coords) * 0.5\n\t\t\tif not int(mid_idx) == mid_idx:\n\t\t\t\tidx1, idx2 = int(mid_idx - 0.5), int(mid_idx + 0.5)\n\t\t\telse:\n\t\t\t\tidx1, idx2 = int(mid_idx - 1), int(mid_idx)\n\t\t\tx1, y1 = graphics.coords[idx1]\n\t\t\tx2, y2 = graphics.coords[idx2]\n\t\t\tx, y = 0.5 * (x1 + x2), 0.5 * (y1 + y2)\n\t\telif graphics.type == 'circle':\n\t\t\tx, y = graphics.x, graphics.y\n\t\telif graphics.type in ('rectangle', 'roundrectangle'):\n\t\t\tx, y = graphics.x, graphics.y\n\t\t# How big so we want the text, and how many characters?\n\t\tif graphics._parent.type == 'map':\n\t\t\ttext = graphics.name\n\t\t\tself.drawing.setFont(self.fontname, self.fontsize + 2)\n\t\telif len(graphics.name) < 15:\n\t\t\ttext = graphics.name\n\t\telse:\n\t\t\ttext = graphics.name[:12] + '...'\n\t\tself.drawing.drawCentredString(x, y, text)\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\n\tdef __add_orthologs(self):\n\t\t\"\"\"Adds 'ortholog' Entry elements to the drawing of the map (PRIVATE).\n\n\t\tIn KGML, these are typically line objects, so we render them\n\t\tbefore the compound circles to cover the unsightly ends/junctions.\n\t\t\"\"\"\n\t\tfor ortholog in self.pathway.orthologs:\n\t\t\tfor g in ortholog.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_orthologs:\n\t\t\t\t\t# We want the label color to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_reaction_entries(self):\n\t\t\"\"\"Adds Entry elements for Reactions to the map drawing (PRIVATE).\n\n\t\tIn KGML, these are typically line objects, so we render them\n\t\tbefore the compound circles to cover the unsightly ends/junctions\n\t\t\"\"\"\n\t\tfor reaction in self.pathway.reaction_entries:\n\t\t\tfor g in reaction.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_reaction_entries:\n\t\t\t\t\t# We want the label color to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_compounds(self):\n\t\t\"\"\"Adds compound elements to the drawing of the map (PRIVATE).\"\"\"\n\t\tfor compound in self.pathway.compounds:\n\t\t\tfor g in compound.graphics:\n\t\t\t\t# Modify transparency of compounds that don't participate\n\t\t\t\t# in reactions\n\t\t\t\tfillcolor = color_to_reportlab(g.bgcolor)\n\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\tfillcolor.alpha *= self.non_reactant_transparency\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(fillcolor)\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\t\tt = 0.3\n\t\t\t\t\telse:\n\t\t\t\t\t\tt = 1\n\t\t\t\t\tself.drawing.setFillColor(colors.Color(0.2, 0.2, 0.2, t))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_genes(self):\n\t\t\"\"\"Adds gene elements to the drawing of the map (PRIVATE).\"\"\"\n\t\tfor gene in self.pathway.genes:\n\t\t\tfor g in gene.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_relations(self):\n\t\t\"\"\"Adds relations to the map (PRIVATE).\n\n\t\tThis is tricky. There is no defined graphic in KGML for a\n\t\trelation, and the corresponding entries are typically defined\n\t\tas objects 'to be connected somehow'.  KEGG uses KegSketch, which\n\t\tis not public, and most third-party software draws straight line\n\t\tarrows, with heads to indicate the appropriate direction\n\t\t(at both ends for reversible reactions), using solid lines for\n\t\tECrel relation types, and dashed lines for maplink relation types.\n\n\t\tThe relation has:\n\t\t- entry1: 'from' node\n\t\t- entry2: 'to' node\n\t\t- subtype: what the relation refers to\n\n\t\tTypically we have entry1 = map/ortholog; entry2 = map/ortholog,\n\t\tsubtype = compound.\n\t\t\"\"\"\n\t\t# Dashed lines for maplinks, solid for everything else\n\t\tfor relation in list(self.pathway.relations):\n\t\t\tif relation.type == 'maplink':\n\t\t\t\tself.drawing.setDash(6, 3)\n\t\t\telse:\n\t\t\t\tself.drawing.setDash()\n\t\t\tfor s in relation.subtypes:\n\t\t\t\tsubtype = self.pathway.entries[s[1]]\n\t\t\t\t# Our aim is to draw an arrow from the entry1 object to the\n\t\t\t\t# entry2 object, via the subtype object.\n\t\t\t\t# 1) Entry 1 to subtype\n\t\t\t\tself.__draw_arrow(relation.entry1, subtype)\n\t\t\t\t# 2) subtype to Entry 2\n\t\t\t\tself.__draw_arrow(subtype, relation.entry2)\n\n\tdef __draw_arrow(self, g_from, g_to):\n\t\t\"\"\"Draw an arrow between given Entry objects (PRIVATE).\n\n\t\tDraws an arrow from the g_from Entry object to the g_to\n\t\tEntry object; both must have Graphics objects.\n\t\t\"\"\"\n\t\t# Centre and bound co-ordinates for the from and two objects\n\t\tbounds_from, bounds_to = g_from.bounds, g_to.bounds\n\t\tcentre_from = (0.5 * (bounds_from[0][0] + bounds_from[1][0]),\n\t\t\t\t\t   0.5 * (bounds_from[0][1] + bounds_from[1][1]))\n\t\tcentre_to = (0.5 * (bounds_to[0][0] + bounds_to[1][0]),\n\t\t\t\t\t 0.5 * (bounds_to[0][1] + bounds_to[1][1]))\n\t\tp = self.drawing.beginPath()\n\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t# If the 'from' and 'to' graphics are vertically-aligned, draw a line\n\t\t# from the 'from' to the 'to' entity\n\t\tif bounds_to[0][0] < centre_from[0] < bounds_to[1][0]:\n\t\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t\tif centre_to[1] > centre_from[1]:  # to above from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\t\telse:\t\t\t\t\t\t\t # to below from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\telif bounds_from[0][0] < centre_to[0] < bounds_from[1][0]:\n\t\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t\tif centre_to[1] > centre_from[1]:  # to above from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\t\telse:\t\t\t\t\t\t\t # to below from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\tself.drawing.drawPath(p)\t# Draw arrow shaft\n\t\t# print(g_from)\n\t\t# print(bounds_from)\n\t\t# print(g_to)\n\t\t# print(bounds_to)\n", "description": "Reportlab Canvas-based representation of a KGML pathway map.", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "from reportlab.lib import colors", "from reportlab.pdfgen import canvas", "from PIL import Image", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}], [{"term": "class", "name": "CGAffineTransform", "data": "class CGAffineTransform(Structure):\n\t_fields_ = [\n\t\t(\"a\", CGFloat),\n\t\t(\"b\", CGFloat),\n\t\t(\"c\", CGFloat),\n\t\t(\"d\", CGFloat),\n\t\t(\"tx\", CGFloat),\n\t\t(\"ty\", CGFloat),\n\t]\n\n", "description": null, "category": "graphics", "imports": ["from ctypes import (", "from rubicon.objc import CGFloat, CGPoint, CGRect, CGSize", "from rubicon.objc.types import register_preferred_encoding"]}, {"term": "class", "name": "CGRectMake", "data": "class CGRectMake(Structure):\n\t_fields_ = [\n\t\t(\"origin\", CGPoint),\n\t\t(\"size\", CGSize),\n\t]\n", "description": null, "category": "graphics", "imports": ["from ctypes import (", "from rubicon.objc import CGFloat, CGPoint, CGRect, CGSize", "from rubicon.objc.types import register_preferred_encoding"]}], [{"term": "class", "name": "CGAffineTransform", "data": "class CGAffineTransform(Structure):\n\t_fields_ = [\n\t\t(\"a\", CGFloat),\n\t\t(\"b\", CGFloat),\n\t\t(\"c\", CGFloat),\n\t\t(\"d\", CGFloat),\n\t\t(\"tx\", CGFloat),\n\t\t(\"ty\", CGFloat),\n\t]\n\n", "description": null, "category": "graphics", "imports": ["from ctypes import (", "from rubicon.objc import CGFloat, CGRect", "from rubicon.objc.types import register_preferred_encoding", "from rubicon.objc.runtime import load_library"]}, {"term": "class", "name": "CGEventRef", "data": "class CGEventRef(c_void_p):\n\tpass\n\n", "description": null, "category": "graphics", "imports": ["from ctypes import (", "from rubicon.objc import CGFloat, CGRect", "from rubicon.objc.types import register_preferred_encoding", "from rubicon.objc.runtime import load_library"]}], [{"term": "def", "name": "main", "data": "def main():\n\t# graphics = BreakoutGraphics()\n\t# Add animation loop here!\n\tonmousemoved(moving_paddle)\n\tonmouseclicked(moving_ball)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.gui.events.mouse import onmousemoved, onmouseclicked"]}, {"term": "def", "name": "moving_paddle", "data": "def moving_paddle(e):\n\tgraphics.paddle.x = e.x - graphics.paddle.width/2\n\tgraphics.paddle.y = graphics.window_height - graphics.paddle_offset\n\t# set the zone that paddle can move.\n\tif graphics.paddle.x >= graphics.window.width - graphics.paddle.width:\n\t\tgraphics.paddle.x = graphics.window.width - graphics.paddle.width\n\telif graphics.paddle.x < 0:\n\t\tgraphics.paddle.x = 0\n\telse:\n\t\tpass\n\tpause(FRAME_RATE)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.gui.events.mouse import onmousemoved, onmouseclicked"]}, {"term": "def", "name": "moving_ball", "data": "def moving_ball(e):\n\tglobal NUM_LIVES\n\tglobal NUM_CLICKS\n\tNUM_CLICKS += 1\n\tgame_on = NUM_CLICKS == GAME_START\n\t# start the game\n\twhile game_on and NUM_LIVES > 0:\n\t\t# If the ball fall out from the screen bottom, we should discount player's lives one time.\n\t\tif graphics.ball.y >= graphics.window_height - graphics.ball_radius:\n\t\t\tNUM_LIVES -= 1\n\t\t\tgraphics.window.remove(graphics.ball)\n\t\t\t# If player's lives are more than 0, player can gain one ball and continue the game.\n\t\t\tif NUM_LIVES > 0:\n\t\t\t\tNUM_CLICKS -= 1\n\t\t\t\tgraphics.prepare_ball()\n\t\t\t\tgraphics.move_ball_random()\n\t\t\t\tbreak\n\t\t\t# If player's lives are no more than 0, player can not gain any ball.\n\t\t\telse:\n\t\t\t\tbreak\n\t\tgraphics.move_ball()\n\t\tgraphics.handle_wall_collisions()\n\t\tgraphics.ball_check()\n\t\tpause(FRAME_RATE)\n\t\tif graphics.win() is True:\n\t\t\tbreak\n\t\tif NUM_LIVES == 0:\n\t\t\tbreak\n\t# When game is started, any clicks cannot influence the ball and the whole game.\n\tif game_on is not True and NUM_LIVES > 0:\n\t\tNUM_CLICKS -= 1\n\t\tgraphics.move_ball()\n\t\tgraphics.handle_wall_collisions()\n\t\tgraphics.ball_check()\n\t\tpause(FRAME_RATE)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.gui.events.mouse import onmousemoved, onmouseclicked"]}], [{"term": "def", "name": "main", "data": "def main():\n\t\"\"\"\n\tThis function controls the animation of the game.\n\t:param graphics, is the object from the class BreakoutGraphics\n\t:param lives, how many more times can try\n\t\"\"\"\n\tgraphics = BreakoutGraphics()\n\tlives = NUM_LIVES\n\tgraphics.chances(lives)\n\tfor i in range(NUM_LIVES):\n\t\tdx = graphics.get_dx()\n\t\tdy = graphics.get_dy()\n\t\twhile True:\n\t\t\tpause(FRAME_RATE)\n\t\t\tif graphics.start == 1:  # game start\n\t\t\t\tif 0 >= graphics.ball.x + dx or graphics.ball.x + dx >= graphics.window_width - 2 * graphics.ball_radius:\n\t\t\t\t\t# bump into the left or right boundary of the window\n\t\t\t\t\tdx = -dx\n\t\t\t\tif 0 >= graphics.ball.y + dy:  # bump into the upper window\n\t\t\t\t\tdy = -dy\n\t\t\t\tgraphics.ball.move(dx, dy)  # move the ball\n\t\t\t\tif graphics.check_collisions():  # Check whether the ball bump into any thing\n\t\t\t\t\tdy = -dy\n\t\t\t\tif graphics.ball.y + dy >= graphics.window_height:  # The ball is out of window\n\t\t\t\t\tgraphics.remove_ball()\n\t\t\t\t\tgraphics.create_ball()\n\t\t\t\t\tgraphics.set_ball_init_velo()\n\t\t\t\t\tgraphics.start = 0\n\t\t\t\t\tlives -= 1\n\t\t\t\t\tgraphics.chances(lives)\n\t\t\t\t\tbreak\n\t\t\t\tif graphics.bricks_left == 0:\n\t\t\t\t\tbreak\n\t\tif lives == 0:  # lose\n\t\t\tgraphics.start = 0\n\t\t\tgraphics.remove_ball()\n\t\t\tgraphics.remove_paddle()\n\t\t\tgraphics.remove_chances()\n\t\t\tgraphics.you_lose()\n\t\t\tbreak\n\t\tif graphics.bricks_left == 0:  # win\n\t\t\tgraphics.remove_ball()\n\t\t\tgraphics.remove_paddle()\n\t\t\tgraphics.start = 0\n\t\t\tgraphics.you_win()\n\t\t\tbreak\n\n\n", "description": "\n\tThis function controls the animation of the game.\n\t:param graphics, is the object from the class BreakoutGraphics\n\t:param lives, how many more times can try\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "def", "name": "write", "data": "def write(font, message, x_pos, y_pos):\n\tmy_font = fonts[font]\n\tmessage = str.lower(message)\n\tif len(message) > 0:\n\t\tfor i in range(len(message)):\n\t\t\tif message[i] != ' ':\n\t\t\t\tletter_image = my_font[message[i]]\n\t\t\t\tpos_y = y_pos - my_font[size_y]/2\n\t\t\t\tpos_x = (i-(len(message)/2))*(my_font[size_x]+5) + x_pos\n\t\t\t\tconstants.screen.blit(letter_image, (pos_x, pos_y))\n\n", "description": null, "category": "graphics", "imports": ["import pygame as py", "import constants"]}, {"term": "def", "name": "write_from_left", "data": "def write_from_left(font, message, x_pos, y_pos):\n\tmy_font = fonts[font]\n\tmessage = str.lower(message)\n\tif len(message) > 0:\n\t\tfor i in range(len(message)):\n\t\t\tif message[i] != ' ':\n\t\t\t\tletter_image = my_font[message[i]]\n\t\t\t\tpos_y = y_pos - my_font[size_y]/2\n\t\t\t\tpos_x = i*(my_font[size_x]+20) + x_pos\n\t\t\t\tconstants.screen.blit(letter_image, (pos_x, pos_y))\n", "description": null, "category": "graphics", "imports": ["import pygame as py", "import constants"]}], [], [{"term": "class", "name": "VMTemplateTests", "data": "class VMTemplateTests(unittest.TestCase):\n\tdef setUp(self):\n\t\tself.iso = '/tmp/mock.iso'\n\t\topen(self.iso, 'w').close()\n\n\tdef tearDown(self):\n\t\tos.unlink(self.iso)\n\n\tdef test_minimal_construct(self):\n\t\tfields = (('name', 'test'), ('os_distro', 'unknown'),\n\t\t\t\t  ('os_version', 'unknown'), ('cpus', 1),\n\t\t\t\t  ('memory', 1024), ('networks', ['default']),\n\t\t\t\t  ('disk_bus', 'ide'), ('nic_model', 'e1000'),\n\t\t\t\t  ('graphics', {'type': 'vnc', 'listen': '127.0.0.1'}),\n\t\t\t\t  ('cdrom', self.iso))\n\n\t\targs = {'name': 'test', 'cdrom': self.iso}\n\t\tt = VMTemplate(args)\n\t\tfor name, val in fields:\n\t\t\tself.assertEquals(val, t.info.get(name))\n\n\tdef test_construct_overrides(self):\n\t\tgraphics = {'type': 'spice', 'listen': '127.0.0.1'}\n\t\targs = {'name': 'test', 'disks': [{'size': 10}, {'size': 20}],\n\t\t\t\t'graphics': graphics, \"cdrom\": self.iso}\n\t\tt = VMTemplate(args)\n\t\tself.assertEquals(2, len(t.info['disks']))\n\t\tself.assertEquals(graphics, t.info['graphics'])\n\n\tdef test_specified_graphics(self):\n\t\t# Test specified listen\n\t\tgraphics = {'type': 'vnc', 'listen': '127.0.0.1'}\n\t\targs = {'name': 'test', 'disks': [{'size': 10}, {'size': 20}],\n\t\t\t\t'graphics': graphics, 'cdrom': self.iso}\n\t\tt = VMTemplate(args)\n\t\tself.assertEquals(graphics, t.info['graphics'])\n\n\t\t# Test specified type\n\t\tgraphics = {'type': 'spice', 'listen': '127.0.0.1'}\n\t\targs['graphics'] = graphics\n\t\tt = VMTemplate(args)\n\t\tself.assertEquals(graphics, t.info['graphics'])\n\n\t\t# If no listen specified, test the default listen\n\t\tgraphics = {'type': 'vnc'}\n\t\targs['graphics'] = graphics\n\t\tt = VMTemplate(args)\n\t\tself.assertEquals(graphics['type'], t.info['graphics']['type'])\n\t\tself.assertEquals('127.0.0.1', t.info['graphics']['listen'])\n\n\tdef test_to_xml(self):\n\t\tgraphics = {'type': 'spice', 'listen': '127.0.0.1'}\n\t\tvm_uuid = str(uuid.uuid4()).replace('-', '')\n\t\tt = VMTemplate({'name': 'test-template', 'cdrom': self.iso})\n\t\txml = t.to_vm_xml('test-vm', vm_uuid, graphics=graphics)\n\t\tself.assertEquals(vm_uuid, xpath_get_text(xml, \"/domain/uuid\")[0])\n\t\tself.assertEquals('test-vm', xpath_get_text(xml, \"/domain/name\")[0])\n\t\texpr = \"/domain/devices/graphics/@type\"\n\t\tself.assertEquals(graphics['type'], xpath_get_text(xml, expr)[0])\n\t\texpr = \"/domain/devices/graphics/@listen\"\n\t\tself.assertEquals(graphics['listen'], xpath_get_text(xml, expr)[0])\n\n\tdef test_arg_merging(self):\n\t\t\"\"\"\n\t\tMake sure that default parameters from osinfo do not override user-\n\t\tprovided parameters.\n\t\t\"\"\"\n\t\tgraphics = {'type': 'vnc', 'listen': '127.0.0.1'}\n\t\targs = {'name': 'test', 'os_distro': 'opensuse', 'os_version': '12.3',\n\t\t\t\t'cpus': 2, 'memory': 2048, 'networks': ['foo'],\n\t\t\t\t'cdrom': self.iso, 'graphics': graphics}\n\t\tt = VMTemplate(args)\n\t\tself.assertEquals(2, t.info.get('cpus'))\n\t\tself.assertEquals(2048, t.info.get('memory'))\n\t\tself.assertEquals(['foo'], t.info.get('networks'))\n\t\tself.assertEquals(self.iso, t.info.get('cdrom'))\n\t\tself.assertEquals(graphics, t.info.get('graphics'))\n", "description": "\n\t\tMake sure that default parameters from osinfo do not override user-\n\t\tprovided parameters.\n\t\t", "category": "graphics", "imports": ["import os", "import unittest", "import uuid", "from kimchi.vmtemplate import VMTemplate", "from kimchi.xmlutils.utils import xpath_get_text"]}], [{"term": "class", "name": "classAnimationPlayer:", "data": "class AnimationPlayer:\n\tdef __init__(self):\n\t\tself.frames = {\n\t\t\t# magic\n\t\t\t'flame': import_folder('./graphics/particles/flame/frames'),\n\t\t\t'aura': import_folder('./graphics/particles/aura'),\n\t\t\t'heal': import_folder('./graphics/particles/heal/frames'),\n\n\t\t\t# attacks\n\t\t\t'claw': import_folder('./graphics/particles/claw'),\n\t\t\t'slash': import_folder('./graphics/particles/slash'),\n\t\t\t'sparkle': import_folder('./graphics/particles/sparkle'),\n\t\t\t'leaf_attack': import_folder('./graphics/particles/leaf_attack'),\n\t\t\t'thunder': import_folder('./graphics/particles/thunder'),\n\n\t\t\t# monster deaths\n\t\t\t'squid': import_folder('./graphics/particles/smoke_orange'),\n\t\t\t'raccoon': import_folder('./graphics/particles/raccoon'),\n\t\t\t'spirit': import_folder('./graphics/particles/nova'),\n\t\t\t'bamboo': import_folder('./graphics/particles/bamboo'),\n\n\t\t\t# leafs\n\t\t\t'leaf': (\n\t\t\t\timport_folder('./graphics/particles/leaf1'),\n\t\t\t\timport_folder('./graphics/particles/leaf2'),\n\t\t\t\timport_folder('./graphics/particles/leaf3'),\n\t\t\t\timport_folder('./graphics/particles/leaf4'),\n\t\t\t\timport_folder('./graphics/particles/leaf5'),\n\t\t\t\timport_folder('./graphics/particles/leaf6'),\n\t\t\t\tself.reflect_images(import_folder(\n\t\t\t\t\t'./graphics/particles/leaf1')),\n\t\t\t\tself.reflect_images(import_folder(\n\t\t\t\t\t'./graphics/particles/leaf2')),\n\t\t\t\tself.reflect_images(import_folder(\n\t\t\t\t\t'./graphics/particles/leaf3')),\n\t\t\t\tself.reflect_images(import_folder(\n\t\t\t\t\t'./graphics/particles/leaf4')),\n\t\t\t\tself.reflect_images(import_folder(\n\t\t\t\t\t'./graphics/particles/leaf5')),\n\t\t\t\tself.reflect_images(import_folder(\n\t\t\t\t\t'./graphics/particles/leaf6'))\n\t\t\t)\n\t\t}\n\n\tdef reflect_images(self, frames):\n\t\tnew_frames = []\n\n\t\tfor frame in frames:\n\t\t\tflipped_frame = pygame.transform.flip(\n\t\t\t\tframe, True, False)  # flip frame, x-axis, y-axis\n\t\t\tnew_frames.append(flipped_frame)\n\t\treturn new_frames\n\n\tdef create_grass_particles(self, pos, groups):\n\t\tanimation_frames = choice(self.frames['leaf'])\n\t\tParticleEffect(pos, animation_frames, groups)\n\n\tdef create_particles(self, animation_type, pos, groups):\n\t\tanimation_frames = self.frames[animation_type]\n\t\tParticleEffect(pos, animation_frames, groups)\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('./graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('./graphics/particles/aura'),", "\t\t\t'heal': import_folder('./graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('./graphics/particles/claw'),", "\t\t\t'slash': import_folder('./graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('./graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('./graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('./graphics/particles/thunder'),", "\t\t\t'squid': import_folder('./graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('./graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('./graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('./graphics/particles/bamboo'),", "\t\t\t\timport_folder('./graphics/particles/leaf1'),", "\t\t\t\timport_folder('./graphics/particles/leaf2'),", "\t\t\t\timport_folder('./graphics/particles/leaf3'),", "\t\t\t\timport_folder('./graphics/particles/leaf4'),", "\t\t\t\timport_folder('./graphics/particles/leaf5'),", "\t\t\t\timport_folder('./graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder(", "\t\t\t\tself.reflect_images(import_folder(", "\t\t\t\tself.reflect_images(import_folder(", "\t\t\t\tself.reflect_images(import_folder(", "\t\t\t\tself.reflect_images(import_folder(", "\t\t\t\tself.reflect_images(import_folder("]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\n\tdef __init__(self, pos, animation_frames, groups):\n\t\tsuper().__init__(groups)\n\t\t# basic setup for any animation\n\t\tself.sprite_type = 'magic'\n\t\tself.frame_index = 0\n\t\tself.animation_speed = 0.15\n\t\tself.frames = animation_frames\n\t\tself.image = self.frames[self.frame_index]\n\t\tself.rect = self.image.get_rect(center=pos)\n\n\tdef animate(self):\n\t\tself.frame_index += self.animation_speed\n\t\tif self.frame_index >= len(self.frames):\n\t\t\tself.kill()  # destroy the sprite after animation is finished\n\t\telse:\n\t\t\tself.image = self.frames[int(self.frame_index)]\n\n\tdef create_particles(self, animation_type, pos, groups):\n\t\tanimation_frames = self.frames[animation_type]\n\t\tParticleEffect(pos, animation_frames, groups)\n\n\tdef update(self):\n\t\tself.animate()\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('./graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('./graphics/particles/aura'),", "\t\t\t'heal': import_folder('./graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('./graphics/particles/claw'),", "\t\t\t'slash': import_folder('./graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('./graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('./graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('./graphics/particles/thunder'),", "\t\t\t'squid': import_folder('./graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('./graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('./graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('./graphics/particles/bamboo'),", "\t\t\t\timport_folder('./graphics/particles/leaf1'),", "\t\t\t\timport_folder('./graphics/particles/leaf2'),", "\t\t\t\timport_folder('./graphics/particles/leaf3'),", "\t\t\t\timport_folder('./graphics/particles/leaf4'),", "\t\t\t\timport_folder('./graphics/particles/leaf5'),", "\t\t\t\timport_folder('./graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder(", "\t\t\t\tself.reflect_images(import_folder(", "\t\t\t\tself.reflect_images(import_folder(", "\t\t\t\tself.reflect_images(import_folder(", "\t\t\t\tself.reflect_images(import_folder(", "\t\t\t\tself.reflect_images(import_folder("]}], [{"term": "class", "name": "GeoMapCustomObject", "data": "class GeoMapCustomObject(GeoMapObject):\n\t'''\n\t\\brief The QGeoMapCustomObject class is a QGeoMapObject used to draw\n\ta pixmap on a map.\n\n\t\\inmodule QtLocation\n\n\t\\ingroup maps-mapping-objects\n\t\\since 1.2\n\n\tAny arbitrary QGraphicsItem can be associated with a QGeoMapCustomObject, and to\n\tthis end it contains support for interpreting the coordinates of the\n\tQGraphicsItem in a variety of different ways.\n\n\tFor example, the following code creates a QGraphicsEllipseItem and a\n\tQGeoMapCustomObject to display it. The EllipseItem extends from the origin point,\n\tout 20 meters to the east and 30 metres south.\n\n\t\\code\n\tQGraphicsEllipseItem *ellipseItem = new QGraphicsEllipseItem;\n\tellipseItem->setRect(0, 0, 20, 30);\n\n\tQGeoMapCustomObject *mapObject = new QGeoMapCustomObject;\n\tmapObject->setGraphicsItem(ellipseItem);\n\tmapObject->setUnits(QGeoMapObject::MeterUnit);\n\tmapObject->setOrigin(QGeoCoordinate(-27.5796, 153.1));\n\t\\endcode\n\n\t\\section2 Units and coordinates\n\n\tThe local units and coordinates of the QGraphicsItem are transformed\n\tonto the map based on the \\a units, \\a origin, \\a transformType and\n\t\\a transform properties. Several systems are available, including\n\tpixels, meters and seconds of arc.\n\n\tIt should be noted that both pixel and meter coordinate systems are south-\n\toriented (ie, positive Y axis faces south on the map). However, the\n\tRelativeArcSeconds unit system faces north to align with the standard\n\tlatitude grid. The Y axis can be flipped if necessary by making use of the\n\tGraphicsItem's \\a transform property\n\n\t\\code\n\tQTransform northFlip;\n\tnorthFlip.scale(0, -1);\n\n\tellipseItem->setTransform(northFlip);\n\t\\endcode\n\n\t\\section2 Transform methods\n\n\tNormally, the GraphicsItem will be transformed into map coordinates using\n\ta bilinear interpolation. Another option is the ExactTransform, which\n\tconverts the GraphicsItem exactly into map coordinates, but is only available\n\tfor certain subclasses of QGraphicsItem. Other interpolation methods may\n\tbe provided in future for greater accuracy near poles and in different\n\tmap projections, without the limitations of ExactTransform.\n\n\tCalling setUnits() or setting the units property will result in the\n\tdefault value of transformType being restored. See QGeoMapObject::transformType\n\tfor more details.\n\n\t\\section2 Caveats\n\n\tOther than the coordinate system features, there are a few differences\n\twith using QGraphicsItems on a map compared to using them on a standard\n\tQGraphicsScene. One of the most important of these is the use of the\n\t\\a update() function. When an application changes anything that has an\n\teffect upon the appearance, size, shape etc of the QGraphicsItem, it\n\tmust call \\a QGeoMapCustomObject::update() to ensure that the map is updated.\n\n\tAnother is the use of child items of a QGraphicsItem. These are supported\n\tin more or less the same manner as in QGraphicsScene, with the exception\n\tof use in concert with \\a ExactTransform -- any object with transformType\n\tset to \\a ExactTransform will not have children of its QGraphicsItem drawn\n\ton the map.\n\t\n\t'''\n\t\n\ttriggerUpdate = pyqtSignal()\n\tgraphicsItemChanged = pyqtSignal(QGraphicsItem)\n\t'''This signal is emitted when the graphics item which this custom object\n\tdraws is changed.\n\n\tThe new value will be \\a graphicsItem.'''\n\t\n\toffsetChanged = pyqtSignal(QPoint)\n\t'''This signal is emitted when the on-screen offset from the coordinate \n\tat which this custom object should be drawn has changed.\n\n\tThe new value will be \\a offset.'''\n\t\n\tdef __init__(self, coordinate=None, offset=None):\n\t\t'''\n\t\t@param coordinate: Optional GeoCoordinate\n\t\t@type coordinate: GeoCoordinate\n\t\t@param offset: The offset\n\t\t@type offset: QPoint\n\t\t'''\n\t\tGeoMapObject.__init__(self)\n\t\tif coordinate is not None:\n\t\t\tself.setOrigin(coordinate)\n\t\t\t\n\t\tself._graphicsItem = None#QGraphicsItem()\n\t\tself._offset = offset\n\t\t\n\t\n\tdef type_(self):\n\t\treturn GeoMapObject.CustomType\n\t\n\tdef update(self):\n\t\tself.triggerUpdate.emit()\n\t\t\n\tdef graphicsItem(self):\n\t\t'''\n\t\t\\property QGeoMapCustomObject::graphicsItem\n\t\t\\brief This property holds the graphics item which will\n\t\tbe drawn by this custom object.\n\t\n\t\tIf the graphics item is 0 then nothing will be drawn.\n\t\t@rtype: QGraphicsItem\n\t\t'''\n\t\treturn self._graphicsItem\n\t\n\tdef setGraphicsItem(self, graphicsItem):\n\t\t'''\n\t\t\\property QGeoMapCustomObject::graphicsItem\n\t\t\\brief This property holds the graphics item which will\n\t\tbe drawn by this custom object.\n\t\n\t\tIf the graphics item is 0 then nothing will be drawn.\n\t\t\n\t\t@param graphicsItem: The new graphicsitem\n\t\t@type graphicsItem: QGraphicsItem\n\t\t'''\n\t\tif self._graphicsItem == graphicsItem:\n\t\t\treturn\n\t\t\n\t\tself._graphicsItem = graphicsItem\n\t\tself.graphicsItemChanged.emit(graphicsItem)\n\t\n\tdef offset(self):\n\t\t'''\n\t\t\\property QGeoMapCustomObject::offset\n\t\t\\brief This property holds the offset in pixels at which the graphics\n\t\titem will be drawn by this custom object.\n\t\t\n\t\tThe default value of this property is QPoint(0, 0). If this value is not\n\t\tchanged the upper left coordinate of the graphics item will be drawn at the\n\t\tcoordinate specified by QGeoMapCustomObject::coordinate.\n\t\t\n\t\tThe offset is in pixels and is independent of the zoom level of the map.\n\t\t@rtype: QPoint\n\t\t'''\n\t\treturn self._offset\n\t\n\tdef setOffset(self, offset):\n\t\t'''\n\t\t@see: offset()\n\t\t@param offset: the new offset\n\t\t@type offset: QPoint\n\t\t'''\n\t\tif self._offset != offset:\n\t\t\tself._offset = offset\n\t\t\tself.offsetChanged.emit(offset)\n", "description": null, "category": "graphics", "imports": ["from PyQt4.QtCore import QPoint, pyqtSignal", "from PyQt4.QtGui import QGraphicsItem", "from geomapobject import GeoMapObject #@UnresolvedImport", "\tQGraphicsScene. One of the most important of these is the use of the"]}], [{"term": "def", "name": "main", "data": "def main():\n\tonmouseclicked(start_the_game)\n\tlabel_1 = add_life()\n\tgraphics.window.add(label_1, x=graphics.window.width - label_life.width, \\\n\t\t\t\t\t\ty=graphics.window.height - label_life.height)\n\tlabel_2 = add_score()\n\tgraphics.window.add(label_2, x=0, y=graphics.window.height - label_life.height)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.gui.events.mouse import onmouseclicked", "from campy.graphics.gobjects import GLabel", "import random"]}, {"term": "def", "name": "start_the_game", "data": "def start_the_game(mouse):\n\t\"\"\"\n\tstart the game by mouse clicking\n\t:param mouse: MouseEvent\n\t\"\"\"\n\tglobal dx, dy, lives, score\n\tif 0 <= mouse.x <= graphics.window.width and lives != 0 and graphics.b_amount > 0:\n\t\twhile True:\n\t\t\tgraphics.ball.move(dx, dy)\n\t\t\tgraphics.img.move(0, img_speed)\n\t\t\tpause(FRAME_RATE)\n\t\t\t# detect object to see if the ball hits paddle, bricks, or others\n\t\t\tdetect_object()\n\t\t\t# if the ball hits the walls, the direction of bouncing will be changed\n\t\t\tchange_direction()\n\t\t\t# when player didn't catch the ball\n\t\t\tif graphics.ball.y + graphics.ball.height > graphics.window.height:\n\t\t\t\tlives -= 1\n\t\t\t\t# change the word on label_life\n\t\t\t\tlabel_life.text = 'LIFE:' + str(lives)\n\t\t\t\tgraphics.window.remove(graphics.ball)\n\t\t\t\tgraphics.reset_ball()\n\t\t\t\tbreak\n\t\t\telif graphics.b_amount <= 0:\n\t\t\t\tbreak\n\t\t# show player game is over\n\t\tif lives == 0:\n\t\t\tlabel_end = label_gameover()\n\t\t\tgraphics.window.add(label_end, x=(graphics.window.width-label_end.width)/2, y=0+graphics.window.height/2)\n\t\telif graphics.b_amount <= 0:\n\t\t\tlabel_win = label_win_the_game()\n\t\t\tgraphics.window.add(label_win, x=(graphics.window.width-label_win.width)/2, y=0+graphics.window.height/2)\n\n", "description": "\n\tstart the game by mouse clicking\n\t:param mouse: MouseEvent\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.gui.events.mouse import onmouseclicked", "from campy.graphics.gobjects import GLabel", "import random"]}, {"term": "def", "name": "change_direction", "data": "def change_direction():\n\t\"\"\"\n\tchange direction of bouncing\n\t\"\"\"\n\tglobal dx, dy\n\t# horizontal velocity\n\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\tdx = -dx\n\t\tgraphics.reset_horizontal_velocity(dx)\n\t# vertical velocity\n\tif graphics.ball.y <= 0:\n\t\tdy = -dy\n\t\tgraphics.reset_vertical_velocity(dy)\n\n", "description": "\n\tchange direction of bouncing\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.gui.events.mouse import onmouseclicked", "from campy.graphics.gobjects import GLabel", "import random"]}, {"term": "def", "name": "add_score", "data": "def add_score():\n\t\"\"\"\n\tshow the score\n\t:return: gobject, score on label\n\t\"\"\"\n\tlabel_score.font = '-20'\n\tlabel_score.color = 'skyblue'\n\treturn label_score\n\n", "description": "\n\tshow the score\n\t:return: gobject, score on label\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.gui.events.mouse import onmouseclicked", "from campy.graphics.gobjects import GLabel", "import random"]}, {"term": "def", "name": "add_life", "data": "def add_life():\n\t\"\"\"\n\tshow lives\n\t:return: gobject, lives on label\n\t\"\"\"\n\tlabel_life.font = '-20'\n\tlabel_life.color = 'skyblue'\n\treturn label_life\n\n", "description": "\n\tshow lives\n\t:return: gobject, lives on label\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.gui.events.mouse import onmouseclicked", "from campy.graphics.gobjects import GLabel", "import random"]}, {"term": "def", "name": "label_gameover", "data": "def label_gameover():\n\t\"\"\"\n\tshow \"Game over!\" as game ends\n\t:return: gobject, show player the game is over\n\t\"\"\"\n\tlabel = GLabel('Game over!')\n\tlabel.font = '-50'\n\tlabel.color = 'skyblue'\n\treturn label\n\n", "description": "\n\tshow \"Game over!\" as game ends\n\t:return: gobject, show player the game is over\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.gui.events.mouse import onmouseclicked", "from campy.graphics.gobjects import GLabel", "import random"]}, {"term": "def", "name": "label_win_the_game", "data": "def label_win_the_game():\n\t\"\"\"\n\tShow \"You Win!\" as user wins the game\n\t:return: gobject\n\t\"\"\"\n\tlabel = GLabel('You Win!')\n\tlabel.font = '-50'\n\tlabel.color = 'skyblue'\n\treturn label\n\n", "description": "\n\tShow \"You Win!\" as user wins the game\n\t:return: gobject\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.gui.events.mouse import onmouseclicked", "from campy.graphics.gobjects import GLabel", "import random"]}, {"term": "def", "name": "reset_speed", "data": "def reset_speed():\n\t\"\"\"\n\treset vertical speed as score achieves certain level\n\t:return: float, new vertical speed\n\t\"\"\"\n\tglobal y_speed\n\t# when score achieves 50\n\tif score == 50:\n\t\t# ball moves faster\n\t\ty_speed = y_speed * 1.2\n\t\tgraphics.reset_vertical_velocity(dy)\n\t# when score achieves 70\n\telif score == 70:\n\t\t# ball moves faster\n\t\ty_speed = y_speed * 1.2\n\t\tgraphics.reset_vertical_velocity(dy)\n\telif score == 120:\n\t\t# ball moves faster\n\t\ty_speed = y_speed * 1.3\n\t\tgraphics.reset_vertical_velocity(dy)\n\n", "description": "\n\treset vertical speed as score achieves certain level\n\t:return: float, new vertical speed\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.gui.events.mouse import onmouseclicked", "from campy.graphics.gobjects import GLabel", "import random"]}, {"term": "def", "name": "detect_object", "data": "def detect_object():\n\t\"\"\"\n\tdetect object is brick, paddle, or others\n\t\"\"\"\n\tglobal score, dy\n\t# get object on the position of ball\n\tobj = graphics.detect_object()\n\t# ball hits the image\n\tif obj is not None and obj == graphics.img and obj is not label_life and obj is not label_score:\n\t\t# get 15 points on each image\n\t\tscore += 15\n\t\t# change the word on label_score\n\t\tlabel_score.text = 'SCORE: ' + str(score)\n\t\t# when score achieves certain standard, the vertical will be increased\n\t\treset_speed()\n\t\t# change ball's direction\n\t\tgraphics.window.add(graphics.img, \\\n\t\t\t\t\t\t\tx=random.randint(0, (graphics.b_w + graphics.b_o) * graphics.b_c - graphics.img.width*2), \\\n\t\t\t\t\t\t\ty=(graphics.b_h + graphics.b_o))\n\t\tgraphics.reset_vertical_velocity(dy)\n\t# ball hits the paddle\n\telif obj is not None and obj == graphics.paddle and obj is not label_life and obj is not label_score:\n\t\t# change ball's direction\n\t\tdy = y_speed\n\t\tgraphics.reset_vertical_velocity(dy)\n\t# ball hits bricks\n\telif obj is not None and obj is not label_life and obj is not label_score:\n\t\t# get 5 points on each brick\n\t\tscore += 5\n\t\t# change the word on label_score\n\t\tlabel_score.text = 'SCORE: ' + str(score)\n\t\t# when score achieves certain standard, the vertical will be increased\n\t\treset_speed()\n\t\t# change ball's direction\n\t\tdy = -y_speed\n\t\tgraphics.window.remove(obj)\n\t\tgraphics.b_amount -= 1\n\t\tgraphics.reset_vertical_velocity(dy)\n\n", "description": "\n\tdetect object is brick, paddle, or others\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.gui.events.mouse import onmouseclicked", "from campy.graphics.gobjects import GLabel", "import random"]}], [{"term": "class", "name": "MapUtiles", "data": "class MapUtiles(QObject):\n\tsignalEdgeChanged = pyqtSignal(bool)\n\tsignalNewRoi = pyqtSignal(bool)\n\tdef __init__(self, graphicsScene, FTS):\n\t\tsuper(MapUtiles, self).__init__()\n\n\t\tself.graphicsScene = graphicsScene\n\t\tself.graphicsScene.signalMousePressedPos.connect(self.pointSelection)\n\t\tself.graphicsScene.signalMouseReleasedPos.connect(self.pointRelease)\n\t\tself.graphicsScene.signalMouseMovePos.connect(self.mouseMove)\n\n\t\tself.FTS = FTS\n\n\t\t# Variable is True is left mouse button is holded\n\t\tself.clicked = False\n\n\t\t# Set dialog layout to grid\n\t\tself.grid = QGridLayout()\n\n\t\t# Initialize variables for FTS matrix\n\t\tself.groupBox_list = []\n\t\tself.edge_matrix = []\n\t\tself.vbox_list = []\n\t\tself.vbox = QVBoxLayout()\n\n\t# Add ROI with mouse click\n\tdef pointSelection(self, pos):\n\t\tself.clicked = True\n\t\tself.current_arrow = []\n\t\tself.graphicsScene.add_ROI(pos)\n\t\tself.pose_of_interest = {'position' : self.graphicsScene.pixelToWorld(pos)}\n\t\tself.add_FTS_matrix()\n\n\t# Set orientation of ROI by releasing mouse button\n\tdef pointRelease(self, pos):\n\t\tself.clicked = False\n\t\tpixel_coords = self.graphicsScene.items_dict['r' + str(self.graphicsScene.regionCounter).zfill(2)]['pixel_coords']\n\t\tdeltay = -pos.y() + pixel_coords.y()\n\t\tdeltax = pos.x() - pixel_coords.x()\n\t\ttheta = atan2(deltay, deltax)\n\t\tquat = Quaternion(axis=(0.0, 0.0, 1.0), radians=theta)\n\t\tself.pose_of_interest.update({'orientation' : (float(quat[0]), float(quat[1]), float(quat[2]), float(quat[3]))})\n\t\tedges = []\n\t\tself.FTS.add_region('r' + str(self.graphicsScene.regionCounter).zfill(2), edges, pose = self.pose_of_interest)\n\t\tself.graphicsScene.items_dict['r' + str(self.graphicsScene.regionCounter).zfill(2)].update({'arrow' : self.current_arrow})\n\n\t\troi_msg = self.build_roi_msg('r' + str(self.graphicsScene.regionCounter).zfill(2))\n\t\tself.sense_msg = Sense()\n\t\tself.sense_msg.rois.append(roi_msg)\n\n\t\tself.signalNewRoi.emit(True)\n\n\t# Update orientation arrow while mouse button is pressed\n\tdef mouseMove(self, pos):\n\t\tarrow_length = 50\n\t\tif self.clicked:\n\t\t\tpixel_coords = self.graphicsScene.items_dict['r' + str(self.graphicsScene.regionCounter).zfill(2)]['pixel_coords']\n\t\t\ttheta = atan2((pos.y() - pixel_coords.y()) , (pos.x() - pixel_coords.x()))\n\t\t\tend_point = QPointF(pixel_coords.x() + arrow_length * cos(theta), pixel_coords.y() + arrow_length * sin(theta))\n\t\t\tif len(self.current_arrow) > 0:\n\t\t\t\tself.graphicsScene.removeArrow(self.current_arrow)\n\t\t\tself.current_arrow = self.graphicsScene.addArrow(pixel_coords, end_point)\n\n\n\tdef init_FTS_matrix(self, FTS):\n\n\t\tself.FTS = FTS\n\t\t# Sort the ROI's alphabetic, needed for FTS matrix since it's implemented with list\n\t\tsorted_keys = self.FTS.region_of_interest.keys()\n\t\tsorted_keys.sort()\n\t\t# Add all the ROI's and edges\n\t\tfor i in range(0, len(self.FTS.region_of_interest)):\n\t\t\tgroupBox = QGroupBox(sorted_keys[i])\n\t\t\tself.groupBox_list.append(groupBox)\n\t\t\tcheckBox_list = []\n\t\t\tself.edge_matrix.append(checkBox_list)\n\n\t\t\tvbox = QVBoxLayout()\n\t\t\tself.vbox_list.append(vbox)\n\n\t\t\tfor j in range(0, len(self.FTS.region_of_interest)):\n\t\t\t\t\tself.edge_matrix[i].append(CustomCheckBox(sorted_keys[j], i, j))\n\t\t\t\t\tself.edge_matrix[i][j].signalStateChanged.connect(self.edge_both_ways)\n\t\t\t\t\tself.vbox_list[i].addWidget(self.edge_matrix[i][j])\n\n\t\t\tself.groupBox_list[i].setLayout(self.vbox_list[i])\n\t\t\tself.grid.addWidget(self.groupBox_list[i], 0, i+1, Qt.AlignRight)\n\n\t\tfor i in range(0, len(self.FTS.region_of_interest)):\n\t\t\tfor j in range(0, len(self.FTS.region_of_interest[sorted_keys[i]]['edges'])):\n\t\t\t\tindex = sorted_keys.index(self.FTS.region_of_interest[sorted_keys[i]]['edges'][j]['target'])\n\t\t\t\tself.edge_matrix[i][index].setCheckState(2)\n\n\tdef add_FTS_matrix(self):\n\t\tregionString = 'r' + str(self.graphicsScene.regionCounter).zfill(2)\n\n\t\tgroupBox = QGroupBox(regionString)\n\t\tself.groupBox_list.append(groupBox)\n\t\tcheckBox_list = []\n\t\tself.edge_matrix.append(checkBox_list)\n\n\t\tvbox = QVBoxLayout()\n\t\tself.vbox_list.append(vbox)\n\t\tfor i in range(0, self.graphicsScene.regionCounter):\n\t\t\tif i == (self.graphicsScene.regionCounter-1):\n\t\t\t\tfor j in range(0, i+1):\n\t\t\t\t\tself.edge_matrix[i].append(CustomCheckBox('r' + str(j+1).zfill(2), i, j))\n\t\t\t\t\tself.edge_matrix[i][j].signalStateChanged.connect(self.edge_both_ways)\n\t\t\t\t\tself.vbox_list[i].addWidget(self.edge_matrix[i][j])\n\t\t\telse:\n\t\t\t\tself.edge_matrix[i].append(CustomCheckBox('r' + str(self.graphicsScene.regionCounter).zfill(2), i, self.graphicsScene.regionCounter-1))\n\t\t\t\tself.edge_matrix[i][self.graphicsScene.regionCounter-1].signalStateChanged.connect(self.edge_both_ways)\n\t\t\t\tself.vbox_list[i].addWidget(self.edge_matrix[i][self.graphicsScene.regionCounter-1])\n\n\t\tfor i in range(0, len(self.groupBox_list)):\n\t\t\tself.groupBox_list[i].setLayout(self.vbox_list[i])\n\t\t\tself.grid.addWidget(self.groupBox_list[i], 0, i+1, Qt.AlignRight)\n\n\tdef remove_FTS_matrix(self):\n\t\tdel self.edge_matrix[self.graphicsScene.regionCounter-1]\n\t\tdel self.FTS.region_of_interest['r' + str(self.graphicsScene.regionCounter).zfill(2)]\n\t\tdel self.vbox_list[self.graphicsScene.regionCounter-1]\n\n\t\tself.grid.removeWidget(self.groupBox_list[self.graphicsScene.regionCounter-1])\n\t\tself.groupBox_list[self.graphicsScene.regionCounter-1].deleteLater()\n\t\tdel self.groupBox_list[self.graphicsScene.regionCounter-1]\n\n\t\tfor i in range(0, self.graphicsScene.regionCounter-1):\n\t\t\tself.vbox_list[i].removeWidget(self.edge_matrix[i][self.graphicsScene.regionCounter-1])\n\t\t\tself.edge_matrix[i][self.graphicsScene.regionCounter-1].deleteLater()\n\t\t\tdel self.edge_matrix[i][self.graphicsScene.regionCounter-1]\n\t\t\tif self.graphicsScene.regionCounter < (i+1):\n\t\t\t\tif ((str(self.graphicsScene.regionCounter) + '-' + str(i+1)) in self.graphicsScene.line_dict.keys()):\n\t\t\t\t\tself.graphicsScene.remove_edge((str(self.graphicsScene.regionCounter) + '-' + str(i+1)))\n\t\t\telse:\n\t\t\t\tif ((str(i+1) + '-' + str(self.graphicsScene.regionCounter)) in self.graphicsScene.line_dict.keys()):\n\t\t\t\t\tself.graphicsScene.remove_edge((str(i+1) + '-' + str(self.graphicsScene.regionCounter)))\n\n\t\tself.graphicsScene.remove_ROI()\n\n\tdef reset_FTS_matrix(self):\n\t\tfor i in range(0, len(self.edge_matrix)):\n\t\t\tself.remove_FTS_matrix()\n\n\n\t# Set the edges both ways in FTS matrix\n\t@pyqtSlot(int, int, int)\n\tdef edge_both_ways(self, state, row, col):\n\t\tself.sense_msg = Sense()\n\t\tstart_pose = self.from_dict_to_pose_msg('r' + str(col+1).zfill(2))\n\t\ttarget_pose = self.from_dict_to_pose_msg('r' + str(row+1).zfill(2))\n\t\tif state == 2:\n\t\t\tif self.edge_matrix[col][row].checkState() != self.edge_matrix[row][col].checkState():\n\t\t\t\tself.edge_matrix[col][row].setCheckState(2)\n\t\t\t\t#self.FTS.add_edge('r' + str(col+1).zfill(2), 'r' + str(row+1).zfill(2), 1.0)\n\t\t\t\t#self.FTS.add_edge('r' + str(row+1).zfill(2), 'r' + str(col+1).zfill(2), 1.0)\n\t\t\t\tedge = self.build_edge_msg(start_pose, target_pose, 1.0, True)\t\t\t   \n\t\t\t\tif edge not in self.sense_msg.edges:\n\t\t\t\t\tself.sense_msg.edges.append(edge)\n\t\t\t\tedge = self.build_edge_msg(target_pose, start_pose, 1.0, True)\n\t\t\t\tif edge not in self.sense_msg.edges:\n\t\t\t\t\tself.sense_msg.edges.append(edge)\n\t\t\t\tif row < col:\n\t\t\t\t\tif (str(row+1) + '-' + str(col+1)) not in self.graphicsScene.line_dict.keys():\n\t\t\t\t\t\tself.graphicsScene.add_edge(row+1, col+1)\n\t\t\t\telse:\n\t\t\t\t\tif (str(col+1) + '-' + str(row+1)) not in self.graphicsScene.line_dict.keys():\n\t\t\t\t\t\tself.graphicsScene.add_edge(col+1, row+1)\n\t\telif state == 0:\n\t\t\tif self.edge_matrix[col][row].checkState() != self.edge_matrix[row][col].checkState():\n\t\t\t\tself.edge_matrix[col][row].setCheckState(0)\n\t\t\t\t#self.FTS.remove_edge('r' + str(col+1).zfill(2), 'r' + str(row+1).zfill(2))\n\t\t\t\t#self.FTS.remove_edge('r' + str(row+1).zfill(2), 'r' + str(col+1).zfill(2))\n\t\t\t\tedge = self.build_edge_msg(start_pose, target_pose, 1.0, False)\n\t\t\t\tif edge not in self.sense_msg.edges:\n\t\t\t\t\tself.sense_msg.edges.append(edge)\n\t\t\t\tedge = self.build_edge_msg(target_pose, start_pose, 1.0, False)\n\t\t\t\tif edge not in self.sense_msg.edges:\n\t\t\t\t\tself.sense_msg.edges.append(edge)\n\t\t\t\tif row < col:\n\t\t\t\t\tif (str(row+1) + '-' + str(col+1)) in self.graphicsScene.line_dict.keys():\n\t\t\t\t\t\tself.graphicsScene.remove_edge(str(row+1) + '-' + str(col+1))\n\t\t\t\telse:\n\t\t\t\t\tif (str(col+1) + '-' + str(row+1)) in self.graphicsScene.line_dict.keys():\n\t\t\t\t\t\tself.graphicsScene.remove_edge(str(col+1) + '-' + str(row+1))\n\n\t\tself.signalEdgeChanged.emit(True)\n\n\tdef from_dict_to_pose_msg(self, roi_label):\n\t\tpose_msg = Pose()\n\t\tpose_msg.position.x = self.FTS.region_of_interest[roi_label]['pose']['position'][0]\n\t\tpose_msg.position.y = self.FTS.region_of_interest[roi_label]['pose']['position'][1]\n\t\tpose_msg.position.z = self.FTS.region_of_interest[roi_label]['pose']['position'][2]\n\t\tpose_msg.orientation.w = self.FTS.region_of_interest[roi_label]['pose']['orientation'][0]\n\t\tpose_msg.orientation.x = self.FTS.region_of_interest[roi_label]['pose']['orientation'][1]\n\t\tpose_msg.orientation.y = self.FTS.region_of_interest[roi_label]['pose']['orientation'][2]\n\t\tpose_msg.orientation.z = self.FTS.region_of_interest[roi_label]['pose']['orientation'][3]\n\n\t\treturn pose_msg\n\n\tdef build_edge_msg(self, start_pose, target_pose, weight, add):\n\t\tedge = Edge()\n\t\tedge.start_pose = start_pose\n\t\tedge.target_pose = target_pose\n\t\tedge.add.data = add\n\t\tedge.weight = weight\n\n\t\treturn edge\n\n\tdef build_roi_msg(self, label):\n\t\troi = Roi()\n\t\tstring_msg = String()\n\t\tstring_msg.data = label\n\n\t\troi.label = string_msg\n\t\troi.pose = self.from_dict_to_pose_msg(label)\n\n\t\troi.propos_satisfied.append(string_msg)\n\t\treturn roi\n", "description": null, "category": "graphics", "imports": ["import os", "import sys", "from math import atan2, cos, sin, pi, atan", "from pyquaternion import Quaternion", "from python_qt_binding.QtWidgets import QVBoxLayout, QGridLayout, QGroupBox", "from python_qt_binding.QtCore import Qt, pyqtSlot, pyqtSignal, QObject, QPointF", "from CustomCheckBox import CustomCheckBox", "from rqt_simulation_msgs.msg import Sense, Edge, Roi", "from geometry_msgs.msg import Pose", "from std_msgs.msg import String"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tlives = NUM_LIVES\n\n\t# Add animation loop here!\n\twhile True:\n\t\t# Update ball movement\n\t\tif graphics.is_game_started:\t\t\t\t\t\t\t\t\t# check if the game is started\n\t\t\tgraphics.ball.move(graphics.get_x_velocity(), graphics.get_y_velocity())\n\n\t\t# Bounce back if the ball reaches borders of the window\n\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\t\tgraphics.bounce_x()\n\t\telif graphics.ball.y <= 0:\t\t\t\t\t\t\t\t\t  # the top of the window\n\t\t\tgraphics.bounce_y()\n\t\telif graphics.ball.y > graphics.window.height:\t\t\t\t  # the bottom of the window(out of bound)\n\t\t\tgraphics.window.add(graphics.ball, x=(graphics.window.width - graphics.ball.width) / 2,\n\t\t\t\t\t\t\t\ty=(graphics.window.height - graphics.ball.height) / 2)\n\t\t\tgraphics.is_game_started = False\t\t\t\t\t\t\t# turn off the game\n\t\t\tlives -= 1\t\t\t\t\t\t\t\t\t\t\t\t  # loose one attempt\n\t\t\tif lives == 0:\t\t\t\t\t\t\t\t\t\t\t  # end the game if no attempts are left\n\t\t\t\tbreak\n\n\t\t# Check whether the upper left corner of the ball hits other objects\n\t\tif graphics.upper_left() is not None:\n\t\t\tif graphics.upper_left() is not graphics.paddle:\t\t\t# make sure the ball won't stick on the paddle\n\t\t\t\tgraphics.remove_brick(graphics.upper_left())\n\t\t\t\tif graphics.upper_right() is None \\\n\t\t\t\t\t\tand graphics.lower_left() is None:\t\t\t  # make sure the ball won't overly advance\n\t\t\t\t\tgraphics.bounce_y()\n\n\t\t# Check whether the upper right corner of the ball hits other objects\n\t\tif graphics.upper_right() is not None:\n\t\t\tif graphics.upper_right() is not graphics.paddle:\t\t   # make sure the ball won't stick on the paddle\n\t\t\t\tgraphics.remove_brick(graphics.upper_right())\n\t\t\t\tif graphics.lower_right() is None \\\n\t\t\t\t\t\tand graphics.lower_left() is None:\t\t\t  # make sure the ball won't overly advance\n\t\t\t\t\tgraphics.bounce_y()\n\n\t\t# Check whether the lower left corner of the ball hits other objects\n\t\tif graphics.lower_left() is not None:\n\t\t\tif graphics.lower_left() is not graphics.paddle:\t\t\t# remove bricks if not encountering paddle\n\t\t\t\tgraphics.remove_brick(graphics.lower_left())\n\t\t\tif graphics.lower_right() is None:\t\t\t\t\t\t  # make sure the ball won't overly advance\n\t\t\t\tgraphics.upward_bounce()\n\n\t\t# Check whether the lower right corner of the ball hits other objects\n\t\tif graphics.lower_right() is not None:\n\t\t\tif graphics.lower_right() is not graphics.paddle:\t\t   # remove bricks if not encountering paddle\n\t\t\t\tgraphics.remove_brick(graphics.lower_right())\n\t\t\tgraphics.upward_bounce()\n\n\t\t# Pause\n\t\tpause(FRAME_RATE)\n\n\t\t# End the game if no bricks are left\n\t\tif graphics.num_brick == 0:\n\t\t\tbreak\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "def", "name": "system", "data": "def system(s):\n\tcode = os.system(s)\n\tif code != 0:\n\t\timport pdb; pdb.set_trace()\n\treturn\n", "description": null, "category": "graphics", "imports": ["import glob", "import math", "import os", "import re", "import subprocess", "\t\timport pdb; pdb.set_trace()", "\timport sys", "\tfrom argparse import ArgumentParser"]}, {"term": "def", "name": "main", "data": "def main(data, out, bindir):\n\trgb2amiga = os.path.join(bindir, 'bin', 'Rgb2Amiga')\n\tbitmap_conv = os.path.join(bindir, 'bin', 'bitmap_conv')\n\ttileset_conv = os.path.join(bindir, 'bin', 'tileset_conv')\n\tpalette_conv = os.path.join(bindir, 'bin', 'palette_conv')\n\tw_h_re = re.compile(r\"PNG image data, (\\d+) x (\\d+),\")\n\ttransparency = r'\\#BBBBBB'\n\n\tdata = os.path.join(data, \".\")\n\tout = os.path.join(out, \".\")\n\n\tfor name,set in DATA.items():\n\t\tinputfiles = []\n\t\tpngfiles = []\n\t\tbmfiles = []\n\t\tfor pattern in set:\n\t\t\tfor i in glob.glob(os.path.join(data, pattern)):\n\t\t\t\toutput = i.replace(data, os.path.join(out, name.lower()))\n\t\t\t\tinputfiles.append(i)\n\t\t\t\tpngfiles.append(output)\n\t\t\t\tos.makedirs(os.path.dirname(output), exist_ok=True)\n\t\t\t\tbmfiles.append(output.replace(\".png\", \".bm\"))\n\n\t\tinargs = \" -i \".join(inputfiles)\n\t\toutargs = \" -o \".join(pngfiles)\n\t\tsystem(f\"{rgb2amiga} -c 32 -f png-gpl -s ! -i {inargs} -o {outargs}\")\n\t\tpalette = os.path.join(out, f\"{name.lower()}.plt\")\n\t\tsystem(f\"{palette_conv} {pngfiles[0]}.gpl {palette}\")\n\t\tfor bmfile,pngfile in zip(bmfiles, pngfiles):\n\t\t\t# TODO: mask color is transparency\n\t\t\tinfo = subprocess.check_output(f\"file {pngfile}.png\", shell=True).decode()\n\t\t\tw, h = (int(x) for x in w_h_re.search(info).groups())\n\t\t\tif w % 16:\n\t\t\t\tif w > 16:\n\t\t\t\t\tcrop_left = math.floor((w % 16) / 2)\n\t\t\t\t\tcrop_right = math.ceil((w % 16) / 2)\n\t\t\t\t\tsystem(f\"convert {pngfile}.png -gravity East -crop {w - crop_left}x{h}+0+0 +repage {pngfile}.png\")\n\t\t\t\t\tsystem(f\"convert {pngfile}.png -gravity West -crop {w - crop_left - crop_right}x{h}+0+0 +repage {pngfile}.png\")\n\t\t\t\telse:\n\t\t\t\t\tadd_left = math.floor((16 - w) / 2)\n\t\t\t\t\tadd_right = math.ceil((16 - w) / 2)\n\t\t\t\t\tsystem(f\"convert {pngfile}.png -gravity East -background {transparency} -splice {add_left}x0 +repage {pngfile}.png\")\n\t\t\t\t\tsystem(f\"convert {pngfile}.png -gravity West -background {transparency} -splice {add_right}x0 +repage {pngfile}.png\")\n\t\t\tsystem(f\"{bitmap_conv} {palette} {pngfile}.png -o {bmfile} -mc {transparency}\")\n\t\tif name.endswith(\"_TILESET\"):\n\t\t\tsystem(f\"{tileset_conv} {pngfiles[0]}.png {TILE_SIZE} {bmfiles[0]} -plt {palette}\")\n\n", "description": null, "category": "graphics", "imports": ["import glob", "import math", "import os", "import re", "import subprocess", "\t\timport pdb; pdb.set_trace()", "\timport sys", "\tfrom argparse import ArgumentParser"]}], [], [{"term": "class", "name": "GraphicsTest", "data": "class GraphicsTest(SampleBase):\n\tdef __init__(self, *args, **kwargs):\n\t\tsuper(GraphicsTest, self).__init__(*args, **kwargs)\n\n\tdef run(self):\n\t\tcanvas = self.matrix\n\t\tfont = graphics.Font()\n\t\tfont.LoadFont(\"../../../fonts/7x13.bdf\")\n\n\t\tred = graphics.Color(255, 0, 0)\n\t\tgraphics.DrawLine(canvas, 5, 5, 22, 13, red)\n\n\t\tgreen = graphics.Color(0, 255, 0)\n\t\tgraphics.DrawCircle(canvas, 15, 15, 10, green)\n\n\t\tblue = graphics.Color(0, 0, 255)\n\t\tgraphics.DrawText(canvas, font, 2, 10, blue, \"Text\")\n\n\t\ttime.sleep(10)   # show display for 10 seconds before exit\n\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "import time"]}], [], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tnum_lives = NUM_LIVES\n\tcount = COUNT\n\t# Add animation loop here!\n\twhile True:\n\t\tgraphics.ball.move(graphics.getter_dx(), graphics.getter_dy())\n\t\tif graphics.ball.x >= graphics.window.width - graphics.ball_radius*2 or graphics.ball.x <= 0:  # hitting left or right border\n\t\t\tgraphics.setter_new_dx(-graphics.getter_dx())  # rebound\n\t\tif graphics.ball.y <= 0:  # hitting upper border\n\t\t\tgraphics.setter_new_dy(-graphics.getter_dy())\n\t\tif graphics.ball.y >= graphics.window.height - graphics.ball_radius*2:  # the ball falls out of the bottom window (lose)\n\t\t\tnum_lives -= 1\n\t\t\tgraphics.reset_ball_position()  # Center a filled ball in the graphical window\n\t\tif num_lives == 0:  # when the players fail for three times\n\t\t\tbreak\n\t\t# check the point according to this order: (x, y), (x, y+2r), (x+2r, y), (x+2r, y+2r)\n\t\tobj1 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y)\n\t\tif obj1 is None:\n\t\t\tobj2 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y+2*graphics.ball_radius)\n\t\t\tif obj2 is None:\n\t\t\t\tobj3 = graphics.window.get_object_at(graphics.ball.x + 2 * graphics.ball_radius, graphics.ball.y)\n\t\t\t\tif obj3 is None:\n\t\t\t\t\tobj4 = graphics.window.get_object_at(graphics.ball.x + 2 * graphics.ball_radius, graphics.ball.y+ 2 * graphics.ball_radius)\n\t\t\t\t\tif obj4 is None:\n\t\t\t\t\t\tpass\n\t\t\t\t\telse:\n\t\t\t\t\t\tif obj4 is graphics.paddle:\n\t\t\t\t\t\t\tif graphics.getter_dy() >= 0:  # fix the problem of the wrong condition of rebounding\n\t\t\t\t\t\t\t\tgraphics.setter_new_dy(-graphics.getter_dy())\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tpass\n\t\t\t\t\t\telse:  # obj4 is a brick\n\t\t\t\t\t\t\tgraphics.setter_new_dy(-graphics.getter_dy())\n\t\t\t\t\t\t\tgraphics.window.remove(obj4)\n\t\t\t\t\t\t\tcount += 1\n\t\t\t\telse:\n\t\t\t\t\tif obj3 is graphics.paddle:\n\t\t\t\t\t\tpass\n\t\t\t\t\telse:  # obj3 is a brick\n\t\t\t\t\t\tgraphics.setter_new_dy(-graphics.getter_dy())\n\t\t\t\t\t\tgraphics.window.remove(obj3)\n\t\t\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tif obj2 is graphics.paddle:\n\t\t\t\t\tif graphics.getter_dy() >= 0:\n\t\t\t\t\t\tgraphics.setter_new_dy(-graphics.getter_dy())\n\t\t\t\t\telse:\n\t\t\t\t\t\tpass\n\t\t\t\telse:  # obj2 is a brick\n\t\t\t\t\tgraphics.setter_new_dy(-graphics.getter_dy())\n\t\t\t\t\tgraphics.window.remove(obj2)\n\t\t\t\t\tcount += 1\n\t\telse:\n\t\t\tif obj1 is graphics.paddle:\n\t\t\t\tpass\n\t\t\telse:  # obj1 is a brick\n\t\t\t\tgraphics.setter_new_dy(-graphics.getter_dy())\n\t\t\t\tgraphics.window.remove(obj1)\n\t\t\t\tcount += 1\n\t\tif count == graphics.brick_cols*graphics.brick_rows:  # when the player hits all of the bricks\n\t\t\tbreak\n\n\t\tpause(FRAME_RATE)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, **kargs):\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [{"term": "class", "name": "About", "data": "class About(QtWidgets.QLabel):\r\n\r\n\tdef __init__(self):\r\n\t\tQtWidgets.QLabel.__init__(self,\r\n\t\t\t\t\t\t\t\t  \"distCarb 1.0\\n\\nPor Servando Chinch\u00f3n Pay\u00e1, 2018\\n\\nPor favor no dude en comentar cualquier sugerencia\\n\\nservando@ietcc.csic.es\\n\\n\u00a1Gracias!\")\r\n\t\tself.setAlignment(QtCore.Qt.AlignCenter)\r\n\r\n\tdef initUI(self):\r\n\t\tself.center()\r\n\r\n\tdef center(self):\r\n\t\tqr = self.frameGeometry()\r\n\t\tcp = app.desktop().availableGeometry().centre()\r\n\t\tqr.moveCenter(cp)\r\n\t\tself.move(qr.topLeft())\r\n\r\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore, QtGui, QtWidgets\r", "from PyQt5.QtCore import pyqtSignal, QFileInfo, Qt, QDate, QPropertyAnimation, QPointF\r", "from PyQt5.QtWidgets import QApplication, QMainWindow, QMessageBox, QFileDialog, QTableWidget, QTableWidgetItem, \\\r", "from Main3 import Ui_MainWindow\r", "from MiGV3 import MiGraphicsView\r", "from pdC3 import Ui_Preferencias\r", "from Kc2 import Ui_Dialog\r", "import numpy as np\r", "from string import Template\r", "import sys, os, time\r", "from PyQt5.QtGui import QColor\r", "from PyQt5.QtCore import QPropertyAnimation, pyqtProperty\r"]}, {"term": "class", "name": "mainProgram", "data": "class mainProgram(QMainWindow, Ui_MainWindow):\r\n\tdef __init__(self):\r\n\t\tsuper(mainProgram, self).__init__()\r\n\t\tself.setupUi(self)\r\n\t\t\"\"\"\r\n\t\tQuito todo lo relativo al GraphicsView de Main.py y lo traigo aqu\u00ed\r\n\t\t\"\"\"\r\n\t\tself.graphicsView = MiGraphicsView()\r\n\t\tself.graphicsView.setAutoFillBackground(False)\r\n\t\tself.graphicsView.setObjectName(\"graphicsView\")\r\n\t\tself.gridLayout_3.addWidget(self.graphicsView, 0, 0, 1, 1)\r\n\r\n\t\tself.titulos_tabla = [\"n\u00famero\", \"ditancia(px)\", \"distancia(valor real)\"]\r\n\r\n\t\tself.actionAbrir_imagen.triggered.connect(self.loadImage)\r\n\t\tself.actionSalir.triggered.connect(self.close_application)\r\n\t\tself.actionAyuda.triggered.connect(self.Ayuda)\r\n\t\tself.actionSobre_el_programa.triggered.connect(self.sobre_programa)\r\n\t\tself.actionPreferencias.triggered.connect(self.open_preferencias)\r\n\t\tself.actionCrear_informe.triggered.connect(self.report)\r\n\t\tself.actionGuardar_imagen.triggered.connect(self.guardar_imagen)\r\n\t\tself.actionCalcular_coeficiente_difusi_n.triggered.connect(self.open_calcular_kc)\r\n\r\n\t\tself.rb_escala.toggled.connect(self.pe)\r\n\t\tself.rb_linea.toggled.connect(self.pl)\r\n\t\tself.rb_puntos.toggled.connect(self.pp)\r\n\r\n\t\tself.pb_rehacerescala.clicked.connect(self.rehacer_escala)\r\n\t\tself.pb_rehacerlinea.clicked.connect(self.rehacer_linea)\r\n\r\n\t\tself.graphicsView.senyal_escala.connect(self.cosasdeescala)\r\n\t\tself.graphicsView.senyal_linea.connect(self.cosasdelinea)\r\n\t\tself.graphicsView.senyal_punto.connect(self.gestionar_puntos)\r\n\r\n\t\tself.dlg = pref()\r\n\t\tself.dlg.setModal(True)\r\n\t\tself.dlg.senyal_cambios_preferencias.connect(self.actualizar_preferencias)\r\n\r\n\t\tself.pb_OK.clicked.connect(self.ok_escala)\r\n\t\tself.pb_calcular.clicked.connect(self.calcular)\r\n\r\n\t\tself.pb_borrar.clicked.connect(self.borrar_punto)\r\n\r\n\t\tself.label = MyLabel(\"de prueba\")\r\n\t\tself.label_puntos = False\r\n\r\n\t\tself.tabla_cara_1 = False\r\n\t\tself.tabla_cara_2 = False\r\n\t\tself.tabla_cara_3 = False\r\n\t\tself.tabla_cara_4 = False\r\n\r\n\t\tself.actionBorrar_puntos.triggered.connect(self.borrar_puntos_lista_cara)\r\n\t\tself.actionBorrar_l_nea.triggered.connect(self.graphicsView.borrarlinea)\r\n\t\tself.actionBorrar_escala.triggered.connect(self.graphicsView.borrarescala)\r\n\r\n\t\tself.cb_caras.currentIndexChanged.connect(self.llenar_tabla)\r\n\r\n\t\tself.tabla.itemClicked.connect(self.anim_start)\r\n\t\tself.tabla.itemDoubleClicked.connect(self.limpiar)\r\n\r\n\t\tself.nuevos_puntos_1 = []\r\n\r\n\t\tself.distancias_kc_1 = []\r\n\t\tself.distancias_kc_2 = []\r\n\t\tself.distancias_kc_3 = []\r\n\t\tself.distancias_kc_4 = []\r\n\r\n\t\tself.dlg_kc = Calc_coef(self.graphicsView.distanciasreales_1, self.graphicsView.distanciasreales_2, self.graphicsView.distanciasreales_3, self.graphicsView.distanciasreales_4)\r\n\t\tself.dlg_kc.setModal(True)\r\n\t\tself.dlg_kc.senyal_kc.connect(self.actualizar_kc)\r\n\t\tself.coeficiente = None\r\n\t\tself.unidades_tiempo = None\r\n\t\tself.unidades_distancia = None\r\n\r\n\tdef loadImage(self):\r\n\t\tname, _ = QtWidgets.QFileDialog.getOpenFileName(None, 'Abrir imagen')\r\n\t\tself.img = QtGui.QPixmap(name)\r\n\t\tself.graphicsView.setPhoto(self.img)\r\n\t\tself.filename = QFileInfo(name).fileName()\r\n\t\tif self.graphicsView.empty == False:\r\n\t\t\tself.actionPreferencias.setEnabled(True)\r\n\t\t\tself.rb_escala.setEnabled(True)\r\n\t\t\tself.rb_escala.setChecked(True)\r\n\t\t\t# self.pb_rehacerescala.setEnabled(True)\r\n\t\t\tself.le_escala.setEnabled(True)\r\n\t\t\tself.pb_OK.setEnabled(True)\r\n\t\t\tself.rb_linea.setEnabled(True)\r\n\t\t\t# self.pb_rehacerlinea.setEnabled(True)\r\n\t\t\tself.rb_puntos.setEnabled(True)\r\n\t\t\t# self.pb_rehacerescala.setEnabled(True)\r\n\r\n\t\t\tself.tabla.setRowCount(0)\r\n\t\t\tself.tabla.setColumnCount(3)\r\n\t\t\tself.tabla.setHorizontalHeaderLabels(self.titulos_tabla)\r\n\t\t\tself.tabla.resizeColumnsToContents()\r\n\t\t\tself.tabla.setEnabled(True)\r\n\t\t\tself.tabla.setEditTriggers(QTableWidget.NoEditTriggers)\r\n\r\n\t\t\tself.cb_caras.setEnabled(True)\r\n\t\t\tself.cb_caras.addItems(['1', '2', '3', '4'])\r\n\t\t\tself.cb_caras.setCurrentIndex(0)\r\n\r\n\t\t\tself.pb_calcular.setEnabled(True)\r\n\t\t\tself.actionGuardar_imagen.setEnabled(True)\r\n\t\t\tself.actionCrear_informe.setEnabled(True)\r\n\r\n\t\t\tself.actionBorrar_puntos.setEnabled(True)\r\n\t\t\tself.actionBorrar_escala.setEnabled(True)\r\n\t\t\tself.actionBorrar_l_nea.setEnabled(True)\r\n\r\n\tdef guardar_imagen(self):\r\n\t\tname, _ = QtWidgets.QFileDialog.getSaveFileName(None, \"Guardar Imagen\", \"\", \"PNG(*.png);;JPEG(*.jpg)\")\r\n\t\tif name == \"\":\r\n\t\t\treturn\r\n\t\tif \".\" not in name:\r\n\t\t\tname += \".png\"\r\n\t\tpixmap = QtGui.QPixmap(self.graphicsView.viewport().size())\r\n\t\tself.graphicsView.viewport().render(pixmap)\r\n\t\tpixmap.save(name)\r\n\r\n\tdef close_application(self):\r\n\t\tchoice = QMessageBox.information(None, 'Informaci\u00f3n',\r\n\t\t\t\t\t\t\t\t\t\t \"\u00bfEst\u00e1s seguro de que quieres salir?\", QMessageBox.Yes | QMessageBox.No)\r\n\t\tif choice == QMessageBox.Yes:\r\n\t\t\tsys.exit()\r\n\t\telse:\r\n\t\t\tpass\r\n\r\n\tdef open_preferencias(self):\r\n\t\tself.dlg.show()\r\n\r\n\tdef open_calcular_kc(self):\r\n\t\tself.dlg_kc.show()\r\n\r\n\tdef Ayuda(self):\r\n\t\tos.startfile('Tutorial.pdf')\r\n\r\n\tdef sobre_programa(self):\r\n\t\tself.pop = About()\r\n\t\tself.pop.resize(555, 333)\r\n\t\tself.pop.setWindowTitle(\"Sobre distCarb\")\r\n\t\tself.pop.show()\r\n\r\n\tdef pe(self):\r\n\t\tif self.rb_escala.isChecked():\r\n\t\t\tself.graphicsView.borrarescala()\r\n\t\t\tself.graphicsView.apintar = 1\r\n\r\n\tdef pl(self):\r\n\t\tif self.rb_linea.isChecked():\r\n\t\t\tself.graphicsView.borrarlinea()\r\n\t\t\tself.graphicsView.apintar = 2\r\n\r\n\tdef pp(self):\r\n\t\tif self.rb_puntos.isChecked():\r\n\t\t\tself.graphicsView.apintar = 3\r\n\t\t\tself.pb_borrar.setEnabled(True)\r\n\r\n\tdef rehacer_escala(self):\r\n\t\tself.graphicsView.borrarescala()\r\n\t\tself.graphicsView.apintar = 1\r\n\t\tself.rb_escala.setChecked(True)\r\n\t\tself.rb_escala.setEnabled(True)\r\n\r\n\tdef cosasdeescala(self):\r\n\t\tself.rb_escala.setEnabled(False)\r\n\t\tself.pb_rehacerescala.setEnabled(True)\r\n\r\n\tdef rehacer_linea(self):\r\n\t\tself.graphicsView.borrarlinea()\r\n\t\tself.graphicsView.apintar = 2\r\n\t\tself.rb_linea.setChecked(True)\r\n\t\tself.rb_linea.setEnabled(True)\r\n\r\n\tdef cosasdelinea(self):\r\n\t\tself.rb_linea.setEnabled(False)\r\n\t\tself.pb_rehacerlinea.setEnabled(True)\r\n\r\n\tdef actualizar_preferencias(self):\r\n\t\tself.graphicsView.grosor_escala = self.dlg.numescala\r\n\t\tself.graphicsView.grosor_linea = self.dlg.numlinea\r\n\t\tself.graphicsView.grosor_puntos = self.dlg.numpunto\r\n\r\n\t\tself.graphicsView.color_escala = self.dlg.colorescala\r\n\t\tself.graphicsView.color_linea = self.dlg.colorlinea\r\n\t\tself.graphicsView.color_puntos = self.dlg.colorpuntos\r\n\t\tself.graphicsView.brush.setColor(self.dlg.colorbrush)\r\n\r\n\t\tself.set_color()\r\n\t\tself.repintar_puntos()\r\n\t\tself.repintar_escala()\r\n\t\tself.repintar_linea()\r\n\r\n\tdef ok_escala(self):\r\n\t\ttry:\r\n\t\t\tvalor_escala = int(self.le_escala.text())\r\n\t\t\tself.graphicsView.valor_de_escala = valor_escala\r\n\t\texcept ValueError:\r\n\t\t\tinfo = QMessageBox.information(None, 'Informaci\u00f3n', \"Has de introducir un n\u00famero entero, sin decimales\",\r\n\t\t\t\t\t\t\t\t\t\t   QMessageBox.Ok)\r\n\t\t\tif info == QMessageBox.Ok:\r\n\t\t\t\tself.le_escala.clear()\r\n\r\n\tdef gestionar_puntos(self):\r\n\t\tif self.cb_caras.currentIndex() == 0:\r\n\t\t\tself.graphicsView.elipses_cara_1.append(self.graphicsView.elipse)\r\n\t\t\tself.graphicsView.puntos_1.append(self.graphicsView.position)\r\n\t\tif self.cb_caras.currentIndex() == 1:\r\n\t\t\tself.graphicsView.elipses_cara_2.append(self.graphicsView.elipse)\r\n\t\t\tself.graphicsView.puntos_2.append(self.graphicsView.position)\r\n\t\tif self.cb_caras.currentIndex() == 2:\r\n\t\t\tself.graphicsView.elipses_cara_3.append(self.graphicsView.elipse)\r\n\t\t\tself.graphicsView.puntos_3.append(self.graphicsView.position)\r\n\t\tif self.cb_caras.currentIndex() == 3:\r\n\t\t\tself.graphicsView.elipses_cara_4.append(self.graphicsView.elipse)\r\n\t\t\tself.graphicsView.puntos_4.append(self.graphicsView.position)\r\n\r\n\t\tself.calcular()\r\n\r\n\tdef calcular(self):\r\n\t\t\"\"\"\r\n\t\tC\u00e1lculo de la distancia entre los dos puntos de la escala, del valor del segmento o longitud de la escala\r\n\t\t\"\"\"\r\n\t\t\"\"\"\r\n\t\ty = mx + b\r\n\t\t\"\"\"\r\n\t\tif len(self.graphicsView.linea) > 1:\r\n\t\t\tm = (self.graphicsView.linea[3] - self.graphicsView.linea[1]) / (\r\n\t\t\t\t\t\tself.graphicsView.linea[2] - self.graphicsView.linea[0])\r\n\t\t\tb = self.graphicsView.linea[1] - (m * self.graphicsView.linea[0])\r\n\t\t\tif self.cb_caras.currentIndex() == 0:\r\n\t\t\t\tself.distancias = self.graphicsView.distancias_1\r\n\t\t\t\tself.distanciasreales = self.graphicsView.distanciasreales_1\r\n\t\t\t\tself.puntos = self.graphicsView.puntos_1\r\n\t\t\tif self.cb_caras.currentIndex() == 1:\r\n\t\t\t\tself.distancias = self.graphicsView.distancias_2\r\n\t\t\t\tself.distanciasreales = self.graphicsView.distanciasreales_2\r\n\t\t\t\tself.puntos = self.graphicsView.puntos_2\r\n\t\t\tif self.cb_caras.currentIndex() == 2:\r\n\t\t\t\tself.distancias = self.graphicsView.distancias_3\r\n\t\t\t\tself.distanciasreales = self.graphicsView.distanciasreales_3\r\n\t\t\t\tself.puntos = self.graphicsView.puntos_3\r\n\t\t\tif self.cb_caras.currentIndex() == 3:\r\n\t\t\t\tself.distancias = self.graphicsView.distancias_4\r\n\t\t\t\tself.distanciasreales = self.graphicsView.distanciasreales_4\r\n\t\t\t\tself.puntos = self.graphicsView.puntos_4\r\n\r\n\t\t\tself.dist(m, b, self.distancias, self.distanciasreales, self.puntos)\r\n\r\n\t\t\"\"\"\r\n\t\tMucho ojo porque las coordenadas reales en la foto son (x, -y). El (0,0) es la esquina superior izquierda\r\n\t\t\"\"\"\r\n\r\n\t\t# self.llenar_tabla()\r\n\t\tself.llenar_tabla()\r\n\r\n\tdef dist(self, m, b, distancias, distanciasreales, puntos):\r\n\r\n\t\tdistancias.clear()\r\n\t\tdistanciasreales.clear()\r\n\t\tfor pto in puntos:\r\n\t\t\tdist = abs(m * pto.x() - pto.y() + b) / np.sqrt((m ** 2) + 1)\r\n\t\t\tdistancias.append(dist)\r\n\t\tif self.graphicsView.existeescala and self.graphicsView.valor_de_escala:\r\n\t\t\tself.d_escala_pix = ((self.graphicsView.escala[2] - self.graphicsView.escala[0]) ** 2 +\r\n\t\t\t\t\t\t\t\t (self.graphicsView.escala[3] - self.graphicsView.escala[1]) ** 2) ** (0.5)\r\n\t\t\tfor i in distancias:\r\n\t\t\t\tdist_real = (self.graphicsView.valor_de_escala * i) / self.d_escala_pix\r\n\t\t\t\tdistanciasreales.append(dist_real)\r\n\t\t\t\tprint(dist_real)\r\n\t\telse:\r\n\t\t\tpass\r\n\r\n\tdef llenar_tabla(self):\r\n\t\tif self.cb_caras.currentIndex() == 0:\r\n\t\t\tself.puntos = self.graphicsView.puntos_1\r\n\t\t\tself.distancias = self.graphicsView.distancias_1\r\n\t\t\tself.distanciasreales = self.graphicsView.distanciasreales_1\r\n\t\tif self.cb_caras.currentIndex() == 1:\r\n\t\t\tself.puntos = self.graphicsView.puntos_2\r\n\t\t\tself.distancias = self.graphicsView.distancias_2\r\n\t\t\tself.distanciasreales = self.graphicsView.distanciasreales_2\r\n\t\tif self.cb_caras.currentIndex() == 2:\r\n\t\t\tself.puntos = self.graphicsView.puntos_3\r\n\t\t\tself.distancias = self.graphicsView.distancias_3\r\n\t\t\tself.distanciasreales = self.graphicsView.distanciasreales_3\r\n\t\tif self.cb_caras.currentIndex() == 3:\r\n\t\t\tself.puntos = self.graphicsView.puntos_4\r\n\t\t\tself.distancias = self.graphicsView.distancias_4\r\n\t\t\tself.distanciasreales = self.graphicsView.distanciasreales_4\r\n\r\n\t\tn = 0\r\n\t\tself.tabla.setRowCount(len(self.puntos))\r\n\t\tfor item in self.puntos:\r\n\t\t\tself.tabla.setItem(n, 0, QTableWidgetItem(str(int(item.x())) + \" , \" + str(int(item.y()))))\r\n\t\t\tself.tabla.resizeColumnsToContents()\r\n\t\t\tn += 1\r\n\t\tif self.graphicsView.existelinea:\r\n\t\t\tm = 0\r\n\t\t\tfor elemento in self.distancias:\r\n\t\t\t\tself.tabla.setItem(m, 1, QTableWidgetItem(str(int(elemento))))\r\n\t\t\t\tself.tabla.resizeColumnsToContents()\r\n\t\t\t\tm += 1\r\n\t\tif self.graphicsView.existeescala:\r\n\t\t\tk = 0\r\n\t\t\tfor element in self.distanciasreales:\r\n\t\t\t\tredondeados = round(element, 2)\r\n\t\t\t\tself.tabla.setItem(k, 2, QTableWidgetItem(str(redondeados)))\r\n\t\t\t\tself.tabla.resizeColumnsToContents()\r\n\t\t\t\tk += 1\r\n\r\n\tdef report(self):\r\n\t\tfilein = open('plantilla_resultados.txt')\r\n\t\tsrc = Template(filein.read())\r\n\r\n\t\tfecha = QDate.currentDate()\r\n\t\tfecha2 = fecha.toString(Qt.DefaultLocaleLongDate)\r\n\t\ttitle = \"La fotograf\u00eda tratada es la: \" + str(self.filename)\r\n\t\tdate = str(fecha2)\r\n\t\ttodas_distancias_num = self.graphicsView.distanciasreales_1 + self.graphicsView.distanciasreales_2 + \\\r\n\t\t\t\t\t\t\t   self.graphicsView.distanciasreales_3 + self.graphicsView.distanciasreales_4\r\n\t\tprint(todas_distancias_num)\r\n\t\tdistancias = [str(x) for x in todas_distancias_num]\r\n\t\tprint(distancias)\r\n\t\tmedia = np.mean(todas_distancias_num)\r\n\t\tprint(media)\r\n\t\tdistancia_media = str(media)\r\n\t\tprint(distancia_media)\r\n\r\n\t\tn = len(todas_distancias_num)\r\n\t\tprint(n)\r\n\r\n\t\tpmax = np.amax(todas_distancias_num)\r\n\t\tprint(pmax)\r\n\r\n\t\ttiempo = self.dlg_kc.le_tiempo.text()\r\n\t\tprint(tiempo)\r\n\t\t# caras = \"4\"\r\n\t\tcaras = self.check()\r\n\t\tkc = self.coeficiente\r\n\t\tun_tiempo = \"d\u00edas\"\r\n\t\tun_distancia = \"mm\"\r\n\t\tif self.unidades_tiempo == 1:\r\n\t\t\tun_tiempo = \"semanas\"\r\n\t\tif self.unidades_tiempo == 2:\r\n\t\t\tun_tiempo = \"meses\"\r\n\t\tif self.unidades_tiempo == 3:\r\n\t\t\tun_tiempo = \"a\u00f1os\"\r\n\t\tif self.unidades_distancia == 1:\r\n\t\t\tun_distancia = \"cm\"\r\n\t\tun_kc = str(un_distancia) + \"/RAIZ(\" + str(un_tiempo) + \")\"\r\n\t\td = {'title': title, 'date': date, 'distancias': '\\n'.join(distancias), 'distancia_media': distancia_media,\r\n\t\t\t \"n\": n, \"pmax\": pmax, \"tiempo\": tiempo, \"un_tiempo\": un_tiempo, \"caras\": caras, \"Kc\": kc, \"un_kc\": un_kc}\r\n\t\tresult = src.substitute(d)\r\n\r\n\t\tname, _ = QFileDialog.getSaveFileName(None, 'Save file', \"\", \"Text Files (*.txt)\")\r\n\t\tfilename = QFileInfo(name).fileName()\r\n\t\tif filename:\r\n\t\t\tfile = open(name, 'w')\r\n\t\t\ttext = result\r\n\t\t\tfile.write(text)\r\n\t\t\tfile.close()\r\n\r\n\tdef borrar_punto(self):\r\n\t\tselected = self.tabla.currentRow()\r\n\t\tprint(selected)\r\n\t\tif selected != -1 and self.tabla.selectedItems():\r\n\t\t\tif self.cb_caras.currentIndex() == 0:\r\n\t\t\t\tself.lista = self.graphicsView.elipses_cara_1\r\n\t\t\t\tself.puntos = self.graphicsView.puntos_1\r\n\t\t\tif self.cb_caras.currentIndex() == 1:\r\n\t\t\t\tself.lista = self.graphicsView.elipses_cara_2\r\n\t\t\t\tself.puntos = self.graphicsView.puntos_2\r\n\t\t\tif self.cb_caras.currentIndex() == 2:\r\n\t\t\t\tself.lista = self.graphicsView.elipses_cara_3\r\n\t\t\t\tself.puntos = self.graphicsView.puntos_3\r\n\t\t\tif self.cb_caras.currentIndex() == 3:\r\n\t\t\t\tself.lista = self.graphicsView.elipses_cara_4\r\n\t\t\t\tself.puntos = self.graphicsView.puntos_4\r\n\r\n\t\t\tself.graphicsView.scene.removeItem(self.lista[selected])  # funciona\r\n\t\t\t# self.graphicsView.scene.removeItem(self.puntos[selected])\r\n\t\t\t\"\"\"\r\n\t\t\taqu\u00ed est\u00e1 el fallo. probar algo del estilo removeitemat\r\n\t\t\t\"\"\"\r\n\t\t\t# x = self.puntos[selected][0]\r\n\t\t\t# y = self.puntos[selected][1]\r\n\t\t\t# self.item = self.graphicsView.scene.itemAt(x, y)\r\n\t\t\t# self.graphicsView.scene.removeItem(self.item)\r\n\r\n\t\t\tdel self.lista[selected]\r\n\t\t\tdel self.puntos[selected]\r\n\t\t\tself.tabla.removeRow(selected)\r\n\t\t\tprint(\"borrar punto\")\r\n\t\t\tprint(self.puntos)\r\n\t\tif self.label_puntos:\r\n\t\t\tself.label.deleteLater()\r\n\t\t\tself.label_puntos = False\r\n\r\n\tdef anim_start(self):\r\n\t\tif self.label_puntos:\r\n\t\t\tself.label.deleteLater()\r\n\r\n\t\tselected = self.tabla.currentRow()\r\n\t\tif self.cb_caras.currentIndex() == 0:\r\n\t\t\tself.puntos = self.graphicsView.puntos_1\r\n\t\tif self.cb_caras.currentIndex() == 1:\r\n\t\t\tself.puntos = self.graphicsView.puntos_2\r\n\t\tif self.cb_caras.currentIndex() == 2:\r\n\t\t\tself.puntos = self.graphicsView.puntos_3\r\n\t\tif self.cb_caras.currentIndex() == 3:\r\n\t\t\tself.puntos = self.graphicsView.puntos_4\r\n\r\n\t\tx = str(int(self.puntos[selected].x()))\r\n\t\ty = str(int(self.puntos[selected].y()))\r\n\t\tcoordenadas = x + ', ' + y\r\n\r\n\t\tself.label = MyLabel(coordenadas)\r\n\t\tfont = self.label.font()\r\n\t\tfont.setPointSize(self.graphicsView.grosor_puntos)\r\n\t\tself.label.setFont(font)\r\n\t\tself.graphicsView.scene.addWidget(self.label)\r\n\t\tself.label.move(self.puntos[selected].x(), self.puntos[selected].y())\r\n\r\n\t\tself.anim = QPropertyAnimation(self.label, b\"color\")\r\n\t\tself.anim.setDuration(2500)\r\n\t\tself.anim.setLoopCount(2)\r\n\t\tself.anim.setStartValue(QColor(0, 0, 0))\r\n\t\tself.anim.setEndValue(QColor(255, 255, 255))\r\n\t\tself.anim.start()\r\n\t\tself.label_puntos = True\r\n\r\n\tdef limpiar(self):\r\n\t\tif self.label_puntos:\r\n\t\t\tself.label.deleteLater()\r\n\t\t\tself.label_puntos = False\r\n\t\telse:\r\n\t\t\tpass\r\n\r\n\tdef borrar_puntos_lista_cara(self):\r\n\t\tif self.cb_caras.currentIndex() == 0:\r\n\t\t\tself.lista_e = self.graphicsView.elipses_cara_1\r\n\t\t\tself.lista_p = self.graphicsView.puntos_1\r\n\t\tif self.cb_caras.currentIndex() == 1:\r\n\t\t\tself.lista_e = self.graphicsView.elipses_cara_2\r\n\t\t\tself.lista_p = self.graphicsView.puntos_2\r\n\t\tif self.cb_caras.currentIndex() == 2:\r\n\t\t\tself.lista_e = self.graphicsView.elipses_cara_3\r\n\t\t\tself.lista_p = self.graphicsView.puntos_3\r\n\t\tif self.cb_caras.currentIndex() == 3:\r\n\t\t\tself.lista_e = self.graphicsView.elipses_cara_4\r\n\t\t\tself.lista_p = self.graphicsView.puntos_4\r\n\t\tfor n in self.lista_e:\r\n\t\t\tself.graphicsView.scene.removeItem(n)\r\n\t\t\tself.lista_e.clear()\r\n\t\t\tself.lista_p.clear()\r\n\t\tprint(self.lista_e, self.lista_p)\r\n\t\tself.calcular()\r\n\t\t# self.llenar_tabla2()\r\n\r\n\tdef set_color(self):\r\n\t\tif self.graphicsView.color_escala == 0:\r\n\t\t\tself.graphicsView.pen_escala.setColor(Qt.green)\r\n\t\telif self.graphicsView.color_escala == 1:\r\n\t\t\tself.graphicsView.pen_escala.setColor(Qt.red)\r\n\t\telif self.graphicsView.color_escala == 2:\r\n\t\t\tself.graphicsView.pen_escala.setColor(Qt.blue)\r\n\t\telif self.graphicsView.color_escala == 3:\r\n\t\t\tself.graphicsView.pen_escala.setColor(Qt.yellow)\r\n\t\telif self.graphicsView.color_escala == 4:\r\n\t\t\tself.graphicsView.pen_escala.setColor(Qt.black)\r\n\t\telif self.graphicsView.color_escala == 5:\r\n\t\t\tself.graphicsView.pen_escala.setColor(Qt.white)\r\n\r\n\t\tif self.graphicsView.color_linea == 0:\r\n\t\t\tself.graphicsView.pen_linea.setColor(Qt.red)\r\n\t\telif self.graphicsView.color_linea == 1:\r\n\t\t\tself.graphicsView.pen_linea.setColor(Qt.green)\r\n\t\telif self.graphicsView.color_linea == 2:\r\n\t\t\tself.graphicsView.pen_linea.setColor(Qt.blue)\r\n\t\telif self.graphicsView.color_linea == 3:\r\n\t\t\tself.graphicsView.pen_linea.setColor(Qt.yellow)\r\n\t\telif self.graphicsView.color_linea == 4:\r\n\t\t\tself.graphicsView.pen_linea.setColor(Qt.black)\r\n\t\telif self.graphicsView.color_linea == 5:\r\n\t\t\tself.graphicsView.pen_linea.setColor(Qt.white)\r\n\r\n\t\tif self.graphicsView.color_puntos == 0:\r\n\t\t\tself.graphicsView.pen_punto.setColor(Qt.red)\r\n\t\t\tself.graphicsView.brush.setColor(Qt.red)\r\n\t\telif self.graphicsView.color_puntos == 1:\r\n\t\t\tself.graphicsView.pen_punto.setColor(Qt.green)\r\n\t\t\tself.graphicsView.brush.setColor(Qt.green)\r\n\t\telif self.graphicsView.color_puntos == 2:\r\n\t\t\tself.graphicsView.pen_punto.setColor(Qt.blue)\r\n\t\t\tself.graphicsView.brush.setColor(Qt.blue)\r\n\t\telif self.graphicsView.color_puntos == 3:\r\n\t\t\tself.graphicsView.pen_punto.setColor(Qt.yellow)\r\n\t\t\tself.graphicsView.brush.setColor(Qt.yellow)\r\n\t\telif self.graphicsView.color_puntos == 4:\r\n\t\t\tself.graphicsView.pen_punto.setColor(Qt.black)\r\n\t\t\tself.graphicsView.brush.setColor(Qt.black)\r\n\t\telif self.graphicsView.color_puntos == 5:\r\n\t\t\tself.graphicsView.pen_punto.setColor(Qt.white)\r\n\t\t\tself.graphicsView.brush.setColor(Qt.white)\r\n\r\n\tdef repintar_puntos(self):\r\n\t\t\"\"\"\r\n\t\tprimero: eliminar todos los puntos de la escena\r\n\t\tsegundo: repintar todos los puntos en la escena\r\n\t\t\"\"\"\r\n\t\tnewpos = 0.5 * self.graphicsView.grosor_puntos\r\n\r\n\t\tfor n in self.graphicsView.elipses_cara_1:\r\n\t\t\tself.graphicsView.scene.removeItem(n)\r\n\t\tself.graphicsView.elipses_cara_1.clear()\r\n\t\tfor m in self.graphicsView.puntos_1:\r\n\t\t\tself.elipse = QGraphicsEllipseItem()\r\n\t\t\tself.elipse.setRect(m.x() - newpos, m.y() - newpos, self.graphicsView.grosor_puntos,\r\n\t\t\t\t\t\t\t\tself.graphicsView.grosor_puntos)\r\n\t\t\tself.elipse.setPen(self.graphicsView.pen_punto)\r\n\t\t\tself.elipse.setBrush(self.graphicsView.brush)\r\n\t\t\tself.graphicsView.scene.addItem(self.elipse)\r\n\t\t\tself.graphicsView.elipses_cara_1.append(self.elipse)\r\n\t\tfor n2 in self.graphicsView.elipses_cara_2:\r\n\t\t\tself.graphicsView.scene.removeItem(n2)\r\n\t\tself.graphicsView.elipses_cara_2.clear()\r\n\t\tfor m2 in self.graphicsView.puntos_2:\r\n\t\t\tself.elipse = QGraphicsEllipseItem()\r\n\t\t\tself.elipse.setRect(m2.x() - newpos, m2.y() - newpos, self.graphicsView.grosor_puntos,\r\n\t\t\t\t\t\t\t\tself.graphicsView.grosor_puntos)\r\n\t\t\tself.elipse.setPen(self.graphicsView.pen_punto)\r\n\t\t\tself.elipse.setBrush(self.graphicsView.brush)\r\n\t\t\tself.graphicsView.scene.addItem(self.elipse)\r\n\t\t\tself.graphicsView.elipses_cara_2.append(self.elipse)\r\n\t\tfor n3 in self.graphicsView.elipses_cara_3:\r\n\t\t\tself.graphicsView.scene.removeItem(n3)\r\n\t\tself.graphicsView.elipses_cara_3.clear()\r\n\t\tfor m3 in self.graphicsView.puntos_3:\r\n\t\t\tself.elipse = QGraphicsEllipseItem()\r\n\t\t\tself.elipse.setRect(m3.x() - newpos, m3.y() - newpos, self.graphicsView.grosor_puntos,\r\n\t\t\t\t\t\t\t\tself.graphicsView.grosor_puntos)\r\n\t\t\tself.elipse.setPen(self.graphicsView.pen_punto)\r\n\t\t\tself.elipse.setBrush(self.graphicsView.brush)\r\n\t\t\tself.graphicsView.scene.addItem(self.elipse)\r\n\t\t\tself.graphicsView.elipses_cara_3.append(self.elipse)\r\n\t\tfor n4 in self.graphicsView.elipses_cara_4:\r\n\t\t\tself.graphicsView.scene.removeItem(n4)\r\n\t\tself.graphicsView.elipses_cara_4.clear()\r\n\t\tfor m4 in self.graphicsView.puntos_4:\r\n\t\t\tself.elipse = QGraphicsEllipseItem()\r\n\t\t\tself.elipse.setRect(m4.x() - newpos, m4.y() - newpos, self.graphicsView.grosor_puntos,\r\n\t\t\t\t\t\t\t\tself.graphicsView.grosor_puntos)\r\n\t\t\tself.elipse.setPen(self.graphicsView.pen_punto)\r\n\t\t\tself.elipse.setBrush(self.graphicsView.brush)\r\n\t\t\tself.graphicsView.scene.addItem(self.elipse)\r\n\t\t\tself.graphicsView.elipses_cara_4.append(self.elipse)\r\n\r\n\t\tself.calcular()\r\n\r\n\tdef repintar_escala(self):\r\n\t\t\"\"\"\r\n\t\tpongo el try-except porque si no he dibujado previamente la escala, crashea al aceptar las preferencias\r\n\t\t\"\"\"\r\n\t\ttry:\r\n\t\t\t# if self.graphicsView.laescala:\r\n\t\t\tself.set_color()\r\n\r\n\t\t\tself.escala_nueva = self.graphicsView.laescala\r\n\t\t\tself.graphicsView.scene.removeItem(self.graphicsView.laescala)\r\n\t\t\tself.graphicsView.pen_escala.setWidth(self.graphicsView.grosor_escala)\r\n\t\t\tself.escala_nueva.setPen(self.graphicsView.pen_escala)\r\n\t\t\tself.graphicsView.scene.addItem(self.escala_nueva)\r\n\t\t\tself.graphicsView.laescala = self.escala_nueva\r\n\t\t\tprint(self.graphicsView.laescala)\r\n\t\t\tprint(self.escala_nueva)\r\n\t\texcept:\r\n\t\t\tpass\r\n\r\n\tdef repintar_linea(self):\r\n\t\ttry:\r\n\t\t\tself.set_color()\r\n\r\n\t\t\tself.linea_nueva = self.graphicsView.lalinea\r\n\t\t\tself.graphicsView.scene.removeItem(self.graphicsView.lalinea)\r\n\t\t\tself.graphicsView.pen_linea.setWidth(self.graphicsView.grosor_linea)\r\n\t\t\tself.linea_nueva.setPen(self.graphicsView.pen_linea)\r\n\t\t\tself.graphicsView.scene.addItem(self.linea_nueva)\r\n\t\t\tself.graphicsView.lalinea = self.linea_nueva\r\n\t\texcept:\r\n\t\t\tpass\r\n\r\n\tdef check(self):\r\n\t\t\"\"\"\r\n\t\tFunici\u00f3n para comprobar el n\u00famero de caras, de distancias reales tengo\r\n\t\t\"\"\"\r\n\t\tself.cuenta = 0\r\n\t\tif self.graphicsView.distanciasreales_1:\r\n\t\t\t# self.distancias_cara_1 = True\r\n\t\t\tself.cuenta += 1\r\n\t\tif self.graphicsView.distanciasreales_2:\r\n\t\t\t# self.distancias_cara_2 = True\r\n\t\t\tself.cuenta += 1\r\n\t\tif self.graphicsView.distanciasreales_3:\r\n\t\t\t# self.distancias_cara_3 = True\r\n\t\t\tself.cuenta += 1\r\n\t\tif self.graphicsView.distanciasreales_4:\r\n\t\t\t# self.distancias_cara_4 = True\r\n\t\t\tself.cuenta += 1\r\n\t\telse:\r\n\t\t\tprint(\"chekeado\")\r\n\t\t\tpass\r\n\t\treturn self.cuenta\r\n\r\n\tdef prueba (self):\r\n\t\tprint(self.cuenta)\r\n\r\n\tdef actualizar_kc(self):\r\n\t\tself.coeficiente = self.dlg_kc.resultado\r\n\t\tself.unidades_tiempo = self.dlg_kc.unidades_tiempo\r\n\t\tself.unidades_distancia = self.dlg_kc.unidades_distancia\r\n\r\n", "description": "\r\n\t\tQuito todo lo relativo al GraphicsView de Main.py y lo traigo aqu\u00ed\r\n\t\t", "category": "graphics", "imports": ["from PyQt5 import QtCore, QtGui, QtWidgets\r", "from PyQt5.QtCore import pyqtSignal, QFileInfo, Qt, QDate, QPropertyAnimation, QPointF\r", "from PyQt5.QtWidgets import QApplication, QMainWindow, QMessageBox, QFileDialog, QTableWidget, QTableWidgetItem, \\\r", "from Main3 import Ui_MainWindow\r", "from MiGV3 import MiGraphicsView\r", "from pdC3 import Ui_Preferencias\r", "from Kc2 import Ui_Dialog\r", "import numpy as np\r", "from string import Template\r", "import sys, os, time\r", "from PyQt5.QtGui import QColor\r", "from PyQt5.QtCore import QPropertyAnimation, pyqtProperty\r"]}, {"term": "class", "name": "MyLabel", "data": "class MyLabel(QtWidgets.QLabel):\r\n\r\n\tdef __init__(self, text):\r\n\t\tsuper().__init__(text)\r\n\r\n\tdef _set_color(self, col):\r\n\t\tpalette = self.palette()\r\n\t\tpalette.setColor(self.foregroundRole(), col)\r\n\t\t# palette.setColor(self.foregroundRole(), None)\r\n\t\tself.setPalette(palette)\r\n\r\n\tcolor = pyqtProperty(QColor, fset=_set_color)\r\n\r\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore, QtGui, QtWidgets\r", "from PyQt5.QtCore import pyqtSignal, QFileInfo, Qt, QDate, QPropertyAnimation, QPointF\r", "from PyQt5.QtWidgets import QApplication, QMainWindow, QMessageBox, QFileDialog, QTableWidget, QTableWidgetItem, \\\r", "from Main3 import Ui_MainWindow\r", "from MiGV3 import MiGraphicsView\r", "from pdC3 import Ui_Preferencias\r", "from Kc2 import Ui_Dialog\r", "import numpy as np\r", "from string import Template\r", "import sys, os, time\r", "from PyQt5.QtGui import QColor\r", "from PyQt5.QtCore import QPropertyAnimation, pyqtProperty\r"]}, {"term": "class", "name": "pref", "data": "class pref(QtWidgets.QDialog, Ui_Preferencias):\r\n\tsenyal_cambios_preferencias = pyqtSignal()\r\n\r\n\tdef __init__(self):\r\n\t\tsuper(pref, self).__init__()\r\n\t\tself.setupUi(self)\r\n\r\n\t\tself.numescala_previo = 1\r\n\t\tself.numlinea_previo = 1\r\n\t\tself.numpunto_previo = 1\r\n\r\n\t\tself.colorescala_previo = 0\r\n\t\tself.colorlinea_previo = 0\r\n\t\tself.colorpuntos_previo = 0\r\n\t\tself.colorbrush_previo = 0\r\n\r\n\t\tself.pb_aceptar.clicked.connect(self.actualizar)\r\n\t\tself.pb_cancelar.clicked.connect(self.cancelar_preferencias)\r\n\r\n\t\tself.cb_color_escala.addItems([\"verde\", \"rojo\", \"azul\", \"amarillo\", \"negro\", \"blanco\"])\r\n\t\tself.cb_color_base.addItems([\"rojo\", \"verde\", \"azul\", \"amarillo\", \"negro\", \"blanco\"])\r\n\t\tself.cb_color_puntos.addItems([\"rojo\", \"verde\", \"azul\", \"amarillo\", \"negro\", \"blanco\"])\r\n\r\n\tdef actualizar(self):\r\n\t\tself.numescala = self.sb_grosor_escala.value()\r\n\t\tself.numlinea = self.sb_grosor_base.value()\r\n\t\tself.numpunto = self.sb_grosor_puntos.value()\r\n\r\n\t\tself.numescala_previo = self.sb_grosor_escala.value()\r\n\t\tself.numlinea_previo = self.sb_grosor_base.value()\r\n\t\tself.numpunto_previo = self.sb_grosor_puntos.value()\r\n\r\n\t\tself.colorescala = self.cb_color_escala.currentIndex()\r\n\t\tself.colorlinea = self.cb_color_base.currentIndex()\r\n\t\tself.colorpuntos = self.cb_color_puntos.currentIndex()\r\n\t\tself.colorbrush = self.cb_color_puntos.currentIndex()\r\n\r\n\t\tself.colorescala_previo = self.cb_color_escala.currentIndex()\r\n\t\tself.colorlinea_previo = self.cb_color_base.currentIndex()\r\n\t\tself.colorpuntos_previo = self.cb_color_puntos.currentIndex()\r\n\t\tself.colorbrush_previo = self.cb_color_puntos.currentIndex()\r\n\r\n\t\tself.senyal_cambios_preferencias.emit()\r\n\t\tpref.close(self)\r\n\r\n\tdef cancelar_preferencias(self):\r\n\t\tself.sb_grosor_escala.setValue(self.numescala_previo)\r\n\t\tself.sb_grosor_base.setValue(self.numlinea_previo)\r\n\t\tself.sb_grosor_puntos.setValue(self.numpunto_previo)\r\n\r\n\t\tself.cb_color_escala.setCurrentIndex(self.colorescala_previo)\r\n\t\tself.cb_color_base.setCurrentIndex(self.colorlinea_previo)\r\n\t\tself.cb_color_puntos.setCurrentIndex(self.colorpuntos_previo)\r\n\r\n\t\tpref.close(self)\r\n\r\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore, QtGui, QtWidgets\r", "from PyQt5.QtCore import pyqtSignal, QFileInfo, Qt, QDate, QPropertyAnimation, QPointF\r", "from PyQt5.QtWidgets import QApplication, QMainWindow, QMessageBox, QFileDialog, QTableWidget, QTableWidgetItem, \\\r", "from Main3 import Ui_MainWindow\r", "from MiGV3 import MiGraphicsView\r", "from pdC3 import Ui_Preferencias\r", "from Kc2 import Ui_Dialog\r", "import numpy as np\r", "from string import Template\r", "import sys, os, time\r", "from PyQt5.QtGui import QColor\r", "from PyQt5.QtCore import QPropertyAnimation, pyqtProperty\r"]}, {"term": "class", "name": "Calc_coef", "data": "class Calc_coef(QtWidgets.QDialog, Ui_Dialog):\r\n\tsenyal_kc = pyqtSignal()\r\n\r\n\tdef __init__(self, lista1, lista2, lista3, lista4, parent = None):\r\n\t\tsuper(Calc_coef, self).__init__()\r\n\t\tself.setupUi(self)\r\n\t\tself.resultado = None\r\n\t\tself.unidades_tiempo = None\r\n\t\tself.unidades_distancia = None\r\n\r\n\t\tself.cb_unidades_distancia.addItems([\"mil\u00edmetros (mm)\", \"cent\u00edmetros (cm)\"])\r\n\t\tself.cb_unidades_tiempo.addItems([\"d\u00edas\", \"semanas\", \"meses\", \"a\u00f1os\"])\r\n\r\n\t\tself.lista1 = lista1\r\n\t\tself.lista2 = lista2\r\n\t\tself.lista3 = lista3\r\n\t\tself.lista4 = lista4\r\n\r\n\t\tself.cBox_1.stateChanged.connect(self.calculo_Kc)\r\n\t\tself.cBox_2.stateChanged.connect(self.calculo_Kc)\r\n\t\tself.cBox_3.stateChanged.connect(self.calculo_Kc)\r\n\t\tself.cBox_4.stateChanged.connect(self.calculo_Kc)\r\n\r\n\t\tself.kc1 = None\r\n\t\tself.kc2 = None\r\n\t\tself.kc3 = None\r\n\t\tself.kc4 = None\r\n\t\tself.kc12 = None\r\n\t\tself.kc13 = None\r\n\t\tself.kc14 = None\r\n\t\tself.kc23 = None\r\n\t\tself.kc24 = None\r\n\t\tself.kc34 = None\r\n\t\tself.kc123 = None\r\n\t\tself.kc124 = None\r\n\t\tself.kc134 = None\r\n\t\tself.kc234 = None\r\n\t\tself.kc1234 = None\r\n\r\n\t\tself.pb_guardar.clicked.connect(self.guardar)\r\n\t\tself.pb_calcular.clicked.connect(self.calcular)\r\n\r\n\tdef media(self, lista):\r\n\t\tmedia = 0\r\n\t\tfor n in lista:\r\n\t\t\tmedia = media + n\r\n\t\ttry:\r\n\t\t\tself.lamedia = media/len(lista)\r\n\t\texcept:\r\n\t\t\tself.lamedia = 0\r\n\t\treturn self.lamedia\r\n\r\n\tdef is_number(self, num):\r\n\t\ttry:\r\n\t\t\tfloat(num)\r\n\t\t\treturn True\r\n\t\texcept ValueError:\r\n\t\t\treturn False\r\n\r\n\r\n\tdef calculo_Kc(self):\r\n\t\t\"\"\"\r\n\t\tKc = d/RAIZ(t)\r\n\t\t\"\"\"\r\n\t\tself.media1 = self.media(self.lista1)\r\n\t\tself.media2 = self.media(self.lista2)\r\n\t\tself.media3 = self.media(self.lista3)\r\n\t\tself.media4 = self.media(self.lista4)\r\n\r\n\t\tself.media1_2 = self.media(self.lista1 + self.lista2)\r\n\t\tself.media1_3 = self.media(self.lista1 + self.lista3)\r\n\t\tself.media1_4 = self.media(self.lista1 + self.lista4)\r\n\r\n\t\tself.media2_3 = self.media(self.lista2 + self.lista3)\r\n\t\tself.media2_4 = self.media(self.lista2 + self.lista4)\r\n\r\n\t\tself.media3_4 = self.media(self.lista3 + self.lista4)\r\n\r\n\t\tself.media1_2_3 = self.media(self.lista1 + self.lista2 + self.lista3)\r\n\t\tself.media1_2_4 = self.media(self.lista1 + self.lista2 + self.lista4)\r\n\t\tself.media1_3_4 = self.media(self.lista1 + self.lista3 + self.lista4)\r\n\t\tself.media2_3_4 = self.media(self.lista2 + self.lista3 + self.lista4)\r\n\r\n\t\tself.media1_2_3_4 = self.media(self.lista1 + self.lista2 + self.lista3 + self.lista4)\r\n\r\n\t\tif self.le_tiempo.text() == \"\":\r\n\t\t\tself.lb_resultado.setText(\"Introducir el valor de tiempo\")\r\n\r\n\t\tself.text = self.le_tiempo.text()\r\n\r\n\t\tif self.is_number(self.text):\r\n\t\t\tself.raiz = float(self.text)**0.5\r\n\t\t\tprint(self.raiz)\r\n\t\t\tself.kc1 = self.media1/self.raiz\r\n\t\t\tself.kc2 = self.media2/self.raiz\r\n\t\t\tself.kc3 = self.media3/self.raiz\r\n\t\t\tself.kc4 = self.media4/self.raiz\r\n\t\t\tself.kc12 = self.media1_2/self.raiz\r\n\t\t\tself.kc13 = self.media1_3/self.raiz\r\n\t\t\tself.kc14 = self.media1_4/self.raiz\r\n\t\t\tself.kc23 = self.media2_3/self.raiz\r\n\t\t\tself.kc24 = self.media2_4/self.raiz\r\n\t\t\tself.kc34 = self.media3_4/self.raiz\r\n\t\t\tself.kc123 = self.media1_2_3/self.raiz\r\n\t\t\tself.kc124 = self.media1_2_4/self.raiz\r\n\t\t\tself.kc134 = self.media1_3_4/self.raiz\r\n\t\t\tself.kc234 = self.media2_3_4/self.raiz\r\n\t\t\tself.kc1234 = self.media1_2_3_4/self.raiz\r\n\r\n\t\tself.mostrar_resultado()\r\n\r\n\tdef mostrar_resultado(self):\r\n\t\tif self.is_number(self.text):\r\n\t\t\tprint(\"si tengo valor de tiempo\")\r\n\r\n\t\t\tif self.cBox_1.isChecked():\r\n\t\t\t\tself.lb_resultado.setText(str(self.kc1))\r\n\t\t\tif self.cBox_2.isChecked():\r\n\t\t\t\tself.lb_resultado.setText(str(self.kc2))\r\n\t\t\tif self.cBox_3.isChecked():\r\n\t\t\t\tself.lb_resultado.setText(str(self.kc3))\r\n\t\t\tif self.cBox_4.isChecked():\r\n\t\t\t\tself.lb_resultado.setText(str(self.kc4))\r\n\r\n\t\t\tif self.cBox_1.isChecked() and self.cBox_2.isChecked():\r\n\t\t\t\tself.lb_resultado.setText(str(self.kc12))\r\n\t\t\tif self.cBox_1.isChecked() and self.cBox_3.isChecked():\r\n\t\t\t\tself.lb_resultado.setText(str(self.kc13))\r\n\t\t\tif self.cBox_1.isChecked() and self.cBox_4.isChecked():\r\n\t\t\t\tself.lb_resultado.setText(str(self.kc14))\r\n\t\t\tif self.cBox_2.isChecked() and self.cBox_3.isChecked():\r\n\t\t\t\tself.lb_resultado.setText(str(self.kc23))\r\n\t\t\tif self.cBox_2.isChecked() and self.cBox_4.isChecked():\r\n\t\t\t\tself.lb_resultado.setText(str(self.kc24))\r\n\t\t\tif self.cBox_3.isChecked() and self.cBox_4.isChecked():\r\n\t\t\t\tself.lb_resultado.setText(str(self.kc34))\r\n\r\n\t\t\tif self.cBox_1.isChecked() and self.cBox_2.isChecked() and self.cBox_3.isChecked():\r\n\t\t\t\tself.lb_resultado.setText(str(self.kc123))\r\n\t\t\tif self.cBox_1.isChecked() and self.cBox_2.isChecked() and self.cBox_4.isChecked():\r\n\t\t\t\tself.lb_resultado.setText(str(self.kc124))\r\n\t\t\tif self.cBox_1.isChecked() and self.cBox_3.isChecked() and self.cBox_4.isChecked():\r\n\t\t\t\tself.lb_resultado.setText(str(self.kc134))\r\n\t\t\tif self.cBox_2.isChecked() and self.cBox_3.isChecked() and self.cBox_4.isChecked():\r\n\t\t\t\tself.lb_resultado.setText(str(self.kc234))\r\n\r\n\t\t\tif self.cBox_1.isChecked() and self.cBox_2.isChecked() and self.cBox_3.isChecked() and self.cBox_4.isChecked():\r\n\t\t\t\tself.lb_resultado.setText(str(self.kc1234))\r\n\t\telse:\r\n\t\t\tprint(\"falta el tiempo\")\r\n\r\n\t\t# self.tiempo = self.le_tiempo.text()\r\n\t\t# print(\"el tiempo es \" + self.tiempo)\r\n\r\n\t\t# print(self.kc1)\r\n\r\n\tdef calcular(self):\r\n\t\tself.calculo_Kc()\r\n\t\tprint(\"bot\u00f3n calcular presionado\")\r\n\r\n\tdef guardar(self):\r\n\t\tself.calculo_Kc()\r\n\t\tself.resultado = self.lb_resultado.text()\r\n\t\tself.unidades_tiempo = self.cb_unidades_tiempo.currentIndex()\r\n\t\tself.unidades_distancia = self.cb_unidades_distancia.currentIndex()\r\n\t\tprint(\"bot\u00f3n Guardar pulsado\")\r\n\t\tprint(self.unidades_distancia)\r\n\t\tself.senyal_kc.emit()\r\n\t\tCalc_coef.close(self)\r\n\r\n", "description": "\r\n\t\tKc = d/RAIZ(t)\r\n\t\t", "category": "graphics", "imports": ["from PyQt5 import QtCore, QtGui, QtWidgets\r", "from PyQt5.QtCore import pyqtSignal, QFileInfo, Qt, QDate, QPropertyAnimation, QPointF\r", "from PyQt5.QtWidgets import QApplication, QMainWindow, QMessageBox, QFileDialog, QTableWidget, QTableWidgetItem, \\\r", "from Main3 import Ui_MainWindow\r", "from MiGV3 import MiGraphicsView\r", "from pdC3 import Ui_Preferencias\r", "from Kc2 import Ui_Dialog\r", "import numpy as np\r", "from string import Template\r", "import sys, os, time\r", "from PyQt5.QtGui import QColor\r", "from PyQt5.QtCore import QPropertyAnimation, pyqtProperty\r"]}], [{"term": "class", "name": "classAnimationPlayer:", "data": "class AnimationPlayer:\n\tdef __init__(self):\n\t\t# particle dictionary\n\t\tself.frames = {\n\t\t\t# magic\n\t\t\t\"flame\": import_folder(\"../graphics/particles/flame/frames\"),\n\t\t\t\"aura\": import_folder(\"../graphics/particles/aura\"),\n\t\t\t\"heal\": import_folder(\"../graphics/particles/heal/frames\"),\n\t\t\t# attacks\n\t\t\t\"claw\": import_folder(\"../graphics/particles/claw\"),\n\t\t\t\"slash\": import_folder(\"../graphics/particles/slash\"),\n\t\t\t\"sparkle\": import_folder(\"../graphics/particles/sparkle\"),\n\t\t\t\"leaf_attack\": import_folder(\"../graphics/particles/leaf_attack\"),\n\t\t\t\"thunder\": import_folder(\"../graphics/particles/thunder\"),\n\t\t\t# monster deaths\n\t\t\t\"squid\": import_folder(\"../graphics/particles/smoke_orange\"),\n\t\t\t\"raccoon\": import_folder(\"../graphics/particles/raccoon\"),\n\t\t\t\"spirit\": import_folder(\"../graphics/particles/nova\"),\n\t\t\t\"bamboo\": import_folder(\"../graphics/particles/bamboo\"),\n\t\t\t# leafs\n\t\t\t\"leaf\": (\n\t\t\t\timport_folder(\"../graphics/particles/leaf1\"),\n\t\t\t\timport_folder(\"../graphics/particles/leaf2\"),\n\t\t\t\timport_folder(\"../graphics/particles/leaf3\"),\n\t\t\t\timport_folder(\"../graphics/particles/leaf4\"),\n\t\t\t\timport_folder(\"../graphics/particles/leaf5\"),\n\t\t\t\timport_folder(\"../graphics/particles/leaf6\"),\n\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf1\")),\n\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf2\")),\n\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf3\")),\n\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf4\")),\n\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf5\")),\n\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf6\")),\n\t\t\t),\n\t\t}\n\n\tdef reflect_images(self,frames):\n\t  new_frames=[]\n\n\t  for frame in frames:\n\t\tflipped_frame=pygame.transform.flip(frame, True, False)\n\t\tnew_frames.append(flipped_frame)\n\n\t  return new_frames\n\n\tdef create_grass_particles(self, pos, groups):\n\t  animation_frames=choice(self.frames[\"leaf\"])\n\t  ParticleEffect(pos, animation_frames, groups)\n\n\tdef create_particles(self,animation_type, pos, groups):\n\t  animation_frames=self.frames[animation_type]\n\t  ParticleEffect(pos, animation_frames,groups)\n\n\n", "description": null, "category": "graphics", "imports": ["from random import choice", "import pygame", "from support import import_folder", "\t\t\t\"flame\": import_folder(\"../graphics/particles/flame/frames\"),", "\t\t\t\"aura\": import_folder(\"../graphics/particles/aura\"),", "\t\t\t\"heal\": import_folder(\"../graphics/particles/heal/frames\"),", "\t\t\t\"claw\": import_folder(\"../graphics/particles/claw\"),", "\t\t\t\"slash\": import_folder(\"../graphics/particles/slash\"),", "\t\t\t\"sparkle\": import_folder(\"../graphics/particles/sparkle\"),", "\t\t\t\"leaf_attack\": import_folder(\"../graphics/particles/leaf_attack\"),", "\t\t\t\"thunder\": import_folder(\"../graphics/particles/thunder\"),", "\t\t\t\"squid\": import_folder(\"../graphics/particles/smoke_orange\"),", "\t\t\t\"raccoon\": import_folder(\"../graphics/particles/raccoon\"),", "\t\t\t\"spirit\": import_folder(\"../graphics/particles/nova\"),", "\t\t\t\"bamboo\": import_folder(\"../graphics/particles/bamboo\"),", "\t\t\t\timport_folder(\"../graphics/particles/leaf1\"),", "\t\t\t\timport_folder(\"../graphics/particles/leaf2\"),", "\t\t\t\timport_folder(\"../graphics/particles/leaf3\"),", "\t\t\t\timport_folder(\"../graphics/particles/leaf4\"),", "\t\t\t\timport_folder(\"../graphics/particles/leaf5\"),", "\t\t\t\timport_folder(\"../graphics/particles/leaf6\"),", "\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf1\")),", "\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf2\")),", "\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf3\")),", "\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf4\")),", "\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf5\")),", "\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf6\")),"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\n\tdef __init__(self, pos, animation_frames, groups):\n\t\tsuper().__init__(groups)\n\t\tself.sprite_type=\"magic\"\n\t\tself.frame_index = 0\n\t\tself.animation_speed = 0.15\n\t\tself.frames = animation_frames\n\t\tself.image = self.frames[self.frame_index]\n\t\tself.rect=self.image.get_rect(center=pos)\n\n\tdef animate(self):\n\t\tself.frame_index += self.animation_speed\n\n\t\tif self.frame_index >= len(self.frames):\n\t\t\tself.kill()\n\t\telse:\n\t\t\tself.image = self.frames[int(self.frame_index)]\n\n\tdef update(self):\n\t\tself.animate()\n", "description": null, "category": "graphics", "imports": ["from random import choice", "import pygame", "from support import import_folder", "\t\t\t\"flame\": import_folder(\"../graphics/particles/flame/frames\"),", "\t\t\t\"aura\": import_folder(\"../graphics/particles/aura\"),", "\t\t\t\"heal\": import_folder(\"../graphics/particles/heal/frames\"),", "\t\t\t\"claw\": import_folder(\"../graphics/particles/claw\"),", "\t\t\t\"slash\": import_folder(\"../graphics/particles/slash\"),", "\t\t\t\"sparkle\": import_folder(\"../graphics/particles/sparkle\"),", "\t\t\t\"leaf_attack\": import_folder(\"../graphics/particles/leaf_attack\"),", "\t\t\t\"thunder\": import_folder(\"../graphics/particles/thunder\"),", "\t\t\t\"squid\": import_folder(\"../graphics/particles/smoke_orange\"),", "\t\t\t\"raccoon\": import_folder(\"../graphics/particles/raccoon\"),", "\t\t\t\"spirit\": import_folder(\"../graphics/particles/nova\"),", "\t\t\t\"bamboo\": import_folder(\"../graphics/particles/bamboo\"),", "\t\t\t\timport_folder(\"../graphics/particles/leaf1\"),", "\t\t\t\timport_folder(\"../graphics/particles/leaf2\"),", "\t\t\t\timport_folder(\"../graphics/particles/leaf3\"),", "\t\t\t\timport_folder(\"../graphics/particles/leaf4\"),", "\t\t\t\timport_folder(\"../graphics/particles/leaf5\"),", "\t\t\t\timport_folder(\"../graphics/particles/leaf6\"),", "\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf1\")),", "\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf2\")),", "\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf3\")),", "\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf4\")),", "\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf5\")),", "\t\t\t\tself.reflect_images(import_folder(\"../graphics/particles/leaf6\")),"]}], [{"term": "def", "name": "load_graphics", "data": "def load_graphics():\n\t\"\"\"\n\tLoads graphics from archives into the code\n\t\"\"\"\n\tplayer_graphics = SpriteSheet(BASE_GRAPHICS_DIR + \"player.png\", (59, 45), 236, 45)\n\tzombie_graphics = SpriteSheet(BASE_GRAPHICS_DIR + \"zombie.png\", (45, 45), 90, 45)\n\tgiant_graphics = SpriteSheet(BASE_GRAPHICS_DIR + \"giant.png\", (135, 135), 270, 135)\n\tbat_graphics = SpriteSheet(BASE_GRAPHICS_DIR + \"bat.png\", (64, 64), 256, 64)\n\tmap_graphics = SpriteSheet(BASE_GRAPHICS_DIR + \"jawbreaker.png\", (8, 8), 64, 72)\n\tbag_graphics = SpriteSheet(BASE_GRAPHICS_DIR + \"bag.png\", (102, 84), 102, 84)\n\tmap_night_graphics = SpriteSheet(BASE_GRAPHICS_DIR + \"jawbreaker_night.png\", (8, 8), 64, 72)\n\titems_graphics = SpriteSheet(BASE_GRAPHICS_DIR + \"items.png\", (32, 32), 352, 32)\n\tbullets_graphics = SpriteSheet(BASE_GRAPHICS_DIR + \"firebullet.png\", (16, 16), 512, 272)\n\tstatus_bar_graphics = SpriteSheet(BASE_GRAPHICS_DIR + \"status_bar.png\", (800, 100), 800, 100)\n\tbutton_graphics = SpriteSheet(BASE_GRAPHICS_DIR + \"button.png\", (34, 10), 68, 10)\n\tmenu_about_graphics = pygame.image.load(BASE_GRAPHICS_DIR + \"menu_about.png\")\n\n\ttitle_graphics = [pygame.image.load(BASE_GRAPHICS_DIR + \"title_1.png\"),\n\t\t\t\t\t pygame.image.load(BASE_GRAPHICS_DIR + \"title_2.png\"),\n\t\t\t\t\t pygame.image.load(BASE_GRAPHICS_DIR + \"title_3.png\"),\n\t\t\t\t\t pygame.image.load(BASE_GRAPHICS_DIR + \"title_4.png\"),\n\t\t\t\t\t pygame.image.load(BASE_GRAPHICS_DIR + \"title_5.png\")]\n\tpause_button_graphics = [pygame.transform.scale(pygame.image.load(BASE_GRAPHICS_DIR + \"black_pause.png\"), (40, 40)),\n\t\t\t\t\t\t\t pygame.transform.scale(pygame.image.load(BASE_GRAPHICS_DIR + \"white_pause.png\"), (40, 40))]\n\tquit_button_graphics = [pygame.transform.scale(pygame.image.load(BASE_GRAPHICS_DIR + \"black_home.png\"), (40, 40)),\n\t\t\t\t\t\t\tpygame.transform.scale(pygame.image.load(BASE_GRAPHICS_DIR + \"white_home.png\"), (40, 40))]\n\n\tgraphics_dict[\"player\"] = player_graphics\n\tgraphics_dict[\"zombie\"] = zombie_graphics\n\tgraphics_dict[\"giant\"] = giant_graphics\n\tgraphics_dict[\"bat\"] = bat_graphics\n\tgraphics_dict[\"bag\"] = bag_graphics\n\tgraphics_dict[\"map\"] = map_graphics\n\tgraphics_dict[\"map_night\"] = map_night_graphics\n\tgraphics_dict[\"items\"] = items_graphics\n\tgraphics_dict[\"bullets\"] = bullets_graphics\n\tgraphics_dict[\"status_bar\"] = status_bar_graphics\n\tgraphics_dict[\"title\"] = title_graphics\n\tgraphics_dict[\"button\"] = button_graphics\n\tgraphics_dict[\"about\"] = menu_about_graphics\n\tgraphics_dict[\"pause_button\"] = pause_button_graphics\n\tgraphics_dict[\"quit_button\"] = quit_button_graphics\n", "description": "\n\tLoads graphics from archives into the code\n\t", "category": "graphics", "imports": ["import pygame", "from .components.base.sprite import SpriteSheet", "from .constants import BASE_GRAPHICS_DIR, BASE_SOUND_EFFECT_DIR, BASE_SOUNDTRACK_DIR"]}, {"term": "def", "name": "load_sound", "data": "def load_sound():\n\t\"\"\"\n\tLoads sounds from archives into the code\n\t\"\"\"\n\tak47_sound = pygame.mixer.Sound(BASE_SOUND_EFFECT_DIR + 'ak47.wav')\n\tuzi_sound = pygame.mixer.Sound(BASE_SOUND_EFFECT_DIR + 'uzi.wav')\n\twinchester_sound = pygame.mixer.Sound(BASE_SOUND_EFFECT_DIR + 'winchester.wav')\n\tbeep_sound = pygame.mixer.Sound(BASE_SOUND_EFFECT_DIR + 'alert-beep.wav')\n\tgameover_sound = pygame.mixer.Sound(BASE_SOUND_EFFECT_DIR + 'gameover.wav')\n\theartbeat_sound = pygame.mixer.Sound(BASE_SOUND_EFFECT_DIR + 'heartbeat.wav')\n\titem_sound = pygame.mixer.Sound(BASE_SOUND_EFFECT_DIR + 'item_collect.wav')\n\thit_1_sound = pygame.mixer.Sound(BASE_SOUND_EFFECT_DIR + 'hit1.wav')\n\tmenu_select_sound = pygame.mixer.Sound(BASE_SOUND_EFFECT_DIR + 'menu_select.wav')\n\tmonster_scream_sound = pygame.mixer.Sound(BASE_SOUND_EFFECT_DIR + 'monster_scream.wav')\n\tdying_zombie_sound = pygame.mixer.Sound(BASE_SOUND_EFFECT_DIR + 'dying.wav')\n\tdying_bat_sound = pygame.mixer.Sound(BASE_SOUND_EFFECT_DIR + 'dying_bat.wav')\n\tbat_wings_sound = pygame.mixer.Sound(BASE_SOUND_EFFECT_DIR + 'bat_wings.wav')\n\theal_sound = pygame.mixer.Sound(BASE_SOUND_EFFECT_DIR + 'heal.wav')\n\tevil_laugh_sound = pygame.mixer.Sound(BASE_SOUND_EFFECT_DIR + 'evil_laugh.wav')\n\tammo_collect_sound = pygame.mixer.Sound(BASE_SOUND_EFFECT_DIR + 'ammo.wav')\n\tsound_dict['Uzi'] = uzi_sound\n\tsound_dict['AK47'] = ak47_sound\n\tsound_dict['Shotgun'] = winchester_sound\n\tsound_dict['beep'] = beep_sound\n\tsound_dict['gameover'] = gameover_sound\n\tsound_dict['heartbeat'] = heartbeat_sound\n\tsound_dict['item_sound'] = item_sound\n\tsound_dict['hit_1'] = hit_1_sound\n\tsound_dict['menu_select'] = menu_select_sound\n\tsound_dict['monster_scream'] = monster_scream_sound\n\tsound_dict['dying_zombie'] = dying_zombie_sound\n\tsound_dict['dying_bat'] = dying_bat_sound\n\tsound_dict['bat_wings'] = bat_wings_sound\n\tsound_dict['heal'] = heal_sound\n\tsound_dict['evil_laugh'] = evil_laugh_sound\n\tsound_dict['ammo_collect'] = ammo_collect_sound\n\tsound_dict['Uzi'].set_volume(0.2)\n\tsound_dict['AK47'].set_volume(0.2)\n\tsound_dict['Shotgun'].set_volume(0.2)\n\tsound_dict['gameover'].set_volume(0.5)\n\tsound_dict['hit_1'].set_volume(0.3)\n\tsound_dict['heartbeat'].set_volume(1.0)\n\tsound_dict['menu_select'].set_volume(0.4)\n\tsound_dict['dying_zombie'].set_volume(0.4)\n\tsound_dict['dying_bat'].set_volume(0.4)\n\tsound_dict['bat_wings'].set_volume(0.3)\n\tsound_dict['monster_scream'].set_volume(0.2)\n\tsound_dict['heal'].set_volume(0.4)\n\tsound_dict['item_sound'].set_volume(0.3)\n\tsound_dict['ammo_collect'].set_volume(0.3)\n", "description": "\n\tLoads sounds from archives into the code\n\t", "category": "graphics", "imports": ["import pygame", "from .components.base.sprite import SpriteSheet", "from .constants import BASE_GRAPHICS_DIR, BASE_SOUND_EFFECT_DIR, BASE_SOUNDTRACK_DIR"]}, {"term": "def", "name": "load_menu_music", "data": "def load_menu_music():\n\t\"\"\"\n\tLoads menu music from archives into the code\n\t\"\"\"\n\tmenu_music = pygame.mixer.music.load(BASE_SOUNDTRACK_DIR + 'horror_game_menu.wav')\n", "description": "\n\tLoads menu music from archives into the code\n\t", "category": "graphics", "imports": ["import pygame", "from .components.base.sprite import SpriteSheet", "from .constants import BASE_GRAPHICS_DIR, BASE_SOUND_EFFECT_DIR, BASE_SOUNDTRACK_DIR"]}], [{"term": "def", "name": "main", "data": "def main():\n\tglobal NUM_LIVES\n\tgraphics = BreakoutGraphics()\n\t# Add animation loop here!\n\t# count = 0\n\t# count_top = 0\n\t# print(graphics.cc)\n\t# This 'while True' is to make second revived click start the game.\n\twhile True:\n\t\tpause(FRAME_RATE)\n\t\tif graphics.cc == 1:\n\t\t\twhile True:\n\t\t\t\tgraphics.ball.move(graphics.get_dx(), graphics.get_dy())\n\t\t\t\tgraphics.remove_brick()\n\t\t\t\t# print(graphics.get_dy())\n\t\t\t\tpause(FRAME_RATE)\n\t\t\t\t# if out of window, change direction\n\t\t\t\tif graphics.ball.x <= 0 or graphics.ball.x >= graphics.window.width - graphics.ball.width:\n\t\t\t\t\tgraphics.change_dx_direction()\n\t\t\t\telif graphics.ball.y <= 0:\n\t\t\t\t\tgraphics.change_dy_direction()\n\t\t\t\t\t# if graphics.win():\n\t\t\t\t\t#\t graphics.reset_ball()\n\t\t\t\t\t# count_top += 1\n\t\t\t\t\t# count += 1\n\t\t\t\t\t# print(graphics.window.height, graphics.ball.y+graphics.ball.width, 'time?', count, graphics.get_dy())\n\t\t\t\t# print(graphics.cc)\n\t\t\t\t# if died\n\t\t\t\telif graphics.ball.y + graphics.ball.height >= graphics.window.height:\n\t\t\t\t\tNUM_LIVES -= 1\n\t\t\t\t\tif NUM_LIVES > 0:\n\t\t\t\t\t\tgraphics.reset_ball()\n\t\t\t\t\t\t# reset to make the second revived click starts the game\n\t\t\t\t\t\tgraphics.cc = 0\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tgraphics.reset_ball()\n\t\t\t\t\t\treturn None\n\t\t\t\t# win then stop the game\n\t\t\t\tif graphics.remove_count == 0:\n\t\t\t\t\tgraphics.reset_ball()\n\t\t\t\t\treturn None\n\n\n\n\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics_extension import BreakoutGraphics", "from campy.gui.events.mouse import onmouseclicked"]}], [{"term": "class", "name": "from.baseclassimportvmmGObjectUI", "data": "from .baseclass import vmmGObjectUI\n\n", "description": null, "category": "graphics", "imports": ["from gi.repository import Gtk", "from gi.repository import GObject", "import virtinst", "from . import uiutil", "from .baseclass import vmmGObjectUI"]}, {"term": "class", "name": "vmmGraphicsDetails", "data": "class vmmGraphicsDetails(vmmGObjectUI):\n\t__gsignals__ = {\n\t\t\"changed-password\": (GObject.SignalFlags.RUN_FIRST, None, []),\n\t\t\"changed-port\": (GObject.SignalFlags.RUN_FIRST, None, []),\n\t\t\"changed-tlsport\": (GObject.SignalFlags.RUN_FIRST, None, []),\n\t\t\"changed-type\": (GObject.SignalFlags.RUN_FIRST, None, []),\n\t\t\"changed-address\": (GObject.SignalFlags.RUN_FIRST, None, []),\n\t\t\"changed-keymap\": (GObject.SignalFlags.RUN_FIRST, None, []),\n\t}\n\n\tdef __init__(self, vm, builder, topwin):\n\t\tvmmGObjectUI.__init__(self, \"gfxdetails.ui\",\n\t\t\t\t\t\t\t  None, builder=builder, topwin=topwin)\n\t\tself.vm = vm\n\t\tself.conn = vm.conn\n\n\t\tself.builder.connect_signals({\n\t\t\t\"on_graphics_type_changed\": self._change_graphics_type,\n\t\t\t\"on_graphics_port_auto_toggled\": self._change_port_auto,\n\t\t\t\"on_graphics_tlsport_auto_toggled\": self._change_tlsport_auto,\n\t\t\t\"on_graphics_use_password\": self._change_password_chk,\n\n\t\t\t\"on_graphics_password_changed\": lambda ignore: self.emit(\"changed-password\"),\n\t\t\t\"on_graphics_address_changed\": lambda ignore: self.emit(\"changed-address\"),\n\t\t\t\"on_graphics_tlsport_changed\": lambda ignore: self.emit(\"changed-tlsport\"),\n\t\t\t\"on_graphics_port_changed\": lambda ignore: self.emit(\"changed-port\"),\n\t\t\t\"on_graphics_keymap_changed\": lambda ignore: self.emit(\"changed-keymap\"),\n\t\t})\n\n\t\tself._init_ui()\n\t\tself.top_box = self.widget(\"graphics-box\")\n\n\tdef _cleanup(self):\n\t\tself.vm = None\n\t\tself.conn = None\n\n\t##########################\n\t# Initialization methods #\n\t##########################\n\n\tdef _init_ui(self):\n\t\tgraphics_list = self.widget(\"graphics-type\")\n\t\tgraphics_model = Gtk.ListStore(str, str)\n\t\tgraphics_list.set_model(graphics_model)\n\t\tuiutil.set_combo_text_column(graphics_list, 1)\n\t\tgraphics_model.clear()\n\t\tgraphics_model.append([\"spice\", _(\"Spice server\")])\n\t\tgraphics_model.append([\"vnc\", _(\"VNC server\")])\n\n\t\tself.widget(\"graphics-address\").set_model(Gtk.ListStore(str, str))\n\t\tuiutil.set_combo_text_column(self.widget(\"graphics-address\"), 1)\n\n\t\tmodel = self.widget(\"graphics-address\").get_model()\n\t\tmodel.clear()\n\t\tmodel.append([None, _(\"Hypervisor default\")])\n\t\tmodel.append([\"127.0.0.1\", _(\"Localhost only\")])\n\t\tmodel.append([\"0.0.0.0\", _(\"All interfaces\")])\n\n\t\t# Keymap\n\t\tcombo = self.widget(\"graphics-keymap\")\n\t\tmodel = Gtk.ListStore(str, str)\n\t\tcombo.set_model(model)\n\t\tuiutil.set_combo_text_column(combo, 1)\n\n\t\tmodel.append([\"auto\", \"Auto\"])\n\t\tmodel.append([virtinst.VirtualGraphics.KEYMAP_LOCAL,\n\t\t\t\t\t  \"Copy local keymap\"])\n\t\tfor k in virtinst.VirtualGraphics.valid_keymaps():\n\t\t\tmodel.append([k, k])\n\n\tdef _get_config_graphics_ports(self):\n\t\tport = uiutil.spin_get_helper(self.widget(\"graphics-port\"))\n\t\ttlsport = uiutil.spin_get_helper(self.widget(\"graphics-tlsport\"))\n\t\tgtype = uiutil.get_list_selection(self.widget(\"graphics-type\"), 0)\n\n\t\tif self.widget(\"graphics-port-auto\").get_active():\n\t\t\tport = -1\n\t\tif self.widget(\"graphics-tlsport-auto\").get_active():\n\t\t\ttlsport = -1\n\n\t\tif gtype != \"spice\":\n\t\t\ttlsport = None\n\t\treturn port, tlsport\n\n\n\t##############\n\t# Public API #\n\t##############\n\n\tdef reset_state(self):\n\t\tuiutil.set_grid_row_visible(self.widget(\"graphics-display\"), False)\n\t\tuiutil.set_grid_row_visible(self.widget(\"graphics-xauth\"), False)\n\n\t\tself.widget(\"graphics-type\").set_active(0)\n\t\tself.widget(\"graphics-address\").set_active(0)\n\t\tself.widget(\"graphics-keymap\").set_active(0)\n\n\t\tself._change_ports()\n\t\tself.widget(\"graphics-port-auto\").set_active(True)\n\t\tself.widget(\"graphics-tlsport-auto\").set_active(True)\n\t\tself.widget(\"graphics-password\").set_text(\"\")\n\t\tself.widget(\"graphics-password\").set_sensitive(False)\n\t\tself.widget(\"graphics-password-chk\").set_active(False)\n\n\tdef get_values(self):\n\t\tgtype = uiutil.get_list_selection(self.widget(\"graphics-type\"), 0)\n\t\tport, tlsport = self._get_config_graphics_ports()\n\t\taddr = uiutil.get_list_selection(self.widget(\"graphics-address\"), 0)\n\t\tkeymap = uiutil.get_combo_entry(self.widget(\"graphics-keymap\"))\n\t\tif keymap == \"auto\":\n\t\t\tkeymap = None\n\n\t\tpasswd = self.widget(\"graphics-password\").get_text()\n\t\tif not self.widget(\"graphics-password-chk\").get_active():\n\t\t\tpasswd = None\n\n\t\treturn gtype, port, tlsport, addr, passwd, keymap\n\n\tdef set_dev(self, gfx):\n\t\tself.reset_state()\n\n\t\tdef set_port(basename, val):\n\t\t\tauto = self.widget(basename + \"-auto\")\n\t\t\twidget = self.widget(basename)\n\t\t\tauto.set_inconsistent(False)\n\t\t\tlabel = auto.get_label().split(\" (\")[0]\n\n\t\t\tif val == -1 or gfx.autoport:\n\t\t\t\tauto.set_active(True)\n\t\t\t\tif val and val != -1:\n\t\t\t\t\tlabel += \" (%s %s)\" % (_(\"Port\"), val)\n\t\t\telif val is None:\n\t\t\t\tauto.set_inconsistent(True)\n\t\t\telse:\n\t\t\t\tauto.set_active(False)\n\t\t\t\twidget.set_value(val)\n\n\t\t\tauto.set_label(label)\n\n\t\tgtype = gfx.type\n\t\tis_vnc = (gtype == \"vnc\")\n\t\tis_sdl = (gtype == \"sdl\")\n\t\tis_spice = (gtype == \"spice\")\n\t\ttitle = (_(\"%(graphicstype)s Server\") %\n\t\t\t\t  {\"graphicstype\" : gfx.pretty_type_simple(gtype)})\n\n\t\tif is_vnc or is_spice:\n\t\t\tuse_passwd = gfx.passwd is not None\n\n\t\t\tset_port(\"graphics-port\", gfx.port)\n\t\t\tuiutil.set_combo_entry(\n\t\t\t\tself.widget(\"graphics-address\"), gfx.listen, 0)\n\t\t\tuiutil.set_combo_entry(\n\t\t\t\tself.widget(\"graphics-keymap\"), gfx.keymap or None, 0)\n\n\t\t\tself.widget(\"graphics-password\").set_text(gfx.passwd or \"\")\n\t\t\tself.widget(\"graphics-password-chk\").set_active(use_passwd)\n\t\t\tself.widget(\"graphics-password\").set_sensitive(use_passwd)\n\n\t\tif is_spice:\n\t\t\tset_port(\"graphics-tlsport\", gfx.tlsPort)\n\n\t\tif is_sdl:\n\t\t\ttitle = _(\"Local SDL Window\")\n\n\t\t\tself.widget(\"graphics-display\").set_text(\n\t\t\t\tgfx.display or _(\"Unknown\"))\n\t\t\tself.widget(\"graphics-xauth\").set_text(\n\t\t\t\tgfx.xauth or _(\"Unknown\"))\n\n\t\tuiutil.set_combo_entry(self.widget(\"graphics-type\"), gtype, 0)\n\t\treturn title\n\n\n\t#############\n\t# Listeners #\n\t#############\n\n\tdef _show_rows_from_type(self):\n\t\thide_all = [\"graphics-xauth\", \"graphics-display\", \"graphics-address\",\n\t\t\t\"graphics-password-box\", \"graphics-keymap\", \"graphics-port-box\",\n\t\t\t\"graphics-tlsport-box\"]\n\n\t\tgtype = uiutil.get_list_selection(self.widget(\"graphics-type\"), 0)\n\t\tsdl_rows = [\"graphics-xauth\", \"graphics-display\"]\n\t\tvnc_rows = [\"graphics-password-box\", \"graphics-address\",\n\t\t\t\"graphics-port-box\", \"graphics-keymap\"]\n\t\tspice_rows = vnc_rows[:] + [\"graphics-tlsport-box\"]\n\n\t\trows = []\n\t\tif gtype == \"sdl\":\n\t\t\trows = sdl_rows\n\t\telif gtype == \"vnc\":\n\t\t\trows = vnc_rows\n\t\telif gtype == \"spice\":\n\t\t\trows = spice_rows\n\n\t\tfor row in hide_all:\n\t\t\tuiutil.set_grid_row_visible(self.widget(row), row in rows)\n\n\tdef _change_graphics_type(self, ignore):\n\t\tself._show_rows_from_type()\n\t\tself.emit(\"changed-type\")\n\n\tdef _change_port_auto(self, ignore):\n\t\tself.widget(\"graphics-port-auto\").set_inconsistent(False)\n\t\tself._change_ports()\n\t\tself.emit(\"changed-port\")\n\n\tdef _change_tlsport_auto(self, ignore):\n\t\tself.widget(\"graphics-tlsport-auto\").set_inconsistent(False)\n\t\tself._change_ports()\n\t\tself.emit(\"changed-tlsport\")\n\n\tdef _change_ports(self):\n\t\tis_auto = (self.widget(\"graphics-port-auto\").get_active() or\n\t\t\tself.widget(\"graphics-port-auto\").get_inconsistent())\n\t\tis_tlsauto = (self.widget(\"graphics-tlsport-auto\").get_active() or\n\t\t\tself.widget(\"graphics-tlsport-auto\").get_inconsistent())\n\n\t\tself.widget(\"graphics-port\").set_visible(not is_auto)\n\t\tself.widget(\"graphics-tlsport\").set_visible(not is_tlsauto)\n\n\tdef _change_password_chk(self, ignore=None):\n\t\tif self.widget(\"graphics-password-chk\").get_active():\n\t\t\tself.widget(\"graphics-password\").set_sensitive(True)\n\t\telse:\n\t\t\tself.widget(\"graphics-password\").set_text(\"\")\n\t\t\tself.widget(\"graphics-password\").set_sensitive(False)\n\t\tself.emit(\"changed-password\")\n", "description": null, "category": "graphics", "imports": ["from gi.repository import Gtk", "from gi.repository import GObject", "import virtinst", "from . import uiutil", "from .baseclass import vmmGObjectUI"]}], [], [{"term": "class", "name": "TestThreeGraphicsTwoDimension", "data": "class TestThreeGraphicsTwoDimension(BaseMultiGraphicsTwoDimension):\n\tGraphics = BaseMultiGraphicsTwoDimension.TypeGraphics[:3]\n\tendpoint_get = EndpointConfig.endpoint_square\n\texpect_status_get = STATUS_200\n\n", "description": null, "category": "graphics", "imports": ["from test.base_test.base_dimension.baseMultiGraphicMixDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicOneDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicTwoDimension import \\", "from app.config.configEndpoint import EndpointConfig", "from app.messages.statusMessages import STATUS_200"]}, {"term": "class", "name": "TestTwoGraphicsTwoDimension", "data": "class TestTwoGraphicsTwoDimension(BaseMultiGraphicsTwoDimension):\n\tGraphics = BaseMultiGraphicsTwoDimension.TypeGraphics[:2]\n\tendpoint_get = EndpointConfig.endpoint_square\n\texpect_status_get = STATUS_200\n\n", "description": null, "category": "graphics", "imports": ["from test.base_test.base_dimension.baseMultiGraphicMixDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicOneDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicTwoDimension import \\", "from app.config.configEndpoint import EndpointConfig", "from app.messages.statusMessages import STATUS_200"]}, {"term": "class", "name": "TestThreeGraphicsOneDimension", "data": "class TestThreeGraphicsOneDimension(BaseMultiGraphicsOneDimension):\n\tGraphics = BaseMultiGraphicsOneDimension.TypeGraphics[:3]\n\tendpoint_get = EndpointConfig.endpoint_square\n\texpect_status_get = STATUS_200\n\n", "description": null, "category": "graphics", "imports": ["from test.base_test.base_dimension.baseMultiGraphicMixDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicOneDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicTwoDimension import \\", "from app.config.configEndpoint import EndpointConfig", "from app.messages.statusMessages import STATUS_200"]}, {"term": "class", "name": "TestTwoGraphicsOneDimension", "data": "class TestTwoGraphicsOneDimension(BaseMultiGraphicsOneDimension):\n\tGraphics = BaseMultiGraphicsOneDimension.TypeGraphics[:2]\n\tendpoint_get = EndpointConfig.endpoint_square\n\texpect_status_get = STATUS_200\n\n", "description": null, "category": "graphics", "imports": ["from test.base_test.base_dimension.baseMultiGraphicMixDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicOneDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicTwoDimension import \\", "from app.config.configEndpoint import EndpointConfig", "from app.messages.statusMessages import STATUS_200"]}, {"term": "class", "name": "TestSixGraphicsMixDimension", "data": "class TestSixGraphicsMixDimension(BaseMultiGraphicsMixDimension):\n\tGraphics = (\n\t\tBaseMultiGraphicsOneDimension.TypeGraphics[:3]\n\t\t+ BaseMultiGraphicsTwoDimension.TypeGraphics[:3]\n\t)\n\tendpoint_get = EndpointConfig.endpoint_square\n\texpect_status_get = STATUS_200\n\n", "description": null, "category": "graphics", "imports": ["from test.base_test.base_dimension.baseMultiGraphicMixDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicOneDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicTwoDimension import \\", "from app.config.configEndpoint import EndpointConfig", "from app.messages.statusMessages import STATUS_200"]}, {"term": "class", "name": "TestFiveGraphicsMixDimension", "data": "class TestFiveGraphicsMixDimension(BaseMultiGraphicsMixDimension):\n\tGraphics = (\n\t\tBaseMultiGraphicsOneDimension.TypeGraphics[:2]\n\t\t+ BaseMultiGraphicsTwoDimension.TypeGraphics[:3]\n\t)\n\tendpoint_get = EndpointConfig.endpoint_square\n\texpect_status_get = STATUS_200\n\n", "description": null, "category": "graphics", "imports": ["from test.base_test.base_dimension.baseMultiGraphicMixDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicOneDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicTwoDimension import \\", "from app.config.configEndpoint import EndpointConfig", "from app.messages.statusMessages import STATUS_200"]}, {"term": "class", "name": "TestFourGraphicsMixDimension", "data": "class TestFourGraphicsMixDimension(BaseMultiGraphicsMixDimension):\n\tGraphics = (\n\t\tBaseMultiGraphicsOneDimension.TypeGraphics[:2]\n\t\t+ BaseMultiGraphicsTwoDimension.TypeGraphics[:2]\n\t)\n\tendpoint_get = EndpointConfig.endpoint_square\n\texpect_status_get = STATUS_200\n\n", "description": null, "category": "graphics", "imports": ["from test.base_test.base_dimension.baseMultiGraphicMixDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicOneDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicTwoDimension import \\", "from app.config.configEndpoint import EndpointConfig", "from app.messages.statusMessages import STATUS_200"]}, {"term": "class", "name": "TestThreeGraphicsMixDimension", "data": "class TestThreeGraphicsMixDimension(BaseMultiGraphicsMixDimension):\n\tGraphics = (\n\t\tBaseMultiGraphicsOneDimension.TypeGraphics[:1]\n\t\t+ BaseMultiGraphicsTwoDimension.TypeGraphics[:2]\n\t)\n\tendpoint_get = EndpointConfig.endpoint_square\n\texpect_status_get = STATUS_200\n\n", "description": null, "category": "graphics", "imports": ["from test.base_test.base_dimension.baseMultiGraphicMixDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicOneDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicTwoDimension import \\", "from app.config.configEndpoint import EndpointConfig", "from app.messages.statusMessages import STATUS_200"]}, {"term": "class", "name": "TestTwoGraphicsMixDimension", "data": "class TestTwoGraphicsMixDimension(BaseMultiGraphicsMixDimension):\n\tGraphics = (\n\t\tBaseMultiGraphicsOneDimension.TypeGraphics[:1]\n\t\t+ BaseMultiGraphicsTwoDimension.TypeGraphics[:1]\n\t)\n\tendpoint_get = EndpointConfig.endpoint_square\n\texpect_status_get = STATUS_200\n", "description": null, "category": "graphics", "imports": ["from test.base_test.base_dimension.baseMultiGraphicMixDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicOneDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicTwoDimension import \\", "from app.config.configEndpoint import EndpointConfig", "from app.messages.statusMessages import STATUS_200"]}], [{"term": "class", "name": "TestManifest", "data": "class TestManifest(unittest.TestCase):\n\tdef process_test_vectors(self, test_vectors):\n\t\tindex = 0\n\t\tfor vector in test_vectors:\n\t\t\tprint(\"Testing index\", index)\n\t\t\texpected, yaml = vector\n\t\t\twith mozfile.NamedTemporaryFile() as tf:\n\t\t\t\ttf.write(yaml)\n\t\t\t\ttf.flush()\n\t\t\t\tif expected == \"exception\":\n\t\t\t\t\twith self.assertRaises(MozYamlVerifyError):\n\t\t\t\t\t\tload_moz_yaml(tf.name, require_license_file=False)\n\t\t\t\telse:\n\t\t\t\t\tself.assertDictEqual(\n\t\t\t\t\t\tload_moz_yaml(tf.name, require_license_file=False), expected\n\t\t\t\t\t)\n\t\t\tindex += 1\n\n\t# ===========================================================================================\n\tdef test_simple(self):\n\t\tsimple_dict = {\n\t\t\t\"schema\": 1,\n\t\t\t\"origin\": {\n\t\t\t\t\"description\": \"2D Graphics Library\",\n\t\t\t\t\"license\": [\"MPL-1.1\", \"LGPL-2.1\"],\n\t\t\t\t\"name\": \"cairo\",\n\t\t\t\t\"release\": \"version 1.6.4\",\n\t\t\t\t\"revision\": \"AA001122334455\",\n\t\t\t\t\"url\": \"https://www.cairographics.org/\",\n\t\t\t},\n\t\t\t\"bugzilla\": {\"component\": \"Graphics\", \"product\": \"Core\"},\n\t\t}\n\n\t\tself.process_test_vectors(\n\t\t\t[\n\t\t\t\t(\n\t\t\t\t\tsimple_dict,\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import, print_function, unicode_literals", "import unittest", "import mozfile", "from mozunit import main", "from mozbuild.vendor.moz_yaml import load_moz_yaml, MozYamlVerifyError"]}, {"term": "def", "name": "ftest_updatebot", "data": "\tdef test_updatebot(self):\n\t\tself.process_test_vectors(\n\t\t\t[\n\t\t\t\t(\n\t\t\t\t\t{\n\t\t\t\t\t\t\"schema\": 1,\n\t\t\t\t\t\t\"origin\": {\n\t\t\t\t\t\t\t\"description\": \"2D Graphics Library\",\n\t\t\t\t\t\t\t\"license\": [\"MPL-1.1\", \"LGPL-2.1\"],\n\t\t\t\t\t\t\t\"name\": \"cairo\",\n\t\t\t\t\t\t\t\"release\": \"version 1.6.4\",\n\t\t\t\t\t\t\t\"revision\": \"AA001122334455\",\n\t\t\t\t\t\t\t\"url\": \"https://www.cairographics.org/\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"bugzilla\": {\"component\": \"Graphics\", \"product\": \"Core\"},\n\t\t\t\t\t\t\"updatebot\": {\n\t\t\t\t\t\t\t\"maintainer-phab\": \"tjr\",\n\t\t\t\t\t\t\t\"maintainer-bz\": \"a@example.com\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import, print_function, unicode_literals", "import unittest", "import mozfile", "from mozunit import main", "from mozbuild.vendor.moz_yaml import load_moz_yaml, MozYamlVerifyError"]}, {"term": "def", "name": "ftest_malformed", "data": "\tdef test_malformed(self):\n\t\twith mozfile.NamedTemporaryFile() as tf:\n\t\t\ttf.write(b\"blah\")\n\t\t\ttf.flush()\n\t\t\twith self.assertRaises(MozYamlVerifyError):\n\t\t\t\tload_moz_yaml(tf.name, require_license_file=False)\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import, print_function, unicode_literals", "import unittest", "import mozfile", "from mozunit import main", "from mozbuild.vendor.moz_yaml import load_moz_yaml, MozYamlVerifyError"]}, {"term": "def", "name": "ftest_schema", "data": "\tdef test_schema(self):\n\t\twith mozfile.NamedTemporaryFile() as tf:\n\t\t\ttf.write(b\"schema: 99\")\n\t\t\ttf.flush()\n\t\t\twith self.assertRaises(MozYamlVerifyError):\n\t\t\t\tload_moz_yaml(tf.name, require_license_file=False)\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import, print_function, unicode_literals", "import unittest", "import mozfile", "from mozunit import main", "from mozbuild.vendor.moz_yaml import load_moz_yaml, MozYamlVerifyError"]}, {"term": "def", "name": "ftest_json", "data": "\tdef test_json(self):\n\t\twith mozfile.NamedTemporaryFile() as tf:\n\t\t\ttf.write(\n\t\t\t\tb'{\"origin\": {\"release\": \"version 1.6.4\", \"url\": \"https://w'\n\t\t\t\tb'ww.cairographics.org/\", \"description\": \"2D Graphics Libra'\n\t\t\t\tb'ry\", \"license\": [\"MPL-1.1\", \"LGPL-2.1\"], \"name\": \"cairo\"}'\n\t\t\t\tb', \"bugzilla\": {\"product\": \"Core\", \"component\": \"Graphics\"'\n\t\t\t\tb'}, \"schema\": 1}'\n\t\t\t)\n\t\t\ttf.flush()\n\t\t\twith self.assertRaises(MozYamlVerifyError):\n\t\t\t\tload_moz_yaml(tf.name, require_license_file=False)\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import, print_function, unicode_literals", "import unittest", "import mozfile", "from mozunit import main", "from mozbuild.vendor.moz_yaml import load_moz_yaml, MozYamlVerifyError"]}, {"term": "def", "name": "ftest_revision", "data": "\tdef test_revision(self):\n\t\tself.process_test_vectors(\n\t\t\t[\n\t\t\t\t(\n\t\t\t\t\t{\n\t\t\t\t\t\t\"schema\": 1,\n\t\t\t\t\t\t\"origin\": {\n\t\t\t\t\t\t\t\"description\": \"2D Graphics Library\",\n\t\t\t\t\t\t\t\"license\": [\"MPL-1.1\", \"LGPL-2.1\"],\n\t\t\t\t\t\t\t\"name\": \"cairo\",\n\t\t\t\t\t\t\t\"release\": \"version 1.6.4\",\n\t\t\t\t\t\t\t\"revision\": \"v1.6.37\",\n\t\t\t\t\t\t\t\"url\": \"https://www.cairographics.org/\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"bugzilla\": {\"component\": \"Graphics\", \"product\": \"Core\"},\n\t\t\t\t\t},\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import, print_function, unicode_literals", "import unittest", "import mozfile", "from mozunit import main", "from mozbuild.vendor.moz_yaml import load_moz_yaml, MozYamlVerifyError"]}], [{"term": "class", "name": "Point", "data": "class Point():\n\tdef __init__(self, x, y, dx, dy):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.dx = dx\n\t\tself.dy = dy\n", "description": null, "category": "graphics", "imports": ["from Graphics import Graphics", "import random"]}, {"term": "class", "name": "Test1", "data": "class Test1(Graphics):\n\n\tdef __init__(self):\n\t\tsuper().__init__(\"PyGame Test 1\", WINDOW_WIDTH, WINDOW_HEIGHT)\n\t\tself.setClearColor(Graphics.BLACK)\n\t\tself.setTargetFps(60)\n\n\tdef setup(self):\n\t\tself.points = []\n\t\tfor i in range(50):\n\t\t\tx = random.randint(5, WINDOW_WIDTH - 5)\n\t\t\ty = random.randint(5, WINDOW_HEIGHT - 5)\n\t\t\tdx = random.randint(-2, 2)\n\t\t\tdy = random.randint(-2, 2)\n\t\t\tp = Point(x, y, dx, dy)\n\t\t\tself.points.append(p)\n\n\tdef cleanup(self):\n\t\t# print(\"Done\")\n\t\tpass\n\n\tdef draw(self):\n\t\tfor p in self.points:\n\t\t\tself.circle(p.x, p.y, 30, Graphics.RED)\n\t\t\tself.circle(p.x, p.y, 20, Graphics.GREEN)\n\t\t\t# self.filled_circle(p.x, p.y, 10, Graphics.BLUE)\n\t\t\t# self.line(100, 100, self.x, self.y, Graphics.RED)\n\t\t\t# self.line(self.x, self.y, 200, 100, Graphics.RED)\n\t\t\t# self.rectangle(100, 100, 150, 150, Graphics.RED)\n\t\tself.line(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, Graphics.WHITE)\n\t\tself.line(WINDOW_WIDTH, 0, 0, WINDOW_HEIGHT, Graphics.WHITE)\n\n\tdef update(self, timeDelta):\n\t\tfor p in self.points:\n\t\t\tp.x += p.dx\n\t\t\tif p.x <= 5 or p.x >= WINDOW_WIDTH - 5:\n\t\t\t\tp.dx *= -1\n\t\t\tp.y += p.dy\n\t\t\tif p.y <= 5 or p.y >= WINDOW_HEIGHT - 5:\n\t\t\t\tp.dy *= -1\n\n\tdef mouseEvent(self, x, y):\n\t\tprint(f\"mouseCallback: {x} {y}\")\n\n\tdef keyEvent(self, key):\n\t\tprint(f\"keyCallback: {key}\")\n\n", "description": null, "category": "graphics", "imports": ["from Graphics import Graphics", "import random"]}], [{"term": "class", "name": "classAnimationPlayer:\r", "data": "class AnimationPlayer:\r\n\tdef __init__(self):\r\n\t\tself.frames = {\r\n\t\t\t# magic\r\n\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\r\n\t\t\t'aura': import_folder('../graphics/particles/aura'),\r\n\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\r\n\t\t\t\r\n\t\t\t# attacks \r\n\t\t\t'claw': import_folder('../graphics/particles/claw'),\r\n\t\t\t'slash': import_folder('../graphics/particles/slash'),\r\n\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\r\n\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\r\n\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\r\n\r\n\t\t\t# monster deaths\r\n\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\r\n\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\r\n\t\t\t'spirit': import_folder('../graphics/particles/nova'),\r\n\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\r\n\t\t\t\r\n\t\t\t# leafs \r\n\t\t\t'leaf': (\r\n\t\t\t\timport_folder('../graphics/particles/leaf1'),\r\n\t\t\t\timport_folder('../graphics/particles/leaf2'),\r\n\t\t\t\timport_folder('../graphics/particles/leaf3'),\r\n\t\t\t\timport_folder('../graphics/particles/leaf4'),\r\n\t\t\t\timport_folder('../graphics/particles/leaf5'),\r\n\t\t\t\timport_folder('../graphics/particles/leaf6'),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\r\n\tdef reflect_images(self,frames):\r\n\t\tnew_frames = []\r\n\r\n\t\tfor frame in frames:\r\n\t \t\tflipped_frame = pygame.transform.flip(frame,True,False)\r\n\t \t\tnew_frames.append(flipped_frame)\r\n\t\treturn new_frames\r\n\r\n\tdef create_grass_particles(self,pos,groups):\r\n\t \tanimation_frames = choice(self.frames['leaf'])\r\n\t \tParticleEffect(pos,animation_frames,groups)\r\n\r\n\tdef create_particles(self,animation_type,pos,groups):\r\n\t\tanimation_frames = self.frames[animation_type]\r\n\t\tParticleEffect(pos,animation_frames,groups)\r\n\r\n", "description": null, "category": "graphics", "imports": ["import pygame\r", "from support import import_folder\r", "from random import choice\r", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\r", "\t\t\t'aura': import_folder('../graphics/particles/aura'),\r", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\r", "\t\t\t'claw': import_folder('../graphics/particles/claw'),\r", "\t\t\t'slash': import_folder('../graphics/particles/slash'),\r", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\r", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\r", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\r", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\r", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\r", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),\r", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf1'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf2'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf3'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf4'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf5'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf6'),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\r"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\r\n\tdef __init__(self,pos,animation_frames,groups):\r\n\t\tsuper().__init__(groups)\r\n\t\tself.sprite_type = 'magic'\r\n\t\tself.frame_index = 0\r\n\t\tself.animation_speed = 0.15\r\n\t\tself.frames = animation_frames\r\n\t\tself.image = self.frames[self.frame_index]\r\n\t\tself.rect = self.image.get_rect(center = pos)\r\n\r\n\tdef animate(self):\r\n\t\tself.frame_index += self.animation_speed\r\n\t\tif self.frame_index >= len(self.frames):\r\n\t\t\tself.kill()\r\n\t\telse:\r\n\t\t\tself.image = self.frames[int(self.frame_index)]\r\n\r\n\tdef update(self):\r\n\t\tself.animate()\r\n", "description": null, "category": "graphics", "imports": ["import pygame\r", "from support import import_folder\r", "from random import choice\r", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\r", "\t\t\t'aura': import_folder('../graphics/particles/aura'),\r", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\r", "\t\t\t'claw': import_folder('../graphics/particles/claw'),\r", "\t\t\t'slash': import_folder('../graphics/particles/slash'),\r", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\r", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\r", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\r", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\r", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\r", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),\r", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf1'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf2'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf3'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf4'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf5'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf6'),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\r"]}], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis widget is an easy starting point for generating multi-panel figures.\n\tExample::\n\t\n\t\tw = pg.GraphicsLayoutWidget()\n\t\tp1 = w.addPlot(row=0, col=0)\n\t\tp2 = w.addPlot(row=0, col=1)\n\t\tv = w.addViewBox(row=1, col=0, colspan=2)\n\t\n\t=========  =================================================================\n\tparent\t (QWidget or None) The parent widget.\n\tshow\t   (bool) If True, then immediately show the widget after it is\n\t\t\t   created. If the widget has no parent, then it will be shown\n\t\t\t   inside a new window.\n\tsize\t   (width, height) tuple. Optionally resize the widget. Note: if\n\t\t\t   this widget is placed inside a layout, then this argument has no\n\t\t\t   effect.\n\ttitle\t  (str or None) If specified, then set the window title for this\n\t\t\t   widget.\n\tkargs\t  All extra arguments are passed to\n\t\t\t   :meth:`GraphicsLayout.__init__\n\t\t\t   `\n\t=========  =================================================================\n\t\t\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, show=False, size=None, title=None, **kargs):\n\t\tmkQApp()\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n\t\t\n\t\tif size is not None:\n\t\t\tself.resize(*size)\n\t\t\t\n\t\tif title is not None:\n\t\t\tself.setWindowTitle(title)\n\t\t\t\n\t\tif show is True:\n\t\t\tself.show()\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis widget is an easy starting point for generating multi-panel figures.\n\tExample::\n\t\n\t\tw = pg.GraphicsLayoutWidget()\n\t\tp1 = w.addPlot(row=0, col=0)\n\t\tp2 = w.addPlot(row=0, col=1)\n\t\tv = w.addViewBox(row=1, col=0, colspan=2)\n\t\n\t=========  =================================================================\n\tparent\t (QWidget or None) The parent widget.\n\tshow\t   (bool) If True, then immediately show the widget after it is\n\t\t\t   created. If the widget has no parent, then it will be shown\n\t\t\t   inside a new window.\n\tsize\t   (width, height) tuple. Optionally resize the widget. Note: if\n\t\t\t   this widget is placed inside a layout, then this argument has no\n\t\t\t   effect.\n\ttitle\t  (str or None) If specified, then set the window title for this\n\t\t\t   widget.\n\tkargs\t  All extra arguments are passed to\n\t\t\t   :meth:`GraphicsLayout.__init__\n\t\t\t   `\n\t=========  =================================================================\n\t\t\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from ..Qt import mkQApp", "from .GraphicsView import GraphicsView"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tlives = NUM_LIVES\n\tlife = GLabel('Lives: ' + str(lives))\n\tlife.font = '-20'\n\tgraphics.window.add(life, 0, graphics.window.height)\n\tbrick_number = graphics.brick_number\n\t# Add animation loop here!\n\twhile lives > 0 and brick_number > 0:\n\t\tdx = graphics.get_dx()\n\t\tdy = graphics.get_dy()\n\t\tgraphics.ball.move(dx, dy)\n\t\t# Hits the side walls and bounces\n\t\tif graphics.ball.x < 0 or graphics.ball.x + graphics.ball.width > graphics.window.width:\n\t\t\tgraphics.set_dx(-dx)\n\t\t# Hits the ceiling and bounces\n\t\tif graphics.ball.y < 0:\n\t\t\tgraphics.set_dy(-dy)\n\t\t# Loses life\n\t\telif graphics.ball.y + graphics.ball.height > graphics.window.height:\n\t\t\tgraphics.restart()\n\t\t\tlives -= 1\n\t\t\tlife.text = ('Lives: ' + str(lives))\n\t\telse:\n\t\t\tfor i in range(2):\n\t\t\t\tfor j in range(2):\n\t\t\t\t\tif graphics.hit_brick(graphics.ball.x + graphics.ball.width * i,\n\t\t\t\t\t\t\t\t\t\t  graphics.ball.y + graphics.ball.height * j):\n\t\t\t\t\t\tobject_detected = graphics.window.get_object_at(graphics.ball.x + graphics.ball.width * i,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgraphics.ball.y + graphics.ball.height * j)\n\t\t\t\t\t\tif object_detected is not None:\n\t\t\t\t\t\t\t# Hits the bricks\n\t\t\t\t\t\t\tif object_detected is not graphics.paddle and object_detected is not life:\n\t\t\t\t\t\t\t\tgraphics.window.remove(object_detected)\n\t\t\t\t\t\t\t\tbrick_number -= 1\n\t\t\t\t\t\t\t\tgraphics.set_dy(-dy)\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t# Hits the paddle\n\t\t\t\t\t\t\telif object_detected is graphics.paddle and dy > 0:\n\t\t\t\t\t\t\t\tgraphics.set_dy(-dy)\n\t\t\t\t\t\t\t\tbreak\n\t\tif lives <= 0:\n\t\t\tgame_over = GLabel('Game Over.')\n\t\t\tgame_over.font = '-40'\n\t\t\tgraphics.window.add(game_over, graphics.window.width / 2 - game_over.width / 2,\n\t\t\t\t\t\t\t\tgraphics.window.height / 2 + game_over.height)\n\t\tpause(FRAME_RATE)\n\t\tif brick_number == 0:\n\t\t\twin = GLabel('You Win!')\n\t\t\twin.font = '-40'\n\t\t\tgraphics.window.add(win, (graphics.window.width - win.width) / 2, (graphics.window.height + win.height) / 2)\n\t\t\tbreak\n\n", "description": null, "category": "graphics", "imports": ["from campy.graphics.gobjects import GLabel", "from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [], [], [], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\twhile True:\n\t\tpause(FRAME_RATE)\n\t\tif not graphics.check_initial_result(): # Initial page for difficulty selection\n\t\t\tbreak\n\n\tdifficulty = graphics.get_difficulty()\t  # Check the result of difficulty\n\tgraphics.initialize_set(difficulty)\t\t # Initialize the bricks for different levels\n\n\tdx = graphics.get_ball_dx()\t\t\t\t # Get initial x-axis speed\n\tdy = graphics.get_ball_dy()\t\t\t\t # Get initial y-axis speed\n\tlife = NUM_LIVES\t\t\t\t\t\t\t# Total lives\n\tgraphics.set_lives(life)\t\t\t\t\t# Update Life boards\n\n\t# Add animation loop here!\n\twhile True:\n\t\tpause(FRAME_RATE)\n\n\t\tif graphics.get_lock():\n\t\t\tgraphics.get_ball().move(dx, dy)\n\n\t\t\t# Get the list of object for additional tools\n\t\t\textra_tool = graphics.get_tool_list()\n\n\t\t\t# The condition to bounce for the window boundary\n\t\t\tif graphics.get_ball().x + graphics.get_ball().width >= graphics.get_window().width or \\\n\t\t\t\t\tgraphics.get_ball().x <= 0:\n\t\t\t\tdx = -dx\n\t\t\tif graphics.get_ball().y <= 0:\n\t\t\t\tdy = -dy\n\n\t\t\t# The condition that life will reduce\n\t\t\tif graphics.get_ball().y + graphics.get_ball().height > \\\n\t\t\t\t\tgraphics.get_window().height + graphics.get_ball().height:\n\t\t\t\tgraphics.set_lives(-1)\n\t\t\t\tlife -= 1\n\t\t\t\tif life > 0:\n\t\t\t\t\tgraphics.reset_the_ball()\t\t\t\t\t   # Move the ball back to initial position\n\t\t\t\t\tgraphics.initialize_the_velocity(difficulty)\t# Initialize the speed\n\t\t\t\t\tdx = graphics.get_ball_dx()\n\t\t\t\t\tdy = graphics.get_ball_dy()\n\t\t\t\t\tgraphics.set_lock(False)\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\n\t\t\tif graphics.get_total_brick() == 0:\n\t\t\t\tbreak\n\n\t\t\t# Local variable for collision result\n\t\t\tobj = graphics.check_collision()\n\t\t\tif obj is not None:\n\t\t\t\tif obj == graphics.get_paddle():\n\t\t\t\t\tgraphics.get_ball().y = graphics.get_paddle().y - graphics.get_ball().height\n\t\t\t\t\tdy = -dy\n\t\t\t\t# If the ball collided with scoreboard and tools\n\t\t\t\telif obj in graphics.get_the_scoreboard() or obj in extra_tool:\n\t\t\t\t\tpass\n\t\t\t\telse:\n\t\t\t\t\tgraphics.get_window().remove(obj)\n\t\t\t\t\tgraphics.calculate_score(obj, difficulty)\n\t\t\t\t\t# Randomly generate tools for user\n\t\t\t\t\tseed = random.randint(1, 100)\n\t\t\t\t\tif seed >= 80:\n\t\t\t\t\t\tgraphics.generate_tools((seed % 5 + 1), graphics.get_ball().x + graphics.get_ball().width/2,\n\t\t\t\t\t\t\t\t\t\t\t\tgraphics.get_ball().y + graphics.get_ball().height/2)\n\t\t\t\t\tdy = -dy\n\n\t\t\t# Handle additional tools result, and move\n\t\t\tif extra_tool:\n\t\t\t\tfor tool in extra_tool:\n\t\t\t\t\ttool.move(0, 1)\n\n\t\t\t\t# Calculate additional effects for tools\n\t\t\t\tgraphics.check_tool_result(extra_tool)\n\n\n\tgraphics.show_the_result()\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics_ext import BreakoutGraphics", "import random"]}], [], [], [], [{"term": "class", "name": "TestThreeGraphicsTwoDimension", "data": "class TestThreeGraphicsTwoDimension(BaseMultiGraphicsTwoDimension):\n\tGraphics = BaseMultiGraphicsTwoDimension.TypeGraphics[:3]\n\tendpoint_get = EndpointConfig.endpoint_quarter\n\texpect_status_get = STATUS_200\n\n", "description": null, "category": "graphics", "imports": ["from test.base_test.base_dimension.baseMultiGraphicMixDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicOneDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicTwoDimension import \\", "from app.config.configEndpoint import EndpointConfig", "from app.messages.statusMessages import STATUS_200"]}, {"term": "class", "name": "TestTwoGraphicsTwoDimension", "data": "class TestTwoGraphicsTwoDimension(BaseMultiGraphicsTwoDimension):\n\tGraphics = BaseMultiGraphicsTwoDimension.TypeGraphics[:2]\n\tendpoint_get = EndpointConfig.endpoint_quarter\n\texpect_status_get = STATUS_200\n\n", "description": null, "category": "graphics", "imports": ["from test.base_test.base_dimension.baseMultiGraphicMixDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicOneDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicTwoDimension import \\", "from app.config.configEndpoint import EndpointConfig", "from app.messages.statusMessages import STATUS_200"]}, {"term": "class", "name": "TestThreeGraphicsOneDimension", "data": "class TestThreeGraphicsOneDimension(BaseMultiGraphicsOneDimension):\n\tGraphics = BaseMultiGraphicsOneDimension.TypeGraphics[:3]\n\tendpoint_get = EndpointConfig.endpoint_quarter\n\texpect_status_get = STATUS_200\n\n", "description": null, "category": "graphics", "imports": ["from test.base_test.base_dimension.baseMultiGraphicMixDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicOneDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicTwoDimension import \\", "from app.config.configEndpoint import EndpointConfig", "from app.messages.statusMessages import STATUS_200"]}, {"term": "class", "name": "TestTwoGraphicsOneDimension", "data": "class TestTwoGraphicsOneDimension(BaseMultiGraphicsOneDimension):\n\tGraphics = BaseMultiGraphicsOneDimension.TypeGraphics[:2]\n\tendpoint_get = EndpointConfig.endpoint_quarter\n\texpect_status_get = STATUS_200\n\n", "description": null, "category": "graphics", "imports": ["from test.base_test.base_dimension.baseMultiGraphicMixDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicOneDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicTwoDimension import \\", "from app.config.configEndpoint import EndpointConfig", "from app.messages.statusMessages import STATUS_200"]}, {"term": "class", "name": "TestFourGraphicsMixDimension", "data": "class TestFourGraphicsMixDimension(BaseMultiGraphicsMixDimension):\n\tGraphics = (\n\t\tBaseMultiGraphicsOneDimension.TypeGraphics[:2]\n\t\t+ BaseMultiGraphicsTwoDimension.TypeGraphics[:2]\n\t)\n\tendpoint_get = EndpointConfig.endpoint_square\n\texpect_status_get = STATUS_200\n\n", "description": null, "category": "graphics", "imports": ["from test.base_test.base_dimension.baseMultiGraphicMixDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicOneDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicTwoDimension import \\", "from app.config.configEndpoint import EndpointConfig", "from app.messages.statusMessages import STATUS_200"]}, {"term": "class", "name": "TestThreeGraphicsMixDimension", "data": "class TestThreeGraphicsMixDimension(BaseMultiGraphicsMixDimension):\n\tGraphics = (\n\t\tBaseMultiGraphicsOneDimension.TypeGraphics[:1]\n\t\t+ BaseMultiGraphicsTwoDimension.TypeGraphics[:2]\n\t)\n\tendpoint_get = EndpointConfig.endpoint_square\n\texpect_status_get = STATUS_200\n\n", "description": null, "category": "graphics", "imports": ["from test.base_test.base_dimension.baseMultiGraphicMixDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicOneDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicTwoDimension import \\", "from app.config.configEndpoint import EndpointConfig", "from app.messages.statusMessages import STATUS_200"]}, {"term": "class", "name": "TestTwoGraphicsMixDimension", "data": "class TestTwoGraphicsMixDimension(BaseMultiGraphicsMixDimension):\n\tGraphics = (\n\t\tBaseMultiGraphicsOneDimension.TypeGraphics[:1]\n\t\t+ BaseMultiGraphicsTwoDimension.TypeGraphics[:1]\n\t)\n\tendpoint_get = EndpointConfig.endpoint_square\n\texpect_status_get = STATUS_200\n", "description": null, "category": "graphics", "imports": ["from test.base_test.base_dimension.baseMultiGraphicMixDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicOneDimension import \\", "from test.base_test.base_dimension.baseMultiGraphicTwoDimension import \\", "from app.config.configEndpoint import EndpointConfig", "from app.messages.statusMessages import STATUS_200"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\t# Add animation loop here!\n\tcount = 0\n\tlive = NUM_LIVES\n\twhile live > 0:\n\t\tif graphics.ball.x != (graphics.window.width - graphics.ball.width) / 2 and graphics.ball.y != (\n\t\t\t\tgraphics.window.height - graphics.ball.height) / 2:\n\t\t\tgraphics.ball.move(graphics.vx, graphics.vy)\n\n\t\t\tif graphics.ball.x == (graphics.window.width - graphics.ball.width) / 2 or graphics.ball.y == (\n\t\t\t\t\tgraphics.window.height - graphics.ball.height) / 2:\n\t\t\t\tgraphics.ball.move(graphics.vx, graphics.vy)\n\t\t\t# The ball must be inside the window\n\t\t\tif graphics.ball.x <= 0 or graphics.ball.x+graphics.ball.width >= graphics.window.width:\n\t\t\t\tgraphics.vx = -graphics.vx\n\t\t\tif graphics.ball.y <= 0:\n\t\t\t\tgraphics.vy = -graphics.vy\n\n\t\t\t# When the ball falls\n\t\t\tgraphics.dead()\n\n\t\t\tp1 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y)\n\t\t\tp2 = graphics.window.get_object_at(graphics.ball.x + graphics.ball.width, graphics.ball.y)\n\t\t\tp3 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y + graphics.ball.width)\n\t\t\tp4 = graphics.window.get_object_at(graphics.ball.x + graphics.ball.width, graphics.ball.y + graphics.ball.width)\n\n\t\t\t# Check if there are any objects in the four corners\n\t\t\tif p1 is not None:\n\t\t\t\tif graphics.ball.y > graphics.window.height/2:\n\t\t\t\t\tgraphics.vy = -graphics.vy\n\t\t\t\telse:\n\t\t\t\t\tgraphics.window.remove(p1)\n\t\t\t\t\tcount += 1\n\t\t\t\t\tgraphics.vy = -graphics.vy\n\n\t\t\telif p2 is not None:\n\t\t\t\tif graphics.ball.y > graphics.window.height / 2:\n\t\t\t\t\tgraphics.vy = -graphics.vy\n\t\t\t\telse:\n\t\t\t\t\tgraphics.window.remove(p2)\n\t\t\t\t\tcount += 1\n\t\t\t\t\tgraphics.vy = -graphics.vy\n\n\t\t\telif p3 is not None:\n\t\t\t\tif graphics.ball.y > graphics.window.height / 2:\n\t\t\t\t\tgraphics.vy = -graphics.vy\n\t\t\t\telse:\n\t\t\t\t\tgraphics.window.remove(p3)\n\t\t\t\t\tcount += 1\n\t\t\t\t\tgraphics.vy = -graphics.vy\n\n\t\t\telif p4 is not None:\n\t\t\t\tif graphics.ball.y > graphics.window.height / 2:\n\t\t\t\t\tgraphics.vy = -graphics.vy\n\t\t\t\telse:\n\t\t\t\t\tgraphics.window.remove(p4)\n\t\t\t\t\tcount += 1\n\t\t\t\t\tgraphics.vy = -graphics.vy\n\n\t\tpause(FRAME_RATE)\n\n\t\t# When the ball falls once, it loses one life\n\t\tif graphics.ball.y >= graphics.window.height-10:\n\t\t\tlive -= 1\n\t\t\t# The ball falls below three times\n\t\t\tif live == 0:\n\t\t\t\tgraphics.lose()\n\t\t\t\tbreak\n\n\t\t# All bricks have been removed\n\t\telif count == graphics.count:\n\t\t\tgraphics.lose()\n\t\t\tbreak\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "class", "name": "GraphicsView", "data": "class GraphicsView(NSView):\n\tgraphicsContainer = objc.ivar(\"graphicsContainer\")\n\tgraphicsKeyPath = objc.ivar(\"graphicsKeyPath\")\n\n\tselectionIndexesContainer = objc.ivar(\n\t\t\"selectionIndexesContainer\"\n\t)  # GraphicsArrayController\n\tselectionIndexesKeyPath = objc.ivar(\"selectionIndexesKeyPath\")\n\n\toldGraphics = objc.ivar(\"oldGraphics\")\n\n\tdef exposedBindings(self):\n\t\treturn [\"graphics\", \"selectedObjects\"]\n\n\tdef initWithFrame_(self, frameRect):\n\t\treturn super().initWithFrame_(frameRect)\n\n\tdef graphics(self):\n\t\tif not self.graphicsContainer:\n\t\t\treturn None\n\t\treturn self.graphicsContainer.valueForKeyPath_(self.graphicsKeyPath)\n\n\tdef selectionIndexes(self):\n\t\tif not self.selectionIndexesContainer:\n\t\t\treturn None\n\t\treturn self.selectionIndexesContainer.valueForKeyPath_(\n\t\t\tself.selectionIndexesKeyPath\n\t\t)\n\n\tdef startObservingGraphics_(self, graphics):\n\t\tif not graphics:\n\t\t\treturn\n\t\t# Register to observe each of the new graphics, and\n\t\t# each of their observable properties -- we need old and new\n\t\t# values for drawingBounds to figure out what our dirty rect\n\t\tfor newGraphic in graphics:\n\t\t\t# Register as observer for all the drawing-related properties\n\t\t\tnewGraphic.addObserver_forKeyPath_options_context_(\n\t\t\t\tself,\n\t\t\t\t\"drawingBounds\",\n\t\t\t\t(NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld),\n\t\t\t\tPropertyObservationContext,\n\t\t\t)\n\t\t\tkeys = Circle.keysForNonBoundsProperties()\n\t\t\tfor key in keys:\n\t\t\t\tnewGraphic.addObserver_forKeyPath_options_context_(\n\t\t\t\t\tself, key, 0, PropertyObservationContext\n\t\t\t\t)\n\n\tdef stopObservingGraphics_(self, graphics):\n\t\tif graphics is None:\n\t\t\treturn\n\t\tfor graphic in graphics:\n\t\t\tfor key in graphic.class__().keysForNonBoundsProperties():\n\t\t\t\tgraphic.removeObserver_forKeyPath_(self, key)\n\t\t\tgraphic.removeObserver_forKeyPath_(self, \"drawingBounds\")\n\n\tdef bind_toObject_withKeyPath_options_(\n\t\tself, bindingName, observableObject, observableKeyPath, options\n\t):\n\t\tif bindingName == \"graphics\":\n\t\t\tself.graphicsContainer = observableObject\n\t\t\tself.graphicsKeyPath = observableKeyPath\n\t\t\tself.graphicsContainer.addObserver_forKeyPath_options_context_(\n\t\t\t\tself,\n\t\t\t\tself.graphicsKeyPath,\n\t\t\t\t(NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld),\n\t\t\t\tGraphicsObservationContext,\n\t\t\t)\n\t\t\tself.startObservingGraphics_(self.graphics())\n\n\t\telif bindingName == \"selectionIndexes\":\n\t\t\tself.selectionIndexesContainer = observableObject\n\t\t\tself.selectionIndexesKeyPath = observableKeyPath\n\t\t\tself.selectionIndexesContainer.addObserver_forKeyPath_options_context_(\n\t\t\t\tself,\n\t\t\t\tself.selectionIndexesKeyPath,\n\t\t\t\t0,\n\t\t\t\tSelectionIndexesObservationContext,\n\t\t\t)\n\t\tself.setNeedsDisplay_(True)\n\n\tdef unbind_(self, bindingName):\n\t\tif bindingName == \"graphics\":\n\t\t\tself.graphicsContainer.removeObserver_forKeyPath_(\n\t\t\t\tself, self.graphicsKeyPath\n\t\t\t)\n\t\t\tself.graphicsContainer = None\n\t\t\tself.graphicsKeyPath = None\n\t\tif bindingName == \"selectionIndexes\":\n\t\t\tself.selectionIndexesContainer.removeObserver_forKeyPath_(\n\t\t\t\tself, self.selectionIndexesKeyPath\n\t\t\t)\n\t\t\tself.seletionIndexesContainer = None\n\t\t\tself.selectionIndexesKeyPath = None\n\t\tself.setNeedsDisplay_(True)\n\n\tdef observeValueForKeyPath_ofObject_change_context_(\n\t\tself, keyPath, an_object, change, context\n\t):\n\t\tif context == GraphicsObservationContext:\n\t\t\t# Should be able to use\n\t\t\t# NSArray *oldGraphics = [change objectForKey:NSKeyValueChangeOldKey];\n\t\t\t# etc. but the dictionary doesn't contain old and new arrays...??\n\t\t\tnewGraphics = set(an_object.valueForKeyPath_(self.graphicsKeyPath))\n\t\t\tonlyNew = newGraphics - set(self.oldGraphics or [])\n\t\t\tself.startObservingGraphics_(onlyNew)\n\n\t\t\tif self.oldGraphics:\n\t\t\t\tremoved = set(self.oldGraphics) - newGraphics\n\t\t\t\tself.stopObservingGraphics_(removed)\n\n\t\t\tself.oldGraphics = newGraphics\n\n\t\t\t# could check drawingBounds of old and new, but...\n\t\t\tself.setNeedsDisplay_(True)\n\t\t\treturn\n\n\t\tif context == PropertyObservationContext:\n\t\t\tupdateRect = (0,)\n\t\t\t# Note: for Circle, drawingBounds is a dependent key of all the other\n\t\t\t# property keys except color, so we'll get this anyway...\n\t\t\tif keyPath == \"drawingBounds\":\n\t\t\t\tnewBounds = change.objectForKey_(NSKeyValueChangeNewKey)\n\t\t\t\toldBounds = change.objectForKey_(NSKeyValueChangeOldKey)\n\t\t\t\tupdateRect = NSUnionRect(newBounds, oldBounds)\n\t\t\telse:\n\t\t\t\tupdateRect = an_object.drawingBounds()\n\t\t\tupdateRect = NSMakeRect(\n\t\t\t\tupdateRect.origin.x - 1.0,\n\t\t\t\tupdateRect.origin.y - 1.0,\n\t\t\t\tupdateRect.size.width + 2.0,\n\t\t\t\tupdateRect.size.height + 2.0,\n\t\t\t)\n\t\t\tself.setNeedsDisplay_(True)\n\t\t\treturn\n\n\t\tif context == SelectionIndexesObservationContext:\n\t\t\tself.setNeedsDisplay_(True)\n\t\t\treturn\n\n\tdef drawRect_(self, rect):\n\t\tmyBounds = self.bounds()\n\t\tNSDrawLightBezel(myBounds, myBounds)  # AppKit Function\n\t\tclipRect = NSBezierPath.bezierPathWithRect_(NSInsetRect(myBounds, 2.0, 2.0))\n\t\tclipRect.addClip()\n\n\t\t# Draw graphics\n\t\tgraphicsArray = self.graphics()\n\t\tif graphicsArray:\n\t\t\tfor graphic in graphicsArray:\n\t\t\t\tgraphicDrawingBounds = graphic.drawingBounds()\n\t\t\t\tif NSIntersectsRect(rect, graphicDrawingBounds):\n\t\t\t\t\tgraphic.drawInView_(self)\n\n\t\t# Draw a red box around items in the current selection.\n\t\t# Selection should be handled by the graphic, but this is a\n\t\t# shortcut simply for display.\n\n\t\tcurrentSelectionIndexes = self.selectionIndexes()\n\t\tif currentSelectionIndexes is not None:\n\t\t\tpath = NSBezierPath.bezierPath()\n\t\t\tindex = currentSelectionIndexes.firstIndex()\n\t\t\twhile index != NSNotFound:\n\t\t\t\tgraphicDrawingBounds = graphicsArray[index].drawingBounds()\n\t\t\t\tif NSIntersectsRect(rect, graphicDrawingBounds):\n\t\t\t\t\tpath.appendBezierPathWithRect_(graphicDrawingBounds)\n\t\t\t\tindex = currentSelectionIndexes.indexGreaterThanIndex_(index)\n\n\t\t\tNSColor.redColor().set()\n\t\t\tpath.setLineWidth_(1.5)\n\t\t\tpath.stroke()\n\n\t\t# Fairly simple just to illustrate the point\n\n\tdef mouseDown_(self, event):\n\t\t# find out if we hit anything\n\t\tp = self.convertPoint_fromView_(event.locationInWindow(), None)\n\t\tfor aGraphic in self.graphics():\n\t\t\tif aGraphic.hitTest_isSelected_(p, False):\n\t\t\t\tbreak\n\n\t\telse:\n\t\t\taGraphic = None\n\n\t\t# if no graphic hit, then if extending selection do nothing\n\t\t# else set selection to nil\n\t\tif aGraphic is None:\n\t\t\tif not event.modifierFlags() & NSShiftKeyMask:\n\t\t\t\tself.selectionIndexesContainer.setValue_forKeyPath_(\n\t\t\t\t\tNone, self.selectionIndexesKeyPath\n\t\t\t\t)\n\t\t\treturn\n\n\t\t# graphic hit\n\t\t# if not extending selection (Shift key down) then set\n\t\t# selection to this graphic\n\t\t# if extending selection, then:\n\t\t# - if graphic in selection remove it\n\t\t# - if not in selection add it\n\t\tgraphicIndex = self.graphics().index(aGraphic)\n\t\tif not event.modifierFlags() & NSShiftKeyMask:\n\t\t\tselection = NSIndexSet.indexSetWithIndex_(graphicIndex)\n\t\telse:\n\t\t\tif self.selectionIndexes().containsIndex_(graphicIndex):\n\t\t\t\tselection = self.selectionIndexes().mutableCopy()\n\t\t\t\tselection.removeIndex_(graphicIndex)\n\t\t\telse:\n\t\t\t\tselection = self.selectionIndexes().mutableCopy()\n\t\t\t\tselection.addIndex_(graphicIndex)\n\n\t\tself.selectionIndexesContainer.setValue_forKeyPath_(\n\t\t\tselection, self.selectionIndexesKeyPath\n\t\t)\n\n", "description": null, "category": "graphics", "imports": ["import objc", "from Circle import Circle", "from Cocoa import (", "from objc import super"]}], [], [{"term": "class", "name": "Display", "data": "class Display(object):\n\t\n\tWHITE = graphicsUtils.formatColor(1.0, 1.0, 1.0)\n\tRED = graphicsUtils.formatColor(1.0, 0.0, 0.0)\n\tGREEN = graphicsUtils.formatColor(0.16, 0.49, 0.31)\n\tBLUE = graphicsUtils.formatColor(0.0, 0.0, 1.0)\n\tBLACK = graphicsUtils.formatColor(0.0, 0.0, 0.0)\n\tGREY = graphicsUtils.formatColor(0.5, .5, 0.5)\n\t\n\tVISIBLE_CUTTOFF = 0.001\n\t\n\t\n\tpartDict = {}\n\tbeliefParts = []\n\tbeliefValue = []\n\tbeliefColor = []\n\tobservations = []\n\t\n\tgraphicsLock = threading.Lock()\n\t\n\tCOLORS = [\n\t\t'purple',\n\t\t'green',\n\t\t'teal',\n\t\t'red',\n\t\t'orange',\n\t\t'yellow'\n\t]\n\tCOLOR_HUES = {\n\t\t'purple' : 0.8,\n\t\t'green' : 0.3,\n\t\t'teal' : 0.49,\n\t\t'red' : 0.0,\n\t\t'orange' : 0.125,\n\t\t'yellow' : 0.21\n\t}\n\t\n\t@staticmethod\n\tdef initGraphics(layout):\n\t\tgraphicsUtils.begin_graphics(\n\t\t\twidth=layout.getWidth(), \n\t\t\theight=layout.getHeight(), \n\t\t\tcolor = Display.WHITE,\n\t\t\ttitle = Const.TITLE\n\t\t);\n\t\t\n\t@staticmethod\n\tdef endGraphics():\n\t\tgraphicsUtils.end_graphics()\n\n\t@staticmethod\n\tdef raiseEndGraphics():\n\t\tgraphicsUtils.raiseEndGraphics()\n\t\n\t@staticmethod\n\tdef drawCar(car):\n\t\tif car in Display.partDict:\n\t\t\tDisplay._remove(car)\n\t\tcolor = Display.GREY\n\t\tif car.isJunior():\n\t\t\tcolor = Display.BLACK\n\t\tparts = graphicsUtils.rectangle(\n\t\t\tcar.pos, Car.LENGTH, \n\t\t\tCar.WIDTH, \n\t\t\tcolor, \n\t\t\tcar.dir\n\t\t)\n\t\tDisplay.partDict[car] = parts\n\t\t\n\t@staticmethod\n\tdef drawObservation(obs):\n\t\tparts = Display.drawCircle(obs.pos, Observation.RADIUS)\n\t\tDisplay.partDict[obs] = parts\n\t\n\t@staticmethod\n\tdef drawSquare(pos, size, color):\n\t\treturn graphicsUtils.square(pos, size, color)\n\t\n\t@staticmethod\n\tdef drawFinish(block):\n\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.GREEN, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\n\t@staticmethod\n\tdef drawBlocks(blocks):\n\t\tfor block in blocks:\n\t\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.BLUE, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\t\n\t@staticmethod\n\tdef drawCircle(pos, radius):\n\t\treturn graphicsUtils.circle(pos, radius, Display.RED, Display.RED)\n\t\n\t@staticmethod\n\tdef drawBelief(model):\n\t\tDisplay.beliefVisible = []\n\t\tfor r in range(model.getBeliefRows()):\n\t\t\tbeliefValueRow = []\n\t\t\tbeliefPartRow = []\n\t\t\tbeliefColorRow = []\n\t\t\tfor c in range(model.getBeliefCols()):\n\t\t\t\tsquare = Display.drawBeliefSquare(r, c, 'purple', 0.0, model)\n\t\t\t\tbeliefPartRow.append(square)\n\t\t\t\tbeliefValueRow.append(0.0)\n\t\t\t\tbeliefColorRow.append(None)\n\t\t\tDisplay.beliefParts.append(beliefPartRow)\n\t\t\tDisplay.beliefValue.append(beliefValueRow)\n\t\t\tDisplay.beliefColor.append(beliefColorRow)\n\t\t\t\t\n\t@staticmethod\n\tdef drawBeliefSquare(row, col, color, value, model):\n\t\ttileSize = Const.BELIEF_TILE_SIZE\n\t\tx = col * tileSize + tileSize / 2.0\n\t\ty = row * tileSize + tileSize / 2.0\n\t\tif not model.inBounds(x, y): return None\n\t\tcolor = Display._getBeliefSquareColor(color, value)\n\t\treturn Display.drawSquare(Vec2d(x, y), tileSize, color)\n\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef getKeys():\n\t\t#print 'attempt get keys'\n\t\tDisplay._acquireLock()\n\t\t#print 'get keys'\n\t\tkeys = graphicsUtils.keys_waiting() + graphicsUtils.keys_pressed()\n\t\tDisplay._releaseLock()\n\t\treturn keys\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef graphicsSleep(timeToSleep):\n\t\tgraphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''for _ in range(int(timeToSleep / 0.005)):\n\t\t\t#print 'attempt sleep'\n\t\t\tDisplay._acquireLock()\n\t\t\t#print 'sleep'\n\t\t\tgraphicsUtils.sleep(0.001)\n\t\t\tDisplay._releaseLock()\n\t\t\ttime.sleep(0.004)'''\n\t\t\n\t\t#graphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''startWait = time.time()\n\t\tDisplay._acquireLock()\n\t\ttimeToSleep -= time.time() - startWait\n\t\tgraphicsUtils.refresh()\n\t\tif timeToSleep > 0:\n\t\t\tgraphicsUtils.sleep(timeToSleep)\n\t\tDisplay._releaseLock()'''\n\t\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef updateBelief(color, belief):\n\t\tDisplay._acquireLock()\n\t\ttotal = belief.getSum()\n\t\tif abs(total - 1.0) > 0.001:\n\t\t\traise Exception('belief does not sum to 1 ('+str(total)+'). Use the normalize method.')\n\t\tfor r in range(belief.getNumRows()):\n\t\t\tfor c in range(belief.getNumCols()):\n\t\t\t\tvalue = belief.getProb(r, c)\n\t\t\t\tDisplay._updateBeliefSquare(r, c, value, color)\n\t\tDisplay._releaseLock()\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef move(obj, delta):\n\t\t#print 'attempt move'\n\t\tDisplay._acquireLock()\n\t\t#print 'move'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.move_by(parts, delta.x, delta.y)\n\t\t#print 'end move'\n\t\tDisplay._releaseLock()\n\t\t\n\t# make thread safe\n\t@staticmethod\n\tdef rotate(obj, angle):\n\t\tif angle == 0: return\n\t\t#print 'attempt rotate'\n\t\tDisplay._acquireLock()\n\t\t#print 'rotate'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.rotate_by(parts, angle)\n\t\tDisplay._releaseLock()\n\t\t\t\t\n\t@staticmethod\n\tdef _getBeliefSquareColor(color, value):\n\t\tvalue = min(1.0, value * 15)\n\t\tsaturation = value\n\t\thue = Display.COLOR_HUES[color]\n\t\tr, g, b = colorsys.hsv_to_rgb(hue, saturation, 1.0)\n\t\tcolor = graphicsUtils.formatColor(r, g, b)\n\t\treturn color\t\t\n\t\n\t@staticmethod\n\tdef _isVisible(value):\n\t\treturn value >= Display.VISIBLE_CUTTOFF\n\t\n\t@staticmethod\n\tdef _updateBeliefSquare(r, c, value, colorName):\n\t\tpart = Display.beliefParts[r][c]\n\t\tif part == None: return\n\t\toldValue = Display.beliefValue[r][c]\n\t\toldColor = Display.beliefColor[r][c]\n\t\twasVisible = Display._isVisible(oldValue)\n\t\tisVisible = Display._isVisible(value) \n\t\tif not isVisible: value = 0.0\n\t\tif oldColor != colorName and oldValue >= value: return\n\t\tif not isVisible and not wasVisible: return\n\t\tcolor = Display._getBeliefSquareColor(colorName, value)\n\t\tgraphicsUtils.changeColor(part, color)\n\t\tDisplay.beliefValue[r][c] = value\n\t\tDisplay.beliefColor[r][c] = colorName\n\t\t\n\t@staticmethod\n\tdef _acquireLock():\n\t\treturn\n\t\t#print 'acquire'\n\t\treturn Display.graphicsLock.acquire()\n\t\n\t@staticmethod\n\tdef _releaseLock():\n\t\treturn\n\t\t#print 'release'\n\t\treturn Display.graphicsLock.release()\n\t \n\t####################################\n\t# Depreicated\n\t####################################\n\t\t\n\t@staticmethod\n\tdef _remove(obj):\n\t\tparts = Display.partDict[obj]\n\t\tgraphicsUtils.remove_from_screen(parts);\n\t\t\n\t@staticmethod\n\tdef redrawObservations(observations):\n\t\traise Exception('depreicated')\n\t\tfor obs in Display.observations:\n\t\t\tDisplay._remove(obs)\n\t\tfor obs in observations:\n\t\t\tDisplay.drawObservation(obs)\n\t\tDisplay.observations = observations\n", "description": null, "category": "graphics", "imports": ["from . import graphicsUtils", "from engine.model.car.car import Car", "from engine.const import Const", "from engine.model.observation import Observation", "from engine.vector import Vec2d", "import colorsys", "import threading"]}], [{"term": "def", "name": "rectangle_overlaps", "data": "def rectangle_overlaps(x1, y1, width1, height1, x2, y2, width2, height2):\r\n\tif ((x1 - width1 / 2) > (x2 + width2 / 2)) or ((x1 + width1 / 2) < (x2 - width2 / 2)):\r\n\t\treturn False\r\n\r\n\telse:\r\n\t\tif ((y1 - height1 / 2) > (y2 + height2 / 2)) or ((y1 + height1 / 2) < (y2 - height2 / 2)):\r\n\t\t\treturn False\r\n\t\telse:\r\n\t\t\treturn True\r\n\r\n\r\n\r\n", "description": null, "category": "graphics", "imports": ["import graphics\r"]}], [], [{"term": "def", "name": "app", "data": "def app(args: list[str] | None = None) -> Application:\n\tinstance = Application.instance()\n\tif instance is not None:\n\t\treturn instance\n\tApplication.disable_window_help_button()\n\treturn Application([] if args is None else args)\n\n", "description": null, "category": "graphics", "imports": ["from __future__ import annotations", "from prettyqt.qt.QtWidgets import (", "from .style import Style", "from .commonstyle import CommonStyle", "from .proxystyle import ProxyStyle", "from .application import Application", "from .sizepolicy import SizePolicy", "from .widget import Widget", "from .frame import Frame", "from .focusframe import FocusFrame", "from .abstractslider import AbstractSlider", "from .abstractscrollarea import AbstractScrollArea", "from .abstractbutton import AbstractButton", "from .abstractspinbox import AbstractSpinBox", "from .abstractitemview import AbstractItemView", "from .scrollbar import ScrollBar", "from .scrollarea import ScrollArea", "from .rubberband import RubberBand", "from .graphicstransform import GraphicsTransform", "from .graphicsrotation import GraphicsRotation", "from .graphicsscale import GraphicsScale", "from .graphicsitem import GraphicsItem", "from .graphicsitemgroup import GraphicsItemGroup", "from .abstractgraphicsshapeitem import AbstractGraphicsShapeItem", "from .graphicspixmapitem import GraphicsPixmapItem", "from .graphicsobject import GraphicsObject", "from .graphicstextitem import GraphicsTextItem", "from .graphicslayoutitem import GraphicsLayoutItem", "from .graphicslayout import GraphicsLayout", "from .graphicsgridlayout import GraphicsGridLayout", "from .graphicslinearlayout import GraphicsLinearLayout", "from .graphicsanchorlayout import GraphicsAnchorLayout", "from .graphicswidget import GraphicsWidget", "from .graphicsproxywidget import GraphicsProxyWidget", "from .graphicslineitem import GraphicsLineItem", "from .graphicsrectitem import GraphicsRectItem", "from .graphicssimpletextitem import GraphicsSimpleTextItem", "from .graphicspolygonitem import GraphicsPolygonItem", "from .graphicsellipseitem import GraphicsEllipseItem", "from .graphicspathitem import GraphicsPathItem", "from .graphicseffect import GraphicsEffect", "from .graphicsblureffect import GraphicsBlurEffect", "from .graphicscolorizeeffect import GraphicsColorizeEffect", "from .graphicsdropshadoweffect import GraphicsDropShadowEffect", "from .graphicsopacityeffect import GraphicsOpacityEffect", "from .graphicsscene import GraphicsScene", "from .graphicsview import GraphicsView", "from .styleoption import StyleOption", "from .styleoptionbutton import StyleOptionButton", "from .styleoptioncomplex import StyleOptionComplex", "from .styleoptiondockwidget import StyleOptionDockWidget", "from .styleoptionfocusrect import StyleOptionFocusRect", "from .styleoptionframe import StyleOptionFrame", "from .styleoptiongraphicsitem import StyleOptionGraphicsItem", "from .styleoptionheader import StyleOptionHeader", "from .styleoptionmenuitem import StyleOptionMenuItem", "from .styleoptionprogressbar import StyleOptionProgressBar", "from .styleoptionrubberband import StyleOptionRubberBand", "from .styleoptiontab import StyleOptionTab", "from .styleoptiontabbarbase import StyleOptionTabBarBase", "from .styleoptiontabwidgetframe import StyleOptionTabWidgetFrame", "from .styleoptiontoolbar import StyleOptionToolBar", "from .styleoptiontoolbox import StyleOptionToolBox", "from .styleoptionviewitem import StyleOptionViewItem", "from .styleoptioncombobox import StyleOptionComboBox", "from .styleoptiongroupbox import StyleOptionGroupBox", "from .styleoptionsizegrip import StyleOptionSizeGrip", "from .styleoptionslider import StyleOptionSlider", "from .styleoptionspinbox import StyleOptionSpinBox", "from .styleoptiontitlebar import StyleOptionTitleBar", "from .styleoptiontoolbutton import StyleOptionToolButton", "from .stylepainter import StylePainter", "from .stylefactory import StyleFactory", "from .pushbutton import PushButton", "from .dialogbuttonbox import DialogButtonBox", "from .dialog import Dialog", "from .messagebox import MessageBox", "from .errormessage import ErrorMessage", "from .fileiconprovider import FileIconProvider", "from .filesystemmodel import FileSystemModel", "from .slider import Slider", "from .dial import Dial", "from .dockwidget import DockWidget", "from .action import Action", "from .actiongroup import ActionGroup", "from .shortcut import Shortcut", "from .undocommand import UndoCommand", "from .undostack import UndoStack", "from .undogroup import UndoGroup", "from .widgetaction import WidgetAction", "from .menu import Menu", "from .mainwindow import MainWindow", "from .whatsthis import WhatsThis", "from .listwidgetitem import ListWidgetItem", "from .treewidgetitem import TreeWidgetItem", "from .toolbutton import ToolButton", "from .tooltip import ToolTip", "from .menubar import MenuBar", "from .statusbar import StatusBar", "from .tabbar import TabBar", "from .tabwidget import TabWidget", "from .mdisubwindow import MdiSubWindow", "from .mdiarea import MdiArea", "from .toolbar import ToolBar", "from .headerview import HeaderView", "from .label import Label", "from .commandlinkbutton import CommandLinkButton", "from .radiobutton import RadioButton", "from .combobox import ComboBox", "from .fontcombobox import FontComboBox", "from .spinbox import SpinBox", "from .doublespinbox import DoubleSpinBox", "from .checkbox import CheckBox", "from .lineedit import LineEdit", "from .keysequenceedit import KeySequenceEdit", "from .textedit import TextEdit", "from .datetimeedit import DateTimeEdit", "from .dateedit import DateEdit", "from .timeedit import TimeEdit", "from .calendarwidget import CalendarWidget", "from .plaintextedit import PlainTextEdit", "from .textbrowser import TextBrowser", "from .completer import Completer", "from .progressbar import ProgressBar", "from .lcdnumber import LCDNumber", "from .columnview import ColumnView", "from .listview import ListView", "from .listwidget import ListWidget", "from .treeview import TreeView", "from .tablewidgetselectionrange import TableWidgetSelectionRange", "from .treewidget import TreeWidget", "from .treewidgetitemiterator import TreeWidgetItemIterator", "from .tableview import TableView", "from .tablewidgetitem import TableWidgetItem", "from .tablewidget import TableWidget", "from .scrollerproperties import ScrollerProperties", "from .scroller import Scroller", "from .abstractitemdelegate import AbstractItemDelegate", "from .itemdelegate import ItemDelegate", "from .styleditemdelegate import StyledItemDelegate", "from .systemtrayicon import SystemTrayIcon", "from .layoutitem import LayoutItem", "from .widgetitem import WidgetItem", "from .layout import Layout", "from .spaceritem import SpacerItem", "from .formlayout import FormLayout", "from .boxlayout import BoxLayout", "from .stackedlayout import StackedLayout", "from .gridlayout import GridLayout", "from .toolbox import ToolBox", "from .splashscreen import SplashScreen", "from .progressdialog import ProgressDialog", "from .fontdialog import FontDialog", "from .filedialog import FileDialog", "from .colordialog import ColorDialog", "from .inputdialog import InputDialog", "from .buttongroup import ButtonGroup", "from .groupbox import GroupBox", "from .splitterhandle import SplitterHandle", "from .splitter import Splitter", "from .wizard import Wizard", "from .wizardpage import WizardPage", "from .stackedwidget import StackedWidget", "from .undoview import UndoView", "from .datawidgetmapper import DataWidgetMapper", "from .sizegrip import SizeGrip", "from .plaintextdocumentlayout import PlainTextDocumentLayout", "from .gesture import Gesture", "from .tapgesture import TapGesture", "from .tapandholdgesture import TapAndHoldGesture", "from .pangesture import PanGesture", "from .pinchgesture import PinchGesture", "from .swipegesture import SwipeGesture", "from .itemeditorcreatorbase import ItemEditorCreatorBase", "from .itemeditorfactory import ItemEditorFactory"]}], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, **kargs):\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, **kargs):\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [], [], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\r\n\t\"\"\"\r\n\tConvenience class consisting of a :class:`GraphicsView \r\n\t` with a single :class:`GraphicsLayout\r\n\t` as its central item. \r\n\r\n\tThis class wraps several methods from its internal GraphicsLayout:\r\n\t:func:`nextRow `\r\n\t:func:`nextColumn `\r\n\t:func:`addPlot `\r\n\t:func:`addViewBox `\r\n\t:func:`addItem `\r\n\t:func:`getItem `\r\n\t:func:`addLabel `\r\n\t:func:`addLayout `\r\n\t:func:`removeItem `\r\n\t:func:`itemIndex `\r\n\t:func:`clear `\r\n\t\"\"\"\r\n\tdef __init__(self, parent=None, **kargs):\r\n\t\tGraphicsView.__init__(self, parent)\r\n\t\tself.ci = GraphicsLayout(**kargs)\r\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\r\n\t\t\tsetattr(self, n, getattr(self.ci, n))\r\n\t\tself.setCentralItem(self.ci)\r\n", "description": "\r\n\tConvenience class consisting of a :class:`GraphicsView \r\n\t` with a single :class:`GraphicsLayout\r\n\t` as its central item. \r\n\r\n\tThis class wraps several methods from its internal GraphicsLayout:\r\n\t:func:`nextRow `\r\n\t:func:`nextColumn `\r\n\t:func:`addPlot `\r\n\t:func:`addViewBox `\r\n\t:func:`addItem `\r\n\t:func:`getItem `\r\n\t:func:`addLabel `\r\n\t:func:`addLayout `\r\n\t:func:`removeItem `\r\n\t:func:`itemIndex `\r\n\t:func:`clear `\r\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui\r", "from ..graphicsItems.GraphicsLayout import GraphicsLayout\r", "from .GraphicsView import GraphicsView\r"]}], [{"term": "def", "name": "color_for", "data": "def color_for ( color ):\n\t\"\"\" Returns the specified color as a QColor.\n\t\"\"\"\n\tif isinstance( color, tuple ):\n\t\treturn QColor( *color )\n\n\tif isinstance( color, int ):\n\t\treturn QColor( (color & 0xFF0000) / 65536,\n\t\t\t\t\t   (color & 0x00FF00) / 256,\n\t\t\t\t\t\tcolor & 0x0000FF )\n\n\treturn color\n\n", "description": " Returns the specified color as a QColor.\n\t", "category": "graphics", "imports": ["\timport Qt, QPoint", "\timport QColor, QPainter, QPen, QBrush, QPixmap, QFontMetrics", "\timport Graphics", "\timport create_facets_font", "\t\tfrom facets.ui.pen import Pen"]}, {"term": "def", "name": "painter_for", "data": "def painter_for ( context ):\n\t\"\"\" Returns a QPainter for the specified *context* object.\n\t\"\"\"\n\tgraphics = QPainter( context )\n\tgraphics.setRenderHint( QPainter.TextAntialiasing )\n\n\treturn graphics\n", "description": " Returns a QPainter for the specified *context* object.\n\t", "category": "graphics", "imports": ["\timport Qt, QPoint", "\timport QColor, QPainter, QPen, QBrush, QPixmap, QFontMetrics", "\timport Graphics", "\timport create_facets_font", "\t\tfrom facets.ui.pen import Pen"]}, {"term": "class", "name": "QtGraphics", "data": "class QtGraphics ( Graphics ):\n\n\t#-- Property Implementations -----------------------------------------------\n\n\tdef _get_pen ( self ):\n\t\treturn self.graphics.pen()\n\n\tdef _set_pen ( self, pen ):\n\t\tfrom facets.ui.pen import Pen\n\n\t\tself._no_pen = (pen is None)\n\t\tif self._no_pen:\n\t\t\tpen = Qt.NoPen\n\t\telif isinstance( pen, Pen ):\n\t\t\tqpen = QPen( pen.color )\n\t\t\tqpen.setStyle( LineStyles[ pen.style ] )\n\t\t\tqpen.setWidth( pen.width )\n\t\t\tpen = qpen\n\t\telif not isinstance( pen, QPen ):\n\t\t\tpen = color_for( pen )\n\n\t\tself.graphics.setPen( pen )\n\n\n\tdef _get_brush ( self ):\n\t\treturn self.graphics.brush()\n\n\tdef _set_brush ( self, color ):\n\t\tif color is None:\n\t\t\tself.graphics.setBrush( Qt.NoBrush )\n\t\telse:\n\t\t\tself.graphics.setBrush( QBrush( color_for( color ) ) )\n\n\n\tdef _set_xor_mode ( self, is_xor_mode ):\n\t\tif is_xor_mode:\n\t\t\tself.graphics.setCompositionMode( QPainter.CompositionMode_Xor )\n\n\n\tdef _set_anti_alias ( self, anti_alias ):\n\t\tself.graphics.setRenderHint( QPainter.Antialiasing, anti_alias )\n\n\n\tdef _get_font ( self ):\n\t\tif self._font is not None:\n\t\t\treturn self._font\n\n\t\treturn self.graphics.font()\n\n\tdef _set_font ( self, font ):\n\t\tif isinstance( font, int ):\n\t\t\tfont = str( font )\n\n\t\tif isinstance( font, basestring ):\n\t\t\tfont = create_facets_font( font )\n\n\t\tascent = getattr( font, '_ascent', None )\n\t\tif ascent is None:\n\t\t\tfont._ascent = ascent = QFontMetrics( font ).ascent()\n\n\t\tself._ascent = ascent\n\t\tself._font   = font\n\t\tif not self._temp_graphics:\n\t\t\tself.graphics.setFont( font )\n\n\n\tdef _get_text_color ( self ):\n\t\treturn self.graphics.pen().color()\n\n\tdef _set_text_color ( self, color ):\n\t\tself._set_pen( color )\n\n\n\tdef _get_text_background_color ( self ):\n\t\tif self.graphics.backgroundMode() == Qt.TransparentMode:\n\t\t\treturn None\n\n\t\treturn self.graphics.background().color()\n\n\tdef _set_text_background_color ( self, color ):\n\t\tif color is None:\n\t\t\tself.graphics.setBackgroundMode( Qt.TransparentMode )\n\n\t\t\treturn\n\n\t\tself.graphics.setBackground( QBrush( color_for( color ) ) )\n\t\tself.graphics.setBackgroundMode( Qt.OpaqueMode )\n\n\n\tdef _get_opacity ( self ):\n\t\treturn self.graphics.opacity()\n\n\tdef _set_opacity ( self, opacity ):\n\t\tself.graphics.setOpacity( opacity )\n\n\n\tdef _get_clipping_bounds ( self ):\n\t\trect = self.graphics.clipRegion().boundingRect()\n\n\t\treturn ( rect.x(), rect.y(), rect.width(), rect.height() )\n\n\tdef _set_clipping_bounds ( self, x_y_dx_dy ):\n\t\tif x_y_dx_dy is None:\n\t\t\tself.graphics.setClipping( False )\n\t\telse:\n\t\t\tself.graphics.setClipping( True )\n\t\t\tself.graphics.setClipRect( *x_y_dx_dy )\n\n\n\tdef _get_size ( self ):\n\t\t# fixme: I'm not sure if this is the right call to make...\n\t\trect = self.graphics.viewport()\n\n\t\treturn ( rect.width(), rect.height() )\n\n\t#-- Method Definitions -----------------------------------------------------\n\n\tdef draw_rectangle ( self, x, y, dx, dy ):\n\t\t\"\"\" Draws a rectangle at the specified position and with the specified\n\t\t\twidth and height.\n\t\t\"\"\"\n\t\tif self._no_pen:\n\t\t\tself.graphics.drawRect( x, y, dx, dy )\n\t\telse:\n\t\t\tself.graphics.drawRect( x, y, dx - 1, dy - 1 )\n\n\n\tdef draw_rounded_rectangle ( self, x, y, dx, dy, radius ):\n\t\t\"\"\" Draws a rectangle with rounded corners at the specified position\n\t\t\tand with the specified size and corner radius.\n\t\t\"\"\"\n\t\tself.graphics.drawRoundedRect ( x, y, dx, dy,\n\t\t\t\t\t\t\t\t\t\tfloat( radius ), float( radius ) )\n\n\n\tdef draw_circle ( self, x, y, radius ):\n\t\t\"\"\" Draws a circle with the specified center point (x,y) and radius.\n\t\t\"\"\"\n\t\tself.graphics.drawEllipse( QPoint( x, y ), radius, radius )\n\n\n\tdef draw_line ( self, x1, y1, x2, y2 ):\n\t\t\"\"\" Draws a line from (x1,y1) to (x2,y2).\n\t\t\"\"\"\n\t\tself.graphics.drawLine( x1, y1, x2, y2 )\n\n\n\tdef draw_bitmap ( self, bitmap, x, y ):\n\t\t\"\"\" Draws a specified bitmap at the specified location.\n\t\t\"\"\"\n\t\tself.graphics.drawPixmap( x, y, bitmap )\n\n\n\tdef bitmap_size ( self, bitmap ):\n\t\t\"\"\" Returns the size (dx,dy) of the specified toolkit specific bitmap:\n\t\t\"\"\"\n\t\treturn ( bitmap.width(), bitmap.height() )\n\n\n\tdef draw_text ( self, text, x, y ):\n\t\t\"\"\" Draws the specified text string at the specified (x,y) location.\n\t\t\"\"\"\n\t\tself.graphics.drawText( x, y + (self._ascent or 12), text )\n\n\n\tdef text_size ( self, text ):\n\t\t\"\"\" Returns the size (dx,dy) of the specified text using the current\n\t\t\tfont.\n\t\t\"\"\"\n\t\trect = QFontMetrics( self.font ).boundingRect( text )\n\n\t\treturn ( rect.width(), rect.height() )\n\n\n\tdef graphics_bitmap ( self, bitmap ):\n\t\t\"\"\" Returns a new graphics memory object using the specified bitmap.\n\t\t\"\"\"\n\t\treturn QtGraphics( painter_for( bitmap ) )\n\n\n\tdef graphics_buffer ( self, dx = None, dy = None, alpha = False ):\n\t\t\"\"\" Returns a new graphics memory object of the specified size (dx,dy)\n\t\t\tthat can be used to implement a buffered screen update. If\n\t\t\talpha is True, the resulting graphics object should support an\n\t\t\talpha channel; otherwise it does not need to.\n\t\t\"\"\"\n\t\t# According to the Qt documentation, all Qt screen updates are\n\t\t# double-buffered, so this support is normally not really needed. As a\n\t\t# result, we simply return 'self' and ignore the 'copy' method in the\n\t\t# case where (dx,dy) is not specified:\n\t\tif dx is None:\n\t\t\treturn self\n\n\t\t# fixme: Do we need to worry about 'alpha':\n\t\tpixmap   = QPixmap( dx, dy )\n\t\tgraphics = painter_for( pixmap )\n\t\tgraphics.setFont( self.font )\n\n\t\treturn QtGraphics( graphics, _painter = self.graphics,\n\t\t\t\t\t\t\t\t\t bitmap   = pixmap )\n\n\n\tdef blit ( self, dst_x, dst_y, dst_dx, dst_dy, g,\n\t\t\t\t\t src_x = 0, src_y = 0, src_dx = None, src_dy = None ):\n\t\t\"\"\" Performs a standard BLT (block transfer) operation from one graphics\n\t\t\tobject to another, copying g(src_x,src_y,src_dx,syc_dy) to\n\t\t\tself(dst_x,dst_y,dst_dx,dst_dy). If src_dx or src_dy is None, then\n\t\t\tthe corresponding dst_dx or dst_dy value is used to determine the\n\t\t\tsource rectangle size. Note that g may also specify a bitmap, as\n\t\t\treturned by an ImageResource 'bitmap' attribute, in place of a\n\t\t\tgraphics adapter.\n\t\t\"\"\"\n\t\tif src_dx is None:\n\t\t\tsrc_dx = dst_dx\n\n\t\tif src_dy is None:\n\t\t\tsrc_dy = dst_dy\n\n\t\t# Convert an AbstractGraphics Adapter to a QPixmap (if it is not already\n\t\t# one):\n\t\tif isinstance( g, Graphics ):\n\t\t\t# fixme: I think that for all actual use cases, 'g' will be created\n\t\t\t# from a QPixmap, so the 'device' call will work...\n\t\t\tg = g.graphics.device()\n\n\t\tself.graphics.drawPixmap( dst_x, dst_y, dst_dx, dst_dy, g,\n\t\t\t\t\t\t\t\t  src_x, src_y, src_dx, src_dy )\n\n\n\tdef copy ( self, x = 0, y = 0 ):\n\t\t\"\"\" Copies the contents of the graphics buffer back to the graphics\n\t\t\tobject it was created from at the specified (x,y) location.\n\t\t\"\"\"\n\t\tpainter = self._painter\n\t\tif painter is not None:\n\t\t\tpainter.drawPixmap( x, y, self.bitmap )\n\t\t\tcontrol = getattr( painter, '_control', None )\n\t\t\tif control is not None:\n\t\t\t\tcontrol.update()\n", "description": " Draws a rectangle at the specified position and with the specified\n\t\t\twidth and height.\n\t\t", "category": "graphics", "imports": ["\timport Qt, QPoint", "\timport QColor, QPainter, QPen, QBrush, QPixmap, QFontMetrics", "\timport Graphics", "\timport create_facets_font", "\t\tfrom facets.ui.pen import Pen"]}], [{"term": "class", "name": "classParserInformation:", "data": "class ParserInformation:\n\tdef get_graphics(self, data: Dict) -> List[str]:\n\t\tgraphic_allow = Graphics.Graphics_Allow\n\t\tlist_graphics = []\n\t\tif graphics := data.get(\"Graphics\"):\n\t\t\tlist_graphics = [\n\t\t\t\tgraphic for graphic in graphics if graphic in graphic_allow\n\t\t\t]\n\t\treturn list_graphics\n\n\tdef get_non_graphics(self, data: Dict) -> List[str]:\n\t\tnon_graphic_allow = NonGraphics.Non_Graphics_Allow\n\t\tlist_graphics = []\n\t\tif graphics := data.get(\"NonGraphics\"):\n\t\t\tlist_graphics = [\n\t\t\t\tgraphic for graphic in graphics if graphic in non_graphic_allow\n\t\t\t]\n\t\treturn list_graphics\n\n\tdef get_axis(self, data: Dict) -> List[str]:\n\t\tnames = []\n\t\tkeys = AxisGraphics.get_values()\n\t\tfor axis in data.keys():\n\t\t\tif axis in keys:\n\t\t\t\tnames.append(axis)\n\t\treturn names\n", "description": null, "category": "graphics", "imports": ["from typing import Dict, List, Type", "from app.config.configGraphics import AxisGraphics, Graphics, NonGraphics"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\t# main loop\n\twhile True:\n\n\t\t# start and restart page\n\t\tif graphics.get_page() == 0 or graphics.get_page() == 2:\n\t\t\tgraphics.start_page()\n\t\t\twhile True:\n\t\t\t\tpause(FRAME_RATE)\n\t\t\t\tif graphics.get_page() != 0 or graphics.get_page != 2:\n\t\t\t\t\tbreak\n\n\t\t# game page\n\t\telif graphics.get_page() == 1:\n\t\t\tgraphics.game_reset()\n\t\t\tgraphics.draw_bricks()\n\t\t\tball = graphics.get_ball()\n\t\t\twindow = graphics.get_window()\n\t\t\twhile graphics.get_lives() > 0:\n\t\t\t\tpause(FRAME_RATE)\n\t\t\t\tball.move(graphics.get_ball_velocity()[0], graphics.get_ball_velocity()[1])\n\t\t\t\tif 0 > ball.x or ball.x + ball.width > window.width:\n\t\t\t\t\tif ball.x < 0:\n\t\t\t\t\t\tball.x = 0\n\t\t\t\t\telif ball.x + ball.width > window.width:\n\t\t\t\t\t\tball.x = window.width - ball.width\n\t\t\t\t\tgraphics.set_ball_velocity(x=-1)\n\t\t\t\tif 0 > ball.y:\n\t\t\t\t\tball.y = 0\n\t\t\t\t\tgraphics.set_ball_velocity(y=-1)\n\t\t\t\tgraphics.detect_collision()\n\t\t\t\tgraphics.wind()\n\t\t\t\tif ball.y > window.height:\n\t\t\t\t\tgraphics.set_lives()\n\t\t\t\t\tgraphics.game_reset()\n\t\t\t\t\tgraphics.draw_bricks()\n\t\t\t\tif graphics.check_over():\n\t\t\t\t\tbreak\n\t\t\tgraphics.set_page(2)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "import time"]}], [], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tlive = NUM_LIVES\n\tscore = 0\n\tdx = graphics.get_dx()\n\tdy = graphics.get_dy()\n\n\t# Add animation loop here!\n\twhile True:\n\t\tpause(FRAME_RATE)\n\t\tif graphics.user_click:\n\t\t\tgraphics.ball.move(dx, dy)\n\t\tif graphics.is_hitup() or graphics.is_hitpaddle():\n\t\t\tdy = -dy\n\t\tif graphics.is_hitside():\n\t\t\tdx = -dx\n\n\t\t# detect if the ball hit bricks or not\n\t\tif graphics.is_hit_something():\n\t\t\twhat = graphics.hit_something()\n\t\t\tif graphics.is_brick(what):\n\t\t\t\tgraphics.window.remove(what)\n\t\t\t\tscore += 10\n\t\t\t\tgraphics.resetscore(score)\n\t\t\t\tif score == graphics.all:\n\t\t\t\t\tgraphics.win\n\t\t\t\tdy = -dy\n\t\tif graphics.is_hitground():\n\t\t\tlive -= 1\n\t\t\tgraphics.resetlive(live)\n\t\t\tgraphics.window.remove(graphics.ball)\n\t\t\tgraphics.user_click = False\n\t\t\tif graphics.lives == 0:\n\t\t\t\tgraphics.window.clear()\n\t\t\t\tgraphics.lose()\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tgraphics.reset_ball()\n\t\t\t\tif graphics.user_click:\n\t\t\t\t\tgraphics.ball.move(dx, dy)\n\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tcount = NUM_LIVES\n\t# Add the animation loop here!\n\twhile count != 0:\n\t\tif not graphics.get_brick_number() == 0:\n\t\t\tgraphics.detect()\n\t\t\tgraphics.ball.move(graphics.get_vx(),graphics.get_vy())\n\t\t\tif graphics.ball.x <= 0 or graphics.ball.x+graphics.ball.width > graphics.window.width:\n\t\t\t\tgraphics.get_nvx()\n\t\t\tif graphics.ball.y <= 0:\n\t\t\t\tgraphics.get_nvy()\n\t\t\tif graphics.ball.y+graphics.ball.height > graphics.window.height:\n\t\t\t\tgraphics.restart()\n\t\t\t\tcount -= 1\n\t\t\tpause(FRAME_RATE)\n\t\t\t# print(graphics.get_brick_number())\n\t\t\t# print(count)\n\t\telse:\n\t\t\tprint(\"You win\")\n\t\t\tbreak\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tcount = NUM_LIVES\n\t# Add the animation loop here!\n\twhile count != 0:\n\t\tif not graphics.get_brick_number() == 0:\n\t\t\tgraphics.detect()\n\t\t\tgraphics.ball.move(graphics.get_vx(),graphics.get_vy())\n\t\t\tif graphics.ball.x <= 0 or graphics.ball.x+graphics.ball.width > graphics.window.width:\n\t\t\t\tgraphics.get_nvx()\n\t\t\tif graphics.ball.y <= 0:\n\t\t\t\tgraphics.get_nvy()\n\t\t\tif graphics.ball.y+graphics.ball.height > graphics.window.height:\n\t\t\t\tgraphics.restart()\n\t\t\t\tcount -= 1\n\t\t\tpause(FRAME_RATE)\n\t\t\t# print(graphics.get_brick_number())\n\t\t\t# print(count)\n\t\telse:\n\t\t\tprint(\"You win\")\n\t\t\tbreak\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "class", "name": "PaintingEnvironment", "data": "class PaintingEnvironment(object):\n\tbusy = False\n\tdef __init__(self):\n\t\tself.activated = True\n\t\ttool.painting_env = self\n\t\t\n\t\t#init buttons\n\t\tself.save_button = gui.Button(\n\t\t\tresources.Button, self.save, \n\t\t\tgraphics.width-resources.Button.width-3, 5, text='Save'\n\t\t)\n\t\tself.open_button = gui.Button(\n\t\t\tresources.Button, self.open, \n\t\t\tself.save_button.x, resources.Button.height+10, text='Open'\n\t\t)\n\t\t\n\t\tself.buttons = [self.save_button, self.open_button]\n\t\tfor button in self.buttons: graphics.main_window.push_handlers(button)\n\t\t\n\t\t#init tool control space\n\t\tself.toolbar_group = gui.ButtonGroup()\n\t\ttool.controlspace.max_x = graphics.width-200\n\t\ttool.controlspace.max_y = graphics.canvas_y\n\t\tgraphics.main_window.push_handlers(tool.controlspace)\n\t\t\n\t\t#load tools, make toolbar\n\t\tself.toolbar = []\n\t\tself.labels = []\n\t\tself.current_tool = None\n\t\tself.toolsize = resources.SquareButton.width\n\t\tself.load_tools()\n\t\t\n\t\tself.keys = key.KeyStateHandler()\n\t\tgraphics.main_window.push_handlers(self.keys)\n\t\t\n\t\tpyglet.clock.schedule(self.on_draw)\n\t\n\t#------------EVENT HANDLING------------#\t\n\tdef on_draw(self, dt=0):\n\t\tif self.keys[key.LEFT]: level.camera_x -= 10\n\t\tif self.keys[key.RIGHT]: level.camera_x += 10\n\t\tif self.keys[key.UP]: level.camera_y += 10\n\t\tif self.keys[key.DOWN]: level.camera_y -= 10\n\t\t\t\n\t\tdraw.clear()\n\t\tpyglet.gl.glPushMatrix()\n\t\tself.apply_camera()\n\t\tself.draw_level()\n\t\tpyglet.gl.glPopMatrix()\n\t\tself.draw_tools()\n\t\n\tdef apply_camera(self):\n\t\tif self.keys[key.SPACE]:\n\t\t\tpyglet.gl.glScalef(0.3, 0.3, 1)\n\t\t\tpyglet.gl.glTranslatef(graphics.width*1.1, graphics.height*1.1, 0)\n\t\t\n\t\tpyglet.gl.glTranslatef(-level.camera_x+graphics.canvas_x, \n\t\t\t\t\t\t\t\t-level.camera_y+graphics.canvas_y, 0)\n\t\n\tdef draw_level(self):\n\t\tdraw.set_color(1,1,1,1)\n\t\tif level.background_image != None:\n\t\t\ttry:\n\t\t\t\tlevel.background_image.blit_tiled(\n\t\t\t\t\t0, 0, 0, level.width, level.height\n\t\t\t\t)\n\t\t\texcept:\n\t\t\t\tlevel.background_image.blit(0,0)\n\t\t\n\t\tdraw.set_color(1, 0, 1, 0.5)\n\t\tdraw.grid(level.camera_x, level.camera_y,\n\t\t\t\t\tgraphics.width, graphics.height)\n\t\tdraw.set_color(0,0,0,1)\n\t\tdraw.line(0,0,0,level.height)\n\t\tdraw.line(0,level.height,level.width,level.height)\n\t\tdraw.line(level.width,level.height,level.width,0)\n\t\tdraw.line(level.width,0,0,0)\n\t\tlevel.draw_level_objects()\n\t\tdraw.set_color(0,1,0,1)\n\t\tdraw.circle(level.player_x, level.player_y, 80)\n\t\tif graphics.drawing: self.current_tool.keep_drawing_static()\n\t\n\tdef draw_tools(self):\n\t\t#toolbar background\n\t\tdraw.set_color(0.8, 0.8, 0.8, 1)\n\t\tdraw.rect(0,graphics.canvas_y,graphics.canvas_x,graphics.height)\n\t\tdraw.rect(0,0,graphics.width,graphics.canvas_y)\n\t\t\n\t\t#buttons\n\t\tdraw.set_color(1,1,1,1)\n\t\tfor button in self.toolbar: button.draw()   #toolbar buttons\n\t\tfor button in self.buttons: button.draw()   #bottom buttons\n\t\tfor label in self.labels: draw.label(label) #text labelsr\n\t\t\n\t\ttool.controlspace.draw()\n\t\t\n\t\t#divider lines\n\t\tdraw.set_color(0,0,0,1)\n\t\tgraphics.set_line_width(1.0)\n\t\tdraw.line(0, graphics.canvas_y, graphics.width, graphics.canvas_y)\n\t\tdraw.line(\n\t\t\tgraphics.canvas_x, graphics.canvas_y, \n\t\t\tgraphics.canvas_x, graphics.height\n\t\t)\n\t\n\tdef on_key_press(self, symbol, modifiers):\n\t\tif symbol == key.O and modifiers == key.MOD_COMMAND:\n\t\t\tself.open()\n\t\t\treturn True\n\t\tif symbol == key.S and modifiers == key.MOD_COMMAND:\n\t\t\tself.save()\n\t\t\treturn True\n\t\tif not graphics.drawing and \\\n\t\t\t\tself.current_tool.key_press != tool.Tool.key_press:\n\t\t\tgraphics.drawing = True\n\t\t\tself.current_tool.key_press(symbol, modifiers)\n\t\t\tgraphics.drawing = False\n\t\tif symbol == key.ESCAPE: return True\t#stop Pyglet from quitting\n\t\n\tdef on_key_release(self, symbol, modifiers):\n\t\tif not graphics.drawing and \\\n\t\t\t\tself.current_tool.key_release != tool.Tool.key_release:\n\t\t\tgraphics.drawing = True\n\t\t\tself.current_tool.key_release(symbol, modifiers)\n\t\t\tgraphics.drawing = False\n\t\n\tdef on_text(self, text):\n\t\tif not graphics.drawing and self.current_tool.text != tool.Tool.text:\n\t\t\tgraphics.drawing = True\n\t\t\tself.current_tool.text(text)\n\t\t\tgraphics.drawing = False\n\t\n\tdef on_mouse_motion(self, x, y, dx, dy):\n\t\tif not self.activated or self.keys[key.SPACE]: return\n\t\tlastx, lasty = x-dx, y-dy\n\t\tif x > graphics.canvas_x and y > graphics.canvas_y:\n\t\t\tif not (lastx > graphics.canvas_x and lasty > graphics.canvas_y) \\\n\t\t\t\t\tand self.current_tool.cursor != None:\n\t\t\t\tgraphics.main_window.set_mouse_cursor(self.current_tool.cursor)\n\t\telse:\n\t\t\tif (lastx > graphics.canvas_x and lasty > graphics.canvas_y) \\\n\t\t\t\t\tor (lastx > graphics.width) or (lasty > graphics.height):\n\t\t\t\tgraphics.set_cursor(graphics.cursor['CURSOR_DEFAULT'])\n\t\n\tdef on_mouse_press(self, x, y, button, modifiers):\n\t\tif not self.activated or self.keys[key.SPACE]: return\n\t\tif x > graphics.canvas_x and y > graphics.canvas_y:\n\t\t\tgraphics.drawing = True\n\t\t\tself.current_tool.start_drawing(x+level.camera_x-graphics.canvas_x,\n\t\t\t\t\t\t\t\t\t\t\ty+level.camera_y-graphics.canvas_y)\n\t\n\tdef on_mouse_drag(self, x, y, dx, dy, button, modifiers):\n\t\tif not self.activated: return\n\t\tif self.keys[key.SPACE]:\n\t\t\tlevel.camera_x -= dx/0.3\n\t\t\tlevel.camera_y -= dy/0.3\n\t\t\treturn\n\t\tself.on_mouse_motion(x,y,dx,dy)\n\t\tif graphics.drawing:\n\t\t\tself.current_tool.keep_drawing(\n\t\t\t\tx+level.camera_x-graphics.canvas_x,\n\t\t\t\ty+level.camera_y-graphics.canvas_y,dx,dy\n\t\t\t)\n\t\n\tdef on_mouse_release(self, x, y, button, modifiers):\n\t\tif not self.activated or self.keys[key.SPACE]: return\n\t\tif graphics.drawing:\n\t\t\tself.current_tool.stop_drawing(\n\t\t\t\tx+level.camera_x-graphics.canvas_x,\n\t\t\t\ty+level.camera_y-graphics.canvas_y\n\t\t\t)\n\t\t\tgraphics.drawing = False\n\t\n\tdef on_close(self):\n\t\tsettings.save_settings()\n\t\tpyglet.app.exit()\n\t\n\tdef on_activate(self):\n\t\tself.activated = True\n\t\n\tdef on_deactivate(self):\n\t\tself.activated = False\n\t\n\t#------------TOOL THINGS------------#\n\tdef import_libs(self, dir):\n\t\t\"\"\" Imports the libs, returns a dictionary of the libraries.\"\"\"\n\t\tlibrary_dict = {}\n\t\tsys.path.append(dir)\n\t\tfor f in os.listdir(os.path.abspath(dir)):\n\t\t\tmodule_name, ext = os.path.splitext(f)\n\t\t\tif ext == '.py' and module_name != '__init__':\n\t\t\t\tmodule = __import__(module_name)\n\t\t\t\tlibrary_dict[module_name] = module\n\t\t\n\t\treturn library_dict\n\t\n\tdef load_tools(self):\n\t\t#Import everything in the Tools directory, shove them in a dictionary\n\t\ttools = self.import_libs('Editor/Tools')\n\t\t#Sort them by their priority property\n\t\tsorted_tools = sorted(tools.values(), key=lambda tool:tool.priority)\n\t\t\n\t\t#Categorize them by group - remain sorted\n\t\tself.grouped_tools = collections.defaultdict(list)\n\t\tfor tool in sorted_tools:\n\t\t\tself.grouped_tools[tool.group].append(tool)\n\t\t\n\t\t#Create appropriate buttons in appropriate locations\n\t\ty = graphics.height\n\t\tfor group in sorted(self.grouped_tools.keys()):\n\t\t\t#group label\n\t\t\tself.labels.append(pyglet.text.Label(group, x=self.toolsize, y=y-self.toolsize/3-3,\n\t\t\t\t\t\t\t\tfont_size=self.toolsize/4, anchor_x='center',anchor_y='bottom',\n\t\t\t\t\t\t\t\tcolor=(0,0,0,255)))\n\t\t\ty -= self.toolsize/3+3\n\t\t\t\n\t\t\ti = 0\n\t\t\tfor tool in self.grouped_tools[group]:\n\t\t\t\ttool.default.cursor = tool.cursor\n\t\t\t\ti += 1\n\t\t\t\tx = self.toolsize\n\t\t\t\t#two to a row\n\t\t\t\tif i % 2 != 0:\n\t\t\t\t\tx = 0\n\t\t\t\t\ty -= self.toolsize\n\t\t\t\tnew_button = gui.ImageButton(\n\t\t\t\t\tresources.SquareButton, \n\t\t\t\t\tself.get_toolbar_button_action(tool.default), x,y, \n\t\t\t\t\tparent_group = self.toolbar_group,image_2=tool.image\n\t\t\t\t)\n\t\t\t\tself.toolbar.append(new_button)\n\t\t\n\t\tself.current_tool = sorted_tools[0].default\n\t\tself.toolbar[0].selected = True\n\t\tself.toolbar_group.buttons = self.toolbar\n\t\tfor tool in self.toolbar: graphics.main_window.push_handlers(tool)\n\t\n\tdef get_toolbar_button_action(self, specific_tool):\n\t\t#decorator for toolbar buttons\n\t\tdef action():\n\t\t\tif not graphics.drawing:\n\t\t\t\tself.current_tool.unselect()\n\t\t\t\tself.current_tool = specific_tool\n\t\t\t\ttool.controlspace.clear()\n\t\t\t\tself.current_tool.select()\n\t\treturn action\n\t\n\t#------------BUTTON THINGS------------#\n\tdef open(self):\n\t\tpath = gui.open_file(type_list = ['yaml'])\n\t\tif path == None: return\n\t\tlevel.load(path)\n\t\n\tdef save(self):\n\t\tpath = gui.save_file(default_name=\"Level_.yaml\")\n\t\tif path == None: return\n\t\tlevel.save(path)\n\t\n\tdef open_old(self):\n\t\tif self.busy: return\n\t\tgraphics.main_window.set_fullscreen(False)\n\t\tpyglet.clock.schedule_once(self.open_2,0.5)\n\t\tself.busy = True\n\t\n\tdef open_2(self, dt=0):\t\n\t\tself.busy = False\n\t\tpath = gui.open_file(type_list = ['yaml'])\n\t\tgraphics.main_window.set_fullscreen(True)\n\t\tif path == None: return\n\t\tpyglet.clock.schedule_once(self.open_3, 0.5, path)\n\t\tself.busy = True\n\t\n\tdef open_3(self, dt=0, path=None):\n\t\tself.busy = False\n\t\tif path != None:\n\t\t\tlevel.load(path)\n\t\n\tdef save_old(self):\n\t\tif self.busy: return\n\t\tgraphics.main_window.set_fullscreen(False)\n\t\tpyglet.clock.schedule_once(self.save_2,0.5)\n\t\tself.busy = True\n\t\n\tdef save_2(self, dt=0):\n\t\tself.busy = False\n\t\tpath = gui.save_file(default_name=\"Level_.yaml\")\n\t\tgraphics.main_window.set_fullscreen(True)\n\t\tif path == None: return\n\t\tlevel.save(path)\n\t\tpyglet.clock.schedule_once(self.save_3, 0.5)\n\t\tself.busy = True\n\t\n\tdef save_3(self, dt=0):\n\t\tself.busy = False\n\t\n", "description": " Imports the libs, returns a dictionary of the libraries.", "category": "graphics", "imports": ["import pyglet", "import gui", "import random, time", "import resources, graphics, draw, tool, level", "import sys, os, time", "from pyglet.window import key", "import settings", "import collections", "\tdef import_libs(self, dir):", "\t\t\t\tmodule = __import__(module_name)", "\t\ttools = self.import_libs('Editor/Tools')"]}], [{"term": "class", "name": "Ship", "data": "class Ship(object):\n\t\"\"\"Base class for all types of ships\"\"\"\n\n\tdef __init__(self, name, numeric_id, gen, subtype, hull, **kwargs):\n\t\tself.id = self.base_id + \"_gen_\" + str(gen) + subtype\n\t\tself._name = name  # private var because 'name' is accessed via @property method to add subtype string\n\t\tself.numeric_id = numeric_id\n\t\tnumeric_id_defender.append(numeric_id)\n\t\t# roster is set when the vehicle is registered to a roster, only one roster per vehicle\n\t\tself.roster_id = \"default\"  # only one roster currently\n\t\tself.roster.register_ship(self)\n\t\t# subtypes determine capacity, and are mapped to hull sizes in subclass\n\t\tself.subtype = subtype\n\t\t# base hull (defines length, wake graphics, hull graphics if composited etc)\n\t\tself.hull = registered_hulls[hull + self.hull_mapping[self.subtype]]\n\t\t# generation used to set default intro dates, speed etc unless explicitly set by a vehicle\n\t\tself.gen = gen\n\t\t# if gen is used, the calculated intro date can be adjusted with +ve or -ve offset\n\t\tself.intro_date_offset = kwargs.get(\"intro_date_offset\", None)\n\t\t# create a structure for cargo /livery graphics options\n\t\tself.gestalt_graphics = GestaltGraphics()\n\t\t# option for multiple default cargos, cascading if first cargo(s) are not available\n\t\tself.default_cargos = []\n\t\t# speed is determined in sub class, or can be over-ridden by individual vehicles\n\t\t# optional per-vehicle speed\n\t\tself._speed = kwargs.get(\"speed\", None)\n\t\t# default to freight speed_class for convenience, over-ride in subclasses as needed\n\t\tself.speed_class = \"freight\"  # over-ride this for, e.g. fast_freight consists\n\t\t# default standard capacities_by_subtype for freight for convenience, over-ride in subclasses as needed\n\t\tself.capacities_by_subtype = {\n\t\t\t\"A\": 80,\n\t\t\t\"B\": 160,\n\t\t\t\"C\": 240,\n\t\t\t\"D\": 360,\n\t\t\t\"E\": 540,\n\t\t\t\"F\": 810,\n\t\t}  # over-ride this for, e.g. pax ship capacities_by_subtype\n\t\t# extra type info, better over-ride in subclass\n\t\tself.str_type_info = \"EMPTY\"  # unused currently\n\t\t# nml-ish props, mostly optional\n\t\tself.sound_effect = kwargs.get(\"sound_effect\", \"SOUND_SHIP_HORN\")\n\t\tself.vehicle_life = kwargs.get(\n\t\t\t\"vehicle_life\", 100\n\t\t)  # default 100 years, assumes 2 generations of ships 1850-2050\n\t\tself._buy_cost = kwargs.get(\"buy_cost\", None)\n\t\t# !! temp - these need move to subtypes at some point (or as over-rides)\n\t\tself.fixed_run_cost_factor = 3.5\n\t\tself.fuel_run_cost_factor = 1.0\n\t\t# over-ride loading speed in subclasses as needed (suggested values are 0.5 for slower loading and 2 for faster loading)\n\t\tself.loading_speed_multiplier = 1\n\t\tself.cargo_age_period = kwargs.get(\n\t\t\t\"cargo_age_period\", global_constants.CARGO_AGE_PERIOD\n\t\t)\n\t\t# by default ships have multiple capacity options, refittable in depot\n\t\tself.capacity_is_refittable_by_cargo_subtype = kwargs.get(\n\t\t\t\"capacity_is_refittable_by_cargo_subtype\", True\n\t\t)\n\t\t# most ships use steam effect_spawn_model so set default, over-ride in ships as needed\n\t\tself.effect_spawn_model = kwargs.get(\n\t\t\t\"effect_spawn_model\", \"EFFECT_SPAWN_MODEL_STEAM\"\n\t\t)\n\t\tself.effect_type = kwargs.get(\"effect_type\", None)\n\t\t# what length to use for cargo sprites in cargo compositing\n\t\tself.cargo_length = kwargs.get(\"cargo_length\", None)\n\t\t# aids 'project management'\n\t\tself.sprites_complete = kwargs.get(\"sprites_complete\", False)\n\n\t@property\n\tdef num_unique_spritesheet_suffixes(self):\n\t\tprint(\"remove num_unique_spritesheet_suffixes\")\n\t\treturn 1\n\n\t@property\n\tdef hull_mapping(self):\n\t\t# default mapping of subtypes to hull lengths; over-ride in subclasses as needed\n\t\treturn {\n\t\t\t\"A\": \"44px\",\n\t\t\t\"B\": \"64px\",\n\t\t\t\"C\": \"80px\",\n\t\t\t\"D\": \"96px\",\n\t\t\t\"E\": \"112px\",\n\t\t\t\"F\": \"128px\",\n\t\t}\n\n\t@property\n\tdef hull_spritesheet_name(self):\n\t\t# generally don't access hull.spritesheet_base_name directly, it needs the gen inserted\n\t\treturn self.hull.spritesheet_base_name + \"_gen_\" + str(self.gen)\n\n\t@property\n\tdef speed(self):\n\t\t# automatic speed, but can over-ride by passing in kwargs for consist\n\t\tif self._speed:\n\t\t\treturn self._speed\n\t\telif self.speed_class:\n\t\t\tspeeds = self.roster.speeds[self.speed_class]\n\t\t\treturn speeds[max([year for year in speeds if self.intro_date >= year])]\n\t\telse:\n\t\t\t# assume no speed limit\n\t\t\treturn None\n\n\tdef get_speed_adjusted_for_param(self, speed_index):\n\t\t# there is a speed adjustment parameter, use that to look up a speed factor\n\t\tspeed_factors = [0.67, 1, 50]\n\t\t# allow that integer maths is needed for newgrf cb results; rounding up for safety, capped at max ship speed\n\t\tresult = int(\n\t\t\tmin(math.ceil(3.2 * self.speed * speed_factors[speed_index]), 79 * 3.2)\n\t\t)\n\t\treturn result\n\n\t@property\n\tdef adjusted_model_life(self):\n\t\treturn \"VEHICLE_NEVER_EXPIRES\"\n\n\t@property\n\tdef running_cost(self):\n\t\t# calculate a running cost\n\t\tgross_tonnage = (\n\t\t\tself.default_capacity * 1.25\n\t\t)  # no real need to vary this by ship type\n\t\tfixed_run_cost = self.fixed_run_cost_factor * global_constants.FIXED_RUN_COST\n\t\tfuel_run_cost = (\n\t\t\tself.fuel_run_cost_factor * gross_tonnage * global_constants.FUEL_RUN_COST\n\t\t)\n\t\tcalculated_run_cost = int(\n\t\t\t(fixed_run_cost + fuel_run_cost) / 98\n\t\t)  # divide by magic constant to get costs as factor in 0-255 range\n\t\treturn min(calculated_run_cost, 255)  # cost factor is a byte, can't exceed 255\n\n\t@property\n\tdef intro_date(self):\n\t\t# automatic intro_date, but can over-ride by passing in kwargs for consist\n\t\tassert self.gen != None, (\n\t\t\t\"%s consist has no gen set, which is incorrect\" % self.id\n\t\t)\n\t\tresult = self.roster.intro_dates[\"DEFAULT\"][self.gen - 1]\n\t\tif self.intro_date_offset is not None:\n\t\t\tresult = result + self.intro_date_offset\n\t\treturn result\n\n\t@property\n\tdef refittable_capacity_factors(self):\n\t\t# default refittable capacities_by_subtype are [base capacity, 25% underload, 25% overload]\n\t\t# over-ride this in the subclass if necessary\n\t\treturn [1, 0.75, 1.25]\n\n\t@property\n\tdef capacities_refittable(self):\n\t\t# ships can refit multiple capacities_by_subtype\n\t\t# faff: mail ships need to divide default capacity for freight; freight ships multiply default capacity for mail\n\t\t# this is theoretically extensible to other cargos/classes, but will get ugly fast eh?\n\t\tif self.default_cargos[0] == \"MAIL\":\n\t\t\tdefault_base = self.default_capacity / global_constants.mail_multiplier\n\t\t\tmail_base = self.default_capacity\n\t\telse:\n\t\t\tdefault_base = self.default_capacity\n\t\t\tmail_base = self.default_capacity * global_constants.mail_multiplier\n\n\t\tcapacities_default = [\n\t\t\tint(default_base * capacity_factor)\n\t\t\tfor capacity_factor in self.refittable_capacity_factors\n\t\t]\n\t\tcapacities_mail = [\n\t\t\tint(mail_base * capacity_factor)\n\t\t\tfor capacity_factor in self.refittable_capacity_factors\n\t\t]\n\t\tresult = {\"default\": capacities_default, \"mail\": capacities_mail}\n\t\treturn result\n\n\t@property\n\tdef default_capacity(self):\n\t\treturn self.capacities_by_subtype[self.subtype]\n\n\t@property\n\tdef refittable_classes(self):\n\t\tcargo_classes = []\n\t\t# maps lists of allowed classes.  No equivalent for disallowed classes, that's overly restrictive and damages the viability of class-based refitting\n\t\tfor i in self.class_refit_groups:\n\t\t\t[\n\t\t\t\tcargo_classes.append(cargo_class)\n\t\t\t\tfor cargo_class in global_constants.base_refits_by_class[i]\n\t\t\t]\n\t\treturn \",\".join(set(cargo_classes))  # use set() here to dedupe\n\n\tdef get_label_refits_allowed(self):\n\t\t# allowed labels, for fine-grained control in addition to classes\n\t\treturn \",\".join(self.label_refits_allowed)\n\n\tdef get_label_refits_disallowed(self):\n\t\t# disallowed labels, for fine-grained control, knocking out cargos that are allowed by classes, but don't fit for gameplay reasons\n\t\treturn \",\".join(self.label_refits_disallowed)\n\n\t@property\n\tdef loading_speed(self):\n\t\t# loading speed is *not* normalised per capacity for ships, unlike vehicles in Road Hog / Iron Horse\n\t\t# 10 is default OTTD value for ships, seems fine to me\n\t\treturn 10 * self.loading_speed_multiplier\n\n\t@property\n\tdef buy_cost(self):\n\t\tif self._buy_cost is not None:\n\t\t\treturn self._buy_cost\n\t\t# !! this is an initial attempt to put buy cost in the correct bracket, but this is not finished !!\n\t\t# !! likely this should account for pax / mail / freight etc, this would be better done by sticking a multiplier on the subclass\n\t\treturn self.default_capacity / 10\n\n\t@property\n\tdef name_suffix_as_string_name(self):\n\t\t# used in ship name string only\n\t\t# may be over-ridden in subclasses\n\t\treturn \"STR_NAME_\" + self.base_id.upper()\n\n\tdef get_str_type_info(self):\n\t\t# makes a string id for nml\n\t\treturn \"STR_\" + self.str_type_info\n\n\t@property\n\tdef name(self):\n\t\treturn (\n\t\t\t\"string(STR_NAME_\"\n\t\t\t+ self.id\n\t\t\t+ \", string(\"\n\t\t\t+ self.name_suffix_as_string_name\n\t\t\t+ \"))\"\n\t\t)\n\n\tdef get_buy_menu_string(self):\n\t\tbuy_menu_template = Template(\n\t\t\t\"string(STR_BUY_MENU_TEXT, string(${str_type_info}), string(STR_EMPTY))\"\n\t\t)\n\t\treturn buy_menu_template.substitute(str_type_info=self.get_str_type_info())\n\n\t@property\n\tdef roster(self):\n\t\tfor roster in registered_rosters:\n\t\t\tif self.roster_id == roster.id:\n\t\t\t\treturn roster\n\n\tdef get_expression_for_rosters(self):\n\t\t# the working definition is one and only one roster per vehicle\n\t\treturn \"param[2]==\" + str(self.roster.numeric_id - 1)\n\n\tdef get_nml_expression_for_default_cargos(self):\n\t\t# sometimes first default cargo is not available, so we use a list\n\t\t# this avoids unwanted cases like piece cargo ships defaulting to mail when goods cargo not available\n\t\t# if there is only one default cargo, the list just has one entry, that's no problem\n\t\tif len(self.default_cargos) == 1:\n\t\t\treturn self.default_cargos[0]\n\t\telse:\n\t\t\t# build stacked ternary operators for cargos\n\t\t\tresult = self.default_cargos[-1]\n\t\t\tfor cargo in reversed(self.default_cargos[0:-1]):\n\t\t\t\tresult = 'cargotype_available(\"' + cargo + '\")?' + cargo + \":\" + result\n\t\t\treturn result\n\n\tdef get_spriterow_counts(self):\n\t\t# !! overly nested as assumes that there would be multiple units, doesn't apply to ships\n\t\tresult = []\n\t\tunit_rows = []\n\t\t# assumes gestalt_graphics is used to handle any other rows, no other cases at time of writing, could be changed eh?\n\t\tunit_rows.extend(self.gestalt_graphics.get_output_row_counts_by_type())\n\t\tresult.append(unit_rows)\n\t\treturn result\n\n\t@property\n\tdef buy_menu_width(self):\n\t\t# currently contains no provision for custom widths\n\t\t# but if needed, add _buy_menu_width from constructor kwargs, and check existence of that here\n\t\t# standard sizes are multiples of 32, except first size, where 32 is just too small to make a nice sprite\n\t\treturn int(self.hull.hull_length.split(\"px\")[0])\n\n\t@property\n\tdef buy_menu_bb_y_offset(self):\n\t\t# !! scaffolding for variable height ships that need offsets on their bounding box for buy menu\n\t\t# !! returns a fixed value currently, more wasn't needed yet :P Possibly delete?\n\t\treturn 16\n\n\t@property\n\tdef offsets(self):\n\t\t# currently contains no provision for custom offsets\n\t\t# but if needed, add _offsets prop from constructor kwargs, and check existence of that here (otherwise returning defaults)\n\t\treturn global_constants.vehicle_offsets[self.hull.hull_length]\n\n\tdef get_nml_expression_for_cargo_variant_random_switch(self, cargo_id=None):\n\t\tswitch_id = (\n\t\t\tself.id\n\t\t\t+ \"_switch_graphics\"\n\t\t\t+ (\"_\" + str(cargo_id) if cargo_id is not None else \"\")\n\t\t)\n\t\treturn \"SELF,\" + switch_id + \", bitmask(TRIGGER_VEHICLE_ANY_LOAD)\"\n\n\tdef get_expression_for_effects(self):\n\t\t# provides part of nml switch for effects (smoke), or none if no effects defined\n\t\tif self.effect_type is not None:\n\t\t\tresult = []\n\t\t\tfor index, effect_position in enumerate(self.hull.effects_positions):\n\t\t\t\tformatted_position = \",\".join(str(i) for i in effect_position)\n\t\t\t\tresult.append(\n\t\t\t\t\t\"STORE_TEMP(create_effect(\"\n\t\t\t\t\t+ self.effect_type\n\t\t\t\t\t+ \",\"\n\t\t\t\t\t+ formatted_position\n\t\t\t\t\t+ \"), 0x10\"\n\t\t\t\t\t+ str(index)\n\t\t\t\t\t+ \")\"\n\t\t\t\t)\n\t\t\treturn \"[\" + \",\".join(result) + \"]\"\n\t\telse:\n\t\t\treturn 0\n\n\tdef assert_cargo_labels(self, cargo_labels):\n\t\tfor i in cargo_labels:\n\t\t\tif i not in global_constants.cargo_labels:\n\t\t\t\tutils.echo_message(\n\t\t\t\t\t\"Warning: ship \"\n\t\t\t\t\t+ self.id\n\t\t\t\t\t+ \" references cargo label \"\n\t\t\t\t\t+ i\n\t\t\t\t\t+ \" which is not defined in the cargo table\"\n\t\t\t\t)\n\n\tdef render(self):\n\t\t# integrity tests\n\t\tself.assert_cargo_labels(self.label_refits_allowed)\n\t\tself.assert_cargo_labels(self.label_refits_disallowed)\n\t\t# templating\n\t\ttemplate = templates[self.gestalt_graphics.nml_template]\n\t\tnml_result = template(ship=self, global_constants=global_constants)\n\t\treturn nml_result\n\n", "description": "Base class for all types of ships", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "BulkBase", "data": "class BulkBase(Ship):\n\t\"\"\"\n\tLimited set of bulk (mineral) cargos.  Equivalent of Road Hog dump hauler and Iron Horse dump car.\n\tTend to be just a single unfitted box hold, distinguishing them from general cargo vessels which have divided holds, tween-decks etc,.\n\tMini-bulkers may be self-discharging (crane or conveyor).  Bulk barges less likely to be.\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tsuper().__init__(**kwargs)\n\t\tself.class_refit_groups = [\"dump_freight\"]\n\t\tself.label_refits_allowed = []  # no specific labels needed\n\t\tself.label_refits_disallowed = global_constants.disallowed_refits_by_label[\n\t\t\t\"non_dump_bulk\"\n\t\t]\n\t\tself.default_cargos = global_constants.default_cargos[\"dump\"]\n\t\tself.loading_speed_multiplier = 2\n\t\t# Graphics configuration\n\t\thouse_recolour_map = (\n\t\t\tgraphics_constants.house_recolour_roof_CC1_1.copy()\n\t\t)  # copy because update is used to extend the map\n\t\tself.gestalt_graphics = GestaltGraphicsVisibleCargo(\n\t\t\tbulk=True,\n\t\t\thull_recolour_map=graphics_constants.hull_recolour_CC1,\n\t\t\thouse_recolour_map=house_recolour_map,\n\t\t)\n\n\t@property\n\tdef name_suffix_as_string_name(self):\n\t\t# used in ship name string only\n\t\t# may be over-ridden in subclasses\n\t\tif self.gen < 3:\n\t\t\treturn \"STR_NAME_COLLIER\"\n\t\telse:\n\t\t\treturn \"STR_NAME_MINI_BULKER\"\n\n", "description": "\n\tLimited set of bulk (mineral) cargos.  Equivalent of Road Hog dump hauler and Iron Horse dump car.\n\tTend to be just a single unfitted box hold, distinguishing them from general cargo vessels which have divided holds, tween-decks etc,.\n\tMini-bulkers may be self-discharging (crane or conveyor).  Bulk barges less likely to be.\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "BulkBarge", "data": "class BulkBarge(BulkBase):\n\t\"\"\"\n\tSparse subclass to set base ID\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"bulk_barge\"\n\t\tsuper().__init__(**kwargs)\n\n", "description": "\n\tSparse subclass to set base ID\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "BulkShip", "data": "class BulkShip(BulkBase):\n\t\"\"\"\n\tSparse subclass to set base ID\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"bulk_ship\"\n\t\tsuper().__init__(**kwargs)\n\n", "description": "\n\tSparse subclass to set base ID\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "CargoLiner", "data": "class CargoLiner(Ship):\n\t\"\"\"\n\tPiece goods cargos, other selected cargos.  Equivalent of Road Hog box hauler and Iron Horse box car / van.\n\tIRL: \"GCV\", \"Break-bulk\", \"Pallet carrier\", also cargo packet (but not mail packet)\n\tNot \"box ship\" because IRL they are container carriers (yair).\n\tThe name is ultimately just a generic solution to 'this is not quite a general freighter', that doesn't describe the specific shape or cargo type or RL trade name.\n\tMany name variants were tried, Cargo Liner seemed to stick.\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"cargo_liner\"\n\t\tsuper().__init__(**kwargs)\n\t\tself.class_refit_groups = [\"packaged_freight\"]\n\t\tself.label_refits_allowed = [\n\t\t\t\"MAIL\",\n\t\t\t\"GRAI\",\n\t\t\t\"WHEA\",\n\t\t\t\"MAIZ\",\n\t\t\t\"FRUT\",\n\t\t\t\"BEAN\",\n\t\t\t\"NITR\",\n\t\t]  # Iron Horse compatibility\n\t\tself.label_refits_disallowed = global_constants.disallowed_refits_by_label[\n\t\t\t\"non_freight_special_cases\"\n\t\t]\n\t\tself.default_cargos = global_constants.default_cargos[\"box\"]\n\t\t# Graphics configuration\n\t\tself.gestalt_graphics = GestaltGraphicsSimpleColourRemaps(\n\t\t\thull_recolour_map=graphics_constants.hull_recolour_CC1\n\t\t)\n\n", "description": "\n\tPiece goods cargos, other selected cargos.  Equivalent of Road Hog box hauler and Iron Horse box car / van.\n\tIRL: \"GCV\", \"Break-bulk\", \"Pallet carrier\", also cargo packet (but not mail packet)\n\tNot \"box ship\" because IRL they are container carriers (yair).\n\tThe name is ultimately just a generic solution to 'this is not quite a general freighter', that doesn't describe the specific shape or cargo type or RL trade name.\n\tMany name variants were tried, Cargo Liner seemed to stick.\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "ContainerCarrier", "data": "class ContainerCarrier(Ship):\n\t\"\"\"\n\tRefits to limited range of freight cargos, shows container graphics according to load state.\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"bulk_carrier\"\n\t\tsuper().__init__(**kwargs)\n\t\tself.template = \"container_carrier.pynml\"\n\t\t# maintain other sets (e.g. IH etc) when changing container refits\n\t\tself.class_refit_groups = [\"express_freight\", \"packaged_freight\"]\n\t\tself.label_refits_allowed = [\"FRUT\", \"WATR\"]\n\t\tself.label_refits_disallowed = [\"FISH\", \"LVST\", \"OIL_\", \"TOUR\", \"WOOD\"]\n\t\tself.default_cargos = global_constants.default_cargos[\"intermodal\"]\n\n", "description": "\n\tRefits to limited range of freight cargos, shows container graphics according to load state.\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "CoveredHopperCarrier", "data": "class CoveredHopperCarrier(Ship):\n\t\"\"\"\n\tBulk cargos needing covered protection.\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"bulk_carrier\"\n\t\tsuper().__init__(**kwargs)\n\t\tself.class_refit_groups = []  # no classes, use explicit labels\n\t\tself.label_refits_allowed = global_constants.allowed_refits_by_label[\n\t\t\t\"covered_hoppers\"\n\t\t]\n\t\tself.label_refits_disallowed = []\n\t\tself.default_cargos = global_constants.default_cargos[\"covered_mineral\"]\n\t\tself.loading_speed_multiplier = 2\n\t\t# Graphics configuration\n\t\tself.gestalt_graphics = GestaltGraphicsSimpleColourRemaps(\n\t\t\thull_recolour_map=graphics_constants.hull_recolour_CC1\n\t\t)\n\n", "description": "\n\tBulk cargos needing covered protection.\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "CryoTanker", "data": "class CryoTanker(Ship):\n\t\"\"\"\n\tSpecialist tankers for gases under pressure, e.g. Oxygen, Chlorine etc.\n\tIRL these are pressurised, semi-pressurised, fully refrigerated etc.  We wavey hands that distinction here.\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"cryo_tanker\"\n\t\tsuper().__init__(**kwargs)\n\t\tself.class_refit_groups = []  # no classes, use explicit labels\n\t\tself.label_refits_allowed = global_constants.allowed_refits_by_label[\n\t\t\t\"cryo_gases\"\n\t\t]\n\t\tself.label_refits_disallowed = []\n\t\tself.default_cargos = global_constants.default_cargos[\"cryo_gases\"]\n\t\tself.loading_speed_multiplier = 2\n\t\t# Graphics configuration\n\t\tself.gestalt_graphics = GestaltGraphicsSimpleColourRemaps(\n\t\t\thull_recolour_map=graphics_constants.hull_recolour_CC1\n\t\t)\n\n", "description": "\n\tSpecialist tankers for gases under pressure, e.g. Oxygen, Chlorine etc.\n\tIRL these are pressurised, semi-pressurised, fully refrigerated etc.  We wavey hands that distinction here.\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "EdiblesTanker", "data": "class EdiblesTanker(Ship):\n\t\"\"\"\n\tGallons and gallons and gallons of wine, milk or water.  Except in metric systems, where it's litres.\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"edibles_tanker\"\n\t\tsuper().__init__(**kwargs)\n\t\tself.class_refit_groups = []  # no classes, use explicit labels\n\t\tself.label_refits_allowed = global_constants.allowed_refits_by_label[\n\t\t\t\"edible_liquids\"\n\t\t]\n\t\tself.label_refits_disallowed = []\n\t\tself.default_cargos = global_constants.default_cargos[\"edibles_tank\"]\n\t\t# Graphics configuration\n\t\thull_recolour_map = graphics_constants.hull_recolour_white\n\t\tdeck_recolour_map = {\n\t\t\t70: 1,\n\t\t\t60: 2,\n\t\t\t72: 3,\n\t\t\t123: 4,\n\t\t\t74: 5,\n\t\t\t75: 6,\n\t\t}\n\t\thouse_recolour_map = (\n\t\t\tgraphics_constants.house_recolour_roof_CC1_1.copy()\n\t\t)  # copy because update is used to extend the map\n\t\thouse_recolour_map.update(graphics_constants.house_recolour_CC2_to_CC1)\n\t\tself.gestalt_graphics = GestaltGraphicsSimpleColourRemaps(\n\t\t\thull_recolour_map=hull_recolour_map,\n\t\t\tdeck_recolour_map=deck_recolour_map,\n\t\t\thouse_recolour_map=house_recolour_map,\n\t\t)\n\n", "description": "\n\tGallons and gallons and gallons of wine, milk or water.  Except in metric systems, where it's litres.\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "FlatDeckBarge", "data": "class FlatDeckBarge(Ship):\n\t\"\"\"\n\tFlat deck, no holds - refits most cargos, not bulk.\n\t!! Not used?? - this was added as equivalent of Horse flat cars, but that mode doesn't apply to shipping.\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"flat_deck\"\n\t\tsuper().__init__(**kwargs)\n\t\tself.class_refit_groups = [\"flatbed_freight\"]\n\t\tself.label_refits_allowed = [\"GOOD\"]\n\t\tself.label_refits_disallowed = global_constants.disallowed_refits_by_label[\n\t\t\t\"non_freight_special_cases\"\n\t\t]\n\t\tself.default_cargos = global_constants.default_cargos[\"flat\"]\n\t\t# Graphics configuration\n\t\tself.gestalt_graphics = GestaltGraphicsVisibleCargo(piece=\"flat\")\n\n\t# class FruitVegCarrier(Ship):\n\t\"\"\"\n\tFruit and vegetables, with improved decay rate\n\t!! deprecated - this was added as equivalent of Horse fruit & veg cars, but that mode doesn't apply to shipping - use reefer / dry cargo instead.\n\t\"\"\"\n\n", "description": "\n\tFlat deck, no holds - refits most cargos, not bulk.\n\t!! Not used?? - this was added as equivalent of Horse flat cars, but that mode doesn't apply to shipping.\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "FreighterBase", "data": "class FreighterBase(Ship):\n\t\"\"\"\n\tGeneral purpose freight vessel type.\n\tNo pax or mail cargos, refits any other cargo including liquids (in barrels or containers).\n\tTend to be fitted with divided holds, tween-decks etc, distinguishing them from mini-bulkers which are just a single unfitted box hold.\n\tIRL: \"multi-purpose vessel\" (modern designation), or \"general cargo vessel\" or \"dry cargo vessel\".  Confusing much?\n\tShip version is probably geared (cranes), barge version is probably not.\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tsuper().__init__(**kwargs)\n\t\tself.class_refit_groups = [\"all_freight\"]\n\t\tself.label_refits_allowed = []  # no specific labels needed, refits all freight\n\t\tself.label_refits_disallowed = global_constants.disallowed_refits_by_label[\n\t\t\t\"non_freight_special_cases\"\n\t\t]\n\t\tself.default_cargos = global_constants.default_cargos[\"open\"]\n\t\t# Graphics configuration\n\t\t# might need to split house stuff down to individual ships / barges?\n\t\tif self.subtype in [\"A\", \"C\", \"E\"]:\n\t\t\thouse_recolour_map = graphics_constants.house_recolour_roof_dark_red_1\n\t\telif self.subtype in [\"B\", \"D\", \"F\"]:\n\t\t\thouse_recolour_map = graphics_constants.house_recolour_roof_silver_1\n\t\telse:\n\t\t\thouse_recolour_map = None\n\t\tself.gestalt_graphics = GestaltGraphicsVisibleCargo(\n\t\t\tbulk=True, piece=\"open\", house_recolour_map=house_recolour_map\n\t\t)\n\n", "description": "\n\tGeneral purpose freight vessel type.\n\tNo pax or mail cargos, refits any other cargo including liquids (in barrels or containers).\n\tTend to be fitted with divided holds, tween-decks etc, distinguishing them from mini-bulkers which are just a single unfitted box hold.\n\tIRL: \"multi-purpose vessel\" (modern designation), or \"general cargo vessel\" or \"dry cargo vessel\".  Confusing much?\n\tShip version is probably geared (cranes), barge version is probably not.\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "FreighterBarge", "data": "class FreighterBarge(FreighterBase):\n\t\"\"\"\n\tSparse subclass, to set base ID\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"freighter_barge\"\n\t\tsuper().__init__(**kwargs)\n\n", "description": "\n\tSparse subclass, to set base ID\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "FreighterShip", "data": "class FreighterShip(FreighterBase):\n\t\"\"\"\n\tSparse subclass, to set base ID\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"freighter_ship\"\n\t\tsuper().__init__(**kwargs)\n\n", "description": "\n\tSparse subclass, to set base ID\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "LivestockCarrier", "data": "class LivestockCarrier(Ship):\n\t\"\"\"\n\tSpecial type for livestock (as you might guess).\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"livestock_carrier\"\n\t\tsuper().__init__(**kwargs)\n\t\tself.class_refit_groups = [\"empty\"]\n\t\tself.label_refits_allowed = [\n\t\t\t\"LVST\"\n\t\t]  # set to livestock by default, don't need to make it refit\n\t\tself.label_refits_disallowed = []\n\t\tself.default_cargos = [\"LVST\"]  # no need for fallbacks, single refit\n\t\t# improved decay rate\n\t\tself.cargo_age_period = 2 * global_constants.CARGO_AGE_PERIOD\n\t\t# Graphics configuration\n\t\tself.gestalt_graphics = GestaltGraphicsSimpleColourRemaps(\n\t\t\thull_recolour_map=graphics_constants.hull_recolour_CC2\n\t\t)\n\n", "description": "\n\tSpecial type for livestock (as you might guess).\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "LogTug", "data": "class LogTug(Ship):\n\t\"\"\"\n\tSpecialist type for hauling logs only, has some specialist refit and speed behaviours.\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"log_tug\"\n\t\tsuper().__init__(**kwargs)\n\t\tself.template = \"log_tug.pynml\"\n\t\tself.class_refit_groups = [\"empty\"]\n\t\tself.label_refits_allowed = [\"WOOD\"]\n\t\tself.label_refits_disallowed = []\n\t\tself.default_cargos = [\"WOOD\"]  # no need for fallbacks, single refit\n\n", "description": "\n\tSpecialist type for hauling logs only, has some specialist refit and speed behaviours.\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "MailShip", "data": "class MailShip(Ship):\n\t\"\"\"\n\tA relatively fast vessel type for mail and express freight.\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"mail_ship\"\n\t\tsuper().__init__(**kwargs)\n\t\tself.speed_class = \"pax_mail\"\n\t\tself.class_refit_groups = [\"mail\", \"express_freight\"]\n\t\tself.label_refits_allowed = []\n\t\tself.label_refits_disallowed = [\"TOUR\"]\n\t\tself.default_cargos = global_constants.default_cargos[\"mail\"]\n\t\t# these are the mail capacities_by_subtype for ships that have MAIL as default; freight capacity will be divided by global_constants.mail_multipler\n\t\tself.capacities_by_subtype = {\n\t\t\t\"A\": 40,\n\t\t\t\"B\": 120,\n\t\t\t\"D\": 360,\n\t\t}  # no large mail ships, by design\n\t\t# Graphics configuration\n\t\tself.gestalt_graphics = GestaltGraphicsSimpleColourRemaps(\n\t\t\thull_recolour_map=graphics_constants.hull_recolour_CC1\n\t\t)\n\n", "description": "\n\tA relatively fast vessel type for mail and express freight.\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "PaxShipBase", "data": "class PaxShipBase(Ship):\n\t\"\"\"\n\tCommon base class for passenger vessels.\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tsuper().__init__(**kwargs)\n\t\tself.class_refit_groups = [\"pax\"]\n\t\tself.label_refits_allowed = []\n\t\tself.label_refits_disallowed = []\n\t\tself.default_cargos = global_constants.default_cargos[\"pax\"]\n\t\tself.capacities_by_subtype = {\"A\": 40, \"B\": 125, \"C\": 300, \"D\": 720}\n\t\tself.sound_effect = \"SOUND_FERRY_HORN\"\n\n", "description": "\n\tCommon base class for passenger vessels.\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "PaxFastLoadingShip", "data": "class PaxFastLoadingShip(PaxShipBase):\n\t\"\"\"\n\tFast-loading passenger vessel - better suited to short routes; keep same speed as luxury pax ship for balancing reasons.\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"pax_fast_loading\"\n\t\tsuper().__init__(**kwargs)\n\t\tself.speed_class = \"pax_mail\"\n\t\tself.loading_speed_multiplier = 3\n\t\t# Graphics configuration\n\t\tself.gestalt_graphics = GestaltGraphicsSimpleColourRemaps(\n\t\t\thull_recolour_map=graphics_constants.hull_recolour_CC1\n\t\t)\n\n\t@property\n\tdef hull_mapping(self):\n\t\t# default mapping of subtypes to hull lengths; over-ride in subclasses as needed\n\t\t# !! WIP the actual mappings here are somewhat undecided\n\t\treturn {\"A\": \"44px\", \"B\": \"44px\", \"C\": \"64px\", \"D\": \"96px\"}\n\n", "description": "\n\tFast-loading passenger vessel - better suited to short routes; keep same speed as luxury pax ship for balancing reasons.\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "PaxLuxuryShip", "data": "class PaxLuxuryShip(PaxShipBase):\n\t\"\"\"\n\tLuxury passenger vessel - better suited to long routes; keep same speed as fast-loading pax ship for balancing reasons.\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"pax_luxury\"\n\t\tsuper().__init__(**kwargs)\n\t\tself.speed_class = \"pax_mail\"\n\t\tself.cargo_age_period = 3 * global_constants.CARGO_AGE_PERIOD\n\t\t# Graphics configuration\n\t\tself.gestalt_graphics = GestaltGraphicsSimpleColourRemaps(\n\t\t\thull_recolour_map=graphics_constants.hull_recolour_CC2\n\t\t)\n\n\t@property\n\tdef hull_mapping(self):\n\t\t# default mapping of subtypes to hull lengths; over-ride in subclasses as needed\n\t\t# !! WIP the actual mappings here are somewhat undecided\n\t\treturn {\"A\": \"44px\", \"B\": \"64px\", \"C\": \"96px\", \"D\": \"128px\"}\n\n", "description": "\n\tLuxury passenger vessel - better suited to long routes; keep same speed as fast-loading pax ship for balancing reasons.\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "Reefer", "data": "class Reefer(Ship):\n\t\"\"\"\n\tRefits to limited range of refrigerated cargos, with 'improved' cargo decay rate.\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"reefer\"\n\t\tsuper().__init__(**kwargs)\n\t\tself.class_refit_groups = [\"refrigerated_freight\"]\n\t\tself.label_refits_allowed = (\n\t\t\t[]\n\t\t)  # no specific labels needed, refits all cargos that have refrigerated class\n\t\tself.label_refits_disallowed = []\n\t\tself.default_cargos = global_constants.default_cargos[\"reefer\"]\n\t\t# improved decay rate\n\t\tself.cargo_age_period = 2 * global_constants.CARGO_AGE_PERIOD\n\t\t# Graphics configuration\n\t\thull_recolour_map = graphics_constants.hull_recolour_white\n\t\tdeck_recolour_map = {\n\t\t\t70: 1,\n\t\t\t60: 2,\n\t\t\t72: 3,\n\t\t\t123: 4,\n\t\t\t74: 5,\n\t\t\t75: 6,\n\t\t}\n\t\tself.gestalt_graphics = GestaltGraphicsSimpleColourRemaps(\n\t\t\thull_recolour_map=hull_recolour_map, deck_recolour_map=deck_recolour_map\n\t\t)\n\n", "description": "\n\tRefits to limited range of refrigerated cargos, with 'improved' cargo decay rate.\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "TankerBase", "data": "class TankerBase(Ship):\n\t\"\"\"\n\tRonseal (\"does what it says on the tin\", for those without extensive knowledge of UK advertising).\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tsuper().__init__(**kwargs)\n\t\tself.template = \"vehicle_with_visible_cargo.pynml\"\n\t\tself.class_refit_groups = [\"liquids\"]\n\t\tself.label_refits_allowed = (\n\t\t\t[]\n\t\t)  # refits most cargos that have liquid class even if they might be edibles\n\t\tself.label_refits_disallowed = global_constants.disallowed_refits_by_label[\n\t\t\t\"non_generic_liquids\"\n\t\t]\n\t\tself.default_cargos = global_constants.default_cargos[\"tank\"]\n\t\t# Graphics configuration\n\t\tdeck_recolour_map = {\n\t\t\t70: 40,\n\t\t\t60: 41,\n\t\t\t72: 42,\n\t\t\t123: 43,\n\t\t\t74: 44,\n\t\t\t75: 45,\n\t\t}\n\t\tif self.subtype in [\"A\", \"C\", \"E\"]:\n\t\t\thouse_recolour_map = (\n\t\t\t\tgraphics_constants.house_recolour_roof_dark_red_1.copy()\n\t\t\t)  # copy because update is used to extend the map\n\t\t\thouse_recolour_map.update(graphics_constants.house_recolour_CC2_to_CC1)\n\t\telif self.subtype in [\"B\", \"D\", \"F\"]:\n\t\t\thouse_recolour_map = graphics_constants.house_recolour_roof_silver_1\n\t\telse:\n\t\t\thouse_recolour_map = None\n\t\tself.gestalt_graphics = GestaltGraphicsSimpleColourRemaps(\n\t\t\tcargo_recolour_maps=polar_fox.constants.tanker_livery_recolour_maps,\n\t\t\tdeck_recolour_map=deck_recolour_map,\n\t\t\thouse_recolour_map=house_recolour_map,\n\t\t)\n\n", "description": "\n\tRonseal (\"does what it says on the tin\", for those without extensive knowledge of UK advertising).\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "TankerBarge", "data": "class TankerBarge(TankerBase):\n\t\"\"\"\n\tSparse subclass to set base ID\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"tanker_barge\"\n\t\tsuper().__init__(**kwargs)\n\n", "description": "\n\tSparse subclass to set base ID\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "TankerShip", "data": "class TankerShip(TankerBase):\n\t\"\"\"\n\tSparse subclass to set base ID\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"tanker_ship\"\n\t\tsuper().__init__(**kwargs)\n\n", "description": "\n\tSparse subclass to set base ID\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "Trawler", "data": "class Trawler(Ship):\n\t\"\"\"\n\tDedicated to fishing\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"trawler\"\n\t\tsuper().__init__(**kwargs)\n\t\tself.class_refit_groups = []\n\t\tself.label_refits_allowed = []\n\t\tself.label_refits_disallowed = []\n\t\tself.default_cargos = [\"FISH\"]  # no need for fallbacks, single refit\n\t\t# Graphics configuration\n\t\thull_recolour_map = {\n\t\t\t136: 146,\n\t\t\t137: 147,\n\t\t\t138: 148,\n\t\t\t139: 149,\n\t\t\t140: 150,\n\t\t\t141: 151,\n\t\t\t142: 152,\n\t\t\t143: 153,\n\t\t}\n\t\tself.gestalt_graphics = GestaltGraphicsSimpleColourRemaps(\n\t\t\thull_recolour_map=hull_recolour_map\n\t\t)\n\n", "description": "\n\tDedicated to fishing\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}, {"term": "class", "name": "UtilityHovercraft", "data": "class UtilityHovercraft(Ship):\n\t\"\"\"\n\tHovercraft for express freight\n\t\"\"\"\n\n\tdef __init__(self, **kwargs):\n\t\tself.base_id = \"utility_hovercraft\"\n\t\tsuper().__init__(**kwargs)\n\t\tself.class_refit_groups = [\"mail\", \"express_freight\"]\n\t\tself.label_refits_allowed = []\n\t\tself.label_refits_disallowed = [\"TOUR\"]\n\t\tself.default_cargos = global_constants.default_cargos[\"mail\"]\n\t\t# these are the mail capacities_by_subtype for ships that have MAIL as default; freight capacity will be divided by global_constants.mail_multipler\n\t\tself.capacities_by_subtype = {\n\t\t\t\"A\": 40,\n\t\t\t\"B\": 120,\n\t\t\t\"D\": 360,\n\t\t}  # no large mail ships, by design\n\t\tself._speed = 50\n\t\t# Graphics configuration\n\t\tself.gestalt_graphics = GestaltGraphicsSimpleColourRemaps(\n\t\t\thull_recolour_map=graphics_constants.hull_recolour_CC1\n\t\t)\n", "description": "\n\tHovercraft for express freight\n\t", "category": "graphics", "imports": ["import os.path", "import sys", "import math", "from string import (", "from chameleon import PageTemplateLoader  # chameleon used in most template cases", "import polar_fox", "import global_constants  # expose all constants for easy passing to templates", "import utils", "from gestalt_graphics.gestalt_graphics import (", "import gestalt_graphics.graphics_constants as graphics_constants", "from hulls import registered_hulls", "from rosters import registered_rosters", "from vehicles import numeric_id_defender"]}], [{"term": "def", "name": "color_for", "data": "def color_for ( color ):\n\t\"\"\" Returns the specified color as a QColor.\n\t\"\"\"\n\tif isinstance( color, tuple ):\n\t\tif isinstance( color[0], float ):\n\t\t\tcolor = [ int( 255.0 * c ) for c in color ]\n\n\t\treturn QColor( *color )\n\n\tif isinstance( color, int ):\n\t\treturn QColor(\n\t\t\t(color >> 16) & 0xFF, (color >> 8) & 0xFF, color & 0xFF\n\t\t)\n\n\treturn color\n\n", "description": " Returns the specified color as a QColor.\n\t", "category": "graphics", "imports": ["\timport Qt, QPoint, QPointF", "\timport QColor, QPainter, QPen, QBrush, QPixmap, QFontMetrics, QPolygonF", "\timport Graphics", "\timport create_facets_font", "\t\tfrom facets.ui.pen import Pen"]}, {"term": "def", "name": "painter_for", "data": "def painter_for ( context ):\n\t\"\"\" Returns a QPainter for the specified *context* object.\n\t\"\"\"\n\tgraphics = QPainter( context )\n\tgraphics.setRenderHint( QPainter.TextAntialiasing )\n\n\treturn graphics\n\n", "description": " Returns a QPainter for the specified *context* object.\n\t", "category": "graphics", "imports": ["\timport Qt, QPoint, QPointF", "\timport QColor, QPainter, QPen, QBrush, QPixmap, QFontMetrics, QPolygonF", "\timport Graphics", "\timport create_facets_font", "\t\tfrom facets.ui.pen import Pen"]}, {"term": "def", "name": "points_for", "data": "def points_for ( points ):\n\t\"\"\" Returns a list of QPointF objects derived from *points*, which can\n\t\teither be a list of Point objects or a Polygon object.\n\t\"\"\"\n\t# Process a list of Point objects:\n\tif isinstance( points, list ):\n\t\treturn QPolygonF( [ point_for( point ) for point in points ] )\n\n\t# Process a Polygon object:\n\tif points._cached is None:\n\t\tpoints._cached = QPolygonF(\n\t\t\t[ point_for( point ) for point in points.points ]\n\t\t)\n\n\treturn points._cached\n\n", "description": " Returns a list of QPointF objects derived from *points*, which can\n\t\teither be a list of Point objects or a Polygon object.\n\t", "category": "graphics", "imports": ["\timport Qt, QPoint, QPointF", "\timport QColor, QPainter, QPen, QBrush, QPixmap, QFontMetrics, QPolygonF", "\timport Graphics", "\timport create_facets_font", "\t\tfrom facets.ui.pen import Pen"]}, {"term": "def", "name": "point_for", "data": "def point_for ( point ):\n\t\"\"\" Returns the QPoint object corresponding to the Point object specified by\n\t\t*point*.\n\t\"\"\"\n\tif point._cached is None:\n\t\tpoint._cached = QPointF( *point.xy )\n\n\treturn point._cached\n", "description": " Returns the QPoint object corresponding to the Point object specified by\n\t\t*point*.\n\t", "category": "graphics", "imports": ["\timport Qt, QPoint, QPointF", "\timport QColor, QPainter, QPen, QBrush, QPixmap, QFontMetrics, QPolygonF", "\timport Graphics", "\timport create_facets_font", "\t\tfrom facets.ui.pen import Pen"]}, {"term": "class", "name": "QtGraphics", "data": "class QtGraphics ( Graphics ):\n\n\t#-- Property Implementations -----------------------------------------------\n\n\tdef _get_pen ( self ):\n\t\treturn self.graphics.pen()\n\n\tdef _set_pen ( self, pen ):\n\t\tfrom facets.ui.pen import Pen\n\n\t\tself._no_pen = (pen is None)\n\t\tif self._no_pen:\n\t\t\tpen = Qt.NoPen\n\t\telif isinstance( pen, Pen ):\n\t\t\tqpen = QPen( pen.color )\n\t\t\tqpen.setStyle( LineStyles[ pen.style ] )\n\t\t\tqpen.setWidth( pen.width )\n\t\t\tpen = qpen\n\t\telif not isinstance( pen, QPen ):\n\t\t\tpen = color_for( pen )\n\n\t\tself.graphics.setPen( pen )\n\n\n\tdef _get_brush ( self ):\n\t\treturn self.graphics.brush()\n\n\tdef _set_brush ( self, color ):\n\t\tif color is None:\n\t\t\tself.graphics.setBrush( Qt.NoBrush )\n\t\telse:\n\t\t\tself.graphics.setBrush( QBrush( color_for( color ) ) )\n\n\n\tdef _set_xor_mode ( self, is_xor_mode ):\n\t\tif is_xor_mode:\n\t\t\tself.graphics.setCompositionMode( QPainter.CompositionMode_Xor )\n\n\n\tdef _set_anti_alias ( self, anti_alias ):\n\t\tself.graphics.setRenderHint( QPainter.Antialiasing, anti_alias )\n\n\n\tdef _get_font ( self ):\n\t\tif self._font is not None:\n\t\t\treturn self._font\n\n\t\treturn self.graphics.font()\n\n\tdef _set_font ( self, font ):\n\t\tif isinstance( font, int ):\n\t\t\tfont = str( font )\n\n\t\tif isinstance( font, basestring ):\n\t\t\tfont = create_facets_font( font )\n\n\t\tascent = getattr( font, '_ascent', None )\n\t\tif ascent is None:\n\t\t\tfont._ascent = ascent = QFontMetrics( font ).ascent()\n\n\t\tself._ascent = ascent\n\t\tself._font   = font\n\t\tif not self._temp_graphics:\n\t\t\tself.graphics.setFont( font )\n\n\n\tdef _get_text_color ( self ):\n\t\treturn self.graphics.pen().color()\n\n\tdef _set_text_color ( self, color ):\n\t\tself._set_pen( color )\n\n\n\tdef _get_text_background_color ( self ):\n\t\tif self.graphics.backgroundMode() == Qt.TransparentMode:\n\t\t\treturn None\n\n\t\treturn self.graphics.background().color()\n\n\tdef _set_text_background_color ( self, color ):\n\t\tif color is None:\n\t\t\tself.graphics.setBackgroundMode( Qt.TransparentMode )\n\n\t\t\treturn\n\n\t\tself.graphics.setBackground( QBrush( color_for( color ) ) )\n\t\tself.graphics.setBackgroundMode( Qt.OpaqueMode )\n\n\n\tdef _get_opacity ( self ):\n\t\treturn self.graphics.opacity()\n\n\tdef _set_opacity ( self, opacity ):\n\t\tself.graphics.setOpacity( opacity )\n\n\n\tdef _get_clipping_bounds ( self ):\n\t\trect = self.graphics.clipRegion().boundingRect()\n\n\t\treturn ( rect.x(), rect.y(), rect.width(), rect.height() )\n\n\tdef _set_clipping_bounds ( self, x_y_dx_dy ):\n\t\tif x_y_dx_dy is None:\n\t\t\tself.graphics.setClipping( False )\n\t\telse:\n\t\t\tself.graphics.setClipping( True )\n\t\t\tself.graphics.setClipRect( *x_y_dx_dy )\n\n\n\tdef _get_size ( self ):\n\t\t# fixme: I'm not sure if this is the right call to make...\n\t\trect = self.graphics.viewport()\n\n\t\treturn ( rect.width(), rect.height() )\n\n\t#-- Method Definitions -----------------------------------------------------\n\n\tdef draw_rectangle ( self, x, y, dx, dy ):\n\t\t\"\"\" Draws a rectangle at the specified position and with the specified\n\t\t\twidth and height.\n\t\t\"\"\"\n\t\tif self._no_pen:\n\t\t\tself.graphics.drawRect( x, y, dx, dy )\n\t\telse:\n\t\t\tself.graphics.drawRect( x, y, dx - 1, dy - 1 )\n\n\n\tdef draw_rounded_rectangle ( self, x, y, dx, dy, radius ):\n\t\t\"\"\" Draws a rectangle with rounded corners at the specified position\n\t\t\tand with the specified size and corner radius.\n\t\t\"\"\"\n\t\tself.graphics.drawRoundedRect( x, y, dx, dy,\n\t\t\t\t\t\t\t\t\t   float( radius ), float( radius ) )\n\n\n\tdef draw_circle ( self, x, y, radius ):\n\t\t\"\"\" Draws a circle with the specified center point (x,y) and radius.\n\t\t\"\"\"\n\t\tself.graphics.drawEllipse( QPoint( x, y ), radius, radius )\n\n\n\tdef draw_line ( self, x1, y1, x2, y2 ):\n\t\t\"\"\" Draws a line from (x1,y1) to (x2,y2).\n\t\t\"\"\"\n\t\tself.graphics.drawLine( x1, y1, x2, y2 )\n\n\n\tdef draw_polygon ( self, points ):\n\t\t\"\"\" Draws the closed polygon specified by *points*. *points* can either\n\t\t\tbe a list of Point objects or a Polygon object.\n\t\t\"\"\"\n\t\tself.graphics.drawPolygon( points_for( points ) )\n\n\n\tdef draw_polyline ( self, points ):\n\t\t\"\"\" Draws the polyline specified by *points*. *points* can either\n\t\t\tbe a list of Point objects or a Polygon object.\n\t\t\"\"\"\n\t\tself.graphics.drawPolyline( points_for( points ) )\n\n\n\tdef draw_bitmap ( self, bitmap, x, y ):\n\t\t\"\"\" Draws a specified bitmap at the specified location.\n\t\t\"\"\"\n\t\tself.graphics.drawPixmap( x, y, bitmap )\n\n\n\tdef bitmap_size ( self, bitmap ):\n\t\t\"\"\" Returns the size (dx,dy) of the specified toolkit specific bitmap:\n\t\t\"\"\"\n\t\treturn ( bitmap.width(), bitmap.height() )\n\n\n\tdef draw_text ( self, text, x, y ):\n\t\t\"\"\" Draws the specified text string at the specified (x,y) location.\n\t\t\"\"\"\n\t\tself.graphics.drawText( x, y + (self._ascent or 12), text )\n\n\n\tdef text_size ( self, text ):\n\t\t\"\"\" Returns the size (dx,dy) of the specified text using the current\n\t\t\tfont.\n\t\t\"\"\"\n\t\trect = QFontMetrics( self.font ).boundingRect( text )\n\n\t\treturn ( rect.width(), rect.height() )\n\n\n\tdef graphics_bitmap ( self, bitmap ):\n\t\t\"\"\" Returns a new graphics memory object using the specified bitmap.\n\t\t\"\"\"\n\t\treturn QtGraphics( painter_for( bitmap ) )\n\n\n\tdef graphics_buffer ( self, dx = None, dy = None, alpha = False ):\n\t\t\"\"\" Returns a new graphics memory object of the specified size (dx,dy)\n\t\t\tthat can be used to implement a buffered screen update. If\n\t\t\talpha is True, the resulting graphics object should support an\n\t\t\talpha channel; otherwise it does not need to.\n\t\t\"\"\"\n\t\t# According to the Qt documentation, all Qt screen updates are\n\t\t# double-buffered, so this support is normally not really needed. As a\n\t\t# result, we simply return 'self' and ignore the 'copy' method in the\n\t\t# case where (dx,dy) is not specified:\n\t\tif dx is None:\n\t\t\treturn self\n\n\t\t# fixme: Do we need to worry about 'alpha':\n\t\tpixmap   = QPixmap( dx, dy )\n\t\tgraphics = painter_for( pixmap )\n\t\tgraphics.setFont( self.font )\n\n\t\treturn QtGraphics( graphics, _painter = self.graphics,\n\t\t\t\t\t\t\t\t\t bitmap   = pixmap )\n\n\n\tdef blit ( self, dst_x, dst_y, dst_dx, dst_dy, g,\n\t\t\t\t\t src_x = 0, src_y = 0, src_dx = None, src_dy = None ):\n\t\t\"\"\" Performs a standard BLT (block transfer) operation from one graphics\n\t\t\tobject to another, copying g(src_x,src_y,src_dx,syc_dy) to\n\t\t\tself(dst_x,dst_y,dst_dx,dst_dy). If src_dx or src_dy is None, then\n\t\t\tthe corresponding dst_dx or dst_dy value is used to determine the\n\t\t\tsource rectangle size. Note that g may also specify a bitmap, as\n\t\t\treturned by an ImageResource 'bitmap' attribute, in place of a\n\t\t\tgraphics adapter.\n\t\t\"\"\"\n\t\tif src_dx is None:\n\t\t\tsrc_dx = dst_dx\n\n\t\tif src_dy is None:\n\t\t\tsrc_dy = dst_dy\n\n\t\t# Convert an AbstractGraphics Adapter to a QPixmap (if it is not already\n\t\t# one):\n\t\tif isinstance( g, Graphics ):\n\t\t\t# fixme: I think that for all actual use cases, 'g' will be created\n\t\t\t# from a QPixmap, so the 'device' call will work...\n\t\t\tg = g.graphics.device()\n\n\t\tself.graphics.drawPixmap( dst_x, dst_y, dst_dx, dst_dy, g,\n\t\t\t\t\t\t\t\t  src_x, src_y, src_dx, src_dy )\n\n\n\tdef copy ( self, x = 0, y = 0 ):\n\t\t\"\"\" Copies the contents of the graphics buffer back to the graphics\n\t\t\tobject it was created from at the specified (x,y) location.\n\t\t\"\"\"\n\t\tpainter = self._painter\n\t\tif painter is not None:\n\t\t\tpainter.drawPixmap( x, y, self.bitmap )\n\t\t\tcontrol = getattr( painter, '_control', None )\n\t\t\tif control is not None:\n\t\t\t\tcontrol.update()\n", "description": " Draws a rectangle at the specified position and with the specified\n\t\t\twidth and height.\n\t\t", "category": "graphics", "imports": ["\timport Qt, QPoint, QPointF", "\timport QColor, QPainter, QPen, QBrush, QPixmap, QFontMetrics, QPolygonF", "\timport Graphics", "\timport create_facets_font", "\t\tfrom facets.ui.pen import Pen"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tvx = graphics.get_remaining_x()\n\tvy = graphics.get_remaining_y()\n\t# Add animation loop here!\n\tlife = NUM_LIVES\n\tgraphics.life_label.text = \"Life: \" + str(life)\n\tbomb_label = GLabel(\"Bomb: \"+str(graphics.bomb))\n\tbomb_label.font = '-20'\n\tgraphics.window.add(bomb_label, graphics.window.width-bomb_label.width, bomb_label.height)\n\tgraphics.life_label.text = \"Life: \" + str(life)\n\twhile True:\n\t\tif life > 0:\n\t\t\tif graphics.begin:\n\t\t\t\tgraphics.ball.move(vx, vy)\n\t\t\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\t\t\t\tvx = - vx\n\t\t\t\tif graphics.ball.y <= 0:\n\t\t\t\t\tvy = - vy\n\t\t\t\tif graphics.ball.y + graphics.ball.height < graphics.paddle.y:\n\t\t\t\t\t# Remove the bricks.\n\t\t\t\t\t\"\"\"\n\t\t\t\t\tballx = int(graphics.ball.x)\n\t\t\t\t\tbally = int(graphics.ball.y)\n\t\t\t\t\tfor x in range (ballx,ballx+2*BALL_RADIUS+1,2*BALL_RADIUS):\n\t\t\t\t\t\tfor y in range(bally, bally + 2 * BALL_RADIUS + 1, 2 * BALL_RADIUS):\n\t\t\t\t\t\t\tgraphics.window.get_object_at(x,y)\n\t\t\t\t\t\t\tvy = - vy\n\t\t\t\t\t\t\tgraphics.score += 1\n\t\t\t\t\t\t\tgraphics.score_speed += 1\n\t\t\t\t\t\t\tgraphics.score_label.text = 'Score: ' + str(graphics.score)\n\t\t\t\t\t\"\"\"\n\t\t\t\t\tif graphics.ball.y > graphics.life_label.y and graphics.window.get_object_at(graphics.ball.x, graphics.ball.y) is not None:\n\t\t\t\t\t\tgraphics.window.remove(graphics.window.get_object_at(graphics.ball.x, graphics.ball.y))\n\t\t\t\t\t\tvy = - vy\n\t\t\t\t\t\tgraphics.score += 1\n\t\t\t\t\t\tgraphics.score_speed += 1\n\t\t\t\t\t\tgraphics.score_label.text = 'Score: ' + str(graphics.score)\n\t\t\t\t\tif graphics.ball.y > graphics.life_label.y and graphics.window.get_object_at(graphics.ball.x+graphics.ball.width, graphics.ball.y) is not None:\n\t\t\t\t\t\tgraphics.window.remove(graphics.window.get_object_at(graphics.ball.x+graphics.ball.width, graphics.ball.y))\n\t\t\t\t\t\tvy = - vy\n\t\t\t\t\t\tgraphics.score += 1\n\t\t\t\t\t\tgraphics.score_speed += 1\n\t\t\t\t\t\tgraphics.score_label.text = 'Score: ' + str(graphics.score)\n\t\t\t\t\tif graphics.ball.y > graphics.life_label.y and graphics.window.get_object_at(graphics.ball.x, graphics.ball.y+graphics.ball.height) is not None:\n\t\t\t\t\t\tgraphics.window.remove(graphics.window.get_object_at(graphics.ball.x, graphics.ball.y+graphics.ball.height))\n\t\t\t\t\t\tvy = - vy\n\t\t\t\t\t\tgraphics.score += 1\n\t\t\t\t\t\tgraphics.score_speed += 1\n\t\t\t\t\t\tgraphics.score_label.text = 'Score: ' + str(graphics.score)\n\t\t\t\t\tif graphics.ball.y > graphics.life_label.y and graphics.window.get_object_at(graphics.ball.x+graphics.ball.width, graphics.ball.y+graphics.ball.height) is not None:\n\t\t\t\t\t\tgraphics.window.remove(graphics.window.get_object_at(graphics.ball.x+graphics.ball.width, graphics.ball.y+graphics.ball.height))\n\t\t\t\t\t\tvy = - vy\n\t\t\t\t\t\tgraphics.score += 1\n\t\t\t\t\t\tgraphics.score_speed += 1\n\t\t\t\t\t\tgraphics.score_label.text = 'Score: ' + str(graphics.score)\n\t\t\t\t# To bounce back after hitting the paddle.\n\t\t\t\telif graphics.ball.y + graphics.ball.height <= graphics.paddle.y + graphics.paddle.height and graphics.window.get_object_at(graphics.ball.x, graphics.ball.y+graphics.ball.height) is not None:\n\t\t\t\t\tvy = - vy\n\t\t\t\telif graphics.ball.y + graphics.ball.height <= graphics.paddle.y + graphics.paddle.height and graphics.window.get_object_at(graphics.ball.x+graphics.ball.width, graphics.ball.y+graphics.ball.height) is not None:\n\t\t\t\t\tvy = - vy\n\t\t\t\t# The ball under the paddle.\n\t\t\t\telif graphics.ball.y + graphics.ball.height >= graphics.window.height:\n\t\t\t\t\tgraphics.window.remove(graphics.ball)\n\t\t\t\t\tgraphics.window.add(graphics.ball, x=(graphics.window.width - graphics.ball.width) / 2, y=(graphics.window.height - graphics.ball.height * 2) / 2)\n\t\t\t\t\tlife -= 1\n\t\t\t\t\tgraphics.on_off = True\n\t\t\t\t\tgraphics.begin = False\n\t\t\t\t\tgraphics.life_label.text = \"Life: \" + str(life)\n\t\t\tpause(FRAME_RATE)\n\t\t\tif graphics.score_speed >= 5:\n\t\t\t\tvx *= 1.2\n\t\t\t\tgraphics.score_speed = 0\n\t\t\tbomb_label.text = \"Bomb: \"+str(graphics.bomb)\n\t\telse:\n\t\t\tgraphics.window.clear()\n\t\t\tgame_over = GLabel('Game Over !')\n\t\t\tgame_over1 = GLabel('Game Over !')\n\t\t\tgame_over2 = GLabel('Game Over !')\n\t\t\tgame_over3 = GLabel('Game Over !')\n\t\t\tgame_over4 = GLabel('Game Over !')\n\t\t\tgame_over5 = GLabel('You are loser !')\n\t\t\tgame_over6 = GLabel('You are loser !')\n\t\t\tgame_over7 = GLabel('You are loser !')\n\t\t\tgame_over8 = GLabel('You are loser !')\n\t\t\tgame_over9 = GLabel('You are loser !')\n\t\t\tgame_over10 = GLabel('You are loser !')\n\t\t\tgame_over11 = GLabel('You are loser !')\n\t\t\tfont = 10\n\t\t\tfor i in range(1, 100):\n\t\t\t\tfont += 5\n\t\t\t\tgraphics.window.remove(game_over)\n\t\t\t\tgame_over.font = str(-font)\n\t\t\t\tgraphics.window.add(game_over, x=(graphics.window.width-game_over.width)/2, y=graphics.window.height/2)\n\t\t\t\tpause(5)\n\t\t\t\tgame_over1.font = str(-font)\n\t\t\t\tgraphics.window.add(game_over1, x=(graphics.window.width - game_over.width) / 2,\n\t\t\t\t\t\t\t\t\ty=graphics.window.height / 2)\n\t\t\t\tpause(10)\n\t\t\t\tgame_over2.font = str(-font)\n\t\t\t\tgraphics.window.add(game_over2, x=(graphics.window.width - game_over.width) / 2,\n\t\t\t\t\t\t\t\t\ty=graphics.window.height / 2)\n\t\t\t\tpause(15)\n\t\t\t\tgame_over3.font = str(-font)\n\t\t\t\tgraphics.window.add(game_over3, x=(graphics.window.width - game_over.width) / 2,\n\t\t\t\t\t\t\t\t\ty=graphics.window.height / 2)\n\t\t\t\tpause(20)\n\t\t\t\tgame_over4.font = str(-font)\n\t\t\t\tgraphics.window.add(game_over4, x=(graphics.window.width - game_over.width) / 2,\n\t\t\t\t\t\t\t\t\ty=graphics.window.height / 2)\n\t\t\t\tpause(25)\n\n\t\t\t\tgame_over9.font = str(-font)\n\t\t\t\tgame_over9.color = 'tomato'\n\t\t\t\tgraphics.window.add(game_over9, x=(graphics.window.width - game_over.width) / 2,\n\t\t\t\t\t\t\t\t\ty=graphics.window.height / 5)\n\t\t\t\tpause(5)\n\t\t\t\tgame_over5.font = str(-font)\n\t\t\t\tgame_over5.color = 'tomato'\n\t\t\t\tgraphics.window.add(game_over5, x=((graphics.window.width - game_over.width)*3) / 4,\n\t\t\t\t\t\t\t\t\ty=(graphics.window.height*3) / 9)\n\t\t\t\tpause(10)\n\t\t\t\tgame_over6.font = str(-font)\n\t\t\t\tgame_over6.color = 'tomato'\n\t\t\t\tgraphics.window.add(game_over6, x=(graphics.window.width - game_over.width) / 4,\n\t\t\t\t\t\t\t\t\ty=(graphics.window.height*3) / 5)\n\t\t\t\tpause(15)\n\t\t\t\tgame_over7.font = str(-font)\n\t\t\t\tgame_over7.color = 'tomato'\n\t\t\t\tgraphics.window.add(game_over7, x=((graphics.window.width - game_over.width)*3) / 15,\n\t\t\t\t\t\t\t\t\ty=graphics.window.height / 4)\n\t\t\t\tpause(20)\n\t\t\t\tgame_over8.font = str(-font)\n\t\t\t\tgame_over8.color = 'tomato'\n\t\t\t\tgraphics.window.add(game_over8, x=(graphics.window.width - game_over.width) / 2,\n\t\t\t\t\t\t\t\t\ty=graphics.window.height*3 / 4)\n\t\t\t\tpause(25)\n\t\t\t\tgame_over10.font = str(-font)\n\t\t\t\tgame_over10.color = 'tomato'\n\t\t\t\tgraphics.window.add(game_over10, x=(graphics.window.width - game_over.width)*3 / 4,\n\t\t\t\t\t\t\t\t\ty=graphics.window.height * 4 / 5)\n\t\t\t\tpause(25)\n\t\t\t\tgame_over11.font = str(-font)\n\t\t\t\tgame_over11.color = 'tomato'\n\t\t\t\tgraphics.window.add(game_over11, x=(graphics.window.width - game_over.width) * 2.5 / 4,\n\t\t\t\t\t\t\t\t\ty=graphics.window.height * 4.8 / 5)\n\t\t\t\tpause(25)\n\t\t\tbreak\n\n", "description": "\n\t\t\t\t\tballx = int(graphics.ball.x)\n\t\t\t\t\tbally = int(graphics.ball.y)\n\t\t\t\t\tfor x in range (ballx,ballx+2*BALL_RADIUS+1,2*BALL_RADIUS):\n\t\t\t\t\t\tfor y in range(bally, bally + 2 * BALL_RADIUS + 1, 2 * BALL_RADIUS):\n\t\t\t\t\t\t\tgraphics.window.get_object_at(x,y)\n\t\t\t\t\t\t\tvy = - vy\n\t\t\t\t\t\t\tgraphics.score += 1\n\t\t\t\t\t\t\tgraphics.score_speed += 1\n\t\t\t\t\t\t\tgraphics.score_label.text = 'Score: ' + str(graphics.score)\n\t\t\t\t\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.graphics.gobjects import GLabel"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tvx = graphics.get_remaining_x()\n\tvy = graphics.get_remaining_y()\n\t# Add animation loop here!\n\tlife = NUM_LIVES\n\tgraphics.bomb = 0\n\tgraphics.life_label.text = \"Life: \" + str(life)\n\twhile True:\n\t\tif life > 0:\n\t\t\tif graphics.begin:\n\t\t\t\tgraphics.ball.move(vx, vy)\n\t\t\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\t\t\t\tvx = - vx\n\t\t\t\tif graphics.ball.y <= 0:\n\t\t\t\t\tvy = - vy\n\t\t\t\tif graphics.ball.y + graphics.ball.height < graphics.paddle.y:\n\t\t\t\t\t# Remove the bricks.\n\t\t\t\t\tif graphics.window.get_object_at(graphics.ball.x, graphics.ball.y) is not None:\n\t\t\t\t\t\tgraphics.window.remove(graphics.window.get_object_at(graphics.ball.x, graphics.ball.y))\n\t\t\t\t\t\tvy = - vy\n\t\t\t\t\t\tgraphics.score += 1\n\t\t\t\t\t\tgraphics.score_speed += 1\n\t\t\t\t\t\tgraphics.score_label.text = 'Score: ' + str(graphics.score)\n\t\t\t\t\tif graphics.window.get_object_at(graphics.ball.x+graphics.ball.width, graphics.ball.y) is not None:\n\t\t\t\t\t\tgraphics.window.remove(graphics.window.get_object_at(graphics.ball.x+graphics.ball.width, graphics.ball.y))\n\t\t\t\t\t\tvy = - vy\n\t\t\t\t\t\tgraphics.score += 1\n\t\t\t\t\t\tgraphics.score_speed += 1\n\t\t\t\t\t\tgraphics.score_label.text = 'Score: ' + str(graphics.score)\n\t\t\t\t\tif graphics.window.get_object_at(graphics.ball.x, graphics.ball.y+graphics.ball.height) is not None:\n\t\t\t\t\t\tgraphics.window.remove(graphics.window.get_object_at(graphics.ball.x, graphics.ball.y+graphics.ball.height))\n\t\t\t\t\t\tvy = - vy\n\t\t\t\t\t\tgraphics.score += 1\n\t\t\t\t\t\tgraphics.score_speed += 1\n\t\t\t\t\t\tgraphics.score_label.text = 'Score: ' + str(graphics.score)\n\t\t\t\t\tif graphics.window.get_object_at(graphics.ball.x+graphics.ball.width, graphics.ball.y+graphics.ball.height) is not None:\n\t\t\t\t\t\tgraphics.window.remove(graphics.window.get_object_at(graphics.ball.x+graphics.ball.width, graphics.ball.y+graphics.ball.height))\n\t\t\t\t\t\tvy = - vy\n\t\t\t\t\t\tgraphics.score += 1\n\t\t\t\t\t\tgraphics.score_speed += 1\n\t\t\t\t\t\tgraphics.score_label.text = 'Score: ' + str(graphics.score)\n\t\t\t\t# To bounce back after hitting the paddle.\n\t\t\t\telif graphics.ball.y + graphics.ball.height <= graphics.paddle.y + graphics.paddle.height and graphics.window.get_object_at(graphics.ball.x, graphics.ball.y+graphics.ball.height) is not None:\n\t\t\t\t\tvy = - vy\n\t\t\t\telif graphics.ball.y + graphics.ball.height <= graphics.paddle.y + graphics.paddle.height and graphics.window.get_object_at(graphics.ball.x+graphics.ball.width, graphics.ball.y+graphics.ball.height) is not None:\n\t\t\t\t\tvy = - vy\n\t\t\t\t# The ball under the paddle.\n\t\t\t\telif graphics.ball.y + graphics.ball.height >= graphics.window.height:\n\t\t\t\t\tgraphics.window.remove(graphics.ball)\n\t\t\t\t\tgraphics.window.add(graphics.ball, x=(graphics.window.width - graphics.ball.width) / 2, y=(graphics.window.height - graphics.ball.height * 2) / 2)\n\t\t\t\t\tlife -= 1\n\t\t\t\t\tgraphics.on_off = True\n\t\t\t\t\tgraphics.begin = False\n\t\t\t\t\tgraphics.life_label.text = \"Life: \" + str(life)\n\t\t\tpause(FRAME_RATE)\n\t\t\tif graphics.score_speed >= 5:\n\t\t\t\tvx *= 1.2\n\t\t\t\tgraphics.score_speed = 0\n\t\telse:\n\t\t\tbreak\n\n\n\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "def", "name": "main", "data": "def main():\n\t# initial window\n\tgraphics = BreakoutGraphics()\n\n\t# other settings\n\tlives = NUM_LIVES\n\tvy = graphics.get_ball_dy()\n\tvx = graphics.get_ball_dx()\n\n\t# animation\n\twhile True:\n\t\tpause(FRAME_RATE)\n\t\tif lives > 0 and graphics.num_bricks > 0:\n\n\t\t\t# first-click to start game\n\t\t\tif graphics.to_start is True:\n\t\t\t\tgraphics.ball.move(vx, vy)\n\n\t\t\t\t# rebound when ball bumps into bricks or the paddle\n\t\t\t\tif graphics.detect_bump() is True:\n\t\t\t\t\t# when near bricks\n\t\t\t\t\tif graphics.ball.y < graphics.bricks_bottom:\n\t\t\t\t\t\tvy = - vy\t   # change the vertical direction of ball\n\n\t\t\t\t\t# when near paddle and the distance from top of paddle to bottom of ball is less than dy\n\t\t\t\t\t# let ball not run along the paddle\n\t\t\t\t\telif graphics.ball.y + graphics.ball.height - graphics.paddle.y < graphics.get_ball_dy():\n\t\t\t\t\t\tvy = - vy\t   # change the vertical direction of ball\n\n\t\t\t\t# when ball touches the left and right side of wall\n\t\t\t\tif graphics.ball.x <= 0 or (graphics.ball.x + graphics.ball.width) > graphics.window.width:\n\t\t\t\t\tvx = - vx\t   # change the horizontal direction of ball\n\n\t\t\t\t# when ball touches the upper side of wall\n\t\t\t\tif graphics.ball.y <= 0:\n\t\t\t\t\tvy = - vy\t   # change the vertical direction of ball\n\n\t\t\t\t# when ball falls down out of window\n\t\t\t\telif graphics.ball.y >= graphics.window.height:\n\t\t\t\t\tlives -= 1\n\t\t\t\t\tif lives > 0:\n\t\t\t\t\t\tpause(FRAME_RATE * 100)\n\t\t\t\t\t\tgraphics.lives_label.text = str(lives) + ' lives left!'\n\t\t\t\t\t\tgraphics.show_lives_left()\n\t\t\t\t\t\tpause(FRAME_RATE * 100)\n\t\t\t\t\t\tgraphics.window.remove(graphics.lives_label)\n\t\t\t\t\t\tpause(FRAME_RATE * 100)\n\t\t\t\t\t\tgraphics.reset_ball()\n\t\t\t\t\t\tpause(FRAME_RATE * 100)\n\t\telse:\n\t\t\tbreak\n\n\t# when win\n\tif graphics.num_bricks == 0:\n\t\tpause(FRAME_RATE * 50)\n\t\tgraphics.game_win()\n\n\t# when lose\n\telif lives == 0:\n\t\tpause(FRAME_RATE * 50)\n\t\tgraphics.game_over()\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [], [{"term": "def", "name": "conv2d_strategy_intel_graphics", "data": "def conv2d_strategy_intel_graphics(attrs, inputs, out_type, target):\n\t\"\"\"conv2d intel graphics strategy\"\"\"\n\tstrategy = _op.OpStrategy()\n\tdata, kernel = inputs\n\tdilation_h, dilation_w = get_const_tuple(attrs.dilation)\n\tgroups = attrs.groups\n\tlayout = attrs.data_layout\n\tkernel_layout = attrs.kernel_layout\n\tif dilation_h < 1 or dilation_w < 1:\n\t\traise ValueError(\"dilation should be positive value\")\n\n\tif groups == 1:\n\t\tif layout == \"NCHW\":\n\t\t\tassert kernel_layout == \"OIHW\"\n\t\t\tstrategy.add_implementation(\n\t\t\t\twrap_compute_conv2d(topi.intel_graphics.conv2d_nchw),\n\t\t\t\twrap_topi_schedule(topi.intel_graphics.schedule_conv2d_nchw),\n\t\t\t\tname=\"conv2d_nchw.intel_graphics\",\n\t\t\t)\n\t\t\t# conv2d_NCHWc won't work without alter op layout pass\n\t\t\t# TODO(@Laurawly): fix this\n\t\t\tstrategy.add_implementation(\n\t\t\t\twrap_compute_conv2d(topi.intel_graphics.conv2d_NCHWc, True, True),\n\t\t\t\twrap_topi_schedule(topi.intel_graphics.schedule_conv2d_NCHWc),\n\t\t\t\tname=\"conv2d_NCHWc.intel_graphics\",\n\t\t\t\tplevel=5,\n\t\t\t)\n\t\telse:\n\t\t\traise RuntimeError(\"Unsupported conv2d layout {} for intel graphics\".format(layout))\n\telif is_depthwise_conv2d(data.shape, layout, kernel.shape, kernel_layout, groups):\n\t\tif layout == \"NCHW\":\n\t\t\tassert kernel_layout == \"OIHW\"\n\t\t\tstrategy.add_implementation(\n\t\t\t\twrap_compute_conv2d(topi.intel_graphics.depthwise_conv2d_nchw),\n\t\t\t\twrap_topi_schedule(topi.intel_graphics.schedule_depthwise_conv2d_nchw),\n\t\t\t\tname=\"depthwise_conv2d_nchw.intel_graphics\",\n\t\t\t)\n\t\telse:\n\t\t\traise RuntimeError(\"Unsupported depthwise_conv2d layout {}\".format(layout))\n\telse:  # group_conv2d\n\t\traise RuntimeError(\"group_conv2d is not supported for intel graphics\")\n\treturn strategy\n\n", "description": "conv2d intel graphics strategy", "category": "graphics", "imports": ["# pylint: disable=invalid-name,unused-argument,wildcard-import,unused-wildcard-import", "from tvm import topi", "from .generic import *", "from .. import op as _op"]}, {"term": "def", "name": "conv2d_NCHWc_strategy_intel_graphics", "data": "def conv2d_NCHWc_strategy_intel_graphics(attrs, inputs, out_type, target):\n\t\"\"\"conv2d_NCHWc intel_graphics strategy\"\"\"\n\tstrategy = _op.OpStrategy()\n\tstrategy.add_implementation(\n\t\twrap_compute_conv2d(topi.intel_graphics.conv2d_NCHWc, True, True),\n\t\twrap_topi_schedule(topi.intel_graphics.schedule_conv2d_NCHWc),\n\t\tname=\"conv2d_NCHWc.intel_graphics\",\n\t)\n\treturn strategy\n", "description": "conv2d_NCHWc intel_graphics strategy", "category": "graphics", "imports": ["# pylint: disable=invalid-name,unused-argument,wildcard-import,unused-wildcard-import", "from tvm import topi", "from .generic import *", "from .. import op as _op"]}], [{"term": "def", "name": "show", "data": "def show(graphics, title=None, width=None, height=None, backend=None, **options):\n\t\"\"\"\n\tShows given graphics in available viewer app. Currently, this is only\n\tavailable if wxPython, PyQt5, PyQt6, PySide2 or PySide2 is installed or\n\twithin Pythonista app on iOS. This method makes sure appropriate backend\n\tcanvas is created and provided to graphics 'draw' method.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\ttitle: str or None\n\t\t\tViewer frame title.\n\t\t\n\t\twidth: float or None\n\t\t\tViewer width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tViewer height in device units.\n\t\t\n\t\tbackend: pero.BACKEND\n\t\t\tSpecific backend to be used. The value must be an item from the\n\t\t\tpero.BACKEND enum.\n\t\t\n\t\toptions: str:any pairs\n\t\t\tAdditional parameters for specific backend.\n\t\"\"\"\n\t\n\t# get backends\n\tbackends = VIEWER_PRIORITY if backend is None else [backend]\n\t\n\t# get backend\n\tbackend = None\n\tfor module in backends:\n\t\t\n\t\t# try to import backend\n\t\ttry:\n\t\t\tif module == BACKEND_PYTHONISTA:\n\t\t\t\tfrom . import pythonista as backend\n\t\t\t\n\t\t\telif module == BACKEND_QT:\n\t\t\t\tfrom . import qt as backend\n\t\t\t\n\t\t\telif module == BACKEND_WX:\n\t\t\t\tfrom . import wx as backend\n\t\t\t\n\t\t\tbreak\n\t\t\n\t\t# ignore missing library\n\t\texcept ImportError:\n\t\t\tbackend = None\n\t\t\tpass\n\t\n\t# no viewer available\n\tif backend is None:\n\t\tmessage = \"No viewer available or missing library (e.g. wxPython, PyQt5, PyQt6, PySide2, PySide6 or Pythonista)!\"\n\t\traise ImportError(message)\n\t\n\t# show viewer\n\tbackend.show(graphics, title, width, height, **options)\n\n", "description": "\n\tShows given graphics in available viewer app. Currently, this is only\n\tavailable if wxPython, PyQt5, PyQt6, PySide2 or PySide2 is installed or\n\twithin Pythonista app on iOS. This method makes sure appropriate backend\n\tcanvas is created and provided to graphics 'draw' method.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\ttitle: str or None\n\t\t\tViewer frame title.\n\t\t\n\t\twidth: float or None\n\t\t\tViewer width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tViewer height in device units.\n\t\t\n\t\tbackend: pero.BACKEND\n\t\t\tSpecific backend to be used. The value must be an item from the\n\t\t\tpero.BACKEND enum.\n\t\t\n\t\toptions: str:any pairs\n\t\t\tAdditional parameters for specific backend.\n\t", "category": "graphics", "imports": ["import os.path", "from .. enums import *", "\t\t# try to import backend", "\t\t\t\tfrom . import pythonista as backend", "\t\t\t\tfrom . import qt as backend", "\t\t\t\tfrom . import wx as backend", "\t# import backend", "\t\t# try to import backend", "\t\t\t\tfrom . import cairo as backend", "\t\t\t\tfrom . import json as backend", "\t\t\t\tfrom . import mupdf as backend", "\t\t\t\tfrom . import pythonista as backend", "\t\t\t\tfrom . import qt as backend", "\t\t\t\tfrom . import svg as backend", "\t\t\t\tfrom . import wx as backend", "\t\tfrom . import qt", "\t\tfrom . import wx", "\t\tfrom . import pythonista"]}, {"term": "def", "name": "export", "data": "def export(graphics, path, width=None, height=None, backend=None, **options):\n\t\"\"\"\n\tDraws given graphics into specified image file using the format determined\n\tautomatically from the file extension. This method makes sure appropriate\n\tbackend canvas is created and provided to graphics 'draw' method.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tpath: str\n\t\t\tFull path of a file to save the image into.\n\t\t\n\t\twidth: float or None\n\t\t\tImage width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage height in device units.\n\t\t\n\t\tbackend: pero.BACKEND\n\t\t\tSpecific backend to be used. The value must be an item from the\n\t\t\tpero.BACKEND enum.\n\t\t\n\t\toptions: str:any pairs\n\t\t\tAdditional parameters for specific backend.\n\t\"\"\"\n\t\n\t# get filename and extension\n\tdirname, filename = os.path.split(path)\n\tbasename, extension = os.path.splitext(filename)\n\textension = extension.lower()\n\t\n\t# get backends\n\tbackends = EXPORT_PRIORITY if backend is None else [backend]\n\t\n\t# import backend\n\tbackend = None\n\tfor module in backends:\n\t\t\n\t\t# check if format is recognized by backend\n\t\tif extension not in EXPORT_FORMATS[module]:\n\t\t\tcontinue\n\t\t\n\t\t# try to import backend\n\t\ttry:\n\t\t\tif module == BACKEND_CAIRO:\n\t\t\t\tfrom . import cairo as backend\n\t\t\t\n\t\t\telif module == BACKEND_JSON:\n\t\t\t\tfrom . import json as backend\n\t\t\t\n\t\t\telif module == BACKEND_MUPDF:\n\t\t\t\tfrom . import mupdf as backend\n\t\t\t\n\t\t\telif module == BACKEND_PYTHONISTA:\n\t\t\t\tfrom . import pythonista as backend\n\t\t\t\n\t\t\telif module == BACKEND_QT:\n\t\t\t\tfrom . import qt as backend\n\t\t\t\n\t\t\telif module == BACKEND_SVG:\n\t\t\t\tfrom . import svg as backend\n\t\t\t\n\t\t\telif module == BACKEND_WX:\n\t\t\t\tfrom . import wx as backend\n\t\t\t\n\t\t\tbreak\n\t\t\n\t\t# ignore missing library\n\t\texcept ImportError:\n\t\t\tbackend = None\n\t\t\tpass\n\t\n\t# unsupported format\n\tif backend is None:\n\t\tmessage = \"Unsupported image format or missing library (e.g. wxPython, PyCairo, PyQt5, PyQt6, PySide2, PySide6)! -> %s\" % extension\n\t\traise ImportError(message)\n\t\n\t# export image\n\tbackend.export(graphics, path, width, height, **options)\n\n", "description": "\n\tDraws given graphics into specified image file using the format determined\n\tautomatically from the file extension. This method makes sure appropriate\n\tbackend canvas is created and provided to graphics 'draw' method.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tpath: str\n\t\t\tFull path of a file to save the image into.\n\t\t\n\t\twidth: float or None\n\t\t\tImage width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage height in device units.\n\t\t\n\t\tbackend: pero.BACKEND\n\t\t\tSpecific backend to be used. The value must be an item from the\n\t\t\tpero.BACKEND enum.\n\t\t\n\t\toptions: str:any pairs\n\t\t\tAdditional parameters for specific backend.\n\t", "category": "graphics", "imports": ["import os.path", "from .. enums import *", "\t\t# try to import backend", "\t\t\t\tfrom . import pythonista as backend", "\t\t\t\tfrom . import qt as backend", "\t\t\t\tfrom . import wx as backend", "\t# import backend", "\t\t# try to import backend", "\t\t\t\tfrom . import cairo as backend", "\t\t\t\tfrom . import json as backend", "\t\t\t\tfrom . import mupdf as backend", "\t\t\t\tfrom . import pythonista as backend", "\t\t\t\tfrom . import qt as backend", "\t\t\t\tfrom . import svg as backend", "\t\t\t\tfrom . import wx as backend", "\t\tfrom . import qt", "\t\tfrom . import wx", "\t\tfrom . import pythonista"]}, {"term": "def", "name": "debug", "data": "def debug(graphics, canvas='show', title=\"\", width=None, height=None, backend=None, **options):\n\t\"\"\"\n\tRenders given graphics using simple viewer or file format. This method makes\n\tsure appropriate backend canvas is created and provided to graphics 'draw'\n\tmethod. In case of the image export the file is stored in current working\n\tdirectory using 'test' and appropriate format as the name.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tcanvas: str\n\t\t\tSpecifies drawing mechanism to be used. This can be either 'show',\n\t\t\t'wx', 'qt' or 'pythonista' to display graphics within a simple\n\t\t\tviewer app, or any of the supported image formats (e.g. 'png',\n\t\t\t'svg') to draw to 'test.?' file.\n\t\t\n\t\ttitle: str or None\n\t\t\tViewer frame title.\n\t\t\n\t\twidth: float or None\n\t\t\tImage or viewer width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage or viewer height in device units.\n\t\t\n\t\tbackend: pero.BACKEND\n\t\t\tSpecific backend to be used. The value must be an item from the\n\t\t\tpero.BACKEND enum.\n\t\t\n\t\toptions: key:value pairs\n\t\t\tAdditional parameters for specific backend.\n\t\"\"\"\n\t\n\t# render graphics in available viewer\n\tif canvas == 'show':\n\t\tshow(graphics, title, width, height, backend, **options)\n\t\n\t# render graphics into qt viewer\n\telif canvas == 'qt':\n\t\tfrom . import qt\n\t\tqt.show(graphics, title, width, height, **options)\n\t\n\t# render graphics into wx viewer\n\telif canvas == 'wx':\n\t\tfrom . import wx\n\t\twx.show(graphics, title, width, height, **options)\n\t\n\t# render graphics into Pythonista console\n\telif canvas == 'pythonista':\n\t\tfrom . import pythonista\n\t\tpythonista.show(graphics, width, height, **options)\n\t\n\t# render graphics as image file\n\telse:\n\t\tfilename = \"test.%s\" % canvas\n\t\texport(graphics, filename, width, height, backend, **options)\n", "description": "\n\tRenders given graphics using simple viewer or file format. This method makes\n\tsure appropriate backend canvas is created and provided to graphics 'draw'\n\tmethod. In case of the image export the file is stored in current working\n\tdirectory using 'test' and appropriate format as the name.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tcanvas: str\n\t\t\tSpecifies drawing mechanism to be used. This can be either 'show',\n\t\t\t'wx', 'qt' or 'pythonista' to display graphics within a simple\n\t\t\tviewer app, or any of the supported image formats (e.g. 'png',\n\t\t\t'svg') to draw to 'test.?' file.\n\t\t\n\t\ttitle: str or None\n\t\t\tViewer frame title.\n\t\t\n\t\twidth: float or None\n\t\t\tImage or viewer width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage or viewer height in device units.\n\t\t\n\t\tbackend: pero.BACKEND\n\t\t\tSpecific backend to be used. The value must be an item from the\n\t\t\tpero.BACKEND enum.\n\t\t\n\t\toptions: key:value pairs\n\t\t\tAdditional parameters for specific backend.\n\t", "category": "graphics", "imports": ["import os.path", "from .. enums import *", "\t\t# try to import backend", "\t\t\t\tfrom . import pythonista as backend", "\t\t\t\tfrom . import qt as backend", "\t\t\t\tfrom . import wx as backend", "\t# import backend", "\t\t# try to import backend", "\t\t\t\tfrom . import cairo as backend", "\t\t\t\tfrom . import json as backend", "\t\t\t\tfrom . import mupdf as backend", "\t\t\t\tfrom . import pythonista as backend", "\t\t\t\tfrom . import qt as backend", "\t\t\t\tfrom . import svg as backend", "\t\t\t\tfrom . import wx as backend", "\t\tfrom . import qt", "\t\tfrom . import wx", "\t\tfrom . import pythonista"]}], [], [{"term": "class", "name": "EinkGraphicsTest", "data": "class EinkGraphicsTest(unittest.TestCase):\n\t\"\"\"Tests the ``EinkGraphics`` class.\"\"\"\n\n\tdef _random_image(self):\n\t\t\"\"\"Return a randomly generated ``Image`` with mode ``'RGB'``.\n\n\t\tUse a fixed seed.\n\t\t\"\"\"\n\t\trng = random.Random(247693537)\n\t\tpixels = []\n\t\tfor _ in range(400):\n\t\t\tpixel = []\n\t\t\tfor _ in range(3):\n\t\t\t\tpixel.append(rng.randrange(256))\n\t\t\tpixels.append(tuple(pixel))\n\t\timage = Image.new('RGB', (20, 20))\n\t\timage.putdata(pixels)\n\t\treturn image\n\n\tdef _random_grayscale_image(self):\n\t\t\"\"\"Return a randomly generated ``Image`` with mode ``'L'``.\n\n\t\tUse a fixed seed.\n\t\t\"\"\"\n\t\trng = random.Random(649695934)\n\t\tpixels = list(rng.randrange(256) for _ in range(400))\n\t\timage = Image.new('L', (20, 20))\n\t\timage.putdata(pixels)\n\t\treturn image\n\n\tdef _are_pixels_in(self, image, values):\n\t\t\"\"\"Return whether all pixels in ``image.getdata()`` are in ``values``.\n\n\t\tArguments:\n\t\t\timage (Image): The image.\n\t\t\tvalues (set): The values.\n\n\t\tReturn:\n\t\t\tbool: The result.\n\t\t\"\"\"\n\t\tfor pixel in image.getdata():\n\t\t\tif pixel not in values:\n\t\t\t\treturn False\n\t\treturn True\n\n\tdef _check_round(self, palette):\n\t\t\"\"\"Test ``EinkGraphics.round`` with the specified ``Palette``.\"\"\"\n\t\tpixels = []\n\t\texpected_pixels = []\n\t\tfor color in palette._colors:\n\t\t\tpixels.append(color)\n\t\t\texpected_pixels.append(color)\n\n\t\t\tpixel = []\n\t\t\tfor component in color:\n\t\t\t\tpixel.append(\n\t\t\t\t\tcomponent + 1 if component < 255 else component - 1)\n\t\t\tpixels.append(tuple(pixel))\n\t\t\texpected_pixels.append(color)\n\t\timage1 = Image.new('RGB', (len(palette._colors), 2))\n\t\timage1.putdata(pixels)\n\n\t\tresult1 = EinkGraphics.round(image1, palette)\n\t\tself.assertEqual(image1.size, result1.size)\n\t\tself.assertFalse(EinkGraphics._has_alpha(result1))\n\t\tactual_pixels = result1.convert('RGB').getdata()\n\t\tself.assertEqual(expected_pixels, list(actual_pixels))\n\n\t\timage2 = self._random_image()\n\t\tresult2 = EinkGraphics.round(image2, palette)\n\t\tself.assertEqual(image2.size, result2.size)\n\t\tself.assertFalse(EinkGraphics._has_alpha(result2))\n\t\tself.assertTrue(\n\t\t\tself._are_pixels_in(result2.convert('RGB'), palette._colors))\n\n\t\timage3 = self._random_grayscale_image()\n\t\tresult3 = EinkGraphics.round(image3, palette)\n\t\tself.assertEqual(image3.size, result3.size)\n\t\tself.assertFalse(EinkGraphics._has_alpha(result3))\n\t\tself.assertTrue(\n\t\t\tself._are_pixels_in(result3.convert('RGB'), palette._colors))\n\n\tdef test_round(self):\n\t\t\"\"\"Test ``EinkGraphics.round``.\"\"\"\n\t\tself._check_round(Palette.THREE_BIT_GRAYSCALE)\n\t\tself._check_round(Palette.MONOCHROME)\n\t\tself._check_round(Palette.SEVEN_COLOR)\n\n\tdef _check_pixels(self, expected_pixels, actual_pixels):\n\t\t\"\"\"Check whether ``actual_pixels`` matches ``expected_pixels``.\n\n\t\tCheck whether the pixels in ``actual_pixels`` match those in\n\t\t``expected_pixels``. We say they match if ``actual_pixels[i] in\n\t\texpected_pixels[i]`` for all ``i``.\n\t\t\"\"\"\n\t\tself.assertEqual(len(expected_pixels), len(actual_pixels))\n\t\tfor expected_pixel, actual_pixel in (\n\t\t\t\tzip(expected_pixels, actual_pixels)):\n\t\t\tself.assertIn(actual_pixel, expected_pixel)\n\n\tdef test_round_grayscale(self):\n\t\t\"\"\"Test ``EinkGraphics.round`` with ``Palette.THREE_BIT_GRAYSCALE``.\"\"\"\n\t\tpixels1 = list(range(256))\n\t\timage1 = Image.new('L', (16, 16))\n\t\timage1.putdata(pixels1)\n\t\tresult1 = EinkGraphics.round(image1)\n\t\tself.assertEqual(image1.size, result1.size)\n\t\tself.assertFalse(EinkGraphics._has_alpha(result1))\n\t\texpected_pixels = (\n\t\t\t([[0]] * 18) + [[0, 1]] + ([[36]] * 36) + ([[73]] * 36) +\n\t\t\t[[73, 109]] + ([[109]] * 36) + ([[146]] * 36) + [[146, 182]] +\n\t\t\t([[182]] * 36) + ([[219]] * 36) + [[219, 255]] + ([[255]] * 18))\n\t\tself._check_pixels(\n\t\t\texpected_pixels, list(result1.convert('L').getdata()))\n\n\t\tpixels2 = list([(i, i, i) for i in range(256)])\n\t\timage2 = Image.new('RGB', (16, 16))\n\t\timage2.putdata(pixels2)\n\t\tresult2 = EinkGraphics.round(image2)\n\t\tself.assertEqual(image2.size, result2.size)\n\t\tself.assertFalse(EinkGraphics._has_alpha(result2))\n\t\tself._check_pixels(\n\t\t\texpected_pixels, list(result2.convert('L').getdata()))\n\n\tdef test_round_monochrome(self):\n\t\t\"\"\"Test ``EinkGraphics.round`` with ``Palette.MONOCHROME``.\"\"\"\n\t\tpixels1 = list(range(256))\n\t\timage1 = Image.new('L', (16, 16))\n\t\timage1.putdata(pixels1)\n\t\tresult1 = EinkGraphics.round(image1, Palette.MONOCHROME)\n\t\tself.assertEqual(image1.size, result1.size)\n\t\tself.assertFalse(EinkGraphics._has_alpha(result1))\n\t\texpected_pixels = ([0] * 128) + ([255] * 128)\n\t\tself.assertEqual(\n\t\t\texpected_pixels, list(result1.convert('L').getdata()))\n\n\t\tpixels2 = list([(i, i, i) for i in range(256)])\n\t\timage2 = Image.new('RGB', (16, 16))\n\t\timage2.putdata(pixels2)\n\t\tresult2 = EinkGraphics.round(image2, Palette.MONOCHROME)\n\t\tself.assertEqual(image2.size, result2.size)\n\t\tself.assertFalse(EinkGraphics._has_alpha(result2))\n\t\tself.assertEqual(\n\t\t\texpected_pixels, list(result2.convert('L').getdata()))\n\n\tdef _check_dither(self, palette):\n\t\t\"\"\"Test ``EinkGraphics.dither`` with the specified ``Palette``.\"\"\"\n\t\timage1 = self._random_image()\n\t\tresult1 = EinkGraphics.dither(image1, palette)\n\t\tself.assertEqual(image1.size, result1.size)\n\t\tself.assertFalse(EinkGraphics._has_alpha(result1))\n\t\tself.assertTrue(\n\t\t\tself._are_pixels_in(result1.convert('RGB'), palette._colors))\n\n\t\timage2 = self._random_grayscale_image()\n\t\tresult2 = EinkGraphics.dither(image2, palette)\n\t\tself.assertEqual(image2.size, result2.size)\n\t\tself.assertFalse(EinkGraphics._has_alpha(result2))\n\t\tself.assertTrue(\n\t\t\tself._are_pixels_in(result2.convert('RGB'), palette._colors))\n\n\tdef test_dither(self):\n\t\t\"\"\"Test ``EinkGraphics.dither``.\"\"\"\n\t\tself._check_dither(Palette.THREE_BIT_GRAYSCALE)\n\t\tself._check_dither(Palette.MONOCHROME)\n\t\tself._check_dither(Palette.SEVEN_COLOR)\n\n\tdef test_dither_grayscale(self):\n\t\t\"\"\"Test ``EinkGraphics.dither`` with ``Palette.THREE_BIT_GRAYSCALE``.\n\t\t\"\"\"\n\t\t# Test an image that only contains pixels with luminosity between 1/7\n\t\t# and 2/7\n\t\trng = random.Random(-1287208726)\n\t\tpixels = list([rng.randrange(36, 74) for i in range(400)])\n\t\timage = Image.new('L', (20, 20))\n\t\timage.putdata(pixels)\n\t\tresult = EinkGraphics.dither(image)\n\t\tself.assertEqual(image.size, result.size)\n\t\tself.assertFalse(EinkGraphics._has_alpha(result))\n\t\tself.assertTrue(\n\t\t\tself._are_pixels_in(result.convert('L'), set([36, 73])))\n", "description": "Tests the ``EinkGraphics`` class.", "category": "graphics", "imports": ["import random", "import unittest", "from PIL import Image", "from eink.image import EinkGraphics", "from eink.image import Palette"]}], [{"term": "class", "name": "classGraphics:", "data": "class Graphics:\n\tdef __init__(self, entity):\n\t\tself.entity = entity\n\n\tdef get_graphics(self, offset):\n\t\tpass\n\n", "description": null, "category": "graphics", "imports": ["from zsquirrel.context import ApplicationInterface", "from zsquirrel.utils.geometry import Rect, Vector, Wall, add_points", "import zsquirrel.constants as con"]}, {"term": "class", "name": "ImageGraphics", "data": "class ImageGraphics(Graphics):\n\tdef __init__(self, entity, image):\n\t\tself.image = image\n\t\tself.mirror = False, False\n\n\t\tsuper(ImageGraphics, self).__init__(entity)\n\n\tdef get_graphics(self, offset):\n\t\timage = self.image\n\n\t\tmirror_x, mirror_y = self.mirror\n\t\tif mirror_x or mirror_y:\n\t\t\timage = image.flip(mirror_x, mirror_y)\n\n\t\tposition = add_points(\n\t\t\tself.entity.position, offset\n\t\t)\n\t\targs = (image, position)\n\n\t\treturn [args]\n\n", "description": null, "category": "graphics", "imports": ["from zsquirrel.context import ApplicationInterface", "from zsquirrel.utils.geometry import Rect, Vector, Wall, add_points", "import zsquirrel.constants as con"]}, {"term": "class", "name": "ImageSectionGraphics", "data": "class ImageSectionGraphics(ImageGraphics):\n\tdef __init__(self, entity, image):\n\t\tsuper(ImageSectionGraphics, self).__init__(entity, image)\n\n\t\tself.layers = []\n\n\tdef get_graphics(self, offset):\n\t\tif not self.layers:\n\t\t\treturn super(ImageSectionGraphics, self).get_graphics(offset)\n\n\t\telse:\n\t\t\targs = []\n\n\t\t\tfor layer in self.layers:\n\t\t\t\ta = self.get_section_args(layer)\n\t\t\t\tposition = add_points(a[1], offset)\n\t\t\t\ta = (a[0], position)\n\t\t\t\targs.append(a)\n\n\t\t\treturn args\n\n\t# section = (rect, draw_offset, mirror=(False, False))\n\t# rect = Rect(size, position)   object\n\t# draw_offset = (ox, oy)\t\t(int, int)\n\t# mirror = (x_bool, y_bool)\t (bool, bool)\n\tdef get_section_args(self, section):\n\t\trect, offset = section[0:2]\n\t\timage = self.image.subsurface(rect)\n\n\t\tmirror = False, False\n\n\t\tif len(section) > 2:\n\t\t\tmirror = section[2]\n\n\t\tmirror_x, mirror_y = mirror\n\t\tif mirror_x or mirror_y:\n\t\t\timage = image.flip(mirror_x, mirror_y)\n\n\t\tpx, py = self.entity.position\n\t\tox, oy = offset\n\t\tpx += ox\n\t\tpy += oy\n\n\t\tlayer_args = (image, (px, py))\n\n\t\treturn layer_args\n\n", "description": null, "category": "graphics", "imports": ["from zsquirrel.context import ApplicationInterface", "from zsquirrel.utils.geometry import Rect, Vector, Wall, add_points", "import zsquirrel.constants as con"]}, {"term": "class", "name": "GeometryGraphics", "data": "class GeometryGraphics(Graphics):\n\tdef __init__(self, entity):\n\t\tsuper(GeometryGraphics, self).__init__(entity)\n\n\t\tself.items = []\n\n\t# item = (Rect, draw_color, draw_width=1)\n\t@staticmethod\n\tdef get_rect_args(item, offset):\n\t\tif len(item) < 3:\n\t\t\trect, color = item\n\t\t\twidth = 0\n\t\telse:\n\t\t\trect, color, width = item\n\n\t\tx, y = add_points(offset, rect.position)\n\t\trect = rect.pygame_rect\n\t\trect.x = int(x)\n\t\trect.y = int(y)\n\n\t\treturn (\n\t\t\tcon.PYGAME_RECT, color, rect, width\n\t\t)\n\n\t# v = (Vector, draw_color, draw_width=1)\n\t@staticmethod\n\tdef get_vector_args(item, offset):\n\t\tif len(item) < 3:\n\t\t\tvector, color = item\n\t\t\twidth = 1\n\t\telse:\n\t\t\tvector, color, width = item\n\n\t\tend = vector.apply_to_point(offset)\n\t\tend = int(end[0]), int(end[1])\n\n\t\treturn (\n\t\t\tcon.PYGAME_LINE, color, offset, end, width\n\t\t)\n\n\tdef get_graphics(self, offset=None):\n\t\tif not offset:\n\t\t\toffset = 0, 0\n\t\toffset = add_points(self.entity.position, offset)\n\t\toffset = int(offset[0]), int(offset[1])\n\n\t\targs = []\n\n\t\tfor item in self.items:\n\t\t\tif type(item[0]) is Rect:\n\t\t\t\targs.append(self.get_rect_args(item, offset))\n\n\t\t\telif type(item[0]) is Vector:\n\t\t\t\targs.append(self.get_vector_args(item, offset))\n\n\t\t\telif type(item[0]) is Wall:\n\t\t\t\targs.append(self.get_vector_args(\n\t\t\t\t\titem, add_points(offset, item[0].origin)\n\t\t\t\t))\n\n\t\t\telif item[0] == con.PYGAME_LINE:\n\t\t\t\titem[2] = add_points(offset, item[2])\n\t\t\t\titem[3] = add_points(offset, item[3])\n\t\t\t\targs.append(item)\n\n\t\t\telif item[0] == con.PYGAME_RECT:\n\t\t\t\titem[2].x += offset[0]\n\t\t\t\titem[2].y += offset[1]\n\t\t\t\targs.append(item)\n\n\t\t\telif item[0] == con.PYGAME_CIRCLE:\n\t\t\t\titem = list(item)\n\t\t\t\titem[2] = add_points(offset, item[2])\n\t\t\t\targs.append(item)\n\n\t\treturn args\n\n", "description": null, "category": "graphics", "imports": ["from zsquirrel.context import ApplicationInterface", "from zsquirrel.utils.geometry import Rect, Vector, Wall, add_points", "import zsquirrel.constants as con"]}, {"term": "class", "name": "GraphicsInterface", "data": "class GraphicsInterface(ApplicationInterface):\n\tdef __init__(self, *args):\n\t\tsuper(GraphicsInterface, self).__init__(*args)\n\n\t\tself.init_order = [\n\t\t\tself.set_image.__name__,\n\t\t\tself.set_image_sections.__name__\n\t\t]\n\n\tdef set_image(self, entity, file_name, sub=None):\n\t\tif not sub:\n\t\t\timage = self.context.load_resource(file_name)\n\t\telse:\n\t\t\tx, y, w, h = sub\n\t\t\tsize, position = (w, h), (x, y)\n\n\t\t\timage = self.context.load_resource(\n\t\t\t\tfile_name\n\t\t\t).subsurface(Rect(size, position))\n\n\t\tgraphics = ImageGraphics(entity, image)\n\t\tentity.graphics = graphics\n\n\t@staticmethod\n\tdef set_color_key(entity, x, y):\n\t\timage = entity.graphics.image\n\t\timage.set_color_key((x, y))\n\n\tdef set_image_sections(self, entity, file_name, *sections):\n\t\timage = self.context.load_resource(file_name)\n\t\tgraphics = ImageSectionGraphics(entity, image)\n\n\t\tfor section in sections:\n\t\t\tx, y, w, h = section[:4]\n\t\t\trect = Rect((w, h), (x, y))\n\n\t\t\tox, oy = 0, 0\n\t\t\tif len(section) > 4:\n\t\t\t\tox, oy = section[4:6]\n\n\t\t\tmx, my = False, False\n\t\t\tif len(section) > 6:\n\t\t\t\tmx, my = section[6:]\n\n\t\t\tgraphics.layers.append(\n\t\t\t\t(rect, (ox, oy), (mx, my))\n\t\t\t)\n\n\t\tentity.graphics = graphics\n\n\tdef set_rect_image(self, entity, *args):\n\t\tif entity.graphics is None:\n\t\t\tentity.graphics = GeometryGraphics(entity)\n\n\t\tif len(args) > 1:\n\t\t\tcolor, width = args\n\t\telse:\n\t\t\tcolor = args[0]\n\t\t\twidth = 1\n\n\t\trect = Rect(entity.size, (0, 0))\n\t\tentity.graphics.items.append(\n\t\t\t(rect, color, width)\n\t\t)\n\n\t\tentity.update_methods.append(\n\t\t\tlambda: self.update_rect_image(entity, rect)\n\t\t)\n\n\t@staticmethod\n\tdef update_rect_image(entity, rect):\n\t\trect.size = entity.size\n\n\t@staticmethod\n\tdef set_vector_image(entity, *args):\n\t\tif entity.graphics is None:\n\t\t\tentity.graphics = GeometryGraphics(entity)\n\n\t\tif len(args) > 3:\n\t\t\tcolor, start, end, width = args\n\t\telse:\n\t\t\tcolor, start, end = args\n\t\t\twidth = 1\n\n\t\tox, oy = start\n\t\tif (ox, oy) == (0, 0):\n\t\t\tv = Vector(*end)\n\t\telse:\n\t\t\tv = Wall(start, end)\n\n\t\tentity.graphics.items.append(\n\t\t\t(v, color, width)\n\t\t)\n\n\t@staticmethod\n\tdef set_draw_method(entity, *args):\n\t\tif entity.graphics is None:\n\t\t\tentity.graphics = GeometryGraphics(entity)\n\t\tentity.graphics.items.append(args)\n", "description": null, "category": "graphics", "imports": ["from zsquirrel.context import ApplicationInterface", "from zsquirrel.utils.geometry import Rect, Vector, Wall, add_points", "import zsquirrel.constants as con"]}], [{"term": "def", "name": "render", "data": "def render(array):\n\t\twin = graphics.GraphWin(\"My Circle\", 300, 300)\n\t\twin.setBackground(\"grey\")\n\n\t\tradius = 50\n\n\t\trPoint1 = graphics.Point(100,100)\n\t\trPoint2 = graphics.Point(200,200)\n\n\t\tr = graphics.Rectangle(rPoint1, rPoint2)\n\n\t\taPoint1 = graphics.Point(0,0)\n\t\taPoint2 = graphics.Point(100,100)\n\t\tbPoint1 = graphics.Point(0,300)\n\t\tbPoint2 = graphics.Point(100,200)\n\t\tcPoint1 = graphics.Point(300,0)\n\t\tcPoint2 = graphics.Point(200,100)\n\t\tdPoint1 = graphics.Point(300,300)\n\t\tdPoint2 = graphics.Point(200,200)\n\n\t\taLine = graphics.Line(aPoint1, aPoint2)\n\t\tbLine = graphics.Line(bPoint1, bPoint2)\n\t\tcLine = graphics.Line(cPoint1, cPoint2)\n\t\tdLine = graphics.Line(dPoint1, dPoint2)\n\n\t\taLine.draw(win)\n\t\tbLine.draw(win)\n\t\tcLine.draw(win)\n\t\tdLine.draw(win)\n\n\t\tr.draw(win)\n\n\t\tc = graphics.Circle(graphics.Point(150,150), radius)\n\t\tc.setFill(\"green\")\n\t\tc.draw(win)\n\n\t\tt = 0\n\t\twhile t < 60 :\n\t\t\tsys.stdout.write(\"Dropping back\")\n\t\t\tradius = array.pop(0)\n\t\t\tsys.stdout.write(\"New Radius is \" + str(radius))\n\t\t\tc.undraw()\n\t\t\tc = graphics.Circle(graphics.Point(150,150), radius)\n\t\t\tc.setFill(\"green\")\n\t\t\tc.draw(win)\n\t\t\ttime.sleep(0.25)\n\t\t\tt = t+1\n\t\twin.close()\n", "description": null, "category": "graphics", "imports": ["import packages.graphics as graphics", "import time, os, sys"]}], [], [], [{"term": "class", "name": "MainScreen", "data": "class MainScreen(Screen):\n\tdef draw_map(self,width_in_squares,height_in_squares):\n\t\tself.map = RelativeLayout(\n\t\t\t\t\tpos=(0,0),\n\t\t\t\t\tsize_hint=(None,None),\n\t\t\t\t\tsize=(app.scale*width_in_squares,app.scale*height_in_squares))\n\n\t\twith self.map.canvas.before:\n\t\t\tColor(.4,.4,0,.5)\n\t\t\tself.map.rect = Rectangle(\n\t\t\t\t\t\t\tsize=self.map.size)\n\n\n\t\tself.draw_room(3,3)\n\n\t\tapp.sm.get_screen('main').add_widget(self.map)\n\n\t\tself.__char_image = Image(\n\t\t\tsource=f'{char_0_atlas}generic',\n\t\t\tkeep_ratio=False,\n\t\t\tallow_stretch=True,\n\t\t\tsize_hint=(None,None),\n\t\t\tsize=(app.scale,app.scale),\n\t\t\tpos=(self.width/2-(app.scale/2),self.height/2))\n\n\n\t\tapp.sm.get_screen('main').add_widget(self.__char_image)\n\n\tdef move_map(self,x,y):\n\t\tself.map.pos=(self.map.x + x,self.map.y + y)\n\n\n\tdef draw_room(self,width_in_squares,height_in_squares):\n\t\tfor x in range(width_in_squares):\n\t\t\tfor y in range(height_in_squares):\n\t\t\t\tself.__cur_square_image = Image(\n\t\t\t\t\tsource=f'{tree0_atlas}row_33_col_12',\n\t\t\t\t\tkeep_ratio=False,\n\t\t\t\t\tallow_stretch=True,\n\t\t\t\t\tsize_hint=(None,None),\n\t\t\t\t\tsize=(app.scale,app.scale),\n\t\t\t\t\tpos=(app.scale*x,app.scale*y))\n\n\t\t\t\tself.map.add_widget(self.__cur_square_image)\n", "description": null, "category": "graphics", "imports": ["from kivy.app import App", "from kivy.uix.widget import Widget", "from kivy.uix.screenmanager import Screen, ScreenManager, SlideTransition", "from kivy.graphics import Color, Rectangle", "from kivy.atlas import Atlas", "from kivy.uix.relativelayout import RelativeLayout", "from kivy.uix.image import Image", "from kivy.core.window import Window", "import random"]}, {"term": "class", "name": "Roguelike", "data": "class Roguelike(App):\n\tdef build(self):\n\t\tapp.sm = ScreenManager(transition=SlideTransition())\n\n\t\tapp.sm.add_widget(MainScreen(name='main'))\n\n\t\t# This represents the size of a square in pixels. Art is 16x16, scaling up will zoom in.\n\t\tapp.scale = 64\n\n\t\treturn app.sm\n", "description": null, "category": "graphics", "imports": ["from kivy.app import App", "from kivy.uix.widget import Widget", "from kivy.uix.screenmanager import Screen, ScreenManager, SlideTransition", "from kivy.graphics import Color, Rectangle", "from kivy.atlas import Atlas", "from kivy.uix.relativelayout import RelativeLayout", "from kivy.uix.image import Image", "from kivy.core.window import Window", "import random"]}, {"term": "def", "name": "d", "data": "def d(sides,times=1):\n\t__result = 0\n\tfor roll in range(times):\n\t\t__result += random.randint(1,sides)\n\treturn __result\n\n", "description": null, "category": "graphics", "imports": ["from kivy.app import App", "from kivy.uix.widget import Widget", "from kivy.uix.screenmanager import Screen, ScreenManager, SlideTransition", "from kivy.graphics import Color, Rectangle", "from kivy.atlas import Atlas", "from kivy.uix.relativelayout import RelativeLayout", "from kivy.uix.image import Image", "from kivy.core.window import Window", "import random"]}], [{"term": "class", "name": "VMTemplateTests", "data": "class VMTemplateTests(unittest.TestCase):\n\tdef setUp(self):\n\t\tself.iso = '/tmp/mock.iso'\n\t\topen(self.iso, 'w').close()\n\n\tdef tearDown(self):\n\t\tos.unlink(self.iso)\n\n\tdef test_minimal_construct(self):\n\t\tdisk_bus = get_template_default('old', 'disk_bus')\n\t\tmemory = get_template_default('old', 'memory')\n\t\tnic_model = get_template_default('old', 'nic_model')\n\t\tfields = (('name', 'test'), ('os_distro', 'unknown'),\n\t\t\t\t  ('os_version', 'unknown'), ('cpus', 1),\n\t\t\t\t  ('memory', memory), ('networks', ['default']),\n\t\t\t\t  ('disk_bus', disk_bus), ('nic_model', nic_model),\n\t\t\t\t  ('graphics', {'type': 'vnc', 'listen': '127.0.0.1'}),\n\t\t\t\t  ('cdrom', self.iso))\n\n\t\targs = {'name': 'test', 'cdrom': self.iso}\n\t\tt = VMTemplate(args)\n\t\tfor name, val in fields:\n\t\t\tself.assertEquals(val, t.info.get(name))\n\n\tdef test_construct_overrides(self):\n\t\tgraphics = {'type': 'spice', 'listen': '127.0.0.1'}\n\t\targs = {'name': 'test', 'disks': [{'size': 10}, {'size': 20}],\n\t\t\t\t'graphics': graphics, \"cdrom\": self.iso}\n\t\tt = VMTemplate(args)\n\t\tself.assertEquals(2, len(t.info['disks']))\n\t\tself.assertEquals(graphics, t.info['graphics'])\n\n\tdef test_specified_graphics(self):\n\t\t# Test specified listen\n\t\tgraphics = {'type': 'vnc', 'listen': '127.0.0.1'}\n\t\targs = {'name': 'test', 'disks': [{'size': 10}, {'size': 20}],\n\t\t\t\t'graphics': graphics, 'cdrom': self.iso}\n\t\tt = VMTemplate(args)\n\t\tself.assertEquals(graphics, t.info['graphics'])\n\n\t\t# Test specified type\n\t\tgraphics = {'type': 'spice', 'listen': '127.0.0.1'}\n\t\targs['graphics'] = graphics\n\t\tt = VMTemplate(args)\n\t\tself.assertEquals(graphics, t.info['graphics'])\n\n\t\t# If no listen specified, test the default listen\n\t\tgraphics = {'type': 'vnc'}\n\t\targs['graphics'] = graphics\n\t\tt = VMTemplate(args)\n\t\tself.assertEquals(graphics['type'], t.info['graphics']['type'])\n\t\tself.assertEquals('127.0.0.1', t.info['graphics']['listen'])\n\n\tdef test_to_xml(self):\n\t\tgraphics = {'type': 'spice', 'listen': '127.0.0.1'}\n\t\tvm_uuid = str(uuid.uuid4()).replace('-', '')\n\t\tif os.uname()[4] in ['ppc', 'ppc64', 'ppc64le']:\n\t\t\tmaxmem = 3328\n\t\telse:\n\t\t\tmaxmem = 3072\n\t\tt = VMTemplate({'name': 'test-template', 'cdrom': self.iso,\n\t\t\t\t\t   'max_memory': maxmem << 10})\n\t\txml = t.to_vm_xml('test-vm', vm_uuid, graphics=graphics)\n\t\tself.assertEquals(vm_uuid, xpath_get_text(xml, \"/domain/uuid\")[0])\n\t\tself.assertEquals('test-vm', xpath_get_text(xml, \"/domain/name\")[0])\n\t\texpr = \"/domain/devices/graphics/@type\"\n\t\tself.assertEquals(graphics['type'], xpath_get_text(xml, expr)[0])\n\t\texpr = \"/domain/devices/graphics/@listen\"\n\t\tself.assertEquals(graphics['listen'], xpath_get_text(xml, expr)[0])\n\t\texpr = \"/domain/maxMemory/@slots\"\n\t\tself.assertEquals('2', xpath_get_text(xml, expr)[0])\n\n\tdef test_arg_merging(self):\n\t\t\"\"\"\n\t\tMake sure that default parameters from osinfo do not override user-\n\t\tprovided parameters.\n\t\t\"\"\"\n\t\tgraphics = {'type': 'vnc', 'listen': '127.0.0.1'}\n\t\targs = {'name': 'test', 'os_distro': 'opensuse', 'os_version': '12.3',\n\t\t\t\t'cpus': 2, 'memory': 2048, 'networks': ['foo'],\n\t\t\t\t'cdrom': self.iso, 'graphics': graphics}\n\t\tt = VMTemplate(args)\n\t\tself.assertEquals(2, t.info.get('cpus'))\n\t\tself.assertEquals(2048, t.info.get('memory'))\n\t\tself.assertEquals(['foo'], t.info.get('networks'))\n\t\tself.assertEquals(self.iso, t.info.get('cdrom'))\n\t\tself.assertEquals(graphics, t.info.get('graphics'))\n", "description": "\n\t\tMake sure that default parameters from osinfo do not override user-\n\t\tprovided parameters.\n\t\t", "category": "graphics", "imports": ["import os", "import unittest", "import uuid", "from wok.xmlutils.utils import xpath_get_text", "from wok.plugins.kimchi.osinfo import get_template_default", "from wok.plugins.kimchi.vmtemplate import VMTemplate"]}], [], [{"term": "def", "name": "main", "data": "def main():\n\t# \u4f7f\u7528\u8005\u9ede\u64ca\u4ecb\u9762\n\t# \u9ede\u64ca\u958b\u59cb\u4f7fgraphics.game == True\uff0c\u57f7\u884cmajor_playing\n\t# graphics.game_not_over = False\n\n\tmajor_playing()\n\t# \u7d50\u675f\u5f8c\uff0c\u9032\u884c\u6392\u540d\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics_ext import BreakoutGraphics"]}, {"term": "def", "name": "major_playing", "data": "def major_playing():\n\t# \u8a2d\u5b9a\u904a\u6232\u4ecb\u9762\n\tgraphics.brick_setting()\n\tgraphics.window.add(graphics.paddle,\n\t\t\t\t\t\tx=(graphics.window_width - graphics.paddle.width) // 2,\n\t\t\t\t\t\ty=graphics.window_height - graphics.paddle_offset)\n\tgraphics.window.add(graphics.brick_number_show,\n\t\t\t\t\t\tx=10,\n\t\t\t\t\t\ty=graphics.window.height - 5)\n\tgraphics.window.add(graphics.ball_number_count_show,\n\t\t\t\t\t\tx=100,\n\t\t\t\t\t\ty=graphics.window.height - 5)\n\tgraphics.window.add(graphics.show,\n\t\t\t\t\t\tx=graphics.window.width - 75,\n\t\t\t\t\t\ty=graphics.window.height - 5)\n\t# \u9ede\u64ca\u5f8c\u958b\u59cb\u904a\u6232\n\twhile graphics.live > 0:\n\t\t# \u51fa\u73fe\u9ede\u64ca\u63d0\u793a\n\t\tif graphics.click_suggest:\n\t\t\tgraphics.window.add(graphics.click_sug, x=graphics.window.width / 2 - 40,\n\t\t\t\t\t\t\t\ty=graphics.window.height / 2)\n\t\t\tgraphics.click_suggest = False\n\t\tpause(FRAME_RATE)\n\t\tif graphics.game:\n\t\t\tball_playing(graphics.basic_ball)\n\tgraphics.game_not_over = False\n\t# \u65b9\u584a\u70ba0\u904a\u6232\u7d50\u675f\n\tif graphics.brick_number == 0:\n\t\tgraphics.window.add(graphics.win, x=graphics.window.width / 2 - 40, y=graphics.window.height / 2)\n\telse:\n\t\tgraphics.window.add(graphics.lose, x=graphics.window.width / 2 - 40, y=graphics.window.height / 2)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics_ext import BreakoutGraphics"]}, {"term": "def", "name": "ball_playing", "data": "def ball_playing(ball_label):\n\tbounce_check = True\n\twhile True:\n\t\tgraphics.dropping_item()\t\t\t\t\t\t\t\t\t\t\t\t\t# \u6253\u7834\u78da\u584a\u6642\u7269\u54c1\u6389\u843d\n\t\tif graphics.drop_item_function(graphics.drop_1):\t\t\t\t\t\t  # \u7576\u6389\u843d\u72691\u78b0\u5230pandle\uff0c\u8b93\u7403\u8b8a\u984f\u8272\n\t\t\tgraphics.window.remove(graphics.drop_1)\n\t\t\tball_label.fill_color = \"blue\"\n\t\tif graphics.drop_item_function(graphics.drop_2):\t\t\t\t\t\t  # \u7576\u6389\u843d\u72692\u78b0\u5230pandle\uff0c\u52a0\u4e00\u9846\u7403\n\t\t\tgraphics.window.remove(graphics.drop_2)\n\t\t\tgraphics.window.add(graphics.bounce_ball,\n\t\t\t\t\t\t\t\tx=graphics.paddle.x + (graphics.paddle.width - graphics.bounce_ball.width) // 2,\n\t\t\t\t\t\t\t\ty=graphics.paddle.y - graphics.bounce_ball.height)\n\t\t\tif bounce_check:\n\t\t\t\tgraphics.ball_number_count += 1\t\t\t\t\t\t\t\t # \u6aaf\u9762\u4e0a\u7403\u6578+1\n\t\t\t\tgraphics.ball_number_count_show.text = f\"Ball number:{graphics.ball_number_count}\"\n\t\t\t\tbounce_check = False\t\t\t\t\t\t\t\t\t\t\t\t   # \u78ba\u4fdd\u4e0d\u6703\u91cd\u8907\u8a08\u7b97\n\t\tfor i in (graphics.drop_3, graphics.drop_4, graphics.drop_5,):\n\t\t\tif graphics.drop_item_function(i):\t\t\t\t\t\t\t\t  # \u7576\u6389\u843d\u72693\u78b0\u5230pandle\uff0c\u767c\u5c04\n\t\t\t\tgraphics.window.remove(i)\n\t\t\t\tgraphics.window.add(graphics.strong_doggy,\n\t\t\t\t\t\t\t\t\tx=graphics.paddle.x + (graphics.paddle.width - graphics.strong_doggy.width) // 2,\n\t\t\t\t\t\t\t\t\ty=graphics.paddle.y - graphics.strong_doggy.height)\n\n\t\t# \u5206\u5225\u5f97\u5230\u7403\u7684\u6c34\u5e73 & \u5782\u76f4\u901f\u5ea6\n\t\tglobal vx\n\t\tglobal vy\n\t\tball_label.move(vx, vy)\n\t\tpause(FRAME_RATE)\n\t\tgraphics.bounce_ball_playing(graphics.bounce_ball)\t\t\t\t\t\t\t  # \u547c\u53ebbounce_ball_playing\n\t\tgraphics.strong_ball(graphics.strong_doggy)\n\t\tgraphics.dropping_item()\t\t\t\t\t\t\t\t\t\t\t\t\t\t# \u6253\u7834\u78da\u584a\u6642\u7269\u54c1\u6389\u843d\n\t\tspeed_change(ball_label)\t\t\t\t\t\t\t\t\t\t\t\t\t\t# \u6539\u8b8a\u7403\u7684\u65b9\u5411\n\t\tif graphics.ball_on_pandle(ball_label):\t\t\t\t\t\t\t\t\t\t # \u7576\u7403\u63a5\u89f8pandle\u6642\n\t\t\tif vy > 0:\n\t\t\t\tvy = -vy\n\t\tif graphics.ball_touch_point(ball_label):\t\t\t\t# \u78b0\u649e\u7522\u751f\u53cd\u5f48\n\t\t\tvy = -vy\n\t\tif graphics.brick_number == 0:\t\t\t\t\t\t  # \u7576\u78da\u584a\u6578\u91cf\u70ba0\u6642\u7684\n\t\t\tgraphics.live = 0\t\t\t\t\t\t\t\t   # \u4f7f\u751f\u547d\u70ba0\u4e26\u7d50\u675f\u904a\u6232\n\t\t\tbreak\t\t\t\t\t\t\t\t\t\t\t   # break\u8ff4\u5708\n\n\t\tif ball_label.y > graphics.window.height:\n\t\t\tif graphics.basic_ball_count_state == 0:\t\t\t# \u7576basic ball state\u72c0\u614b\u70ba0\u6642\n\t\t\t\tgraphics.basic_ball_count_state = 1\t\t\t # \u5148\u8b93basic ball state = 1\n\t\t\t\tgraphics.window.remove(ball_label)\n\t\t\t\tgraphics.ball_number_count -= 1\t\t\t\t # \u6aaf\u9762\u4e0a\u7403\u6578-1\n\t\t\t\tgraphics.ball_number_count_show.text = f\"Ball number:{graphics.ball_number_count}\"\n\t\t\t\tgraphics.basic_ball_count_state = 2\t\t\t # \u6700\u5f8c\u8b93basic ball state = 2\n\t\tif graphics.ball_number_count <= 0:\t\t\t\t\t # \u6aaf\u9762\u4e0a\u7403\u6578\u70ba0\u6642\uff0c\u751f\u547d\u503c-1\n\t\t\tgraphics.live -= 1\n\t\t\t# dropping_remove()\t\t\t\t\t\t\t\t   # \u79fb\u9664\u6240\u6709\u6389\u843d\u7269\n\t\t\tgraphics.check = True\t\t\t\t\t\t\t   # \u4f7f\u53ef\u63a5\u53d7\u4e0b\u4e00\u8f2a\u904a\u6232\n\t\t\tgraphics.game = False\t\t\t\t\t\t\t   # \u4f7f\u672c\u8f2a\u904a\u6232\u7d42\u6b62\n\t\t\tgraphics.click_suggest = True\t\t\t\t\t   # \u9ede\u64ca\u63d0\u793a\u6253\u958b\n\t\t\tgraphics.show.text = f\"live left: {graphics.live}\"\n\t\t\tbreak\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics_ext import BreakoutGraphics"]}, {"term": "def", "name": "speed_change", "data": "def speed_change(ball_label):\n\tglobal vx\n\tglobal vy\n\tif ball_label.x <= 0 or ball_label.x >= graphics.window.width - ball_label.width:\n\t\tvx = -vx\n\tif ball_label.y <= 0:\n\t\tvy = -vy\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics_ext import BreakoutGraphics"]}, {"term": "def", "name": "dropping_remove", "data": "def dropping_remove():\n\tgraphics.window.remove(graphics.drop_1)\n\tgraphics.window.remove(graphics.drop_2)\n\tgraphics.window.remove(graphics.drop_3)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics_ext import BreakoutGraphics"]}], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis widget is an easy starting point for generating multi-panel figures.\n\tExample::\n\t\n\t\tw = pg.GraphicsLayoutWidget()\n\t\tp1 = w.addPlot(row=0, col=0)\n\t\tp2 = w.addPlot(row=0, col=1)\n\t\tv = w.addViewBox(row=1, col=0, colspan=2)\n\t\n\t=========  =================================================================\n\tparent\t (QWidget or None) The parent widget.\n\tshow\t   (bool) If True, then immediately show the widget after it is\n\t\t\t   created. If the widget has no parent, then it will be shown\n\t\t\t   inside a new window.\n\tsize\t   (width, height) tuple. Optionally resize the widget. Note: if\n\t\t\t   this widget is placed inside a layout, then this argument has no\n\t\t\t   effect.\n\ttitle\t  (str or None) If specified, then set the window title for this\n\t\t\t   widget.\n\tkargs\t  All extra arguments are passed to\n\t\t\t   :meth:`GraphicsLayout.__init__\n\t\t\t   `\n\t=========  =================================================================\n\t\t\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, show=False, size=None, title=None, **kargs):\n\t\tmkQApp()\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n\t\t\n\t\tif size is not None:\n\t\t\tself.resize(*size)\n\t\t\t\n\t\tif title is not None:\n\t\t\tself.setWindowTitle(title)\n\t\t\t\n\t\tif show is True:\n\t\t\tself.show()\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis widget is an easy starting point for generating multi-panel figures.\n\tExample::\n\t\n\t\tw = pg.GraphicsLayoutWidget()\n\t\tp1 = w.addPlot(row=0, col=0)\n\t\tp2 = w.addPlot(row=0, col=1)\n\t\tv = w.addViewBox(row=1, col=0, colspan=2)\n\t\n\t=========  =================================================================\n\tparent\t (QWidget or None) The parent widget.\n\tshow\t   (bool) If True, then immediately show the widget after it is\n\t\t\t   created. If the widget has no parent, then it will be shown\n\t\t\t   inside a new window.\n\tsize\t   (width, height) tuple. Optionally resize the widget. Note: if\n\t\t\t   this widget is placed inside a layout, then this argument has no\n\t\t\t   effect.\n\ttitle\t  (str or None) If specified, then set the window title for this\n\t\t\t   widget.\n\tkargs\t  All extra arguments are passed to\n\t\t\t   :meth:`GraphicsLayout.__init__\n\t\t\t   `\n\t=========  =================================================================\n\t\t\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import mkQApp", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [{"term": "def", "name": "main", "data": "def main():\n\t\"\"\"\n\t\u65b0\u589e\u529f\u80fd\uff1a\n\t\t1.\u78da\u584a\u8d8a\u6df1\u9700\u8981\u8d8a\u591a\u6b21\u624d\u80fd\u6253\u6389\n\t\t2.\u78b0\u5230\u78da\u584a\u6703\u4f7f\u78da\u584a\u984f\u8272\u8b8a\u6dfa\n\t\t3.\u4e0d\u540c\u984f\u8272\u7684\u78da\u584a\u96a8\u6a5f\u64fa\u653e\n\t\t4.\u6253\u5230\u78da\u584a\u8207\u6253\u6389\u78da\u584a\u5206\u6578\u4e0d\u4e00\u6a23\n\t\t5.\u56e0\u70ba\u6b7b\u6389\u6b21\u6578\u7684\u4e0d\u540c\u6703\u7d66\u4e88\u5206\u6578\u52a0\u6210\n\t\t6.\u96a8\u8457\u5206\u6578\u8d8a\u9ad8\u8d8a\u9ad8\u904a\u6232\u901f\u5ea6\u6703\u52a0\u5feb\n\t\t7.\u6389\u6771\u897f\u7684\u90e8\u5206\u5c1a\u672a\u5beb\u5b8c\uff0c\u56e0\u70ba\u6642\u9593\u7684\u95dc\u4fc2\u5148\u4ea4\n\t\"\"\"\n\tgraphics = BreakoutGraphics(num_lives=NUM_LIVES)\n\twhile not graphics.game_start():\t\t\t\t\t\t# \u9ede\u64ca\u555f\u52d5\u7684\u958b\u95dc\n\t\tpause(FRAME_RATE)\n\n\tdx, dy = graphics.get_speed()\t\t\t\t\t\t   # \u901f\u5ea6\n\tdeath_times = 0\n\twin = graphics.brick_rows*graphics.brick_cols\t\t# \u5168\u90e8\u78da\u584a\u6253\u5b8c\u7684\u5206\u6578\n\tfalling_obj_l = None\n\tsorted\n\n\t# Add animation loop here!\n\twhile death_times < NUM_LIVES and graphics.brick_break_times < win:\n\n\t\t# \u79fb\u52d5\n\t\tgraphics.ball.move(dx, dy)\n\t\ttry:\n\t\t\tfalling_obj_l.move(0, FALLING_OBJ_SPEED)\n\t\t\tif graphics.obj_hit_paddle(falling_obj_l):\n\t\t\t\tgraphics.lengthen_paddle()\n\t\t\t\tgraphics.window.remove(falling_obj_l)\n\t\t\telif falling_obj_l.y >= graphics.window.height-falling_obj_l.height:\n\t\t\t\tgraphics.window.remove(falling_obj_l)\n\t\texcept UnboundLocalError:\n\t\t\tpass\n\n\t\t# \u5224\u65b7\u689d\u4ef6\n\t\tif graphics.hit_block(death_times):\t\t\t\t\t\t\t# \u6253\u5230\u78da\u584a\n\t\t\tdx, dy = graphics.get_speed()\n\t\t\tgraphics.score_board.text = f\"Score : {graphics.score}\"\n\t\t\tif graphics.brick_break:\n\t\t\t\ttry:\n\t\t\t\t\tif falling_obj_l is not None:\n\t\t\t\t\t\tpass\n\t\t\t\texcept UnboundLocalError:\n\t\t\t\t\tfalling_obj_l = graphics.falling_obj_lengthen(graphics.the_brick_x, graphics.the_brick_y)\n\t\tif graphics.ball.x <= 0 or graphics.ball.x >= graphics.window.width-graphics.ball.width:\t# \u6253\u5230\u5de6\u53f3\u7246\u58c1\n\t\t\tgraphics.rebound_x()\n\t\t\tdx, dy = graphics.get_speed()\n\t\tif graphics.hit_paddle():\t\t\t\t\t\t   # \u6253\u5230paddle\n\t\t\tif dy > 0:\t\t\t\t\t\t\t\t\t  # \u78ba\u4fdd\u7403\u4e0d\u6703\u5361\u5728paddle\u4e2d\n\t\t\t\tgraphics.rebound_y()\n\t\t\t\tdx, dy = graphics.get_speed()\n\t\t\telse:\n\t\t\t\tpass\n\t\telif graphics.ball.y <= 0:\t\t\t\t\t\t  # \u6253\u5230\u6700\u4e0a\u9762\n\t\t\tgraphics.rebound_y()\n\t\t\tdx, dy = graphics.get_speed()\n\t\telif graphics.ball.y >= graphics.window.height-graphics.ball.height:\t\t   # \u6253\u5230\u6700\u4e0b\u9762\u800c\u6b7b\u4ea1\n\t\t\tgraphics.reset_ball_position()\n\t\t\tdx, dy = graphics.get_speed()\n\t\t\tdeath_times += 1\n\t\t\tpause(FRAME_RATE*120)\t\t\t\t\t\t   # \u4f7f\u6b7b\u4ea1\u5f8c\u80fd\u66ab\u505c\u4e00\u4e0b\u518d\u958b\u59cb\n\t\tgraphics.new_ball_speed()  # \u96a8\u8457\u5206\u6578\u589e\u52a0\u901f\u5ea6\n\n\n\n\t\t# \u57f7\u884c\u66ab\u505c\n\t\tpause(FRAME_RATE)\n\n\t# \u5370\u51fa\u7d50\u675f\u5b57\u6a23\n\tif death_times == NUM_LIVES:\n\t\tfinal_label = GLabel(\"You Lose! \u00af\\_(\u30c4)_/\u00af\")\n\telse:\n\t\tfinal_label = GLabel(\"You Win! \u00af\\_(\u30c4)_/\u00af\")\n\tfinal_label.color = \"navy\"\n\tfinal_label.font = \"Comic Sans MS-40\"\n\tgraphics.window.remove(graphics.ball)\n\tgraphics.window.add(final_label, (graphics.window.width-final_label.width)/2, (graphics.window.height-final_label.height)/2+60)\n\n", "description": "\n\t\u65b0\u589e\u529f\u80fd\uff1a\n\t\t1.\u78da\u584a\u8d8a\u6df1\u9700\u8981\u8d8a\u591a\u6b21\u624d\u80fd\u6253\u6389\n\t\t2.\u78b0\u5230\u78da\u584a\u6703\u4f7f\u78da\u584a\u984f\u8272\u8b8a\u6dfa\n\t\t3.\u4e0d\u540c\u984f\u8272\u7684\u78da\u584a\u96a8\u6a5f\u64fa\u653e\n\t\t4.\u6253\u5230\u78da\u584a\u8207\u6253\u6389\u78da\u584a\u5206\u6578\u4e0d\u4e00\u6a23\n\t\t5.\u56e0\u70ba\u6b7b\u6389\u6b21\u6578\u7684\u4e0d\u540c\u6703\u7d66\u4e88\u5206\u6578\u52a0\u6210\n\t\t6.\u96a8\u8457\u5206\u6578\u8d8a\u9ad8\u8d8a\u9ad8\u904a\u6232\u901f\u5ea6\u6703\u52a0\u5feb\n\t\t7.\u6389\u6771\u897f\u7684\u90e8\u5206\u5c1a\u672a\u5beb\u5b8c\uff0c\u56e0\u70ba\u6642\u9593\u7684\u95dc\u4fc2\u5148\u4ea4\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics_extend import BreakoutGraphics", "from campy.graphics.gobjects import GLabel"]}], [{"term": "class", "name": "classAnimationPlayer:\r", "data": "class AnimationPlayer:\r\n\tdef __init__(self):\r\n\t\tself.frames = {\r\n\t\t\t# magic\r\n\t\t\t\"flame\": import_folder(\"./graphics/particles/flame/frames\"),\r\n\t\t\t\"aura\": import_folder(\"./graphics/particles/aura\"),\r\n\t\t\t\"heal\": import_folder(\"./graphics/particles/heal/frames\"),\r\n\t\t\t# attacks\r\n\t\t\t\"claw\": import_folder(\"./graphics/particles/claw\"),\r\n\t\t\t\"slash\": import_folder(\"./graphics/particles/slash\"),\r\n\t\t\t\"sparkle\": import_folder(\"./graphics/particles/sparkle\"),\r\n\t\t\t\"leaf_attack\": import_folder(\"./graphics/particles/leaf_attack\"),\r\n\t\t\t\"thunder\": import_folder(\"./graphics/particles/thunder\"),\r\n\t\t\t# Monster Deaths\r\n\t\t\t\"squid\": import_folder(\"./graphics/particles/smoke_orange\"),\r\n\t\t\t\"raccoon\": import_folder(\"./graphics/particles/raccoon\"),\r\n\t\t\t\"spirit\": import_folder(\"./graphics/particles/nova\"),\r\n\t\t\t\"bamboo\": import_folder(\"./graphics/particles/bamboo\"),\r\n\t\t\t# leafs\r\n\t\t\t\"leaf\": (\r\n\t\t\t\timport_folder(\"./graphics/particles/leaf1\"),\r\n\t\t\t\timport_folder(\"./graphics/particles/leaf2\"),\r\n\t\t\t\timport_folder(\"./graphics/particles/leaf3\"),\r\n\t\t\t\timport_folder(\"./graphics/particles/leaf4\"),\r\n\t\t\t\timport_folder(\"./graphics/particles/leaf5\"),\r\n\t\t\t\timport_folder(\"./graphics/particles/leaf6\"),\r\n\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf1\")),\r\n\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf2\")),\r\n\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf3\")),\r\n\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf4\")),\r\n\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf5\")),\r\n\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf6\")),\r\n\t\t\t),\r\n\t\t}\r\n\r\n\tdef reflect_images(self, frames):\r\n\t\tnew_frames = []\r\n\t\tfor frame in frames:\r\n\t\t\tflipped_frame = pygame.transform.flip(frame, True, False)\r\n\t\t\tnew_frames.append(flipped_frame)\r\n\r\n\t\treturn new_frames\r\n\r\n\tdef create_grass_particles(self, pos, groups):\r\n\t\tanimation_frames = choice(self.frames[\"leaf\"])\r\n\t\tParticleEffect(pos, animation_frames, groups)\r\n\r\n\tdef create_particles(self, animation_type, pos, groups):\r\n\t\tanimation_frames = self.frames[animation_type]\r\n\t\tParticleEffect(pos, animation_frames, groups)\r\n\r\n", "description": null, "category": "graphics", "imports": ["import pygame\r", "from support import import_folder\r", "from random import choice\r", "\t\t\t\"flame\": import_folder(\"./graphics/particles/flame/frames\"),\r", "\t\t\t\"aura\": import_folder(\"./graphics/particles/aura\"),\r", "\t\t\t\"heal\": import_folder(\"./graphics/particles/heal/frames\"),\r", "\t\t\t\"claw\": import_folder(\"./graphics/particles/claw\"),\r", "\t\t\t\"slash\": import_folder(\"./graphics/particles/slash\"),\r", "\t\t\t\"sparkle\": import_folder(\"./graphics/particles/sparkle\"),\r", "\t\t\t\"leaf_attack\": import_folder(\"./graphics/particles/leaf_attack\"),\r", "\t\t\t\"thunder\": import_folder(\"./graphics/particles/thunder\"),\r", "\t\t\t\"squid\": import_folder(\"./graphics/particles/smoke_orange\"),\r", "\t\t\t\"raccoon\": import_folder(\"./graphics/particles/raccoon\"),\r", "\t\t\t\"spirit\": import_folder(\"./graphics/particles/nova\"),\r", "\t\t\t\"bamboo\": import_folder(\"./graphics/particles/bamboo\"),\r", "\t\t\t\timport_folder(\"./graphics/particles/leaf1\"),\r", "\t\t\t\timport_folder(\"./graphics/particles/leaf2\"),\r", "\t\t\t\timport_folder(\"./graphics/particles/leaf3\"),\r", "\t\t\t\timport_folder(\"./graphics/particles/leaf4\"),\r", "\t\t\t\timport_folder(\"./graphics/particles/leaf5\"),\r", "\t\t\t\timport_folder(\"./graphics/particles/leaf6\"),\r", "\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf1\")),\r", "\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf2\")),\r", "\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf3\")),\r", "\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf4\")),\r", "\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf5\")),\r", "\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf6\")),\r"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\r\n\tdef __init__(self, pos, animation_frames, groups):\r\n\t\tsuper().__init__(groups)\r\n\t\tself.sprite_type = 'magic'\r\n\t\tself.frame_index = 0\r\n\t\tself.animation_speed = 0.15\r\n\t\tself.frames = animation_frames\r\n\t\tself.image = self.frames[self.frame_index]\r\n\t\tself.rect = self.image.get_rect(center=pos)\r\n\r\n\tdef animate(self):\r\n\t\tself.frame_index += self.animation_speed\r\n\r\n\t\tif self.frame_index >= len(self.frames):\r\n\t\t\tself.kill()\r\n\t\telse:\r\n\t\t\tself.image = self.frames[int(self.frame_index)]\r\n\r\n\tdef update(self):\r\n\t\tself.animate()\r\n", "description": null, "category": "graphics", "imports": ["import pygame\r", "from support import import_folder\r", "from random import choice\r", "\t\t\t\"flame\": import_folder(\"./graphics/particles/flame/frames\"),\r", "\t\t\t\"aura\": import_folder(\"./graphics/particles/aura\"),\r", "\t\t\t\"heal\": import_folder(\"./graphics/particles/heal/frames\"),\r", "\t\t\t\"claw\": import_folder(\"./graphics/particles/claw\"),\r", "\t\t\t\"slash\": import_folder(\"./graphics/particles/slash\"),\r", "\t\t\t\"sparkle\": import_folder(\"./graphics/particles/sparkle\"),\r", "\t\t\t\"leaf_attack\": import_folder(\"./graphics/particles/leaf_attack\"),\r", "\t\t\t\"thunder\": import_folder(\"./graphics/particles/thunder\"),\r", "\t\t\t\"squid\": import_folder(\"./graphics/particles/smoke_orange\"),\r", "\t\t\t\"raccoon\": import_folder(\"./graphics/particles/raccoon\"),\r", "\t\t\t\"spirit\": import_folder(\"./graphics/particles/nova\"),\r", "\t\t\t\"bamboo\": import_folder(\"./graphics/particles/bamboo\"),\r", "\t\t\t\timport_folder(\"./graphics/particles/leaf1\"),\r", "\t\t\t\timport_folder(\"./graphics/particles/leaf2\"),\r", "\t\t\t\timport_folder(\"./graphics/particles/leaf3\"),\r", "\t\t\t\timport_folder(\"./graphics/particles/leaf4\"),\r", "\t\t\t\timport_folder(\"./graphics/particles/leaf5\"),\r", "\t\t\t\timport_folder(\"./graphics/particles/leaf6\"),\r", "\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf1\")),\r", "\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf2\")),\r", "\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf3\")),\r", "\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf4\")),\r", "\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf5\")),\r", "\t\t\t\tself.reflect_images(import_folder(\"./graphics/particles/leaf6\")),\r"]}], [], [], [], [], [{"term": "def", "name": "main", "data": "def main():\n\tonmouseclicked(start_move_ball)\n\tgraphics.window.add(score_label, 0, score_label.height+10)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.gui.events.mouse import onmousemoved,onmouseclicked,onmousedragged", "from campy.graphics.gobjects import GLabel", "import random"]}, {"term": "def", "name": "start_move_ball", "data": "def start_move_ball(event):\n\tglobal count\n\twhile 0 <= event.x <= graphics.window.width and 0 <= event.y <= graphics.window.height \\\n\t\t\tand count < graphics.brick_amount and not graphics.no_restart and graphics.life >= 0:\n\t\tpause(FRAME_RATE)\n\t\tgraphics.ball.move(graphics.get_dx(), graphics.get_dy())\n\t\tobj1 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y)\n\t\tobj2 = graphics.window.get_object_at(graphics.ball.x + graphics.ball.width, graphics.ball.y)\n\t\tobj3 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y + graphics.ball.height)\n\t\tobj4 = graphics.window.get_object_at(graphics.ball.x + graphics.ball.width,\n\t\t\t\t\t\t\t\t\t\t\t graphics.ball.y + graphics.ball.height)\n\t\tif obj1 is not None:\n\t\t\tif obj1 is not graphics.paddle and obj1 is not score_label:\n\t\t\t\tgraphics.remove_brick(obj1)\n\t\t\t\tcount += 1\n\t\t\t\tscore_label.text = 'Score: ' + str(count)\n\t\t\telif obj1 is graphics.paddle and obj1 is not score_label and graphics.ball_touch_paddle_check:\n\t\t\t\tgraphics.bouncing_dy()\n\t\t\t\tgraphics.ball_touch_paddle_check = False\n\t\t\tif graphics.ball.y >= graphics.window.height/2:\n\t\t\t\tgraphics.ball_touch_paddle_check = True\n\n\t\telif obj2 is not None:\n\t\t\tif obj2 is not graphics.paddle and obj2 is not score_label:\n\t\t\t\tgraphics.remove_brick(obj2)\n\t\t\t\tcount += 1\n\t\t\t\tscore_label.text = 'Score: ' + str(count)\n\t\t\telif obj2 is graphics.paddle and obj2 is not score_label:\n\t\t\t\tgraphics.bouncing_dy()\n\t\t\t\tgraphics.ball_touch_paddle_check = False\n\t\t\tif graphics.ball.y >= graphics.window.height / 2:\n\t\t\t\tgraphics.ball_touch_paddle_check = True\n\n\t\telif obj3 is not None:\n\t\t\tif obj3 is not graphics.paddle and obj3 is not score_label:\n\t\t\t\tgraphics.remove_brick(obj3)\n\t\t\t\tcount += 1\n\t\t\t\tscore_label.text = 'Score: ' + str(count)\n\t\t\telif obj3 is graphics.paddle and obj3 is not score_label:\n\t\t\t\tgraphics.bouncing_dy()\n\t\t\t\tgraphics.ball_touch_paddle_check = False\n\t\t\tif graphics.ball.y >= graphics.window.height / 2:\n\t\t\t\tgraphics.ball_touch_paddle_check = True\n\n\t\telif obj4 is not None:\n\t\t\tif obj4 is not graphics.paddle and obj4 is not score_label:\n\t\t\t\tgraphics.remove_brick(obj4)\n\t\t\t\tcount += 1\n\t\t\t\tscore_label.text = 'Score: ' + str(count)\n\t\t\telif obj4 is graphics.paddle and obj4 is not score_label:\n\t\t\t\tgraphics.bouncing_dy()\n\t\t\t\tgraphics.ball_touch_paddle_check = False\n\t\t\tif graphics.ball.y >= graphics.window.height / 2:\n\t\t\t\tgraphics.ball_touch_paddle_check = True\n\n\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\t\tgraphics.bouncing_dx()\n\t\tif graphics.ball.y <= 0:\n\t\t\tgraphics.bouncing_dy()\n\t\tif count == graphics.brick_amount:\n\t\t\tgraphics.finish_game()\n\t\t\tgraphics.remove_ball_paddle()\n\t\tif graphics.ball_outside_window():\n\t\t\tgraphics.life -= 1\n\t\t\tgraphics.set_ball_position()\n\t\t\tif graphics.life <= 0:\n\t\t\t\tgraphics.game_over()\n\t\t\t\tgraphics.no_restart = True\n\t\t\tbreak\n\n\n\n\n\t# return life\n\n\n\n\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.gui.events.mouse import onmousemoved,onmouseclicked,onmousedragged", "from campy.graphics.gobjects import GLabel", "import random"]}], [{"term": "def", "name": "main", "data": "def main():\n\t\"\"\"\n\tThis program create breakout game.\n\t\"\"\"\n\tglobal score\n\tgraphics = BreakoutGraphics()\n\tscore_label.font = '-20'\n\tgraphics.window.add(score_label, x=0, y=graphics.window.height)\n\tlives = NUM_LIVES\n\n\t# Add the animation loop here!\n\twhile True:\n\t\tpause(FRAME_RATE)\n\t\tvx = graphics.ball_x()\t# Ball moving x velocity.\n\t\tvy = graphics.ball_y()\t# Ball moving y velocity.\n\t\tif graphics.start:\n\t\t\tgraphics.ball.move(vx, vy)\n\n\t\t\t# Find object while ball touched.\n\t\t\tobj1 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y)\n\t\t\tobj2 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y+graphics.ball.width)\n\t\t\tobj3 = graphics.window.get_object_at(graphics.ball.x+graphics.ball.height, graphics.ball.y)\n\t\t\tobj4 = graphics.window.get_object_at(graphics.ball.x+graphics.ball.height,\n\t\t\t\t\t\t\t\t\t\t\t\t graphics.ball.y+graphics.ball.width)\n\n\t\t\t# Check the ball four corners.\n\t\t\t# Top left corner.\n\t\t\tif obj1 is not None:\t\t\t\t   # When ball touching an object.\n\t\t\t\tif obj1 is not graphics.paddle and obj1 is not score_label:\t\t# Ball touching brick.\n\t\t\t\t\tgraphics.window.remove(obj1)\n\t\t\t\t\t# vy = graphics.bounce_y()\n\t\t\t\t\tgraphics.bounce_y()\n\t\t\t\t\tscore += 1\n\t\t\t\t\tscore_label.text = 'Score: ' + str(score)\n\t\t\t\telif obj1 == graphics.paddle and not graphics.touch_paddle:  # While ball touching paddle.\n\t\t\t\t\t# vy = graphics.bounce_y()\n\t\t\t\t\tgraphics.bounce_y()\n\t\t\t\t\tgraphics.touch_paddle = True  # This check point prevent ball touch paddle continuously.\n\t\t\t\tif graphics.ball.y + graphics.ball.height < graphics.paddle.y:\n\t\t\t\t\tgraphics.touch_paddle = False\n\n\t\t\t# Bottom left corner.\n\t\t\telif obj2 is not None:\n\t\t\t\tif obj2 is not graphics.paddle and obj2 is not score_label:\n\t\t\t\t\tgraphics.window.remove(obj2)\n\t\t\t\t\t# vy = graphics.bounce_y()\n\t\t\t\t\tgraphics.bounce_y()\n\t\t\t\t\tscore += 1\n\t\t\t\t\tscore_label.text = 'Score: ' + str(score)\n\t\t\t\telif obj2 == graphics.paddle and not graphics.touch_paddle:\n\t\t\t\t\t# vy = graphics.bounce_y()\n\t\t\t\t\tgraphics.bounce_y()\n\t\t\t\t\tgraphics.touch_paddle = True\n\t\t\t\tif graphics.ball.y + graphics.ball.height < graphics.paddle.y:\n\t\t\t\t\tgraphics.touch_paddle = False\n\n\t\t\t# Top right corner.\n\t\t\telif obj3 is not None:\n\t\t\t\tif obj3 is not graphics.paddle and obj3 is not score_label:\n\t\t\t\t\tgraphics.window.remove(obj3)\n\t\t\t\t\t# vy = graphics.bounce_y()\n\t\t\t\t\tgraphics.bounce_y()\n\t\t\t\t\tscore += 1\n\t\t\t\t\tscore_label.text = 'Score: ' + str(score)\n\t\t\t\telif obj3 == graphics.paddle and not graphics.touch_paddle:\n\t\t\t\t\t# vy = graphics.bounce_y()\n\t\t\t\t\tgraphics.bounce_y()\n\t\t\t\t\tgraphics.touch_paddle = True\n\t\t\t\tif graphics.ball.y + graphics.ball.height < graphics.paddle.y:\n\t\t\t\t\tgraphics.touch_paddle = False\n\n\t\t\t# Bottom right corner.\n\t\t\telif obj4 is not None:\n\t\t\t\tif obj4 is not graphics.paddle and obj4 is not score_label:\n\t\t\t\t\tgraphics.window.remove(obj4)\n\t\t\t\t\t# vy = graphics.bounce_y()\n\t\t\t\t\tgraphics.bounce_y()\n\t\t\t\t\tscore += 1\n\t\t\t\t\tscore_label.text = 'Score: ' + str(score)\n\t\t\t\telif obj4 == graphics.paddle and not graphics.touch_paddle:\n\t\t\t\t\t# vy = graphics.bounce_y()\n\t\t\t\t\tgraphics.bounce_y()\n\t\t\t\t\tgraphics.touch_paddle = True\n\t\t\t\tif graphics.ball.y + graphics.ball.height < graphics.paddle.y:\n\t\t\t\t\tgraphics.touch_paddle = False\n\n\t\t\t# While ball touching the edge of window.\n\t\t\t# Ball touch the right and left walls.\n\t\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\t\t\t# vx = graphics.bounce_x()\n\t\t\t\tgraphics.bounce_x(-vx)\n\t\t\tif graphics.ball.y <= 0:\t  # Ball touch the top of the window.\n\t\t\t\t# vy = graphics.bounce_y()\n\t\t\t\tgraphics.bounce_y()\n\t\t\tif graphics.ball.y + graphics.ball.height >= graphics.window.height:  # Ball touch the bottom of the window.\n\t\t\t\tgraphics.reset_ball()\n\t\t\t\tgraphics.start = False\n\t\t\t\tlives -= 1\n\n\t\t\tif lives == 0:\t\t\t\t\t# There's no life to play the game.\n\t\t\t\tgraphics.game_over()\n\t\t\t\tbreak\n\n\t\t\tif score == graphics.brick_num:   # Clean all bricks.\n\t\t\t\tgraphics.break_game()\n\t\t\t\tbreak\n\n", "description": "\n\tThis program create breakout game.\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.graphics.gobjects import GLabel"]}], [], [], [], [], [{"term": "def", "name": "main", "data": "def main():\n\n\tgraphics = BreakoutGraphics()\n\t# Add animation loop here!\n\tglobal NUM_LIVES\n\n\n\twhile True:\n\n\n\t\tpause(FRAME_RATE)\n\n\t\tgraphics.ball.move(graphics.get_dx(), graphics.get_dy())\n\n\t\tif graphics.ball.y >= graphics.window.height:\n\t\t\tNUM_LIVES -= 1\n\t\t\tif NUM_LIVES == 2:\n\t\t\t\tgraphics.window.remove(graphics.live_3)\n\t\t\tif NUM_LIVES == 1:\n\t\t\t\tgraphics.window.remove(graphics.live_2)\n\n\t\t\tif NUM_LIVES > 0:\n\t\t\t\tgraphics.reset_ball()\n\t\t\t\tgraphics.reset_dx()\n\t\t\t\tgraphics.reset_dy()\n\t\t\t\tgraphics.switch = 0\n\t\t\telse:\n\t\t\t\tgraphics.window.remove(graphics.live_1)\n\t\t\t\tgraphics.window.add(graphics.label_e)\n\t\t\t\tbreak\n\n\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\t\tgraphics.change_dx()\n\n\t\tif graphics.ball.y <= 0:\n\t\t\tgraphics.change_dy()\n\n\t\tobj = graphics.object()\n\t\tif obj is not None:\n\t\t\tgraphics.b_or_p()\n\n\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "class", "name": "GeoTiledMapObjectInfo", "data": "class GeoTiledMapObjectInfo(GeoMapObjectInfo):\n\tdef __init__(self, mapData, mapObject):\n\t\tself.inited = False\n\t\tGeoMapObjectInfo.__init__(self, mapData, mapObject)\n\t\t\n\t\t\n\t\tself.updateAfterInit = False\n\t\tself.graphicsItem = None\n\t\tself.tiledMapData = mapData\n\t\t\n\t\n\tdef init(self):\n\t\tif self.graphicsItem:\n\t\t\tself.graphicsItem.setZValue(self._mapObject.zValue())\n\t\t\tself.graphicsItem.setVisible(self._mapObject.isVisible())\n\t\tself.inited = True\n\t\tif self.updateAfterInit:\n\t\t\tself.tiledMapData._updateMapDisplay()\n\t\t\tself.updateAfterInit = False\n\t\tGeoMapObjectInfo.init(self)\n\t\n\t@pyqtSlot(int)\n\tdef zValueChanged(self, zValue):\n\t\tif self.graphicsItem:\n\t\t\tself.graphicsItem.setZValue(zValue)\n\t\t\tself.updateItem()\n\t\t\tif self.tiledMapData and self.tiledMapData._oe:\n\t\t\t\tself.tiledMapData._oe.rebuildScenes()\n\t\n\t@pyqtSlot(bool)\n\tdef visibleChanged(self, visible):\n\t\tif self.graphicsItem:\n\t\t\tself.graphicsItem.setVisible(visible)\n\t\t\tself.updateItem()\n\t\n\t@pyqtSlot(GeoCoordinate)\n\tdef originChanged(self, origin):\n\t\tif self.graphicsItem:\n\t\t\tself.updateItem()\n\t\n\t@pyqtSlot(int)\n\tdef unitsChanged(self, units):\n\t\tif self.graphicsItem:\n\t\t\tself.updateItem()\n\t\n\t@pyqtSlot(int)\n\tdef transformTypeChanged(self, transformType):\n\t\tif self.graphicsItem:\n\t\t\tself.updateItem()\n\t\n\tdef boundingBox(self):\n\t\tif not self.graphicsItem or not self.tiledMapData:\n\t\t\treturn GeoBoundingBox()\n\t\t\n\t\te = self.tiledMapData._oe\n\t\t\n\t\tobj = self._mapObject\n\t\t\n\t\te.updateTransforms()\n\t\t\n\t\tif e.latLonExact.contains(obj):\n\t\t\titems = e.latLonExact.values(obj)\n\t\t\tfor item in items:\n\t\t\t\tlatLonBounds = item.boundingRect()\n\t\t\t\ttopLeft = latLonBounds.bottomLeft()\n\t\t\t\tif topLeft.x() >= 180.0 * 3600.0:\n\t\t\t\t\ttopLeft.setX(topLeft.x() - 360.0 * 3600.0)\n\t\t\t\tif (topLeft.x() < -180.0 * 3600.0):\n\t\t\t\t\ttopLeft.setX(topLeft.x() + 360.0 * 3600.0)\n\t\t\t\t\n\t\t\t\tbottomRight = latLonBounds.topRight()\n\t\t\t\tif (bottomRight.x() >= 180.0 * 3600.0):\n\t\t\t\t\tbottomRight.setX(bottomRight.x() - 360.0 * 3600.0)\n\t\t\t\tif (bottomRight.x() < -180.0 * 3600.0):\n\t\t\t\t\tbottomRight.setX(bottomRight.x() + 360.0 * 3600.0)\n\t\t\t\t\n\t\t\t\ttlc = GeoCoordinate(topLeft.y() / 3600.0, topLeft.x() / 3600.0)\n\t\t\t\tbrc = GeoCoordinate(bottomRight.y() / 3600.0, bottomRight.x() / 3600.0)\n\t\t\t\t\n\t\t\t\treturn GeoBoundingBox(tlc, brc)\n\t\t\treturn GeoBoundingBox()\n\t\telse:\n\t\t\ttrans = e.latLonTrans.value(obj)\n\t\t\tbounds = self.graphicsItem.boundingRect()\n\t\t\tpoly = bounds * trans\n\t\t\t\n\t\t\tlatLonBounds = poly.boundingRect()\n\t\t\ttopLeft = latLonBounds.bottomLeft()\n\t\t\tif (topLeft.x() >= 180.0 * 3600.0):\n\t\t\t\ttopLeft.setX(topLeft.x() - 360.0 * 3600.0)\n\t\t\tif (topLeft.x() < -180.0 * 3600.0):\n\t\t\t\ttopLeft.setX(topLeft.x() + 360.0 * 3600.0)\n\t\t\t\n\t\t\tbottomRight = latLonBounds.topRight()\n\t\t\tif (bottomRight.x() >= 180.0 * 3600.0):\n\t\t\t\tbottomRight.setX(bottomRight.x() - 360.0 * 3600.0)\n\t\t\tif (bottomRight.x() < -180.0 * 3600.0):\n\t\t\t\tbottomRight.setX(bottomRight.x() + 360.0 * 3600.0)\n\t\t\t\n\t\t\ttlc = GeoCoordinate(topLeft.y() / 3600.0, topLeft.x() / 3600.0)\n\t\t\tbrc = GeoCoordinate(bottomRight.y() / 3600.0, bottomRight.x() / 3600.0)\n\t\t\t\n\t\t\treturn GeoBoundingBox(tlc, brc)\n\t\n\tdef contains(self, coordinate):\n\t\tif not self.graphicsItem or not self.tiledMapData:\n\t\t\treturn False\n\t\t\n\t\te = self.tiledMapData._oe\n\t\t\n\t\te.updateTransforms()\n\t\tlatLonPoint = QPointF(coordinate.longitude()*3600.0, coordinate.latitude()*3600.0)\n\t\t\n\t\tobj = self._mapObject\n\t\t\n\t\tif e.latLonExact.contains(obj):\n\t\t\titems = e.latLonExact.values(obj)\n\t\t\tfor item in items:\n\t\t\t\tif item.contains(latLonPoint):\n\t\t\t\t\treturn True\n\t\telse:\n\t\t\ttransList = e.latLonTrans.values(obj)\n\t\t\tfor trans in transList:\n\t\t\t\tunused = False\n\t\t\t\tinv,ok = trans.inverted(unused)\n\t\t\t\tif not ok:\n\t\t\t\t\tcontinue\n\t\t\t\tlocalPoint = latLonPoint * inv\n\t\t\t\t\n\t\t\t\tif self.graphicsItem.contains(localPoint):\n\t\t\t\t\treturn True\n\t\treturn False\n\t\n\tdef updateItem(self, target=None):\n\t\tif target is None:\n\t\t\ttarget = QRectF()\n\t\tif not self.inited:\n\t\t\tself.updateAfterInit = True\n\t\t\treturn\n\t\t\n\t\tobj = self._mapObject\n\t\tif obj:\n\t\t\tself.tiledMapData.update(obj)\n\t\tif self.graphicsItem:\n\t\t\tself.tiledMapData.triggerUpdateMapDisplay(target)\n", "description": null, "category": "graphics", "imports": ["from PyQt4.QtCore import pyqtSignal, pyqtSlot, QPointF, QRectF ", "from ems.qt4.location.maps.geomapobjectinfo import GeoMapObjectInfo", "from ems.qt4.location.geocoordinate import GeoCoordinate #@UnresolvedImport", "from ems.qt4.location.geoboundingbox import GeoBoundingBox #@UnresolvedImport"]}], [{"term": "def", "name": "_make_graphics_inst", "data": "  def _make_graphics_inst(gconfig, system):\n\t\"\"\"\n\tCreate an instance of the graphics delegate for the user's system.\n\tAppropriate modules are defined in the app.ini then dynamically instantiated\n\t:param gconfig: the config file section for graphics\n\t:param system: the system the user is on\n\t:return: an instance of the appropriate class\n\t\"\"\"\n\tif system == 'iOS':\n\t  smod = gconfig['DefaultModulePythonista']\n\telif system == 'Windows':\n\t  smod = gconfig['DefaultModuleDesktop']\n\telse:\n\t  raise Exception('Platform not supported: [%s]' % system)\n\tlib = importlib.import_module(smod)\n\t\n\t# inspect imported module for defined classes\n\tclasses = [m[0] for m in inspect.getmembers(lib, inspect.isclass) if m[1].__module__ == smod]\n\tif len(classes) != 1:\n\t  raise Exception('A graphics delegate module should contain one, and only one, delegate class definition.')\n\t  \n\t# get class object and return a fresh instance\n\tcls = getattr(lib, classes[0])\n\treturn cls()\n", "description": "\n\tCreate an instance of the graphics delegate for the user's system.\n\tAppropriate modules are defined in the app.ini then dynamically instantiated\n\t:param gconfig: the config file section for graphics\n\t:param system: the system the user is on\n\t:return: an instance of the appropriate class\n\t", "category": "graphics", "imports": ["import platform", "import configparser", "import importlib", "import inspect", "from pythonista3d.graphics.graphics_delegate import GraphicsDelegate", "\tlib = importlib.import_module(smod)", "\t# inspect imported module for defined classes"]}, {"term": "def", "name": "get_delegate", "data": "  def get_delegate() -> \"GraphicsDelegate\":\n\t\"\"\"\n\tDetect the type of system the user is on\n\t:return: the appropriate graphics delegate\n\t\"\"\"\n\tif platform.system() == 'Darwin':  #iOS\n\t  system = 'iOS'\n\telif platform.system() == 'Windows':\n\t  system = 'Windows'\n\t\n\tconfig = configparser.ConfigParser()\n\tconfig.read(APP_INI_LOCATION)\n\tgraphics_config = config['graphics']\n\treturn GraphicsFactory._make_graphics_inst(graphics_config, system)\n\n", "description": "\n\tDetect the type of system the user is on\n\t:return: the appropriate graphics delegate\n\t", "category": "graphics", "imports": ["import platform", "import configparser", "import importlib", "import inspect", "from pythonista3d.graphics.graphics_delegate import GraphicsDelegate", "\tlib = importlib.import_module(smod)", "\t# inspect imported module for defined classes"]}], [{"term": "class", "name": "Noide1D", "data": "class Noide1D():\n\n\twidth = 0\n\toutput = []\n\tnoiseSeed = []\n\toctaves = 9\n\tscalingBias = 20.0\n\n\tdef __init__(self, width):\n\t\tself.width = width\n\t\tfor i in range(self.width):\n\t\t\tf = random.random()\n\t\t\tself.noiseSeed.append(f)\n\n\tdef generate(self):\n\t\tfor x in range(self.width):\n\t\t\tnoise = 0.0\n\t\t\tscale = 1.0\n\t\t\tscaleSum = 0.0\n\t\t\tfor o in range(self.octaves):\n\t\t\t\tpitch = self.width >> o\n\t\t\t\tsample1 = int((x / pitch) * pitch)  \t# integer division !!\n\t\t\t\tsample2 = int((sample1 + pitch) % self.width)\n\t\t\t\tblend = float(x - sample1) / float(pitch)\n\t\t\t\tsample = (1.0 - blend) * self.noiseSeed[sample1] + blend * self.noiseSeed[sample2]\n\t\t\t\tnoise = noise + sample * scale\n\t\t\t\tif x == 1:\n\t\t\t\t\tprint(o,scale)\n\t\t\t\tscaleSum = scaleSum + scale\n\t\t\t\tscale = scale / self.scalingBias\n\n\t\t\tself.output.append(noise / scaleSum)\n\n\tdef draw(self):\n\t\tfor x, n in enumerate(self.output):\n\t\t\ty = n * HEIGHT\n\t\t\tgraphics.line(x, 0, x, y, 1, WHITE)\n", "description": null, "category": "graphics", "imports": ["import queue", "import random", "import pygame ", "from Graphics import Graphics"]}, {"term": "def", "name": "run", "data": "def run():\n\tdone = False\n\tnoise = Noide1D(WIDTH)\n\tnoise.generate()\n\twhile not done:\n\t\tdone = graphics.queryQuit()\n\t\tgraphics.fill(BLACK)\n\n\t\tnoise.draw()\n\n\t\tgraphics.flip()\n\n\tgraphics.quit()\n\n", "description": null, "category": "graphics", "imports": ["import queue", "import random", "import pygame ", "from Graphics import Graphics"]}], [{"term": "def", "name": "ConstructFilenameAndPath", "data": "def ConstructFilenameAndPath():\n\tglobal gFilenameAndPath\n\tif gFilenameAndPath == \"\":\n\t\tif PtIsInternalRelease():\n\t\t\t# check for local file\n\t\t\tlocalNameAndPath = \"init/\" + gFilename\n\t\t\tif PtFileExists(localNameAndPath):\n\t\t\t\tgFilenameAndPath = localNameAndPath\n\t\t\t\tPtDebugPrint(\"xIniDisplay::ConstructFilenameAndPath(): Using internal \\\"\" + gFilenameAndPath + \"\\\" file\")\n\t\t\t\treturn\n\t\t# otherwise, use the standard init path\n\t\tgFilenameAndPath = PtGetInitPath() + \"/\" + gFilename\n\t\tPtDebugPrint(\"xIniDisplay::ConstructFilenameAndPath(): Using user-level \\\"\" + gFilenameAndPath + \"\\\" file\")\n", "description": null, "category": "graphics", "imports": ["import xIniHelper", "from Plasma import *"]}, {"term": "def", "name": "WriteIni", "data": "def WriteIni():\n\tglobal gIniFile\n\tif gIniFile:\n\t\tConstructFilenameAndPath()\n\t\tgIniFile.writeFile(gFilenameAndPath)\n", "description": null, "category": "graphics", "imports": ["import xIniHelper", "from Plasma import *"]}, {"term": "def", "name": "ReadIni", "data": "def ReadIni():\n\tglobal gIniFile\n\tConstructFilenameAndPath()\n\tgIniFile = xIniHelper.iniFile(gFilenameAndPath)\n\tif gIniFile.isEmpty():\n\t\t# add defaults\n\t\tgIniFile.addEntry(\"# This is an auto-generated file.\")\n\t\tgIniFile.addEntry(\"\\n\")\n\t\tgIniFile.addEntry(kGraphicsWidth + \" 800\")\n\t\tgIniFile.addEntry(kGraphicsHeight + \" 600\")\n\t\tgIniFile.addEntry(kGraphicsColorDepth + \" 32\")\n\t\tgIniFile.addEntry(kGraphicsWindowed + \" false\")\n\t\tgIniFile.addEntry(kGraphicsTextureQuality + \" 2\")\n\t\tgIniFile.addEntry(kGraphicsAntiAliasLevel + \" 0\")\n\t\tgIniFile.addEntry(kGraphicsAnisotropicLevel + \" 0\")\n\t\tgIniFile.addEntry(kGraphicsQualityLevel + \" 2\")\n\t\tgIniFile.addEntry(kGraphicsShadows + \" true\")\n\t\tgIniFile.addEntry(kGraphicsVerticalSync + \" false\")\n\t\tgIniFile.addEntry(kGraphicsShadowQuality + \" 0\")\n\t\tgIniFile.writeFile(gFilenameAndPath)\n\n\telse:\n\t\tiniChanged = 0\n\t\tfor idx in range(len(CmdList)):\n\t\t\tcmd = CmdList[idx]\n\t\t\tentry,idx = gIniFile.findByCommand(cmd)\n\t\t\tif not entry:\n\t\t\t\tgIniFile.addEntry(cmd + \" \" + DefaultsList[idx])\n\t\t\t\tiniChanged = 1\n\n\t\tif iniChanged:\n\t\t\tConstructFilenameAndPath()\n\t\t\tgIniFile.writeFile(gFilenameAndPath)\n", "description": null, "category": "graphics", "imports": ["import xIniHelper", "from Plasma import *"]}, {"term": "def", "name": "SetGraphicsOptions", "data": "def SetGraphicsOptions(width, heigth, colordepth, windowed, texquality, aaLevel, anisoLevel, qualityLevel, useShadows, vsync, shadowqual):\n\tif gIniFile:\n\t\tparamList = [width, heigth, colordepth, windowed, texquality, aaLevel, anisoLevel, qualityLevel, useShadows, vsync, shadowqual]\n\t\tfor idx in range(len(CmdList)):\n\t\t\tentry,junk = gIniFile.findByCommand(CmdList[idx])\n\t\t\tval = str(paramList[idx])\n\t\t\tif entry:\n\t\t\t\tentry.setValue(0, val)\n\t\t\telse:\n\t\t\t\tgIniFile.addEntry(\"%s %s\" % (CmdList[idx], val))\n", "description": null, "category": "graphics", "imports": ["import xIniHelper", "from Plasma import *"]}, {"term": "def", "name": "GetGraphicsOptions", "data": "def GetGraphicsOptions():\n\toptsList = {}\n\tif gIniFile:\n\t\tfor cmd in CmdList:\n\t\t\tentry,idx = gIniFile.findByCommand(cmd)\n\t\t\tif entry:\n\t\t\t\tvalue = entry.getValue(0)\n\t\t\t\tif value:\n\t\t\t\t\ttry:\n\t\t\t\t\t\toptsList[cmd] = int(value)\n\t\t\t\t\texcept ValueError:\n\t\t\t\t\t\toptsList[cmd] = value\n\treturn optsList\n", "description": null, "category": "graphics", "imports": ["import xIniHelper", "from Plasma import *"]}], [], [{"term": "class", "name": "SceneManager", "data": "class SceneManager(QObject):\n\n\tdef __init__(self, parent=None, storageManager=None):\n\t\tsuper(SceneManager, self).__init__(parent)\n\t\tself._scene = None\n\t\tself._widget = None\n\t\tself._tools = None\n\t\tself._storageManager = None\n\t\tself._importStorageManager = None\n\t\tself._loadAction = None\n\t\tself._saveAction = None\n\t\tself._importAction = None\n\t\tself._exportAction = None\n\t\tself._actions = []\n\t\tself._finalizers = [BackgroundCorrector(), PageItemHider()]\n\t\tif storageManager:\n\t\t\tself.setStorageManager(storageManager)\n\n\tdef actions(self):\n\t\tif not self._actions:\n\t\t\tself._populateActions()\n\t\treturn self._actions\n\n\tdef getScene(self):\n\t\tif not self._scene:\n\t\t\tself._scene = GraphicsScene()\n\t\t\tself._scene.deleteRequested.connect(self.deleteIfWanted)\n\t\treturn self._scene\n\n\tscene = pyqtProperty(GraphicsScene, getScene)\n\n\tdef getWidget(self):\n\t\tif not self._widget:\n\t\t\tself._widget = GraphicsWidget(scene=self.scene, tools=self.tools)\n\t\t\tself._addActionsToWidget(self._widget)\n\t\t\tself._widget.printPreviewRequested.connect(self.showPrintPreviewDialog)\n\t\treturn self._widget\n\n\twidget = pyqtProperty(GraphicsWidget, getWidget)\n\n\tdef getTools(self):\n\t\tif not self._tools:\n\t\t\tself._tools = self._createTools()\n\t\treturn self._tools\n\n\ttools = pyqtProperty(GraphicsTool, getTools)\n\n\tdef load(self, *args):\n\t\tif self._storageManager:\n\t\t\treturn self._storageManager.load()\n\n\tdef save(self, *args):\n\t\tif self._storageManager:\n\t\t\treturn self._storageManager.save()\n\n\tdef importScene(self, *args):\n\t\tif self._importStorageManager:\n\t\t\treturn self._importStorageManager.load()\n\n\tdef exportScene(self, *args):\n\t\tif self._importStorageManager:\n\t\t\treturn self._importStorageManager.save()\n\n\tdef getStorageManager(self):\n\t\treturn self._storageManager\n\n\t@pyqtSlot(SceneStorageManager)\n\tdef setStorageManager(self, storageManager):\n\t\tself._storageManager = storageManager\n\t\tself._storageManager.setScene(self.scene)\n\t\tself._storageManager.setTools(self.tools)\n\n\tstorageManager = pyqtProperty(SceneStorageManager, getStorageManager, setStorageManager)\n\n\tdef getImportStorageManager(self):\n\t\treturn self._importStorageManager\n\n\tdef setImportStorageManager(self, storageManager):\n\t\tself._importStorageManager = storageManager\n\t\tself._importStorageManager.setScene(self.scene)\n\t\tself._importStorageManager.setTools(self.tools)\n\n\timportStorageManager = pyqtProperty(SceneStorageManager, getImportStorageManager, setImportStorageManager)\n\n\t@property\n\tdef loadAction(self):\n\t\tif self._loadAction:\n\t\t\treturn self._loadAction\n\n\t\tself._loadAction = QAction('Load', self.getWidget(), shortcut = QKeySequence.Open)\n\t\tself._loadAction.triggered.connect(self.load)\n\t\treturn self._loadAction\n\n\t@property\n\tdef saveAction(self):\n\t\tif self._saveAction:\n\t\t\treturn self._saveAction\n\t\tself._saveAction = QAction('Save', self.getWidget(), shortcut = QKeySequence.Save)\n\t\tself._saveAction.triggered.connect(self.save)\n\t\treturn self._saveAction\n\n\t@property\n\tdef importAction(self):\n\t\tif self._importAction:\n\t\t\treturn self._importAction\n\t\tself._importAction = QAction('Import', self.getWidget())\n\t\tself._importAction.triggered.connect(self.importScene)\n\t\treturn self._importAction\n\n\t@property\n\tdef exportAction(self):\n\t\tif self._exportAction:\n\t\t\treturn self._exportAction\n\t\tself._exportAction = QAction('Export', self.getWidget())\n\t\tself._exportAction.triggered.connect(self.exportScene)\n\t\treturn self._exportAction\n\n\tdef printScene(self, printer, painter=None):\n\t\tpainter = painter if isinstance(painter, QPainter) else QPainter(printer)\n\t\tfor finalizer in self._finalizers:\n\t\t\tfinalizer.toFinalized(self.scene)\n\t\tpageItem = self._findPageItem()\n\t\tif pageItem:\n\t\t\tself.scene.render(painter, QRectF(), pageItem.boundingRect())\n\t\telse:\n\t\t\tself.scene.render(painter)\n\n\t\tfor finalizer in self._finalizers:\n\t\t\tfinalizer.toEditable(self.scene)\n\n\tdef showPrintPreviewDialog(self):\n\t\tmargin = 30\n\t\tparent = self.getWidget()\n\t\tself.printPrvDlg = QPrintPreviewDialog(parent)\n\t\tself.printPrvDlg.setWindowTitle(u'Druckvorschau')\n\t\tself.printPrvDlg.paintRequested.connect(self.printScene)\n\t\tself.printPrvDlg.resize(parent.width()-margin, parent.height()-margin)\n\t\tself.printPrvDlg.show()\n\n\tdef deleteIfWanted(self):\n\t\titems = self.scene.selectedItems()\n\t\tif not len(items):\n\t\t\treturn\n\n\t\tfor item in items:\n\t\t\tself.scene.removeItem(item)\n\n\t@accepts(Finalizer)\n\tdef addFinalizer(self, finalizer):\n\t\tself._finalizers.append(finalizer)\n\n\tdef hasFinalizer(self, finalizer):\n\t\treturn finalizer in self._finalizers\n\n\tdef finalizer(self, cls):\n\t\tfor finalizer in self._finalizers:\n\t\t\tif isinstance(finalizer, cls):\n\t\t\t\treturn finalizer\n\n\tdef _createTools(self):\n\t\ttools = GraphicsToolDispatcher(self)\n\t\ttools.setScene(self.scene)\n\t\ttextTool = TextTool()\n\t\ttools.addTool(textTool)\n\t\tpixmapTool = PixmapTool()\n\t\ttools.addTool(pixmapTool)\n\t\treturn tools\n\n\tdef _populateActions(self):\n\t\tif self._actions:\n\t\t\treturn\n\t\tself._actions.append(self.loadAction)\n\t\tself._actions.append(self.saveAction)\n\t\tself._actions.append(self.importAction)\n\t\tself._actions.append(self.exportAction)\n\n\tdef _addActionsToWidget(self, widget):\n\t\tfor action in self.actions():\n\t\t\twidget.addAction(action)\n\n\tdef _findPageItem(self):\n\t\tfor item in self.scene.items():\n\t\t\tif isinstance(item, PageItem):\n", "description": null, "category": "graphics", "imports": ["from ems.typehint import accepts", "from ems.qt.event_hook_proxy import SignalEventHookProxy", "from ems.qt import QtWidgets, QtGui, QtCore, QtPrintSupport", "from ems.qt.graphics.graphics_scene import GraphicsScene, BackgroundCorrector", "from ems.qt.graphics.graphics_widget import GraphicsWidget", "from ems.qt.graphics.storage.interfaces import SceneStorageManager", "from ems.qt.graphics.tool import GraphicsTool", "from ems.qt.graphics.tool import GraphicsToolDispatcher", "from ems.qt.graphics.text_tool import TextTool", "from ems.qt.graphics.pixmap_tool import PixmapTool", "from ems.qt.graphics.interfaces import Finalizer", "from ems.qt.graphics.page_item import PageItemHider, PageItem", "\t\tself._importStorageManager = None", "\t\tself._importAction = None", "\tdef importScene(self, *args):", "\t\tif self._importStorageManager:", "\t\t\treturn self._importStorageManager.load()", "\t\tif self._importStorageManager:", "\t\t\treturn self._importStorageManager.save()", "\t\treturn self._importStorageManager", "\t\tself._importStorageManager = storageManager", "\t\tself._importStorageManager.setScene(self.scene)", "\t\tself._importStorageManager.setTools(self.tools)", "\timportStorageManager = pyqtProperty(SceneStorageManager, getImportStorageManager, setImportStorageManager)", "\tdef importAction(self):", "\t\tif self._importAction:", "\t\t\treturn self._importAction", "\t\tself._importAction = QAction('Import', self.getWidget())", "\t\tself._importAction.triggered.connect(self.importScene)", "\t\treturn self._importAction", "\t\tself._actions.append(self.importAction)"]}], [{"term": "class", "name": "GraphicsTest", "data": "class GraphicsTest(SampleBase):\n\tdef __init__(self, *args, **kwargs):\n\t\tsuper(GraphicsTest, self).__init__(*args, **kwargs)\n\n\tdef run(self):\n\t\tcanvas = self.matrix\n\t\tfont = graphics.Font()\n\t\tfont.LoadFont(\"../../fonts/7x13.bdf\")\n\n\t\tred = graphics.Color(255, 0, 0)\n\t\tgraphics.DrawLine(canvas, 5, 5, 22, 13, red)\n\n\t\tgreen = graphics.Color(0, 255, 0)\n\t\tgraphics.DrawCircle(canvas, 15, 15, 10, green)\n\n\t\tblue = graphics.Color(0, 0, 255)\n\t\tgraphics.DrawText(canvas, font, 2, 10, blue, \"Text\")\n\n\t\ttime.sleep(10)   # show display for 10 seconds before exit\n\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "import time"]}], [{"term": "def", "name": "main", "data": "def main():\n\tpygame.init()\n\tdisplay = pygame.display.set_mode((CONFIG[\"graphics\"][\"width\"], CONFIG[\"graphics\"][\"height\"]))\n\tstart_menu(display)\n\t# game_loop(display)\n\tpygame.quit()\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from gamelogic import *", "from random import randint", "import time", "from gun import Gun", "from env import *"]}, {"term": "def", "name": "game_loop", "data": "def game_loop(display):\n\ttimer = 0\n\tscore = 0\n\tenemys = []  # [Enemy(50, 50, randint(0, WIDTH - 50), randint(SCORE_BOTTOM_LEFT, GUN_TOP_LEFT)) for _ in range(2)]\n\tcrosshair = Crosshair(0, 0)\n\tgun = Gun(0, 0)\n\trunning = True\n\twhile running:\n\n\t\tfor event in pygame.event.get():\n\t\t\tif event.type == pygame.QUIT:\n\t\t\t\tpygame.quit()\n\t\t\t\texit(0)\n\t\t\tif event.type == 768:\n\t\t\t\trunning = False\n\t\t\t#print(event.type)\n\t\t\t#print(pygame.K_ESCAPE)\n\t\t\t# if event.type == pygame.K_ESCAPE:\n\t\t\t#\t running = False\n\n\t\ttimer += 1\n\t\tif timer >= CONFIG[\"graphics\"][\"FPS\"] * CONFIG[\"settings\"][\"time_to_add_enemy\"]:\n\t\t\ttimer = 0\n\t\t\twhile True:\n\t\t\t\ttemp_enemy = Enemy(50, 50, randint(0, CONFIG[\"graphics\"][\"width\"] - 50),randint(SCORE_BOTTOM_LEFT, GUN_TOP_LEFT))\n\t\t\t\tif not enemy_collision(temp_enemy, enemys):\n\t\t\t\t\tenemys.append(temp_enemy)\n\t\t\t\t\tbreak\n\n\t\tfor enemy in enemys:\n\t\t\tenemy.timer += 1\n\t\t\tif enemy.timer >= CONFIG[\"graphics\"][\"FPS\"] * CONFIG[\"settings\"][\"time_to_remove_enemy\"]:\n\t\t\t\tenemys.remove(enemy)\n\t\t\t\tif score > 0:\n\t\t\t\t\tscore -= 1\n\n\t\tmouse_posx, mouse_posy = pygame.mouse.get_pos()\n\t\tcrosshair.pos_x = mouse_posx\n\t\tcrosshair.pos_y = mouse_posy\n\t\tgun.pos_x = crosshair.pos_x + 80\n\t\tgun.pos_y = 0\n\n\t\tleft_button, mid_button, right_button = pygame.mouse.get_pressed(num_buttons=3)\n\t\tif left_button:\n\t\t\ttarget_enemy = check_for_collision(enemys, crosshair)\n\t\t\tif target_enemy is not None:\n\t\t\t\tenemys.remove(target_enemy)\n\t\t\t\tscore += 1\n\n\t\tdraw_display(display, enemys, crosshair, score, gun)\n\t\tclock.tick(CONFIG[\"graphics\"][\"FPS\"])\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from gamelogic import *", "from random import randint", "import time", "from gun import Gun", "from env import *"]}, {"term": "def", "name": "draw_display", "data": "def draw_display(display, enemys, crosshair, score, gun):\n\tdisplay.blit(BACKGROUND, (0, 0))\n\tdraw_enemy(display, enemys)\n\tdraw_crosshair(display, crosshair)\n\tdraw_gun(display, gun, crosshair)\n\n\t# fonts :\n\tfont = pygame.font.Font('../assets/GILSANUB.TTF', 28)\n\tif score > 0:\n\t\tcolor = GREEN\n\telse:\n\t\tcolor = RED\n\ttext = font.render(f\"SCORE : {score}\", True, color)\n\ttextRect = text.get_rect()\n\ttextRect.center = (CONFIG[\"graphics\"][\"width\"] - textRect.width / 1.5, textRect.height)\n\tdisplay.blit(text, textRect)\n\tpygame.display.flip()\n\tglobal SCORE_BOTTOM_LEFT\n\tSCORE_BOTTOM_LEFT = textRect.y + textRect.height\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from gamelogic import *", "from random import randint", "import time", "from gun import Gun", "from env import *"]}, {"term": "def", "name": "draw_gun", "data": "def draw_gun(display, gun, crosshair):\n\tgun_width = 300\n\tgun_height = 200\n\tgun_image = pygame.image.load(\"../assets/gun.png\")\n\tgun_image_center = (gun.pos_x, CONFIG[\"graphics\"][\"height\"] - gun_height / 2)\n\tgun_scaled_image = pygame.transform.scale(gun_image, (gun_width, gun_height))\n\timage_get_rect = gun_scaled_image.get_rect(center=gun_image_center)\n\tglobal GUN_TOP_LEFT\n\tGUN_TOP_LEFT = image_get_rect.top\n\tdisplay.blit(gun_scaled_image, image_get_rect)\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from gamelogic import *", "from random import randint", "import time", "from gun import Gun", "from env import *"]}, {"term": "def", "name": "draw_enemy", "data": "def draw_enemy(display, enemys):\n\tfor enemy in enemys:\n\t\timage_get_rect = enemy.image.get_rect(center=(enemy.pos_x + enemy.width / 2, enemy.pos_y + enemy.height / 2))\n\t\t# pygame.draw.rect(display, GREEN, image_get_rect)\n\t\tdisplay.blit(enemy.image, image_get_rect)\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from gamelogic import *", "from random import randint", "import time", "from gun import Gun", "from env import *"]}, {"term": "def", "name": "draw_crosshair", "data": "def draw_crosshair(display, crosshair):\n\tcrosshair_image = pygame.image.load(\"../assets/crosshair.png\")\n\tcrosshair_image_center = (crosshair.pos_x, crosshair.pos_y)\n\tscaled_image = pygame.transform.scale(crosshair_image, (50, 50))\n\timage_get_rect = scaled_image.get_rect(center=crosshair_image_center)\n\tdisplay.blit(scaled_image, image_get_rect)\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from gamelogic import *", "from random import randint", "import time", "from gun import Gun", "from env import *"]}, {"term": "def", "name": "start_menu", "data": "def start_menu(display):\n\tclicked = False\n\trunning = True\n\ttext_buttons = {\"START GAME\": BLACK, \"OPTIONS\": BLACK}\n\tfont = pygame.font.Font('../assets/GILSANUB.TTF', 34)\n\tcolor = BLACK\n\n\twhile running:\n\t\tdisplay.fill(WHITE)\n\t\tfor event in pygame.event.get():\n\t\t\tif event.type == pygame.QUIT:\n\t\t\t\tpygame.quit()\n\t\t\t\texit(0)\n\t\t\tif event.type == pygame.MOUSEBUTTONDOWN:\n\t\t\t\tclicked = True\n\n\t\tmouse_position = pygame.mouse.get_pos()\n\n\t\tfor index, text1 in enumerate(text_buttons):\n\t\t\ttext = font.render(text1, True, text_buttons[text1])\n\t\t\ttext_rect = text.get_rect()\n\t\t\ttext_rect.center = (\n\t\t\tCONFIG[\"graphics\"][\"width\"] // 2, CONFIG[\"graphics\"][\"offset\"] + index * CONFIG[\"graphics\"][\"gap\"])\n\t\t\tif text_collision(text_rect, mouse_position):\n\t\t\t\ttext_buttons[text1] = GREEN\n\t\t\t\tif text1 == \"START GAME\" and clicked:\n\t\t\t\t\tclicked = False\n\t\t\t\t\tgame_loop(display)\n\n\t\t\t\tif text1 == \"OPTIONS\" and clicked:\n\t\t\t\t\tclicked = False\n\t\t\t\t\toptions_menu(display)\n\n\t\t\telse:\n\t\t\t\ttext_buttons[text1] = BLACK\n\t\t\tdisplay.blit(text, text_rect)\n\t\tpygame.display.flip()\n\n\t\tclock.tick(CONFIG[\"graphics\"][\"FPS\"])\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from gamelogic import *", "from random import randint", "import time", "from gun import Gun", "from env import *"]}, {"term": "def", "name": "text_collision", "data": "def text_collision(text_rect, mouse_positions):\n\treturn text_rect.collidepoint(mouse_positions)\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from gamelogic import *", "from random import randint", "import time", "from gun import Gun", "from env import *"]}, {"term": "def", "name": "enemy_collision", "data": "def enemy_collision(temp_enemy, enemys):\n\tfor enemy in enemys:\n\t\tif ((temp_enemy.center[0] - enemy.center[0]) ** 2 + (\n\t\t\t\ttemp_enemy.center[1] - enemy.center[1]) ** 2) ** 0.5 < 2 * enemy.radius:\n\t\t\treturn True\n\treturn False\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from gamelogic import *", "from random import randint", "import time", "from gun import Gun", "from env import *"]}, {"term": "def", "name": "options_menu", "data": "def options_menu(display):\n\tclicked = False\n\trunning = True\n\ttext_buttons = {\"BACK\": BLACK, \"VELOCITY\": BLACK}\n\tfont = pygame.font.Font('../assets/GILSANUB.TTF', 34)\n\tcolor = BLACK\n\ttext1 = None\n\twhile running:\n\t\tdisplay.fill(WHITE)\n\t\tfor event in pygame.event.get():\n\t\t\tif event.type == pygame.QUIT:\n\t\t\t\tpygame.quit()\n\t\t\t\texit(0)\n\n\t\t\tif event.type == pygame.MOUSEBUTTONDOWN:\n\t\t\t\tclicked = True\n\n\t\tmouse_position = pygame.mouse.get_pos()\n\n\t\tfor index, text1 in enumerate(text_buttons):\n\t\t\ttext = font.render(text1, True, text_buttons[text1])\n\t\t\ttext_rect = text.get_rect()\n\t\t\ttext_rect.center = (\n\t\t\tCONFIG[\"graphics\"][\"width\"] // 2, CONFIG[\"graphics\"][\"offset\"] + index * CONFIG[\"graphics\"][\"gap\"])\n\t\t\tif text_collision(text_rect, mouse_position):\n\t\t\t\ttext_buttons[text1] = GREEN\n\t\t\t\tif text1 == \"VELOCITY\" and clicked:\n\t\t\t\t\tclicked = False\n\t\t\t\t\tvelocity_menu(display)\n\n\t\t\t\tif text1 == \"BACK\" and clicked:\n\t\t\t\t\tclicked = False\n\t\t\t\t\trunning = False\n\n\t\t\telse:\n\t\t\t\ttext_buttons[text1] = BLACK\n\t\t\tdisplay.blit(text, text_rect)\n\t\tpygame.display.flip()\n\n\t\tclock.tick(CONFIG[\"graphics\"][\"FPS\"])\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from gamelogic import *", "from random import randint", "import time", "from gun import Gun", "from env import *"]}, {"term": "def", "name": "velocity_menu", "data": "def velocity_menu(display):\n\tclicked = False\n\trunning = True\n\ttext_buttons = {\"BACK\": BLACK, \"NORMAL\": BLACK, \"MEDIUM\": BLACK, \"HARD\": BLACK}\n\tfont = pygame.font.Font('../assets/GILSANUB.TTF', 34)\n\tcolor = BLACK\n\twhile running:\n\t\tdisplay.fill(WHITE)\n\t\tfor event in pygame.event.get():\n\t\t\tif event.type == pygame.QUIT:\n\t\t\t\tpygame.quit()\n\t\t\t\texit(0)\n\t\t\tif event.type == pygame.MOUSEBUTTONDOWN:\n\t\t\t\tclicked = True\n\n\t\tmouse_position = pygame.mouse.get_pos()\n\n\t\tfor index, text1 in enumerate(text_buttons):\n\t\t\ttext = font.render(text1, True, text_buttons[text1])\n\t\t\ttext_rect = text.get_rect()\n\t\t\ttext_rect.center = (\n\t\t\tCONFIG[\"graphics\"][\"width\"] // 2, CONFIG[\"graphics\"][\"offset\"] + index * CONFIG[\"graphics\"][\"gap\"])\n\t\t\tif text_collision(text_rect, mouse_position):\n\t\t\t\ttext_buttons[text1] = GREEN\n\n\t\t\t\tif text1 == \"BACK\" and clicked:\n\t\t\t\t\tclicked = False\n\t\t\t\t\trunning = False\n\n\t\t\t\tif text1 == \"NORMAL\" and clicked:\n\t\t\t\t\tclicked = False\n\t\t\t\t\tCONFIG[\"settings\"][\"time_to_add_enemy\"] = 0.7\n\t\t\t\t\tCONFIG[\"settings\"][\"time_to_remove_enemy\"] = 2.6\n\t\t\t\t\tsave_to_config()\n\n\n\t\t\t\tif text1 == \"MEDIUM\" and clicked:\n\t\t\t\t\tclicked = False\n\t\t\t\t\tCONFIG[\"settings\"][\"time_to_add_enemy\"] = 0.5\n\t\t\t\t\tCONFIG[\"settings\"][\"time_to_remove_enemy\"] = 2.2\n\t\t\t\t\tsave_to_config()\n\n\n\t\t\t\tif text1 == \"HARD\" and clicked:\n\t\t\t\t\tclicked = False\n\t\t\t\t\tCONFIG[\"settings\"][\"time_to_add_enemy\"] = 0.3\n\t\t\t\t\tCONFIG[\"settings\"][\"time_to_remove_enemy\"] = 1.5\n\t\t\t\t\tsave_to_config()\n\n\t\t\telse:\n\t\t\t\ttext_buttons[text1] = BLACK\n\t\t\tdisplay.blit(text, text_rect)\n\t\tpygame.display.flip()\n\n\t\tclock.tick(CONFIG[\"graphics\"][\"FPS\"])\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from gamelogic import *", "from random import randint", "import time", "from gun import Gun", "from env import *"]}], [{"term": "class", "name": "EnvObject", "data": "class EnvObject(Entity):\n\tdef __init__(self, level):\n\t\tEntity.__init__(self)\n\t\tself._category = '_Environment'\n\t\tself._level = level\n\t\tself.animPath = ''\n\t\tself.graphics = ''\n\t\tself.physics = ''\n\n\tdef loadDb3(self, db3File, guid):\n\t\tEntity.loadDb3(self, db3File, guid)\n\t\tself.animPath = db3File.queryEntityData(guid, 'AnimPath')\n\t\tself.graphics = db3File.queryEntityData(guid, 'Graphics')\n\t\tself.physics = db3File.queryEntityData(guid, 'Physics')\n\n\tdef saveDb3(self, db3File):\n\t\tEntity.saveDb3(self, db3File)\n\t\tif self.animPath:\n\t\t\tdb3File.updateEntityData(self.guid, 'AnimPath', self.animPath)\n\t\tif self.graphics:\n\t\t\tdb3File.updateEntityData(self.guid, 'Graphics', self.graphics)\n\t\tif self.physics:\n\t\t\tdb3File.updateEntityData(self.guid, 'Physics', self.physics)\n\n\tdef setAttributes(self, attrs):\n\t\tEntity.setAttributes(self, attrs)\n\t\tif 'res' in attrs:\n\t\t\tself.graphics = attrs['res']\n\t\t\tself.physics = attrs['res']\n\t\tif 'AnimPath' in attrs:\n\t\t\tself.animPath = attrs['AnimPath']\n\t\tif 'Graphics' in attrs:\n\t\t\tself.graphics = attrs['Graphics']\n\t\tif 'Physics' in attrs:\n\t\t\tself.physics = attrs['Physics']\n\n\tdef getAttributes(self):\n\t\tattrs = Entity.getAttributes(self)\n\t\tif self.graphics:\n\t\t\tattrs['res'] = self.graphics\n\t\tif self.animPath:\n\t\t\tattrs['AnimPath'] = self.animPath\n\t\tif self.graphics:\n\t\t\tattrs['Graphics'] = self.graphics\n\t\tif self.physics:\n\t\t\tattrs['Physics'] = self.physics\n\t\treturn attrs\n", "description": null, "category": "graphics", "imports": ["from entity import Entity"]}], [], [{"term": "class", "name": "ActionPipelineGraphics", "data": "class ActionPipelineGraphics(ActionGraphics):\n\n\tSIDE_MARGIN = 50\n\tV_SPACE = 50\n\tHORIZONTAL_ROW_BUFFER = 5\n\t\n\tdef __init__(self, actionPipeline: 'ActionPipeline', parent=None) -> 'ActionPipelineGraphics':\n\t\t\"\"\"\n\t\tConstructs a Action Graphics object for the given action.\n\n\t\t:param actionPipeline: The action pipeline for which this graphics item represents.\n\t\t:type actionPipeline: ActionPipeline\n\t\t:param parent: The parent graphics item\n\t\t:type parent: QGraphicsItem\n\t\t:return: The graphics of the action pipeline.\n\t\t:rtype: ActionPipelineGraphics\n\t\t\"\"\"\n\t\tActionGraphics.__init__(self, actionPipeline, parent)\n\t\t\n\t\tself._actionGraphics = []\n\t\tself._wireGraphics = []\n\t\t\n\t\tself._actionMapping = {}\n\t\tself._wireMapping = {}\n\t\t\n\t\t# item used to draw lines between ports being connected.\n\t\tself.connectionIndicator = ConnectionIndicator(self)\n\t\tself.connectionIndicator.hide()\n\t\tself.stagingConnection = None\n\t\t\n\t\tActionPipelineGraphics.updateGraphics(self)\n\t\n\t@Slot()\n\tdef updateGraphics(self) -> None:\n\t\t\"\"\"\n\t\tUpdates the graphics and all sub-graphics for the action pipeline.\n\t\t\n\t\tstarts by updating the sub-actions, then sub-wires, then calls the same method but in the\n\t\tActionGraphics class to update the ports.\n\t\t\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\tself.prepareGeometryChange()\n\t\tself.updateActionGraphics()\n\t\tActionGraphics.updateGraphics(self)\n\t\tself.updateWireGraphics()\n\t\n\tdef updateActionGraphics(self) -> None:\n\t\t\"\"\"\n\t\tSyncs the internal action graphics with the action pipeline's internal actions.\n\t\t\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\t\n\t\tnewOrdering = []\n\t\t\n\t\t# map all of the actions to action graphics.\n\t\tfor refAction in self._action.getActions():\n\t\t\t\n\t\t\t# update any action graphics that are already in the mapping.\n\t\t\tif refAction in self._actionMapping:\n\t\t\t\tself._actionMapping[refAction].updateGraphics()\n\t\t\t\n\t\t\t# create new action graphics that aren't already in the mapping.\n\t\t\telse:\n\t\t\t\tnewActionGraphics = ActionWrapperGraphics(refAction, self)\n\t\t\t\tself._actionGraphics.append(newActionGraphics)\n\t\t\t\tself._actionMapping[refAction] = newActionGraphics\n\t\t\t\n\t\t\tnewOrdering.append(self._actionMapping[refAction])\n\t\t\n\t\t# remove any actions that don't exist in the reference action pipeline.\n\t\tfor actionGraphics in self._actionGraphics[:]:\n\t\t\tif actionGraphics not in newOrdering:\n\t\t\t\tself._actionGraphics.remove(actionGraphics)\n\t\t\t\tactionGraphics.scene().removeItem(actionGraphics)\n\t\t\n\t\t# maintain correct ordering of action graphics\n\t\tself._actionGraphics.clear()\n\t\tfor actionGraphics in newOrdering:\n\t\t\tself._actionGraphics.append(actionGraphics)\n\t\t\t\n\t\tself.placeActions()\n\t\n\tdef getPortGraphics(self, port: 'Port') -> PortGraphics:\n\t\t\"\"\"\n\t\tGets the port graphics for any port that is owned by either this action pipeline or any\n\t\tactions inside of the this action pipeline.\n\t\t\n\t\t.. note:: This function returns None if the port was not found.\n\t\t\n\t\t:param port: The port to get the PortGraphics for.\n\t\t:type port: Port\n\t\t:return: The PortGraphics for the port\n\t\t:rtype: PortGraphics\n\t\t\"\"\"\n\t\t\n\t\tpm = {}\n\t\tpm.update(self._inputPortMapping)\n\t\tpm.update(self._outputPortMapping)\n\t\tfor a in self._actionGraphics:\n\t\t\tpm.update(a._inputPortMapping)\n\t\t\tpm.update(a._outputPortMapping)\n\t\t\t\n\t\treturn pm[port]\n\t\t\n\t\tpg = ActionGraphics.getPortGraphics(self, port)\n\t\tif pg is not None:\n\t\t\treturn pg\n\t\t\n\t\telse:\n\t\t\tfor action in self._actionGraphics:\n\t\t\t\tpg = action.getPortGraphics(port)\n\t\t\t\tif pg:\n\t\t\t\t\treturn pg\n\t\t\n\t\traise Exception(\"Port Graphics not found!\")\n\n\tdef updateWireGraphics(self) -> None:\n\t\t\"\"\"\n\t\tSyncs the internal wire graphics with the action pipeline's internal wires.\n\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\t\n\t\tnewOrdering = []\n\n\t\tcolumnAssignmentLedger, rowAssignmentLedger = self.allocateWireLanes()\n\t\t\n\t\t# map all of the wires to wire graphics.\n\t\tfor refWire in self._action.getWireSet().getWires():\n\n\t\t\t# create new wire graphics that aren't already in the mapping.\n\t\t\tif refWire not in self._wireMapping:\n\t\t\t\tnewWireGraphics = WireGraphics(refWire, self)\n\t\t\t\tself._wireGraphics.append(newWireGraphics)\n\t\t\t\tself._wireMapping[refWire] = newWireGraphics\n\n\t\t\t# srcAction = refWire.getSourcePort().getAction().getName()\n\t\t\t# srcPort = refWire.getSourcePort().getName()\n\t\t\t# dstAction = refWire.getDestPort().getAction().getName()\n\t\t\t# dstPort = refWire.getDestPort().getName()\n\t\t\t# msg = \"WIRE! {}: {} -> {}: {}\".format(srcAction, srcPort, dstAction, dstPort)\n\t\t\t# print(msg)\n\n\t\t\t# update any wire graphics that are already in the mapping.\n\t\t\tsrcPortGraphics = self.getPortGraphics(refWire.getSourcePort())\n\t\t\tdstPortGraphics = self.getPortGraphics(refWire.getDestPort())\n\n\t\t\t# Generate the current wire's graphics.\n\t\t\t# Need to determine the wire's starting and ending \"rows\". A row falls between sub actions.\n\t\t\tif refWire.getSourcePort().getAction() == self._action:\n\t\t\t\t# If current wire's srcPort belongs to this action, wire's srcActionRow = 0.\n\t\t\t\tsrcActionRow = 0\n\t\t\telse:\n\t\t\t\tsrcActionGFX = self._actionMapping[refWire.getSourcePort().getAction()]\n\t\t\t\tsrcActionRow = self._actionGraphics.index(srcActionGFX) + 1\n\n\t\t\tif refWire.getDestPort().getAction() == self._action:\n\t\t\t\t# If current wire's dstPort belongs to this action, wire's dstActionRow = # of actions.\n\t\t\t\tdstActionRow = len(self._actionGraphics)\n\t\t\telse:\n\t\t\t\tdstActionGFX = self._actionMapping[refWire.getDestPort().getAction()]\n\t\t\t\tdstActionRow = self._actionGraphics.index(dstActionGFX)\n\t\t\tself._wireMapping[refWire].updateGraphics(srcPortGraphics, dstPortGraphics, srcActionRow, dstActionRow,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  columnAssignmentLedger, rowAssignmentLedger)\n\t\t\t\n\t\t\tnewOrdering.append(self._wireMapping[refWire])\n\t\t\n\t\t# remove any wire graphics that don't exist in the reference wires.\n\t\tfor wireGraphics in self._wireGraphics[:]:\n\t\t\tif wireGraphics not in newOrdering:\n\t\t\t\tself._wireGraphics.remove(wireGraphics)\n\t\t\t\twireGraphics.scene().removeItem(wireGraphics)\n\t\t\n\t\t# maintain correct ordering of wire graphics\n\t\tself._wireGraphics.clear()\n\t\tfor wireGraphics in newOrdering:\n\t\t\tself._wireGraphics.append(wireGraphics)\n\n\tdef placeActions(self) -> None:\n\t\t\"\"\"\n\t\tMoves all of the sub-actions to their proper positions.\n\t\t\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\tinputs = self._action.getInputPorts()\n\t\toutputs = self._action.getOutputPorts()\n\t\tselfx, selfy, width, height = self.getActionRect(inputs, outputs)\n\t\t\n\t\toffset = (ActionGraphics.MAX_HEIGHT + PortGraphics.TOTAL_HEIGHT)/2 + ActionPipelineGraphics.V_SPACE\n\t\t\n\t\tfor i in range(len(self._actionGraphics)):\n\t\t\tactionGraphics = self._actionGraphics[i]\n\t\t\tactionHeight = ActionGraphics.MAX_HEIGHT + ActionPipelineGraphics.V_SPACE\n\t\t\ty = selfy + i * actionHeight + offset\n\t\t\t\n\t\t\t# msg = \"{} -> ({}, {})\".format(actionGraphics.getAction().getName(), str(0), str(y))\n\t\t\t# print(\"Moving Internal Action:\", msg)\n\t\t\t\n\t\t\tactionGraphics.setPos(0, y)\n\t\t\tactionGraphics.updateMoveButtonVisibility()\n\n\tdef getActionRect(self, inputPorts: QGraphicsItem, outputPorts: QGraphicsItem) -> list:\n\t\t\"\"\"\n\t\tGets the bounding rect of the action.\n\n\t\t:param inputPorts: Input ports added for the action.\n\t\t:type: QGraphicsItem\n\t\t:param outputPorts: Output ports added for the action.\n\t\t:type: QGraphicsItem\n\t\t:return: List of coordinates and dimensions for the bounding rect of the action.\n\t\t:rtype: list\n\t\t\"\"\"\n\t\tx, y, width, height = ActionGraphics.getActionRect(self, inputPorts, outputPorts)\n\t\t\n\t\t# resize the action to fit all actions and wires inside.\n\t\tmaxChildWidth = 0\n\t\tnumActions = len(self._actionGraphics)\n\n\t\tfor actionGraphics in self._actionGraphics:\n\t\t\tbr = actionGraphics.boundingRect()\n\t\t\tcurChildWidth = br.width() + ActionPipelineGraphics.SIDE_MARGIN*2\n\t\t\tmaxChildWidth = max(maxChildWidth, curChildWidth)\n\n\t\theight = ActionGraphics.MAX_HEIGHT * numActions + \\\n\t\t\t\t ActionPipelineGraphics.V_SPACE * (numActions + 1) + \\\n\t\t\t\t PortGraphics.TOTAL_HEIGHT\n\t\t\t\n\t\tself._width = max(self._width, maxChildWidth)\n\t\tself._height = height\n\n\t\tx = -self._width/2\n\t\ty = -self._height/2\n\t\t\n\t\treturn x, y, self._width, self._height\n\t\n\tdef paint(self, painter: QPainter, option: QStyleOptionGraphicsItem, index: QWidget) -> None:\n\t\t\"\"\"\n\t\tPaint the graphics of the action pipeline with ports, wires, and internal graphics.\n\n\t\t:param painter: This draws the widget.\n\t\t:type painter: QPainter\n\t\t:param option: Option for the style of graphic.\n\t\t:type option: QStyleOptionGraphicsItem\n\t\t:param index: Index for the painted graphic.\n\t\t:type index: QWidget\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\t\n\t\tself.getActionRect(self._action.getInputPorts(), self._action.getOutputPorts())\n\t\tActionGraphics.paint(self, painter, option, index)\n\t\tself.placeActions()\n\t\n\tdef mousePressEvent(self, event):\n\t\t\"\"\"\n\t\tWhen the mouse button is pressed, keep the starting point to use as the source of the wire.\n\t\t\n\t\t:param event: The event that carries the location of the mouse press\n\t\t:type event: QGraphicsSceneMouseEvent\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\t# get the port under the mouse\n\t\tpg = self.getPortGraphicsAtPos(event.scenePos().x(), event.scenePos().y())\n\t\tActionGraphics.mousePressEvent(self, event, emitSelected = (pg is None))\n\t\tif not pg:\n\t\t\treturn\n\t\t\n\t\tif not pg.getPort().isValidSource():\n\t\t\treturn\n\t\t\n\t\t# connect from tip of port to cursor\n\t\tx = pg.scenePos().x()\n\t\ty = pg.scenePos().y() + PortGraphics.TOTAL_HEIGHT/2\n\t\tself.connectionIndicator.setSrc(QPointF(x, y))\n\t\tself.connectionIndicator.setDest(QPointF(event.scenePos().x(), event.scenePos().y()))\n\t\t\n\t\t# stage the port to be the source for potential connections\n\t\tself.stagingConnection = pg\n\t\tself.connectionIndicator.setColor(ConnectionIndicator.BAD_COLOR)\n\t\tself.connectionIndicator.show()\n\n\t\tevent.accept()\n\t\n\tdef mouseMoveEvent(self, event):\n\t\t\"\"\"\n\t\tWhen the mouse is moved, update the destination and color of the indicator.\n\n\t\t:param event: The event that carries the location of the mouse move\n\t\t:type event: QGraphicsSceneMouseEvent\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\tif self.stagingConnection is None:\n\t\t\treturn\n\t\t\n\t\tdestP = event.scenePos()\n\t\tpg = self.getPortGraphicsAtPos(event.scenePos().x(), event.scenePos().y())\n\t\tif pg is not self.stagingConnection and pg is not None:\n\t\t\t\n\t\t\t# if it's a valid connection, color the indicator and snap to middle of port.\n\t\t\tsrc = self.stagingConnection.getPort()\n\t\t\tdst = pg.getPort()\n\t\t\tif self._action.connectionIsValid(src, dst):\n\t\t\t\tx = pg.scenePos().x()\n\t\t\t\ty = pg.scenePos().y() - PortGraphics.TOTAL_HEIGHT / 2\n\t\t\t\tdestP = QPointF(x, y)\n\t\t\t\tself.connectionIndicator.setColor(ConnectionIndicator.GOOD_COLOR)\n\t\t\telse:\n\t\t\t\tself.connectionIndicator.setColor(ConnectionIndicator.BAD_COLOR)\n\t\t\t\t\n\t\t# If the src port is the dest port, color it bad.\n\t\telif pg is self.stagingConnection:\n\t\t\tself.connectionIndicator.setColor(ConnectionIndicator.BAD_COLOR)\n\t\t\t\n\t\t# If we're not over a port, just use the base color.\n\t\telse:\n\t\t\tself.connectionIndicator.setColor(ConnectionIndicator.BASE_COLOR)\n\t\t\n\t\tself.connectionIndicator.setDest(destP)\n\t\tself.connectionIndicator.prepareGeometryChange()\n\t\tevent.accept()\n\t\n\tdef mouseReleaseEvent(self, event):\n\t\t\"\"\"\n\t\tWhen the mouse button is released, connect a wire if the mouse is over a port and the\n\t\tconnection would be valid.\n\n\t\t:param event: The event that carries the location of the mouse press\n\t\t:type event: QGraphicsSceneMouseEvent\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\tif self.stagingConnection is None:\n\t\t\treturn\n\n\t\tpg = self.getPortGraphicsAtPos(event.scenePos().x(), event.scenePos().y())\n\t\tif pg is not self.stagingConnection and pg is not None:\n\t\t\t\n\t\t\t# if it's a valid connection, color the indicator and snap to middle of port.\n\t\t\tsrc = self.stagingConnection.getPort()\n\t\t\tdst = pg.getPort()\n\t\t\tif self._action.connectionIsValid(src, dst):\n\t\t\t\tself._action.connect(self.stagingConnection._port, pg._port)\n\t\t\t\n\t\tself.stagingConnection = None\n\t\tself.connectionIndicator.hide()\n\t\tevent.accept()\n\n\tdef allocateWireLanes(self) -> Tuple[Dict[str, List[int]], Dict[int, List[int]]]:\n\t\t\"\"\"\n\t\tDetermine how many lanes to put between action and on the sides of the action pipelines.\n\t\t\n\t\t:return: TODO: Insert explanation of what's returned here.\n\t\t:rtype: Tuple[Dict[str, List[int]], Dict[int, List[int]]]\n\t\t\"\"\"\n\t\twires = [wire for wire in self._action.getWireSet().getWires()]\n\t\tcolLanes = {\"leftColumn\": [0, 0], \"rightColumn\": [0, 0]}  # {col: [total_lanes, lanes_assigned], ...}\n\t\trowLanes = {i: [0, 0] for i in range(len(self._actionGraphics)+1)}  # {row: [total_lanes, lanes_assigned], ...}\n\n\t\t# Heuristic: For the columns to the sides of the actions, just allocate ~1/2 as many lanes as there are wires.\n\t\tcolLanes[\"leftColumn\"][0] = (len(wires)//2) + 1\n\t\tcolLanes[\"rightColumn\"][0] = (len(wires)//2) + 1\n\n\t\t# Heuristic: Between actions, just allocate as many lanes as there are adjacent ports.\n\t\tif len(self._actionGraphics) > 0:\n\t\t\t# Allocate lanes between the ActionPipeline's input and the first sub Action.\n\t\t\tnumPipelineInputs = len(self._action.getInputPorts())\n\t\t\tnumfirstSubActionInputs = len(self._actionGraphics[0].getAction().getInputPorts())\n\t\t\tnumFirstRowLanes = numPipelineInputs + numfirstSubActionInputs\n\t\t\trowLanes[0][0] = numFirstRowLanes\n\n\t\t\t# Allocate lanes between the ActionPipeline's output and the last sub Action.\n\t\t\tnumPipelineOutputs = len(self._action.getOutputPorts())\n\t\t\tnumLastSubActionOutputs = len(self._actionGraphics[-1].getAction().getOutputPorts())\n\t\t\tnumLastRowLanes = numPipelineOutputs + numLastSubActionOutputs\n\t\t\trowLanes[len(rowLanes.keys())-1][0] = numLastRowLanes\n\n\t\t\t# Allocate lanes between sub Actions.\n\t\t\tif len(self._actionGraphics) > 1:\n\t\t\t\tfor i in range(0, len(self._actionGraphics)-1):\n\t\t\t\t\t# Allocate Lanes between ith and (i+1)=jth sub actions.\n\t\t\t\t\tnumIthOutputs = len(self._actionGraphics[i].getAction().getOutputPorts())\n\t\t\t\t\tnumJthInputs = len(self._actionGraphics[i+1].getAction().getInputPorts())\n\t\t\t\t\tnumRowLanes = numIthOutputs + numJthInputs\n\t\t\t\t\trowLanes[i+1][0] = numRowLanes\n\n\t\treturn colLanes, rowLanes\n\n\n\t# An unfinished, more complicated (but maybe better?) alternative to allocateWireLanes.\n\t# def allocateWireLanes(self, wires, actions) -> (dict, dict):\n\t# \tcolLanes = {\"left\": [0, 0], \"right\": [0, 0]}\t\t # {col: [total_lanes, lanes_unassigned], ...}\n\t# \trowLanes = {i: [0, 0] for i in range(len(wires)+1)}  # {row: [total_lanes, lanes_unassigned], ...}\n\t#\n\t# \t# Iterate through the wires, examine their source and destination actions, allocate lanes accordingly.\n\t# \tfor wire in wires:\n\t# \t\tsrcAction = wire.getSourcePort().getAction()\n\t# \t\tdstAction = wire.getDestPort().getAction()\n\t#\n\t# \t\t# If source action is adjacent to destination action.\n\t# \t\tsrcActionGFX = self._actionMapping[srcAction]  # ...may not work if wire connected to the input/output of self.\n\t# \t\tdstActionGFX = self._actionGraphics[dstAction]\n\t# \t\tassert(srcActionGFX in self._actionGraphics)\n\t# \t\tassert(dstActionGFX in self._actionGraphics)\n\t# \t\tif self._actionGraphics.index(dstActionGFX) == self._actionGraphics.index(srcActionGFX) + 1:\n\t# \t\t\t# This wire goes between adjacent actions. Add a lane in between actions.\n\t# \t\t\trowIndex = self._actionGraphics.index(srcActionGFX)\n", "description": "\n\t\tConstructs a Action Graphics object for the given action.\n\n\t\t:param actionPipeline: The action pipeline for which this graphics item represents.\n\t\t:type actionPipeline: ActionPipeline\n\t\t:param parent: The parent graphics item\n\t\t:type parent: QGraphicsItem\n\t\t:return: The graphics of the action pipeline.\n\t\t:rtype: ActionPipelineGraphics\n\t\t", "category": "graphics", "imports": ["from typing import Tuple, Dict, List", "from PySide2.QtWidgets import QGraphicsItem, QWidget, QStyleOptionGraphicsItem", "from PySide2.QtGui import QPainter, QColor, QTransform", "from PySide2.QtCore import QRectF, Slot, QPointF", "from graphics.apim.actiongraphics import ActionGraphics", "from graphics.apim.wiregraphics import WireGraphics", "from graphics.apim.portgraphics import PortGraphics", "from graphics.apim.connectionindicator import ConnectionIndicator", "from graphics.apim.actionwrappergraphics import ActionWrapperGraphics"]}], [], [{"term": "def", "name": "__init__", "data": "  def __init__(self):\r\n\tself.visited = \"\"\r\n", "description": null, "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "visitRectangleGF", "data": "  def visitRectangleGF(self, rectangleGF):\r\n\tself.ref = rectangleGF\r\n\tself.visited = \"RectangleGF\"\r\n", "description": null, "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "visitOvalGF", "data": "  def visitOvalGF(self, ovalGF):\r\n\tself.ref = ovalGF\r\n\tself.visited = \"OvalGF\"\r\n", "description": null, "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "visitPolygonGF", "data": "  def visitPolygonGF(self, polygonGF):\r\n\tself.ref = polygonGF\r\n\tself.visited = \"PolygonGF\"\r\n", "description": null, "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "visitPolylineGF", "data": "  def visitPolylineGF(self, polylineGF):\r\n\tself.ref = polylineGF\r\n\tself.visited = \"PolylineGF\"\r\n", "description": null, "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "visitTextGF", "data": "  def visitTextGF(self, textGF):\r\n\tself.ref = textGF\r\n\tself.visited = \"TextGF\"\r\n", "description": null, "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "visitConnectorGF", "data": "  def visitConnectorGF(self, connectorGF):\r\n\tself.ref = connectorGF\r\n\tself.visited = \"ConnectorGF\"\r\n", "description": null, "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "visitCompositeGF", "data": "  def visitCompositeGF(self, compositeGF):\r\n\tself.ref = compositeGF\r\n\tself.visited = \"CompositeGF\"\r\n\r\n", "description": null, "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testNotImplementedGF", "data": "  def testNotImplementedGF(self):\r\n\t\"\"\"test failure to instantiate GF\"\"\"\r\n\tself.assertRaises(NotImplementedError, Graphics.GF)\r\n\r\n", "description": "test failure to instantiate GF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testNotImplementedLeafGF", "data": "  def testNotImplementedLeafGF(self):\r\n\t\"\"\"test failure to instantiate LeafGF\"\"\"\r\n\tself.assertRaises(NotImplementedError, Graphics.LeafGF)\r\n\r\n", "description": "test failure to instantiate LeafGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testBoundingBoxLeafGF", "data": "  def testBoundingBoxLeafGF(self):\r\n\t\"\"\"test LeafGF getApproxBoundingBox\"\"\"\r\n\t#Leaf GFs\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tfor gf in leafGFs:\r\n\t  box = gf.getApproxBoundingBox()\r\n\t  numPoints = len(gf.xy)/2\r\n\t  for i in range(numPoints):\r\n\t\tself.failIf(box[0] > round(gf.xy[2*i]))\r\n\t\tself.failIf(box[2] < round(gf.xy[2*i]))\r\n\t\tself.failIf(box[1] > round(gf.xy[2*i+1]))\r\n\t\tself.failIf(box[3] < round(gf.xy[2*i+1]))\r\n\r\n", "description": "test LeafGF getApproxBoundingBox", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testSetZoomLeafGF", "data": "  def testSetZoomLeafGF(self):\r\n\t\"\"\"test LeafGF setZoom\"\"\"\r\n\t#Leaf GFs\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tfor gf in leafGFs:\r\n\t  gf.setZoom(7.2)\r\n\t  self.assertEqual(gf.zoom, 7.2)\r\n\r\n", "description": "test LeafGF setZoom", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testLockSanity", "data": "  def testLockSanity(self):\r\n\t\"\"\"test lock sanity LeafGF\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tfor gf in leafGFs:\r\n\t  gf.setLock(1)\r\n\t  self.assertEqual(gf.getLock(), 1)\r\n\t  gf.setLock(0)\r\n\t  self.assertEqual(gf.getLock(), 0)\r\n\r\n", "description": "test lock sanity LeafGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testLock", "data": "  def testLock(self):\r\n\t\"\"\"test lock LeafGF\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tfor gf in leafGFs:\r\n\t  old_xy = gf.xy[:]\r\n\t  gf.setLock(1)\r\n\t  gf.translate(2,3)\r\n\t  self.assertEqual(old_xy, gf.xy)\r\n\t  gf.setLock(0)\r\n\t  gf.translate(2,3)\r\n\t  self.assertNotEqual(old_xy, gf.xy)\r\n\r\n", "description": "test lock LeafGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testSetFillColorSanity", "data": "  def testSetFillColorSanity(self):\r\n\t\"\"\"test fill color sanity LeafGF\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tfor gf in leafGFs:\r\n\t  gf.setFillColor(\"green\")\r\n\t  self.assertEqual(gf.getFillColor(), \"green\")\r\n", "description": "test fill color sanity LeafGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testSetOutlineColorSanity", "data": "  def testSetOutlineColorSanity(self):\r\n\t\"\"\"test outline color sanity for LeafGFs with outline\"\"\"\r\n\tleafGFs = [Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tfor gf in leafGFs:\r\n\t  gf.setOutlineColor(\"green\")\r\n\t  self.assertEqual(gf.getOutlineColor(), \"green\")\r\n\r\n\r\n", "description": "test outline color sanity for LeafGFs with outline", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testTranslateLeafGF", "data": "  def testTranslateLeafGF(self):\r\n\t\"\"\"test LeafGF translate\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3, 2.3, 12], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\ttranslations = [(leafGFs[0], leafGFs[0].translate, (3.4, 54.), (4.4, 66.0)),\r\n\t\t\t\t\t(leafGFs[1], leafGFs[1].translate, (2.4, 4.), (12.4, 24.0)),\r\n\t\t\t\t\t(leafGFs[2], leafGFs[2].translate, (-2., 33.), (-4.0, 36.0, -68.0, 65.3, 0.3, 45.0)),\r\n\t\t\t\t\t(leafGFs[3], leafGFs[3].translate, (-2.1, 0.1), (-14.1, 12.33, 63.7, -32.9)),\r\n\t\t\t\t\t(leafGFs[4], leafGFs[4].translate, (1.,1.), (2.0, 2.0, 13.0, 13.0)),\r\n\t\t\t\t\t(leafGFs[5], leafGFs[5].translate, (4., 3.0), (6.0, 9.0, 8.8, 9.4))]\r\n\ttestOperationsLeafGF(self, translations)\r\n\r\n", "description": "test LeafGF translate", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testRotateLeafGF", "data": "  def testRotateLeafGF(self):\r\n\t\"\"\"test LeafGF rotate\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3, 2.3, 12], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\trotations = [(leafGFs[0], leafGFs[0].rotate, (0, 0, 90), (-12.0, 1.0)),\r\n\t\t\t\t (leafGFs[1], leafGFs[1].rotate, (0, 0, 180), (-10.0, -20.0)),\r\n\t\t\t\t (leafGFs[2], leafGFs[2].rotate, (0, 0, 0), (-2.0, 3.0, -66.0, 32.3, 2.3, 12)),\r\n\t\t\t\t (leafGFs[3], leafGFs[3].rotate, (0, 0, 270), (12.23, 12.0, -33.0, -65.8)),\r\n\t\t\t\t (leafGFs[4], leafGFs[4].rotate, (0, 0, -90), (1.0, -1.0, 12.0, -12.0)),\r\n\t\t\t\t (leafGFs[5], leafGFs[5].rotate, (0, 0, 90), (-6.0, 2.0, -6.4, 4.8))]\r\n\r\n\ttestOperationsLeafGF(self, rotations)\r\n\r\n", "description": "test LeafGF rotate", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testScaleLeafGF", "data": "  def testScaleLeafGF(self):\r\n\t\"\"\"test LeafGF scale\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3, 2.3, 12], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tscalings = [(leafGFs[0], leafGFs[0].scale, (0, 0, 0, 0), (0, 0)),\r\n\t\t\t\t(leafGFs[1], leafGFs[1].scale, (0, 0, 1.0, 2.0), (10.0, 40.0)),\r\n\t\t\t\t(leafGFs[2], leafGFs[2].scale, (0, 0, 2.0, 3.0), (-4.0, 9.0, -132.0, 96.9, 4.6, 36)),\r\n\t\t\t\t(leafGFs[3], leafGFs[3].scale, (0, 0, -1.0, 2.0), (12.0, 24.46, -65.8, -66.0)),\r\n\t\t\t\t(leafGFs[4], leafGFs[4].scale, (0, 0, 3.0, 3.0), (3.0, 3.0, 36.0, 36.0)),\r\n\t\t\t\t(leafGFs[5], leafGFs[5].scale, (0, 0, 0.0, 0.5), (0.0, 3.0, 0.0, 3.2))]\r\n\ttestOperationsLeafGF(self, scalings)\r\n\t\t\r\n", "description": "test LeafGF scale", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testAcceptRectangleGF", "data": "  def testAcceptRectangleGF(self):\r\n\t\"\"\"test accept visitor RectangleGF\"\"\"\r\n\tvisitor = UselessVisitor()\r\n\trectangleGF = Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\trectangleGF.accept(visitor)\r\n\tself.assertEqual(visitor.visited, \"RectangleGF\")\r\n\tself.failIf(not (visitor.ref is rectangleGF))\r\n\t\r\n", "description": "test accept visitor RectangleGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testAcceptOvalGF", "data": "  def testAcceptOvalGF(self):\r\n\t\"\"\"test accept visitor OvalGF\"\"\"\r\n\tvisitor = UselessVisitor()\r\n\tovalGF = Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tovalGF.accept(visitor)\r\n\tself.assertEqual(visitor.visited, \"OvalGF\")\r\n\tself.failIf(not (visitor.ref is ovalGF))\r\n\r\n", "description": "test accept visitor OvalGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testAcceptPolygonGF", "data": "  def testAcceptPolygonGF(self):\r\n\t\"\"\"test accept visitor PolygonGF\"\"\"\r\n\tvisitor = UselessVisitor()\r\n\tpolygonGF = Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3, 2.3, 12], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tpolygonGF.accept(visitor)\r\n\tself.assertEqual(visitor.visited, \"PolygonGF\")\r\n\tself.failIf(not (visitor.ref is polygonGF))\r\n\r\n", "description": "test accept visitor PolygonGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testAcceptPolylineGF", "data": "  def testAcceptPolylineGF(self):\r\n\t\"\"\"test accept visitor PolylineGF\"\"\"\r\n\tvisitor = UselessVisitor()\r\n\tpolylineGF = Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tpolylineGF.accept(visitor)\r\n\tself.assertEqual(visitor.visited, \"PolylineGF\")\r\n\tself.failIf(not (visitor.ref is polylineGF))\r\n\r\n", "description": "test accept visitor PolylineGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testAcceptTextGF", "data": "  def testAcceptTextGF(self):\r\n\t\"\"\"test accept visitor TextGF\"\"\"\r\n\tvisitor = UselessVisitor()\r\n\ttextGF = Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None)\r\n\ttextGF.accept(visitor)\r\n\tself.assertEqual(visitor.visited, \"TextGF\")\r\n\tself.failIf(not (visitor.ref is textGF))\r\n\r\n", "description": "test accept visitor TextGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testAcceptConnectorGF", "data": "  def testAcceptConnectorGF(self):\r\n\t\"\"\"test accept visitor ConnectorGF\"\"\"\r\n\tvisitor = UselessVisitor()\r\n\tconnectorGF = Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None)\r\n\tconnectorGF.accept(visitor)\r\n\tself.assertEqual(visitor.visited, \"ConnectorGF\")\r\n\tself.failIf(not (visitor.ref is connectorGF))\r\n", "description": "test accept visitor ConnectorGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyTypeRectangleGF", "data": "  def testCopyTypeRectangleGF(self):\r\n\t\"\"\"test RectangleGF copy return type\"\"\"\r\n\trectangleGF = Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tself.failIf(not isinstance(rectangleGF.copy(), Graphics.RectangleGF))\r\n\r\n", "description": "test RectangleGF copy return type", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyTypeOvalGF", "data": "  def testCopyTypeOvalGF(self):\r\n\t\"\"\"test OvalGF copy return type\"\"\"\r\n\tovalGF = Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tself.failIf(not isinstance(ovalGF.copy(), Graphics.OvalGF))\r\n\r\n", "description": "test OvalGF copy return type", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyTypePolygonGF", "data": "  def testCopyTypePolygonGF(self):\r\n\t\"\"\"test PolygonGF copy return type\"\"\"\r\n\tpolygonGF = Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3, 2.3, 12], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tself.failIf(not isinstance(polygonGF.copy(), Graphics.PolygonGF))\r\n\r\n", "description": "test PolygonGF copy return type", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyTypePolylineGF", "data": "  def testCopyTypePolylineGF(self):\r\n\t\"\"\"test Polyline copy return type\"\"\"\r\n\tpolylineGF = Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tself.failIf(not isinstance(polylineGF.copy(), Graphics.PolylineGF))\r\n\r\n", "description": "test Polyline copy return type", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyTypeTextGF", "data": "  def testCopyTypeTextGF(self):\r\n\t\"\"\"test TextGF copy return type\"\"\"\r\n\ttextGF = Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None)\r\n\tself.failIf(not isinstance(textGF.copy(), Graphics.TextGF))\r\n\r\n", "description": "test TextGF copy return type", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyTypeConnectorGF", "data": "  def testCopyTypeConnectorGF(self):\r\n\t\"\"\"test ConnectorGF copy return type\"\"\"\r\n\tconnectorGF = Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None)\r\n\tself.failIf(not isinstance(connectorGF.copy(), Graphics.ConnectorGF))\r\n\r\n", "description": "test ConnectorGF copy return type", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyRectangleGF", "data": "  def testCopyRectangleGF(self):\r\n\t\"\"\"test RectangleGF copy\"\"\"\r\n\tgf = Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tgf2 = gf.copy()\r\n\tself.assertEqual(gf.xy, gf2.xy)\r\n\tself.assertEqual(gf.fill, gf2.fill)\r\n\tself.assertEqual(gf.outline, gf2.outline)\r\n\tself.assertEqual(gf.width, gf2.width)\r\n\tself.assertEqual(gf.isActive, gf2.isActive)\r\n\tself.assertEqual(gf.isLocked, gf2.isLocked)\r\n\tself.assertEqual(gf.zoom, gf2.zoom)\r\n\r\n", "description": "test RectangleGF copy", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyOvalGF", "data": "  def testCopyOvalGF(self):\r\n\t\"\"\"test OvalGF copy\"\"\"\r\n\tgf = Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tgf2 = gf.copy()\r\n\tself.assertEqual(gf.xy, gf2.xy)\r\n\tself.assertEqual(gf.fill, gf2.fill)\r\n\tself.assertEqual(gf.outline, gf2.outline)\r\n\tself.assertEqual(gf.width, gf2.width)\r\n\tself.assertEqual(gf.isActive, gf2.isActive)\r\n\tself.assertEqual(gf.isLocked, gf2.isLocked)\r\n\tself.assertEqual(gf.zoom, gf2.zoom)\r\n\r\n", "description": "test OvalGF copy", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyPolygonGF", "data": "  def testCopyPolygonGF(self):\r\n\t\"\"\"test PolygonGF copy\"\"\"\r\n\tgf = Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3, 2.3, 32], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tgf2 = gf.copy()\r\n\tself.assertEqual(gf.xy, gf2.xy)\r\n\tself.assertEqual(gf.fill, gf2.fill)\r\n\tself.assertEqual(gf.outline, gf2.outline)\r\n\tself.assertEqual(gf.width, gf2.width)\r\n\tself.assertEqual(gf.isActive, gf2.isActive)\r\n\tself.assertEqual(gf.isLocked, gf2.isLocked)\r\n\tself.assertEqual(gf.zoom, gf2.zoom)\r\n\r\n", "description": "test PolygonGF copy", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyPolylineGF", "data": "  def testCopyPolylineGF(self):\r\n\t\"\"\"test Polyline copy\"\"\"\r\n\tgf = Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4, 2.3, 32], \"black\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tgf2 = gf.copy()\r\n\tself.assertEqual(gf.xy, gf2.xy)\r\n\tself.assertEqual(gf.fill, gf2.fill)\r\n\tself.assertEqual(gf.width, gf2.width)\r\n\tself.assertEqual(gf.isActive, gf2.isActive)\r\n\tself.assertEqual(gf.isLocked, gf2.isLocked)\r\n\tself.assertEqual(gf.zoom, gf2.zoom)\r\n\r\n", "description": "test Polyline copy", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyTextGF", "data": "  def testCopyTextGF(self):\r\n\t\"\"\"test TextGF copy\"\"\"\r\n\tgf = Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None)\r\n\tgf2 = gf.copy()\r\n\tself.assertEqual(gf.xy, gf2.xy)\r\n\tself.assertEqual(gf.fill, gf2.fill)\r\n\tself.assertEqual(gf.textCopy, gf2.textCopy)\r\n\tself.assertEqual(gf.isActive, gf2.isActive)\r\n\tself.assertEqual(gf.isLocked, gf2.isLocked)\r\n\tself.assertEqual(gf.zoom, gf2.zoom)\r\n\r\n", "description": "test TextGF copy", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyConnectorGF", "data": "  def testCopyConnectorGF(self):\r\n\t\"\"\"test ConnectorGF copy\"\"\"\r\n\tgf = Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None)\r\n\tgf2 = gf.copy()\r\n\tself.assertEqual(gf.xy, gf2.xy)\r\n\tself.assertEqual(gf.fill, gf2.fill)\r\n\tself.assertEqual(gf.outline, gf2.outline)\r\n\tself.assertEqual(gf.width, gf2.width)\r\n\tself.assertEqual(gf.isActive, gf2.isActive)\r\n\tself.assertEqual(gf.isLocked, gf2.isLocked)\r\n\tself.assertEqual(gf.zoom, gf2.zoom)\r\n\r\n", "description": "test ConnectorGF copy", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testAcceptCompositeGF", "data": "  def testAcceptCompositeGF(self):\r\n\t\"\"\"test accept visitor CompositeGF\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None)]\r\n\tvisitor = UselessVisitor()\r\n\tcompositeGF = Graphics.CompositeGF([leafGFs[0], leafGFs[1]], 1, 0, 1.0, None)\r\n\tcompositeGF.accept(visitor)\r\n\tself.assertEqual(visitor.visited, \"CompositeGF\")\r\n\tself.failIf(not (visitor.ref is compositeGF))\r\n\r\n", "description": "test accept visitor CompositeGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testLockSanity", "data": "  def testLockSanity(self):\r\n\t\"\"\"test lock sanity CompositeGF\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tcompositeGFs = [Graphics.CompositeGF([leafGFs[0], leafGFs[1]], 1, 0, 1.0, None),\r\n\t\t\t\t\tGraphics.CompositeGF([leafGFs[1], leafGFs[3]], 1, 0, 1.0, None),\r\n\t\t\t\t\tGraphics.CompositeGF([leafGFs[1], leafGFs[4]], 1, 0, 1.0, None),\r\n\t\t\t\t\tGraphics.CompositeGF([leafGFs[3], leafGFs[5]], 1, 0, 1.0, None)]\r\n\tfor gf in compositeGFs:\r\n\t  gf.setLock(1)\r\n\t  self.assertEqual(gf.getLock(), 1)\r\n\t  gf.setLock(0)\r\n\t  self.assertEqual(gf.getLock(), 0)\r\n\r\n", "description": "test lock sanity CompositeGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testLock", "data": "  def testLock(self):\r\n\t\"\"\"test lock sanity CompositeGF\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tcompositeGFs = [Graphics.CompositeGF([leafGFs[0], leafGFs[1]], 1, 0, 1.0, None),\r\n\t\t\t\t\tGraphics.CompositeGF([leafGFs[1], leafGFs[3]], 1, 0, 1.0, None),\r\n\t\t\t\t\tGraphics.CompositeGF([leafGFs[1], leafGFs[4]], 1, 0, 1.0, None),\r\n\t\t\t\t\tGraphics.CompositeGF([leafGFs[3], leafGFs[5]], 1, 0, 1.0, None)]\r\n\tfor gf in compositeGFs:\r\n\t  components = gf.getComponents()\r\n\t  oldCoordList = []\r\n\t  for c in components:\r\n\t\toldCoordList.append(c.xy[:])\r\n\t  #lock\r\n\t  gf.setLock(1)\r\n\t  gf.translate(2,2)\r\n\t  newCoordList = []\r\n\t  for c in components:\r\n\t\tnewCoordList.append(c.xy[:])\r\n\t  tuples = map(None, oldCoordList, newCoordList)\r\n\t  for t in tuples:\r\n\t\tself.assertEqual(t[0], t[1])\r\n\t  #now unlock\r\n\t  gf.setLock(0)\r\n\t  gf.translate(2,2)\r\n\t  newCoordList = []\r\n\t  for c in components:\r\n\t\tnewCoordList.append(c.xy[:])\r\n\t  tuples = map(None, oldCoordList, newCoordList)\r\n\t  for t in tuples:\r\n\t\tself.assertNotEqual(t[0], t[1])\r\n\r\n", "description": "test lock sanity CompositeGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testTranslateCompositeGF", "data": "  def testTranslateCompositeGF(self):\r\n\t\"\"\"test CompositeGF translate\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3, 2.3, 12], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tcompositeGF = Graphics.CompositeGF(leafGFs, 1, 0, 1.0, None)\r\n\tcomponents = compositeGF.getComponents()\r\n\toldCoordLists = []\r\n\tfor c in components:\r\n\t  oldCoordLists.append(c.xy[:])\r\n\tcompositeGF.translate(2,2)\r\n\tnewCoordLists = []\r\n\tfor c in components:\r\n\t\tnewCoordLists.append(c.xy[:])\r\n\tlistPairs = map(None, oldCoordLists, newCoordLists)\r\n\tfor p in listPairs:\r\n\t  coordPair = map(None, p[0], p[1])\r\n\t  for c in coordPair:\r\n\t\tself.assertEqual(c[0] + 2, c[1])\r\n\r\n", "description": "test CompositeGF translate", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testRotateCompositeGF", "data": "  def testRotateCompositeGF(self):\r\n\t\"\"\"test CompositeGF rotate\"\"\"\r\n\tleafGFs = [Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3, 2.3, 12], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tcompositeGF = Graphics.CompositeGF(leafGFs, 1, 0, 1.0, None)\r\n\tcomponents = compositeGF.getComponents()\r\n\toldCoordLists = []\r\n\tfor c in components:\r\n\t  oldCoordLists.append(c.xy[:])\r\n\tcompositeGF.rotate(0,0,180)\r\n\tnewCoordLists = []\r\n\tfor c in components:\r\n\t\tnewCoordLists.append(c.xy[:])\r\n\tlistPairs = map(None, oldCoordLists, newCoordLists)\r\n\tfor p in listPairs:\r\n\t  coordPair = map(None, p[0], p[1])\r\n\t  for c in coordPair:\r\n\t\tself.assertEqual(-c[0], c[1])\r\n\r\n", "description": "test CompositeGF rotate", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testScaleCompositeGF", "data": "  def testScaleCompositeGF(self):\r\n\t\"\"\"test CompositeGF scale\"\"\"\r\n\tleafGFs = [Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tcompositeGF = Graphics.CompositeGF(leafGFs, 1, 0, 1.0, None)\r\n\tcomponents = compositeGF.getComponents()\r\n\toldCoordLists = []\r\n\tfor c in components:\r\n\t  oldCoordLists.append(c.xy[:])\r\n\tcompositeGF.scale(0,0,2,2)\r\n\tnewCoordLists = []\r\n\tfor c in components:\r\n\t\tnewCoordLists.append(c.xy[:])\r\n\tlistPairs = map(None, oldCoordLists, newCoordLists)\r\n\tfor p in listPairs:\r\n\t  coordPair = map(None, p[0], p[1])\r\n\t  for c in coordPair:\r\n\t\tself.assertEqual(2*c[0], c[1])\r\n\r\n", "description": "test CompositeGF scale", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testGetComponentsCompositeGF", "data": "  def testGetComponentsCompositeGF(self):\r\n\t\"\"\"test CompositeGF getComponents\"\"\"\r\n\tleafGFs = [Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tcompositeGF = Graphics.CompositeGF(leafGFs, 1, 0, 1.0, None)\r\n\tcomponents = compositeGF.getComponents()\r\n\tself.failIf(not components[0] is leafGFs[0])\r\n\tself.failIf(not components[1] is leafGFs[1])\r\n\r\n", "description": "test CompositeGF getComponents", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testBoundingBoxCompositeGF", "data": "  def testBoundingBoxCompositeGF(self):\r\n\t\"\"\"test CompositeGF getApproxBoundingBox\"\"\"\r\n\t#Leaf GFs\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None)]\r\n\tcompositeGF = Graphics.CompositeGF(leafGFs, 1, 0, 1.0, None)\r\n\tbox = compositeGF.getApproxBoundingBox()\r\n\tfor gf in leafGFs:\r\n\t  leafBox = gf.getApproxBoundingBox()\r\n\t  self.failIf(box[0] > leafBox[0])\r\n\t  self.failIf(box[2] < leafBox[2])\r\n\t  self.failIf(box[1] > leafBox[1])\r\n\t  self.failIf(box[3] < leafBox[3])\r\n\r\n", "description": "test CompositeGF getApproxBoundingBox", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyTypeCompositeGF", "data": "  def testCopyTypeCompositeGF(self):\r\n\t\"\"\"test CompositeGF copy return type\"\"\"\r\n\tleafGFs = [Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tcompositeGF = Graphics.CompositeGF(leafGFs, 1, 0, 1.0, None)\r\n\tself.failIf(not isinstance(compositeGF.copy(), Graphics.CompositeGF))\r\n\r\n\r\n", "description": "test CompositeGF copy return type", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testRotation", "data": "  def testRotation(self):\r\n\t\"\"\"testing rotation primitive\"\"\"\r\n\tfor t in self.rotationTests:\r\n\t  point = Geometry.rotate(t[0][0], t[0][1], t[0][2], t[0][3], t[0][4])\r\n\t  self.assertEqual(point, t[1])\r\n\r\n", "description": "testing rotation primitive", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testTranslation", "data": "  def testTranslation(self):\r\n\t\"\"\"testing translation primitive\"\"\"\r\n\tfor t in self.translationTests:\r\n\t  point = Geometry.translate(t[0][0], t[0][1], t[0][2], t[0][3])\r\n\t  self.assertEqual(point, t[1])\r\n", "description": "testing translation primitive", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testScaling", "data": "  def testScaling(self):\r\n\t\"\"\"testing scaling primitive\"\"\"\r\n\tfor t in self.scalingTests:\r\n\t  point = Geometry.scale(t[0][0], t[0][1], t[0][2], t[0][3], t[0][4], t[0][5])\r\n\t  self.assertEqual(point, t[1])\r\n\r\n", "description": "testing scaling primitive", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}], [{"term": "def", "name": "one2two", "data": "def one2two(pos):\n\t# this is a dreadfully ugly conversion fucntion for the 1d number into the\n\t# corresponding 2d value\n\t# used exclusively for the laser position\n\t# modulo is always 400\n\tpos = pos%400\n\tdigs = [int(i) for i in str(pos).zfill(3)]\n\tconv = [digs[0]*100, digs[1]*10 + digs[2]]\n\n\tif pos>=300:\t\t\n\t\tconv = [0, 100-(pos-300)]\n\telif pos>=200:\n\t\tconv = [100-(pos-200), 100]\n\telif pos>=100:\n\t\tconv = [digs[0]*100, digs[1]*10 + digs[2]]\n\telse:\n\t\tconv = [digs[1]*10 + digs[2], 0]\t\n\treturn np.array(conv)\n", "description": null, "category": "graphics", "imports": ["import pygame as pg", "import random", "import numpy as np", "import math as m", "import time"]}, {"term": "def", "name": "gameconv", "data": "def gameconv(pos, ref, unit):\n\t# convert a position into the relevant game units\n\t# ref: the point of reference by which everything is defined.\n\t#\t  (for this game, everything is measured from top left\n\t#\t   corner of this grid).\n\tconv_pos = np.array([int(ref[0] + pos[0]*unit), int(ref[1] + pos[1]*unit)])\n\n\treturn conv_pos\n", "description": null, "category": "graphics", "imports": ["import pygame as pg", "import random", "import numpy as np", "import math as m", "import time"]}, {"term": "class", "name": "classLaser:", "data": "class Laser:\n\t\"\"\"\n\tThe laser is drives the interaction process. It assumes the following processes:\n\t- state:\t\ton or off\n\t- position:\t the point at which the laser is fired\n\t- angle:\t\tthe orientation of the laser\n\t- intensity:\tthe power of the laser (will be used to control ablation rate)\n\t- energy:\t   the amount of energy the laser has: powers down when energy is spent\n\t\"\"\"\t\n\tdef __init__(self, graphics):\n\t\t\"\"\"\n\t\tInitialise laser, relevant data (the position, orientation, intensity, state, and \n\t\tenergy).\n\t\t\"\"\"\n\t\tself.graphics = graphics\n\t\tself.game = self.graphics.game\n\t\tself.interface = self.graphics.game.interface\n\n\t\t# The position of the laser is ONE DIMENSIONAL with modulo 400 to represent a\n\t\t# on a square with unit 100 side length.\n\t\t# [0, 100)   --> (0,0), (100, 0)\n\t\t# [100, 200) --> (100, 0), (100, 100)\n\t\t# [200, 300) --> (100, 100), (0, 100)\n\t\t# [300, 400)   --> (0, 100), (0, 0) \n\t\t\n\t\t# Note however that the above coordinates aren't what pygame will be reading.\n\t\t# In the raw units,\n\t\t# [0, 100)   --> (xcoord, ycoord+reference) (xcoord+reference, ycoord+reference)\n\t\t# [100, 200) --> (xcoord+reference, ycoord+reference) (xcoord+reference, ycoord)\n\t\t# [200, 300) --> (xcoord, ycoord+reference) (xcoord, ycoord)\n\t\t# [300, 0)   --> (xcoord, ycoord) (xcoord, ycoord+reference)\n\t\t# This will, however, be converted in the \"draw laser\" method.\n\n\t\t# reference\n\t\tself.ref = np.array([self.graphics.xcoord, self.graphics.ycoord])\n\t\tself.read_commands = None\n\t\tself.finished = False\n\n\t\t# fineness of the laser beam\n\t\t# lower fineness == better accuracy, but slower calculation.\n\t\tself.fine = 0.1\n\t\t\n\t\t# State variables\n\t\tself.on = False\n\t\tself.error = False\n\t\tself.position = 250\n\t\tself.angle = 90\n\t\tself.intensity = 2\n\n\t\t# rotation matrix, dependent on self.angle\t\t\t   \n\t\t# drawing\n\t\tself.radius = int(m.sqrt(0.3*self.graphics.game.sx))\n\t\t\n\t\t# default cannon values\n\t\t# mag: the distance from the centre of the cannon to the tip\n\t\tself.mag = np.array([int(0.005*self.graphics.game.sy), 0])\n\n\tdef reset(self,):\n\t\tself.on = False\n\t\tself.error = False\n\t\tself.position = 250\n\t\tself.angle = 90\n\t\tself.intensity = 2\n\n\tdef beam_calc(self,):\n\t\t\"\"\"\n\t\tThis is pretty intensive, so it'll only activate in the main graphics program when\n\t\tthe beam is on.\n\t\tEssentially calculates the end point of the beam. Will be used in both the drawing\n\t\tand the materials class.\n\t\t\"\"\"\n\t\t# remembering to copy() saves lives\n\n\t\trot = np.array([[m.cos(m.radians(self.angle)),  m.sin(m.radians(self.angle))],\n\t\t\t\t\t\t[-m.sin(m.radians(self.angle)),  m.cos(m.radians(self.angle))]])\n\t\tposition = one2two(self.position) + rot@self.mag\n\t\t\n\t\tdirection = rot@self.mag\n\t\tgame_pos = gameconv(position, self.ref, self.graphics.game_unit)\n\t\t\n\t\txcond = (game_pos[0] > 0) and (game_pos[0]< self.graphics.game.sx)\n\t\tycond = (game_pos[1] > 0) and (game_pos[1]< self.graphics.game.sy)\n\n\t\t\n\t\twhile xcond==True and ycond==True:\n\t\t\t# there's no point in initializing a new unit vector each time\n\t\t\t# scaling the fineness will have the required effect\n\n\t\t\t# material collision detection\n\t\t\tposition += self.fine*direction\n\t\t\tgame_pos = gameconv(position, self.ref, self.graphics.game_unit)\n\n\t\t\t# conditions for gamepos[0]\n\t\t\tlx0 = (game_pos[0] > self.graphics.materials.graph_x)\n\t\t\tlx1 = (game_pos[0] < self.graphics.materials.graph_x + self.graphics.materials.graph_h)\n\t\t\t\n\t\t\t# conditions for gamepos[1]\n\t\t\tly0 = (game_pos[1] > self.graphics.materials.graph_y)\n\t\t\tly1 = (game_pos[1] < self.graphics.materials.graph_y + self.graphics.materials.graph_v)\n\n\t\t\tif lx0 and lx1 and ly0 and ly1:\n\t\t\t\tindex1 = int(game_pos[0] - self.graphics.materials.graph_x)\n\t\t\t\tindex2 = int(game_pos[1] - self.graphics.materials.graph_y)\n\t\t\t\t\n\t\t\t\tcollision = self.graphics.materials.matpix[index1, index2][2] != 128\n\t\t\t\t\n\t\t\t\tif collision.all():\n\t\t\t\t\tfor i in range(-self.intensity,self.intensity):\n\t\t\t\t\t\tfor j in range(-self.intensity,self.intensity):\n\t\t\t\t\t\t\tself.graphics.materials.matpix[index1+i, index2+j] = np.array(DBLUE)\n\t\t\t\t\tbreak\n\t\t\t\n\t\t\txcond = (game_pos[0] > 0) and (game_pos[0]< self.graphics.game.sx)\n\t\t\tycond = (game_pos[1] > 0) and (game_pos[1]< self.graphics.game.sy)\n\n\t\treturn position\n\t\t\t\n\t\t\n\tdef update_laser(self,):\n\t\t\"\"\"\n\t\tUpdates the state of the laser variables.\n\t\tIf the laser's state variable is True, a line will be drawn. \n\t\t\"\"\"\n\t\tif self.interface.index == len(self.interface.program):\n\t\t\tself.finished = True\n\t\t\treturn 0\n\t\t\n\t\tcurrent_command = self.interface.program[self.interface.index].split(\" \")\n\t\targument = current_command[0]\n\t\tvalue = int(current_command[1])\n\n\t\t# for numerical arguments,\n\t\t#  1. reduce the argument in the list by one\n\t\t#  2. increment the corresponding state variable of the laser by one.\n\t\t#  3. if zero, increment the index of the list.\n\t\t\n\t\tif value == 0:\n\t\t\tself.interface.index += 1\n\t\telse:\n\t\t\t# Remember: FOR doesn't turn up here.\n\t\t\t#\t\t   it's dealt with in the \"parsing\" function and performed automatically.\n\t\t\tif argument == \"TON\":\n\t\t\t\tself.interface.program[self.interface.index] = \"TON \" + str(value-1)\n\t\t\t\tself.on = True\n\t\t\t\t\n\t\t\tif argument == \"TOF\":\n\t\t\t\tself.interface.program[self.interface.index] = \"TOF \" + str(value-1)\n\t\t\t\tself.on = False\n\t\t\t\t\n\t\t\tif argument == \"PAU\":\n\t\t\t\tself.interface.program[self.interface.index] = \"PAU \" + str(value-1)\n\n\t\t\tif argument == \"INT\":\n\t\t\t\tself.intensity = value\n\t\t\t\tself.interface.index+=1\n\t\t\t\t\n\t\t\tif argument == \"MOV\":\n\t\t\t\tself.interface.program[self.interface.index] = \"MOV \" + str(value-np.sign(value))\n\t\t\t\tself.position += np.sign(value)\n\n\t\t\tif argument == \"ORI\":\n\t\t\t\tself.interface.program[self.interface.index] = \"ORI \" + str(value-np.sign(value))\n\t\t\t\tself.angle += np.sign(value)\n\t\t\n\tdef draw_laser(self,):\n\t\t\"\"\"\n\t\tNOTE: TRANSFORMATIONS MUST BE APPLIED HERE.\n\t\t1. pygame's native coordinate system is (x, -y) for some reason (stupid af). This must\n\t\t   be accounted for.\n\t\t2. The one-dimensional position of the square must be mapped to a two-dimensional\n\t\t   coordinate system.\n\t\t\"\"\"\n\t\t\n\t\tpg.draw.circle(self.graphics.game.display,\n\t\t\t\t\t   SILVER,\n\t\t\t\t\t   gameconv(one2two(self.position), self.ref, self.graphics.game_unit),\n\t\t\t\t\t   self.radius)\n\n\n\t\t# cannon fire:\n\t\trot = np.array([[m.cos(m.radians(self.angle)),  m.sin(m.radians(self.angle))],\n\t\t\t\t\t\t[-m.sin(m.radians(self.angle)),  m.cos(m.radians(self.angle))]])\n\t\tcan = one2two(self.position) + rot@self.mag\n\t\t\n\t\tif self.on == True:\n\t\t\tcancol = GREEN\n\t\t\tstart = gameconv(can, self.ref, self.graphics.game_unit)\n\t\t\tend = gameconv(self.beam_calc(), self.ref, self.graphics.game_unit)\n\t\t\tpg.draw.line(self.graphics.game.display, cancol, start, end, (int(self.intensity/10)+1))\n\t\t\t\n\t\telse:\n\t\t\tcancol = ORANGE\n\t\t\t\n\t\tpg.draw.circle(self.graphics.game.display,\n\t\t\t\t\t   cancol,\n\t\t\t\t\t   gameconv(can, self.ref, self.graphics.game_unit),\t\t\t\t\t   \n\t\t\t\t\t   int((0.5*(self.intensity/100) + 0.3)*self.radius))\n\n", "description": "\n\tThe laser is drives the interaction process. It assumes the following processes:\n\t- state:\t\ton or off\n\t- position:\t the point at which the laser is fired\n\t- angle:\t\tthe orientation of the laser\n\t- intensity:\tthe power of the laser (will be used to control ablation rate)\n\t- energy:\t   the amount of energy the laser has: powers down when energy is spent\n\t", "category": "graphics", "imports": ["import pygame as pg", "import random", "import numpy as np", "import math as m", "import time"]}, {"term": "class", "name": "classMaterials:", "data": "class Materials:\n\t\"\"\"\n\tThere are two kinds of materials used in the game.\n\t\ta) Material particles that interact with the laser. \n\t\t   These are given two position values, x and y.\n\t\tb) Gas particles, which are formed in two situations:\n\t\t\t - When the material comes into contact with a laser.\n\t\t\t - When a gas particle comes into contact with a material.\n\t\t   Gas particles take velocity values as well as position values.\n\t\t\t\n\tNOTE: this needs to be as efficient as possible.\n\tIt's best to build a system that checks the neighbourhood AROUND a point.\n\t\"\"\"\n\t#-----------------------------------------------------------------------------------------------\n\t\n\tdef __init__(self, graphics, laser):\n\t\t\"\"\" \n\t\tInitialise material lists and relevant details.\n\t\t\"\"\"\n\t\tself.graphics = graphics\n\t\tself.laser = laser\n\n\t\t# dimensions of the box\n\t\tself.graph_h = int(0.91*self.graphics.reference)+1\n\t\tself.graph_v = int(0.91*self.graphics.reference)+1\n\n\t\t# coordinates of the origin of the material matrix\t\t\n\t\tself.graph_x = self.graphics.xcoord + 0.03*self.graphics.game.sx\n\t\tself.graph_y = self.graphics.ycoord + 0.04*self.graphics.game.sy\n\n\t\tself.level = None\n\t\t# the level matrix, designed by hand\n\t\tself.level_matrix = None # initially none, but updated once the level is selected.\n\n\n\tdef init_level(self, level, bgcol=DBLUE):\n\t\tself.level = level\n\t\tself.level_matrix = level_list[level-1]\t\t\t\t\n\t\t# build the pixel version of the level matrix\n\t\tn = np.shape(self.level_matrix)[0]\n\t\t\n\t\t\n\t\tblockx = int(self.graph_h/n)\n\t\tblocky = int(self.graph_v/n)\n\n\t\t\n\t\tself.matpix = np.zeros((self.graph_h, self.graph_v, 3), dtype=np.uint8)\n\t\tself.matpix[:, :, 0] = bgcol[0]\n\t\tself.matpix[:, :, 1] = bgcol[1]\n\t\tself.matpix[:, :, 2] = bgcol[2]\n\t\t\n\t\tfor i in range(0,n):\n\t\t\tfor j in range(0,n):\n\t\t\t\tiind = i*blockx\n\t\t\t\tjind = j*blocky\n\t\t\t\tif self.level_matrix[i,j] == 2:\n\t\t\t\t\tfor graphi in range(0, blockx):\n\t\t\t\t\t\tfor graphj in range(0, blocky):\n\t\t\t\t\t\t\tself.matpix[iind+graphi, jind+graphj, 0] = RED[0] - random.randrange(50)\n\t\t\t\t\t\t\tself.matpix[iind+graphi, jind+graphj, 1] = RED[1]\n\t\t\t\t\t\t\tself.matpix[iind+graphi, jind+graphj, 2] = RED[2]\n\t\t\t\tif self.level_matrix[i,j] == 1:\n\t\t\t\t\tfor graphi in range(0, blockx):\n\t\t\t\t\t\tfor graphj in range(0, blocky):\n\t\t\t\t\t\t\tself.matpix[iind+graphi, jind+graphj, 0] = ORANGE[0] - random.randrange(50)\n\t\t\t\t\t\t\tself.matpix[iind+graphi, jind+graphj, 1] = ORANGE[1]\n\t\t\t\t\t\t\tself.matpix[iind+graphi, jind+graphj, 2] = ORANGE[2]\n\t\t\t\t\t\n\tdef draw_material(self):\n\t\t\"\"\"\n\t\tDraws the materials.\n\t\t\"\"\"\n\t\tdrawn_matpix = pg.surfarray.make_surface(self.matpix)\t\t\n\t\tself.graphics.game.display.blit(drawn_matpix, (self.graph_x, self.graph_y))\n\n", "description": "\n\tThere are two kinds of materials used in the game.\n\t\ta) Material particles that interact with the laser. \n\t\t   These are given two position values, x and y.\n\t\tb) Gas particles, which are formed in two situations:\n\t\t\t - When the material comes into contact with a laser.\n\t\t\t - When a gas particle comes into contact with a material.\n\t\t   Gas particles take velocity values as well as position values.\n\t\t\t\n\tNOTE: this needs to be as efficient as possible.\n\tIt's best to build a system that checks the neighbourhood AROUND a point.\n\t", "category": "graphics", "imports": ["import pygame as pg", "import random", "import numpy as np", "import math as m", "import time"]}], [], [{"term": "class", "name": "MultiGraphics", "data": "class MultiGraphics(WithEqualityById, SageObject):\n\tr\"\"\"\n\tBase class for objects composed of :class:`~sage.plot.graphics.Graphics`\n\tobjects.\n\n\tBoth the display and the output to a file of ``MultiGraphics`` objects\n\tare governed by the method :meth:`save`, which is called by the rich output\n\tdisplay manager, via\n\t:meth:`~sage.repl.rich_output.display_manager.DisplayManager.graphics_from_save`.\n\n\tThe user interface is through the functions\n\t:func:`~sage.plot.plot.multi_graphics` (generic multi-graphics) and\n\t:func:`~sage.plot.plot.graphics_array` (subclass :class:`GraphicsArray`).\n\n\tINPUT:\n\n\t- ``graphics_list`` -- a list of graphics along with their positions on the\n\t  common canvas; each element of ``graphics_list`` is either\n\n\t  - a pair ``(graphics, position)``, where ``graphics`` is a\n\t\t:class:`~sage.plot.graphics.Graphics` object and ``position`` is the\n\t\t4-tuple ``(left, bottom, width, height)`` specifying the location and\n\t\tsize of the graphics on the canvas, all quantities being in fractions\n\t\tof the canvas width and height\n\n\t  - or a single :class:`~sage.plot.graphics.Graphics` object; its position\n\t\tis then assumed to occupy the whole canvas, except for some padding;\n\t\tthis corresponds to the default position\n\t\t``(left, bottom, width, height) = (0.125, 0.11, 0.775, 0.77)``\n\n\tEXAMPLES:\n\n\tA multi-graphics made from two graphics objects::\n\n\t\tsage: g1 = plot(sin(x^3), (x, -pi, pi))\n\t\tsage: g2 = circle((0,0), 1, color='red')\n\t\tsage: G = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tsage: G\n\t\tMultigraphics with 2 elements\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**3), (x, -pi, pi))\n\t\tg2 = circle((0,0), 1, color='red')\n\t\tG = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tsphinx_plot(G)\n\n\tSince no position was given for ``g1``, it occupies the whole canvas.\n\tMoreover, we note that ``g2`` has been drawn over ``g1`` with a white\n\tbackground. To have a transparent background instead, one has to construct\n\t``g2`` with the keyword ``transparent`` set to ``True``::\n\n\t\tsage: g2 = circle((0,0), 1, color='red', transparent=True)\n\t\tsage: G = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tsage: G\n\t\tMultigraphics with 2 elements\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**3), (x, -pi, pi))\n\t\tg2 = circle((0,0), 1, color='red', transparent=True)\n\t\tG = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tsphinx_plot(G)\n\n\tWe can add a new graphics object to G via the method :meth:`append`::\n\n\t\tsage: g3 = complex_plot(zeta, (-20, 10), (-20, 20),\n\t\t....:\t\t\t\t   axes_labels=['$x$', '$y$'], frame=True)\n\t\tsage: G.append(g3, pos=(0.63, 0.12, 0.3, 0.3))\n\t\tsage: G\n\t\tMultigraphics with 3 elements\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**3), (x, -pi, pi))\n\t\tg2 = circle((0,0), 1, color='red', transparent=True)\n\t\tG = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tg3 = complex_plot(zeta, (-20, 10), (-20, 20), \\\n\t\t\t\t\t\t  axes_labels=['$x$', '$y$'], frame=True)\n\t\tG.append(g3, pos=(0.63, 0.12, 0.3, 0.3))\n\t\tsphinx_plot(G)\n\n\tWe can access the individual elements composing ``G`` with the\n\tsquare-bracket operator::\n\n\t\tsage: print(G[0])\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: G[0] is g1\n\t\tTrue\n\t\tsage: G[1] is g2\n\t\tTrue\n\t\tsage: G[2] is g3\n\t\tTrue\n\n\t``G[:]`` returns the full list of graphics objects composing ``G``::\n\n\t\tsage: G[:]\n\t\t[Graphics object consisting of 1 graphics primitive,\n\t\t Graphics object consisting of 1 graphics primitive,\n\t\t Graphics object consisting of 1 graphics primitive]\n\t\tsage: len(G)\n\t\t3\n\n\t\"\"\"\n\tdef __init__(self, graphics_list):\n\t\tr\"\"\"\n\t\tInitialize the attributes common to all MultiGraphics objects.\n\n\t\tTESTS::\n\n\t\t\tsage: from sage.plot.multigraphics import MultiGraphics\n\t\t\tsage: G = MultiGraphics([])\n\t\t\tsage: print(G)\n\t\t\tMultigraphics with 0 element\n\t\t\tsage: c = circle((0,0), 1)\n\t\t\tsage: G = MultiGraphics([c, (c, (0.7, 0.6, 0.2, 0.2))])\n\t\t\tsage: print(G)\n\t\t\tMultigraphics with 2 elements\n\n\t\t\"\"\"\n\t\tself._glist = []\n\t\tself._positions = []\n\t\t#\n\t\tfor ins in graphics_list:\n\t\t\tif isinstance(ins, Graphics):\n\t\t\t\tself.append(ins)  # default position\n\t\t\telse:\n\t\t\t\tif not isinstance(ins, (list, tuple)) or len(ins) != 2:\n\t\t\t\t\traise TypeError(\"a pair (Graphics, position) is \"\n\t\t\t\t\t\t\t\t\t\"expected, not {}\".format(ins))\n\t\t\t\tself.append(ins[0], pos=ins[1])\n\n\tdef _repr_(self):\n\t\tr\"\"\"\n\t\tRepresentation of ``self``.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: c = circle((0,0), 1)\n\t\t\tsage: G = graphics_array([c, c, c])\n\t\t\tsage: G._repr_()\n\t\t\t'Graphics Array of size 1 x 3'\n\t\t\tsage: G\n\t\t\tGraphics Array of size 1 x 3\n\n\t\t\"\"\"\n\t\treturn str(self)\n\n\tdef _rich_repr_(self, display_manager, **kwds):\n\t\tr\"\"\"\n\t\tRich Output Magic Method.\n\n\t\tSee :mod:`sage.repl.rich_output` for details.\n\n\t\t.. TODO::\n\n\t\t   This method is identical to Graphics._rich_repr_ so it could be\n\t\t   inherited from a common base class\n\n\t\tEXAMPLES::\n\n\t\t\tsage: from sage.repl.rich_output import get_display_manager\n\t\t\tsage: dm = get_display_manager()\n\t\t\tsage: G = graphics_array([Graphics(), Graphics()], 1, 2)\n\t\t\tsage: G._rich_repr_(dm)\n\t\t\tOutputImagePng container\n\n\t\t\"\"\"\n\t\ttypes = display_manager.types\n\t\tprefer_raster = (\n\t\t\t('.png', types.OutputImagePng),\n\t\t\t('.jpg', types.OutputImageJpg),\n\t\t\t('.gif', types.OutputImageGif),\n\t\t)\n\t\tprefer_vector = (\n\t\t\t('.svg', types.OutputImageSvg),\n\t\t\t('.pdf', types.OutputImagePdf),\n\t\t)\n\t\tgraphics = display_manager.preferences.graphics\n\t\tif graphics == 'disable':\n\t\t\treturn\n\t\telif graphics == 'raster' or graphics is None:\n\t\t\tpreferred = prefer_raster + prefer_vector\n\t\telif graphics == 'vector':\n\t\t\tpreferred = prefer_vector + prefer_raster\n\t\telse:\n\t\t\traise ValueError('unknown graphics output preference')\n\t\tfor file_ext, output_container in preferred:\n\t\t\tif output_container in display_manager.supported_output():\n\t\t\t\treturn display_manager.graphics_from_save(\n\t\t\t\t\tself.save, kwds, file_ext, output_container)\n\n\tdef __getitem__(self, i):\n\t\tr\"\"\"\n\t\tReturn the ``i``th element of the list of graphics composing ``self``.\n\n\t\tEXAMPLES:\n\n\t\tWe can access and view individual plots::\n\n\t\t\tsage: L = [[plot(x^2)], [plot(x^3)]]\n\t\t\tsage: G = graphics_array(L)\n\t\t\tsage: G[1]\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tAnother example::\n\n\t\t\tsage: L = [plot(sin(k*x), (x,-pi,pi)) + circle((k,k), 1,\n\t\t\t....:\t\t   color='red') for k in range(10)]\n\t\t\tsage: G = graphics_array(L, 5, 2)\n\t\t\tsage: G[3]\n\t\t\tGraphics object consisting of 2 graphics primitives\n\n\t\t\"\"\"\n\t\treturn self._glist[i]\n\n\tdef __setitem__(self, i, g):\n\t\tr\"\"\"\n\t\tSet the ``i``th element of the list of graphics composing ``self``.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: L = [[plot(x^2)], [plot(x^3)]]\n\t\t\tsage: G = graphics_array(L)\n\t\t\tsage: G[1] # the plot of x^3\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tNow we change it::\n\n\t\t\tsage: G[1] = circle((1,1), 2) + points([(1,2), (3,2), (5,5)],\n\t\t\t....:\t\t\t\t\t\t\t\t  color='purple')\n\t\t\tsage: G[1] # a circle and some purple points\n\t\t\tGraphics object consisting of 2 graphics primitives\n\n\t\t\"\"\"\n\t\tself._glist[i] = g\n\n\tdef __len__(self):\n\t\tr\"\"\"\n\t\tTotal number of Graphics objects composing ``self``.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: L = [circle((0,0), n) for n in range(6)]\n\t\t\tsage: G = graphics_array(L, 2, 3)\n\t\t\tsage: len(G)\n\t\t\t6\n\n\t\t\"\"\"\n\t\treturn len(self._glist)\n\n\tdef matplotlib(self, figure=None, figsize=None, **kwds):\n\t\tr\"\"\"\n\t\tConstruct or modify a Matplotlib figure by drawing ``self`` on it.\n\n\t\tINPUT:\n\n\t\t- ``figure`` -- (default: ``None``) Matplotlib figure (class\n\t\t  ``matplotlib.figure.Figure``) on which ``self`` is to be displayed;\n\t\t  if ``None``, the figure will be created from the parameter\n\t\t  ``figsize``\n\n\t\t- ``figsize`` -- (default: ``None``) width or [width, height] in inches\n\t\t  of the Matplotlib figure in case ``figure`` is ``None``; if\n\t\t  ``figsize`` is ``None``, Matplotlib's default (6.4 x 4.8 inches) is\n\t\t  used\n\n\t\t- ``kwds`` -- options passed to the\n\t\t  :meth:`~sage.plot.graphics.Graphics.matplotlib` method of\n\t\t  each graphics object constituting ``self``\n\n\t\tOUTPUT:\n\n\t\t- a ``matplotlib.figure.Figure`` object; if the argument ``figure`` is\n\t\t  provided, this is the same object as ``figure``.\n\n\t\tEXAMPLES:\n\n\t\tLet us consider a :class:`GraphicsArray` object with 3 elements::\n\n\t\t\tsage: G = graphics_array([plot(sin(x^k), (x, 0, 3))\n\t\t\t....:\t\t\t\t\t for k in range(1, 4)])\n\n\t\tIf ``matplotlib()`` is invoked without any argument, a Matplotlib\n\t\tfigure is created and contains the 3 graphics element of the array\n\t\tas 3 Matplotlib ``Axes``::\n\n\t\t\tsage: fig = G.matplotlib()\n\t\t\tsage: fig\n\t\t\t\n\t\t\tsage: type(fig)\n\t\t\t\n\n\t\tSpecifying the figure size (in inches)::\n\n\t\t\tsage: G.matplotlib(figsize=(8., 5.))\n\t\t\t\n\n\t\tIf a single number is provided for ``figsize``, it is considered to be\n\t\tthe width; the height is then computed according to Matplotlib's\n\t\tdefault aspect ratio (4/3)::\n\n\t\t\tsage: G.matplotlib(figsize=8.)\n\t\t\t\n\n\t\tAn example of use with a preexisting created figure, created by\n\t\t``pyplot``::\n\n\t\t\tsage: import matplotlib.pyplot as plt\n\t\t\tsage: fig1 = plt.figure(1)\n\t\t\tsage: fig1\n\t\t\t\n\t\t\tsage: fig_out = G.matplotlib(figure=fig1)\n\t\t\tsage: fig_out\n\t\t\t\n\n\t\tNote that the output figure is the same object as the input one::\n\n\t\t\tsage: fig_out is fig1\n\t\t\tTrue\n\n\t\tIt has however been modified by ``G.matplotlib(figure=fig1)``, which\n\t\thas added 3 new ``Axes`` to it.\n\n\t\tAnother example, with a figure created from scratch, via Matplolib's\n\t\t``Figure``::\n\n\t\t\tsage: from matplotlib.figure import Figure\n\t\t\tsage: fig2 = Figure()\n\t\t\tsage: fig2\n\t\t\t\n\t\t\tsage: G.matplotlib(figure=fig2)\n\t\t\t\n\t\t\tsage: fig2\n\t\t\t\n\n\t\t\"\"\"\n\t\tfrom matplotlib.figure import Figure\n\t\tglist = self._glist\n\t\tif len(glist) == 0:\t   # for an empty MultiGraphics, we create\n\t\t\tglist = [Graphics()]  # a 1-element list with an empty graphics\n\t\t# If no Matplotlib figure is provided, it is created here:\n\t\tif figure is None:\n\t\t\tif figsize is not None:\n\t\t\t\tfigsize = _parse_figsize(figsize)\n\t\t\tfigure = Figure(figsize=figsize)\n\t\tglobal do_verify\n\t\tdo_verify = True\n\t\tfor i, g in enumerate(glist):\n\t\t\t# Options for g.matplotlib():\n\t\t\toptions = {}\n\t\t\toptions.update(Graphics.SHOW_OPTIONS)  # default options for show()\n\t\t\toptions['legend_options'] = Graphics.LEGEND_OPTIONS  # default leg.\n\t\t\toptions.update(g._extra_kwds)  # options set in g\n\t\t\toptions.update(kwds)\n\t\t\t# We get rid of options that are not relevant for g.matplotlib():\n\t\t\toptions.pop('dpi', None)\n\t\t\toptions.pop('fig_tight', None)\n\t\t\ttransparent = options.pop('transparent', None)\n\t\t\t# Creating the Matplotlib Axes object \"subplot\" on the figure:\n\t\t\tsubplot = self._add_subplot(figure, i)\n\t\t\t# and drawing g on it:\n\t\t\tg.matplotlib(figure=figure, sub=subplot, verify=do_verify,\n\t\t\t\t\t\t **options)\n\t\t\tif transparent:\n\t\t\t\tsubplot.set_facecolor('none')\n\t\treturn figure\n\n\tdef save(self, filename, figsize=None, **kwds):\n\t\tr\"\"\"\n\t\tSave ``self`` to a file, in various formats.\n\n\t\tINPUT:\n\n\t\t- ``filename`` -- (string) the file name; the image format is given by\n\t\t  the extension, which can be one of the following:\n\n\t\t\t* ``.eps``,\n\n\t\t\t* ``.pdf``,\n\n\t\t\t* ``.png``,\n\n\t\t\t* ``.ps``,\n\n\t\t\t* ``.sobj`` (for a Sage object you can load later),\n\n\t\t\t* ``.svg``,\n\n\t\t\t* empty extension will be treated as ``.sobj``.\n\n\t\t- ``figsize`` -- (default: ``None``) width or [width, height] in inches\n\t\t  of the Matplotlib figure; if none is provided, Matplotlib's default\n\t\t  (6.4 x 4.8 inches) is used\n\n\t\t- ``kwds`` -- keyword arguments, like ``dpi=...``, passed to the\n\t\t  plotter, see :meth:`show`\n\n\t\tEXAMPLES::\n\n\t\t\tsage: F = tmp_filename(ext='.png')\n\t\t\tsage: L = [plot(sin(k*x), (x,-pi,pi)) for k in [1..3]]\n\t\t\tsage: G = graphics_array(L)\n\t\t\tsage: G.save(F, dpi=500, axes=False)\n\n\t\tTESTS::\n\n\t\t\tsage: graphics_array([]).save(F)\n\t\t\tsage: graphics_array([[]]).save(F)\n\n\t\t\"\"\"\n\t\tfrom matplotlib import rcParams\n\t\text = os.path.splitext(filename)[1].lower()\n\t\tif ext in ['', '.sobj']:\n\t\t\tSageObject.save(self, filename)\n\t\telif ext not in ALLOWED_EXTENSIONS:\n\t\t\traise ValueError(\"allowed file extensions for images are '\" +\n\t\t\t\t\t\t\t \"', '\".join(ALLOWED_EXTENSIONS) + \"'!\")\n\t\telse:\n\t\t\trc_backup = (rcParams['ps.useafm'], rcParams['pdf.use14corefonts'],\n\t\t\t\t\t\t rcParams['text.usetex'])  # save the rcParams\n\t\t\tfigure = self.matplotlib(figsize=figsize, **kwds)\n\t\t\ttransparent = kwds.get('transparent',\n\t\t\t\t\t\t\t\t   Graphics.SHOW_OPTIONS['transparent'])\n\t\t\tfig_tight = kwds.get('fig_tight',\n\t\t\t\t\t\t\t\t Graphics.SHOW_OPTIONS['fig_tight'])\n\t\t\tdpi = kwds.get('dpi', Graphics.SHOW_OPTIONS['dpi'])\n\t\t\t# One can output in PNG, PS, EPS, PDF, PGF, or SVG format,\n\t\t\t# depending on the file extension.\n\t\t\t# PGF is handled by a different backend\n\t\t\tif ext == '.pgf':\n\t\t\t\tfrom sage.features.latex import xelatex,pdflatex,lualatex\n\t\t\t\tlatex_implementations = []\n\t\t\t\tif xelatex().is_present():\n\t\t\t\t\tlatex_implementations.append('xelatex')\n\t\t\t\tif pdflatex().is_present():\n\t\t\t\t\tlatex_implementations.append('pdflatex')\n\t\t\t\tif lualatex().is_present():\n\t\t\t\t\tlatex_implementations.append('lualatex')\n\t\t\t\tif not latex_implementations:\n\t\t\t\t\traise ValueError(\"Matplotlib requires either xelatex, \"\n\t\t\t\t\t\t\t\t\t \"lualatex, or pdflatex.\")\n\t\t\t\tif latex_implementations[0] == \"pdflatex\":\n\t\t\t\t\t# use pdflatex and set font encoding as per\n\t\t\t\t\t# Matplotlib documentation:\n\t\t\t\t\t# https://matplotlib.org/users/pgf.html#pgf-tutorial\n\t\t\t\t\tpgf_options = {\"pgf.texsystem\": \"pdflatex\",\n\t\t\t\t\t\t\t\t   \"pgf.preamble\": [\n\t\t\t\t\t\t\t\t\t  r\"\\usepackage[utf8x]{inputenc}\",\n\t\t\t\t\t\t\t\t\t  r\"\\usepackage[T1]{fontenc}\"\n\t\t\t\t\t\t\t\t\t  ]}\n\t\t\t\telse:\n\t\t\t\t\tpgf_options = {\"pgf.texsystem\": latex_implementations[0]}\n\t\t\t\trcParams.update(pgf_options)\n\t\t\t\tfrom matplotlib.backends.backend_pgf import FigureCanvasPgf\n\t\t\t\tfigure.set_canvas(FigureCanvasPgf(figure))\n\t\t\t# Matplotlib looks at the file extension to see what the renderer\n\t\t\t# should be. The default is FigureCanvasAgg for PNG's because this\n\t\t\t# is by far the most common type of files rendered, like in the\n\t\t\t# notebook, for example. If the file extension is not '.png', then\n\t\t\t# Matplotlib will handle it.\n\t\t\telse:\n\t\t\t\tfrom matplotlib.backends.backend_agg import FigureCanvasAgg\n\t\t\t\tfigure.set_canvas(FigureCanvasAgg(figure))\n\t\t\tif isinstance(self, GraphicsArray):\n\t\t\t\t# tight_layout adjusts the *subplot* parameters so ticks aren't\n\t\t\t\t# cut off, etc.\n\t\t\t\tfigure.tight_layout()\n\t\t\topts = dict(dpi=dpi, transparent=transparent)\n\t\t\tif fig_tight is True:\n\t\t\t\topts['bbox_inches'] = 'tight'\n\t\t\tfigure.savefig(filename, **opts)\n\t\t\t# Restore the rcParams to the original, possibly user-set values\n\t\t\t(rcParams['ps.useafm'], rcParams['pdf.use14corefonts'],\n\t\t\t rcParams['text.usetex']) = rc_backup\n\n\tdef save_image(self, filename=None, *args, **kwds):\n\t\tr\"\"\"\n\t\tSave an image representation of ``self``.  The image type is\n\t\tdetermined by the extension of the filename.  For example,\n\t\tthis could be ``.png``, ``.jpg``, ``.gif``, ``.pdf``,\n\t\t``.svg``.  Currently this is implemented by calling the\n\t\t:meth:`save` method of self, passing along all arguments and\n\t\tkeywords.\n\n\t\t.. NOTE::\n\n\t\t\tNot all image types are necessarily implemented for all\n\t\t\tgraphics types.  See :meth:`save` for more details.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: plots = [[plot(m*cos(x + n*pi/4), (x, 0, 2*pi))\n\t\t\t....:\t\t   for n in range(3)] for m in range(1,3)]\n\t\t\tsage: G = graphics_array(plots)\n\t\t\tsage: G.save_image(tmp_filename(ext='.png'))\n\n\t\t\"\"\"\n\t\tself.save(filename, *args, **kwds)\n\n\tdef _latex_(self, **kwds):\n\t\tr\"\"\"\n\t\tReturn a string plotting ``self`` with PGF.\n\n\t\tINPUT:\n\n\t\tAll keyword arguments will be passed to the plotter.\n\n\t\tOUTPUT:\n\n\t\tA string of PGF commands to plot ``self``\n\n\t\tEXAMPLES::\n\n\t\t\tsage: A = graphics_array([plot(sin), plot(cos)])\n\t\t\tsage: A._latex_()[:40]  # not tested (see comment below)\n\t\t\t'%% Creator: Matplotlib, PGF backend\\n%%\\n%'\n\n\t\tThe above doctest fails on macOS due to the following Matplotlib issue: https://github.com/matplotlib/matplotlib/issues/10307\n\n\t\t\"\"\"\n\t\ttmpfilename = tmp_filename(ext='.pgf')\n\t\tself.save(filename=tmpfilename, **kwds)\n\t\twith open(tmpfilename, \"r\") as tmpfile:\n\t\t\tlatex_list = tmpfile.readlines()\n\t\treturn ''.join(latex_list)\n\n\tdef show(self, **kwds):\n\t\tr\"\"\"\n\t\tShow ``self`` immediately.\n\n\t\tThis method attempts to display the graphics immediately,\n\t\twithout waiting for the currently running code (if any) to\n\t\treturn to the command line. Be careful, calling it from within\n\t\ta loop will potentially launch a large number of external\n\t\tviewer programs.\n\n\t\tOPTIONAL INPUT:\n\n\t\t- ``dpi`` -- dots per inch\n\n\t\t- ``figsize`` -- width or [width, height] of the figure, in inches; the\n\t\t  default is 6.4 x 4.8 inches\n\n\t\t- ``axes`` -- boolean; if ``True``, all individual graphics are\n\t\t  endowed with axes; if ``False``, all axes are removed (this overrides\n\t\t  the ``axes`` option set in each graphics)\n\n\t\t- ``frame`` -- boolean; if ``True``, all individual graphics are\n\t\t  drawn with a frame around them; if ``False``, all frames are removed\n\t\t  (this overrides the ``frame`` option set in each graphics)\n\n\t\t- ``fontsize`` -- positive integer, the size of fonts for the axes\n\t\t  labels (this overrides the ``fontsize`` option set in each graphics)\n\n\t\tOUTPUT:\n\n\t\tThis method does not return anything. Use :meth:`save` if you\n\t\twant to save the figure as an image.\n\n\t\tEXAMPLES:\n\n\t\tThis draws a graphics array with four trig plots and no axes in any of\n\t\tthe plots and a figure width of 4 inches::\n\n\t\t\tsage: G = graphics_array([[plot(sin), plot(cos)],\n\t\t\t....:\t\t\t\t\t [plot(tan), plot(sec)]])\n\t\t\tsage: G.show(axes=False, figsize=4)\n\n\t\t.. PLOT::\n\n\t\t\tG = graphics_array([[plot(sin), plot(cos)], \\\n\t\t\t\t\t\t\t\t[plot(tan), plot(sec)]])\n\t\t\tsphinx_plot(G, axes=False, figsize=4)\n\n\t\tSame thing with a frame around each individual graphics::\n\n\t\t\tsage: G.show(axes=False, frame=True, figsize=4)\n\n\t\t.. PLOT::\n\n\t\t\tG = graphics_array([[plot(sin), plot(cos)], \\\n\t\t\t\t\t\t\t\t[plot(tan), plot(sec)]])\n\t\t\tsphinx_plot(G, axes=False, frame=True, figsize=4)\n\n\t\tActually, many options are possible; for instance, we may set\n\t\t``fontsize`` and ``gridlines``::\n\n\t\t\tsage: G.show(axes=False, frame=True, figsize=4, fontsize=8,\n\t\t\t....:\t\tgridlines='major')\n\n\t\t.. PLOT::\n\n\t\t\tG = graphics_array([[plot(sin), plot(cos)], \\\n\t\t\t\t\t\t\t\t[plot(tan), plot(sec)]])\n\t\t\tsphinx_plot(G, axes=False, frame=True, figsize=4, fontsize=8, \\\n\t\t\t\t\t\tgridlines='major')\n\n\t\t\"\"\"\n\t\tfrom sage.repl.rich_output import get_display_manager\n\t\tdm = get_display_manager()\n\t\tdm.display_immediately(self, **kwds)\n\n\tdef plot(self):\n\t\tr\"\"\"\n\t\tReturn ``self`` since ``self`` is already a graphics object.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: g1 = plot(cos, 0, 1)\n\t\t\tsage: g2 = circle((0,0), 1)\n\t\t\tsage: G = multi_graphics([g1, g2])\n\t\t\tsage: G.plot() is G\n\t\t\tTrue\n\n\t\t\"\"\"\n\t\treturn self\n\n\tdef inset(self, graphics, pos=None, fontsize=None):\n\t\tr\"\"\"\n\t\tAdd a graphics object as an inset.\n\n\t\tINPUT:\n\n\t\t- ``graphics`` -- the graphics object (instance of :class:`Graphics`)\n\t\t  to be added as an inset\n\n\t\t- ``pos`` -- (default: ``None``) 4-tuple\n\t\t  ``(left, bottom, width, height)`` specifying the location and\n\t\t  relative size of the inset on the canvas, all quantities being\n\t\t  expressed in fractions of the canvas width and height; if ``None``,\n\t\t  the value ``(0.7, 0.7, 0.2, 0.2)`` is used\n\n\t\t- ``fontsize`` -- (default: ``None``)  integer, font size (in points)\n\t\t  for the inset; if ``None``, the value of 6 points is used, unless\n\t\t  ``fontsize`` has been explicitly set in the construction of\n\t\t  ``graphics`` (in this case, it is not overwritten here)\n\n\t\tOUTPUT:\n\n\t\t- instance of :class:`~sage.plot.multigraphics.MultiGraphics`\n\n\t\tEXAMPLES:\n\n\t\tLet us consider a graphics array of 2 elements::\n\n\t\t\tsage: G = graphics_array([plot(sin, (0, 2*pi)),\n\t\t\t....:\t\t\t\t\t plot(cos, (0, 2*pi))])\n\t\t\tsage: G\n\t\t\tGraphics Array of size 1 x 2\n\n\t\t.. PLOT::\n\n\t\t\tG = graphics_array([plot(sin, (0, 2*pi)), plot(cos, (0, 2*pi))])\n\t\t\tsphinx_plot(G)\n\n\t\tand add some inset at the default position::\n\n\t\t\tsage: c = circle((0,0), 1, color='red', thickness=2, frame=True)\n\t\t\tsage: G.inset(c)\n\t\t\tMultigraphics with 3 elements\n\n\t\t.. PLOT::\n\n\t\t\tG = graphics_array([plot(sin, (0, 2*pi)), plot(cos, (0, 2*pi))])\n\t\t\tc = circle((0,0), 1, color='red', thickness=2, frame=True)\n\t\t\tsphinx_plot(G.inset(c))\n\n\t\tWe may customize the position and font size of the inset::\n\n\t\t\tsage: G.inset(c, pos=(0.3, 0.7, 0.2, 0.2), fontsize=8)\n\t\t\tMultigraphics with 3 elements\n\n\t\t.. PLOT::\n\n\t\t\tG = graphics_array([plot(sin, (0, 2*pi)), plot(cos, (0, 2*pi))])\n\t\t\tc = circle((0,0), 1, color='red', thickness=2, frame=True)\n\t\t\tsphinx_plot(G.inset(c, pos=(0.3, 0.7, 0.2, 0.2), fontsize=8))\n\n\t\t\"\"\"\n\t\tif pos is None:\n\t\t\tpos = (0.7, 0.7, 0.2, 0.2)\n\t\tif fontsize is not None:\n\t\t\tgraphics._extra_kwds['fontsize'] = fontsize\n\t\telif 'fontsize' not in graphics._extra_kwds:\n\t\t\tgraphics._extra_kwds['fontsize'] = 6\n\t\tcurrent = []  # list of current pairs (graphics, position)\n\t\tfor i, g in enumerate(self._glist):\n\t\t\tcurrent.append((g, self.position(i)))\n\t\tresu = MultiGraphics(current)\n\t\tresu.append(graphics, pos=pos)\n\t\treturn resu\n\n\t#\n\t# Methods to reimplement in derived classes:\n\t#\n\tdef __str__(self):\n\t\tr\"\"\"\n\t\tString representation of ``self``\n\n\t\tEXAMPLES::\n\n\t\t\tsage: from sage.plot.multigraphics import MultiGraphics\n\t\t\tsage: G = MultiGraphics([])\n\t\t\tsage: G.__str__()\n\t\t\t'Multigraphics with 0 element'\n\t\t\tsage: str(G)\n\t\t\t'Multigraphics with 0 element'\n\t\t\tsage: c = circle((0,0), 1)\n\t\t\tsage: G = MultiGraphics([c])\n\t\t\tsage: str(G)\n\t\t\t'Multigraphics with 1 element'\n\t\t\tsage: G = MultiGraphics([c, c, c])\n\t\t\tsage: str(G)\n\t\t\t'Multigraphics with 3 elements'\n\n\t\t\"\"\"\n\t\tn = len(self._glist)\n\t\tif n <= 1:\n\t\t\treturn \"Multigraphics with {} element\".format(n)\n\t\treturn \"Multigraphics with {} elements\".format(n)\n\n\tdef _add_subplot(self, figure, index, **options):\n\t\tr\"\"\"\n\t\tAdd a subplot to a given Matplotlib ``Figure``, the position of\n\t\twhich is governed by a given element of ``self``.\n\n\t\tThis method encapsulates the Matplotlib method ``Figure.add_axes``\n\t\tand is intended to be called by :meth:`MultiGraphics.save`.\n\n\t\tINPUT:\n\n\t\t- ``figure`` -- a Matplotlib ``Figure`` object\n\t\t- ``index`` -- integer specifiying the element of ``self``\n\t\t- ``options`` -- extra options to be passed to ``Figure.add_axes``\n\n\t\tOUTPUT:\n\n\t\t- a Matplotlib ``Axes`` object\n\n\t\tEXAMPLES::\n\n\t\t\tsage: g0 = circle((0,0), 1)\n\t\t\tsage: g1 = plot(sin)\n\t\t\tsage: G = multi_graphics([g0, (g1, (0.2, 0.3, 0.4, 0.1))])\n\t\t\tsage: from matplotlib.figure import Figure\n\t\t\tsage: fig = Figure()\n\t\t\tsage: fig\n\t\t\t\n\t\t\tsage: ax0 = G._add_subplot(fig, 0)\n\t\t\tsage: type(ax0)\n\t\t\t\n\t\t\tsage: fig\n\t\t\t\n\t\t\tsage: ax1 = G._add_subplot(fig, 1)\n\t\t\tsage: fig\n\t\t\t\n\n\t\tTESTS::\n\n\t\t\tsage: [ax0, ax1] == fig.get_axes()\n\t\t\tTrue\n\t\t\tsage: G.position(1)\n\t\t\t(0.2, 0.3, 0.4, 0.1)\n\t\t\tsage: ax1.get_position().bounds  # tol 1.0e-13\n\t\t\t(0.2, 0.3, 0.4000000000000001, 0.10000000000000003)\n\n\t\t\"\"\"\n\t\t# Note: using label=str(index) ensures that a new Axes is generated\n\t\t# for each element of ``self``, even if some elements share the same\n\t\t# positions\n\t\treturn figure.add_axes(self._positions[index], label=str(index),\n\t\t\t\t\t\t\t   **options)\n\n\tdef position(self, index):\n\t\tr\"\"\"\n\t\tReturn the position and relative size of an element of ``self`` on the\n\t\tcanvas.\n\n\t\tINPUT:\n\n\t\t- ``index`` -- integer specifiying which element of ``self``\n\n\t\tOUTPUT:\n\n\t\t- a 4-tuple ``(left, bottom, width, height)`` giving the location and\n\t\t  relative size of the element on the canvas, all quantities being\n\t\t  expressed in fractions of the canvas width and height\n\n\t\tEXAMPLES::\n\n\t\t\tsage: g1 = plot(sin(x^2), (x, 0, 4))\n\t\t\tsage: g2 = circle((0,0), 1, rgbcolor='red', fill=True, axes=False)\n\t\t\tsage: G = multi_graphics([g1, (g2, (0.15, 0.2, 0.1, 0.15))])\n\t\t\tsage: G.position(0)  # tol 1.0e-13\n\t\t\t(0.125, 0.11, 0.775, 0.77)\n\t\t\tsage: G.position(1)  # tol 1.0e-13\n\t\t\t(0.15, 0.2, 0.1, 0.15)\n\n\t\t\"\"\"\n\t\treturn self._positions[index]\n\n\tdef append(self, graphics, pos=None):\n\t\tr\"\"\"\n\t\tAppend a graphics object to ``self``.\n\n\t\tINPUT:\n\n\t\t- ``graphics`` -- the graphics object (instance of :class:`Graphics`)\n\t\t  to be added to ``self``\n\n\t\t- ``pos`` -- (default: ``None``) 4-tuple\n\t\t  ``(left, bottom, width, height)`` specifying the location and size\n\t\t  of ``graphics`` on the canvas, all quantities being in fractions of\n\t\t  the canvas width and height; if ``None``, ``graphics`` is assumed to\n\t\t  occupy the whole canvas, except for some padding; this corresponds to\n\t\t  the default position\n\t\t  ``(left, bottom, width, height) = (0.125, 0.11, 0.775, 0.77)``\n\n\t\tEXAMPLES:\n\n\t\tLet us consider a multigraphics with 2 elements::\n\n\t\t\tsage: g1 = plot(chebyshev_T(4, x), (x, -1, 1), title='n=4')\n\t\t\tsage: g2 = plot(chebyshev_T(8, x), (x, -1, 1), title='n=8',\n\t\t\t....:\t\t   color='red')\n\t\t\tsage: G = multi_graphics([(g1, (0.125, 0.2, 0.4, 0.4)),\n\t\t\t....:\t\t\t\t\t (g2, (0.55, 0.4, 0.4, 0.4))])\n\t\t\tsage: G\n\t\t\tMultigraphics with 2 elements\n\n\t\t.. PLOT::\n\n\t\t\tg1 = plot(chebyshev_T(4, x), (x, -1, 1), title='n=4')\n\t\t\tg2 = plot(chebyshev_T(8, x), (x, -1, 1), title='n=8', color='red')\n\t\t\tG = multi_graphics([(g1, (0.125, 0.2, 0.4, 0.4)), \\\n\t\t\t\t\t\t\t\t(g2, (0.55, 0.4, 0.4, 0.4))])\n\t\t\tsphinx_plot(G)\n\n\t\tWe append a third plot to it::\n\n\t\t\tsage: g3 = plot(chebyshev_T(16, x), (x, -1, 1), title='n=16',\n\t\t\t....:\t\t   color='brown')\n\t\t\tsage: G.append(g3, pos=(0.55, 0.11, 0.4, 0.15))\n\t\t\tsage: G\n\t\t\tMultigraphics with 3 elements\n\n\t\t.. PLOT::\n\n\t\t\tg1 = plot(chebyshev_T(4, x), (x, -1, 1), title='n=4')\n\t\t\tg2 = plot(chebyshev_T(8, x), (x, -1, 1), title='n=8', color='red')\n\t\t\tG = multi_graphics([(g1, (0.125, 0.2, 0.4, 0.4)), \\\n\t\t\t\t\t\t\t\t(g2, (0.55, 0.4, 0.4, 0.4))])\n\t\t\tg3 = plot(chebyshev_T(16, x), (x, -1, 1), title='n=16', \\\n\t\t\t\t\t  color='brown')\n\t\t\tG.append(g3, pos=(0.55, 0.11, 0.4, 0.15))\n\t\t\tsphinx_plot(G)\n\n\t\tWe may use ``append`` to add a title::\n\n\t\t\tsage: title = text(\"Chebyshev polynomials\", (0, 0), fontsize=16,\n\t\t\t....:\t\t\t  axes=False)\n\t\t\tsage: G.append(title, pos=(0.18, 0.8, 0.7, 0.1))\n\t\t\tsage: G\n\t\t\tMultigraphics with 4 elements\n\n\t\t.. PLOT::\n\n\t\t\tg1 = plot(chebyshev_T(4, x), (x, -1, 1), title='n=4')\n\t\t\tg2 = plot(chebyshev_T(8, x), (x, -1, 1), title='n=8', color='red')\n\t\t\tG = multi_graphics([(g1, (0.125, 0.2, 0.4, 0.4)), \\\n\t\t\t\t\t\t\t\t(g2, (0.55, 0.4, 0.4, 0.4))])\n\t\t\tg3 = plot(chebyshev_T(16, x), (x, -1, 1), title='n=16', \\\n\t\t\t\t\t  color='brown')\n\t\t\tG.append(g3, pos=(0.55, 0.11, 0.4, 0.15))\n\t\t\ttitle = text(\"Chebyshev polynomials\", (0, 0), fontsize=16, \\\n\t\t\t\t\t\t axes=False)\n\t\t\tG.append(title, pos=(0.18, 0.8, 0.7, 0.1))\n\t\t\tsphinx_plot(G)\n\n\t\t.. SEEALSO::\n\n\t\t\t:meth:`inset`\n\n\t\t\"\"\"\n\t\tfrom matplotlib import rcParams\n\t\tif not isinstance(graphics, Graphics):\n\t\t\traise TypeError(\"a Graphics object is expected, \"\n\t\t\t\t\t\t\t\"not {}\".format(graphics))\n\t\tif pos is None:\n\t\t\t# Default position:\n\t\t\tleft = rcParams['figure.subplot.left']\n\t\t\tbottom = rcParams['figure.subplot.bottom']\n\t\t\twidth = rcParams['figure.subplot.right'] - left\n\t\t\theight = rcParams['figure.subplot.top'] - bottom\n\t\t\tpos = (left, bottom, width, height)\n\t\telif not isinstance(pos, (list, tuple)) or len(pos) != 4:\n\t\t\traise TypeError(\"pos must be a 4-tuple, not {}\".format(pos))\n\t\tpos = tuple(float(p) for p in pos)\n\t\tself._glist.append(graphics)\n\t\tself._positions.append(pos)\n\n", "description": "\n\tBase class for objects composed of :class:`~sage.plot.graphics.Graphics`\n\tobjects.\n\n\tBoth the display and the output to a file of ``MultiGraphics`` objects\n\tare governed by the method :meth:`save`, which is called by the rich output\n\tdisplay manager, via\n\t:meth:`~sage.repl.rich_output.display_manager.DisplayManager.graphics_from_save`.\n\n\tThe user interface is through the functions\n\t:func:`~sage.plot.plot.multi_graphics` (generic multi-graphics) and\n\t:func:`~sage.plot.plot.graphics_array` (subclass :class:`GraphicsArray`).\n\n\tINPUT:\n\n\t- ``graphics_list`` -- a list of graphics along with their positions on the\n\t  common canvas; each element of ``graphics_list`` is either\n\n\t  - a pair ``(graphics, position)``, where ``graphics`` is a\n\t\t:class:`~sage.plot.graphics.Graphics` object and ``position`` is the\n\t\t4-tuple ``(left, bottom, width, height)`` specifying the location and\n\t\tsize of the graphics on the canvas, all quantities being in fractions\n\t\tof the canvas width and height\n\n\t  - or a single :class:`~sage.plot.graphics.Graphics` object; its position\n\t\tis then assumed to occupy the whole canvas, except for some padding;\n\t\tthis corresponds to the default position\n\t\t``(left, bottom, width, height) = (0.125, 0.11, 0.775, 0.77)``\n\n\tEXAMPLES:\n\n\tA multi-graphics made from two graphics objects::\n\n\t\tsage: g1 = plot(sin(x^3), (x, -pi, pi))\n\t\tsage: g2 = circle((0,0), 1, color='red')\n\t\tsage: G = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tsage: G\n\t\tMultigraphics with 2 elements\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**3), (x, -pi, pi))\n\t\tg2 = circle((0,0), 1, color='red')\n\t\tG = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tsphinx_plot(G)\n\n\tSince no position was given for ``g1``, it occupies the whole canvas.\n\tMoreover, we note that ``g2`` has been drawn over ``g1`` with a white\n\tbackground. To have a transparent background instead, one has to construct\n\t``g2`` with the keyword ``transparent`` set to ``True``::\n\n\t\tsage: g2 = circle((0,0), 1, color='red', transparent=True)\n\t\tsage: G = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tsage: G\n\t\tMultigraphics with 2 elements\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**3), (x, -pi, pi))\n\t\tg2 = circle((0,0), 1, color='red', transparent=True)\n\t\tG = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tsphinx_plot(G)\n\n\tWe can add a new graphics object to G via the method :meth:`append`::\n\n\t\tsage: g3 = complex_plot(zeta, (-20, 10), (-20, 20),\n\t\t....:\t\t\t\t   axes_labels=['$x$', '$y$'], frame=True)\n\t\tsage: G.append(g3, pos=(0.63, 0.12, 0.3, 0.3))\n\t\tsage: G\n\t\tMultigraphics with 3 elements\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**3), (x, -pi, pi))\n\t\tg2 = circle((0,0), 1, color='red', transparent=True)\n\t\tG = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tg3 = complex_plot(zeta, (-20, 10), (-20, 20), \\\n\t\t\t\t\t\t  axes_labels=['$x$', '$y$'], frame=True)\n\t\tG.append(g3, pos=(0.63, 0.12, 0.3, 0.3))\n\t\tsphinx_plot(G)\n\n\tWe can access the individual elements composing ``G`` with the\n\tsquare-bracket operator::\n\n\t\tsage: print(G[0])\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: G[0] is g1\n\t\tTrue\n\t\tsage: G[1] is g2\n\t\tTrue\n\t\tsage: G[2] is g3\n\t\tTrue\n\n\t``G[:]`` returns the full list of graphics objects composing ``G``::\n\n\t\tsage: G[:]\n\t\t[Graphics object consisting of 1 graphics primitive,\n\t\t Graphics object consisting of 1 graphics primitive,\n\t\t Graphics object consisting of 1 graphics primitive]\n\t\tsage: len(G)\n\t\t3\n\n\t", "category": "graphics", "imports": ["import os", "from sage.misc.fast_methods import WithEqualityById", "from sage.structure.sage_object import SageObject", "from sage.misc.temporary_file import tmp_filename", "from .graphics import Graphics, ALLOWED_EXTENSIONS, _parse_figsize", "\t\t\tsage: from sage.plot.multigraphics import MultiGraphics", "\t\t\tsage: from sage.repl.rich_output import get_display_manager", "\t\t\tsage: import matplotlib.pyplot as plt", "\t\t\tsage: from matplotlib.figure import Figure", "\t\tfrom matplotlib.figure import Figure", "\t\tfrom matplotlib import rcParams", "\t\t\t\tfrom sage.features.latex import xelatex,pdflatex,lualatex", "\t\t\t\tfrom matplotlib.backends.backend_pgf import FigureCanvasPgf", "\t\t\t\tfrom matplotlib.backends.backend_agg import FigureCanvasAgg", "\t\tfrom sage.repl.rich_output import get_display_manager", "\t\t\tsage: from sage.plot.multigraphics import MultiGraphics", "\t\t\tsage: from matplotlib.figure import Figure", "\t\tfrom matplotlib import rcParams", "\t\t\tsage: from sage.plot.multigraphics import GraphicsArray", "\t\t\tsage: from matplotlib.figure import Figure", "\t\t\tsage: from sage.plot.multigraphics import GraphicsArray", "\t\t\tfrom matplotlib.backends.backend_agg import FigureCanvasAgg"]}, {"term": "class", "name": "GraphicsArray", "data": "class GraphicsArray(MultiGraphics):\n\tr\"\"\"\n\tThis class implements 2-dimensional graphical objects that constitute\n\tan array of :class:`~sage.plot.graphics.Graphics` drawn on a single\n\tcanvas.\n\n\tThe user interface is through the function\n\t:func:`~sage.plot.plot.graphics_array`.\n\n\tINPUT:\n\n\t- ``array`` -- either a list of lists of\n\t  :class:`~sage.plot.graphics.Graphics` elements (generic case) or a\n\t  single list of :class:`~sage.plot.graphics.Graphics` elements (case of a\n\t  single-row array)\n\n\tEXAMPLES:\n\n\tAn array made of four graphics objects::\n\n\t\tsage: g1 = plot(sin(x^2), (x, 0, 6), axes_labels=['$x$', '$y$'],\n\t\t....:\t\t   axes=False, frame=True, gridlines='minor')\n\t\tsage: y = var('y')\n\t\tsage: g2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3),\n\t\t....:\t\t\t\t\t  aspect_ratio=1)\n\t\tsage: g3 = graphs.DodecahedralGraph().plot()\n\t\tsage: g4 = polar_plot(sin(5*x)^2, (x, 0, 2*pi), color='green',\n\t\t....:\t\t\t\t fontsize=8) \\\n\t\t....:\t  + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1,\n\t\t....:\t\t\t   legend_label='pink')\n\t\tsage: g4.set_legend_options(loc='upper right')\n\t\tsage: G = graphics_array([[g1, g2], [g3, g4]])\n\t\tsage: G\n\t\tGraphics Array of size 2 x 2\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**2), (x, 0, 6), axes_labels=['$x$', '$y$'], \\\n\t\t\t\t  axes=False, frame=True, gridlines='minor')\n\t\ty = var('y')\n\t\tg2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3), \\\n\t\t\t\t\t\t\t aspect_ratio=1)\n\t\tg3 = graphs.DodecahedralGraph().plot()\n\t\tg4 = polar_plot(sin(5*x)**2, (x, 0, 2*pi), color='green', fontsize=8) \\\n\t\t\t + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1, \\\n\t\t\t\t\t  legend_label='pink')\n\t\tg4.set_legend_options(loc='upper right')\n\t\tG = graphics_array([[g1, g2], [g3, g4]])\n\t\tsphinx_plot(G)\n\n\tIf one constructs the graphics array from a single list of graphics\n\tobjects, one obtains a single-row array::\n\n\t\tsage: G = graphics_array([g1, g2, g3, g4])\n\t\tsage: G\n\t\tGraphics Array of size 1 x 4\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**2), (x, 0, 6), axes_labels=['$x$', '$y$'], \\\n\t\t\t\t  axes=False, frame=True, gridlines='minor')\n\t\ty = var('y')\n\t\tg2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3), \\\n\t\t\t\t\t\t\t aspect_ratio=1)\n\t\tg3 = graphs.DodecahedralGraph().plot()\n\t\tg4 = polar_plot(sin(5*x)**2, (x, 0, 2*pi), color='green', fontsize=8) \\\n\t\t\t + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1, \\\n\t\t\t\t\t  legend_label='pink')\n\t\tg4.set_legend_options(loc='upper right')\n\t\tG = graphics_array([g1, g2, g3, g4])\n\t\tsphinx_plot(G)\n\n\tWe note that the overall aspect ratio of the figure is 4/3 (the default),\n\twhich makes ``g1`` elongated, while the aspect ratio of ``g2``, which has\n\tbeen specified with the parameter ``aspect_ratio=1`` is preserved. To get\n\ta better aspect ratio for the whole figure, one can use the option\n\t``figsize`` in the method :meth:`~MultiGraphics.show`::\n\n\t\tsage: G.show(figsize=[8, 3])\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**2), (x, 0, 6), axes_labels=['$x$', '$y$'], \\\n\t\t\t\t  axes=False, frame=True, gridlines='minor')\n\t\ty = var('y')\n\t\tg2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3), \\\n\t\t\t\t\t\t\t aspect_ratio=1)\n\t\tg3 = graphs.DodecahedralGraph().plot()\n\t\tg4 = polar_plot(sin(5*x)**2, (x, 0, 2*pi), color='green', fontsize=8) \\\n\t\t\t + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1, \\\n\t\t\t\t\t  legend_label='pink')\n\t\tg4.set_legend_options(loc='upper right')\n\t\tG = graphics_array([g1, g2, g3, g4])\n\t\tsphinx_plot(G, figsize=[8, 3])\n\n\tWe can access individual elements of the graphics array with the\n\tsquare-bracket operator::\n\n\t\tsage: G = graphics_array([[g1, g2], [g3, g4]])  # back to the 2x2 array\n\t\tsage: print(G)\n\t\tGraphics Array of size 2 x 2\n\t\tsage: G[0] is g1\n\t\tTrue\n\t\tsage: G[1] is g2\n\t\tTrue\n\t\tsage: G[2] is g3\n\t\tTrue\n\t\tsage: G[3] is g4\n\t\tTrue\n\n\tNote that with respect to the square-bracket operator, ``G`` is considered\n\tas a flattened list of graphics objects, not as an array. For instance,\n\t``G[0, 1]`` throws an error::\n\n\t\tsage: G[0, 1]\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tTypeError: list indices must be integers or slices, not tuple\n\n\t``G[:]`` returns the full (flattened) list of graphics objects composing\n\t``G``::\n\n\t\tsage: G[:]\n\t\t[Graphics object consisting of 1 graphics primitive,\n\t\tGraphics object consisting of 1 graphics primitive,\n\t\tGraphics object consisting of 51 graphics primitives,\n\t\tGraphics object consisting of 2 graphics primitives]\n\n\tThe total number of Graphics objects composing the array is returned\n\tby the function ``len``::\n\n\t\tsage: len(G)\n\t\t4\n\n\tThe square-bracket operator can be used to replace elements in the array::\n\n\t\tsage: G[0] = g4\n\t\tsage: G\n\t\tGraphics Array of size 2 x 2\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**2), (x, 0, 6), axes_labels=['$x$', '$y$'], \\\n\t\t\t\t  axes=False, frame=True, gridlines='minor')\n\t\ty = var('y')\n\t\tg2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3), \\\n\t\t\t\t\t\t\t aspect_ratio=1)\n\t\tg3 = graphs.DodecahedralGraph().plot()\n\t\tg4 = polar_plot(sin(5*x)**2, (x, 0, 2*pi), color='green', fontsize=8) \\\n\t\t\t + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1, \\\n\t\t\t\t\t  legend_label='pink')\n\t\tg4.set_legend_options(loc='upper right')\n\t\tG = graphics_array([[g1, g2], [g3, g4]])\n\t\tG[0] = g4\n\t\tsphinx_plot(G)\n\n\t\"\"\"\n\tdef __init__(self, array):\n\t\tr\"\"\"\n\t\tConstruct a ``GraphicsArray``.\n\n\t\tTESTS::\n\n\t\t\tsage: from sage.plot.multigraphics import GraphicsArray\n\t\t\tsage: g = circle((0,0), 1)  # a Graphics object\n\t\t\tsage: G = GraphicsArray([[g, g], [g, g]])\n\t\t\tsage: print(G)\n\t\t\tGraphics Array of size 2 x 2\n\n\t\tConstruction from a single list ==> 1-row array::\n\n\t\t\tsage: G = GraphicsArray([g, g, g])\n\t\t\tsage: print(G)\n\t\t\tGraphics Array of size 1 x 3\n\t\t\tsage: G = GraphicsArray([g])\n\t\t\tsage: print(G)\n\t\t\tGraphics Array of size 1 x 1\n\n\t\tEmpty array::\n\n\t\t\tsage: G = GraphicsArray([])\n\t\t\tsage: print(G)\n\t\t\tGraphics Array of size 0 x 0\n\t\t\tsage: len(G)\n\t\t\t0\n\t\t\tsage: G = GraphicsArray([[]])\n\t\t\tsage: print(G)\n\t\t\tGraphics Array of size 1 x 0\n\t\t\tsage: len(G)\n\t\t\t0\n\n\t\tCheck treatment of wrong inputs::\n\n\t\t\tsage: G = GraphicsArray([[g, g], [g]])\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tTypeError: array must be a list of equal-size lists of Graphics\n\t\t\t objects, not [[Graphics object consisting of 1 graphics primitive,\n\t\t\t Graphics object consisting of 1 graphics primitive],\n\t\t\t [Graphics object consisting of 1 graphics primitive]]\n\t\t\tsage: G = GraphicsArray(g)\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tTypeError: array must be a list of lists of Graphics objects, not\n\t\t\t Graphics object consisting of 1 graphics primitive\n\t\t\tsage: G = GraphicsArray([g, x])\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tTypeError: every element of array must be a Graphics object\n\n\t\t\"\"\"\n\t\tMultiGraphics.__init__(self, [])\n\t\tif not isinstance(array, (list, tuple)):\n\t\t\traise TypeError(\"array must be a list of lists of Graphics \"\n\t\t\t\t\t\t\t\"objects, not {}\".format(array))\n\t\tarray = list(array)\n\t\tself._rows = len(array)\n\t\tif self._rows > 0:\n\t\t\tif not isinstance(array[0], (list, tuple)):\n\t\t\t\tarray = [array]\n\t\t\t\tself._rows = 1\n\t\t\tself._cols = len(array[0])\n\t\telse:\n\t\t\tself._cols = 0\n\t\tfor row in array:  # basically flatten the list\n\t\t\tif not isinstance(row, (list, tuple)) or len(row) != self._cols:\n\t\t\t\traise TypeError(\"array must be a list of equal-size lists of \"\n\t\t\t\t\t\t\t\t\"Graphics objects, not {}\".format(array))\n\t\t\tfor g in row:\n\t\t\t\tif not isinstance(g, Graphics):\n\t\t\t\t\traise TypeError(\"every element of array must be a \"\n\t\t\t\t\t\t\t\t\t\"Graphics object\")\n\t\t\t\tself._glist.append(g)\n\t\t# self._positions is not initialized since most of the time, it is not\n\t\t# not used. It is required only by the method inset(); it is then\n\t\t# initialized by the method position().\n\n\tdef __str__(self):\n\t\tr\"\"\"\n\t\tString representation of the graphics array.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: c = circle((0,0), 1)\n\t\t\tsage: G = graphics_array([c]*6, 2, 3)\n\t\t\tsage: G.__str__()\n\t\t\t'Graphics Array of size 2 x 3'\n\t\t\tsage: str(G)\n\t\t\t'Graphics Array of size 2 x 3'\n\n\t\t\"\"\"\n\t\treturn \"Graphics Array of size {} x {}\".format(self._rows, self._cols)\n\n\tdef _add_subplot(self, figure, index, **options):\n\t\tr\"\"\"\n\t\tAdd a subplot to a given Matplotlib ``Figure``, the position of\n\t\twhich is governed by a given element of ``self``.\n\n\t\tThis method encapsulates the Matplotlib method ``Figure.add_subplot``\n\t\tand is intended to be called by :meth:`MultiGraphics.save`.\n\n\t\tINPUT:\n\n\t\t- ``figure`` -- a Matplotlib ``Figure`` object\n\t\t- ``index`` -- integer specifiying the element of ``self``\n\t\t- ``options`` -- extra options to be passed to ``Figure.add_subplot``\n\n\t\tOUTPUT:\n\n\t\t- a Matplotlib ``Axes`` object\n\n\t\tEXAMPLES::\n\n\t\t\tsage: c = circle((0,0), 1)\n\t\t\tsage: G = graphics_array([c, c])\n\t\t\tsage: from matplotlib.figure import Figure\n\t\t\tsage: fig = Figure()\n\t\t\tsage: ax1 = G._add_subplot(fig, 0)\n\t\t\tsage: type(ax1)\n\t\t\t\n\t\t\tsage: ax2 = G._add_subplot(fig, 1)\n\t\t\tsage: fig.get_axes() == [ax1, ax2]\n\t\t\tTrue\n\n\t\t\"\"\"\n\t\tif self._rows == 0 or self._cols == 0:\n\t\t\trows = 1\n\t\t\tcols = 1\n\t\telse:\n\t\t\trows = self._rows\n\t\t\tcols = self._cols\n\t\t# index --> index + 1 for Figure.add_subplot:\n\t\treturn figure.add_subplot(rows, cols, index + 1, **options)\n\n\tdef nrows(self):\n\t\tr\"\"\"\n\t\tNumber of rows of the graphics array.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: R = rainbow(6)\n\t\t\tsage: L = [plot(x^n, (x,0,1), color=R[n]) for n in range(6)]\n\t\t\tsage: G = graphics_array(L, 2, 3)\n\t\t\tsage: G.nrows()\n\t\t\t2\n\t\t\tsage: graphics_array(L).nrows()\n\t\t\t1\n\n\t\t\"\"\"\n\t\treturn self._rows\n\n\tdef ncols(self):\n\t\tr\"\"\"\n\t\tNumber of columns of the graphics array.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: R = rainbow(6)\n\t\t\tsage: L = [plot(x^n, (x,0,1), color=R[n]) for n in range(6)]\n\t\t\tsage: G = graphics_array(L, 2, 3)\n\t\t\tsage: G.ncols()\n\t\t\t3\n\t\t\tsage: graphics_array(L).ncols()\n\t\t\t6\n\t\t\"\"\"\n\t\treturn self._cols\n\n\tdef append(self, g):\n\t\tr\"\"\"\n\t\tAppend a graphics to the array.\n\n\t\tCurrently not implemented.\n\n\t\tTESTS::\n\n\t\t\tsage: from sage.plot.multigraphics import GraphicsArray\n\t\t\tsage: c = circle((0,0), 1)\n\t\t\tsage: G = GraphicsArray([c, c])\n\t\t\tsage: G.append(c)\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tNotImplementedError: Appending to a graphics array is not yet\n\t\t\t implemented\n\n\t\t\"\"\"\n\t\t# Not clear if there is a way to do this\n\t\traise NotImplementedError('Appending to a graphics array is not '\n\t\t\t\t\t\t\t\t  'yet implemented')\n\n\tdef position(self, index):\n\t\tr\"\"\"\n\t\tReturn the position and relative size of an element of ``self`` on the\n\t\tcanvas.\n\n\t\tINPUT:\n\n\t\t- ``index`` -- integer specifiying which element of ``self``\n\n\t\tOUTPUT:\n\n\t\t- a 4-tuple ``(left, bottom, width, height)`` giving the location and\n\t\t  relative size of the element on the canvas, all quantities being\n\t\t  expressed in fractions of the canvas width and height\n\n\t\tEXAMPLES::\n\n\t\t\tsage: g1 = plot(sin(x), (x, -pi, pi))\n\t\t\tsage: g2 = circle((0,1), 1.)\n\t\t\tsage: G = graphics_array([g1, g2])\n\t\t\tsage: G.position(0)  # tol 5.0e-3\n\t\t\t(0.025045451349937315,\n\t\t\t 0.03415488992713045,\n\t\t\t 0.4489880779745068,\n\t\t\t 0.9345951100728696)\n\t\t\tsage: G.position(1)  # tol 5.0e-3\n\t\t\t(0.5170637412999687,\n\t\t\t 0.20212705964722733,\n\t\t\t 0.4489880779745068,\n\t\t\t 0.5986507706326758)\n\n\t\t\"\"\"\n\t\tif not self._positions:\n\t\t\t# self._positions must be generated, by invoking get_position() on\n\t\t\t# each of the Axes of the Matplotlib figure corresponding to self:\n\t\t\tfrom matplotlib.backends.backend_agg import FigureCanvasAgg\n\t\t\tfigure = self.matplotlib()\n\t\t\tfigure.set_canvas(FigureCanvasAgg(figure))\n\t\t\tfigure.tight_layout()\n\t\t\taxes = figure.get_axes()\n\t\t\tself._positions = [ax.get_position().bounds for ax in axes]\n\t\treturn self._positions[index]\n", "description": "\n\tThis class implements 2-dimensional graphical objects that constitute\n\tan array of :class:`~sage.plot.graphics.Graphics` drawn on a single\n\tcanvas.\n\n\tThe user interface is through the function\n\t:func:`~sage.plot.plot.graphics_array`.\n\n\tINPUT:\n\n\t- ``array`` -- either a list of lists of\n\t  :class:`~sage.plot.graphics.Graphics` elements (generic case) or a\n\t  single list of :class:`~sage.plot.graphics.Graphics` elements (case of a\n\t  single-row array)\n\n\tEXAMPLES:\n\n\tAn array made of four graphics objects::\n\n\t\tsage: g1 = plot(sin(x^2), (x, 0, 6), axes_labels=['$x$', '$y$'],\n\t\t....:\t\t   axes=False, frame=True, gridlines='minor')\n\t\tsage: y = var('y')\n\t\tsage: g2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3),\n\t\t....:\t\t\t\t\t  aspect_ratio=1)\n\t\tsage: g3 = graphs.DodecahedralGraph().plot()\n\t\tsage: g4 = polar_plot(sin(5*x)^2, (x, 0, 2*pi), color='green',\n\t\t....:\t\t\t\t fontsize=8) \\\n\t\t....:\t  + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1,\n\t\t....:\t\t\t   legend_label='pink')\n\t\tsage: g4.set_legend_options(loc='upper right')\n\t\tsage: G = graphics_array([[g1, g2], [g3, g4]])\n\t\tsage: G\n\t\tGraphics Array of size 2 x 2\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**2), (x, 0, 6), axes_labels=['$x$', '$y$'], \\\n\t\t\t\t  axes=False, frame=True, gridlines='minor')\n\t\ty = var('y')\n\t\tg2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3), \\\n\t\t\t\t\t\t\t aspect_ratio=1)\n\t\tg3 = graphs.DodecahedralGraph().plot()\n\t\tg4 = polar_plot(sin(5*x)**2, (x, 0, 2*pi), color='green', fontsize=8) \\\n\t\t\t + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1, \\\n\t\t\t\t\t  legend_label='pink')\n\t\tg4.set_legend_options(loc='upper right')\n\t\tG = graphics_array([[g1, g2], [g3, g4]])\n\t\tsphinx_plot(G)\n\n\tIf one constructs the graphics array from a single list of graphics\n\tobjects, one obtains a single-row array::\n\n\t\tsage: G = graphics_array([g1, g2, g3, g4])\n\t\tsage: G\n\t\tGraphics Array of size 1 x 4\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**2), (x, 0, 6), axes_labels=['$x$', '$y$'], \\\n\t\t\t\t  axes=False, frame=True, gridlines='minor')\n\t\ty = var('y')\n\t\tg2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3), \\\n\t\t\t\t\t\t\t aspect_ratio=1)\n\t\tg3 = graphs.DodecahedralGraph().plot()\n\t\tg4 = polar_plot(sin(5*x)**2, (x, 0, 2*pi), color='green', fontsize=8) \\\n\t\t\t + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1, \\\n\t\t\t\t\t  legend_label='pink')\n\t\tg4.set_legend_options(loc='upper right')\n\t\tG = graphics_array([g1, g2, g3, g4])\n\t\tsphinx_plot(G)\n\n\tWe note that the overall aspect ratio of the figure is 4/3 (the default),\n\twhich makes ``g1`` elongated, while the aspect ratio of ``g2``, which has\n\tbeen specified with the parameter ``aspect_ratio=1`` is preserved. To get\n\ta better aspect ratio for the whole figure, one can use the option\n\t``figsize`` in the method :meth:`~MultiGraphics.show`::\n\n\t\tsage: G.show(figsize=[8, 3])\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**2), (x, 0, 6), axes_labels=['$x$', '$y$'], \\\n\t\t\t\t  axes=False, frame=True, gridlines='minor')\n\t\ty = var('y')\n\t\tg2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3), \\\n\t\t\t\t\t\t\t aspect_ratio=1)\n\t\tg3 = graphs.DodecahedralGraph().plot()\n\t\tg4 = polar_plot(sin(5*x)**2, (x, 0, 2*pi), color='green', fontsize=8) \\\n\t\t\t + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1, \\\n\t\t\t\t\t  legend_label='pink')\n\t\tg4.set_legend_options(loc='upper right')\n\t\tG = graphics_array([g1, g2, g3, g4])\n\t\tsphinx_plot(G, figsize=[8, 3])\n\n\tWe can access individual elements of the graphics array with the\n\tsquare-bracket operator::\n\n\t\tsage: G = graphics_array([[g1, g2], [g3, g4]])  # back to the 2x2 array\n\t\tsage: print(G)\n\t\tGraphics Array of size 2 x 2\n\t\tsage: G[0] is g1\n\t\tTrue\n\t\tsage: G[1] is g2\n\t\tTrue\n\t\tsage: G[2] is g3\n\t\tTrue\n\t\tsage: G[3] is g4\n\t\tTrue\n\n\tNote that with respect to the square-bracket operator, ``G`` is considered\n\tas a flattened list of graphics objects, not as an array. For instance,\n\t``G[0, 1]`` throws an error::\n\n\t\tsage: G[0, 1]\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tTypeError: list indices must be integers or slices, not tuple\n\n\t``G[:]`` returns the full (flattened) list of graphics objects composing\n\t``G``::\n\n\t\tsage: G[:]\n\t\t[Graphics object consisting of 1 graphics primitive,\n\t\tGraphics object consisting of 1 graphics primitive,\n\t\tGraphics object consisting of 51 graphics primitives,\n\t\tGraphics object consisting of 2 graphics primitives]\n\n\tThe total number of Graphics objects composing the array is returned\n\tby the function ``len``::\n\n\t\tsage: len(G)\n\t\t4\n\n\tThe square-bracket operator can be used to replace elements in the array::\n\n\t\tsage: G[0] = g4\n\t\tsage: G\n\t\tGraphics Array of size 2 x 2\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**2), (x, 0, 6), axes_labels=['$x$', '$y$'], \\\n\t\t\t\t  axes=False, frame=True, gridlines='minor')\n\t\ty = var('y')\n\t\tg2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3), \\\n\t\t\t\t\t\t\t aspect_ratio=1)\n\t\tg3 = graphs.DodecahedralGraph().plot()\n\t\tg4 = polar_plot(sin(5*x)**2, (x, 0, 2*pi), color='green', fontsize=8) \\\n\t\t\t + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1, \\\n\t\t\t\t\t  legend_label='pink')\n\t\tg4.set_legend_options(loc='upper right')\n\t\tG = graphics_array([[g1, g2], [g3, g4]])\n\t\tG[0] = g4\n\t\tsphinx_plot(G)\n\n\t", "category": "graphics", "imports": ["import os", "from sage.misc.fast_methods import WithEqualityById", "from sage.structure.sage_object import SageObject", "from sage.misc.temporary_file import tmp_filename", "from .graphics import Graphics, ALLOWED_EXTENSIONS, _parse_figsize", "\t\t\tsage: from sage.plot.multigraphics import MultiGraphics", "\t\t\tsage: from sage.repl.rich_output import get_display_manager", "\t\t\tsage: import matplotlib.pyplot as plt", "\t\t\tsage: from matplotlib.figure import Figure", "\t\tfrom matplotlib.figure import Figure", "\t\tfrom matplotlib import rcParams", "\t\t\t\tfrom sage.features.latex import xelatex,pdflatex,lualatex", "\t\t\t\tfrom matplotlib.backends.backend_pgf import FigureCanvasPgf", "\t\t\t\tfrom matplotlib.backends.backend_agg import FigureCanvasAgg", "\t\tfrom sage.repl.rich_output import get_display_manager", "\t\t\tsage: from sage.plot.multigraphics import MultiGraphics", "\t\t\tsage: from matplotlib.figure import Figure", "\t\tfrom matplotlib import rcParams", "\t\t\tsage: from sage.plot.multigraphics import GraphicsArray", "\t\t\tsage: from matplotlib.figure import Figure", "\t\t\tsage: from sage.plot.multigraphics import GraphicsArray", "\t\t\tfrom matplotlib.backends.backend_agg import FigureCanvasAgg"]}], [], [{"term": "class", "name": "classgraphics_data:\r", "data": "class graphics_data:\r\n\tresolution_x = 1280\r\n\tresolution_y = 800\r\n\tfactor_x = int(resolution_x/320)\r\n\tfactor_y = int(resolution_y/200)\r\n\ttile_w = 16*factor_x\r\n\ttile_h = 16*factor_y\r\n\tscroll_x = 0.0\r\n\tscroll_y = 0.0\r\n\ttilemap_width = 1\r\n\ttilemap_height = 1\r\n\ttilemap = [0]\r\n\tsprite_x = [0 for i in range(256)]\r\n\tsprite_y = [0 for i in range(256)]\r\n\tsprite_c = [0 for i in range(256)]\r\n\tsprite_s = [0 for i in range(256)]\r\n\tsprites = 0\r\n\ti = 0\r\n\r\n\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "init_video", "data": "def init_video():\r\n\tgraphics = graphics_data()\r\n\tpygame.init()\r\n\tgraphics.screen = pygame.display.set_mode((graphics.resolution_x,graphics.resolution_y), pygame.FULLSCREEN|pygame.HWSURFACE|pygame.DOUBLEBUF, 32)\r\n\tgraphics.tileset = pygame.Surface((256*graphics.factor_x, 256*graphics.factor_y), pygame.HWSURFACE, 32)\r\n\tgraphics.tileset.fill((255, 0, 255))\r\n\tgraphics.spriteset = pygame.Surface((256*graphics.factor_x, 512*graphics.factor_y), pygame.HWSURFACE, 32)\r\n\tgraphics.spriteset.fill((255, 0, 255))\r\n\tgraphics.spriteset.set_colorkey((255, 0, 255, 255))\r\n\tf = data.load(\"tileset.png\")\r\n\tload_tileset(f, graphics)\r\n\r\n\t\r\n\treturn graphics\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "load_tileset", "data": "def load_tileset(file, graphics):\r\n\timg = pygame.image.load(file)\r\n\tbuff = pygame.Surface((256*graphics.factor_x, 256*graphics.factor_y), pygame.HWSURFACE, 32)\r\n\timg.convert(32, pygame.HWSURFACE)\r\n\ti = 0\r\n\twhile i < 256*graphics.factor_x:\r\n\t\tbuff.blit(img, (i, 0), (i/graphics.factor_x, 0, 1, 256))\r\n\t\ti += 1\r\n\ti = 0\r\n\twhile i < 256*graphics.factor_y:\r\n\t\tgraphics.tileset.blit(buff, (0, i), (0, i/graphics.factor_y, 256*graphics.factor_x, 1))\r\n\t\ti += 1\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "load_spriteset", "data": "def load_spriteset(file, graphics):\r\n\timg = pygame.image.load(file)\r\n\tbuff = pygame.Surface((256*graphics.factor_x, 512*graphics.factor_y), pygame.HWSURFACE, 32)\r\n\timg.convert(32, pygame.HWSURFACE)\r\n\ti = 0\r\n\twhile i < 256*graphics.factor_x:\r\n\t\tbuff.blit(img, (i, 256), (i/graphics.factor_x, 0, 1, 256))\r\n\t\tbuff.blit(img, (i, 0), (15 - ((i/graphics.factor_x)%16) + (i/graphics.factor_x/16)*16, 0, 1, 256))\r\n\t\ti += 1\r\n\ti = 0\r\n\twhile i < 256*graphics.factor_y:\r\n\t\tgraphics.spriteset.blit(buff, (0, i), (0, i/graphics.factor_y, 256*graphics.factor_x, 1))\r\n\t\tgraphics.spriteset.blit(buff, (0, i+256*graphics.factor_y), (0, i/graphics.factor_y + 256, 256*graphics.factor_x, 1))\r\n\t\ti += 1\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "draw_sprite", "data": "def draw_sprite(c, x, y, graphics):\r\n\tif graphics.sprites < 256:\r\n\t\tgraphics.sprite_x[graphics.sprites] = x\r\n\t\tgraphics.sprite_y[graphics.sprites] = y\r\n\t\tgraphics.sprite_c[graphics.sprites] = c\r\n\t\tgraphics.sprite_s[graphics.sprites] = 1\r\n\t\tgraphics.sprites += 1\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "draw_sprite_multi", "data": "def draw_sprite_multi(c, x, y, w, h, graphics):\r\n\ti3 = 0\r\n\ti2 = 0\r\n\twhile i2 < h:\r\n\t\ti = 0\r\n\t\twhile i < w:\r\n\t\t\tif graphics.sprites < 256:\r\n\t\t\t\tgraphics.sprite_x[graphics.sprites] = x + i*16\r\n\t\t\t\tgraphics.sprite_y[graphics.sprites] = y + i2*16\r\n\t\t\t\tgraphics.sprite_c[graphics.sprites] = c + i3\r\n\t\t\t\tgraphics.sprite_s[graphics.sprites] = 1\r\n\t\t\t\tgraphics.sprites += 1\r\n\t\t\ti3 += 1\r\n\t\t\ti += 1\r\n\t\ti2 += 1\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "draw_sprite_static", "data": "def draw_sprite_static(c, x, y, graphics):\r\n\tif graphics.sprites < 256:\r\n\t\tgraphics.sprite_x[graphics.sprites] = x\r\n\t\tgraphics.sprite_y[graphics.sprites] = y\r\n\t\tgraphics.sprite_c[graphics.sprites] = c\r\n\t\tgraphics.sprite_s[graphics.sprites] = 0\r\n\t\tgraphics.sprites += 1\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "draw_sprite_static_multi", "data": "def draw_sprite_static_multi(c, x, y, w, h, graphics):\r\n\ti3 = 0\r\n\ti2 = 0\r\n\twhile i2 < h:\r\n\t\ti = 0\r\n\t\twhile i < w:\r\n\t\t\tif graphics.sprites < 256:\r\n\t\t\t\tgraphics.sprite_x[graphics.sprites] = x + i*16\r\n\t\t\t\tgraphics.sprite_y[graphics.sprites] = y + i2*16\r\n\t\t\t\tgraphics.sprite_c[graphics.sprites] = c + i3\r\n\t\t\t\tgraphics.sprite_s[graphics.sprites] = 0\r\n\t\t\t\tgraphics.sprites += 1\r\n\t\t\ti3 += 1\r\n\t\t\ti += 1\r\n\t\ti2 += 1\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "free_video", "data": "def free_video():\r\n\tpygame.display.quit()\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "draw_screen", "data": "def draw_screen(graphics):\r\n\tx = 0\r\n\ttile_x = int(graphics.scroll_x/16)\r\n\twhile x < 21:\r\n\t\ty = 0\r\n\t\ttile_y = int(graphics.scroll_y/16)\r\n\t\twhile y < 14:\r\n\t\t\tif tile_x < graphics.tilemap_width \\\r\n\t\t\t  and tile_y < graphics.tilemap_height \\\r\n\t\t\t  and tile_x >= 0 \\\r\n\t\t\t  and tile_y >= 0:\r\n\t\t\t\ttile = graphics.tilemap[tile_y * graphics.tilemap_width + tile_x]\r\n\t\t\t\tgraphics.screen.blit(graphics.tileset, (x*graphics.tile_w - (graphics.scroll_x % 16)*graphics.factor_x, y*graphics.tile_h - (graphics.scroll_y % 16)*graphics.factor_y), ((tile%16)*graphics.tile_w, (tile/16)*graphics.tile_h, graphics.tile_w, graphics.tile_h))\r\n\t\t\ty += 1\r\n\t\t\ttile_y += 1\r\n\t\tx += 1\r\n\t\ttile_x += 1\r\n\ti=0\r\n\twhile i < graphics.sprites:\r\n\t\tgraphics.screen.blit(graphics.spriteset, ((graphics.sprite_x[i] - graphics.scroll_x*graphics.sprite_s[i])*graphics.factor_x, (graphics.sprite_y[i] - graphics.scroll_y*graphics.sprite_s[i])*graphics.factor_y), ((graphics.sprite_c[i]%16)*graphics.tile_w, (graphics.sprite_c[i]/16)*graphics.tile_h, graphics.tile_w, graphics.tile_h))\r\n\t\ti += 1\r\n\tgraphics.sprites = 0\r\n\t\r\n\tpygame.display.flip()\r\n\t\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}], [{"term": "def", "name": "extract_client_from_request", "data": "def extract_client_from_request(req_data):\n\tclient = []\n\tProcessor = req_data['Processor']\n\tscreen = req_data['Screen Size(inch)']\n\tram = req_data['RAM(GB)']\n\tgraphics = req_data['Graphics Card']\n\tssd = req_data['SSD(GB)']\n\thdd = req_data['HDD(GB)']\n\tos = req_data['OS']\n\tnormal = req_data['Normal']\n\n\t# evaluation\n\ttry:\n\t\tif (Processor.includes(\"cpu\") or\n\t\t\tProcessor.includes(\"intel\") or Processor.includes(\"xeon\") or\n\t\t\tProcessor.includes(\" e\") or Processor.includes(\"i3\") or\n\t\t\tProcessor.includes(\"i5\") or Processor.includes(\"i7\") or\n\t\t\tProcessor.includes(\"i9\") or Processor.includes(\"amd\") or\n\t\t\tProcessor.includes(\"ryzen\") or Processor.includes(\"r3\") or\n\t\t\tProcessor.includes(\"r 3\") or Processor.includes(\"r5\") or\n\t\t\tProcessor.includes(\"r 5\") or Processor.includes(\"r7\") or\n\t\t\tProcessor.includes(\"r 7\") or Processor.includes(\"m1\")):\n\t\t\t\tpass\n\t\telse:\n\t\t\treturn jsonify({\"Processor error\": \"please a valid Processor model\"})\n\n\t\tif (Graphics_Card.length >= 2 and (Graphics_Card.includes(\"gpu\") or\n\t\t\tGraphics_Card.includes(\"nividia\") or Graphics_Card.includes(\"rtx\") or\n\t\t\tGraphics_Card.includes(\"gtx\") or Graphics_Card.includes(\"geforce\") or\n\t\t\tGraphics_Card.includes(\"quadro\") or Graphics_Card.includes(\"amd\") or\n\t\t\tGraphics_Card.includes(\"radeon\") or Graphics_Card.includes(\"rx\") or\n\t\t\tGraphics_Card.includes(\"vega\") or Graphics_Card.includes(\"intel\") or\n\t\t\tGraphics_Card.includes(\"iris\") or Graphics_Card.includes(\"hd\") or\n\t\t\tGraphics_Card.includes(\"m1\") or Graphics_Card.includes(\"graphic\"))):\n\t\t\tpass\n\t\telse:\n\t\t\treturn jsonify({\"Processor error\": \"please a valid Graphics Card model\"})\n\n\t\tif ssd > 128 and ssd <= 4000:\n\t\t\tpass\n\t\telse:\n\t\t\treturn jsonify({\"ssd error\": \"please number betwwen 128, 40000\"})\n\n\t\tif hdd > 128 and hdd <= 4000:\n\t\t\tpass\n\t\telse:\n\t\t\treturn jsonify({\"hdd error\": \"please number betwwen 128, 40000\"})\n\t\tif screen >= 8 and screen <= 30:\n\t\t\tpass\n\t\telse:\n\t\t\treturn jsonify({\"screen error\": \"please inter number betwwen 8, 30\"})\n\t\tif type(ram) == int:\n\t\t\tif ram >= 2 and ram <= 64:\n\t\t\t\tpass\n\t\telse:\n\t\t\treturn jsonify({\"ram error\": \"please number betwwen 2, 64\"})\n\n\texcept:\n\t\treturn jsonify({\"error\": \"Server Error\"})\n\treturn client\n\n", "description": null, "category": "graphics", "imports": ["from flask import Flask, request, jsonify", "import joblib"]}, {"term": "def", "name": "predict", "data": "def predict():\n\tclient = [extract_client_from_request(request.json)]\n\tprediction = model.predict(client)[0]\n\treturn jsonify({'price is': prediction})\n\n", "description": null, "category": "graphics", "imports": ["from flask import Flask, request, jsonify", "import joblib"]}], [{"term": "class", "name": "Display", "data": "class Display(object):\n\t\n\tWHITE = graphicsUtils.formatColor(1.0, 1.0, 1.0)\n\tRED = graphicsUtils.formatColor(1.0, 0.0, 0.0)\n\tGREEN = graphicsUtils.formatColor(0.16, 0.49, 0.31)\n\tBLUE = graphicsUtils.formatColor(0.0, 0.0, 1.0)\n\tBLACK = graphicsUtils.formatColor(0.0, 0.0, 0.0)\n\tGREY = graphicsUtils.formatColor(0.5, .5, 0.5)\n\t\n\tVISIBLE_CUTTOFF = 0.001\n\t\n\t\n\tpartDict = {}\n\tbeliefParts = []\n\tbeliefValue = []\n\tbeliefColor = []\n\tobservations = []\n\t\n\tgraphicsLock = threading.Lock()\n\t\n\tCOLORS = [\n\t\t'purple',\n\t\t'green',\n\t\t'teal',\n\t\t'red',\n\t\t'orange',\n\t\t'yellow'\n\t]\n\tCOLOR_HUES = {\n\t\t'purple' : 0.8,\n\t\t'green' : 0.3,\n\t\t'teal' : 0.49,\n\t\t'red' : 0.0,\n\t\t'orange' : 0.125,\n\t\t'yellow' : 0.21\n\t}\n\t\n\t@staticmethod\n\tdef initGraphics(layout):\n\t\tgraphicsUtils.begin_graphics(\n\t\t\twidth=layout.getWidth(), \n\t\t\theight=layout.getHeight(), \n\t\t\tcolor = Display.WHITE,\n\t\t\ttitle = Const.TITLE\n\t\t);\n\t\t\n\t@staticmethod\n\tdef endGraphics():\n\t\tgraphicsUtils.end_graphics()\n\n\t@staticmethod\n\tdef raiseEndGraphics():\n\t\tgraphicsUtils.raiseEndGraphics()\n\t\n\t@staticmethod\n\tdef drawCar(car):\n\t\tif car in Display.partDict:\n\t\t\tDisplay._remove(car)\n\t\tcolor = Display.GREY\n\t\tif car.isJunior():\n\t\t\tcolor = Display.BLACK\n\t\tparts = graphicsUtils.rectangle(\n\t\t\tcar.pos, Car.LENGTH, \n\t\t\tCar.WIDTH, \n\t\t\tcolor, \n\t\t\tcar.dir\n\t\t)\n\t\tDisplay.partDict[car] = parts\n\t\t\n\t@staticmethod\n\tdef drawObservation(obs):\n\t\tparts = Display.drawCircle(obs.pos, Observation.RADIUS)\n\t\tDisplay.partDict[obs] = parts\n\t\n\t@staticmethod\n\tdef drawSquare(pos, size, color):\n\t\treturn graphicsUtils.square(pos, size, color)\n\t\n\t@staticmethod\n\tdef drawFinish(block):\n\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.GREEN, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\n\t@staticmethod\n\tdef drawBlocks(blocks):\n\t\tfor block in blocks:\n\t\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.BLUE, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\t\n\t@staticmethod\n\tdef drawCircle(pos, radius):\n\t\treturn graphicsUtils.circle(pos, radius, Display.RED, Display.RED)\n\t\n\t@staticmethod\n\tdef drawBelief(model):\n\t\tDisplay.beliefVisible = []\n\t\tfor r in range(model.getBeliefRows()):\n\t\t\tbeliefValueRow = []\n\t\t\tbeliefPartRow = []\n\t\t\tbeliefColorRow = []\n\t\t\tfor c in range(model.getBeliefCols()):\n\t\t\t\tsquare = Display.drawBeliefSquare(r, c, 'purple', 0.0, model)\n\t\t\t\tbeliefPartRow.append(square)\n\t\t\t\tbeliefValueRow.append(0.0)\n\t\t\t\tbeliefColorRow.append(None)\n\t\t\tDisplay.beliefParts.append(beliefPartRow)\n\t\t\tDisplay.beliefValue.append(beliefValueRow)\n\t\t\tDisplay.beliefColor.append(beliefColorRow)\n\t\t\t\t\n\t@staticmethod\n\tdef drawBeliefSquare(row, col, color, value, model):\n\t\ttileSize = Const.BELIEF_TILE_SIZE\n\t\tx = col * tileSize + tileSize / 2.0\n\t\ty = row * tileSize + tileSize / 2.0\n\t\tif not model.inBounds(x, y): return None\n\t\tcolor = Display._getBeliefSquareColor(color, value)\n\t\treturn Display.drawSquare(Vec2d(x, y), tileSize, color)\n\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef getKeys():\n\t\t#print 'attempt get keys'\n\t\tDisplay._acquireLock()\n\t\t#print 'get keys'\n\t\tkeys = graphicsUtils.keys_waiting() + graphicsUtils.keys_pressed()\n\t\tDisplay._releaseLock()\n\t\treturn keys\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef graphicsSleep(timeToSleep):\n\t\tgraphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''for _ in range(int(timeToSleep / 0.005)):\n\t\t\t#print 'attempt sleep'\n\t\t\tDisplay._acquireLock()\n\t\t\t#print 'sleep'\n\t\t\tgraphicsUtils.sleep(0.001)\n\t\t\tDisplay._releaseLock()\n\t\t\ttime.sleep(0.004)'''\n\t\t\n\t\t#graphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''startWait = time.time()\n\t\tDisplay._acquireLock()\n\t\ttimeToSleep -= time.time() - startWait\n\t\tgraphicsUtils.refresh()\n\t\tif timeToSleep > 0:\n\t\t\tgraphicsUtils.sleep(timeToSleep)\n\t\tDisplay._releaseLock()'''\n\t\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef updateBelief(color, belief):\n\t\tDisplay._acquireLock()\n\t\ttotal = belief.getSum()\n\t\tif abs(total - 1.0) > 0.001:\n\t\t\traise Exception('belief does not sum to 1 ('+str(total)+'). Use the normalize method.')\n\t\tfor r in range(belief.getNumRows()):\n\t\t\tfor c in range(belief.getNumCols()):\n\t\t\t\tvalue = belief.getProb(r, c)\n\t\t\t\tDisplay._updateBeliefSquare(r, c, value, color)\n\t\tDisplay._releaseLock()\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef move(obj, delta):\n\t\t#print 'attempt move'\n\t\tDisplay._acquireLock()\n\t\t#print 'move'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.move_by(parts, delta.x, delta.y)\n\t\t#print 'end move'\n\t\tDisplay._releaseLock()\n\t\t\n\t# make thread safe\n\t@staticmethod\n\tdef rotate(obj, angle):\n\t\tif angle == 0: return\n\t\t#print 'attempt rotate'\n\t\tDisplay._acquireLock()\n\t\t#print 'rotate'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.rotate_by(parts, angle)\n\t\tDisplay._releaseLock()\n\t\t\t\t\n\t@staticmethod\n\tdef _getBeliefSquareColor(color, value):\n\t\tvalue = min(1.0, value * 15)\n\t\tsaturation = value\n\t\thue = Display.COLOR_HUES[color]\n\t\tr, g, b = colorsys.hsv_to_rgb(hue, saturation, 1.0)\n\t\tcolor = graphicsUtils.formatColor(r, g, b)\n\t\treturn color\t\t\n\t\n\t@staticmethod\n\tdef _isVisible(value):\n\t\treturn value >= Display.VISIBLE_CUTTOFF\n\t\n\t@staticmethod\n\tdef _updateBeliefSquare(r, c, value, colorName):\n\t\tpart = Display.beliefParts[r][c]\n\t\tif part == None: return\n\t\toldValue = Display.beliefValue[r][c]\n\t\toldColor = Display.beliefColor[r][c]\n\t\twasVisible = Display._isVisible(oldValue)\n\t\tisVisible = Display._isVisible(value) \n\t\tif not isVisible: value = 0.0\n\t\tif oldColor != colorName and oldValue >= value: return\n\t\tif not isVisible and not wasVisible: return\n\t\tcolor = Display._getBeliefSquareColor(colorName, value)\n\t\tgraphicsUtils.changeColor(part, color)\n\t\tDisplay.beliefValue[r][c] = value\n\t\tDisplay.beliefColor[r][c] = colorName\n\t\t\n\t@staticmethod\n\tdef _acquireLock():\n\t\treturn\n\t\t#print 'acquire'\n\t\treturn Display.graphicsLock.acquire()\n\t\n\t@staticmethod\n\tdef _releaseLock():\n\t\treturn\n\t\t#print 'release'\n\t\treturn Display.graphicsLock.release()\n\t \n\t####################################\n\t# Depreicated\n\t####################################\n\t\t\n\t@staticmethod\n\tdef _remove(obj):\n\t\tparts = Display.partDict[obj]\n\t\tgraphicsUtils.remove_from_screen(parts);\n\t\t\n\t@staticmethod\n\tdef redrawObservations(observations):\n\t\traise Exception('depreicated')\n\t\tfor obs in Display.observations:\n\t\t\tDisplay._remove(obs)\n\t\tfor obs in observations:\n\t\t\tDisplay.drawObservation(obs)\n\t\tDisplay.observations = observations\n", "description": null, "category": "graphics", "imports": ["from . import graphicsUtils", "from engine.model.car.car import Car", "from engine.const import Const", "from engine.model.observation import Observation", "from engine.vector import Vec2d", "import colorsys", "import threading"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\twhile not graphics.game_start():\t\t\t\t\t\t# \u9ede\u64ca\u555f\u52d5\u7684\u958b\u95dc\n\t\tpause(FRAME_RATE)\n\n\tdx, dy = graphics.get_speed()\t\t\t\t\t\t   # \u901f\u5ea6\n\tdeath_times = 0\n\twin = 10*graphics.brick_rows*graphics.brick_cols\t\t# \u5168\u90e8\u78da\u584a\u6253\u5b8c\u7684\u5206\u6578\n\n\t# Add animation loop here!\n\twhile death_times < NUM_LIVES and graphics.score < win:\n\n\t\t# \u79fb\u52d5\n\t\tgraphics.ball.move(dx, dy)\n\n\t\t# \u5224\u65b7\u689d\u4ef6\n\t\tif graphics.hit_block():\t\t\t\t\t\t\t# \u6253\u5230\u78da\u584a\n\t\t\tdx, dy = graphics.get_speed()\n\t\t\tgraphics.score_board.text = f\"Score : {graphics.score}\"\n\t\tif graphics.ball.x <= 0 or graphics.ball.x >= graphics.window.width-graphics.ball.width:\t# \u6253\u5230\u5de6\u53f3\u7246\u58c1\n\t\t\tgraphics.rebound_x()\n\t\t\tdx, dy = graphics.get_speed()\n\t\tif graphics.hit_paddle():\t\t\t\t\t\t   # \u6253\u5230paddle\n\t\t\tif dy > 0:\t\t\t\t\t\t\t\t\t  # \u78ba\u4fdd\u7403\u4e0d\u6703\u5361\u5728paddle\u4e2d\n\t\t\t\tgraphics.rebound_y()\n\t\t\t\tdx, dy = graphics.get_speed()\n\t\t\telse:\n\t\t\t\tpass\n\t\telif graphics.ball.y <= 0:\t\t\t\t\t\t  # \u6253\u5230\u6700\u4e0a\u9762\n\t\t\tgraphics.rebound_y()\n\t\t\tdx, dy = graphics.get_speed()\n\t\telif graphics.ball.y >= graphics.window.height-graphics.ball.height:\t\t   # \u6253\u5230\u6700\u4e0b\u9762\u800c\u6b7b\u4ea1\n\t\t\tgraphics.reset_ball_position()\n\t\t\tdx, dy = graphics.get_speed()\n\t\t\tdeath_times += 1\n\t\t\tpause(FRAME_RATE*120)\t\t\t\t\t\t   # \u4f7f\u6b7b\u4ea1\u5f8c\u80fd\u66ab\u505c\u4e00\u4e0b\u518d\u958b\u59cb\n\n\t\t# \u57f7\u884c\u66ab\u505c\n\t\tpause(FRAME_RATE)\n\n\t# \u5370\u51fa\u7d50\u675f\u5b57\u6a23\n\tif death_times == NUM_LIVES:\n\t\tfinal_label = GLabel(\"You Lose! \u00af\\_(\u30c4)_/\u00af\")\n\telse:\n\t\tfinal_label = GLabel(\"You Win! \u00af\\_(\u30c4)_/\u00af\")\n\tfinal_label.color = \"navy\"\n\tfinal_label.font = \"Comic Sans MS-40\"\n\tgraphics.window.remove(graphics.ball)\n\tgraphics.window.add(final_label, (graphics.window.width-final_label.width)/2, (graphics.window.height-final_label.height)/2+60)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.graphics.gobjects import GLabel"]}], [], [{"term": "def", "name": "__init__", "data": "  def __init__(self):\r\n\tself.visited = \"\"\r\n", "description": null, "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "visitRectangleGF", "data": "  def visitRectangleGF(self, rectangleGF):\r\n\tself.ref = rectangleGF\r\n\tself.visited = \"RectangleGF\"\r\n", "description": null, "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "visitOvalGF", "data": "  def visitOvalGF(self, ovalGF):\r\n\tself.ref = ovalGF\r\n\tself.visited = \"OvalGF\"\r\n", "description": null, "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "visitPolygonGF", "data": "  def visitPolygonGF(self, polygonGF):\r\n\tself.ref = polygonGF\r\n\tself.visited = \"PolygonGF\"\r\n", "description": null, "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "visitPolylineGF", "data": "  def visitPolylineGF(self, polylineGF):\r\n\tself.ref = polylineGF\r\n\tself.visited = \"PolylineGF\"\r\n", "description": null, "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "visitTextGF", "data": "  def visitTextGF(self, textGF):\r\n\tself.ref = textGF\r\n\tself.visited = \"TextGF\"\r\n", "description": null, "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "visitConnectorGF", "data": "  def visitConnectorGF(self, connectorGF):\r\n\tself.ref = connectorGF\r\n\tself.visited = \"ConnectorGF\"\r\n", "description": null, "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "visitCompositeGF", "data": "  def visitCompositeGF(self, compositeGF):\r\n\tself.ref = compositeGF\r\n\tself.visited = \"CompositeGF\"\r\n\r\n", "description": null, "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testNotImplementedGF", "data": "  def testNotImplementedGF(self):\r\n\t\"\"\"test failure to instantiate GF\"\"\"\r\n\tself.assertRaises(NotImplementedError, Graphics.GF)\r\n\r\n", "description": "test failure to instantiate GF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testNotImplementedLeafGF", "data": "  def testNotImplementedLeafGF(self):\r\n\t\"\"\"test failure to instantiate LeafGF\"\"\"\r\n\tself.assertRaises(NotImplementedError, Graphics.LeafGF)\r\n\r\n", "description": "test failure to instantiate LeafGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testBoundingBoxLeafGF", "data": "  def testBoundingBoxLeafGF(self):\r\n\t\"\"\"test LeafGF getApproxBoundingBox\"\"\"\r\n\t#Leaf GFs\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tfor gf in leafGFs:\r\n\t  box = gf.getApproxBoundingBox()\r\n\t  numPoints = len(gf.xy)/2\r\n\t  for i in range(numPoints):\r\n\t\tself.failIf(box[0] > round(gf.xy[2*i]))\r\n\t\tself.failIf(box[2] < round(gf.xy[2*i]))\r\n\t\tself.failIf(box[1] > round(gf.xy[2*i+1]))\r\n\t\tself.failIf(box[3] < round(gf.xy[2*i+1]))\r\n\r\n", "description": "test LeafGF getApproxBoundingBox", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testSetZoomLeafGF", "data": "  def testSetZoomLeafGF(self):\r\n\t\"\"\"test LeafGF setZoom\"\"\"\r\n\t#Leaf GFs\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tfor gf in leafGFs:\r\n\t  gf.setZoom(7.2)\r\n\t  self.assertEqual(gf.zoom, 7.2)\r\n\r\n", "description": "test LeafGF setZoom", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testLockSanity", "data": "  def testLockSanity(self):\r\n\t\"\"\"test lock sanity LeafGF\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tfor gf in leafGFs:\r\n\t  gf.setLock(1)\r\n\t  self.assertEqual(gf.getLock(), 1)\r\n\t  gf.setLock(0)\r\n\t  self.assertEqual(gf.getLock(), 0)\r\n\r\n", "description": "test lock sanity LeafGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testLock", "data": "  def testLock(self):\r\n\t\"\"\"test lock LeafGF\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tfor gf in leafGFs:\r\n\t  old_xy = gf.xy[:]\r\n\t  gf.setLock(1)\r\n\t  gf.translate(2,3)\r\n\t  self.assertEqual(old_xy, gf.xy)\r\n\t  gf.setLock(0)\r\n\t  gf.translate(2,3)\r\n\t  self.assertNotEqual(old_xy, gf.xy)\r\n\r\n", "description": "test lock LeafGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testSetFillColorSanity", "data": "  def testSetFillColorSanity(self):\r\n\t\"\"\"test fill color sanity LeafGF\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tfor gf in leafGFs:\r\n\t  gf.setFillColor(\"green\")\r\n\t  self.assertEqual(gf.getFillColor(), \"green\")\r\n", "description": "test fill color sanity LeafGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testSetOutlineColorSanity", "data": "  def testSetOutlineColorSanity(self):\r\n\t\"\"\"test outline color sanity for LeafGFs with outline\"\"\"\r\n\tleafGFs = [Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tfor gf in leafGFs:\r\n\t  gf.setOutlineColor(\"green\")\r\n\t  self.assertEqual(gf.getOutlineColor(), \"green\")\r\n\r\n\r\n", "description": "test outline color sanity for LeafGFs with outline", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testTranslateLeafGF", "data": "  def testTranslateLeafGF(self):\r\n\t\"\"\"test LeafGF translate\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3, 2.3, 12], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\ttranslations = [(leafGFs[0], leafGFs[0].translate, (3.4, 54.), (4.4, 66.0)),\r\n\t\t\t\t\t(leafGFs[1], leafGFs[1].translate, (2.4, 4.), (12.4, 24.0)),\r\n\t\t\t\t\t(leafGFs[2], leafGFs[2].translate, (-2., 33.), (-4.0, 36.0, -68.0, 65.3, 0.3, 45.0)),\r\n\t\t\t\t\t(leafGFs[3], leafGFs[3].translate, (-2.1, 0.1), (-14.1, 12.33, 63.7, -32.9)),\r\n\t\t\t\t\t(leafGFs[4], leafGFs[4].translate, (1.,1.), (2.0, 2.0, 13.0, 13.0)),\r\n\t\t\t\t\t(leafGFs[5], leafGFs[5].translate, (4., 3.0), (6.0, 9.0, 8.8, 9.4))]\r\n\ttestOperationsLeafGF(self, translations)\r\n\r\n", "description": "test LeafGF translate", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testRotateLeafGF", "data": "  def testRotateLeafGF(self):\r\n\t\"\"\"test LeafGF rotate\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3, 2.3, 12], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\trotations = [(leafGFs[0], leafGFs[0].rotate, (0, 0, 90), (-12.0, 1.0)),\r\n\t\t\t\t (leafGFs[1], leafGFs[1].rotate, (0, 0, 180), (-10.0, -20.0)),\r\n\t\t\t\t (leafGFs[2], leafGFs[2].rotate, (0, 0, 0), (-2.0, 3.0, -66.0, 32.3, 2.3, 12)),\r\n\t\t\t\t (leafGFs[3], leafGFs[3].rotate, (0, 0, 270), (12.23, 12.0, -33.0, -65.8)),\r\n\t\t\t\t (leafGFs[4], leafGFs[4].rotate, (0, 0, -90), (1.0, -1.0, 12.0, -12.0)),\r\n\t\t\t\t (leafGFs[5], leafGFs[5].rotate, (0, 0, 90), (-6.0, 2.0, -6.4, 4.8))]\r\n\r\n\ttestOperationsLeafGF(self, rotations)\r\n\r\n", "description": "test LeafGF rotate", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testScaleLeafGF", "data": "  def testScaleLeafGF(self):\r\n\t\"\"\"test LeafGF scale\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3, 2.3, 12], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tscalings = [(leafGFs[0], leafGFs[0].scale, (0, 0, 0, 0), (0, 0)),\r\n\t\t\t\t(leafGFs[1], leafGFs[1].scale, (0, 0, 1.0, 2.0), (10.0, 40.0)),\r\n\t\t\t\t(leafGFs[2], leafGFs[2].scale, (0, 0, 2.0, 3.0), (-4.0, 9.0, -132.0, 96.9, 4.6, 36)),\r\n\t\t\t\t(leafGFs[3], leafGFs[3].scale, (0, 0, -1.0, 2.0), (12.0, 24.46, -65.8, -66.0)),\r\n\t\t\t\t(leafGFs[4], leafGFs[4].scale, (0, 0, 3.0, 3.0), (3.0, 3.0, 36.0, 36.0)),\r\n\t\t\t\t(leafGFs[5], leafGFs[5].scale, (0, 0, 0.0, 0.5), (0.0, 3.0, 0.0, 3.2))]\r\n\ttestOperationsLeafGF(self, scalings)\r\n\t\t\r\n", "description": "test LeafGF scale", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testAcceptRectangleGF", "data": "  def testAcceptRectangleGF(self):\r\n\t\"\"\"test accept visitor RectangleGF\"\"\"\r\n\tvisitor = UselessVisitor()\r\n\trectangleGF = Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\trectangleGF.accept(visitor)\r\n\tself.assertEqual(visitor.visited, \"RectangleGF\")\r\n\tself.failIf(not (visitor.ref is rectangleGF))\r\n\t\r\n", "description": "test accept visitor RectangleGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testAcceptOvalGF", "data": "  def testAcceptOvalGF(self):\r\n\t\"\"\"test accept visitor OvalGF\"\"\"\r\n\tvisitor = UselessVisitor()\r\n\tovalGF = Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tovalGF.accept(visitor)\r\n\tself.assertEqual(visitor.visited, \"OvalGF\")\r\n\tself.failIf(not (visitor.ref is ovalGF))\r\n\r\n", "description": "test accept visitor OvalGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testAcceptPolygonGF", "data": "  def testAcceptPolygonGF(self):\r\n\t\"\"\"test accept visitor PolygonGF\"\"\"\r\n\tvisitor = UselessVisitor()\r\n\tpolygonGF = Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3, 2.3, 12], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tpolygonGF.accept(visitor)\r\n\tself.assertEqual(visitor.visited, \"PolygonGF\")\r\n\tself.failIf(not (visitor.ref is polygonGF))\r\n\r\n", "description": "test accept visitor PolygonGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testAcceptPolylineGF", "data": "  def testAcceptPolylineGF(self):\r\n\t\"\"\"test accept visitor PolylineGF\"\"\"\r\n\tvisitor = UselessVisitor()\r\n\tpolylineGF = Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tpolylineGF.accept(visitor)\r\n\tself.assertEqual(visitor.visited, \"PolylineGF\")\r\n\tself.failIf(not (visitor.ref is polylineGF))\r\n\r\n", "description": "test accept visitor PolylineGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testAcceptTextGF", "data": "  def testAcceptTextGF(self):\r\n\t\"\"\"test accept visitor TextGF\"\"\"\r\n\tvisitor = UselessVisitor()\r\n\ttextGF = Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None)\r\n\ttextGF.accept(visitor)\r\n\tself.assertEqual(visitor.visited, \"TextGF\")\r\n\tself.failIf(not (visitor.ref is textGF))\r\n\r\n", "description": "test accept visitor TextGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testAcceptConnectorGF", "data": "  def testAcceptConnectorGF(self):\r\n\t\"\"\"test accept visitor ConnectorGF\"\"\"\r\n\tvisitor = UselessVisitor()\r\n\tconnectorGF = Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None)\r\n\tconnectorGF.accept(visitor)\r\n\tself.assertEqual(visitor.visited, \"ConnectorGF\")\r\n\tself.failIf(not (visitor.ref is connectorGF))\r\n", "description": "test accept visitor ConnectorGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyTypeRectangleGF", "data": "  def testCopyTypeRectangleGF(self):\r\n\t\"\"\"test RectangleGF copy return type\"\"\"\r\n\trectangleGF = Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tself.failIf(not isinstance(rectangleGF.copy(), Graphics.RectangleGF))\r\n\r\n", "description": "test RectangleGF copy return type", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyTypeOvalGF", "data": "  def testCopyTypeOvalGF(self):\r\n\t\"\"\"test OvalGF copy return type\"\"\"\r\n\tovalGF = Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tself.failIf(not isinstance(ovalGF.copy(), Graphics.OvalGF))\r\n\r\n", "description": "test OvalGF copy return type", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyTypePolygonGF", "data": "  def testCopyTypePolygonGF(self):\r\n\t\"\"\"test PolygonGF copy return type\"\"\"\r\n\tpolygonGF = Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3, 2.3, 12], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tself.failIf(not isinstance(polygonGF.copy(), Graphics.PolygonGF))\r\n\r\n", "description": "test PolygonGF copy return type", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyTypePolylineGF", "data": "  def testCopyTypePolylineGF(self):\r\n\t\"\"\"test Polyline copy return type\"\"\"\r\n\tpolylineGF = Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tself.failIf(not isinstance(polylineGF.copy(), Graphics.PolylineGF))\r\n\r\n", "description": "test Polyline copy return type", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyTypeTextGF", "data": "  def testCopyTypeTextGF(self):\r\n\t\"\"\"test TextGF copy return type\"\"\"\r\n\ttextGF = Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None)\r\n\tself.failIf(not isinstance(textGF.copy(), Graphics.TextGF))\r\n\r\n", "description": "test TextGF copy return type", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyTypeConnectorGF", "data": "  def testCopyTypeConnectorGF(self):\r\n\t\"\"\"test ConnectorGF copy return type\"\"\"\r\n\tconnectorGF = Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None)\r\n\tself.failIf(not isinstance(connectorGF.copy(), Graphics.ConnectorGF))\r\n\r\n", "description": "test ConnectorGF copy return type", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyRectangleGF", "data": "  def testCopyRectangleGF(self):\r\n\t\"\"\"test RectangleGF copy\"\"\"\r\n\tgf = Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tgf2 = gf.copy()\r\n\tself.assertEqual(gf.xy, gf2.xy)\r\n\tself.assertEqual(gf.fill, gf2.fill)\r\n\tself.assertEqual(gf.outline, gf2.outline)\r\n\tself.assertEqual(gf.width, gf2.width)\r\n\tself.assertEqual(gf.isActive, gf2.isActive)\r\n\tself.assertEqual(gf.isLocked, gf2.isLocked)\r\n\tself.assertEqual(gf.zoom, gf2.zoom)\r\n\r\n", "description": "test RectangleGF copy", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyOvalGF", "data": "  def testCopyOvalGF(self):\r\n\t\"\"\"test OvalGF copy\"\"\"\r\n\tgf = Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tgf2 = gf.copy()\r\n\tself.assertEqual(gf.xy, gf2.xy)\r\n\tself.assertEqual(gf.fill, gf2.fill)\r\n\tself.assertEqual(gf.outline, gf2.outline)\r\n\tself.assertEqual(gf.width, gf2.width)\r\n\tself.assertEqual(gf.isActive, gf2.isActive)\r\n\tself.assertEqual(gf.isLocked, gf2.isLocked)\r\n\tself.assertEqual(gf.zoom, gf2.zoom)\r\n\r\n", "description": "test OvalGF copy", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyPolygonGF", "data": "  def testCopyPolygonGF(self):\r\n\t\"\"\"test PolygonGF copy\"\"\"\r\n\tgf = Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3, 2.3, 32], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tgf2 = gf.copy()\r\n\tself.assertEqual(gf.xy, gf2.xy)\r\n\tself.assertEqual(gf.fill, gf2.fill)\r\n\tself.assertEqual(gf.outline, gf2.outline)\r\n\tself.assertEqual(gf.width, gf2.width)\r\n\tself.assertEqual(gf.isActive, gf2.isActive)\r\n\tself.assertEqual(gf.isLocked, gf2.isLocked)\r\n\tself.assertEqual(gf.zoom, gf2.zoom)\r\n\r\n", "description": "test PolygonGF copy", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyPolylineGF", "data": "  def testCopyPolylineGF(self):\r\n\t\"\"\"test Polyline copy\"\"\"\r\n\tgf = Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4, 2.3, 32], \"black\", 0, 1, 0, self.canvas, 1.0, None)\r\n\tgf2 = gf.copy()\r\n\tself.assertEqual(gf.xy, gf2.xy)\r\n\tself.assertEqual(gf.fill, gf2.fill)\r\n\tself.assertEqual(gf.width, gf2.width)\r\n\tself.assertEqual(gf.isActive, gf2.isActive)\r\n\tself.assertEqual(gf.isLocked, gf2.isLocked)\r\n\tself.assertEqual(gf.zoom, gf2.zoom)\r\n\r\n", "description": "test Polyline copy", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyTextGF", "data": "  def testCopyTextGF(self):\r\n\t\"\"\"test TextGF copy\"\"\"\r\n\tgf = Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None)\r\n\tgf2 = gf.copy()\r\n\tself.assertEqual(gf.xy, gf2.xy)\r\n\tself.assertEqual(gf.fill, gf2.fill)\r\n\tself.assertEqual(gf.textCopy, gf2.textCopy)\r\n\tself.assertEqual(gf.isActive, gf2.isActive)\r\n\tself.assertEqual(gf.isLocked, gf2.isLocked)\r\n\tself.assertEqual(gf.zoom, gf2.zoom)\r\n\r\n", "description": "test TextGF copy", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyConnectorGF", "data": "  def testCopyConnectorGF(self):\r\n\t\"\"\"test ConnectorGF copy\"\"\"\r\n\tgf = Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None)\r\n\tgf2 = gf.copy()\r\n\tself.assertEqual(gf.xy, gf2.xy)\r\n\tself.assertEqual(gf.fill, gf2.fill)\r\n\tself.assertEqual(gf.outline, gf2.outline)\r\n\tself.assertEqual(gf.width, gf2.width)\r\n\tself.assertEqual(gf.isActive, gf2.isActive)\r\n\tself.assertEqual(gf.isLocked, gf2.isLocked)\r\n\tself.assertEqual(gf.zoom, gf2.zoom)\r\n\r\n", "description": "test ConnectorGF copy", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testAcceptCompositeGF", "data": "  def testAcceptCompositeGF(self):\r\n\t\"\"\"test accept visitor CompositeGF\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None)]\r\n\tvisitor = UselessVisitor()\r\n\tcompositeGF = Graphics.CompositeGF([leafGFs[0], leafGFs[1]], 1, 0, 1.0, None)\r\n\tcompositeGF.accept(visitor)\r\n\tself.assertEqual(visitor.visited, \"CompositeGF\")\r\n\tself.failIf(not (visitor.ref is compositeGF))\r\n\r\n", "description": "test accept visitor CompositeGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testLockSanity", "data": "  def testLockSanity(self):\r\n\t\"\"\"test lock sanity CompositeGF\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tcompositeGFs = [Graphics.CompositeGF([leafGFs[0], leafGFs[1]], 1, 0, 1.0, None),\r\n\t\t\t\t\tGraphics.CompositeGF([leafGFs[1], leafGFs[3]], 1, 0, 1.0, None),\r\n\t\t\t\t\tGraphics.CompositeGF([leafGFs[1], leafGFs[4]], 1, 0, 1.0, None),\r\n\t\t\t\t\tGraphics.CompositeGF([leafGFs[3], leafGFs[5]], 1, 0, 1.0, None)]\r\n\tfor gf in compositeGFs:\r\n\t  gf.setLock(1)\r\n\t  self.assertEqual(gf.getLock(), 1)\r\n\t  gf.setLock(0)\r\n\t  self.assertEqual(gf.getLock(), 0)\r\n\r\n", "description": "test lock sanity CompositeGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testLock", "data": "  def testLock(self):\r\n\t\"\"\"test lock sanity CompositeGF\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tcompositeGFs = [Graphics.CompositeGF([leafGFs[0], leafGFs[1]], 1, 0, 1.0, None),\r\n\t\t\t\t\tGraphics.CompositeGF([leafGFs[1], leafGFs[3]], 1, 0, 1.0, None),\r\n\t\t\t\t\tGraphics.CompositeGF([leafGFs[1], leafGFs[4]], 1, 0, 1.0, None),\r\n\t\t\t\t\tGraphics.CompositeGF([leafGFs[3], leafGFs[5]], 1, 0, 1.0, None)]\r\n\tfor gf in compositeGFs:\r\n\t  components = gf.getComponents()\r\n\t  oldCoordList = []\r\n\t  for c in components:\r\n\t\toldCoordList.append(c.xy[:])\r\n\t  #lock\r\n\t  gf.setLock(1)\r\n\t  gf.translate(2,2)\r\n\t  newCoordList = []\r\n\t  for c in components:\r\n\t\tnewCoordList.append(c.xy[:])\r\n\t  tuples = map(None, oldCoordList, newCoordList)\r\n\t  for t in tuples:\r\n\t\tself.assertEqual(t[0], t[1])\r\n\t  #now unlock\r\n\t  gf.setLock(0)\r\n\t  gf.translate(2,2)\r\n\t  newCoordList = []\r\n\t  for c in components:\r\n\t\tnewCoordList.append(c.xy[:])\r\n\t  tuples = map(None, oldCoordList, newCoordList)\r\n\t  for t in tuples:\r\n\t\tself.assertNotEqual(t[0], t[1])\r\n\r\n", "description": "test lock sanity CompositeGF", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testTranslateCompositeGF", "data": "  def testTranslateCompositeGF(self):\r\n\t\"\"\"test CompositeGF translate\"\"\"\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3, 2.3, 12], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tcompositeGF = Graphics.CompositeGF(leafGFs, 1, 0, 1.0, None)\r\n\tcomponents = compositeGF.getComponents()\r\n\toldCoordLists = []\r\n\tfor c in components:\r\n\t  oldCoordLists.append(c.xy[:])\r\n\tcompositeGF.translate(2,2)\r\n\tnewCoordLists = []\r\n\tfor c in components:\r\n\t\tnewCoordLists.append(c.xy[:])\r\n\tlistPairs = map(None, oldCoordLists, newCoordLists)\r\n\tfor p in listPairs:\r\n\t  coordPair = map(None, p[0], p[1])\r\n\t  for c in coordPair:\r\n\t\tself.assertEqual(c[0] + 2, c[1])\r\n\r\n", "description": "test CompositeGF translate", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testRotateCompositeGF", "data": "  def testRotateCompositeGF(self):\r\n\t\"\"\"test CompositeGF rotate\"\"\"\r\n\tleafGFs = [Graphics.PolygonGF([-2.0, 3.0, -66.0, 32.3, 2.3, 12], \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.OvalGF(-12.0, 12.23, 65.8, -33.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tcompositeGF = Graphics.CompositeGF(leafGFs, 1, 0, 1.0, None)\r\n\tcomponents = compositeGF.getComponents()\r\n\toldCoordLists = []\r\n\tfor c in components:\r\n\t  oldCoordLists.append(c.xy[:])\r\n\tcompositeGF.rotate(0,0,180)\r\n\tnewCoordLists = []\r\n\tfor c in components:\r\n\t\tnewCoordLists.append(c.xy[:])\r\n\tlistPairs = map(None, oldCoordLists, newCoordLists)\r\n\tfor p in listPairs:\r\n\t  coordPair = map(None, p[0], p[1])\r\n\t  for c in coordPair:\r\n\t\tself.assertEqual(-c[0], c[1])\r\n\r\n", "description": "test CompositeGF rotate", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testScaleCompositeGF", "data": "  def testScaleCompositeGF(self):\r\n\t\"\"\"test CompositeGF scale\"\"\"\r\n\tleafGFs = [Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tcompositeGF = Graphics.CompositeGF(leafGFs, 1, 0, 1.0, None)\r\n\tcomponents = compositeGF.getComponents()\r\n\toldCoordLists = []\r\n\tfor c in components:\r\n\t  oldCoordLists.append(c.xy[:])\r\n\tcompositeGF.scale(0,0,2,2)\r\n\tnewCoordLists = []\r\n\tfor c in components:\r\n\t\tnewCoordLists.append(c.xy[:])\r\n\tlistPairs = map(None, oldCoordLists, newCoordLists)\r\n\tfor p in listPairs:\r\n\t  coordPair = map(None, p[0], p[1])\r\n\t  for c in coordPair:\r\n\t\tself.assertEqual(2*c[0], c[1])\r\n\r\n", "description": "test CompositeGF scale", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testGetComponentsCompositeGF", "data": "  def testGetComponentsCompositeGF(self):\r\n\t\"\"\"test CompositeGF getComponents\"\"\"\r\n\tleafGFs = [Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tcompositeGF = Graphics.CompositeGF(leafGFs, 1, 0, 1.0, None)\r\n\tcomponents = compositeGF.getComponents()\r\n\tself.failIf(not components[0] is leafGFs[0])\r\n\tself.failIf(not components[1] is leafGFs[1])\r\n\r\n", "description": "test CompositeGF getComponents", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testBoundingBoxCompositeGF", "data": "  def testBoundingBoxCompositeGF(self):\r\n\t\"\"\"test CompositeGF getApproxBoundingBox\"\"\"\r\n\t#Leaf GFs\r\n\tleafGFs = [Graphics.TextGF(1.0, 12.0, \"text\", \"blue\", 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.ConnectorGF(10.0, 20.0, \"black\", \"blue\", 1, 0, self.canvas, 1.0, None)]\r\n\tcompositeGF = Graphics.CompositeGF(leafGFs, 1, 0, 1.0, None)\r\n\tbox = compositeGF.getApproxBoundingBox()\r\n\tfor gf in leafGFs:\r\n\t  leafBox = gf.getApproxBoundingBox()\r\n\t  self.failIf(box[0] > leafBox[0])\r\n\t  self.failIf(box[2] < leafBox[2])\r\n\t  self.failIf(box[1] > leafBox[1])\r\n\t  self.failIf(box[3] < leafBox[3])\r\n\r\n", "description": "test CompositeGF getApproxBoundingBox", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testCopyTypeCompositeGF", "data": "  def testCopyTypeCompositeGF(self):\r\n\t\"\"\"test CompositeGF copy return type\"\"\"\r\n\tleafGFs = [Graphics.RectangleGF(1.0, 1.0, 12.0, 12.0, \"black\", \"blue\", 0, 1, 0, self.canvas, 1.0, None),\r\n\t\t\t   Graphics.PolylineGF([2.0, 6.0, 4.8, 6.4], \"black\", 0, 1, 0, self.canvas, 1.0, None)]\r\n\tcompositeGF = Graphics.CompositeGF(leafGFs, 1, 0, 1.0, None)\r\n\tself.failIf(not isinstance(compositeGF.copy(), Graphics.CompositeGF))\r\n\r\n\r\n", "description": "test CompositeGF copy return type", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testRotation", "data": "  def testRotation(self):\r\n\t\"\"\"testing rotation primitive\"\"\"\r\n\tfor t in self.rotationTests:\r\n\t  point = Geometry.rotate(t[0][0], t[0][1], t[0][2], t[0][3], t[0][4])\r\n\t  self.assertEqual(point, t[1])\r\n\r\n", "description": "testing rotation primitive", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testTranslation", "data": "  def testTranslation(self):\r\n\t\"\"\"testing translation primitive\"\"\"\r\n\tfor t in self.translationTests:\r\n\t  point = Geometry.translate(t[0][0], t[0][1], t[0][2], t[0][3])\r\n\t  self.assertEqual(point, t[1])\r\n", "description": "testing translation primitive", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}, {"term": "def", "name": "testScaling", "data": "  def testScaling(self):\r\n\t\"\"\"testing scaling primitive\"\"\"\r\n\tfor t in self.scalingTests:\r\n\t  point = Geometry.scale(t[0][0], t[0][1], t[0][2], t[0][3], t[0][4], t[0][5])\r\n\t  self.assertEqual(point, t[1])\r\n\r\n", "description": "testing scaling primitive", "category": "graphics", "imports": ["import unittest\r", "import Tkinter\r", "import Graphics\r", "import Geometry\r"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\n\t# Add animation loop here!\n\tlives = NUM_LIVES\n\tdx = graphics.get_xvelocity()\n\tdy = graphics.get_yvelocity()\n\n\twhile True:\n\t\tif lives > 0:\n\t\t\tpause(FRAME_RATE)\n\n\t\t\tif graphics.click_to_start:\n\t\t\t\tgraphics.ball.move(dx, dy)\n\n\t\t\t\t# check whether the collision happen\n\t\t\t\tupper_left = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y)\n\t\t\t\tupper_right = graphics.window.get_object_at(graphics.ball.x + graphics.ball.width, graphics.ball.y)\n\t\t\t\tlower_left = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y + graphics.ball.height)\n\t\t\t\tlower_right = graphics.window.get_object_at(graphics.ball.x + graphics.ball.width,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgraphics.ball.y + graphics.ball.width)\n\n\t\t\t\tif upper_left is not None:\n\t\t\t\t\tif upper_left is graphics.paddle:\n\t\t\t\t\t\tdy *= -1\n\t\t\t\t\t\tgraphics.ball.move(3 * dx, 3 * dy)\n\t\t\t\t\telse:\n\t\t\t\t\t\tif upper_left is not graphics.score_label:\n\t\t\t\t\t\t\tgraphics.window.remove(upper_left)\n\t\t\t\t\t\t\tgraphics.score += 1\n\t\t\t\t\t\t\tgraphics.score_label.text = 'Score: ' + str(graphics.score)\n\t\t\t\t\t\t\tdy *= -1\n\n\t\t\t\telse:\n\t\t\t\t\tif upper_right is not None and not graphics.score_label:\n\t\t\t\t\t\tif upper_right is graphics.paddle:\n\t\t\t\t\t\t\tdy *= -1\n\t\t\t\t\t\t\tgraphics.ball.move(3 * dx, 3 * dy)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tgraphics.window.remove(upper_right)\n\t\t\t\t\t\t\tgraphics.score += 1\n\t\t\t\t\t\t\tgraphics.score_label.text = 'Score: ' + str(graphics.score)\n\t\t\t\t\t\t\tdy *= -1\n\n\t\t\t\t\telse:\n\t\t\t\t\t\tif lower_right is not None and not graphics.score_label:\n\t\t\t\t\t\t\tif lower_right is graphics.paddle:\n\t\t\t\t\t\t\t\tdy *= -1\n\t\t\t\t\t\t\t\tgraphics.ball.move(3 * dx, 3 * dy)\n\t\t\t\t\t\t\telse:\n\n\t\t\t\t\t\t\t\tgraphics.window.remove(lower_right)\n\t\t\t\t\t\t\t\tgraphics.score += 1\n\t\t\t\t\t\t\t\tgraphics.score_label.text = 'Score: ' + str(graphics.score)\n\t\t\t\t\t\t\t\tdy *= -1\n\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tif lower_left is not None and not graphics.score_label:\n\t\t\t\t\t\t\t\tif lower_left is graphics.paddle:\n\t\t\t\t\t\t\t\t\tdy *= -1\n\t\t\t\t\t\t\t\t\tgraphics.ball.move(3 * dx, 3 * dy)\n\t\t\t\t\t\t\t\telse:\n\n\t\t\t\t\t\t\t\t\tgraphics.window.remove(lower_right)\n\t\t\t\t\t\t\t\t\tgraphics.score += 1\n\t\t\t\t\t\t\t\t\tgraphics.score_label.text = 'Score: ' + str(graphics.score)\n\t\t\t\t\t\t\t\t\tdy *= -1\n\n\t\t\t\t# Check whether the ball is out of boundary\n\t\t\t\tif graphics.ball.x + graphics.ball.width - 1 >= graphics.window.width or graphics.ball.x <= 0:\n\t\t\t\t\tdx *= -1\n\t\t\t\tif graphics.ball.y <= 0:\n\t\t\t\t\tdy *= -1\n\t\t\t\tif graphics.ball.y + graphics.ball.height >= graphics.window.height:\n\t\t\t\t\tlives -= 1\n\t\t\t\t\tif lives > 0:\n\t\t\t\t\t\t# Reset ball position, return boolean false and ready to next click\n\t\t\t\t\t\tgraphics.window.add(graphics.ball, x=(graphics.window.width - graphics.ball.width)/2,\n\t\t\t\t\t\t\t\t\t\t\ty=(graphics.window.height - graphics.ball.height)/2)\n\t\t\t\t\tgraphics.click_to_start = False\n\n\t\t\t\t# Set the win condition\n\t\t\t\tif graphics.score == graphics.number_brick:\n\t\t\t\t\tgraphics.window.add(graphics.win, x=(graphics.window.width - graphics.win.width) / 2,\n\t\t\t\t\t\t\t\t\t\ty=((graphics.window.height - graphics.win.height) / 2))\n\t\t\t\t\tbreak\n\n\t\telse:\n\t\t\t# Set the lose condition\n\t\t\tgraphics.window.add(graphics.lose, x=(graphics.window.width-graphics.lose.width)/2,\n\t\t\t\t\t\t\t\ty=((graphics.window.height-graphics.lose.height)/2))\n\t\t\tbreak\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [], [{"term": "class", "name": "classAnimationPlayer:", "data": "class AnimationPlayer:\n\tdef __init__(self):\n\t\tself.frames = {\n\t\t\t# magic\n\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\n\t\t\t'aura': import_folder('../graphics/particles/aura'),\n\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\n\t\t\t\n\t\t\t# attacks \n\t\t\t'claw': import_folder('../graphics/particles/claw'),\n\t\t\t'slash': import_folder('../graphics/particles/slash'),\n\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\n\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\n\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\n\n\t\t\t# monster deaths\n\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\n\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\n\t\t\t'spirit': import_folder('../graphics/particles/nova'),\n\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\n\t\t\t\n\t\t\t# leafs \n\t\t\t'leaf': (\n\t\t\t\timport_folder('../graphics/particles/leaf1'),\n\t\t\t\timport_folder('../graphics/particles/leaf2'),\n\t\t\t\timport_folder('../graphics/particles/leaf3'),\n\t\t\t\timport_folder('../graphics/particles/leaf4'),\n\t\t\t\timport_folder('../graphics/particles/leaf5'),\n\t\t\t\timport_folder('../graphics/particles/leaf6'),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\n\t\t\t\t)\n\t\t\t}\n\t\n\tdef reflect_images(self,frames):\n\t\tnew_frames = []\n\n\t\tfor frame in frames:\n\t \t\tflipped_frame = pygame.transform.flip(frame,True,False)\n\t \t\tnew_frames.append(flipped_frame)\n\t\treturn new_frames\n\n\tdef create_grass_particles(self,pos,groups):\n\t \tanimation_frames = choice(self.frames['leaf'])\n\t \tParticleEffect(pos,animation_frames,groups)\n\n\tdef create_particles(self,animation_type,pos,groups):\n\t\tanimation_frames = self.frames[animation_type]\n\t\tParticleEffect(pos,animation_frames,groups)\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\n\tdef __init__(self,pos,animation_frames,groups):\n\t\tsuper().__init__(groups)\n\t\tself.sprite_type = 'magic'\n\t\tself.frame_index = 0\n\t\tself.animation_speed = 0.15\n\t\tself.frames = animation_frames\n\t\tself.image = self.frames[self.frame_index]\n\t\tself.rect = self.image.get_rect(center = pos)\n\n\tdef animate(self):\n\t\tself.frame_index += self.animation_speed\n\t\tif self.frame_index >= len(self.frames):\n\t\t\tself.kill()\n\t\telse:\n\t\t\tself.image = self.frames[int(self.frame_index)]\n\n\tdef update(self):\n\t\tself.animate()\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}], [{"term": "class", "name": "classAnimationPlayer:", "data": "class AnimationPlayer:\n\tdef __init__(self):\n\t\tself.frames = {\n\t\t\t# magic\n\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\n\t\t\t'aura': import_folder('../graphics/particles/aura'),\n\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\n\t\t\t\n\t\t\t# attacks \n\t\t\t'claw': import_folder('../graphics/particles/claw'),\n\t\t\t'slash': import_folder('../graphics/particles/slash'),\n\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\n\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\n\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\n\n\t\t\t# monster deaths\n\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\n\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\n\t\t\t'spirit': import_folder('../graphics/particles/nova'),\n\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\n\t\t\t\n\t\t\t# leafs \n\t\t\t'leaf': (\n\t\t\t\timport_folder('../graphics/particles/leaf1'),\n\t\t\t\timport_folder('../graphics/particles/leaf2'),\n\t\t\t\timport_folder('../graphics/particles/leaf3'),\n\t\t\t\timport_folder('../graphics/particles/leaf4'),\n\t\t\t\timport_folder('../graphics/particles/leaf5'),\n\t\t\t\timport_folder('../graphics/particles/leaf6'),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\n\t\t\t\t)\n\t\t\t}\n\t\n\tdef reflect_images(self,frames):\n\t\tnew_frames = []\n\n\t\tfor frame in frames:\n\t \t\tflipped_frame = pygame.transform.flip(frame,True,False)\n\t \t\tnew_frames.append(flipped_frame)\n\t\treturn new_frames\n\n\tdef create_grass_particles(self,pos,groups):\n\t \tanimation_frames = choice(self.frames['leaf'])\n\t \tParticleEffect(pos,animation_frames,groups)\n\n\tdef create_particles(self,animation_type,pos,groups):\n\t\tanimation_frames = self.frames[animation_type]\n\t\tParticleEffect(pos,animation_frames,groups)\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\n\tdef __init__(self,pos,animation_frames,groups):\n\t\tsuper().__init__(groups)\n\t\tself.sprite_type = 'magic'\n\t\tself.frame_index = 0\n\t\tself.animation_speed = 0.15\n\t\tself.frames = animation_frames\n\t\tself.image = self.frames[self.frame_index]\n\t\tself.rect = self.image.get_rect(center = pos)\n\n\tdef animate(self):\n\t\tself.frame_index += self.animation_speed\n\t\tif self.frame_index >= len(self.frames):\n\t\t\tself.kill()\n\t\telse:\n\t\t\tself.image = self.frames[int(self.frame_index)]\n\n\tdef update(self):\n\t\tself.animate()\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}], [{"term": "class", "name": "classAnimationPlayer:", "data": "class AnimationPlayer:\n\tdef __init__(self):\n\t\tself.frames = {\n\t\t\t# magic\n\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\n\t\t\t'aura': import_folder('../graphics/particles/aura'),\n\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\n\t\t\t\n\t\t\t# attacks \n\t\t\t'claw': import_folder('../graphics/particles/claw'),\n\t\t\t'slash': import_folder('../graphics/particles/slash'),\n\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\n\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\n\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\n\n\t\t\t# monster deaths\n\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\n\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\n\t\t\t'spirit': import_folder('../graphics/particles/nova'),\n\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\n\t\t\t\n\t\t\t# leafs \n\t\t\t'leaf': (\n\t\t\t\timport_folder('../graphics/particles/leaf1'),\n\t\t\t\timport_folder('../graphics/particles/leaf2'),\n\t\t\t\timport_folder('../graphics/particles/leaf3'),\n\t\t\t\timport_folder('../graphics/particles/leaf4'),\n\t\t\t\timport_folder('../graphics/particles/leaf5'),\n\t\t\t\timport_folder('../graphics/particles/leaf6'),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\n\t\t\t\t)\n\t\t\t}\n\t\n\tdef reflect_images(self,frames):\n\t\tnew_frames = []\n\n\t\tfor frame in frames:\n\t \t\tflipped_frame = pygame.transform.flip(frame,True,False)\n\t \t\tnew_frames.append(flipped_frame)\n\t\treturn new_frames\n\n\tdef create_grass_particles(self,pos,groups):\n\t \tanimation_frames = choice(self.frames['leaf'])\n\t \tParticleEffect(pos,animation_frames,groups)\n\n\tdef create_particles(self,animation_type,pos,groups):\n\t\tanimation_frames = self.frames[animation_type]\n\t\tParticleEffect(pos,animation_frames,groups)\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\n\tdef __init__(self,pos,animation_frames,groups):\n\t\tsuper().__init__(groups)\n\t\tself.sprite_type = 'magic'\n\t\tself.frame_index = 0\n\t\tself.animation_speed = 0.15\n\t\tself.frames = animation_frames\n\t\tself.image = self.frames[self.frame_index]\n\t\tself.rect = self.image.get_rect(center = pos)\n\n\tdef animate(self):\n\t\tself.frame_index += self.animation_speed\n\t\tif self.frame_index >= len(self.frames):\n\t\t\tself.kill()\n\t\telse:\n\t\t\tself.image = self.frames[int(self.frame_index)]\n\n\tdef update(self):\n\t\tself.animate()\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}], [{"term": "class", "name": "classAnimationPlayer:", "data": "class AnimationPlayer:\n\tdef __init__(self):\n\t\tself.frames = {\n\t\t\t# magic\n\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\n\t\t\t'aura': import_folder('../graphics/particles/aura'),\n\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\n\t\t\t\n\t\t\t# attacks \n\t\t\t'claw': import_folder('../graphics/particles/claw'),\n\t\t\t'slash': import_folder('../graphics/particles/slash'),\n\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\n\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\n\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\n\n\t\t\t# monster deaths\n\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\n\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\n\t\t\t'spirit': import_folder('../graphics/particles/nova'),\n\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\n\t\t\t\n\t\t\t# leafs \n\t\t\t'leaf': (\n\t\t\t\timport_folder('../graphics/particles/leaf1'),\n\t\t\t\timport_folder('../graphics/particles/leaf2'),\n\t\t\t\timport_folder('../graphics/particles/leaf3'),\n\t\t\t\timport_folder('../graphics/particles/leaf4'),\n\t\t\t\timport_folder('../graphics/particles/leaf5'),\n\t\t\t\timport_folder('../graphics/particles/leaf6'),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\n\t\t\t\t)\n\t\t\t}\n\t\n\tdef reflect_images(self,frames):\n\t\tnew_frames = []\n\n\t\tfor frame in frames:\n\t \t\tflipped_frame = pygame.transform.flip(frame,True,False)\n\t \t\tnew_frames.append(flipped_frame)\n\t\treturn new_frames\n\n\tdef create_grass_particles(self,pos,groups):\n\t \tanimation_frames = choice(self.frames['leaf'])\n\t \tParticleEffect(pos,animation_frames,groups)\n\n\tdef create_particles(self,animation_type,pos,groups):\n\t\tanimation_frames = self.frames[animation_type]\n\t\tParticleEffect(pos,animation_frames,groups)\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\n\tdef __init__(self,pos,animation_frames,groups):\n\t\tsuper().__init__(groups)\n\t\tself.frame_index = 0\n\t\tself.animation_speed = 0.15\n\t\tself.frames = animation_frames\n\t\tself.image = self.frames[self.frame_index]\n\t\tself.rect = self.image.get_rect(center = pos)\n\n\tdef animate(self):\n\t\tself.frame_index += self.animation_speed\n\t\tif self.frame_index >= len(self.frames):\n\t\t\tself.kill()\n\t\telse:\n\t\t\tself.image = self.frames[int(self.frame_index)]\n\n\tdef update(self):\n\t\tself.animate()\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}], [], [{"term": "class", "name": "TGUIMScene", "data": "class TGUIMScene(QGraphicsScene):\n\titemSelected = Signal(int)\n\titemBlink = Signal(int)\n\t\n\tdef __init__(self, targetGUIModel: 'TargetGuiModel'):\n\t\t\"\"\"\n\t\tConstruct the TGUIMScene class\n\n\t\t:param targetGUIModel: get the TargetGuiModel of the project\n\t\t:type targetGUIModel: TargetGuiModel\n\t\t\"\"\"\n\t\tQGraphicsScene.__init__(self)\n\t\tself._targetGuiModel = targetGUIModel\n\t\tself._dataToGraphicsMapping = {}\n\n\t\t# Create all component graphics\n\t\t# WARNING: We create an invisible graphics item for the root, which is a bit weird. If there's a\n\t\t# graphics-related bug, look into this.\n\t\troot = self._targetGuiModel.getRoot()\n\t\trootGraphics = ComponentGraphics(root, (0,0,0,0), None)\n\t\tself._dataToGraphicsMapping[root] = rootGraphics\n\t\twork = [(root, rootGraphics)]\n\t\twhile len(work) > 0:\n\t\t\tdata, parentGraphics = work.pop()\n\n\t\t\t# add the root's component to the scene.\n\t\t\tif data is self._targetGuiModel.getRoot():\n\t\t\t\tself.addItem(parentGraphics)\n\n\t\t\tfor child in data.getChildren():\n\t\t\t\tgraphics = self.createComponentGraphics(child, parentGraphics)\n\t\t\t\tif isinstance(graphics, ComponentGraphics):\n\t\t\t\t\tgraphics.chkExtraComponents()\n\t\t\t\twork.append((child, graphics))\n\n\t\t# Create all visibility behavior graphics\n\t\tfor vb in (targetGUIModel.getEntity(id) for id in targetGUIModel.getVisibilityBehaviors()):\n\t\t\tgraphics = self.createVisibilityBehaviorGraphics(vb)\n\t\t\tself.addItem(graphics)\n\n\t\tdef onNewComponent(newComponent):\n\t\t\tparentGraphics = self.getGraphics(newComponent.getParent())\n\t\t\tgraphics = self.createComponentGraphics(newComponent, parentGraphics)\n\t\t\tif parentGraphics is None:\n\t\t\t\tself.addItem(graphics)\n\n\t\tdef onNewBehavior(newBehavior):\n\t\t\tself.createVisibilityBehaviorGraphics(newBehavior)\n\n\t\tself._targetGuiModel.newComponent.connect(onNewComponent)\n\t\tself._targetGuiModel.newBehavior.connect(onNewBehavior)\n\n\tdef createComponentGraphics(self, dataItem: 'Component', parent: 'ComponentGraphics') -> 'ComponentGraphics':\n\t\t\"\"\"\n\t\tCreate the graphics for a component\n\n\t\t:param dataItem: The component to make a graphics item for\n\t\t:type dataItem: Component\n\t\t:param parent: The parent to the new graphics item.\n\t\t:type parent: ComponentGraphics\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\tgraphics = ComponentGraphics(dataItem, dataItem.getSuperToken().posRelativeToParent, parent)\n\t\tself._dataToGraphicsMapping[dataItem] = graphics\n\t\treturn graphics\n\n\tdef createVisibilityBehaviorGraphics(self, dataItem: 'VisibilityBehavior') -> 'VisibilityBehaviorGraphics':\n\t\t\"\"\"\n\t\tCreate the graphics for a visibility behavior\n\n\t\t:param dataItem: The visibility behavior to create the graphics for.\n\t\t:type dataItem: VisibilityBehavior\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\tgraphics = vbg.VBGraphics(dataItem, self)\n\t\tself._dataToGraphicsMapping[dataItem] = graphics\n\t\treturn graphics\n\n\tdef getGraphics(self, dataItem):\n\t\t\"\"\"\n\t\tGets the graphics associated with either a component or a visibility behavior.\n\n\t\t.. note:: alternatively, this method can take in the id of a component or visibility behavior.\n\n\t\t:param dataItem: The component or visibility behavior to get the graphics for.\n\t\t:type dataItem: Component or VisibilityBehavior\n\t\t:return: The graphics associated with dataItem.\n\t\t:rtype: ComponentGraphics or VBGraphics\n\t\t\"\"\"\n\t\tif type(dataItem) is int:\n\t\t\tdataItem = self._targetGuiModel.getComponent(dataItem)\n\n\t\treturn self._dataToGraphicsMapping.get(dataItem, None)\n\t\n\tdef getTargetGUIModel(self) -> 'TargetGuiModel':\n\t\t\"\"\"\n\t\tGets the target GUI Model.\n\n\t\t:return The target GUI model\n\t\t:rtype data.tguim.targetguimodel.TargetGuiModel\n\t\t\"\"\"\n\t\treturn self._targetGuiModel\n\t\n\tdef emitItemSelected(self, id: int) -> None:\n\t\t\"\"\"\n\t\tEmits a signal that carries the ID of the item that was selected\n\n\t\t:param id: The ID of the item that was selected.\n\t\t:type id: int\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\tself.itemSelected.emit(id)\n\t\n\tdef blinkComponent(self, id: int) -> None:\n\t\t\"\"\"\n\t\temits the itemBlink signal which means that an item should be shown in the\n\t\ttarget GUI.\n\t\t\n\t\t:param id: The ID of the component that should be blinked.\n\t\t:type id: int\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\tself.itemBlink.emit(id)\n", "description": "\n\t\tConstruct the TGUIMScene class\n\n\t\t:param targetGUIModel: get the TargetGuiModel of the project\n\t\t:type targetGUIModel: TargetGuiModel\n\t\t", "category": "graphics", "imports": ["from PySide2.QtCore import Signal, QTimer", "from PySide2.QtWidgets import QGraphicsScene", "from graphics.tguim.componentgraphics import ComponentGraphics", "import graphics.tguim.visibilitybehaviorgraphics as vbg", "from data.tguim.component import Component"]}], [], [{"term": "def", "name": "f_fromUtf8", "data": "\tdef _fromUtf8(s):\n\t\treturn s\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtCore, QtGui"]}, {"term": "def", "name": "f_translate", "data": "\tdef _translate(context, text, disambig):\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtCore, QtGui"]}, {"term": "def", "name": "f_translate", "data": "\tdef _translate(context, text, disambig):\n\t\treturn QtGui.QApplication.translate(context, text, disambig)\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtCore, QtGui"]}, {"term": "class", "name": "Ui_GraphicsPage", "data": "class Ui_GraphicsPage(object):\n\tdef setupUi(self, GraphicsPage):\n\t\tGraphicsPage.setObjectName(_fromUtf8(\"GraphicsPage\"))\n\t\tGraphicsPage.resize(440, 334)\n\t\tself.vboxlayout = QtGui.QVBoxLayout(GraphicsPage)\n\t\tself.vboxlayout.setObjectName(_fromUtf8(\"vboxlayout\"))\n\t\tself.headerLabel = QtGui.QLabel(GraphicsPage)\n\t\tself.headerLabel.setObjectName(_fromUtf8(\"headerLabel\"))\n\t\tself.vboxlayout.addWidget(self.headerLabel)\n\t\tself.line7 = QtGui.QFrame(GraphicsPage)\n\t\tself.line7.setFrameShape(QtGui.QFrame.HLine)\n\t\tself.line7.setFrameShadow(QtGui.QFrame.Sunken)\n\t\tself.line7.setFrameShape(QtGui.QFrame.HLine)\n\t\tself.line7.setFrameShadow(QtGui.QFrame.Sunken)\n\t\tself.line7.setObjectName(_fromUtf8(\"line7\"))\n\t\tself.vboxlayout.addWidget(self.line7)\n\t\tself.hboxlayout = QtGui.QHBoxLayout()\n\t\tself.hboxlayout.setObjectName(_fromUtf8(\"hboxlayout\"))\n\t\tself.graphicsFontButton = QtGui.QPushButton(GraphicsPage)\n\t\tself.graphicsFontButton.setObjectName(_fromUtf8(\"graphicsFontButton\"))\n\t\tself.hboxlayout.addWidget(self.graphicsFontButton)\n\t\tself.graphicsFontSample = QtGui.QLineEdit(GraphicsPage)\n\t\tself.graphicsFontSample.setFocusPolicy(QtCore.Qt.NoFocus)\n\t\tself.graphicsFontSample.setAlignment(QtCore.Qt.AlignHCenter)\n\t\tself.graphicsFontSample.setReadOnly(True)\n\t\tself.graphicsFontSample.setObjectName(_fromUtf8(\"graphicsFontSample\"))\n\t\tself.hboxlayout.addWidget(self.graphicsFontSample)\n\t\tself.vboxlayout.addLayout(self.hboxlayout)\n\t\tspacerItem = QtGui.QSpacerItem(20, 40, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding)\n\t\tself.vboxlayout.addItem(spacerItem)\n\n\t\tself.retranslateUi(GraphicsPage)\n\t\tQtCore.QMetaObject.connectSlotsByName(GraphicsPage)\n\n\tdef retranslateUi(self, GraphicsPage):\n\t\tself.headerLabel.setText(_translate(\"GraphicsPage\", \"Configure graphics settings\", None))\n\t\tself.graphicsFontButton.setToolTip(_translate(\"GraphicsPage\", \"Press to select the font for the graphic items\", None))\n\t\tself.graphicsFontButton.setText(_translate(\"GraphicsPage\", \"Graphics Font\", None))\n\t\tself.graphicsFontSample.setText(_translate(\"GraphicsPage\", \"Graphics Font\", None))\n\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtCore, QtGui"]}], [{"term": "def", "name": "show", "data": "def show(graphics, title=None, width=None, height=None, **options):\n\t\"\"\"\n\tShows given graphics in the viewer app.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics or pero.Control\n\t\t\tGraphics to be shown.\n\t\t\n\t\ttitle: str or None\n\t\t\tViewer frame title.\n\t\t\n\t\twidth: float or None\n\t\t\tViewer width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tViewer height in device units.\n\t\"\"\"\n\t\n\t# init app\n\tapp = QApplication.instance()\n\tif app is None:\n\t\tapp = QApplication([])\n\t\n\t# init main window\n\twindow = QtViewer()\n\t\n\t# set title\n\tif title is not None:\n\t\twindow.set_title(title)\n\t\n\t# check size\n\tif not width:\n\t\twidth = VIEWER_WIDTH\n\tif not height:\n\t\theight = VIEWER_HEIGHT\n\t\n\t# set size\n\twindow.set_size((width, height))\n\t\n\t# set graphics\n\twindow.set_content(graphics)\n\t\n\t# draw graphics\n\twindow.refresh()\n\t\n\t# start app\n\twindow.show()\n\tapp.exec()\n\n", "description": "\n\tShows given graphics in the viewer app.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics or pero.Control\n\t\t\tGraphics to be shown.\n\t\t\n\t\ttitle: str or None\n\t\t\tViewer frame title.\n\t\t\n\t\twidth: float or None\n\t\t\tViewer width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tViewer height in device units.\n\t", "category": "graphics", "imports": ["import os.path", "from . loader import QSizeF, QPageSize, QImage, QPrinter, QPainter, QApplication", "from . enums import *", "from . canvas import QtCanvas", "from . viewer import QtViewer"]}, {"term": "def", "name": "export", "data": "def export(graphics, path, width=None, height=None, **options):\n\t\"\"\"\n\tDraws given graphics into specified image file. The image format is\n\tdetermined from the extension of given file path. Supported extensions are\n\t.bmp, .gif, .jpg, .jpeg, .pdf and .png.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tpath: str\n\t\t\tFull path of a file to save the image into.\n\t\t\n\t\twidth: float or None\n\t\t\tImage width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage height in device units.\n\t\t\n\t\tdraw_scale: float\n\t\t\tDrawing scaling factor.\n\t\t\n\t\tline_scale: float\n\t\t\tLine scaling factor.\n\t\t\n\t\tfont_scale: float\n\t\t\tFont scaling factor.\n\t\t\n\t\tquality: int\n\t\t\tImage quality in range between 0 and 100 with 0 meaning very poor\n\t\t\tand 100 excellent. This option is only available for JPEG format.\n\t\"\"\"\n\t\n\t# get filename and extension\n\tdirname, filename = os.path.split(path)\n\tbasename, extension = os.path.splitext(filename)\n\textension = extension.lower()\n\t\n\t# export as raster image\n\tif extension in QT_RASTER_TYPES:\n\t\texport_raster(graphics, path, width, height, **options)\n\t\n\t# export as vector format\n\telif extension in QT_VECTOR_TYPES:\n\t\texport_vector(graphics, path, width, height, **options)\n\t\n\t# unsupported image format\n\telse:\n\t\tmessage = \"Unsupported image format! -> %s\" % extension\n\t\traise NotImplementedError(message)\n\n", "description": "\n\tDraws given graphics into specified image file. The image format is\n\tdetermined from the extension of given file path. Supported extensions are\n\t.bmp, .gif, .jpg, .jpeg, .pdf and .png.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tpath: str\n\t\t\tFull path of a file to save the image into.\n\t\t\n\t\twidth: float or None\n\t\t\tImage width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage height in device units.\n\t\t\n\t\tdraw_scale: float\n\t\t\tDrawing scaling factor.\n\t\t\n\t\tline_scale: float\n\t\t\tLine scaling factor.\n\t\t\n\t\tfont_scale: float\n\t\t\tFont scaling factor.\n\t\t\n\t\tquality: int\n\t\t\tImage quality in range between 0 and 100 with 0 meaning very poor\n\t\t\tand 100 excellent. This option is only available for JPEG format.\n\t", "category": "graphics", "imports": ["import os.path", "from . loader import QSizeF, QPageSize, QImage, QPrinter, QPainter, QApplication", "from . enums import *", "from . canvas import QtCanvas", "from . viewer import QtViewer"]}, {"term": "def", "name": "export_raster", "data": "def export_raster(graphics, path, width=None, height=None, **options):\n\t\"\"\"\n\tDraws given graphics as raster image into specified file. The image format\n\tis determined from the extension of given file path. Supported extensions\n\tare .bmp, .gif, .jpg, .jpeg and .png.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tpath: str\n\t\t\tFull path of a file to save the image into.\n\t\t\n\t\twidth: float or None\n\t\t\tImage width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage height in device units.\n\t\t\n\t\tdraw_scale: float\n\t\t\tDrawing scaling factor.\n\t\t\n\t\tline_scale: float\n\t\t\tLine scaling factor.\n\t\t\n\t\tfont_scale: float\n\t\t\tFont scaling factor.\n\t\t\n\t\tquality: int\n\t\t\tImage quality in range between 0 and 100 with 0 meaning very poor\n\t\t\tand 100 excellent.\n\t\"\"\"\n\t\n\t# check size\n\tif not width:\n\t\twidth = EXPORT_WIDTH\n\tif not height:\n\t\theight = EXPORT_HEIGHT\n\t\n\t# init app\n\tapp = QApplication.instance()\n\tif app is None:\n\t\tapp = QApplication([])\n\t\n\t# init image\n\timage = QImage(width, height, QImage.Format.Format_ARGB32)\n\t\n\t# init painter\n\tqp = QPainter()\n\tqp.begin(image)\n\tqp.setRenderHint(QPainter.RenderHint.Antialiasing)\n\tqp.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform)\n\t\n\t# init canvas\n\tcanvas = QtCanvas(qp, width=width, height=height)\n\t\n\tif 'draw_scale' in options:\n\t\tcanvas.draw_scale = options['draw_scale']\n\t\n\tif 'line_scale' in options:\n\t\tcanvas.line_scale = options['line_scale']\n\t\n\tif 'font_scale' in options:\n\t\tcanvas.font_scale = options['font_scale']\n\t\n\t# draw graphics\n\tgraphics.draw(canvas)\n\t\n\t# end drawing\n\tqp.end()\n\t\n\t# get image options\n\tquality = options.get('quality', -1)\n\t\n\t# save to file\n\timage.save(path, quality=quality)\n\n", "description": "\n\tDraws given graphics as raster image into specified file. The image format\n\tis determined from the extension of given file path. Supported extensions\n\tare .bmp, .gif, .jpg, .jpeg and .png.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tpath: str\n\t\t\tFull path of a file to save the image into.\n\t\t\n\t\twidth: float or None\n\t\t\tImage width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage height in device units.\n\t\t\n\t\tdraw_scale: float\n\t\t\tDrawing scaling factor.\n\t\t\n\t\tline_scale: float\n\t\t\tLine scaling factor.\n\t\t\n\t\tfont_scale: float\n\t\t\tFont scaling factor.\n\t\t\n\t\tquality: int\n\t\t\tImage quality in range between 0 and 100 with 0 meaning very poor\n\t\t\tand 100 excellent.\n\t", "category": "graphics", "imports": ["import os.path", "from . loader import QSizeF, QPageSize, QImage, QPrinter, QPainter, QApplication", "from . enums import *", "from . canvas import QtCanvas", "from . viewer import QtViewer"]}, {"term": "def", "name": "export_vector", "data": "def export_vector(graphics, path, width=None, height=None, **options):\n\t\"\"\"\n\tDraws given graphics as vector image into specified file. The image format\n\tis determined from the extension of given file path. Supported extension\n\tis .pdf only.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tpath: str\n\t\t\tFull path of a file to save the image into.\n\t\t\n\t\twidth: float or None\n\t\t\tImage width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage height in device units.\n\t\t\n\t\tdraw_scale: float\n\t\t\tDrawing scaling factor.\n\t\t\n\t\tline_scale: float\n\t\t\tLine scaling factor.\n\t\t\n\t\tfont_scale: float\n\t\t\tFont scaling factor.\n\t\"\"\"\n\t\n\t# check size\n\tif not width:\n\t\twidth = EXPORT_WIDTH\n\tif not height:\n\t\theight = EXPORT_HEIGHT\n\t\n\t# init app\n\tapp = QApplication.instance()\n\tif app is None:\n\t\tapp = QApplication([])\n\t\n\t# init page size\n\tsize = QPageSize(QSizeF(width, height), QPageSize.Unit.Point)\n\t\n\t# init printer\n\tprinter = QPrinter()\n\tprinter.setPageSize(size)\n\tprinter.setOutputFormat(QPrinter.OutputFormat.PdfFormat)\n\tprinter.setOutputFileName(path)\n\t\n\t# init painter\n\tqp = QPainter()\n\tqp.begin(printer)\n\tqp.setRenderHint(QPainter.RenderHint.Antialiasing)\n\tqp.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform)\n\t\n\t# init canvas\n\tcanvas = QtCanvas(qp, width=width, height=height)\n\t\n\tif 'draw_scale' in options:\n\t\tcanvas.draw_scale = options['draw_scale']\n\t\n\tif 'line_scale' in options:\n\t\tcanvas.line_scale = options['line_scale']\n\t\n\tif 'font_scale' in options:\n\t\tcanvas.font_scale = options['font_scale']\n\t\n\t# draw graphics\n\tgraphics.draw(canvas)\n\t\n\t# end drawing\n\tqp.end()\n", "description": "\n\tDraws given graphics as vector image into specified file. The image format\n\tis determined from the extension of given file path. Supported extension\n\tis .pdf only.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tpath: str\n\t\t\tFull path of a file to save the image into.\n\t\t\n\t\twidth: float or None\n\t\t\tImage width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage height in device units.\n\t\t\n\t\tdraw_scale: float\n\t\t\tDrawing scaling factor.\n\t\t\n\t\tline_scale: float\n\t\t\tLine scaling factor.\n\t\t\n\t\tfont_scale: float\n\t\t\tFont scaling factor.\n\t", "category": "graphics", "imports": ["import os.path", "from . loader import QSizeF, QPageSize, QImage, QPrinter, QPainter, QApplication", "from . enums import *", "from . canvas import QtCanvas", "from . viewer import QtViewer"]}], [{"term": "def", "name": "dt_dhms", "data": "def dt_dhms(dt):\n\treturn dt.days, dt.seconds//3600, (dt.seconds//60)%60, dt.seconds%60\n", "description": null, "category": "graphics", "imports": ["from displaybase import DisplayBase", "from rgbmatrix import graphics", "from datetime import datetime, timedelta", "import time", "import json"]}, {"term": "def", "name": "set_t0", "data": "def set_t0():\n\tglobal t0\n\tt0 = datetime.now()\n\tapp_data['t0'] = t0.isoformat()\n\n\ttry:\n\t\twith open(config_file, 'w') as f:\n\t\t\tjson.dump(app_data, f, indent=4)\n\n\texcept:\n\t\tprint('err')\n\n\treturn t0\n", "description": null, "category": "graphics", "imports": ["from displaybase import DisplayBase", "from rgbmatrix import graphics", "from datetime import datetime, timedelta", "import time", "import json"]}, {"term": "def", "name": "get_t0", "data": "def get_t0():\n\tglobal t0\n\n\ttry:\n\t\twith open(config_file) as f:\n\t\t\tapp_data = json.load(f)\n\n\t\tt0 = datetime.fromisoformat(app_data['t0'])\n\n\texcept:\n\t\tprint('err')\n\t\tset_t0()\n\n\treturn t0\n", "description": null, "category": "graphics", "imports": ["from displaybase import DisplayBase", "from rgbmatrix import graphics", "from datetime import datetime, timedelta", "import time", "import json"]}, {"term": "class", "name": "GraphicsTest", "data": "class GraphicsTest(DisplayBase):\n\tdef __init__(self, *args, **kwargs):\n\t\tsuper(GraphicsTest, self).__init__(*args, **kwargs)\n\n\tdef run(self):\n\t\tglobal t0\n\t\tcanvas = self.matrix\n\t\tfont = graphics.Font()\n\t\tfont.LoadFont(\"fonts/5x8.bdf\")\n\t\t#blue = graphics.Color(0, 0, 255)\n\t\tgreen = graphics.Color(0, 255, 0)\n\t\tred = graphics.Color(255, 0, 0)\n\t\twhite = graphics.Color(100, 100, 100)\n\t\torange = graphics.Color(255, 128, 0)\n\t\tbrown = graphics.Color(102, 51, 0)\n\n\t\t#set_t0()\n\t\tget_t0()\n\n\t\tinterval = 1\n\t\tnext_time = round(time.time() + interval) + 0.1\n\t\twhile True:\n\t\t\tt1 = datetime.now()\n\t\t\ttdiff = t0 - t1\n\t\t\tif tdiff < timedelta(hours=-24):\n\t\t\t\ttdiff = timedelta(0)\n\t\t\t\ttimecolor = white\n\t\t\t\tget_t0()\n\t\t\telif tdiff < timedelta(0):\n\t\t\t\ttdiff = timedelta(0)\n\t\t\t\ttimecolor = red\n\t\t\telse:\n\t\t\t\ttimecolor = green\n\n\n\t\t\ttdiff_dhms = dt_dhms(tdiff)\n\t\t\ttop_msg = f'{tdiff_dhms[0]:2d} {tdiff_dhms[1]:2d}'\n\t\t\tbot_msg = f'{tdiff_dhms[2]:2d} {tdiff_dhms[3]:2d}'\n\t\t\tday_msg = 'd'\n\t\t\thour_msg = 'h'\n\t\t\tmin_msg = 'm'\n\t\t\tsec_msg = 's'\n\n\t\t\tcanvas.Clear()\n\t\t\tgraphics.DrawText(canvas, font, 1, 7, timecolor, top_msg)\n\t\t\tgraphics.DrawText(canvas, font, 1, 14, timecolor, bot_msg)\n\t\t\tgraphics.DrawText(canvas, font, 11, 7, red, day_msg)\n\t\t\tgraphics.DrawText(canvas, font, 26, 7, red, hour_msg)\n\t\t\tgraphics.DrawText(canvas, font, 11, 14, red, min_msg)\n\t\t\tgraphics.DrawText(canvas, font, 26, 14, red, sec_msg)\n\n\t\t\t# Force time updates to happen on uniform intervals\\\n\t\t\tsleep_time = next_time - time.time()\n\t\t\tif sleep_time < 0.1:\n\t\t\t\tnext_time = round(time.time() + interval) + 0.1\n\t\t\t\tsleep_time = 0.2\n\t\t\t# print(f'sleep:{sleep_time} next{next_time} time{time_temp}')\n\t\t\ttime.sleep(sleep_time)\n\t\t\tnext_time += interval\n", "description": null, "category": "graphics", "imports": ["from displaybase import DisplayBase", "from rgbmatrix import graphics", "from datetime import datetime, timedelta", "import time", "import json"]}], [{"term": "def", "name": "GraphicsIO", "data": "def GraphicsIO(ecudata, controlQueue):\n\t\"\"\" GraphicsIO - output sensor data to graphics options: OLED screens or SDL windows on your desktop \"\"\"\n\t\n\t# Our process name\n\tproc_name = multiprocessing.current_process().name\n\tmyButtonId = settings.BUTTON_DEST_GRAPHICSIO\n\t\n\tlogger.info(\"GraphicsIO process now running\")\n\t\n\t# Counter to wake up the display loop\n\ti = 0\n\tbutton = False\n\t\n\t########################################################################\n\t#\n\t# This next chunk is all just SDL/desktop graphics initialisation\n\t#\n\t########################################################################\n\tUSE_SDL_GRAPHICS = False\n\tUSE_SDL_GRAPHICS_MASTER = False\n\tif settings.USE_SDL_GRAPHICS:\n\t\t################################################\n\t\t# Set up the main control window to mirror the big OLED screen\n\t\t################################################\n\t\twindowSettings = settings.GFX_MASTER_WINDOW\n\t\tresult = sdlInit(windowSettings, settings.GFX_MASTER_SIZE[0], settings.GFX_MASTER_SIZE[1])\n\t\tif result:\n\t\t\tUSE_SDL_GRAPHICS = True\n\t\t\tUSE_SDL_GRAPHICS_MASTER = True\n\t\telse:\n\t\t\tUSE_SDL_GRAPHICS = False\n\t\t\tUSE_SDL_GRAPHICS_MASTER = False\n\t\t################################################\n\t\t# Set up sub-windows to emulate the small OLED screens\n\t\t################################################\n\t\t#USE_SDL_GRAPHICS = True\n\t\t#for k in settings.GFX_WINDOWS.keys():\n\t\t#\twindowSettings = settings.GFX_WINDOWS[k]\n\t\t#\tresult = sdlInit(windowSettings, settings.GFX_OLED_SIZE[0], settings.GFX_OLED_SIZE[1])\n\t\t#\tif result:\n\t\t#\t\tsettings.GFX_WINDOWS[k] = result\n\t\t#\t\tUSE_SDL_GRAPHICS = True\n\t\t#\telse:\n\t\t#\t\tUSE_SDL_GRAPHICS = False\n\t\n\t#######################################################\n\t#\n\t# Initialise any I2C OLED devices\n\t#\n\t#######################################################\n\tUSE_OLED_GRAPHICS = False\n\tUSE_OLED_GRAPHICS_MASTER = False\n\tif settings.USE_OLED_GRAPHICS:\n\t\t################################################\n\t\t# Set up a the master windows on the main OLED screen\n\t\t################################################\n\t\tresult = oledInit(settings.GFX_MASTER_WINDOW, settings.GFX_MASTER_SIZE[0], settings.GFX_MASTER_SIZE[1])\n\t\tif result:\n\t\t\tsettings.GFX_MASTER_WINDOW = result\n\t\t\tUSE_OLED_GRAPHICS_MASTER = True\n\t\t\tUSE_OLED_GRAPHICS = True\n\t\n\t# Summary of available devices\n\tlogger.info(\"SDL graphics: %s\" % USE_SDL_GRAPHICS)\n\t#logger.info(\"SDL graphics: %s (master)\" % USE_SDL_GRAPHICS_MASTER)\n\tlogger.info(\"OLED graphics: %s\" % USE_OLED_GRAPHICS)\n\t#logger.info(\"OLED graphics: %s (master)\" % USE_OLED_GRAPHICS_MASTER)\n\t\n\tif (USE_SDL_GRAPHICS is False) and (USE_SDL_GRAPHICS_MASTER is False) and (USE_OLED_GRAPHICS is False) and (USE_OLED_GRAPHICS_MASTER is False):\n\t\tlogger.fatal(\"There are NO display devices available\")\n\t\tlogger.fatal(\"This process will now exit - we cannot display anything!\")\n\t\texit(1)\n\t\t\t\n\t# Pre-load any image assets\n\timage_assets = buildImageAssets(USE_OLED_GRAPHICS_MASTER, USE_SDL_GRAPHICS_MASTER)\n\n\t#####################################################################################\n\t#\n\t# This next section shows a splash logo and a few loading screens in turn, \n\t# just so that we delay sensor output until the serial port has started to\n\t# gather data.\n\t#\n\t#####################################################################################\n\t\n\t# Show the splash logo\n\tr = \"%sx%s\" % (settings.GFX_MASTER_SIZE[0], settings.GFX_MASTER_SIZE[1])\n\t# Splash logo sequence\n\tfor i in ['boot_logo', 'boot_logo1']:\n\t\timage = image_assets[i][r].copy()\n\t\tif USE_OLED_GRAPHICS_MASTER:\n\t\t\tupdateOLEDScreen(pilImage = image, windowSettings = settings.GFX_MASTER_WINDOW)\n\t\tif USE_SDL_GRAPHICS:\n\t\t\tupdateSDLWindow(pilImage = image, windowSettings = settings.GFX_MASTER_WINDOW)\n\n\t\t# Slide out intro screen....\n\t\ttime.sleep(1.5)\n\t\tslideBitmapVertical(\n\t\t\tbitmap = image,\n\t\t\tx_start = 0, \n\t\t\ty_start = 0, \n\t\t\ty_end = settings.GFX_MASTER_WINDOW['y_size'], \n\t\t\tdirection = \"down\", \n\t\t\tsteps = 30,\n\t\t\tsleep = 0.025,\n\t\t\twindowSettings = settings.GFX_MASTER_WINDOW,\n\t\t\tUSE_SDL_GRAPHICS = USE_SDL_GRAPHICS,\n\t\t\tUSE_OLED_GRAPHICS = USE_OLED_GRAPHICS\n\t\t)\t\t\n\t\t\n\t# Show a 'please wait' loading sequence - just so that the serial port can \n\t# start collecting data or finish setting up.\n\tr = \"%sx%s\" % (settings.GFX_MASTER_SIZE[0], settings.GFX_MASTER_SIZE[1])\n\tres_list = list(image_assets['wait_sequence'].keys())\t\n\tframe_count = len(res_list[0])\n\tframes = range(0, frame_count -1)\n\tfor f in frames:\n\t\tif r in image_assets['wait_sequence'].keys():\n\t\t\t# Main screen\n\t\t\tr = \"%sx%s\" % (settings.GFX_MASTER_SIZE[0], settings.GFX_MASTER_SIZE[1])\n\t\t\timage = image_assets['wait_sequence'][r][f]\n\t\t\tif USE_OLED_GRAPHICS_MASTER:\n\t\t\t\tupdateOLEDScreen(pilImage = image, windowSettings = settings.GFX_MASTER_WINDOW)\t\t\n\t\t\tif USE_SDL_GRAPHICS:\n\t\t\t\tupdateSDLWindow(pilImage = image, windowSettings = settings.GFX_MASTER_WINDOW)\n\t\t\ttime.sleep(0.5)\n\t\n\t####################################################################################\n\t#\n\t# Now begin the main display loop\n\t#\n\t####################################################################################\n\t\t\n\t# Default selected window\n\tselectWindowIdx = 0\n\tselectWindow = None\t\t\n\t\t\n\tif settings.GFX_SLEEP_TIME == 0:\n\t\tlogger.warn(\"Graphics frame limiter disabled - frames will be rendered as fast as possible\")\n\t\tlogger.warn(\"This may result in uneven performance!\")\n\n\t# Set display mode defaults\n\tsettings.GFX_MASTER_WINDOW['displayModes'] = {}\n\tfor sensor in settings.SENSORS:\n\t\tsensorId = sensor['sensorId']\n\t\tlogger.debug(\"Adjusting %s sensor defaults for the current %dx%d output device\" % (sensorId, settings.GFX_MASTER_WINDOW['x_size'],settings.GFX_MASTER_WINDOW['y_size']))\n\t\tsettings.GFX_MASTER_WINDOW['displayModes'][sensorId] = sensorGraphicsInit(sensor, settings.GFX_MASTER_WINDOW)\n\n\tlogger.info(\"Entering main graphics loop now...\")\n\tif settings.INFO:\n\t\tt0 = timeit.default_timer()\n\t\tfps = 0\n\t\tfired_windows = 0\n\t\t\n\t# Slide out intro screen....\n\tslideBitmapVertical(\n\t\tbitmap = image.copy(),\n\t\tx_start = 0, \n\t\ty_start = 0, \n\t\ty_end = settings.GFX_MASTER_WINDOW['y_size'], \n\t\tdirection = \"down\", \n\t\tsteps = 30,\n\t\tsleep = 0.025,\n\t\twindowSettings = settings.GFX_MASTER_WINDOW,\n\t\tUSE_SDL_GRAPHICS = USE_SDL_GRAPHICS,\n\t\tUSE_OLED_GRAPHICS = USE_OLED_GRAPHICS\n\t)\n\t\n\t# Default state of various indicators\n\tIS_LOGGING = False\n\tIS_POWERED = True\n\tIS_ECU_ERROR = False\n\tIS_AEM_ERROR = False\n\tIS_DEMO_ENABLED = False\n\t\n\twhile True:\n\t\t\n\t\t# Set a timer for this loop\n\t\tif settings.INFO:\n\t\t\tt1 = timeit.default_timer()\n\t\t\n\t\t####################################################\n\t\t#\n\t\t# Listen for control messages\n\t\t#\n\t\t####################################################\n\t\tif controlQueue.empty() == False:\n\t\t\tcdata = controlQueue.get()\n\t\t\tif cdata.isMine(myButtonId):\n\t\t\t\tlogger.debug(\"Got a control message\")\n\n\t\t\t\tif cdata.button == settings.STATUS_SHUTDOWN:\n\t\t\t\t\tlogger.critical(\"Shutting down\")\n\t\t\t\t\tsys.exit(0)\n\n\t\t\t\t##########################################################\n\t\t\t\t# ECU Reset underware\n\t\t\t\t##########################################################\n\t\t\t\tif cdata.button and (cdata.button == settings.BUTTON_RESET_ECU):\n\t\t\t\t\tlogger.info(\"Showing comms reset message\")\n\t\t\t\t\timage = addResetStatus(pilImage = image, windowSettings = windowSettings)\n\t\t\t\t\tif USE_OLED_GRAPHICS:\n\t\t\t\t\t\t# Update the OLED screen\n\t\t\t\t\t\tupdateOLEDScreen(pilImage = image, windowSettings = windowSettings)\n\t\t\t\t\t\n\t\t\t\t\tif USE_SDL_GRAPHICS:\n\t\t\t\t\t\t# Update the SDL window\n\t\t\t\t\t\tupdateSDLWindow(pilImage = image, windowSettings = windowSettings)\n\t\t\t\t\ttime.sleep(5)\n\n\t\t\t\t##########################################################\n\t\t\t\t# Logging status\n\t\t\t\t##########################################################\n\t\t\t\tif cdata.button and (cdata.button == settings.BUTTON_LOGGING_STATUS):\n\t\t\t\t\tif cdata.data['status'] is True:\n\t\t\t\t\t\tif IS_LOGGING is False:\n\t\t\t\t\t\t\tlogger.info(\"Enabling logging status message\")\n\t\t\t\t\t\t\tIS_LOGGING = True\n\t\t\t\t\telse:\n\t\t\t\t\t\tif IS_LOGGING:\n\t\t\t\t\t\t\tlogger.info(\"Disabling logging status message\")\n\t\t\t\t\t\t\tIS_LOGGING = False\n\n\t\t\t\t##########################################################\n\t\t\t\t# Power is off / timer until shutdown/ignition turned back on\n\t\t\t\t##########################################################\n\t\t\t\tif cdata.button and (cdata.button == settings.STATUS_POW_ERROR):\n\t\t\t\t\tpass\n\t\t\t\tif cdata.button and (cdata.button == settings.STATUS_POW_OK):\n\t\t\t\t\tpass\n\n\t\t\t\t##########################################################\n\t\t\t\t# ECU connection error\n\t\t\t\t##########################################################\n\t\t\t\tif cdata.button and (cdata.button == settings.STATUS_ECU_ERROR):\n\t\t\t\t\tIS_ECU_ERROR = True\n\t\t\t\tif cdata.button and (cdata.button == settings.STATUS_ECU_OK):\n\t\t\t\t\tIS_ECU_ERROR = False\n\n\t\t\t\t##########################################################\n\t\t\t\t# AEM connection error\n\t\t\t\t##########################################################\n\t\t\t\tif cdata.button and (cdata.button == settings.STATUS_AEM_ERROR):\n\t\t\t\t\tIS_AEM_ERROR = True\n\t\t\t\tif cdata.button and (cdata.button == settings.STATUS_AEM_OK):\n\t\t\t\t\tIS_AEM_ERROR = False\n\n\t\t\t\t##########################################################\n\t\t\t\t# Demo mode\n\t\t\t\t##########################################################\n\t\t\t\tif cdata.button and (cdata.button == settings.STATUS_DEMO_ENABLED):\n\t\t\t\t\tIS_DEMO_ENABLED = True\n\t\t\t\tif cdata.button and (cdata.button == settings.STATUS_DEMO_DISABLED):\n\t\t\t\t\tIS_DEMO_ENABLED = False\n\n\t\t\t\t##########################################################\n\t\t\t\t# Change sensor for the window\n\t\t\t\t##########################################################\n\t\t\t\tif cdata.button and (cdata.button == settings.BUTTON_SENSOR_NEXT):\n\t\t\t\t\n\t\t\t\t\tlogger.info(\"SENSOR: Control data received to change sensor\")\n\t\t\t\t\tlogger.info(\"SENSOR: Current window has sensor [%s] index [%s]\" % (settings.GFX_MASTER_WINDOW['currentSensorId'], settings.GFX_MASTER_WINDOW['currentSensorIdx']))\n\t\t\t\t\t# Select next sensor, handling sensor list wraparound\n\t\t\t\t\tif settings.GFX_MASTER_WINDOW['currentSensorIdx'] < (len(settings.GFX_MASTER_WINDOW['sensorIds']) - 1):\n\t\t\t\t\t\tsettings.GFX_MASTER_WINDOW['currentSensorIdx'] += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\tsettings.GFX_MASTER_WINDOW['currentSensorIdx'] = 0\n\t\t\t\t\n\t\t\t\t\tsettings.GFX_MASTER_WINDOW['currentSensorId'] = settings.GFX_MASTER_WINDOW['sensorIds'][settings.GFX_MASTER_WINDOW['currentSensorIdx']]\n\t\t\t\t\tlogger.info(\"SENSOR: Current window now has sensor [%s] index [%s]\" % (settings.GFX_MASTER_WINDOW['currentSensorId'], settings.GFX_MASTER_WINDOW['currentSensorIdx']))\n\t\t\t\t\t\n\t\t\t\t\t# Slide the current sensor screen out\n\t\t\t\t\tslideBitmapVertical(\n\t\t\t\t\t\tbitmap = image.copy(),\n\t\t\t\t\t\tx_start = 0, \n\t\t\t\t\t\ty_start = 0, \n\t\t\t\t\t\ty_end = settings.GFX_MASTER_WINDOW['y_size'], \n\t\t\t\t\t\tdirection = \"down\", \n\t\t\t\t\t\tsteps = 10,\n\t\t\t\t\t\tsleep = 0.025,\n\t\t\t\t\t\twindowSettings = settings.GFX_MASTER_WINDOW,\n\t\t\t\t\t\tUSE_SDL_GRAPHICS = USE_SDL_GRAPHICS,\n\t\t\t\t\t\tUSE_OLED_GRAPHICS = USE_OLED_GRAPHICS\n\t\t\t\t\t)\t\t\t\t\t\n\t\t\t\t\ttime.sleep(0.2)\n\t\t\t#time.sleep(0.2)\n\t\t\t\n\t\t##############################################################\n\t\t#\n\t\t# Update each OLED or SDL gfx sub-window in turn\n\t\t#\n\t\t##############################################################\n\t\t\t\t\n\t\twindowSettings = settings.GFX_MASTER_WINDOW\n\t\twindowSettings['currentSensorId'] = settings.GFX_MASTER_WINDOW['sensorIds'][settings.GFX_MASTER_WINDOW['currentSensorIdx']]\n\t\tif (requiresRefresh(windowSettings)):\n\t\t\t# Generate the latest image of sensor data for this gfx window (be it SDL or OLED)\n\t\t\tcurrentSensorId = windowSettings['currentSensorId']\n\t\t\tcurrentMode = windowSettings['currentMode']\n\t\t\t\n\t\t\t# Add latest sensor value to list of previous values\n\t\t\t# As the list is a fixed size, this also pushes the oldest\n\t\t\t# value off the back of the list.\n\t\t\tvalue = ecudata.getData(currentSensorId)\n\t\t\tif value:\n\t\t\t\twindowSettings['displayModes'][currentSensorId]['previousValues'].append(value)\n\t\t\tsensorData = ecudata.getSensorData(currentSensorId)\n\t\t\t\n\t\t\t# Simple numeric gauge\n\t\t\tif currentMode == settings.GFX_MODE_NUMERIC:\n\t\t\t\t# Simple numeric display\n\t\t\t\timage = gaugeNumeric(ecudata = ecudata,\n\t\t\t\t\tsensor = windowSettings['displayModes'][currentSensorId],\n\t\t\t\t\twindowSettings = windowSettings,\n\t\t\t\t\tsensorData = sensorData\n\t\t\t\t)\n\t\t\telse:\n\t\t\t\tpass\n\t\t\t\n\t\t\t# Display any warning/errors/status messages\n\t\t\tif IS_LOGGING:\n\t\t\t\taddLogStatus(pilImage = image, windowSettings = windowSettings)\n\t\t\t\n\t\t\t# Display any demo mode status\n\t\t\tif IS_DEMO_ENABLED:\n\t\t\t\taddDemoStatus(pilImage = image, windowSettings = windowSettings)\n\t\t\t\n\t\t\t# Display ECU error connection status\n\t\t\tif IS_ECU_ERROR:\n\t\t\t\taddECUStatus(pilImage = image, windowSettings = windowSettings)\n\t\t\telse:\n\t\t\t\t# We only print the AEM AFR error status if the main ECU is \n\t\t\t\t# not already in error!\n\t\t\t\tif IS_AEM_ERROR:\n\t\t\t\t\taddAEMStatus(pilImage = image, windowSettings = windowSettings)\n\t\t\t\n\t\t\tif USE_OLED_GRAPHICS:\n\t\t\t\t# Update the OLED screen\n\t\t\t\tupdateOLEDScreen(pilImage = image, windowSettings = windowSettings)\n\t\t\t\n\t\t\tif USE_SDL_GRAPHICS:\n\t\t\t\t# Update the SDL window\n\t\t\t\tupdateSDLWindow(pilImage = image, windowSettings = windowSettings)\n\t\t\t\t\n\t\t\t# Reset the timer for this window\n\t\t\tsetRefresh(windowSettings)\n\t\t\t\n\t\t\tfired_windows += 1\n\t\t\n\t\t# Timers to work out average latency for updating all windows\n\t\t# as well as a rough approximation of frames generated per second\n\t\tif settings.DEBUG:\n\t\t\tfps += 1\n\t\t\tt2 = timeit.default_timer()\n\t\t\tlogger.debug(\"Update latency this loop: %6.4fms\" % ((t2 - t1) * 1000))\n\t\t\tt = t2 - t0\n\t\t\tif t >= settings.GFX_FRAME_COUNT_TIME:\n\t\t\t\tlogger.debug(\"Image update speed approximately: %sfps [%s frames / %6.3fs]\" % (fired_windows / settings.GFX_FRAME_COUNT_TIME, fired_windows, t))\n\t\t\t\tfps = 0\n\t\t\t\tfired_windows = 0\n\t\t\t\tt0 = timeit.default_timer()\n\t\t\t\t\n\t\t# After updating all of the windows, sleep so that we limit the amount of screen refreshes we do\n\t\ttime.sleep(settings.GFX_SLEEP_TIME)\n\t\t\n\t\t# At the end of the loop the variable 'image' always contains the content of the screen from the last update\n\t\t# ...\n", "description": " GraphicsIO - output sensor data to graphics options: OLED screens or SDL windows on your desktop ", "category": "graphics", "imports": ["import multiprocessing", "import math", "import time", "import timeit ", "import numpy", "import sys", "import os", "import copy", "import traceback", "from collections import deque", "import sdl2", "import sdl2.ext", "from PIL import Image", "from PIL import ImageOps", "from PIL import ImageDraw", "from PIL import ImageFont", "from iomodules.graphics.SDLInit import sdlInit", "from iomodules.graphics.OLEDInit import oledInit", "from iomodules.graphics.GraphicsUtils import *", "from libs import settings", "from libs.ControlData import ControlData", "from libs.newlog import newlog"]}, {"term": "def", "name": "slideBitmapVertical", "data": "def slideBitmapVertical(bitmap = None, x_start = 0, y_start = 0, y_end = 0, steps = 0, direction = \"up\", sleep = 0.1, windowSettings = None, USE_SDL_GRAPHICS = False, USE_OLED_GRAPHICS = False):\n\t\"\"\" Slide in a bitmap vertically - either from top or bottom of screen \"\"\"\n\t\n\ty_pos = y_start\n\ty_increment = int(bitmap.size[1]/steps)\n\timage = None\n\t\n\tif direction == \"up\":\n\t\t# Slide a bitmap from bottom to top\n\t\tlogger.debug(\"Vertically sliding image up from y:%s to y:%s in x%s %spx steps\" % (y_start, y_end, steps, y_increment))\n\t\tfor i in range(0, steps + 1):\n\t\t\timage = Image.new('1', (settings.GFX_MASTER_WINDOW['x_size'], settings.GFX_MASTER_WINDOW['y_size']))\n\t\t\tlogger.debug(\"Pasting bitmap at x:%s,y:%s\" % (x_start, y_pos))\n\t\t\timage.paste(bitmap,(x_start, y_pos))\n\t\t\tif USE_OLED_GRAPHICS:\n\t\t\t\tupdateOLEDScreen(pilImage = image, windowSettings = windowSettings)\n\t\t\tif USE_SDL_GRAPHICS:\n\t\t\t\tupdateSDLWindow(pilImage = image, windowSettings = windowSettings)\n\t\t\ttime.sleep(sleep)\n\t\t\ty_pos -= y_increment\n\telse:\n\t\tlogger.debug(\"Vertically sliding image up from y:%s to y:%s - %s steps\" % (y_start, y_end, steps))\n\t\tl = list(range(0, steps + 1))\n\t\tl.reverse()\n\t\tfor i in l: \n\t\t\timage = Image.new('1', (settings.GFX_MASTER_WINDOW['x_size'], settings.GFX_MASTER_WINDOW['y_size']))\n\t\t\tlogger.debug(\"Pasting bitmap at x:%s,y:%s\" % (x_start, y_pos))\n\t\t\timage.paste(bitmap,(x_start, y_pos))\n\t\t\tif USE_OLED_GRAPHICS:\n\t\t\t\tupdateOLEDScreen(pilImage = image, windowSettings = windowSettings)\n\t\t\tif USE_SDL_GRAPHICS:\n\t\t\t\tupdateSDLWindow(pilImage = image, windowSettings = windowSettings)\n\t\t\ttime.sleep(sleep)\n\t\t\ty_pos += y_increment\n\t\t# Slide a bitmap from top to bottom\n", "description": " Slide in a bitmap vertically - either from top or bottom of screen ", "category": "graphics", "imports": ["import multiprocessing", "import math", "import time", "import timeit ", "import numpy", "import sys", "import os", "import copy", "import traceback", "from collections import deque", "import sdl2", "import sdl2.ext", "from PIL import Image", "from PIL import ImageOps", "from PIL import ImageDraw", "from PIL import ImageFont", "from iomodules.graphics.SDLInit import sdlInit", "from iomodules.graphics.OLEDInit import oledInit", "from iomodules.graphics.GraphicsUtils import *", "from libs import settings", "from libs.ControlData import ControlData", "from libs.newlog import newlog"]}], [], [], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis widget is an easy starting point for generating multi-panel figures.\n\tExample::\n\t\n\t\tw = pg.GraphicsLayoutWidget()\n\t\tp1 = w.addPlot(row=0, col=0)\n\t\tp2 = w.addPlot(row=0, col=1)\n\t\tv = w.addViewBox(row=1, col=0, colspan=2)\n\t\n\t=========  =================================================================\n\tparent\t (QWidget or None) The parent widget.\n\tshow\t   (bool) If True, then immediately show the widget after it is\n\t\t\t   created. If the widget has no parent, then it will be shown\n\t\t\t   inside a new window.\n\tsize\t   (width, height) tuple. Optionally resize the widget. Note: if\n\t\t\t   this widget is placed inside a layout, then this argument has no\n\t\t\t   effect.\n\ttitle\t  (str or None) If specified, then set the window title for this\n\t\t\t   widget.\n\tkargs\t  All extra arguments are passed to\n\t\t\t   :meth:`GraphicsLayout.__init__\n\t\t\t   `\n\t=========  =================================================================\n\t\t\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, show=False, size=None, title=None, **kargs):\n\t\tmkQApp()\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n\t\t\n\t\tif size is not None:\n\t\t\tself.resize(*size)\n\t\t\t\n\t\tif title is not None:\n\t\t\tself.setWindowTitle(title)\n\t\t\t\n\t\tif show is True:\n\t\t\tself.show()\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis widget is an easy starting point for generating multi-panel figures.\n\tExample::\n\t\n\t\tw = pg.GraphicsLayoutWidget()\n\t\tp1 = w.addPlot(row=0, col=0)\n\t\tp2 = w.addPlot(row=0, col=1)\n\t\tv = w.addViewBox(row=1, col=0, colspan=2)\n\t\n\t=========  =================================================================\n\tparent\t (QWidget or None) The parent widget.\n\tshow\t   (bool) If True, then immediately show the widget after it is\n\t\t\t   created. If the widget has no parent, then it will be shown\n\t\t\t   inside a new window.\n\tsize\t   (width, height) tuple. Optionally resize the widget. Note: if\n\t\t\t   this widget is placed inside a layout, then this argument has no\n\t\t\t   effect.\n\ttitle\t  (str or None) If specified, then set the window title for this\n\t\t\t   widget.\n\tkargs\t  All extra arguments are passed to\n\t\t\t   :meth:`GraphicsLayout.__init__\n\t\t\t   `\n\t=========  =================================================================\n\t\t\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import mkQApp", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [{"term": "def", "name": "get_complexity", "data": "def get_complexity():\n\n\t\"\"\"\n\tGets the player input from the command line and updates the global variable level that is used to make difference\n\tbetween AI playing strategies.\n\t:return:\n\t\"\"\"\n\n\tglobal level\n\tmy_level = input()\n\tif my_level == \"1\":\n\t\tlevel = 1\n\telif my_level == \"2\":\n\t\tlevel = 2\n\telif my_level == \"3\":\n\t\tlevel = 3\n\n", "description": "\n\tGets the player input from the command line and updates the global variable level that is used to make difference\n\tbetween AI playing strategies.\n\t:return:\n\t", "category": "graphics", "imports": ["import sys", "import pygame", "import myGraphics", "import random"]}, {"term": "def", "name": "check_last_row", "data": "def check_last_row(last_r):\n\n\t\"\"\"\n\tGets the current lowest row that is used to place pieces on the board and checks if it has any available positions.\n\t:param last_r: The current lowest row with free positions on the board\n\t:return rez: Counter that is used to check how many available positions remained on the actual row and returned by\n\tthis function in order to complete further actions.\n\t\"\"\"\n\n\trez = columns\n\tfor col in range(columns):\n\t\tif myGraphics.board[last_r][col] == 1:\n\t\t\trez = rez - 1\n\t\telif myGraphics.board[last_r][col] == 2:\n\t\t\trez = rez - 1\n\t\telse:\n\t\t\tpass\n\treturn rez\n\n", "description": "\n\tGets the current lowest row that is used to place pieces on the board and checks if it has any available positions.\n\t:param last_r: The current lowest row with free positions on the board\n\t:return rez: Counter that is used to check how many available positions remained on the actual row and returned by\n\tthis function in order to complete further actions.\n\t", "category": "graphics", "imports": ["import sys", "import pygame", "import myGraphics", "import random"]}, {"term": "def", "name": "check_winner", "data": "def check_winner():\n\n\t\"\"\"\n\tThis function is called after everytime a  move is made on the board in order to check if there is already a winner\n\tfor the game.\n\tDepending on the direction of checking, every 4 elements will be selected and verified if they represent a row of\n\tthe same pieces.\n\t:return:\n\t\t1 - player 1 wins\n\t\t2 - player 2 wins\n\t\t3 - there are no winners yet\n\t\"\"\"\n\n\tfor c in range(COLUMNS-3):  # check horizontal combinations\n\t\tfor r in range(ROWS):\n\t\t\tif myGraphics.board[r][c] == 1 and myGraphics.board[r][c + 1] == 1 and myGraphics.board[r][c + 2] == 1 and \\\n\t\t\t\t\tmyGraphics.board[r][c + 3] == 1:\n\t\t\t\treturn 1\n\t\t\tif myGraphics.board[r][c] == 2 and myGraphics.board[r][c + 1] == 2 and myGraphics.board[r][c + 2] == 2 and \\\n\t\t\t\t\tmyGraphics.board[r][c + 3] == 2:\n\t\t\t\treturn 2\n\tfor c in range(COLUMNS):   # check vertical combinations\n\t\tfor r in range(ROWS - 3):\n\t\t\tif myGraphics.board[r][c] == 1 and myGraphics.board[r + 1][c] == 1 and myGraphics.board[r + 2][c] == 1 and \\\n\t\t\t\t\tmyGraphics.board[r + 3][c] == 1:\n\t\t\t\treturn 1\n\t\t\tif myGraphics.board[r][c] == 2 and myGraphics.board[r + 1][c] == 2 and myGraphics.board[r + 2][c] == 2 and \\\n\t\t\t\t\tmyGraphics.board[r + 3][c] == 2:\n\t\t\t\treturn 2\n\tfor c in range(COLUMNS - 3):  # check main diagonal\n\t\tfor r in range(ROWS - 3):\n\t\t\tif myGraphics.board[r][c] == 1 and myGraphics.board[r + 1][c + 1] == 1 and\\\n\t\t\t\t\tmyGraphics.board[r + 2][c + 2] == 1 and myGraphics.board[r + 3][c + 3] == 1:\n\t\t\t\treturn 1\n\t\t\tif myGraphics.board[r][c] == 2 and myGraphics.board[r + 1][c + 1] == 2 and \\\n\t\t\t\t\tmyGraphics.board[r + 2][c + 2] == 2 and myGraphics.board[r + 3][c + 3] == 2:\n\t\t\t\treturn 2\n\tfor c in range(COLUMNS - 3):  # check on secondary diagonal\n\t\tfor r in range(3, ROWS):\n\t\t\tif myGraphics.board[r][c] == 1 and myGraphics.board[r - 1][c + 1] == 1 and \\\n\t\t\t\t\tmyGraphics.board[r - 2][c + 2] == 1 and myGraphics.board[r - 3][c + 3] == 1:\n\t\t\t\treturn 1\n\t\t\tif myGraphics.board[r][c] == 2 and myGraphics.board[r - 1][c + 1] == 2 and \\\n\t\t\t\t\tmyGraphics.board[r - 2][c + 2] == 2 and myGraphics.board[r - 3][c + 3] == 2:\n\t\t\t\treturn 2\n\treturn 3\n\n", "description": "\n\tThis function is called after everytime a  move is made on the board in order to check if there is already a winner\n\tfor the game.\n\tDepending on the direction of checking, every 4 elements will be selected and verified if they represent a row of\n\tthe same pieces.\n\t:return:\n\t\t1 - player 1 wins\n\t\t2 - player 2 wins\n\t\t3 - there are no winners yet\n\t", "category": "graphics", "imports": ["import sys", "import pygame", "import myGraphics", "import random"]}, {"term": "def", "name": "get_best_move", "data": "def get_best_move():\n\n\t\"\"\"\n\tThe current function has as purpose calculating the best move AI could perform at hard level.\n\tWhen human puts a piece on board it calculates the available positions on the horizontal(right, left) and vertical\n\tdirections, then chooses random one of them in order to block the player.\n\t:return:\n\tIf the position is possible to calculate, function returns the choice.\n\t\"\"\"\n\n\tdirections = list()\n\tfor column in range(COLUMNS):\n\t\tfor row in range(ROWS):\n\t\t\tif myGraphics.board[row][column] == 1:\n\t\t\t\tif column-1 >= 0 and myGraphics.board[row][column-1] == 0:\n\t\t\t\t\tdirections.append((row, column - 1))\n\t\t\t\tif column+1 < COLUMNS and myGraphics.board[row][column+1] == 0:\n\t\t\t\t\tdirections.append((row, column + 1))\n\t\t\t\tif row-1 >= 0 and myGraphics.board[row-1][column] == 0:\n\t\t\t\t\tdirections.append((row - 1, column))\n\tif len(directions) > 0:\n\t\treturn random.choice(directions)\n\n", "description": "\n\tThe current function has as purpose calculating the best move AI could perform at hard level.\n\tWhen human puts a piece on board it calculates the available positions on the horizontal(right, left) and vertical\n\tdirections, then chooses random one of them in order to block the player.\n\t:return:\n\tIf the position is possible to calculate, function returns the choice.\n\t", "category": "graphics", "imports": ["import sys", "import pygame", "import myGraphics", "import random"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tglobal NUM_LIVES, bol_x, bol_y, disbrick\n\twhile NUM_LIVES > 0:\n\t\tpause(FRAME_RATE)\n\t\t#\u5b9a\u7fa9vx,vy\n\t\tvx = graphics.get_dx()\n\t\tvy = graphics.get_dy()\n\t\t#\u6587\u5b57\u8868\u793a\u72c0\u614b\n\t\tgraphics.score.text= \"\u5206\u6578:\" + str(disbrick)+ \"\u8840\u91cf:\" + str(NUM_LIVES)\n\t\t#\u9ede\u64ca\u5f8c\u7403\u52d5\u4f5c\n\t\tif graphics.count == 1:\n\t\t\tgraphics.ball.move(vx,vy)\n\t\t\tbo_x=0\n\t\t\tbo_y=0\n\t\t\t#\u6c92\u63a5\u5230\u6263\u4e00\u6ef4\u8840\uff0c\u7403\u56de\u5230\u539f\u9ede\n\t\t\tif graphics.ball.y+graphics.ball.height >= graphics.window.height:\n\t\t\t\tNUM_LIVES -=1\n\t\t\t\tgraphics.count = 0\n\t\t\t\tgraphics.reset_ball()\n\t\t\t#\u78b0\u649e\u7246\u58c1\n\t\t\tgraphics.check_wall()\n\t\t\t# if graphics.ball.x <=0 or graphics.ball.x+graphics.ball.width >= graphics.window.width:\n\t\t\t#\t vx *=-1\n\t\t\t# if graphics.ball.y <= 0:\n\t\t\t#\t vy *=-1\n\t\t\t# if graphics.window.get_object_at(graphics.ball.x,graphics.ball.y+graphics.ball.height) is graphics.paddle:\n\t\t\t#\t vy *=-1\n\t\t\t#\u5b9a\u7fa9\u74034\u500b\u65b9\u4f4d\n\t\t\tobj1=graphics.window.get_object_at(graphics.ball.x,graphics.ball.y)\n\t\t\tobj2=graphics.window.get_object_at(graphics.ball.x+graphics.ball.width,graphics.ball.y)\n\t\t\tobj3=graphics.window.get_object_at(graphics.ball.x,graphics.ball.y+graphics.ball.height)\n\t\t\tobj4=graphics.window.get_object_at(graphics.ball.x+graphics.ball.width,graphics.ball.y+graphics.ball.height)\n\t\t\t#\u5224\u5b9a\u78b0\u649e\n\t\t\tbo1= obj1 is not None and obj1 is not graphics.paddle\n\t\t\tbo2= obj2 is not None and obj2 is not graphics.paddle\n\t\t\tbo3= obj3 is not None and obj3 is not graphics.paddle\n\t\t\tbo4= obj4 is not None and obj4 is not graphics.paddle\n\n\t\t\t#\u5224\u65b7\u78b0\u649e\u5f8cxy\u7684\u521d\u901f\u7684\u65b9\u5411(\u5b9a\u7fa94\u500b\u9ede\u649e\u64ca\u5230\u6642\u7403\u6703\u5982\u4f55\u8dd1\u52d5):\n\t\t\tif bo1: #\u5075\u6e2c\u5230\u5de6\u4e0a\u65b9\uff0c\u5f80\u53f3\u4e0b\u8dd1\n\t\t\t\tbo_x += 1\n\t\t\t\tbo_y += 1\n\t\t\tif bo2: #\u5075\u6e2c\u5230\u53f3\u4e0a\u65b9\uff0c\u5f80\u5de6\u4e0b\u8dd1\n\t\t\t\tbo_x -= 1\n\t\t\t\tbo_y += 1\n\t\t\tif bo3: #\u5075\u6e2c\u5230\u5de6\u4e0b\u65b9\uff0c\u5f80\u53f3\u4e0a\u8dd1\n\t\t\t\tbo_x += 1\n\t\t\t\tbo_y -= 1\n\t\t\tif bo4: #\u5075\u6e2c\u5230\u53f3\u4e0a\u65b9\uff0c\u5f80\u5de6\u4e0a\u8dd1\n\t\t\t\tbo_x -= 1\n\t\t\t\tbo_y -= 1\n\n\t\t\t#\u5224\u65b7\u649e\u64ca\u5f8c\uff0c\u7403\u79fb\u52d5\u7684\u65b9\u5411(\u5c07bo_x,b0_\u500b\u5225\u52a0\u7e3d\u8d77\u4f86\u5224\u65b7(\u7b49\u540c\u5075\u6e2c\u78b0\u649e1\u500b\u89d2\u30012\u500b\u89d2\u9084\u662f3\u500b\u89d2\u7684\u8dd1\u52d5\u65b9\u5f0f):\n\t\t\tif bo_x > 0:\n\t\t\t\tgraphics.bo_x1 = abs(vx)\n\t\t\t\tgraphics.bouncing()\n\t\t\telif bo_x < 0:\n\t\t\t\tgraphics.bo_x2 = -abs(vx)\n\t\t\t\tgraphics.bouncing()\n\t\t\tif bo_y > 0 :\n\t\t\t\tgraphics.bo_y1 = abs(vx)\n\t\t\t\tgraphics.bouncing()\n\t\t\telif bo_y < 0:\n\t\t\t\tgraphics.bo_y2 = -abs(vx)\n\t\t\t\tgraphics.bouncing()\n\n\t\t\t#\u53d6\u4ee3\u524d\u9762\u7684\u4f4d\u7f6e\uff0c\u4e26\u522a\u9664\u65b9\u584a(\u6b64\u5224\u65b7\u6253\u6389\u4e00\u500b\u7b97\u4e00\u5206\uff0c\u4e14\u53ef\u5075\u6e2c\u5230\u78da\u584a\u662f\u5426\u6d88\u5931)\n\t\t\tobj1 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y)\n\t\t\tbo1 = obj1 is not None and obj1 is not graphics.paddle\n\t\t\tif bo1:\n\t\t\t\tgraphics.window.remove(obj1)\n\t\t\t\tdisbrick += 1\n\n\t\t\tobj2 = graphics.window.get_object_at(graphics.ball.x+graphics.ball.width,graphics.ball.y)\n\t\t\tbo2 = obj2 is not None and obj2 is not graphics.paddle\n\t\t\tif bo2:\n\t\t\t\tgraphics.window.remove(obj2)\n\t\t\t\tdisbrick += 1\n\n\t\t\tobj3= graphics.window.get_object_at(graphics.ball.x,graphics.ball.y+graphics.ball.height)\n\t\t\tbo3 = obj3 is not None and obj3 is not graphics.paddle\n\t\t\tif bo3:\n\t\t\t\tgraphics.window.remove(obj3)\n\t\t\t\tdisbrick += 1\n\n\t\t\tobj4 = graphics.window.get_object_at(graphics.ball.x + graphics.ball.width,\n\t\t\t\t\t\t\t\t\t\t\t\t graphics.ball.y + graphics.ball.height)\n\t\t\tbo4 = obj4 is not None and obj4 is not graphics.paddle\n\t\t\tif bo4:\n\t\t\t\tgraphics.window.remove(obj4)\n\t\t\t\tdisbrick += 1\n\t\t\t#\u7576\u78da\u584a\u5168\u90e8\u6253\u5b8c\n\t\t\tif disbrick > 100:\n\t\t\t\tNUM_LIVES = 0\n\t\t\t\tgraphics.score.text=\"\u606d\u559c\u7834\u95dc\"\n\t\t\telif NUM_LIVES == 0 :\n\t\t\t\tgraphics.score.text = \"\u53ef\u60dc\uff0c\u4f60\u53ea\u6253\u4e86\" + str(disbrick) + '\u500b'\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "class", "name": "SimpleVectorPlotter", "data": "class SimpleVectorPlotter(object):\n\t\"\"\"Plots vector data represented as lists of coordinates.\"\"\"\n\n\t# _graphics = {}\n\n\tdef __init__(self, interactive, ticks=False, figsize=None, limits=None):\n\t\t\"\"\"Construct a new SimpleVectorPlotter.\n\n\t\tinteractive - boolean flag denoting interactive mode\n\t\tticks\t   - boolean flag denoting whether to show axis tickmarks\n\t\tfigsize\t - optional figure size\n\t\tlimits\t  - optional geographic limits (x_min, x_max, y_min, y_max)\n\t\t\"\"\"\n\t\t# if figsize:\n\t\t#\t plt.figure(num=1, figsize=figsize)\n\t\tplt.figure(num=1, figsize=figsize)\n\t\tself.interactive = interactive\n\t\tself.ticks = ticks\n\t\tif interactive:\n\t\t\tplt.ion()\n\t\telse:\n\t\t\tplt.ioff()\n\t\tif limits is not None:\n\t\t\tself.set_limits(*limits)\n\t\tif not ticks:\n\t\t\tself.no_ticks()\n\t\tplt.axis('equal')\n\t\tself._graphics = {}\n\t\tself._init_colors()\n\n\tdef adjust_markers(self):\n\t\tfigsize = plt.gcf().get_size_inches()\n\t\tr = min(figsize[0] / 8, figsize[1] / 6)\n\t\tmpl.rcParams['lines.markersize'] = 6 * r\n\t\tmpl.rcParams['lines.markeredgewidth'] = 0.5 * r\n\t\tmpl.rcParams['lines.linewidth'] = r\n\t\tmpl.rcParams['patch.linewidth'] = r\n\n\tdef adjust_markersize(self, size):\n\t\tfigsize = plt.gcf().get_size_inches()\n\t\tr = min(figsize[0] / 8, figsize[1] / 6)\n\t\treturn 6 * r\n\n\n\tdef axis_on(self, on):\n\t\t\"\"\"Turn the axes and labels on or off.\"\"\"\n\t\tif on:\n\t\t\tplt.axis('on')\n\t\telse:\n\t\t\tplt.axis('off')\n\n\tdef clear(self):\n\t\t\"\"\"Clear the plot area.\"\"\"\n\t\tplt.cla()\n\t\tself._graphics = {}\n\t\tif not self.ticks:\n\t\t\tself.no_ticks()\n\n\tdef close(self):\n\t\t\"\"\"Close the plot.\"\"\"\n\t\tself.clear()\n\t\tplt.close()\n\n\tdef draw(self):\n\t\t\"\"\"Draw a non-interactive plot.\"\"\"\n\t\tplt.show()\n\n\tdef hide(self, name):\n\t\t\"\"\"Hide the layer with the given name.\"\"\"\n\t\ttry:\n\t\t\tgraphics = self._graphics[name]\n\t\t\tgraphic_type = type(graphics[0])\n\t\t\tif graphic_type is mpl.lines.Line2D:\n\t\t\t\tfor graphic in graphics:\n\t\t\t\t\tplt.axes().lines.remove(graphic)\n\t\t\telif graphic_type is mpl.patches.Polygon or graphic_type is mpl.patches.PathPatch:\n\t\t\t\tfor graphic in graphics:\n\t\t\t\t\tplt.axes().patches.remove(graphic)\n\t\t\telse:\n\t\t\t\traise RuntimeError('{} not supported'.format(graphic_type))\n\t\texcept (KeyError, ValueError):\n\t\t\tpass\n\n\tdef plot_line(self, data, symbol='', name='', **kwargs):\n\t\t\"\"\"Plot a line.\n\n\t\tdata   - list of (x, y) tuples\n\t\tsymbol - optional pyplot symbol to draw the line with\n\t\tname   - optional name to assign to layer so can access it later\n\t\tkwargs - optional pyplot drawing parameters\n\t\t\"\"\"\n\t\tgraphics = self._plot_line(data, symbol, **kwargs)\n\t\tself._set_graphics(graphics, name, symbol or kwargs)\n\n\tdef plot_multiline(self, data, symbol='', name='', **kwargs):\n\t\t\"\"\"Plot a multiline.\n\n\t\tdata   - list of lines, each of which is a list of (x, y) tuples\n\t\tsymbol - optional pyplot symbol to draw the lines with\n\t\tname   - optional name to assign to layer so can access it later\n\t\tkwargs - optional pyplot drawing parameters\n\t\t\"\"\"\n\t\thas_symbol = symbol or kwargs\n\t\tsymbol = symbol or self._line_symbol()\n\t\tgraphics = self._plot_multiline(data, symbol, **kwargs)\n\t\tself._set_graphics(graphics, name, has_symbol)\n\n\tdef plot_multipoint(self, data, symbol='', name='', **kwargs):\n\t\t\"\"\"Plot a multipoint.\n\n\t\tdata   - list of (x, y) tuples\n\t\tsymbol - optional pyplot symbol to draw the points with\n\t\tname   - optional name to assign to layer so can access it later\n\t\tkwargs - optional pyplot drawing parameters\n\t\t\"\"\"\n\t\thas_symbol = symbol or kwargs\n\t\tsymbol = symbol or self._point_symbol()\n\t\tgraphics = self._plot_multipoint(data, **kwargs)\n\t\tself._set_graphics(graphics, name, has_symbol)\n\n\tdef plot_multipolygon(self, data, color='', name='', **kwargs):\n\t\t\"\"\"Plot a multipolygon.\n\n\t\tdata   - list of polygons, each of which is a list of rings, each of\n\t\t\t\t which is a list of (x, y) tuples\n\t\tcolor  - optional pyplot color to draw the polygons with\n\t\tname   - optional name to assign to layer so can access it later\n\t\tkwargs - optional pyplot drawing parameters\n\t\t\"\"\"\n\t\thas_symbol = bool(color or kwargs)\n\t\tif not ('facecolor' in kwargs or 'fc' in kwargs):\n\t\t\tkwargs['fc'] = color or self._next_color()\n\t\tgraphics = self._plot_multipolygon(data, **kwargs)\n\t\tself._set_graphics(graphics, name, has_symbol)\n\n\tdef plot_point(self, data, symbol='', name='', **kwargs):\n\t\t\"\"\"Plot a point.\n\n\t\tdata   - (x, y) tuple\n\t\tsymbol - optional pyplot symbol to draw the point with\n\t\tname   - optional name to assign to layer so can access it later\n\t\tkwargs - optional pyplot drawing parameters\n\t\t\"\"\"\n\t\thas_symbol = symbol or kwargs\n\t\tsymbol = symbol or self._point_symbol()\n\t\tgraphics = self._plot_point(data, symbol, **kwargs)\n\t\tself._set_graphics(graphics, name, has_symbol)\n\n\tdef plot_polygon(self, data, color='', name='', **kwargs):\n\t\t\"\"\"Plot a polygon.\n\n\t\tdata   - list of rings, each of which is a list of (x, y) tuples\n\t\tcolor  - optional pyplot color to draw the polygon with\n\t\tname   - optional name to assign to layer so can access it later\n\t\tkwargs - optional pyplot drawing parameters\n\t\t\"\"\"\n\t\thas_symbol = bool(color or kwargs)\n\t\tif not ('facecolor' in kwargs or 'fc' in kwargs):\n\t\t\tkwargs['fc'] = color or self._next_color()\n\t\tgraphics = self._plot_polygon(data, **kwargs)\n\t\tself._set_graphics(graphics, name, has_symbol)\n\n\tdef remove(self, name):\n\t\t\"\"\"Remove a layer with the given name.\"\"\"\n\t\ttry:\n\t\t\tself.hide(name)\n\t\t\tdel self._graphics[name]\n\t\texcept KeyError:\n\t\t\tpass\n\n\tdef save(self, fn, dpi=300):\n\t\tplt.savefig(fn, dpi=dpi, bbox_inches='tight', pad_inches=0.02)\n\n\tdef set_limits(self, x_min, x_max, y_min, y_max):\n\t\t\"\"\"Set geographic limits for plotting.\"\"\"\n\t\tself.x_lim = x_min, x_max\n\t\tself.y_lim = y_min, y_max\n\t\tself._set_limits()\n\n\tdef show(self, name):\n\t\t\"\"\"Show the layer with the given name.\"\"\"\n\t\ttry:\n\t\t\tgraphics = self._graphics[name]\n\t\t\tgraphic_type = type(graphics[0])\n\t\t\tif graphic_type is mpl.lines.Line2D:\n\t\t\t\tfor graphic in graphics:\n\t\t\t\t\tplt.axes().add_line(graphic)\n\t\t\telif graphic_type is mpl.patches.Polygon or graphic_type is mpl.patches.PathPatch:\n\t\t\t\tfor graphic in graphics:\n\t\t\t\t\tplt.axes().add_patch(graphic)\n\t\t\telse:\n\t\t\t\traise RuntimeError('{} not supported'.format(graphic_type))\n\t\texcept KeyError:\n\t\t\tpass\n\n\tdef no_ticks(self):\n\t\tplt.gca().get_xaxis().set_ticks([])\n\t\tplt.gca().get_yaxis().set_ticks([])\n\n\tdef zoom(self, factor):\n\t\t\"\"\"Zoom in or out by a percentage; negative is out.\"\"\"\n\t\tx_min, x_max, y_min, y_max = plt.axis()\n\t\tx_delta = (x_max - x_min) * factor / 100\n\t\ty_delta = (y_max - y_min) * factor / 100\n\t\tplt.axis((x_min + x_delta, x_max - x_delta,\n\t\t\t\t  y_min + y_delta, y_max - y_delta))\n\n\tdef _clockwise(self, data):\n\t\t\"\"\"Determine if points are in clockwise order.\"\"\"\n\t\ttotal = 0\n\t\tx1, y1 = data[0]\n\t\tfor x, y in data[1:]:\n\t\t\ttotal += (x - x1) * (y + y1)\n\t\t\tx1, y1 = x, y\n\t\tx, y = data[0]\n\t\ttotal += (x - x1) * (y + y1)\n\t\treturn total > 0\n\n\tdef _codes(self, data):\n\t\t\"\"\"Get a list of codes for creating a new PathPatch.\"\"\"\n\t\tcodes = np.ones(len(data), dtype=np.int) * Path.LINETO\n\t\tcodes[0] = Path.MOVETO\n\t\treturn codes\n\n\tdef _init_colors(self):\n\t\tif mpl.__version__ >= '1.5':\n\t\t\tself.colors = list(mpl.rcParams['axes.prop_cycle'])\n\t\t\tself.current_color = -1\n\t\t\tself._next_color = self._next_color_new\n\t\telse:\n\t\t\tself._next_color = self._next_color_old\n\n\tdef _line_symbol(self):\n\t\t\"\"\"Get a default line symbol.\"\"\"\n\t\treturn self._next_color() + '-'\n\n\tdef _next_color_old(self):\n\t\t\"\"\"Get the next color in the rotation.\"\"\"\n\t\treturn next(plt.gca()._get_lines.color_cycle)\n\n\tdef _next_color_new(self):\n\t\t\"\"\"Get the next color in the rotation.\"\"\"\n\t\tself.current_color += 1\n\t\tif self.current_color >= len(self.colors):\n\t\t\tself.current_color = 0\n\t\treturn self.colors[self.current_color]['color']\n\n\tdef _order_vertices(self, data, clockwise=True):\n\t\t\"\"\"Order vertices in clockwise or counter-clockwise order.\"\"\"\n\t\tself._clockwise(data) != clockwise or data.reverse()\n\t\tif data[0] != data[-1]:\n\t\t\tdata.append(data[0])\n\t\treturn data\n\n\tdef _plot_line(self, data, symbol, **kwargs):\n\t\tx, y = zip(*data)\n\t\treturn plt.plot(x, y, symbol, **kwargs)\n\n\tdef _plot_multiline(self, data, symbol, **kwargs):\n\t\t\"\"\"Plot a multiline.\"\"\"\n\t\tgraphics = []\n\t\tfor line in data:\n\t\t\tgraphics += self._plot_line(line, symbol, **kwargs)\n\t\treturn graphics\n\n\tdef _plot_multipoint(self, data, symbol, **kwargs):\n\t\t\"\"\"Plot a multipoint.\"\"\"\n\t\tgraphics = []\n\t\tfor point in data:\n\t\t\tgraphics += self._plot_point(point, symbol, **kwargs)\n\t\treturn graphics\n\n\tdef _plot_multipolygon(self, data, **kwargs):\n\t\t\"\"\"Plot a multipolygon.\"\"\"\n\t\tgraphics = []\n\t\tfor poly in data:\n\t\t\tgraphics += self._plot_polygon(poly, **kwargs)\n\t\treturn graphics\n\n\tdef _plot_point(self, data, symbol, **kwargs):\n\t\t\"\"\"Plot a point.\"\"\"\n\t\treturn plt.plot(data[0], data[1], symbol, **kwargs)\n\n\tdef _plot_polygon(self, data, **kwargs):\n\t\t\"\"\"Plot a polygon.\"\"\"\n\t\touter = self._order_vertices(data[0], True)\n\t\tinner = [self._order_vertices(d, False) for d in data[1:]]\n\t\tvertices = np.concatenate(\n\t\t\t[np.asarray(outer)] + [np.asarray(i) for i in inner])\n\t\tcodes = np.concatenate(\n\t\t\t[self._codes(outer)] + [self._codes(i) for i in inner])\n\t\tpatch = PathPatch(Path(vertices, codes), **kwargs)\n\t\tplt.axes().add_patch(patch)\n\t\treturn [patch]\n\n\tdef _point_symbol(self):\n\t\t\"\"\"Get a default point symbol.\"\"\"\n\t\treturn self._next_color() + 'o'\n\n\tdef _same_type(self, graphic1, graphic2):\n\t\t\"\"\"Determine if two graphics are of the same type.\"\"\"\n\t\tif type(graphic1) is not type(graphic2):\n\t\t\treturn False\n\t\tif type(graphic1) is mpl.patches.Polygon: ## huh?\n\t\t\treturn True\n\t\tif len(graphic1.get_xdata()) == len(graphic2.get_xdata()):\n\t\t\treturn True\n\t\treturn len(graphic1.get_xdata()) > 1 and len(graphic2.get_xdata()) > 1\n\n\tdef _set_graphics(self, graphics, name, has_symbol):\n\t\t\"\"\"Add graphics to plot.\"\"\"\n\t\tname = name or len(self._graphics)\n\t\tif name in self._graphics:\n\t\t\tself.hide(name)\n\t\t\tif not has_symbol and self._same_type(graphics[0], self._graphics[name][0]):\n\t\t\t\tstyled_graphic = self._graphics[name][0]\n\t\t\t\tfor graphic in graphics:\n\t\t\t\t\tgraphic.update_from(styled_graphic)\n\t\tself._graphics[name] = graphics\n\t\tplt.axis('equal')\n\n\tdef _set_limits(self):\n\t\t\"\"\"Set axis limits.\"\"\"\n\t\tplt.xlim(*self.x_lim)\n\t\tplt.ylim(*self.y_lim)\n\t\tplt.axes().set_aspect('equal')\n", "description": "Plots vector data represented as lists of coordinates.", "category": "graphics", "imports": ["import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.path import Path", "from matplotlib.patches import PathPatch", "import numpy as np"]}], [{"term": "class", "name": "SimpleVectorPlotter", "data": "class SimpleVectorPlotter(object):\n\t\"\"\"Plots vector data represented as lists of coordinates.\"\"\"\n\n\t# _graphics = {}\n\n\tdef __init__(self, interactive, ticks=False, figsize=None, limits=None):\n\t\t\"\"\"Construct a new SimpleVectorPlotter.\n\n\t\tinteractive - boolean flag denoting interactive mode\n\t\tticks\t   - boolean flag denoting whether to show axis tickmarks\n\t\tfigsize\t - optional figure size\n\t\tlimits\t  - optional geographic limits (x_min, x_max, y_min, y_max)\n\t\t\"\"\"\n\t\t# if figsize:\n\t\t#\t plt.figure(num=1, figsize=figsize)\n\t\tplt.figure(num=1, figsize=figsize)\n\t\tself.interactive = interactive\n\t\tself.ticks = ticks\n\t\tif interactive:\n\t\t\tplt.ion()\n\t\telse:\n\t\t\tplt.ioff()\n\t\tif limits is not None:\n\t\t\tself.set_limits(*limits)\n\t\tif not ticks:\n\t\t\tself.no_ticks()\n\t\tplt.axis('equal')\n\t\tself._graphics = {}\n\t\tself._init_colors()\n\n\tdef adjust_markers(self):\n\t\tfigsize = plt.gcf().get_size_inches()\n\t\tr = min(figsize[0] / 8, figsize[1] / 6)\n\t\tmpl.rcParams['lines.markersize'] = 6 * r\n\t\tmpl.rcParams['lines.markeredgewidth'] = 0.5 * r\n\t\tmpl.rcParams['lines.linewidth'] = r\n\t\tmpl.rcParams['patch.linewidth'] = r\n\n\tdef adjust_markersize(self, size):\n\t\tfigsize = plt.gcf().get_size_inches()\n\t\tr = min(figsize[0] / 8, figsize[1] / 6)\n\t\treturn 6 * r\n\n\n\tdef axis_on(self, on):\n\t\t\"\"\"Turn the axes and labels on or off.\"\"\"\n\t\tif on:\n\t\t\tplt.axis('on')\n\t\telse:\n\t\t\tplt.axis('off')\n\n\tdef clear(self):\n\t\t\"\"\"Clear the plot area.\"\"\"\n\t\tplt.cla()\n\t\tself._graphics = {}\n\t\tif not self.ticks:\n\t\t\tself.no_ticks()\n\n\tdef close(self):\n\t\t\"\"\"Close the plot.\"\"\"\n\t\tself.clear()\n\t\tplt.close()\n\n\tdef draw(self):\n\t\t\"\"\"Draw a non-interactive plot.\"\"\"\n\t\tplt.show()\n\n\tdef hide(self, name):\n\t\t\"\"\"Hide the layer with the given name.\"\"\"\n\t\ttry:\n\t\t\tgraphics = self._graphics[name]\n\t\t\tgraphic_type = type(graphics[0])\n\t\t\tif graphic_type is mpl.lines.Line2D:\n\t\t\t\tfor graphic in graphics:\n\t\t\t\t\tplt.axes().lines.remove(graphic)\n\t\t\telif graphic_type is mpl.patches.Polygon or graphic_type is mpl.patches.PathPatch:\n\t\t\t\tfor graphic in graphics:\n\t\t\t\t\tplt.axes().patches.remove(graphic)\n\t\t\telse:\n\t\t\t\traise RuntimeError('{} not supported'.format(graphic_type))\n\t\texcept (KeyError, ValueError):\n\t\t\tpass\n\n\tdef plot_line(self, data, symbol='', name='', **kwargs):\n\t\t\"\"\"Plot a line.\n\n\t\tdata   - list of (x, y) tuples\n\t\tsymbol - optional pyplot symbol to draw the line with\n\t\tname   - optional name to assign to layer so can access it later\n\t\tkwargs - optional pyplot drawing parameters\n\t\t\"\"\"\n\t\tgraphics = self._plot_line(data, symbol, **kwargs)\n\t\tself._set_graphics(graphics, name, symbol or kwargs)\n\n\tdef plot_multiline(self, data, symbol='', name='', **kwargs):\n\t\t\"\"\"Plot a multiline.\n\n\t\tdata   - list of lines, each of which is a list of (x, y) tuples\n\t\tsymbol - optional pyplot symbol to draw the lines with\n\t\tname   - optional name to assign to layer so can access it later\n\t\tkwargs - optional pyplot drawing parameters\n\t\t\"\"\"\n\t\thas_symbol = symbol or kwargs\n\t\tsymbol = symbol or self._line_symbol()\n\t\tgraphics = self._plot_multiline(data, symbol, **kwargs)\n\t\tself._set_graphics(graphics, name, has_symbol)\n\n\tdef plot_multipoint(self, data, symbol='', name='', **kwargs):\n\t\t\"\"\"Plot a multipoint.\n\n\t\tdata   - list of (x, y) tuples\n\t\tsymbol - optional pyplot symbol to draw the points with\n\t\tname   - optional name to assign to layer so can access it later\n\t\tkwargs - optional pyplot drawing parameters\n\t\t\"\"\"\n\t\thas_symbol = symbol or kwargs\n\t\tsymbol = symbol or self._point_symbol()\n\t\tgraphics = self._plot_multipoint(data, **kwargs)\n\t\tself._set_graphics(graphics, name, has_symbol)\n\n\tdef plot_multipolygon(self, data, color='', name='', **kwargs):\n\t\t\"\"\"Plot a multipolygon.\n\n\t\tdata   - list of polygons, each of which is a list of rings, each of\n\t\t\t\t which is a list of (x, y) tuples\n\t\tcolor  - optional pyplot color to draw the polygons with\n\t\tname   - optional name to assign to layer so can access it later\n\t\tkwargs - optional pyplot drawing parameters\n\t\t\"\"\"\n\t\thas_symbol = bool(color or kwargs)\n\t\tif not ('facecolor' in kwargs or 'fc' in kwargs):\n\t\t\tkwargs['fc'] = color or self._next_color()\n\t\tgraphics = self._plot_multipolygon(data, **kwargs)\n\t\tself._set_graphics(graphics, name, has_symbol)\n\n\tdef plot_point(self, data, symbol='', name='', **kwargs):\n\t\t\"\"\"Plot a point.\n\n\t\tdata   - (x, y) tuple\n\t\tsymbol - optional pyplot symbol to draw the point with\n\t\tname   - optional name to assign to layer so can access it later\n\t\tkwargs - optional pyplot drawing parameters\n\t\t\"\"\"\n\t\thas_symbol = symbol or kwargs\n\t\tsymbol = symbol or self._point_symbol()\n\t\tgraphics = self._plot_point(data, symbol, **kwargs)\n\t\tself._set_graphics(graphics, name, has_symbol)\n\n\tdef plot_polygon(self, data, color='', name='', **kwargs):\n\t\t\"\"\"Plot a polygon.\n\n\t\tdata   - list of rings, each of which is a list of (x, y) tuples\n\t\tcolor  - optional pyplot color to draw the polygon with\n\t\tname   - optional name to assign to layer so can access it later\n\t\tkwargs - optional pyplot drawing parameters\n\t\t\"\"\"\n\t\thas_symbol = bool(color or kwargs)\n\t\tif not ('facecolor' in kwargs or 'fc' in kwargs):\n\t\t\tkwargs['fc'] = color or self._next_color()\n\t\tgraphics = self._plot_polygon(data, **kwargs)\n\t\tself._set_graphics(graphics, name, has_symbol)\n\n\tdef remove(self, name):\n\t\t\"\"\"Remove a layer with the given name.\"\"\"\n\t\ttry:\n\t\t\tself.hide(name)\n\t\t\tdel self._graphics[name]\n\t\texcept KeyError:\n\t\t\tpass\n\n\tdef save(self, fn, dpi=300):\n\t\tplt.savefig(fn, dpi=dpi, bbox_inches='tight', pad_inches=0.02)\n\n\tdef set_limits(self, x_min, x_max, y_min, y_max):\n\t\t\"\"\"Set geographic limits for plotting.\"\"\"\n\t\tself.x_lim = x_min, x_max\n\t\tself.y_lim = y_min, y_max\n\t\tself._set_limits()\n\n\tdef show(self, name):\n\t\t\"\"\"Show the layer with the given name.\"\"\"\n\t\ttry:\n\t\t\tgraphics = self._graphics[name]\n\t\t\tgraphic_type = type(graphics[0])\n\t\t\tif graphic_type is mpl.lines.Line2D:\n\t\t\t\tfor graphic in graphics:\n\t\t\t\t\tplt.axes().add_line(graphic)\n\t\t\telif graphic_type is mpl.patches.Polygon or graphic_type is mpl.patches.PathPatch:\n\t\t\t\tfor graphic in graphics:\n\t\t\t\t\tplt.axes().add_patch(graphic)\n\t\t\telse:\n\t\t\t\traise RuntimeError('{} not supported'.format(graphic_type))\n\t\texcept KeyError:\n\t\t\tpass\n\n\tdef no_ticks(self):\n\t\tplt.gca().get_xaxis().set_ticks([])\n\t\tplt.gca().get_yaxis().set_ticks([])\n\n\tdef zoom(self, factor):\n\t\t\"\"\"Zoom in or out by a percentage; negative is out.\"\"\"\n\t\tx_min, x_max, y_min, y_max = plt.axis()\n\t\tx_delta = (x_max - x_min) * factor / 100\n\t\ty_delta = (y_max - y_min) * factor / 100\n\t\tplt.axis((x_min + x_delta, x_max - x_delta,\n\t\t\t\t  y_min + y_delta, y_max - y_delta))\n\n\tdef _clockwise(self, data):\n\t\t\"\"\"Determine if points are in clockwise order.\"\"\"\n\t\ttotal = 0\n\t\tx1, y1 = data[0]\n\t\tfor x, y in data[1:]:\n\t\t\ttotal += (x - x1) * (y + y1)\n\t\t\tx1, y1 = x, y\n\t\tx, y = data[0]\n\t\ttotal += (x - x1) * (y + y1)\n\t\treturn total > 0\n\n\tdef _codes(self, data):\n\t\t\"\"\"Get a list of codes for creating a new PathPatch.\"\"\"\n\t\tcodes = np.ones(len(data), dtype=np.int) * Path.LINETO\n\t\tcodes[0] = Path.MOVETO\n\t\treturn codes\n\n\tdef _init_colors(self):\n\t\tif mpl.__version__ >= '1.5':\n\t\t\tself.colors = list(mpl.rcParams['axes.prop_cycle'])\n\t\t\tself.current_color = -1\n\t\t\tself._next_color = self._next_color_new\n\t\telse:\n\t\t\tself._next_color = self._next_color_old\n\n\tdef _line_symbol(self):\n\t\t\"\"\"Get a default line symbol.\"\"\"\n\t\treturn self._next_color() + '-'\n\n\tdef _next_color_old(self):\n\t\t\"\"\"Get the next color in the rotation.\"\"\"\n\t\treturn next(plt.gca()._get_lines.color_cycle)\n\n\tdef _next_color_new(self):\n\t\t\"\"\"Get the next color in the rotation.\"\"\"\n\t\tself.current_color += 1\n\t\tif self.current_color >= len(self.colors):\n\t\t\tself.current_color = 0\n\t\treturn self.colors[self.current_color]['color']\n\n\tdef _order_vertices(self, data, clockwise=True):\n\t\t\"\"\"Order vertices in clockwise or counter-clockwise order.\"\"\"\n\t\tself._clockwise(data) != clockwise or data.reverse()\n\t\tif data[0] != data[-1]:\n\t\t\tdata.append(data[0])\n\t\treturn data\n\n\tdef _plot_line(self, data, symbol, **kwargs):\n\t\tx, y = zip(*data)\n\t\treturn plt.plot(x, y, symbol, **kwargs)\n\n\tdef _plot_multiline(self, data, symbol, **kwargs):\n\t\t\"\"\"Plot a multiline.\"\"\"\n\t\tgraphics = []\n\t\tfor line in data:\n\t\t\tgraphics += self._plot_line(line, symbol, **kwargs)\n\t\treturn graphics\n\n\tdef _plot_multipoint(self, data, symbol, **kwargs):\n\t\t\"\"\"Plot a multipoint.\"\"\"\n\t\tgraphics = []\n\t\tfor point in data:\n\t\t\tgraphics += self._plot_point(point, symbol, **kwargs)\n\t\treturn graphics\n\n\tdef _plot_multipolygon(self, data, **kwargs):\n\t\t\"\"\"Plot a multipolygon.\"\"\"\n\t\tgraphics = []\n\t\tfor poly in data:\n\t\t\tgraphics += self._plot_polygon(poly, **kwargs)\n\t\treturn graphics\n\n\tdef _plot_point(self, data, symbol, **kwargs):\n\t\t\"\"\"Plot a point.\"\"\"\n\t\treturn plt.plot(data[0], data[1], symbol, **kwargs)\n\n\tdef _plot_polygon(self, data, **kwargs):\n\t\t\"\"\"Plot a polygon.\"\"\"\n\t\touter = self._order_vertices(data[0], True)\n\t\tinner = [self._order_vertices(d, False) for d in data[1:]]\n\t\tvertices = np.concatenate(\n\t\t\t[np.asarray(outer)] + [np.asarray(i) for i in inner])\n\t\tcodes = np.concatenate(\n\t\t\t[self._codes(outer)] + [self._codes(i) for i in inner])\n\t\tpatch = PathPatch(Path(vertices, codes), **kwargs)\n\t\tplt.axes().add_patch(patch)\n\t\treturn [patch]\n\n\tdef _point_symbol(self):\n\t\t\"\"\"Get a default point symbol.\"\"\"\n\t\treturn self._next_color() + 'o'\n\n\tdef _same_type(self, graphic1, graphic2):\n\t\t\"\"\"Determine if two graphics are of the same type.\"\"\"\n\t\tif type(graphic1) is not type(graphic2):\n\t\t\treturn False\n\t\tif type(graphic1) is mpl.patches.Polygon: ## huh?\n\t\t\treturn True\n\t\tif len(graphic1.get_xdata()) == len(graphic2.get_xdata()):\n\t\t\treturn True\n\t\treturn len(graphic1.get_xdata()) > 1 and len(graphic2.get_xdata()) > 1\n\n\tdef _set_graphics(self, graphics, name, has_symbol):\n\t\t\"\"\"Add graphics to plot.\"\"\"\n\t\tname = name or len(self._graphics)\n\t\tif name in self._graphics:\n\t\t\tself.hide(name)\n\t\t\tif not has_symbol and self._same_type(graphics[0], self._graphics[name][0]):\n\t\t\t\tstyled_graphic = self._graphics[name][0]\n\t\t\t\tfor graphic in graphics:\n\t\t\t\t\tgraphic.update_from(styled_graphic)\n\t\tself._graphics[name] = graphics\n\t\tplt.axis('equal')\n\n\tdef _set_limits(self):\n\t\t\"\"\"Set axis limits.\"\"\"\n\t\tplt.xlim(*self.x_lim)\n\t\tplt.ylim(*self.y_lim)\n\t\tplt.axes().set_aspect('equal')\n", "description": "Plots vector data represented as lists of coordinates.", "category": "graphics", "imports": ["import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.path import Path", "from matplotlib.patches import PathPatch", "import numpy as np"]}], [], [], [], [], [], [{"term": "class", "name": "GraphicsView", "data": "class GraphicsView(NSView):\n\tgraphicsContainer = objc.ivar(\"graphicsContainer\")\n\tgraphicsKeyPath = objc.ivar(\"graphicsKeyPath\")\n\n\tselectionIndexesContainer = objc.ivar(\n\t\t\"selectionIndexesContainer\"\n\t)  # GraphicsArrayController\n\tselectionIndexesKeyPath = objc.ivar(\"selectionIndexesKeyPath\")\n\n\toldGraphics = objc.ivar(\"oldGraphics\")\n\n\tdef exposedBindings(self):\n\t\treturn [\"graphics\", \"selectedObjects\"]\n\n\tdef initWithFrame_(self, frameRect):\n\t\treturn super(GraphicsView, self).initWithFrame_(frameRect)\n\n\tdef graphics(self):\n\t\tif not self.graphicsContainer:\n\t\t\treturn None\n\t\treturn self.graphicsContainer.valueForKeyPath_(self.graphicsKeyPath)\n\n\tdef selectionIndexes(self):\n\t\tif not self.selectionIndexesContainer:\n\t\t\treturn None\n\t\treturn self.selectionIndexesContainer.valueForKeyPath_(\n\t\t\tself.selectionIndexesKeyPath\n\t\t)\n\n\tdef startObservingGraphics_(self, graphics):\n\t\tif not graphics:\n\t\t\treturn\n\t\t# Register to observe each of the new graphics, and\n\t\t# each of their observable properties -- we need old and new\n\t\t# values for drawingBounds to figure out what our dirty rect\n\t\tfor newGraphic in graphics:\n\t\t\t# Register as observer for all the drawing-related properties\n\t\t\tnewGraphic.addObserver_forKeyPath_options_context_(\n\t\t\t\tself,\n\t\t\t\t\"drawingBounds\",\n\t\t\t\t(NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld),\n\t\t\t\tPropertyObservationContext,\n\t\t\t)\n\t\t\tkeys = Circle.keysForNonBoundsProperties()\n\t\t\tfor key in keys:\n\t\t\t\tnewGraphic.addObserver_forKeyPath_options_context_(\n\t\t\t\t\tself, key, 0, PropertyObservationContext\n\t\t\t\t)\n\n\tdef stopObservingGraphics_(self, graphics):\n\t\tif graphics is None:\n\t\t\treturn\n\t\tfor graphic in graphics:\n\t\t\tfor key in graphic.class__().keysForNonBoundsProperties():\n\t\t\t\tgraphic.removeObserver_forKeyPath_(self, key)\n\t\t\tgraphic.removeObserver_forKeyPath_(self, \"drawingBounds\")\n\n\tdef bind_toObject_withKeyPath_options_(\n\t\tself, bindingName, observableObject, observableKeyPath, options\n\t):\n\t\tif bindingName == \"graphics\":\n\t\t\tself.graphicsContainer = observableObject\n\t\t\tself.graphicsKeyPath = observableKeyPath\n\t\t\tself.graphicsContainer.addObserver_forKeyPath_options_context_(\n\t\t\t\tself,\n\t\t\t\tself.graphicsKeyPath,\n\t\t\t\t(NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld),\n\t\t\t\tGraphicsObservationContext,\n\t\t\t)\n\t\t\tself.startObservingGraphics_(self.graphics())\n\n\t\telif bindingName == \"selectionIndexes\":\n\t\t\tself.selectionIndexesContainer = observableObject\n\t\t\tself.selectionIndexesKeyPath = observableKeyPath\n\t\t\tself.selectionIndexesContainer.addObserver_forKeyPath_options_context_(\n\t\t\t\tself,\n\t\t\t\tself.selectionIndexesKeyPath,\n\t\t\t\t0,\n\t\t\t\tSelectionIndexesObservationContext,\n\t\t\t)\n\t\tself.setNeedsDisplay_(True)\n\n\tdef unbind_(self, bindingName):\n\t\tif bindingName == \"graphics\":\n\t\t\tself.graphicsContainer.removeObserver_forKeyPath_(\n\t\t\t\tself, self.graphicsKeyPath\n\t\t\t)\n\t\t\tself.graphicsContainer = None\n\t\t\tself.graphicsKeyPath = None\n\t\tif bindingName == \"selectionIndexes\":\n\t\t\tself.selectionIndexesContainer.removeObserver_forKeyPath_(\n\t\t\t\tself, self.selectionIndexesKeyPath\n\t\t\t)\n\t\t\tself.seletionIndexesContainer = None\n\t\t\tself.selectionIndexesKeyPath = None\n\t\tself.setNeedsDisplay_(True)\n\n\tdef observeValueForKeyPath_ofObject_change_context_(\n\t\tself, keyPath, object, change, context\n\t):\n\t\tif context == GraphicsObservationContext:\n\t\t\t# Should be able to use\n\t\t\t# NSArray *oldGraphics = [change objectForKey:NSKeyValueChangeOldKey];\n\t\t\t# etc. but the dictionary doesn't contain old and new arrays...??\n\t\t\tnewGraphics = set(object.valueForKeyPath_(self.graphicsKeyPath))\n\t\t\tonlyNew = newGraphics - set(self.oldGraphics or [])\n\t\t\tself.startObservingGraphics_(onlyNew)\n\n\t\t\tif self.oldGraphics:\n\t\t\t\tremoved = set(self.oldGraphics) - newGraphics\n\t\t\t\tself.stopObservingGraphics_(removed)\n\n\t\t\tself.oldGraphics = newGraphics\n\n\t\t\t# could check drawingBounds of old and new, but...\n\t\t\tself.setNeedsDisplay_(True)\n\t\t\treturn\n\n\t\tif context == PropertyObservationContext:\n\t\t\tupdateRect = (0,)\n\t\t\t# Note: for Circle, drawingBounds is a dependent key of all the other\n\t\t\t# property keys except color, so we'll get this anyway...\n\t\t\tif keyPath == \"drawingBounds\":\n\t\t\t\tnewBounds = change.objectForKey_(NSKeyValueChangeNewKey)\n\t\t\t\toldBounds = change.objectForKey_(NSKeyValueChangeOldKey)\n\t\t\t\tupdateRect = NSUnionRect(newBounds, oldBounds)\n\t\t\telse:\n\t\t\t\tupdateRect = object.drawingBounds()\n\t\t\tupdateRect = NSMakeRect(\n\t\t\t\tupdateRect.origin.x - 1.0,\n\t\t\t\tupdateRect.origin.y - 1.0,\n\t\t\t\tupdateRect.size.width + 2.0,\n\t\t\t\tupdateRect.size.height + 2.0,\n\t\t\t)\n\t\t\tself.setNeedsDisplay_(True)\n\t\t\treturn\n\n\t\tif context == SelectionIndexesObservationContext:\n\t\t\tself.setNeedsDisplay_(True)\n\t\t\treturn\n\n\tdef drawRect_(self, rect):\n\t\tmyBounds = self.bounds()\n\t\tNSDrawLightBezel(myBounds, myBounds)  # AppKit Function\n\t\tclipRect = NSBezierPath.bezierPathWithRect_(NSInsetRect(myBounds, 2.0, 2.0))\n\t\tclipRect.addClip()\n\n\t\t# Draw graphics\n\t\tgraphicsArray = self.graphics()\n\t\tif graphicsArray:\n\t\t\tfor graphic in graphicsArray:\n\t\t\t\tgraphicDrawingBounds = graphic.drawingBounds()\n\t\t\t\tif NSIntersectsRect(rect, graphicDrawingBounds):\n\t\t\t\t\tgraphic.drawInView_(self)\n\n\t\t# Draw a red box around items in the current selection.\n\t\t# Selection should be handled by the graphic, but this is a\n\t\t# shortcut simply for display.\n\n\t\tcurrentSelectionIndexes = (\n\t\t\tself.selectionIndexes()\n\t\t)  # ist das wir ein Array im Indezes?\n\t\tif currentSelectionIndexes != None:\n\t\t\tpath = NSBezierPath.bezierPath()\n\t\t\tindex = currentSelectionIndexes.firstIndex()\n\t\t\twhile index != NSNotFound:\n\t\t\t\tgraphicDrawingBounds = graphicsArray[index].drawingBounds()\n\t\t\t\tif NSIntersectsRect(rect, graphicDrawingBounds):\n\t\t\t\t\tpath.appendBezierPathWithRect_(graphicDrawingBounds)\n\t\t\t\tindex = currentSelectionIndexes.indexGreaterThanIndex_(index)\n\n\t\t\tNSColor.redColor().set()\n\t\t\tpath.setLineWidth_(1.5)\n\t\t\tpath.stroke()\n\n\t\t# Fairly simple just to illustrate the point\n\n\tdef mouseDown_(self, event):\n\t\t# find out if we hit anything\n\t\tp = self.convertPoint_fromView_(event.locationInWindow(), None)\n\t\tfor aGraphic in self.graphics():\n\t\t\tif aGraphic.hitTest_isSelected_(p, False):\n\t\t\t\tbreak\n\t\t\t\t# aGraphic soll spaeter einen Wert haben, falls es getroffene gibt!\n\t\telse:\n\t\t\taGraphic = None\n\n\t\t# if no graphic hit, then if extending selection do nothing\n\t\t# else set selection to nil\n\t\tif aGraphic is None:\n\t\t\tif not event.modifierFlags() & NSShiftKeyMask:\n\t\t\t\tself.selectionIndexesContainer.setValue_forKeyPath_(\n\t\t\t\t\tNone, self.selectionIndexesKeyPath\n\t\t\t\t)\n\t\t\treturn\n\n\t\t# graphic hit\n\t\t# if not extending selection (Shift key down) then set\n\t\t# selection to this graphic\n\t\t# if extending selection, then:\n\t\t# - if graphic in selection remove it\n\t\t# - if not in selection add it\n\t\tgraphicIndex = self.graphics().index(aGraphic)\n\t\tif not event.modifierFlags() & NSShiftKeyMask:\n\t\t\tselection = NSIndexSet.indexSetWithIndex_(graphicIndex)\n\t\telse:\n\t\t\tif self.selectionIndexes().containsIndex_(graphicIndex):\n\t\t\t\tselection = self.selectionIndexes().mutableCopy()\n\t\t\t\tselection.removeIndex_(graphicIndex)\n\t\t\telse:\n\t\t\t\tselection = self.selectionIndexes().mutableCopy()\n\t\t\t\tselection.addIndex_(graphicIndex)\n\n\t\tself.selectionIndexesContainer.setValue_forKeyPath_(\n\t\t\tselection, self.selectionIndexesKeyPath\n\t\t)\n\n", "description": null, "category": "graphics", "imports": ["import objc", "from objc import super", "from Cocoa import NSView, NSKeyValueObservingOptionNew, NSKeyValueObservingOptionOld", "from Cocoa import (", "from Cocoa import NSDrawLightBezel, NSBezierPath, NSNotFound, NSIntersectsRect, NSColor", "from Cocoa import NSShiftKeyMask, NSIndexSet, NSInsetRect", "from Circle import Circle"]}], [], [], [{"term": "def", "name": "func1", "data": "def func1():\n\tfor i in range(30):\n\t\tfigure(maturin, graphics,3,70)\n", "description": null, "category": "graphics", "imports": ["import queue", "import threading", "#from modulo2 import forward,right, left, figuree, process_queue, generate_screen,generate_Tortugas", "from modulo2 import *"]}, {"term": "def", "name": "func2", "data": "def func2():\n\tfor i in range(60):\n\t\tfigure(frank, graphics,8,100)\n", "description": null, "category": "graphics", "imports": ["import queue", "import threading", "#from modulo2 import forward,right, left, figuree, process_queue, generate_screen,generate_Tortugas", "from modulo2 import *"]}, {"term": "def", "name": "func3", "data": "def func3():\n\tpenup(maturin0,graphics)\n\tgoto(maturin0,graphics,-300, 180)\n\tpendown(maturin0,graphics)\n\tfor i in range(30):\n\t\tfigure(maturin0, graphics,3,70)\n", "description": null, "category": "graphics", "imports": ["import queue", "import threading", "#from modulo2 import forward,right, left, figuree, process_queue, generate_screen,generate_Tortugas", "from modulo2 import *"]}, {"term": "def", "name": "func4", "data": "def func4():\n\tpenup(frank0,graphics)\n\tgoto(frank0,graphics,-300, 180)\n\tpendown(frank0,graphics)\t\n\tfor i in range(60):\n\t\tfigure(frank0, graphics,8,100)\n\t\tright(frank0, 91,graphics)\t\n", "description": null, "category": "graphics", "imports": ["import queue", "import threading", "#from modulo2 import forward,right, left, figuree, process_queue, generate_screen,generate_Tortugas", "from modulo2 import *"]}, {"term": "def", "name": "func5", "data": "def func5():\n\tpenup(maturin1,graphics)\n\tgoto(maturin1,graphics,300, 180)\n\tpendown(maturin1,graphics)\n\tfor i in range(30):\n\t\tfigure(maturin1, graphics,3,70)\n", "description": null, "category": "graphics", "imports": ["import queue", "import threading", "#from modulo2 import forward,right, left, figuree, process_queue, generate_screen,generate_Tortugas", "from modulo2 import *"]}, {"term": "def", "name": "func6", "data": "def func6():\n\tpenup(frank1,graphics)\n\tgoto(frank1,graphics,300, 180)\n\tpendown(frank1,graphics)\t\n\tfor i in range(60):\n\t\tfigure(frank1, graphics,8,100)\n\t\tright(frank1, 91,graphics)\t\t \n", "description": null, "category": "graphics", "imports": ["import queue", "import threading", "#from modulo2 import forward,right, left, figuree, process_queue, generate_screen,generate_Tortugas", "from modulo2 import *"]}, {"term": "def", "name": "func7", "data": "def func7():\n\tpenup(maturin2,graphics)\n\tgoto(maturin2,graphics,300, -180)\n\tpendown(maturin2,graphics)\n\tfor i in range(30):\n\t\tfigure(maturin2, graphics,3,70)\n", "description": null, "category": "graphics", "imports": ["import queue", "import threading", "#from modulo2 import forward,right, left, figuree, process_queue, generate_screen,generate_Tortugas", "from modulo2 import *"]}, {"term": "def", "name": "func8", "data": "def func8():\n\tpenup(frank2,graphics)\n\tgoto(frank2,graphics,300, -180)\n\tpendown(frank2,graphics)\t\n\tfor i in range(60):\n\t\tfigure(frank2, graphics,8,100)\n", "description": null, "category": "graphics", "imports": ["import queue", "import threading", "#from modulo2 import forward,right, left, figuree, process_queue, generate_screen,generate_Tortugas", "from modulo2 import *"]}, {"term": "def", "name": "func9", "data": "def func9():\n\tpenup(maturin3,graphics)\n\tgoto(maturin3,graphics,-300, -180)\n\tpendown(maturin3,graphics)\n\tfor i in range(30):\n\t\tfigure(maturin3, graphics,3,70)\n", "description": null, "category": "graphics", "imports": ["import queue", "import threading", "#from modulo2 import forward,right, left, figuree, process_queue, generate_screen,generate_Tortugas", "from modulo2 import *"]}, {"term": "def", "name": "func10", "data": "def func10():\n\tpenup(frank3,graphics)\n\tgoto(frank3,graphics,-300, -180)\n\tpendown(frank3,graphics)\t\n\tfor i in range(60):\n\t\tfigure(frank3, graphics,8,100)\n", "description": null, "category": "graphics", "imports": ["import queue", "import threading", "#from modulo2 import forward,right, left, figuree, process_queue, generate_screen,generate_Tortugas", "from modulo2 import *"]}], [{"term": "class", "name": "TimeBar", "data": "class TimeBar(Sprite):\n\tdef __init__(self):\n\t\tsuper(TimeBar, self).__init__()\n\n\t\tself.totalTime = 60\n\t\tself.usedTime = 0\n\t\tself.preTime = time.time()\n\t\tself.usedTimeColor = \"#CC99FF\"\n\t\tself.leftTimeColor = \"#CC00FF\"\n\t\tself.borderColor = \"#6600FF\"\n\t\t\n\t\tself.graphics.beginFill(self.usedTimeColor)\n\t\tself.graphics.lineStyle(3, self.borderColor)\n\t\tself.graphics.drawRect(0, 0, 20, stage.height * 0.75)\n\t\tself.graphics.endFill()\n\n\t\t# add loop event that will be dispatch when the page is redrawn\n\t\tself.addEventListener(LoopEvent.ENTER_FRAME, self.loop)\n\n\tdef loop(self, e):\n\t\tcurrentTime = time.time()\n\t\tself.usedTime += currentTime - self.preTime\n\t\tself.preTime = currentTime\n\n\t\tbarHeight = stage.height * 0.75\n\t\t# calculate the position at which the left time bar is drawn\n\t\tstartX = barHeight * (self.usedTime / self.totalTime)\n\n\t\tif (self.usedTime >= self.totalTime):\n\t\t\tif self.parent:\n\t\t\t\tself.parent.gameOver(\"lose\")\n\n\t\t\treturn\n\n\t\t# redraw the time bar\n\t\tself.graphics.clear()\n\n\t\tself.graphics.beginFill(self.usedTimeColor)\n\t\tself.graphics.drawRect(0, 0, 20, barHeight)\n\t\tself.graphics.endFill()\n\n\t\tself.graphics.beginFill(self.leftTimeColor)\n\t\tself.graphics.drawRect(0, startX, 20, barHeight - startX)\n\t\tself.graphics.endFill()\n\n\t\tself.graphics.beginFill()\n\t\tself.graphics.lineStyle(3, self.borderColor)\n\t\tself.graphics.drawRect(0, 0, 20, barHeight)\n", "description": null, "category": "graphics", "imports": ["import time", "from pylash.core import stage", "from pylash.display import Sprite", "from pylash.events import LoopEvent"]}], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView\n\t` with a single :class:`GraphicsLayout\n\t` as its central item.\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, **kargs):\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView\n\t` with a single :class:`GraphicsLayout\n\t` as its central item.\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [{"term": "class", "name": "classScreenshotData:", "data": "class ScreenshotData:\n\tdef __init__(self):\n\t\tself.screenshotName=\"\"\n\t\tself.screenshotCoreName=\"\"\n\t\tself.spaceDimension=\"2D\"\n\t\tself.projection=\"xy\"\n\t\tself.plotData=(\"Cell_Field\",\"CellField\") # this is a tuple where first element is field name (as displayed in the field list in the player) and the second one is plot type (e.g. CellField, Confield, Vector Field)\n\t\tself.projectionPosition=0\n\t\tself.screenshotGraphicsWidget=None\n\t\t# self.originalCameraObj=None\n\t\t#those are the values used to handle 3D screenshots\n\t\t\n\t\tself.clippingRange=None\n\t\tself.focalPoint=None\n\t\tself.position=None\n\t\tself.viewUp=None\n", "description": null, "category": "graphics", "imports": ["import os, sys", "import string", "import Configuration", "import SimpleTabView", "from  Graphics.GraphicsFrameWidget import GraphicsFrameWidget", "\t\tfrom weakref import ref", "\t\tself.screenshotGraphicsWidget.is_screenshot_widget = True # important because e.g. we do not save screenshot widget in the windows layout", "#\t\timport pdb; pdb.set_trace()", "\t\tfrom XMLUtils import ElementCC3D", "\t\timport XMLUtils", "#\t\timport pdb; pdb.set_trace()"]}, {"term": "def", "name": "fextractCameraInfo", "data": "\tdef extractCameraInfo(self,_camera):\n\t\tself.clippingRange=_camera.GetClippingRange()\n\t\tself.focalPoint=_camera.GetFocalPoint()\n\t\tself.position=_camera.GetPosition()\n", "description": null, "category": "graphics", "imports": ["import os, sys", "import string", "import Configuration", "import SimpleTabView", "from  Graphics.GraphicsFrameWidget import GraphicsFrameWidget", "\t\tfrom weakref import ref", "\t\tself.screenshotGraphicsWidget.is_screenshot_widget = True # important because e.g. we do not save screenshot widget in the windows layout", "#\t\timport pdb; pdb.set_trace()", "\t\tfrom XMLUtils import ElementCC3D", "\t\timport XMLUtils", "#\t\timport pdb; pdb.set_trace()"]}, {"term": "def", "name": "fextractCameraInfoFromList", "data": "\tdef extractCameraInfoFromList(self,_cameraSettings):\n\t\tself.clippingRange=_cameraSettings[0:2]\n\t\tself.focalPoint=_cameraSettings[2:5]\n\t\tself.position=_cameraSettings[5:8]\n", "description": null, "category": "graphics", "imports": ["import os, sys", "import string", "import Configuration", "import SimpleTabView", "from  Graphics.GraphicsFrameWidget import GraphicsFrameWidget", "\t\tfrom weakref import ref", "\t\tself.screenshotGraphicsWidget.is_screenshot_widget = True # important because e.g. we do not save screenshot widget in the windows layout", "#\t\timport pdb; pdb.set_trace()", "\t\tfrom XMLUtils import ElementCC3D", "\t\timport XMLUtils", "#\t\timport pdb; pdb.set_trace()"]}, {"term": "def", "name": "fcompareCameras", "data": "\tdef compareCameras(self,_camera):\n\t\t_clippingRange=_camera.GetClippingRange()\n\t\tif self.clippingRange != _camera.GetClippingRange():\n\t\t\treturn False\n\t\tif self.focalPoint!=_camera.GetFocalPoint():\n\t\t\treturn False\n\t\tif self.position!=_camera.GetPosition():\n\t\t\treturn False\n\t\tif self.viewUp!=_camera.GetViewUp():\n\t\t\treturn False\n\t\treturn True\n", "description": null, "category": "graphics", "imports": ["import os, sys", "import string", "import Configuration", "import SimpleTabView", "from  Graphics.GraphicsFrameWidget import GraphicsFrameWidget", "\t\tfrom weakref import ref", "\t\tself.screenshotGraphicsWidget.is_screenshot_widget = True # important because e.g. we do not save screenshot widget in the windows layout", "#\t\timport pdb; pdb.set_trace()", "\t\tfrom XMLUtils import ElementCC3D", "\t\timport XMLUtils", "#\t\timport pdb; pdb.set_trace()"]}, {"term": "def", "name": "fcompareExistingCameraToNewCameraSettings", "data": "\tdef compareExistingCameraToNewCameraSettings(self, _cameraSettings):\n\t\tif self.clippingRange[0]!=_cameraSettings[0] or self.clippingRange[1]!=_cameraSettings[1]:\n\t\t\treturn False\n\t\tif self.focalPoint[0]!=_cameraSettings[2] or self.focalPointe[1]!=_cameraSettings[3] or self.focalPoint[3]!=_cameraSettings[4]:\n\t\t\treturn False\n\t\tif self.position[0]!=_cameraSettings[5] or self.position[1]!=_cameraSettings[6] or self.position[3]!=_cameraSettings[7]:\n\t\t\treturn False\n\t\tif self.viewUp[0]!=_cameraSettings[8] or self.viewUp[1]!=_cameraSettings[9] or self.viewUp[3]!=_cameraSettings[10]:\n\t\t\treturn False\n\n", "description": null, "category": "graphics", "imports": ["import os, sys", "import string", "import Configuration", "import SimpleTabView", "from  Graphics.GraphicsFrameWidget import GraphicsFrameWidget", "\t\tfrom weakref import ref", "\t\tself.screenshotGraphicsWidget.is_screenshot_widget = True # important because e.g. we do not save screenshot widget in the windows layout", "#\t\timport pdb; pdb.set_trace()", "\t\tfrom XMLUtils import ElementCC3D", "\t\timport XMLUtils", "#\t\timport pdb; pdb.set_trace()"]}, {"term": "class", "name": "classScreenshotManager:", "data": "class ScreenshotManager:\n\tdef __init__(self,_tabViewWidget):\n\n\n\t\tself.screenshotDataDict={}\n\t\tfrom weakref import ref\n\t\tself.tabViewWidget=ref(_tabViewWidget)\n\t\ttvw=self.tabViewWidget()\n", "description": null, "category": "graphics", "imports": ["import os, sys", "import string", "import Configuration", "import SimpleTabView", "from  Graphics.GraphicsFrameWidget import GraphicsFrameWidget", "\t\tfrom weakref import ref", "\t\tself.screenshotGraphicsWidget.is_screenshot_widget = True # important because e.g. we do not save screenshot widget in the windows layout", "#\t\timport pdb; pdb.set_trace()", "\t\tfrom XMLUtils import ElementCC3D", "\t\timport XMLUtils", "#\t\timport pdb; pdb.set_trace()"]}, {"term": "def", "name": "fcleanup", "data": "\tdef cleanup(self):\n\t\t# have to do cleanup to ensure some of the memory intensive resources e.g. self.screenshotGraphicsWidget get deallocated\n\t\tif self.screenshotGraphicsWidget:\n\t\t\tprint 'JUST BEFORE CLOSING self.screenshotGraphicsWidget'\n\t\t\t# this close and assignment do not do much for the non-mdi layout\n\t\t\tself.screenshotGraphicsWidget.close()\n\t\t\tself.screenshotGraphicsWidget=None\n\t\tself.tabViewWidget=None\n\t\tself.basicSimulationData=None\n", "description": null, "category": "graphics", "imports": ["import os, sys", "import string", "import Configuration", "import SimpleTabView", "from  Graphics.GraphicsFrameWidget import GraphicsFrameWidget", "\t\tfrom weakref import ref", "\t\tself.screenshotGraphicsWidget.is_screenshot_widget = True # important because e.g. we do not save screenshot widget in the windows layout", "#\t\timport pdb; pdb.set_trace()", "\t\tfrom XMLUtils import ElementCC3D", "\t\timport XMLUtils", "#\t\timport pdb; pdb.set_trace()"]}, {"term": "def", "name": "fproduceScreenshotCoreName", "data": "\tdef produceScreenshotCoreName(self,_scrData):\n\t\treturn str(_scrData.plotData[0])+\"_\"+str(_scrData.plotData[1])\n", "description": null, "category": "graphics", "imports": ["import os, sys", "import string", "import Configuration", "import SimpleTabView", "from  Graphics.GraphicsFrameWidget import GraphicsFrameWidget", "\t\tfrom weakref import ref", "\t\tself.screenshotGraphicsWidget.is_screenshot_widget = True # important because e.g. we do not save screenshot widget in the windows layout", "#\t\timport pdb; pdb.set_trace()", "\t\tfrom XMLUtils import ElementCC3D", "\t\timport XMLUtils", "#\t\timport pdb; pdb.set_trace()"]}, {"term": "def", "name": "fproduceScreenshotName", "data": "\tdef produceScreenshotName(self,_scrData):\n\t\tscreenshotName=\"Screenshot\"\n\t\tscreenshotCoreName=\"Screenshot\"\n\t\t\n\t\tif _scrData.spaceDimension==\"2D\":\n\t\t\tscreenshotCoreName=self.produceScreenshotCoreName(_scrData)\n\t\t\tscreenshotName=screenshotCoreName+\"_\"+_scrData.spaceDimension+\"_\"+_scrData.projection+\"_\"+str(_scrData.projectionPosition)\n\t\telif _scrData.spaceDimension==\"3D\":\n\t\t\tscreenshotCoreName=self.produceScreenshotCoreName(_scrData)\n\t\t\tscreenshotName=screenshotCoreName+\"_\"+_scrData.spaceDimension+\"_\"+str(self.screenshotCounter3D)\n\t\treturn (screenshotName,screenshotCoreName)\n", "description": null, "category": "graphics", "imports": ["import os, sys", "import string", "import Configuration", "import SimpleTabView", "from  Graphics.GraphicsFrameWidget import GraphicsFrameWidget", "\t\tfrom weakref import ref", "\t\tself.screenshotGraphicsWidget.is_screenshot_widget = True # important because e.g. we do not save screenshot widget in the windows layout", "#\t\timport pdb; pdb.set_trace()", "\t\tfrom XMLUtils import ElementCC3D", "\t\timport XMLUtils", "#\t\timport pdb; pdb.set_trace()"]}, {"term": "def", "name": "fwriteScreenshotDescriptionFile", "data": "\tdef writeScreenshotDescriptionFile(self,_fileName):\n\t\tfrom XMLUtils import ElementCC3D\n\t\t\n\t\tscreenshotFileElement=ElementCC3D(\"CompuCell3DScreenshots\")\n\t\t\n\t\tfor name in self.screenshotDataDict:\n\t\t\tscrData=self.screenshotDataDict[name]\n\t\t\tif scrData.spaceDimension==\"2D\":\n\t\t\t\tscrDescElement=screenshotFileElement.ElementCC3D(\"ScreenshotDescription\")\n\t\t\t\tscrDescElement.ElementCC3D(\"Dimension\", {}, str(scrData.spaceDimension))\n\t\t\t\tscrDescElement.ElementCC3D(\"Plot\", {\"PlotType\":str(scrData.plotData[1]),\"PlotName\":str(scrData.plotData[0])})\n\t\t\t\tscrDescElement.ElementCC3D(\"Projection\", {\"ProjectionPlane\":scrData.projection,\"ProjectionPosition\":str(scrData.projectionPosition)})\n\t\t\t\tscrDescElement.ElementCC3D(\"Size\", {\"Width\":str(scrData.screenshotGraphicsWidget.size().width()),\"Height\":str(scrData.screenshotGraphicsWidget.size().height())})\n\t\t\t\t\n\t\t\tif scrData.spaceDimension==\"3D\":\n\t\t\t\tscrDescElement=screenshotFileElement.ElementCC3D(\"ScreenshotDescription\")\t\t\t\t\n\t\t\t\tscrDescElement.ElementCC3D(\"Dimension\", {}, str(scrData.spaceDimension))\n\t\t\t\tscrDescElement.ElementCC3D(\"Plot\", {\"PlotType\":str(scrData.plotData[1]),\"PlotName\":str(scrData.plotData[0])})\n\t\t\t\tscrDescElement.ElementCC3D(\"CameraClippingRange\", {\"Min\":str(scrData.clippingRange[0]),\"Max\":str(scrData.clippingRange[1])})\n\t\t\t\tscrDescElement.ElementCC3D(\"CameraFocalPoint\", {\"x\":str(scrData.focalPoint[0]),\"y\":str(scrData.focalPoint[1]),\"z\":str(scrData.focalPoint[2])})\n\t\t\t\tscrDescElement.ElementCC3D(\"CameraPosition\", {\"x\":str(scrData.position[0]),\"y\":str(scrData.position[1]),\"z\":str(scrData.position[2])})\n\t\t\t\tscrDescElement.ElementCC3D(\"CameraViewUp\", {\"x\":str(scrData.viewUp[0]),\"y\":str(scrData.viewUp[1]),\"z\":str(scrData.viewUp[2])})\n\t\t\t\tscrDescElement.ElementCC3D(\"Size\", {\"Width\":str(scrData.screenshotGraphicsWidget.size().width()),\"Height\":str(scrData.screenshotGraphicsWidget.size().height())})\n\t\t\t\t\n\t\tscreenshotFileElement.CC3DXMLElement.saveXML(str(_fileName))\n", "description": null, "category": "graphics", "imports": ["import os, sys", "import string", "import Configuration", "import SimpleTabView", "from  Graphics.GraphicsFrameWidget import GraphicsFrameWidget", "\t\tfrom weakref import ref", "\t\tself.screenshotGraphicsWidget.is_screenshot_widget = True # important because e.g. we do not save screenshot widget in the windows layout", "#\t\timport pdb; pdb.set_trace()", "\t\tfrom XMLUtils import ElementCC3D", "\t\timport XMLUtils", "#\t\timport pdb; pdb.set_trace()"]}, {"term": "def", "name": "freadScreenshotDescriptionFile", "data": "\tdef readScreenshotDescriptionFile(self,_fileName):\t\t\n\t\timport XMLUtils\n\t\t\n\t\txml2ObjConverter = XMLUtils.Xml2Obj()\n\t\troot_element=xml2ObjConverter.Parse(_fileName)\n\t\tscrList=XMLUtils.CC3DXMLListPy(root_element.getElements(\"ScreenshotDescription\"))\n\t\tfor scr in scrList:\n\t\t\tif scr.getFirstElement(\"Dimension\").getText()==\"2D\":\n\t\t\t\tprint MODULENAME,\"GOT 2D SCREENSHOT\"\n\t\t\t\tscrData=ScreenshotData()\n\t\t\t\tscrData.spaceDimension=\"2D\"\n\t\t\t\t\n\t\t\t\tplotElement=scr.getFirstElement(\"Plot\")\n\t\t\t\tscrData.plotData=(plotElement.getAttribute(\"PlotName\"),plotElement.getAttribute(\"PlotType\"))\n\t\t\t\t\n\t\t\t\tprojElement=scr.getFirstElement(\"Projection\")\n\t\t\t\tscrData.projection=projElement.getAttribute(\"ProjectionPlane\")\n\t\t\t\tscrData.projectionPosition=int(projElement.getAttribute(\"ProjectionPosition\"))\n\t\t\t\t\n\t\t\t\tsizeElement=scr.getFirstElement(\"Size\")\n\t\t\t\tscrSize=[int(sizeElement.getAttribute(\"Width\")),int(sizeElement.getAttribute(\"Height\"))]\n\t\t\t\t\n\t\t\t\t# scrData initialized now will initialize graphics widget\n\t\t\t\t(scrName,scrCoreName)=self.produceScreenshotName(scrData)\n\t\t\t\tif not scrName in self.screenshotDataDict:\n\t\t\t\t\tscrData.screenshotName=scrName\n\t\t\t\t\tscrData.screenshotCoreName=scrCoreName\n\t\t\t\t\tscrData.screenshotGraphicsWidget=self.screenshotGraphicsWidget\n\t\t\t\t\tself.screenshotDataDict[scrData.screenshotName]=scrData\n\t\t\t\telse:\n\t\t\t\t\tprint MODULENAME,\"Screenshot \",scrName,\" already exists\"\n\t\t\t\t\n\t\t\telif scr.getFirstElement(\"Dimension\").getText()==\"3D\":\n\t\t\t\tscrData=ScreenshotData()\n\t\t\t\tscrData.spaceDimension=\"3D\"\n\t\t\t\tplotElement=scr.getFirstElement(\"Plot\")\n\t\t\t\tscrData.plotData=(plotElement.getAttribute(\"PlotName\"),plotElement.getAttribute(\"PlotType\"))\n\t\t\t\tsizeElement=scr.getFirstElement(\"Size\")\n\t\t\t\tscrSize=[int(sizeElement.getAttribute(\"Width\")),int(sizeElement.getAttribute(\"Height\"))]\n\t\t\t\t\n\t\t\t\t(scrName,scrCoreName)=self.produceScreenshotName(scrData)\n\t\t\t\tprint MODULENAME,\"(scrName,scrCoreName)=\",(scrName,scrCoreName)\n\t\t\t\tokToAddScreenshot=True\n\t\t\t\t\n\t\t\t\t# extracting Camera Settings\n\t\t\t\tcamSettings=[]\n\t\t\t\t\n\t\t\t\tclippingRangeElement=scr.getFirstElement(\"CameraClippingRange\")\n\t\t\t\tcamSettings.append(float(clippingRangeElement.getAttribute(\"Min\")))\n\t\t\t\tcamSettings.append(float(clippingRangeElement.getAttribute(\"Max\")))\n\t\t\t\t\n\t\t\t\tfocalPointElement=scr.getFirstElement(\"CameraFocalPoint\")\n\t\t\t\tcamSettings.append(float(focalPointElement.getAttribute(\"x\")))\n\t\t\t\tcamSettings.append(float(focalPointElement.getAttribute(\"y\")))\n\t\t\t\tcamSettings.append(float(focalPointElement.getAttribute(\"z\")))\n\t\t\t\t\n\t\t\t\tpositionElement=scr.getFirstElement(\"CameraPosition\")\n\t\t\t\tcamSettings.append(float(positionElement.getAttribute(\"x\")))\n\t\t\t\tcamSettings.append(float(positionElement.getAttribute(\"y\")))\n\t\t\t\tcamSettings.append(float(positionElement.getAttribute(\"z\")))\n\t\t\t\t\n\t\t\t\tviewUpElement=scr.getFirstElement(\"CameraViewUp\")\n\t\t\t\tcamSettings.append(float(viewUpElement.getAttribute(\"x\")))\n\t\t\t\tcamSettings.append(float(viewUpElement.getAttribute(\"y\")))\n\t\t\t\tcamSettings.append(float(viewUpElement.getAttribute(\"z\")))\n\t\t\t\t\n\t\t\t\tfor name in self.screenshotDataDict:\n\t\t\t\t\tscrDataFromDict=self.screenshotDataDict[name]\n\t\t\t\t\tif scrDataFromDict.screenshotCoreName==scrCoreName and scrDataFromDict.spaceDimension==\"3D\":\n\t\t\t\t\t\tprint MODULENAME,\"scrDataFromDict.screenshotCoreName=\",scrDataFromDict.screenshotCoreName,\" scrCoreName=\",scrCoreName\n\t\t\t\t\t\t\n\t\t\t\t\t\tif scrDataFromDict.compareExistingCameraToNewCameraSettings(camSettings):\n\t\t\t\t\t\t\tprint MODULENAME,\"CAMERAS ARE THE SAME\"\n\t\t\t\t\t\t\tokToAddScreenshot=False\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tprint MODULENAME,\"CAMERAS ARE DIFFERENT\"\n\t\t\t\tprint MODULENAME,\"okToAddScreenshot=\",okToAddScreenshot\t\n\t\t\t\t\n\t\t\t\tif (not scrName in self.screenshotDataDict) and okToAddScreenshot:\n\t\t\t\t\tscrData.screenshotName=scrName\n\t\t\t\t\tscrData.screenshotCoreName=scrCoreName\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tscrData.screenshotGraphicsWidget=self.screenshotGraphicsWidget\n\t\t\t\t\t\n\t\t\t\t\tscrData.extractCameraInfoFromList(camSettings)\n\t\t\t\t\tself.screenshotDataDict[scrData.screenshotName]=scrData\n\t\t\t\t\n\t\t\telse:\n\t\t\t\tprint MODULENAME,\"GOT UNKNOWN SCREENSHOT\"\n\t\t\t\n", "description": null, "category": "graphics", "imports": ["import os, sys", "import string", "import Configuration", "import SimpleTabView", "from  Graphics.GraphicsFrameWidget import GraphicsFrameWidget", "\t\tfrom weakref import ref", "\t\tself.screenshotGraphicsWidget.is_screenshot_widget = True # important because e.g. we do not save screenshot widget in the windows layout", "#\t\timport pdb; pdb.set_trace()", "\t\tfrom XMLUtils import ElementCC3D", "\t\timport XMLUtils", "#\t\timport pdb; pdb.set_trace()"]}, {"term": "def", "name": "fadd2DScreenshot", "data": "\tdef add2DScreenshot(self, _plotName,_plotType,_projection,_projectionPosition,_camera):   # called from GraphicsFrameWidget\n\t\tif len(self.screenshotDataDict)>self.maxNumberOfScreenshots:\n\t\t\tprint MODULENAME,\"MAX NUMBER OF SCREENSHOTS HAS BEEN REACHED\"\n\t\t\n\t\tscrData=ScreenshotData()\n\t\tscrData.spaceDimension=\"2D\"\n\t\tscrData.plotData=(_plotName,_plotType)\t\t\n", "description": null, "category": "graphics", "imports": ["import os, sys", "import string", "import Configuration", "import SimpleTabView", "from  Graphics.GraphicsFrameWidget import GraphicsFrameWidget", "\t\tfrom weakref import ref", "\t\tself.screenshotGraphicsWidget.is_screenshot_widget = True # important because e.g. we do not save screenshot widget in the windows layout", "#\t\timport pdb; pdb.set_trace()", "\t\tfrom XMLUtils import ElementCC3D", "\t\timport XMLUtils", "#\t\timport pdb; pdb.set_trace()"]}, {"term": "def", "name": "fadd3DScreenshot", "data": "\tdef add3DScreenshot(self, _plotName,_plotType,_camera):   # called from GraphicsFrameWidget\n\t\tif len(self.screenshotDataDict)>self.maxNumberOfScreenshots:\n\t\t\tprint MODULENAME,\"MAX NUMBER OF SCREENSHOTS HAS BEEN REACHED\"\t\t\n\t\tscrData=ScreenshotData()\n\t\tscrData.spaceDimension=\"3D\"\n\t\tscrData.plotData=(_plotName,_plotType)\n\t\tprint MODULENAME,\"add3DScreenshot(): scrData.plotData\",scrData.plotData\n\t\t(scrName,scrCoreName)=self.produceScreenshotName(scrData)\n\n\t\tprint MODULENAME,\"add3DScreenshot(): scrName\",scrName\n\t\tokToAddScreenshot=True\n\t\tfor name in self.screenshotDataDict:\n\t\t\tscrDataFromDict=self.screenshotDataDict[name]\n\t\t\tif scrDataFromDict.screenshotCoreName==scrCoreName and scrDataFromDict.spaceDimension==\"3D\":\n\t\t\t\tif scrDataFromDict.compareCameras(_camera):\n\t\t\t\t\tprint MODULENAME,\"CAMERAS ARE THE SAME\"\n\t\t\t\t\tokToAddScreenshot=False\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tprint MODULENAME,\"CAMERAS ARE DIFFERENT\"\n", "description": null, "category": "graphics", "imports": ["import os, sys", "import string", "import Configuration", "import SimpleTabView", "from  Graphics.GraphicsFrameWidget import GraphicsFrameWidget", "\t\tfrom weakref import ref", "\t\tself.screenshotGraphicsWidget.is_screenshot_widget = True # important because e.g. we do not save screenshot widget in the windows layout", "#\t\timport pdb; pdb.set_trace()", "\t\tfrom XMLUtils import ElementCC3D", "\t\timport XMLUtils", "#\t\timport pdb; pdb.set_trace()"]}], [{"term": "class", "name": "GraphicsTest", "data": "class GraphicsTest(SampleBase):\n\tdef __init__(self, *args, **kwargs):\n\t\tsuper(GraphicsTest, self).__init__(*args, **kwargs)\n\n\tdef run(self):\n\t\tcanvas = self.matrix\n\t\tfont = graphics.Font()\n\t\tfont.LoadFont(\"../../../fonts/7x13.bdf\")\n\n\t\tred = graphics.Color(255, 0, 0)\n\t\tgraphics.DrawLine(canvas, 5, 5, 22, 13, red)\n\n\t\tgreen = graphics.Color(0, 255, 0)\n\t\tgraphics.DrawCircle(canvas, 15, 15, 10, green)\n\n\t\tblue = graphics.Color(0, 0, 255)\n\t\tgraphics.DrawText(canvas, font, 2, 10, blue, \"Text\")\n\n\t\ttime.sleep(10)   # show display for 10 seconds before exit\n\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "import time"]}], [{"term": "def", "name": "main", "data": "def main():\n\tglobal NUM_LIVES\n\n\tgraphics = BreakoutGraphics()\n\t# bricks_num is the number of existing bricks  in the game\n\tbricks_num = 100\n\n\t# Add animation loop here!\n\twhile True:\n\t\tdx = graphics.dx_get()\n\t\tdy = graphics.dy_get()\n\t\tgraphics.ball.x =(graphics.window.width - graphics.ball.width) / 2\n\t\tgraphics.ball.y=(graphics.window.height - graphics.ball.height) / 2\n\n\t\twhile True:\n\t\t\tif dx == 0 and dy == 0:\n\t\t\t\tdx = graphics.dx_get()\n\t\t\t\tdy = graphics.dy_get()\n\t\t\t\tpause(FRAME_RATE)\n\t\t\telse:\n\t\t\t\tgraphics.ball.move(dx,dy)\n\n\t\t\t\t# when ball is touching the paddle, it will just work the function of \"check_object\".\n\t\t\t\t# And when the ball is touching the other thing, it means the ball touched the bricks.\n\t\t\t\t# It will remove the brick and bricks_num subtract one.\n\n\t\t\t\tif graphics.window.get_object_at(graphics.ball.x,graphics.ball.y) is not None:\n\t\t\t\t\tif graphics.paddle.x <= graphics.ball.x <= graphics.paddle.x+graphics.paddle.width and graphics.paddle.y <= graphics.ball.y <= graphics.paddle.y + graphics.paddle.height:\n\t\t\t\t\t\tdy = abs(dy)\n\t\t\t\t\telse:\n\t\t\t\t\t\tgraphics.window.remove(graphics.window.get_object_at(graphics.ball.x,graphics.ball.y))\n\t\t\t\t\t\tbricks_num -= 1\n\t\t\t\t\tdy = -dy\n\t\t\t\telif graphics.window.get_object_at(graphics.ball.x,graphics.ball.y+graphics.ball.height) is not None:\n\t\t\t\t\tif graphics.paddle.x <= graphics.ball.x <= graphics.paddle.x+graphics.paddle.width and graphics.paddle.y <= graphics.ball.y+graphics.ball.height  <= graphics.paddle.y + graphics.paddle.height:\n\t\t\t\t\t\tdy = abs(dy)\n\t\t\t\t\telse:\n\t\t\t\t\t\tgraphics.window.remove(graphics.window.get_object_at(graphics.ball.x,graphics.ball.y+graphics.ball.height))\n\t\t\t\t\t\tbricks_num -= 1\n\t\t\t\t\tdy = -dy\n\t\t\t\telif graphics.window.get_object_at(graphics.ball.x+graphics.ball.width , graphics.ball.y) is not None:\n\t\t\t\t\tif graphics.paddle.x <= graphics.ball.x+graphics.ball.width <= graphics.paddle.x+graphics.paddle.width and graphics.paddle.y <= graphics.ball.y  <= graphics.paddle.y + graphics.paddle.height:\n\t\t\t\t\t\tdy = abs(dy)\n\t\t\t\t\telse:\n\t\t\t\t\t\tgraphics.window.remove(graphics.window.get_object_at(graphics.ball.x+graphics.ball.width ,graphics.ball.y))\n\t\t\t\t\t\tbricks_num -= 1\n\t\t\t\t\tdy = -dy\n\t\t\t\telif graphics.window.get_object_at(graphics.ball.x+graphics.ball.width, graphics.ball.y + graphics.ball.height) is not None:\n\t\t\t\t\tif graphics.paddle.x <= graphics.ball.x+graphics.ball.width <= graphics.paddle.x+graphics.paddle.width and graphics.paddle.y <= graphics.ball.y + graphics.ball.height  <= graphics.paddle.y + graphics.paddle.height:\n\t\t\t\t\t\tdy = abs(dy)\n\t\t\t\t\telse:\n\t\t\t\t\t\tgraphics.window.remove(graphics.window.get_object_at(graphics.ball.x+graphics.ball.width, graphics.ball.y + graphics.ball.height))\n\t\t\t\t\t\tbricks_num -= 1\n\t\t\t\t\tdy = -dy\n\n\t\t\t\t# when the ball touches the bounder of the window,\n\t\t\t\t# it will change the velocity except the bottom of the window.\n\t\t\t\tif graphics.ball.x <= 0 or graphics.ball.x >= graphics.window.width - graphics.ball.width:\n\t\t\t\t\tdx = - dx\n\t\t\t\tif graphics.ball.y <= 0:\n\t\t\t\t\tdy = -dy\n\n\t\t\t\t# 1. bricks_num =0 means winning, so we have bto break.\n\t\t\t\t# 2. When ball is touching the bottom of the window, NUM_LIVES will minus one and break.\n\t\t\t\tif bricks_num == 0:\n\t\t\t\t\tbreak\n\t\t\t\telif graphics.ball.y + graphics.ball.height >= graphics.window.height :\n\t\t\t\t\tNUM_LIVES -= 1\n\t\t\t\t\tgraphics.trigger =0\n\n\t\t\t\t\tbreak\n\n\t\t\t\tpause(FRAME_RATE)\n\n\t\t# check the winning condition and losing condition\n\t\tif NUM_LIVES == 0 :\n\t\t\tgraphics.window.remove(graphics.ball)\n\t\t\tgraphics.window.add(graphics.game_over)\n\t\t\tbreak\n\t\telif bricks_num ==0:\n\t\t\tgraphics.window.remove(graphics.ball)\n\t\t\tgraphics.window.add(graphics.win)\n\t\t\tbreak\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [], [], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tlive = NUM_LIVES\n\thit_object_total = 0\n\n\t# Animation loop starts from here!\n\twhile True:\n\t\tglobal vx, vy\n\t\t# The program will wait for the mouse clicked event to change the ball velocity\n\t\tif vx == 0 and vy == 0:\n\t\t\tvx = graphics.get_dx()\n\t\t\tvy = graphics.get_dy()\n\n\t\t# Update\n\t\tgraphics.ball.move(vx, vy)\n\n\t\t# Check_1: If the ball is outbound.\n\t\tif graphics.ball.y > graphics.window.height:\n\t\t\tlive -= 1\n\t\t\tif live > 0:\n\t\t\t\tgraphics.reset_ball()\n\t\t\t\tvy = graphics.get_dx()\n\t\t\t\tvx = graphics.get_dy()\n\t\t\telse:\n\t\t\t\tbreak\n\n\t\t# Check_2: If ball hits bricks or paddle.\n\t\thit_object = graphics.check_ball_hit()\n\n\t\tif hit_object is not None:\n\t\t\t# If hit the paddle and the ball direction is downward.\n\t\t\tif hit_object is graphics.paddle and vy > 0:\n\t\t\t\tvy = -vy\n\t\t\t# If hit the brick and the ball direction is downward.\n\t\t\telif hit_object is not graphics.paddle and hit_object is not graphics.scoreboard:\n\t\t\t\tgraphics.window.remove(hit_object)\n\t\t\t\thit_object_total += 1\n\t\t\t\tgraphics.scoreboard.text = 'Score: ' + str(hit_object_total)\n\t\t\t\tvy = -vy\n\t\t\t\tif hit_object_total == graphics.brick_total:\n\t\t\t\t\tbreak\n\n\t\t# Check_3: Set the window boundary if the ball hits nothing.\n\t\telif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\t\tvx = -vx\n\t\telif graphics.ball.y <= 0:\n\t\t\tvy = -vy\n\n\t\t# Pause\n\t\tpause(FRAME_RATE)\n\n\t# Lose the game\n\tif live == 0:\n\t\tgraphics.game_over()\n\n\t# Win the game\n\telse:\n\t\tgraphics.congrats()\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "def", "name": "color_for", "data": "def color_for ( color ):\n\t\"\"\" Returns the specified color as a wx.Colour.\n\t\"\"\"\n\tif isinstance( color, wx.Colour ):\n\t\treturn color\n\n\tif isinstance( color, tuple ):\n\t\treturn wx.Colour( *color )\n\n\tif not isinstance( color, IntTypes ):\n\t\tfrom facets.extra.helper.debug import log\n\t\tlog( 'Graphics adapter received an invalid color value: %s' % color )\n\t\tcolor = 0\n\n\treturn wx.Colour( (color >> 16) & 0xFF,\n\t\t\t\t\t  (color >>  8) & 0xFF,\n\t\t\t\t\t  color\t\t & 0xFF,\n\t\t\t\t\t  255 - ((color >> 24) & 0xFF) )\n\n", "description": " Returns the specified color as a wx.Colour.\n\t", "category": "graphics", "imports": ["import wx", "\timport Graphics", "\t\tfrom facets.extra.helper.debug import log", "\t\tfrom facets.ui.pen import Pen"]}, {"term": "def", "name": "dc_for", "data": "def dc_for ( dc ):\n\t\"\"\" Returns a device context that supports the extended wx drawing API if\n\t\tpossible. Otherwise, it returns the original device context.\n\t\"\"\"\n\ttry:\n\t\tgcdc\t   = wx.GCDC( dc )\n\t\tgcdc._size = dc.GetSize()\n\n\t\treturn gcdc\n\texcept:\n\t\treturn dc\n", "description": " Returns a device context that supports the extended wx drawing API if\n\t\tpossible. Otherwise, it returns the original device context.\n\t", "category": "graphics", "imports": ["import wx", "\timport Graphics", "\t\tfrom facets.extra.helper.debug import log", "\t\tfrom facets.ui.pen import Pen"]}, {"term": "class", "name": "WxGraphics", "data": "class WxGraphics ( Graphics ):\n\n\t#-- Property Implementations -----------------------------------------------\n\n\tdef _get_pen ( self ):\n\t\treturn self.graphics.GetPen()\n\n\tdef _set_pen ( self, pen ):\n\t\tfrom facets.ui.pen import Pen\n\n\t\tif pen is None:\n\t\t\tpen = wx.TRANSPARENT_PEN\n\t\telif isinstance( pen, Pen ):\n\t\t\tpen = wx.Pen( pen.color, pen.width, LineStyle[ pen.style ] )\n\t\telif not isinstance( pen, wx.Pen ):\n\t\t\tpen = wx.Pen( color_for( pen ), 1, wx.SOLID )\n\n\t\tself.graphics.SetPen( pen )\n\n\n\tdef _get_brush ( self ):\n\t\treturn self.graphics.GetBrush()\n\n\tdef _set_brush ( self, color ):\n\t\tif color is None:\n\t\t\tself.graphics.SetBrush( wx.TRANSPARENT_BRUSH )\n\t\telse:\n\t\t\tself.graphics.SetBrush( wx.Brush( color_for( color ), wx.SOLID ) )\n\n\n\tdef _set_xor_mode ( self, is_xor_mode ):\n\t\tif is_xor_mode:\n\t\t\tself.graphics.SetLogicalFunction( wx.XOR )\n\n\n\tdef _get_font ( self ):\n\t\treturn self.graphics.GetFont()\n\n\tdef _set_font ( self, font ):\n\t\tself.graphics.SetFont( font )\n\n\n\tdef _get_text_color ( self ):\n\t\treturn self.graphics.GetTextForegroundColour()\n\n\tdef _set_text_color ( self, color ):\n\t\tself.graphics.SetTextForeground( color_for( color ) )\n\n\n\tdef _get_text_background_color ( self ):\n\t\tif self.graphics.GetBackgroundMode() == wx.TRANSPARENT:\n\t\t\treturn None\n\n\t\treturn self.graphics.GetTextBackground()\n\n\tdef _set_text_background_color ( self, color ):\n\t\tif color is None:\n\t\t\tself.graphics.SetBackgroundMode( wx.TRANSPARENT )\n\t\t\treturn\n\n\t\tself.graphics.SetTextBackground( color_for( color ) )\n\t\tself.graphics.SetBackgroundMode( wx.SOLID )\n\n\n\tdef _get_opacity ( self ):\n\t\traise NotImplementedError\n\n\tdef _set_opacity ( self, opacity ):\n\t\traise NotImplementedError\n\n\n\tdef _get_clipping_bounds ( self ):\n\t\treturn self.graphics.GetClippingBox()\n\n\tdef _set_clipping_bounds ( self, x_y_dx_dy ):\n\t\tself.graphics.DestroyClippingRegion()\n\t\tif x_y_dx_dy is not None:\n\t\t\tself.graphics.SetClippingRegion( *x_y_dx_dy )\n\n\n\tdef _get_size ( self ):\n\t\treturn self.graphics.GetSizeTuple()\n\n\t#-- Method Definitions -----------------------------------------------------\n\n\tdef draw_rectangle ( self, x, y, dx, dy ):\n\t\t\"\"\" Draws a rectangle at the specified position and with the specified\n\t\t\twidth and height.\n\t\t\"\"\"\n\t\tself.graphics.DrawRectangle( x, y, dx, dy )\n\n\n\tdef draw_rounded_rectangle ( self, x, y, dx, dy, radius ):\n\t\t\"\"\" Draws a rectangle with rounded corners at the specified position\n\t\t\tand with the specified size and corner radius.\n\t\t\"\"\"\n\t\tself.graphics.DrawRoundedRectangle( x, y, dx, dy, radius )\n\n\n\tdef draw_circle ( self, x, y, radius ):\n\t\t\"\"\" Draws a circle with the specified center point (x,y) and radius.\n\t\t\"\"\"\n\t\tself.graphics.DrawCircle( x, y, radius )\n\n\n\tdef draw_line ( self, x1, y1, x2, y2 ):\n\t\t\"\"\" Draws a line from (x1,y1) to (x2,y2).\n\t\t\"\"\"\n\t\tif y1 == y2:\n\t\t\tif x2 > x1:\n\t\t\t\tx2 += 1\n\t\t\telse:\n\t\t\t\tx2 -= 1\n\t\telif x1 == x2:\n\t\t\tif y2 > y1:\n\t\t\t\ty2 += 1\n\t\t\telse:\n\t\t\t\ty2 -= 1\n\n\t\tself.graphics.DrawLine( x1, y1, x2, y2 )\n\n\n\tdef draw_bitmap ( self, bitmap, x, y ):\n\t\t\"\"\" Draws a specified bitmap at the specified location.\n\t\t\"\"\"\n\t\tself.graphics.DrawBitmap( bitmap, x, y, True )\n\n\n\tdef bitmap_size ( self, bitmap ):\n\t\t\"\"\" Returns the size (dx,dy) of the specified toolkit specific bitmap:\n\t\t\"\"\"\n\t\treturn ( bitmap.GetWidth(), bitmap.GetHeight() )\n\n\n\tdef draw_text ( self, text, x, y ):\n\t\t\"\"\" Draws the specified text string at the specified (x,y) location.\n\t\t\"\"\"\n\t\tself.graphics.DrawText( text, x, y )\n\n\n\tdef text_size ( self, text ):\n\t\t\"\"\" Returns the size (dx,dy) of the specified text using the current\n\t\t\tfont.\n\t\t\"\"\"\n\t\treturn self.graphics.GetTextExtent( text )\n\n\n\tdef graphics_bitmap ( self, bitmap ):\n\t\t\"\"\" Returns a new graphics memory object using the specified bitmap.\n\t\t\"\"\"\n\t\tdc = wx.MemoryDC()\n\t\tdc.SelectObject( bitmap )\n\n\t\treturn WxGraphics( dc )\n\n\n\tdef graphics_buffer ( self, dx = None, dy = None, alpha = False ):\n\t\t\"\"\" Returns a new graphics memory object of the specified size (dx,dy)\n\t\t\tthat can be used to implement a buffered screen update. If\n\t\t\talpha is True, the resulting graphics object should support an\n\t\t\talpha channel; otherwise it does not need to.\n\t\t\"\"\"\n\t\tdc  = BufferDC( self.graphics, dx, dy )\n\t\tdc2 = dc_for( dc )\n\n\t\treturn WxGraphics( dc2, _dc = dc, bitmap = dc.bitmap )\n\n\n\tdef blit ( self, dst_x, dst_y, dst_dx, dst_dy, g,\n\t\t\t\t\t src_x = 0, src_y = 0, src_dx = None, src_dy = None ):\n\t\t\"\"\" Performs a standard BLT (block transfer) operation from one graphics\n\t\t\tobject to another, copying g(src_x,src_y,src_dx,syc_dy) to\n\t\t\tself(dst_x,dst_y,dst_dx,dst_dy). If src_dx or src_dy is None, then\n\t\t\tthe corresponding dst_dx or dst_dy value is used to determine the\n\t\t\tsource rectangle size. Note that g may also specify a bitmap, as\n\t\t\treturned by an ImageResource 'bitmap' attribute, in place of a\n\t\t\tgraphics adapter.\n\t\t\"\"\"\n\t\tdst_dc = self._dc or self.graphics\n\t\tif isinstance( g, Graphics ):\n\t\t\tsrc_dc = g.graphics\n\t\telse:\n\t\t\tsrc_dc = wx.MemoryDC()\n\t\t\tsrc_dc.SelectObject( g )\n\n\t\tif src_dx is None:\n\t\t\tsrc_dx = dst_dx\n\n\t\tif src_dy is None:\n\t\t\tsrc_dy = dst_dy\n\n\t\tif (src_dx == dst_dx) and (src_dy == dst_dy):\n\t\t\tdst_dc.Blit( dst_x, dst_y, dst_dx, dst_dy, src_dc, src_x, src_y,\n\t\t\t\t\t\t useMask = True )\n\t\telse:\n\t\t\tsx = float( dst_dx ) / src_dx\n\t\t\tsy = float( dst_dy ) / src_dy\n\t\t\tdst_dc.SetUserScale( sx, sy )\n\t\t\tdst_dc.Blit( int( round( dst_x / sx ) ),\n\t\t\t\t\t\t int( round( dst_y / sy ) ),\n\t\t\t\t\t\t int( round( dst_dx / sx ) ),\n\t\t\t\t\t\t int( round( dst_dy / sy ) ),\n\t\t\t\t\t\t src_dc, src_x, src_y, useMask = True )\n\t\t\tdst_dc.SetUserScale( 1.0, 1.0 )\n\n\n\tdef copy ( self, x = 0, y = 0 ):\n\t\t\"\"\" Copies the contents of the graphics buffer back to the graphics\n\t\t\tobject it was created from at the specified (x,y) location.\n\t\t\"\"\"\n\t\tself._dc.copy( x, y )\n", "description": " Draws a rectangle at the specified position and with the specified\n\t\t\twidth and height.\n\t\t", "category": "graphics", "imports": ["import wx", "\timport Graphics", "\t\tfrom facets.extra.helper.debug import log", "\t\tfrom facets.ui.pen import Pen"]}, {"term": "class", "name": "BufferDC", "data": "class BufferDC ( wx.MemoryDC ):\n\t\"\"\" An off-screen buffer class.\n\n\t\tThis class implements a off-screen output buffer. Data is meant to\n\t\tbe drawn in the buffer and then blitted directly to the output device\n\t\tcontext.\n\t\"\"\"\n\n\t#-- Public Methods ---------------------------------------------------------\n\n\tdef __init__ ( self, dc, width = None, height = None ):\n\t\t\"\"\" Initializes the buffer.\n\t\t\"\"\"\n\t\twx.MemoryDC.__init__( self )\n\n\t\tif width is None:\n\t\t\t# Note: Sometimes the dc is a GCDC, which returns really large (and\n\t\t\t# incorrect) values for size, so the 'gc_for' function attaches a\n\t\t\t# correct size value to the GCDC in the '_size' attribute. So, if\n\t\t\t# the dc has a '_size' attribute, we use that value instead of the\n\t\t\t# value reported by the GetSize() method:\n\t\t\twidth, height = getattr( dc, '_size', none_none )\n\t\t\tif width is None:\n\t\t\t\twidth, height = dc.GetSize()\n\n\t\tself.dc\t = dc\n\t\tself.bitmap = wx.EmptyBitmap( width, height )\n\n\t\tself.SelectObject( self.bitmap )\n\n\t\tself.SetFont( dc.GetFont() )\n\n\n\tdef copy ( self, x = 0, y = 0 ):\n\t\t\"\"\" Performs the blit of the buffer contents to the specified device\n\t\t\tcontext location.\n\t\t\"\"\"\n\t\tself.dc.Blit( x, y, self.bitmap.GetWidth(), self.bitmap.GetHeight(),\n\t\t\t\t\t  self, 0, 0 )\n", "description": " An off-screen buffer class.\n\n\t\tThis class implements a off-screen output buffer. Data is meant to\n\t\tbe drawn in the buffer and then blitted directly to the output device\n\t\tcontext.\n\t", "category": "graphics", "imports": ["import wx", "\timport Graphics", "\t\tfrom facets.extra.helper.debug import log", "\t\tfrom facets.ui.pen import Pen"]}], [{"term": "def", "name": "darken", "data": "def darken(color, factor=0.7):\n\t\"\"\"Return darkened color as a ReportLab RGB color.\n\n\tTake a passed color and returns a Reportlab color that is darker by the\n\tfactor indicated in the parameter.\n\t\"\"\"\n\tnewcol = color_to_reportlab(color)\n\tfor a in ['red', 'green', 'blue']:\n\t\tsetattr(newcol, a, factor * getattr(newcol, a))\n\treturn newcol\n\n", "description": "Return darkened color as a ReportLab RGB color.\n\n\tTake a passed color and returns a Reportlab color that is darker by the\n\tfactor indicated in the parameter.\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "from reportlab.lib import colors", "from reportlab.pdfgen import canvas", "from PIL import Image", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "def", "name": "color_to_reportlab", "data": "def color_to_reportlab(color):\n\t\"\"\"Return the passed color in Reportlab Color format.\n\n\tWe allow colors to be specified as hex values, tuples, or Reportlab Color\n\tobjects, and with or without an alpha channel. This function acts as a\n\tRosetta stone for conversion of those formats to a Reportlab Color\n\tobject, with alpha value.\n\n\tAny other color specification is returned directly\n\t\"\"\"\n\t# Reportlab Color objects are in the format we want already\n\tif isinstance(color, colors.Color):\n\t\treturn color\n\telif isinstance(color, str):  # String implies hex color\n\t\tif color.startswith(\"0x\"):  # Standardise to octothorpe\n\t\t\tcolor.replace(\"0x\", \"#\")\n\t\tif len(color) == 7:\n\t\t\treturn colors.HexColor(color)\n\t\telse:\n\t\t\ttry:\n\t\t\t\treturn colors.HexColor(color, hasAlpha=True)\n\t\t\texcept TypeError:  # Catch pre-2.7 Reportlab\n\t\t\t\traise RuntimeError(\"Your reportlab seems to be too old, try 2.7 onwards\")\n\telif isinstance(color, tuple):  # Tuple implies RGB(alpha) tuple\n\t\treturn colors.Color(*color)\n\treturn color\n\n", "description": "Return the passed color in Reportlab Color format.\n\n\tWe allow colors to be specified as hex values, tuples, or Reportlab Color\n\tobjects, and with or without an alpha channel. This function acts as a\n\tRosetta stone for conversion of those formats to a Reportlab Color\n\tobject, with alpha value.\n\n\tAny other color specification is returned directly\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "from reportlab.lib import colors", "from reportlab.pdfgen import canvas", "from PIL import Image", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "def", "name": "get_temp_imagefilename", "data": "def get_temp_imagefilename(url):\n\t\"\"\"Return filename of temporary file containing downloaded image.\n\n\tCreate a new temporary file to hold the image file at the passed URL\n\tand return the filename.\n\t\"\"\"\n\timg = _urlopen(url).read()\n\tim = Image.open(BytesIO(img))\n\t# im.transpose(Image.FLIP_TOP_BOTTOM)\n\tf = tempfile.NamedTemporaryFile(delete=False, suffix='.png')\n\tfname = f.name\n\tf.close()\n\tim.save(fname, 'PNG')\n\treturn fname\n\n", "description": "Return filename of temporary file containing downloaded image.\n\n\tCreate a new temporary file to hold the image file at the passed URL\n\tand return the filename.\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "from reportlab.lib import colors", "from reportlab.pdfgen import canvas", "from PIL import Image", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "class", "name": "KGMLCanvas", "data": "class KGMLCanvas(object):\n\t\"\"\"Reportlab Canvas-based representation of a KGML pathway map.\"\"\"\n\n\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,\n\t\t\t\t label_orthologs=True, label_reaction_entries=True,\n\t\t\t\t label_maps=True, show_maps=False, fontname='Helvetica',\n\t\t\t\t fontsize=6, draw_relations=True, show_orthologs=True,\n\t\t\t\t show_compounds=True, show_genes=True,\n\t\t\t\t show_reaction_entries=True, margins=(0.02, 0.02)):\n\t\t\"\"\"Initialize.\"\"\"\n\t\tself.pathway = pathway\n\t\tself.show_maps = show_maps\n\t\tself.show_orthologs = show_orthologs\n\t\tself.show_compounds = show_compounds\n\t\tself.show_genes = show_genes\n\t\tself.show_reaction_entries = show_reaction_entries\n\t\tself.label_compounds = label_compounds\n\t\tself.label_orthologs = label_orthologs\n\t\tself.label_reaction_entries = label_reaction_entries\n\t\tself.label_maps = label_maps\n\t\tself.fontname = fontname\n\t\tself.fontsize = fontsize\n\t\tself.draw_relations = draw_relations\n\t\tself.non_reactant_transparency = 0.3\n\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL\n\t\t# percentage of canvas that will be margin in on either side in the\n\t\t# X and Y directions\n\t\tself.margins = margins\n\n\tdef draw(self, filename):\n\t\t\"\"\"Add the map elements to the drawing.\"\"\"\n\t\t# Instantiate the drawing, first\n\t\t# size x_max, y_max for now - we can add margins, later\n\t\tif self.import_imagemap:\n\t\t\t# We're drawing directly on the image, so we set the canvas to the\n\t\t\t# same size as the image\n\t\t\tif os.path.isfile(self.pathway.image):\n\t\t\t\timfilename = self.pathway.image\n\t\t\telse:\n\t\t\t\timfilename = get_temp_imagefilename(self.pathway.image)\n\t\t\tim = Image.open(imfilename)\n\t\t\tcwidth, cheight = im.size\n\t\telse:\n\t\t\t# No image, so we set the canvas size to accommodate visible\n\t\t\t# elements\n\t\t\tcwidth, cheight = (self.pathway.bounds[1][0],\n\t\t\t\t\t\t\t   self.pathway.bounds[1][1])\n\t\t# Instantiate canvas\n\t\tself.drawing = \\\n\t\t\tcanvas.Canvas(filename, bottomup=0,\n\t\t\t\t\t\t  pagesize=(cwidth * (1 + 2 * self.margins[0]),\n\t\t\t\t\t\t\t\t\tcheight * (1 + 2 * self.margins[1])))\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\t\t# Transform the canvas to add the margins\n\t\tself.drawing.translate(self.margins[0] * self.pathway.bounds[1][0],\n\t\t\t\t\t\t\t   self.margins[1] * self.pathway.bounds[1][1])\n\t\t# Add the map image, if required\n\t\tif self.import_imagemap:\n\t\t\tself.drawing.saveState()\n\t\t\tself.drawing.scale(1, -1)\n\t\t\tself.drawing.translate(0, -cheight)\n\t\t\tself.drawing.drawImage(imfilename, 0, 0)\n\t\t\tself.drawing.restoreState()\n\t\t# Add the reactions, compounds and maps\n\t\t# Maps go on first, to be overlaid by more information.\n\t\t# By default, they're slightly transparent.\n\t\tif self.show_maps:\n\t\t\tself.__add_maps()\n\t\tif self.show_reaction_entries:\n\t\t\tself.__add_reaction_entries()\n\t\tif self.show_orthologs:\n\t\t\tself.__add_orthologs()\n\t\tif self.show_compounds:\n\t\t\tself.__add_compounds()\n\t\tif self.show_genes:\n\t\t\tself.__add_genes()\n\t\t# TODO: complete draw_relations code\n\t\t# if self.draw_relations:\n\t\t#\tself.__add_relations()\n\t\t# Write the pathway map to PDF\n\t\tself.drawing.save()\n\n\tdef __add_maps(self):\n\t\t\"\"\"Add maps to the drawing of the map (PRIVATE).\n\n\t\tWe do this first, as they're regional labels to be overlaid by\n\t\tinformation.  Also, we want to set the color to something subtle.\n\n\t\tWe're using Hex colors because that's what KGML uses, and\n\t\tReportlab doesn't mind.\n\t\t\"\"\"\n\t\tfor m in self.pathway.maps:\n\t\t\tfor g in m.graphics:\n\t\t\t\tself.drawing.setStrokeColor('#888888')\n\t\t\t\tself.drawing.setFillColor('#DDDDDD')\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_maps:\n\t\t\t\t\tself.drawing.setFillColor('#888888')\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_graphics(self, graphics):\n\t\t\"\"\"Add the passed graphics object to the map (PRIVATE).\n\n\t\tAdd text, add after the graphics object, for sane Z-ordering.\n\t\t\"\"\"\n\t\tif graphics.type == 'line':\n\t\t\tp = self.drawing.beginPath()\n\t\t\tx, y = graphics.coords[0]\n\t\t\t# There are optional settings for lines that aren't necessarily\n\t\t\t# part of the KGML DTD\n\t\t\tif graphics.width is not None:\n\t\t\t\tself.drawing.setLineWidth(graphics.width)\n\t\t\telse:\n\t\t\t\tself.drawing.setLineWidth(1)\n\t\t\tp.moveTo(x, y)\n\t\t\tfor (x, y) in graphics.coords:\n\t\t\t\tp.lineTo(x, y)\n\t\t\tself.drawing.drawPath(p)\n\t\t\tself.drawing.setLineWidth(1)\t\t# Return to default\n\t\t# KGML defines the (x, y) coordinates as the centre of the circle/\n\t\t# rectangle/roundrectangle, but Reportlab uses the co-ordinates of the\n\t\t# lower-left corner for rectangle/elif.\n\t\tif graphics.type == 'circle':\n\t\t\tself.drawing.circle(graphics.x, graphics.y, graphics.width * 0.5,\n\t\t\t\t\t\t\t\tstroke=1, fill=1)\n\t\telif graphics.type == 'roundrectangle':\n\t\t\tself.drawing.roundRect(graphics.x - graphics.width * 0.5,\n\t\t\t\t\t\t\t\t   graphics.y - graphics.height * 0.5,\n\t\t\t\t\t\t\t\t   graphics.width, graphics.height,\n\t\t\t\t\t\t\t\t   min(graphics.width, graphics.height) * 0.1,\n\t\t\t\t\t\t\t\t   stroke=1, fill=1)\n\t\telif graphics.type == 'rectangle':\n\t\t\tself.drawing.rect(graphics.x - graphics.width * 0.5,\n\t\t\t\t\t\t\t  graphics.y - graphics.height * 0.5,\n\t\t\t\t\t\t\t  graphics.width, graphics.height,\n\t\t\t\t\t\t\t  stroke=1, fill=1)\n\n\tdef __add_labels(self, graphics):\n\t\t\"\"\"Add labels for the passed graphics objects to the map (PRIVATE).\n\n\t\tWe don't check that the labels fit inside objects such as circles/\n\t\trectangles/roundrectangles.\n\t\t\"\"\"\n\t\tif graphics.type == 'line':\n\t\t\t# We use the midpoint of the line - sort of - we take the median\n\t\t\t# line segment (list-wise, not in terms of length), and use the\n\t\t\t# midpoint of that line.  We could have other options here,\n\t\t\t# maybe even parameterising it to a proportion of the total line\n\t\t\t# length.\n\t\t\tmid_idx = len(graphics.coords) * 0.5\n\t\t\tif not int(mid_idx) == mid_idx:\n\t\t\t\tidx1, idx2 = int(mid_idx - 0.5), int(mid_idx + 0.5)\n\t\t\telse:\n\t\t\t\tidx1, idx2 = int(mid_idx - 1), int(mid_idx)\n\t\t\tx1, y1 = graphics.coords[idx1]\n\t\t\tx2, y2 = graphics.coords[idx2]\n\t\t\tx, y = 0.5 * (x1 + x2), 0.5 * (y1 + y2)\n\t\telif graphics.type == 'circle':\n\t\t\tx, y = graphics.x, graphics.y\n\t\telif graphics.type in ('rectangle', 'roundrectangle'):\n\t\t\tx, y = graphics.x, graphics.y\n\t\t# How big so we want the text, and how many characters?\n\t\tif graphics._parent.type == 'map':\n\t\t\ttext = graphics.name\n\t\t\tself.drawing.setFont(self.fontname, self.fontsize + 2)\n\t\telif len(graphics.name) < 15:\n\t\t\ttext = graphics.name\n\t\telse:\n\t\t\ttext = graphics.name[:12] + '...'\n\t\tself.drawing.drawCentredString(x, y, text)\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\n\tdef __add_orthologs(self):\n\t\t\"\"\"Add 'ortholog' Entry elements to the drawing of the map (PRIVATE).\n\n\t\tIn KGML, these are typically line objects, so we render them\n\t\tbefore the compound circles to cover the unsightly ends/junctions.\n\t\t\"\"\"\n\t\tfor ortholog in self.pathway.orthologs:\n\t\t\tfor g in ortholog.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_orthologs:\n\t\t\t\t\t# We want the label color to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_reaction_entries(self):\n\t\t\"\"\"Add Entry elements for Reactions to the map drawing (PRIVATE).\n\n\t\tIn KGML, these are typically line objects, so we render them\n\t\tbefore the compound circles to cover the unsightly ends/junctions\n\t\t\"\"\"\n\t\tfor reaction in self.pathway.reaction_entries:\n\t\t\tfor g in reaction.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_reaction_entries:\n\t\t\t\t\t# We want the label color to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_compounds(self):\n\t\t\"\"\"Add compound elements to the drawing of the map (PRIVATE).\"\"\"\n\t\tfor compound in self.pathway.compounds:\n\t\t\tfor g in compound.graphics:\n\t\t\t\t# Modify transparency of compounds that don't participate\n\t\t\t\t# in reactions\n\t\t\t\tfillcolor = color_to_reportlab(g.bgcolor)\n\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\tfillcolor.alpha *= self.non_reactant_transparency\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(fillcolor)\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\t\tt = 0.3\n\t\t\t\t\telse:\n\t\t\t\t\t\tt = 1\n\t\t\t\t\tself.drawing.setFillColor(colors.Color(0.2, 0.2, 0.2, t))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_genes(self):\n\t\t\"\"\"Add gene elements to the drawing of the map (PRIVATE).\"\"\"\n\t\tfor gene in self.pathway.genes:\n\t\t\tfor g in gene.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_relations(self):\n\t\t\"\"\"Add relations to the map (PRIVATE).\n\n\t\tThis is tricky. There is no defined graphic in KGML for a\n\t\trelation, and the corresponding entries are typically defined\n\t\tas objects 'to be connected somehow'.  KEGG uses KegSketch, which\n\t\tis not public, and most third-party software draws straight line\n\t\tarrows, with heads to indicate the appropriate direction\n\t\t(at both ends for reversible reactions), using solid lines for\n\t\tECrel relation types, and dashed lines for maplink relation types.\n\n\t\tThe relation has:\n\t\t- entry1: 'from' node\n\t\t- entry2: 'to' node\n\t\t- subtype: what the relation refers to\n\n\t\tTypically we have entry1 = map/ortholog; entry2 = map/ortholog,\n\t\tsubtype = compound.\n\t\t\"\"\"\n\t\t# Dashed lines for maplinks, solid for everything else\n\t\tfor relation in list(self.pathway.relations):\n\t\t\tif relation.type == 'maplink':\n\t\t\t\tself.drawing.setDash(6, 3)\n\t\t\telse:\n\t\t\t\tself.drawing.setDash()\n\t\t\tfor s in relation.subtypes:\n\t\t\t\tsubtype = self.pathway.entries[s[1]]\n\t\t\t\t# Our aim is to draw an arrow from the entry1 object to the\n\t\t\t\t# entry2 object, via the subtype object.\n\t\t\t\t# 1) Entry 1 to subtype\n\t\t\t\tself.__draw_arrow(relation.entry1, subtype)\n\t\t\t\t# 2) subtype to Entry 2\n\t\t\t\tself.__draw_arrow(subtype, relation.entry2)\n\n\tdef __draw_arrow(self, g_from, g_to):\n\t\t\"\"\"Draw an arrow between given Entry objects (PRIVATE).\n\n\t\tDraws an arrow from the g_from Entry object to the g_to\n\t\tEntry object; both must have Graphics objects.\n\t\t\"\"\"\n\t\t# Centre and bound co-ordinates for the from and two objects\n\t\tbounds_from, bounds_to = g_from.bounds, g_to.bounds\n\t\tcentre_from = (0.5 * (bounds_from[0][0] + bounds_from[1][0]),\n\t\t\t\t\t   0.5 * (bounds_from[0][1] + bounds_from[1][1]))\n\t\tcentre_to = (0.5 * (bounds_to[0][0] + bounds_to[1][0]),\n\t\t\t\t\t 0.5 * (bounds_to[0][1] + bounds_to[1][1]))\n\t\tp = self.drawing.beginPath()\n\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t# If the 'from' and 'to' graphics are vertically-aligned, draw a line\n\t\t# from the 'from' to the 'to' entity\n\t\tif bounds_to[0][0] < centre_from[0] < bounds_to[1][0]:\n\t\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t\tif centre_to[1] > centre_from[1]:  # to above from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\t\telse:\t\t\t\t\t\t\t # to below from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\telif bounds_from[0][0] < centre_to[0] < bounds_from[1][0]:\n\t\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t\tif centre_to[1] > centre_from[1]:  # to above from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\t\telse:\t\t\t\t\t\t\t # to below from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\tself.drawing.drawPath(p)\t# Draw arrow shaft\n\t\t# print(g_from)\n\t\t# print(bounds_from)\n\t\t# print(g_to)\n\t\t# print(bounds_to)\n", "description": "Reportlab Canvas-based representation of a KGML pathway map.", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "from reportlab.lib import colors", "from reportlab.pdfgen import canvas", "from PIL import Image", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}], [{"term": "def", "name": "darken", "data": "def darken(color, factor=0.7):\n\t\"\"\"Return darkened color as a ReportLab RGB color.\n\n\tTake a passed color and returns a Reportlab color that is darker by the\n\tfactor indicated in the parameter.\n\t\"\"\"\n\tnewcol = color_to_reportlab(color)\n\tfor a in ['red', 'green', 'blue']:\n\t\tsetattr(newcol, a, factor * getattr(newcol, a))\n\treturn newcol\n\n", "description": "Return darkened color as a ReportLab RGB color.\n\n\tTake a passed color and returns a Reportlab color that is darker by the\n\tfactor indicated in the parameter.\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "\tfrom reportlab.lib import colors", "\tfrom reportlab.pdfgen import canvas", "\tfrom Bio import MissingPythonDependencyError", "\tfrom PIL import Image", "\tfrom Bio import MissingPythonDependencyError", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "def", "name": "color_to_reportlab", "data": "def color_to_reportlab(color):\n\t\"\"\"Return the passed color in Reportlab Color format.\n\n\tWe allow colors to be specified as hex values, tuples, or Reportlab Color\n\tobjects, and with or without an alpha channel. This function acts as a\n\tRosetta stone for conversion of those formats to a Reportlab Color\n\tobject, with alpha value.\n\n\tAny other color specification is returned directly\n\t\"\"\"\n\t# Reportlab Color objects are in the format we want already\n\tif isinstance(color, colors.Color):\n\t\treturn color\n\telif isinstance(color, str):  # String implies hex color\n\t\tif color.startswith(\"0x\"):  # Standardise to octothorpe\n\t\t\tcolor.replace(\"0x\", \"#\")\n\t\tif len(color) == 7:\n\t\t\treturn colors.HexColor(color)\n\t\telse:\n\t\t\ttry:\n\t\t\t\treturn colors.HexColor(color, hasAlpha=True)\n\t\t\texcept TypeError:  # Catch pre-2.7 Reportlab\n\t\t\t\traise RuntimeError(\"Your reportlab seems to be too old, try 2.7 onwards\")\n\telif isinstance(color, tuple):  # Tuple implies RGB(alpha) tuple\n\t\treturn colors.Color(*color)\n\treturn color\n\n", "description": "Return the passed color in Reportlab Color format.\n\n\tWe allow colors to be specified as hex values, tuples, or Reportlab Color\n\tobjects, and with or without an alpha channel. This function acts as a\n\tRosetta stone for conversion of those formats to a Reportlab Color\n\tobject, with alpha value.\n\n\tAny other color specification is returned directly\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "\tfrom reportlab.lib import colors", "\tfrom reportlab.pdfgen import canvas", "\tfrom Bio import MissingPythonDependencyError", "\tfrom PIL import Image", "\tfrom Bio import MissingPythonDependencyError", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "def", "name": "get_temp_imagefilename", "data": "def get_temp_imagefilename(url):\n\t\"\"\"Return filename of temporary file containing downloaded image.\n\n\tCreate a new temporary file to hold the image file at the passed URL\n\tand return the filename.\n\t\"\"\"\n\timg = _urlopen(url).read()\n\tim = Image.open(BytesIO(img))\n\t# im.transpose(Image.FLIP_TOP_BOTTOM)\n\tf = tempfile.NamedTemporaryFile(delete=False, suffix='.png')\n\tfname = f.name\n\tf.close()\n\tim.save(fname, 'PNG')\n\treturn fname\n\n", "description": "Return filename of temporary file containing downloaded image.\n\n\tCreate a new temporary file to hold the image file at the passed URL\n\tand return the filename.\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "\tfrom reportlab.lib import colors", "\tfrom reportlab.pdfgen import canvas", "\tfrom Bio import MissingPythonDependencyError", "\tfrom PIL import Image", "\tfrom Bio import MissingPythonDependencyError", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "class", "name": "KGMLCanvas", "data": "class KGMLCanvas(object):\n\t\"\"\"Reportlab Canvas-based representation of a KGML pathway map.\"\"\"\n\n\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,\n\t\t\t\t label_orthologs=True, label_reaction_entries=True,\n\t\t\t\t label_maps=True, show_maps=False, fontname='Helvetica',\n\t\t\t\t fontsize=6, draw_relations=True, show_orthologs=True,\n\t\t\t\t show_compounds=True, show_genes=True,\n\t\t\t\t show_reaction_entries=True, margins=(0.02, 0.02)):\n\t\t\"\"\"Initialize.\"\"\"\n\t\tself.pathway = pathway\n\t\tself.show_maps = show_maps\n\t\tself.show_orthologs = show_orthologs\n\t\tself.show_compounds = show_compounds\n\t\tself.show_genes = show_genes\n\t\tself.show_reaction_entries = show_reaction_entries\n\t\tself.label_compounds = label_compounds\n\t\tself.label_orthologs = label_orthologs\n\t\tself.label_reaction_entries = label_reaction_entries\n\t\tself.label_maps = label_maps\n\t\tself.fontname = fontname\n\t\tself.fontsize = fontsize\n\t\tself.draw_relations = draw_relations\n\t\tself.non_reactant_transparency = 0.3\n\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL\n\t\t# percentage of canvas that will be margin in on either side in the\n\t\t# X and Y directions\n\t\tself.margins = margins\n\n\tdef draw(self, filename):\n\t\t\"\"\"Add the map elements to the drawing.\"\"\"\n\t\t# Instantiate the drawing, first\n\t\t# size x_max, y_max for now - we can add margins, later\n\t\tif self.import_imagemap:\n\t\t\t# We're drawing directly on the image, so we set the canvas to the\n\t\t\t# same size as the image\n\t\t\tif os.path.isfile(self.pathway.image):\n\t\t\t\timfilename = self.pathway.image\n\t\t\telse:\n\t\t\t\timfilename = get_temp_imagefilename(self.pathway.image)\n\t\t\tim = Image.open(imfilename)\n\t\t\tcwidth, cheight = im.size\n\t\telse:\n\t\t\t# No image, so we set the canvas size to accommodate visible\n\t\t\t# elements\n\t\t\tcwidth, cheight = (self.pathway.bounds[1][0],\n\t\t\t\t\t\t\t   self.pathway.bounds[1][1])\n\t\t# Instantiate canvas\n\t\tself.drawing = \\\n\t\t\tcanvas.Canvas(filename, bottomup=0,\n\t\t\t\t\t\t  pagesize=(cwidth * (1 + 2 * self.margins[0]),\n\t\t\t\t\t\t\t\t\tcheight * (1 + 2 * self.margins[1])))\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\t\t# Transform the canvas to add the margins\n\t\tself.drawing.translate(self.margins[0] * self.pathway.bounds[1][0],\n\t\t\t\t\t\t\t   self.margins[1] * self.pathway.bounds[1][1])\n\t\t# Add the map image, if required\n\t\tif self.import_imagemap:\n\t\t\tself.drawing.saveState()\n\t\t\tself.drawing.scale(1, -1)\n\t\t\tself.drawing.translate(0, -cheight)\n\t\t\tself.drawing.drawImage(imfilename, 0, 0)\n\t\t\tself.drawing.restoreState()\n\t\t# Add the reactions, compounds and maps\n\t\t# Maps go on first, to be overlaid by more information.\n\t\t# By default, they're slightly transparent.\n\t\tif self.show_maps:\n\t\t\tself.__add_maps()\n\t\tif self.show_reaction_entries:\n\t\t\tself.__add_reaction_entries()\n\t\tif self.show_orthologs:\n\t\t\tself.__add_orthologs()\n\t\tif self.show_compounds:\n\t\t\tself.__add_compounds()\n\t\tif self.show_genes:\n\t\t\tself.__add_genes()\n\t\t# TODO: complete draw_relations code\n\t\t# if self.draw_relations:\n\t\t#\tself.__add_relations()\n\t\t# Write the pathway map to PDF\n\t\tself.drawing.save()\n\n\tdef __add_maps(self):\n\t\t\"\"\"Add maps to the drawing of the map (PRIVATE).\n\n\t\tWe do this first, as they're regional labels to be overlaid by\n\t\tinformation.  Also, we want to set the color to something subtle.\n\n\t\tWe're using Hex colors because that's what KGML uses, and\n\t\tReportlab doesn't mind.\n\t\t\"\"\"\n\t\tfor m in self.pathway.maps:\n\t\t\tfor g in m.graphics:\n\t\t\t\tself.drawing.setStrokeColor('#888888')\n\t\t\t\tself.drawing.setFillColor('#DDDDDD')\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_maps:\n\t\t\t\t\tself.drawing.setFillColor('#888888')\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_graphics(self, graphics):\n\t\t\"\"\"Add the passed graphics object to the map (PRIVATE).\n\n\t\tAdd text, add after the graphics object, for sane Z-ordering.\n\t\t\"\"\"\n\t\tif graphics.type == 'line':\n\t\t\tp = self.drawing.beginPath()\n\t\t\tx, y = graphics.coords[0]\n\t\t\t# There are optional settings for lines that aren't necessarily\n\t\t\t# part of the KGML DTD\n\t\t\tif graphics.width is not None:\n\t\t\t\tself.drawing.setLineWidth(graphics.width)\n\t\t\telse:\n\t\t\t\tself.drawing.setLineWidth(1)\n\t\t\tp.moveTo(x, y)\n\t\t\tfor (x, y) in graphics.coords:\n\t\t\t\tp.lineTo(x, y)\n\t\t\tself.drawing.drawPath(p)\n\t\t\tself.drawing.setLineWidth(1)\t\t# Return to default\n\t\t# KGML defines the (x, y) coordinates as the centre of the circle/\n\t\t# rectangle/roundrectangle, but Reportlab uses the co-ordinates of the\n\t\t# lower-left corner for rectangle/elif.\n\t\tif graphics.type == 'circle':\n\t\t\tself.drawing.circle(graphics.x, graphics.y, graphics.width * 0.5,\n\t\t\t\t\t\t\t\tstroke=1, fill=1)\n\t\telif graphics.type == 'roundrectangle':\n\t\t\tself.drawing.roundRect(graphics.x - graphics.width * 0.5,\n\t\t\t\t\t\t\t\t   graphics.y - graphics.height * 0.5,\n\t\t\t\t\t\t\t\t   graphics.width, graphics.height,\n\t\t\t\t\t\t\t\t   min(graphics.width, graphics.height) * 0.1,\n\t\t\t\t\t\t\t\t   stroke=1, fill=1)\n\t\telif graphics.type == 'rectangle':\n\t\t\tself.drawing.rect(graphics.x - graphics.width * 0.5,\n\t\t\t\t\t\t\t  graphics.y - graphics.height * 0.5,\n\t\t\t\t\t\t\t  graphics.width, graphics.height,\n\t\t\t\t\t\t\t  stroke=1, fill=1)\n\n\tdef __add_labels(self, graphics):\n\t\t\"\"\"Add labels for the passed graphics objects to the map (PRIVATE).\n\n\t\tWe don't check that the labels fit inside objects such as circles/\n\t\trectangles/roundrectangles.\n\t\t\"\"\"\n\t\tif graphics.type == 'line':\n\t\t\t# We use the midpoint of the line - sort of - we take the median\n\t\t\t# line segment (list-wise, not in terms of length), and use the\n\t\t\t# midpoint of that line.  We could have other options here,\n\t\t\t# maybe even parameterising it to a proportion of the total line\n\t\t\t# length.\n\t\t\tmid_idx = len(graphics.coords) * 0.5\n\t\t\tif not int(mid_idx) == mid_idx:\n\t\t\t\tidx1, idx2 = int(mid_idx - 0.5), int(mid_idx + 0.5)\n\t\t\telse:\n\t\t\t\tidx1, idx2 = int(mid_idx - 1), int(mid_idx)\n\t\t\tx1, y1 = graphics.coords[idx1]\n\t\t\tx2, y2 = graphics.coords[idx2]\n\t\t\tx, y = 0.5 * (x1 + x2), 0.5 * (y1 + y2)\n\t\telif graphics.type == 'circle':\n\t\t\tx, y = graphics.x, graphics.y\n\t\telif graphics.type in ('rectangle', 'roundrectangle'):\n\t\t\tx, y = graphics.x, graphics.y\n\t\t# How big so we want the text, and how many characters?\n\t\tif graphics._parent.type == 'map':\n\t\t\ttext = graphics.name\n\t\t\tself.drawing.setFont(self.fontname, self.fontsize + 2)\n\t\telif len(graphics.name) < 15:\n\t\t\ttext = graphics.name\n\t\telse:\n\t\t\ttext = graphics.name[:12] + '...'\n\t\tself.drawing.drawCentredString(x, y, text)\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\n\tdef __add_orthologs(self):\n\t\t\"\"\"Add 'ortholog' Entry elements to the drawing of the map (PRIVATE).\n\n\t\tIn KGML, these are typically line objects, so we render them\n\t\tbefore the compound circles to cover the unsightly ends/junctions.\n\t\t\"\"\"\n\t\tfor ortholog in self.pathway.orthologs:\n\t\t\tfor g in ortholog.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_orthologs:\n\t\t\t\t\t# We want the label color to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_reaction_entries(self):\n\t\t\"\"\"Add Entry elements for Reactions to the map drawing (PRIVATE).\n\n\t\tIn KGML, these are typically line objects, so we render them\n\t\tbefore the compound circles to cover the unsightly ends/junctions\n\t\t\"\"\"\n\t\tfor reaction in self.pathway.reaction_entries:\n\t\t\tfor g in reaction.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_reaction_entries:\n\t\t\t\t\t# We want the label color to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_compounds(self):\n\t\t\"\"\"Add compound elements to the drawing of the map (PRIVATE).\"\"\"\n\t\tfor compound in self.pathway.compounds:\n\t\t\tfor g in compound.graphics:\n\t\t\t\t# Modify transparency of compounds that don't participate\n\t\t\t\t# in reactions\n\t\t\t\tfillcolor = color_to_reportlab(g.bgcolor)\n\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\tfillcolor.alpha *= self.non_reactant_transparency\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(fillcolor)\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\t\tt = 0.3\n\t\t\t\t\telse:\n\t\t\t\t\t\tt = 1\n\t\t\t\t\tself.drawing.setFillColor(colors.Color(0.2, 0.2, 0.2, t))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_genes(self):\n\t\t\"\"\"Add gene elements to the drawing of the map (PRIVATE).\"\"\"\n\t\tfor gene in self.pathway.genes:\n\t\t\tfor g in gene.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_relations(self):\n\t\t\"\"\"Add relations to the map (PRIVATE).\n\n\t\tThis is tricky. There is no defined graphic in KGML for a\n\t\trelation, and the corresponding entries are typically defined\n\t\tas objects 'to be connected somehow'.  KEGG uses KegSketch, which\n\t\tis not public, and most third-party software draws straight line\n\t\tarrows, with heads to indicate the appropriate direction\n\t\t(at both ends for reversible reactions), using solid lines for\n\t\tECrel relation types, and dashed lines for maplink relation types.\n\n\t\tThe relation has:\n\t\t- entry1: 'from' node\n\t\t- entry2: 'to' node\n\t\t- subtype: what the relation refers to\n\n\t\tTypically we have entry1 = map/ortholog; entry2 = map/ortholog,\n\t\tsubtype = compound.\n\t\t\"\"\"\n\t\t# Dashed lines for maplinks, solid for everything else\n\t\tfor relation in list(self.pathway.relations):\n\t\t\tif relation.type == 'maplink':\n\t\t\t\tself.drawing.setDash(6, 3)\n\t\t\telse:\n\t\t\t\tself.drawing.setDash()\n\t\t\tfor s in relation.subtypes:\n\t\t\t\tsubtype = self.pathway.entries[s[1]]\n\t\t\t\t# Our aim is to draw an arrow from the entry1 object to the\n\t\t\t\t# entry2 object, via the subtype object.\n\t\t\t\t# 1) Entry 1 to subtype\n\t\t\t\tself.__draw_arrow(relation.entry1, subtype)\n\t\t\t\t# 2) subtype to Entry 2\n\t\t\t\tself.__draw_arrow(subtype, relation.entry2)\n\n\tdef __draw_arrow(self, g_from, g_to):\n\t\t\"\"\"Draw an arrow between given Entry objects (PRIVATE).\n\n\t\tDraws an arrow from the g_from Entry object to the g_to\n\t\tEntry object; both must have Graphics objects.\n\t\t\"\"\"\n\t\t# Centre and bound co-ordinates for the from and two objects\n\t\tbounds_from, bounds_to = g_from.bounds, g_to.bounds\n\t\tcentre_from = (0.5 * (bounds_from[0][0] + bounds_from[1][0]),\n\t\t\t\t\t   0.5 * (bounds_from[0][1] + bounds_from[1][1]))\n\t\tcentre_to = (0.5 * (bounds_to[0][0] + bounds_to[1][0]),\n\t\t\t\t\t 0.5 * (bounds_to[0][1] + bounds_to[1][1]))\n\t\tp = self.drawing.beginPath()\n\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t# If the 'from' and 'to' graphics are vertically-aligned, draw a line\n\t\t# from the 'from' to the 'to' entity\n\t\tif bounds_to[0][0] < centre_from[0] < bounds_to[1][0]:\n\t\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t\tif centre_to[1] > centre_from[1]:  # to above from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\t\telse:\t\t\t\t\t\t\t # to below from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\telif bounds_from[0][0] < centre_to[0] < bounds_from[1][0]:\n\t\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t\tif centre_to[1] > centre_from[1]:  # to above from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\t\telse:\t\t\t\t\t\t\t # to below from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\tself.drawing.drawPath(p)\t# Draw arrow shaft\n\t\t# print(g_from)\n\t\t# print(bounds_from)\n\t\t# print(g_to)\n\t\t# print(bounds_to)\n", "description": "Reportlab Canvas-based representation of a KGML pathway map.", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "\tfrom reportlab.lib import colors", "\tfrom reportlab.pdfgen import canvas", "\tfrom Bio import MissingPythonDependencyError", "\tfrom PIL import Image", "\tfrom Bio import MissingPythonDependencyError", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}], [{"term": "def", "name": "darken", "data": "def darken(color, factor=0.7):\n\t\"\"\"Return darkened color as a ReportLab RGB color.\n\n\tTake a passed color and returns a Reportlab color that is darker by the\n\tfactor indicated in the parameter.\n\t\"\"\"\n\tnewcol = color_to_reportlab(color)\n\tfor a in ['red', 'green', 'blue']:\n\t\tsetattr(newcol, a, factor * getattr(newcol, a))\n\treturn newcol\n\n", "description": "Return darkened color as a ReportLab RGB color.\n\n\tTake a passed color and returns a Reportlab color that is darker by the\n\tfactor indicated in the parameter.\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "\tfrom reportlab.lib import colors", "\tfrom reportlab.pdfgen import canvas", "\tfrom Bio import MissingPythonDependencyError", "\tfrom PIL import Image", "\tfrom Bio import MissingPythonDependencyError", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "def", "name": "color_to_reportlab", "data": "def color_to_reportlab(color):\n\t\"\"\"Return the passed color in Reportlab Color format.\n\n\tWe allow colors to be specified as hex values, tuples, or Reportlab Color\n\tobjects, and with or without an alpha channel. This function acts as a\n\tRosetta stone for conversion of those formats to a Reportlab Color\n\tobject, with alpha value.\n\n\tAny other color specification is returned directly\n\t\"\"\"\n\t# Reportlab Color objects are in the format we want already\n\tif isinstance(color, colors.Color):\n\t\treturn color\n\telif isinstance(color, str):  # String implies hex color\n\t\tif color.startswith(\"0x\"):  # Standardise to octothorpe\n\t\t\tcolor.replace(\"0x\", \"#\")\n\t\tif len(color) == 7:\n\t\t\treturn colors.HexColor(color)\n\t\telse:\n\t\t\ttry:\n\t\t\t\treturn colors.HexColor(color, hasAlpha=True)\n\t\t\texcept TypeError:  # Catch pre-2.7 Reportlab\n\t\t\t\traise RuntimeError(\"Your reportlab seems to be too old, try 2.7 onwards\")\n\telif isinstance(color, tuple):  # Tuple implies RGB(alpha) tuple\n\t\treturn colors.Color(*color)\n\treturn color\n\n", "description": "Return the passed color in Reportlab Color format.\n\n\tWe allow colors to be specified as hex values, tuples, or Reportlab Color\n\tobjects, and with or without an alpha channel. This function acts as a\n\tRosetta stone for conversion of those formats to a Reportlab Color\n\tobject, with alpha value.\n\n\tAny other color specification is returned directly\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "\tfrom reportlab.lib import colors", "\tfrom reportlab.pdfgen import canvas", "\tfrom Bio import MissingPythonDependencyError", "\tfrom PIL import Image", "\tfrom Bio import MissingPythonDependencyError", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "def", "name": "get_temp_imagefilename", "data": "def get_temp_imagefilename(url):\n\t\"\"\"Return filename of temporary file containing downloaded image.\n\n\tCreate a new temporary file to hold the image file at the passed URL\n\tand return the filename.\n\t\"\"\"\n\timg = _urlopen(url).read()\n\tim = Image.open(BytesIO(img))\n\t# im.transpose(Image.FLIP_TOP_BOTTOM)\n\tf = tempfile.NamedTemporaryFile(delete=False, suffix='.png')\n\tfname = f.name\n\tf.close()\n\tim.save(fname, 'PNG')\n\treturn fname\n\n", "description": "Return filename of temporary file containing downloaded image.\n\n\tCreate a new temporary file to hold the image file at the passed URL\n\tand return the filename.\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "\tfrom reportlab.lib import colors", "\tfrom reportlab.pdfgen import canvas", "\tfrom Bio import MissingPythonDependencyError", "\tfrom PIL import Image", "\tfrom Bio import MissingPythonDependencyError", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "class", "name": "KGMLCanvas", "data": "class KGMLCanvas(object):\n\t\"\"\"Reportlab Canvas-based representation of a KGML pathway map.\"\"\"\n\n\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,\n\t\t\t\t label_orthologs=True, label_reaction_entries=True,\n\t\t\t\t label_maps=True, show_maps=False, fontname='Helvetica',\n\t\t\t\t fontsize=6, draw_relations=True, show_orthologs=True,\n\t\t\t\t show_compounds=True, show_genes=True,\n\t\t\t\t show_reaction_entries=True, margins=(0.02, 0.02)):\n\t\t\"\"\"Initialize.\"\"\"\n\t\tself.pathway = pathway\n\t\tself.show_maps = show_maps\n\t\tself.show_orthologs = show_orthologs\n\t\tself.show_compounds = show_compounds\n\t\tself.show_genes = show_genes\n\t\tself.show_reaction_entries = show_reaction_entries\n\t\tself.label_compounds = label_compounds\n\t\tself.label_orthologs = label_orthologs\n\t\tself.label_reaction_entries = label_reaction_entries\n\t\tself.label_maps = label_maps\n\t\tself.fontname = fontname\n\t\tself.fontsize = fontsize\n\t\tself.draw_relations = draw_relations\n\t\tself.non_reactant_transparency = 0.3\n\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL\n\t\t# percentage of canvas that will be margin in on either side in the\n\t\t# X and Y directions\n\t\tself.margins = margins\n\n\tdef draw(self, filename):\n\t\t\"\"\"Add the map elements to the drawing.\"\"\"\n\t\t# Instantiate the drawing, first\n\t\t# size x_max, y_max for now - we can add margins, later\n\t\tif self.import_imagemap:\n\t\t\t# We're drawing directly on the image, so we set the canvas to the\n\t\t\t# same size as the image\n\t\t\tif os.path.isfile(self.pathway.image):\n\t\t\t\timfilename = self.pathway.image\n\t\t\telse:\n\t\t\t\timfilename = get_temp_imagefilename(self.pathway.image)\n\t\t\tim = Image.open(imfilename)\n\t\t\tcwidth, cheight = im.size\n\t\telse:\n\t\t\t# No image, so we set the canvas size to accommodate visible\n\t\t\t# elements\n\t\t\tcwidth, cheight = (self.pathway.bounds[1][0],\n\t\t\t\t\t\t\t   self.pathway.bounds[1][1])\n\t\t# Instantiate canvas\n\t\tself.drawing = \\\n\t\t\tcanvas.Canvas(filename, bottomup=0,\n\t\t\t\t\t\t  pagesize=(cwidth * (1 + 2 * self.margins[0]),\n\t\t\t\t\t\t\t\t\tcheight * (1 + 2 * self.margins[1])))\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\t\t# Transform the canvas to add the margins\n\t\tself.drawing.translate(self.margins[0] * self.pathway.bounds[1][0],\n\t\t\t\t\t\t\t   self.margins[1] * self.pathway.bounds[1][1])\n\t\t# Add the map image, if required\n\t\tif self.import_imagemap:\n\t\t\tself.drawing.saveState()\n\t\t\tself.drawing.scale(1, -1)\n\t\t\tself.drawing.translate(0, -cheight)\n\t\t\tself.drawing.drawImage(imfilename, 0, 0)\n\t\t\tself.drawing.restoreState()\n\t\t# Add the reactions, compounds and maps\n\t\t# Maps go on first, to be overlaid by more information.\n\t\t# By default, they're slightly transparent.\n\t\tif self.show_maps:\n\t\t\tself.__add_maps()\n\t\tif self.show_reaction_entries:\n\t\t\tself.__add_reaction_entries()\n\t\tif self.show_orthologs:\n\t\t\tself.__add_orthologs()\n\t\tif self.show_compounds:\n\t\t\tself.__add_compounds()\n\t\tif self.show_genes:\n\t\t\tself.__add_genes()\n\t\t# TODO: complete draw_relations code\n\t\t# if self.draw_relations:\n\t\t#\tself.__add_relations()\n\t\t# Write the pathway map to PDF\n\t\tself.drawing.save()\n\n\tdef __add_maps(self):\n\t\t\"\"\"Add maps to the drawing of the map (PRIVATE).\n\n\t\tWe do this first, as they're regional labels to be overlaid by\n\t\tinformation.  Also, we want to set the color to something subtle.\n\n\t\tWe're using Hex colors because that's what KGML uses, and\n\t\tReportlab doesn't mind.\n\t\t\"\"\"\n\t\tfor m in self.pathway.maps:\n\t\t\tfor g in m.graphics:\n\t\t\t\tself.drawing.setStrokeColor('#888888')\n\t\t\t\tself.drawing.setFillColor('#DDDDDD')\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_maps:\n\t\t\t\t\tself.drawing.setFillColor('#888888')\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_graphics(self, graphics):\n\t\t\"\"\"Add the passed graphics object to the map (PRIVATE).\n\n\t\tAdd text, add after the graphics object, for sane Z-ordering.\n\t\t\"\"\"\n\t\tif graphics.type == 'line':\n\t\t\tp = self.drawing.beginPath()\n\t\t\tx, y = graphics.coords[0]\n\t\t\t# There are optional settings for lines that aren't necessarily\n\t\t\t# part of the KGML DTD\n\t\t\tif graphics.width is not None:\n\t\t\t\tself.drawing.setLineWidth(graphics.width)\n\t\t\telse:\n\t\t\t\tself.drawing.setLineWidth(1)\n\t\t\tp.moveTo(x, y)\n\t\t\tfor (x, y) in graphics.coords:\n\t\t\t\tp.lineTo(x, y)\n\t\t\tself.drawing.drawPath(p)\n\t\t\tself.drawing.setLineWidth(1)\t\t# Return to default\n\t\t# KGML defines the (x, y) coordinates as the centre of the circle/\n\t\t# rectangle/roundrectangle, but Reportlab uses the co-ordinates of the\n\t\t# lower-left corner for rectangle/elif.\n\t\tif graphics.type == 'circle':\n\t\t\tself.drawing.circle(graphics.x, graphics.y, graphics.width * 0.5,\n\t\t\t\t\t\t\t\tstroke=1, fill=1)\n\t\telif graphics.type == 'roundrectangle':\n\t\t\tself.drawing.roundRect(graphics.x - graphics.width * 0.5,\n\t\t\t\t\t\t\t\t   graphics.y - graphics.height * 0.5,\n\t\t\t\t\t\t\t\t   graphics.width, graphics.height,\n\t\t\t\t\t\t\t\t   min(graphics.width, graphics.height) * 0.1,\n\t\t\t\t\t\t\t\t   stroke=1, fill=1)\n\t\telif graphics.type == 'rectangle':\n\t\t\tself.drawing.rect(graphics.x - graphics.width * 0.5,\n\t\t\t\t\t\t\t  graphics.y - graphics.height * 0.5,\n\t\t\t\t\t\t\t  graphics.width, graphics.height,\n\t\t\t\t\t\t\t  stroke=1, fill=1)\n\n\tdef __add_labels(self, graphics):\n\t\t\"\"\"Add labels for the passed graphics objects to the map (PRIVATE).\n\n\t\tWe don't check that the labels fit inside objects such as circles/\n\t\trectangles/roundrectangles.\n\t\t\"\"\"\n\t\tif graphics.type == 'line':\n\t\t\t# We use the midpoint of the line - sort of - we take the median\n\t\t\t# line segment (list-wise, not in terms of length), and use the\n\t\t\t# midpoint of that line.  We could have other options here,\n\t\t\t# maybe even parameterising it to a proportion of the total line\n\t\t\t# length.\n\t\t\tmid_idx = len(graphics.coords) * 0.5\n\t\t\tif not int(mid_idx) == mid_idx:\n\t\t\t\tidx1, idx2 = int(mid_idx - 0.5), int(mid_idx + 0.5)\n\t\t\telse:\n\t\t\t\tidx1, idx2 = int(mid_idx - 1), int(mid_idx)\n\t\t\tx1, y1 = graphics.coords[idx1]\n\t\t\tx2, y2 = graphics.coords[idx2]\n\t\t\tx, y = 0.5 * (x1 + x2), 0.5 * (y1 + y2)\n\t\telif graphics.type == 'circle':\n\t\t\tx, y = graphics.x, graphics.y\n\t\telif graphics.type in ('rectangle', 'roundrectangle'):\n\t\t\tx, y = graphics.x, graphics.y\n\t\t# How big so we want the text, and how many characters?\n\t\tif graphics._parent.type == 'map':\n\t\t\ttext = graphics.name\n\t\t\tself.drawing.setFont(self.fontname, self.fontsize + 2)\n\t\telif len(graphics.name) < 15:\n\t\t\ttext = graphics.name\n\t\telse:\n\t\t\ttext = graphics.name[:12] + '...'\n\t\tself.drawing.drawCentredString(x, y, text)\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\n\tdef __add_orthologs(self):\n\t\t\"\"\"Add 'ortholog' Entry elements to the drawing of the map (PRIVATE).\n\n\t\tIn KGML, these are typically line objects, so we render them\n\t\tbefore the compound circles to cover the unsightly ends/junctions.\n\t\t\"\"\"\n\t\tfor ortholog in self.pathway.orthologs:\n\t\t\tfor g in ortholog.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_orthologs:\n\t\t\t\t\t# We want the label color to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_reaction_entries(self):\n\t\t\"\"\"Add Entry elements for Reactions to the map drawing (PRIVATE).\n\n\t\tIn KGML, these are typically line objects, so we render them\n\t\tbefore the compound circles to cover the unsightly ends/junctions\n\t\t\"\"\"\n\t\tfor reaction in self.pathway.reaction_entries:\n\t\t\tfor g in reaction.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_reaction_entries:\n\t\t\t\t\t# We want the label color to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_compounds(self):\n\t\t\"\"\"Add compound elements to the drawing of the map (PRIVATE).\"\"\"\n\t\tfor compound in self.pathway.compounds:\n\t\t\tfor g in compound.graphics:\n\t\t\t\t# Modify transparency of compounds that don't participate\n\t\t\t\t# in reactions\n\t\t\t\tfillcolor = color_to_reportlab(g.bgcolor)\n\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\tfillcolor.alpha *= self.non_reactant_transparency\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(fillcolor)\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\t\tt = 0.3\n\t\t\t\t\telse:\n\t\t\t\t\t\tt = 1\n\t\t\t\t\tself.drawing.setFillColor(colors.Color(0.2, 0.2, 0.2, t))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_genes(self):\n\t\t\"\"\"Add gene elements to the drawing of the map (PRIVATE).\"\"\"\n\t\tfor gene in self.pathway.genes:\n\t\t\tfor g in gene.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_relations(self):\n\t\t\"\"\"Add relations to the map (PRIVATE).\n\n\t\tThis is tricky. There is no defined graphic in KGML for a\n\t\trelation, and the corresponding entries are typically defined\n\t\tas objects 'to be connected somehow'.  KEGG uses KegSketch, which\n\t\tis not public, and most third-party software draws straight line\n\t\tarrows, with heads to indicate the appropriate direction\n\t\t(at both ends for reversible reactions), using solid lines for\n\t\tECrel relation types, and dashed lines for maplink relation types.\n\n\t\tThe relation has:\n\t\t- entry1: 'from' node\n\t\t- entry2: 'to' node\n\t\t- subtype: what the relation refers to\n\n\t\tTypically we have entry1 = map/ortholog; entry2 = map/ortholog,\n\t\tsubtype = compound.\n\t\t\"\"\"\n\t\t# Dashed lines for maplinks, solid for everything else\n\t\tfor relation in list(self.pathway.relations):\n\t\t\tif relation.type == 'maplink':\n\t\t\t\tself.drawing.setDash(6, 3)\n\t\t\telse:\n\t\t\t\tself.drawing.setDash()\n\t\t\tfor s in relation.subtypes:\n\t\t\t\tsubtype = self.pathway.entries[s[1]]\n\t\t\t\t# Our aim is to draw an arrow from the entry1 object to the\n\t\t\t\t# entry2 object, via the subtype object.\n\t\t\t\t# 1) Entry 1 to subtype\n\t\t\t\tself.__draw_arrow(relation.entry1, subtype)\n\t\t\t\t# 2) subtype to Entry 2\n\t\t\t\tself.__draw_arrow(subtype, relation.entry2)\n\n\tdef __draw_arrow(self, g_from, g_to):\n\t\t\"\"\"Draw an arrow between given Entry objects (PRIVATE).\n\n\t\tDraws an arrow from the g_from Entry object to the g_to\n\t\tEntry object; both must have Graphics objects.\n\t\t\"\"\"\n\t\t# Centre and bound co-ordinates for the from and two objects\n\t\tbounds_from, bounds_to = g_from.bounds, g_to.bounds\n\t\tcentre_from = (0.5 * (bounds_from[0][0] + bounds_from[1][0]),\n\t\t\t\t\t   0.5 * (bounds_from[0][1] + bounds_from[1][1]))\n\t\tcentre_to = (0.5 * (bounds_to[0][0] + bounds_to[1][0]),\n\t\t\t\t\t 0.5 * (bounds_to[0][1] + bounds_to[1][1]))\n\t\tp = self.drawing.beginPath()\n\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t# If the 'from' and 'to' graphics are vertically-aligned, draw a line\n\t\t# from the 'from' to the 'to' entity\n\t\tif bounds_to[0][0] < centre_from[0] < bounds_to[1][0]:\n\t\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t\tif centre_to[1] > centre_from[1]:  # to above from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\t\telse:\t\t\t\t\t\t\t # to below from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\telif bounds_from[0][0] < centre_to[0] < bounds_from[1][0]:\n\t\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t\tif centre_to[1] > centre_from[1]:  # to above from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\t\telse:\t\t\t\t\t\t\t # to below from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\tself.drawing.drawPath(p)\t# Draw arrow shaft\n\t\t# print(g_from)\n\t\t# print(bounds_from)\n\t\t# print(g_to)\n\t\t# print(bounds_to)\n", "description": "Reportlab Canvas-based representation of a KGML pathway map.", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "\tfrom reportlab.lib import colors", "\tfrom reportlab.pdfgen import canvas", "\tfrom Bio import MissingPythonDependencyError", "\tfrom PIL import Image", "\tfrom Bio import MissingPythonDependencyError", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}], [{"term": "class", "name": "Section", "data": "class Section(ScoreContentWithPopup, ClassWithLogger):\n\tnotes: list = ListProperty()\n\tnotes_per_beat = NumericProperty()\n\ttitle: str = StringProperty()\n\n\ttime_signature_a: list = NumericProperty()\n\ttime_signature_b: list = NumericProperty()\n\ttime_signature: list = ReferenceListProperty(time_signature_a, time_signature_b)\n\n\tcontent: RelativeLayout\n\n\trequired_mode = \"section\"\n\n\tupdate = None\n\tmode = None\n\t\n\tdef __init__(self, **kwargs):\n\t\tClassWithLogger.__init__(self)\n\t\tScoreContentWithPopup.__init__(self, **kwargs)\n\n\t\tself.update = Clock.create_trigger(lambda _elapsed_time: self._update())\n\t\tWindow.bind(mouse_pos=self.on_mouse_move)\n\t\tGlobalBindings.bind(mode=self.change_mode)\n\n\t\tself.time_signature, self.notes_per_beat, self.notes = self.parse_string(\"4/4-4[. . . . . . . . . . . . . . . .\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"]\")\n\n\n\tdef on_kv_post(self, base_widget):\n\t\tself.content = self.ids[\"content\"]\n\n\tdef on_title(self, _instance, value):\n\t\tself.ids[\"title_text\"].text = value\n\n\tdef get_popup_class(self, **kwargs):\n\t\treturn AddSectionPopup(**kwargs)\n\n\tdef popup_submitted(self, instance, data):\n\t\tself.title = data.pop(\"title\", \"No Title Given\")\n\n\t\tself.update()\n\n\tdef open_popup_with_pre_values(self):\n\t\tself.popup(title=self.title)\n\n\n\tdef parse_string(self, string):\n\t\tparts = string.split(\"-\")\n\n\t\tts = parts[0].split(\"/\")\n\t\ttime_signature = int(ts[0]), int(ts[1])\n\t\tnotes_per_beat = int(parts[1].split(\"[\")[0])\n\t\tnotes = [note.split(\",\") for note in parts[1].split(\"[\")[1].replace(\"]\", \"\").split(\" \")]\n\n\t\tnotes = [([] if note == [\".\"] else note) for note in notes]\n\n\t\tself.log_debug(f\"Parsed {string} too ts={time_signature} npb={notes_per_beat} notes={notes}\")\n\t\treturn time_signature, notes_per_beat, notes\n\n\n\tdef change_mode(self, mode):\n\t\tself.mode = mode\n\n\tdef on_mouse_move(self, _instance, pos):\n\t\tif self.mode == \"note\":\n\t\t\tpos = self.to_widget(*pos)\n\n\t\t\tchild: Bar\n\t\t\tfor child in self.content.children:\n\t\t\t\tanimation: Optional[Animation]\n\n\t\t\t\tif child.current_animation_info is not None:\n\t\t\t\t\tanimation, direction = child.current_animation_info\n\n\t\t\t\telse:\n\t\t\t\t\tanimation, direction = None, None\n\n\n\t\t\t\tif child.collide_point(*pos):\n\t\t\t\t\tif direction == \"in\":\n\t\t\t\t\t\tanimation.stop(child)\n\n\t\t\t\t\t\tchild.current_animation_info = (None, None)\n\t\t\t\t\t\tanimation, direction = None, None\n\n\n\n\t\t\t\t\tif direction is None:\n\t\t\t\t\t\tanimation = Animation(none_music_note_width=constants.graphics.expanded_none_music_note_width,\n\t\t\t\t\t\t\t\t\t\t\t  duration=constants.graphics.none_music_note_expand_time,\n\t\t\t\t\t\t\t\t\t\t\t  transition=none_music_note_expand_transition)\n\t\t\t\t\t\tanimation.start(child)\n\t\t\t\t\t\tchild.current_animation_info = (animation, \"out\")\n\n\n\t\t\t\t\t# Future note place\n\t\t\t\t\tr_pos = child.to_local(*pos)\n\t\t\t\t\tnote_index, staff_level = child.pos_to_note(*r_pos)\n\n\t\t\t\t\tif note_index is not None:\n\t\t\t\t\t\tnote_type = constants.score.staff_level_to_note_name[\n\t\t\t\t\t\t\tmin(constants.score.staff_level_to_note_name.keys(), key=lambda x: abs(staff_level - x))]\n\n\t\t\t\t\t\tchild.temp_note_index = note_index\n\t\t\t\t\t\tchild.temp_note_type = note_type\n\n\n\n\t\t\t\telse:\n\t\t\t\t\tif direction == \"out\":\n\t\t\t\t\t\tanimation.stop(child)\n\n\t\t\t\t\t\tchild.current_animation_info = (None, None)\n\t\t\t\t\t\tanimation, direction = None, None\n\n\t\t\t\t\tif direction is None:\n\t\t\t\t\t\tanimation = Animation(none_music_note_width=constants.graphics.default_none_music_note_width,\n\t\t\t\t\t\t\t\t\t\t\t  duration=constants.graphics.none_music_note_expand_time,\n\t\t\t\t\t\t\t\t\t\t\t  transition=none_music_note_expand_transition)\n\t\t\t\t\t\tanimation.start(child)\n\t\t\t\t\t\tchild.current_animation_info = (animation, \"in\")\n\n\t\t\t\t\tchild.temp_note_index = None\n\t\t\t\t\tchild.temp_note_type = None\n\n\n\t@push_name_to_logger_name_stack\n\tdef _update(self):\n\t\tbeats_per_bar = self.notes_per_beat * self.time_signature[0]\n\t\tself.log_debug(f\"{beats_per_bar} beats per bar\")\n\t\tbars_needed = len(self.notes) / beats_per_bar\n\n\t\t# if bars_needed is 1.0 or 2.0 then int(bars_needed) == 1 or 2 which still == bars_needed,\n\t\t# but if it is 1.5 then it doesnt == int(bars_needed) which is 2\n\t\tassert bars_needed == int(bars_needed)\n\n\t\tbars_needed = int(bars_needed)\n\t\tbars_too_add = bars_needed - len(self.content.children)\n\t\tself.log_debug(f\"Adding {bars_too_add} bar widgets too self from {bars_needed} out of \"\n\t\t\t\t\t   f\"{len(self.content.children)}\")\n\n\n\t\tfor _ in range(bars_too_add):\n\t\t\tb = Bar()\n\t\t\tb.bind(width=self.do_width)\n\t\t\tself.content.add_widget(b)\n\n\t\tfor n, child in enumerate(self.content.children):\n\t\t\tnotes = self.notes[n * beats_per_bar:(n + 1) * beats_per_bar]\n\n\t\t\tchild.notes_per_beat = self.notes_per_beat\n\t\t\tchild.notes = notes\n\t\t\tself.log_dump(f\"Giving {child} \\\"{notes}\\\"\")\n\n\t\tself.content.children[0].bar_start_line_type = \"repeat\"\n\t\tself.content.children[-1].bar_end_line_type = \"repeat\"\n\n\n\tdef do_width(self, _instance, _value):\n\t\twidth = 0\n\t\tfor child in self.content.children:\n\t\t\tchild.x = width\n\t\t\twidth += child.width\n\t\tself.width = width\n\n\n\tdef on_touch_up(self, touch: MotionEvent):\n\t\tif check_mode(\"note\") and self.collide_point(*touch.pos):\n\t\t\tpos = self.to_local(*touch.pos)\n\n\t\t\tchild: Bar\n\t\t\tfor child in self.content.children:\n\t\t\t\tr_pos = child.to_local(*pos)\n\t\t\t\tnote_index, staff_level = child.pos_to_note(*r_pos)\n\n\t\t\t\tif note_index is not None:\n\t\t\t\t\tnote_type = constants.score.staff_level_to_note_name[\n\t\t\t\t\t\tmin(constants.score.staff_level_to_note_name.keys(), key=lambda x: abs(staff_level - x))]\n\n\t\t\t\t\tif note_type in self.notes[note_index]:\n\t\t\t\t\t\tself.log_debug(f\"Removing note of level {staff_level} which is {note_type} at {note_index}\")\n\n\t\t\t\t\t\tself.notes[note_index].remove(note_type)\n\t\t\t\t\t\tchild.update()\n\n\t\t\t\t\telse:\n\t\t\t\t\t\tself.log_debug(f\"Added note of level {staff_level} which is {note_type} at {note_index}\")\n\n\t\t\t\t\t\tself.notes[note_index].append(note_type)\n\t\t\t\t\t\tchild.update()\n\t\t\t\t\tself.update()\n\n\t\t\t\t\treturn True\n\n\n\t\telse:\n\t\t\treturn ScoreContentWithPopup.on_touch_up(self, touch)\n\n\n", "description": null, "category": "graphics", "imports": ["from fractions import Fraction", "from math import log", "from typing import Optional", "from kivy.animation import Animation, AnimationTransition", "from kivy.atlas import Atlas", "from kivy.clock import Clock", "from kivy.core.window import Window", "from kivy.graphics import Canvas, Color", "from kivy.input import MotionEvent", "from kivy.properties import NumericProperty, OptionProperty, ListProperty, ReferenceListProperty, StringProperty", "from kivy.uix.relativelayout import RelativeLayout", "import constants", "from app.globalBindings import GlobalBindings", "from app.mathVertexInstructions import MathLine, MathEllipse, MathRectangle", "from app.misc import check_mode", "from app.popups.addSectionPopup import AddSectionPopup", "from app.uix.scoreContent.scoreContentWithPopup import ScoreContentWithPopup", "from logger import push_name_to_logger_name_stack, ClassWithLogger, reset_logger_name_stack_for_function, \\"]}, {"term": "class", "name": "Bar", "data": "class Bar(RelativeLayout, ClassWithLogger):\n\tupdate: callable\n\tcurrent_animation_info: tuple[Animation, str] = None\n\t\"\"\"\n\tUsed by :class:`Section` for expanding the bar when the mouse is over it\n\t\"\"\"\n\n\tnotes: list = ListProperty()\n\tnotes_per_beat: int = NumericProperty()\n\tnone_music_note_width = NumericProperty(constants.graphics.default_none_music_note_width)\n\n\ttemp_note_index = NumericProperty(None, allownone=True)\n\ttemp_note_type = StringProperty(None, allownone=True)\n\n\t_current_not_drawn_rests: int = NumericProperty()\n\t_current_dx: int = NumericProperty()\n\n\tbar_start_line_type: str = OptionProperty(\"single\", options=[\"single\", \"repeat\"])\n\tbar_end_line_type: str = OptionProperty(\"single\", options=[\"single\", \"repeat\"])\n\n\t_bar_start_line_width: int = NumericProperty(constants.graphics.bar_edge_line_width)\n\t_bar_end_line_width: int = NumericProperty(constants.graphics.bar_edge_line_width)\n\n\tnote_canvas: Canvas\n\n\tdef __init__(self, **kwargs):\n\t\tClassWithLogger.__init__(self)\n\n\t\tself.note_canvas = Canvas()\n\t\tself.update = Clock.create_trigger(lambda _elapsed_time: self._update())\n\t\tself.do_width = Clock.create_trigger(lambda _elapsed_time: self._do_width())\n\t\tself.bind(notes=lambda _instance, _value: self.update(), notes_per_beat=lambda _instance, _value: self.update(),\n\t\t\t\t  none_music_note_width=lambda _instance, _value: self.do_width(),\n\t\t\t\t  temp_note_index=lambda _instance, _value: self.update(),\n\t\t\t\t  temp_note_type=lambda _instance, _value: self.update(),\n\t\t\t\t  _current_not_drawn_rests=lambda _instance, _value: self.do_width(),\n\t\t\t\t  _current_dx=lambda _instance, _value: self.do_width())\n\n\t\tRelativeLayout.__init__(self, **kwargs)\n\n\t\tself.canvas.add(self.note_canvas)\n\n\n\tdef on_bar_start_line_type(self, _instance, value):\n\t\tif value == \"single\":\n\t\t\tself._bar_start_line_width = constants.graphics.bar_edge_line_width\n\n\t\telif value == \"repeat\":\n\t\t\tself._bar_start_line_width = constants.graphics.bar_edge_repeat_line_width\n\n\t\telse:\n\t\t\tself.log_critical(f\"No know bar_start_line_type called {value}\")\n\n\n\tdef on_bar_end_line_type(self, _instance, value):\n\t\tif value == \"single\":\n\t\t\tself._bar_end_line_width = constants.graphics.bar_edge_line_width\n\n\t\telif value == \"repeat\":\n\t\t\tself._bar_end_line_width = constants.graphics.bar_edge_repeat_line_width\n\n\t\telse:\n\t\t\tself.log_critical(f\"No know bar_end_line_type called {value}\")\n\n\n\tdef _do_width(self):\n\t\tself.width = self._current_dx + (self._current_not_drawn_rests * self.none_music_note_width)\n\n\n\tdef pos_to_note(self, x, y):\n\t\tdx = (constants.graphics.note_head_width * -1) + constants.graphics.bar_start_padding\n\n\t\tfor note_index, notes in enumerate(self.notes):\n\t\t\tif not notes:\n\t\t\t\tdx += self.none_music_note_width\n\n\t\t\telse:\n\t\t\t\tdx += constants.graphics.note_width\n\n\t\t\tif x < dx:\n\t\t\t\treturn note_index, ((y - (constants.graphics.staff_gap / 2)) / constants.graphics.staff_gap)\n\n\t\treturn None, None\n\n\n\n\n\t@push_name_to_logger_name_stack\n\tdef _update(self):\n\t\tnotes_per_beat = self.notes_per_beat\n\n\t\t_all_notes = self.notes.copy()\n\t\tif self.temp_note_index is not None:\n\t\t\t_all_notes[self.temp_note_index] = ((_all_notes[self.temp_note_index] + [self.temp_note_type]) if\n\t\t\t\t\t\t\t\t\t\t\t\t _all_notes[self.temp_note_index] != [] else [self.temp_note_type])\n\t\tall_notes = [_all_notes[n:n + 4] for n in range(0, len(_all_notes), notes_per_beat)]\n\t\tself.log_debug(f\"Got notes_per_beat: {notes_per_beat}, all_notes: {all_notes}\")\n\t\tself.log_dump()\n\n\t\tdx = 0\n\t\tnot_drawn_rests_this_bar = 0\n\t\tlast_not_drawn_rests_this_bar = 0\n\t\ttotal_note_index = 0\n\n\n\t\tself.note_canvas.clear()\n\t\tself.note_canvas.__enter__()\n\t\tColor(rgb=constants.graphics.note_color)\n\n\t\tdx += constants.graphics.bar_start_padding\n\t\tfor beat_index, beat_notes in enumerate(all_notes):\n\t\t\tself.log_dump()\n\t\t\tself.log_debug(f\"Beat {beat_index + 1} --------------| notes: {beat_notes} |--------------\")\n\t\t\tself.push_logger_name(f\"beat_{beat_index}\")\n\n\t\t\tsub_beats_to_skip, dx, did_draw_rest = self.draw_compressed_rests(beat_notes, dx, not_drawn_rests_this_bar)\n\t\t\tstem_y_points = self.get_stem_y_points(beat_notes)\n\t\t\tlast_note_stem_y_points = None\n\t\t\tlast_note_duration = None\n\t\t\tlast_note_dx = None\n\t\t\tmusic_notes_draw_this_beat = 0\n\n\t\t\tfor note_index, notes in enumerate(beat_notes):\n\t\t\t\tself.push_logger_name(f\"{note_index + 1}/{notes_per_beat}\")\n\t\t\t\tself.log_dump(f\"values: ({notes}, amount_of_beat_done: \"\n\t\t\t\t\t\t\t  f\"{Fraction(note_index, notes_per_beat)}, dx: {dx}, sub_beats_to_skip: \"\n\t\t\t\t\t\t\t  f\"{sub_beats_to_skip})\")\n\n\t\t\t\tnote_duration = get_note_duration(beat_notes, note_index, notes_per_beat)\n\n\t\t\t\tif sub_beats_to_skip > 0:\n\t\t\t\t\tif sub_beats_to_skip != 0:\n\t\t\t\t\t\tnot_drawn_rests_this_bar += 1\n\n\t\t\t\t\tsub_beats_to_skip -= 1\n\n\t\t\t\telse:\n\t\t\t\t\tif not notes:\n\t\t\t\t\t\tif not did_draw_rest:\n\t\t\t\t\t\t\tnot_drawn_rests_this_bar += 1\n\n\t\t\t\t\telse:\n\t\t\t\t\t\tdid_draw_rest = False\n\t\t\t\t\t\tnote_stem_y_points = stem_y_points[music_notes_draw_this_beat]\n\n\t\t\t\t\t\tfor note in notes:\n\t\t\t\t\t\t\ttmp_note = ((total_note_index == self.temp_note_index) and (note == self.temp_note_type))\n\t\t\t\t\t\t\tprint(tmp_note, (total_note_index == self.temp_note_index), (note == self.temp_note_type), total_note_index, self.temp_note_index)\n\t\t\t\t\t\t\tif tmp_note:\n\t\t\t\t\t\t\t\tif self.temp_note_type in self.notes[self.temp_note_index]:\n\t\t\t\t\t\t\t\t\tColor(rgb=constants.graphics.temp_note_that_exists_color)\n\n\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\tColor(rgb=constants.graphics.temp_note_color)\n\n\t\t\t\t\t\t\tdraw_note(self, note, dx, not_drawn_rests_this_bar)\n\n\t\t\t\t\t\t\tif tmp_note:\n\t\t\t\t\t\t\t\tColor(rgb=constants.graphics.note_color)\n\n\t\t\t\t\t\t\tMathLine(self, [\"none_music_note_width\"],\n\t\t\t\t\t\t\t\t\t [f\"{dx + constants.graphics.note_head_width} + ({not_drawn_rests_this_bar} * \"\n\t\t\t\t\t\t\t\t\t  f\"self.none_music_note_width)\",\n\t\t\t\t\t\t\t\t\t  f\"{note_stem_y_points[0]}\",\n\t\t\t\t\t\t\t\t\t  f\"{dx + constants.graphics.note_head_width} + ({not_drawn_rests_this_bar} * \"\n\t\t\t\t\t\t\t\t\t  f\"self.none_music_note_width)\",\n\t\t\t\t\t\t\t\t\t  f\"{note_stem_y_points[1]}\"],\n\t\t\t\t\t\t\t\t\t width=constants.graphics.note_stem_width)\n\n\n\n\n\t\t\t\t\t\tif music_notes_draw_this_beat == 0 and all([sub_beat_notes == []  # Flags required\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor sub_beat_notes in\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbeat_notes[note_index + 1:len(beat_notes)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   ]]):\n\t\t\t\t\t\t\tself.draw_note_flags(note_stem_y_points, note_duration, dx, not_drawn_rests_this_bar)\n\n\t\t\t\t\t\telse:  # Bars required\n\t\t\t\t\t\t\tif last_note_stem_y_points is not None:\n\t\t\t\t\t\t\t\tself.draw_note_bars(last_note_stem_y_points, last_note_duration, last_note_dx,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnote_stem_y_points, note_duration, dx, not_drawn_rests_this_bar,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlast_not_drawn_rests_this_bar)\n\n\n\t\t\t\t\t\tlast_note_dx = dx\n\t\t\t\t\t\tdx += constants.graphics.note_width\n\t\t\t\t\t\tmusic_notes_draw_this_beat += 1\n\n\t\t\t\t\t\tlast_note_stem_y_points = note_stem_y_points\n\t\t\t\t\t\tlast_note_duration = note_duration\n\n\t\t\t\t\t\tlast_not_drawn_rests_this_bar = not_drawn_rests_this_bar\n\t\t\t\ttotal_note_index += 1\n\n\n\t\t\t\tself.pop_logger_name()\n\t\t\tself.pop_logger_name()\n\t\tself.note_canvas.__exit__()\n\n\t\tself._current_not_drawn_rests = not_drawn_rests_this_bar\n\t\tself._current_dx = dx\n\n\n\t@push_name_to_logger_name_stack_custom(\"bars\")\n\tdef draw_note_bars(self, last_note_stem_y_points, last_note_duration, last_dx,\n\t\t\t\t\t   note_stem_y_points, note_duration, dx, not_drawn_rests_this_beat,\n\t\t\t\t\t   last_not_drawn_rests_this_beat):\n\t\tself.log_dump(f\"Drawing bars with {last_note_stem_y_points} last_note_stem_y_points, {last_note_duration} \"\n\t\t\t\t\t  f\"last_note_duration, {last_dx} last_dx, {note_stem_y_points} note_stem_y_points, {note_duration}\"\n\t\t\t\t\t  f\" note_duration, {dx} dx, {not_drawn_rests_this_beat}, none_draw_rests_this_beat, \"\n\t\t\t\t\t  f\"{last_not_drawn_rests_this_beat}\")\n\n\t\tif note_duration == Fraction(3, 4):\n\t\t\tself.log_dump(f\"Note has a duration of {note_duration} so gets a dot\")\n\n\t\t\tMathEllipse(self, [\"none_music_note_width\"],\n\t\t\t\t\t\t(f\"{dx + constants.graphics.note_dot_dpos[0]} + ({not_drawn_rests_this_beat} * \"\n\t\t\t\t\t\t\t\tf\"self.none_music_note_width)\",\n\t\t\t\t\t\t   f\"{note_stem_y_points[0] + constants.graphics.note_dot_dpos[1]}\"),\n\t\t\t\t\t\tsize=constants.graphics.note_dot_size)\n\n\t\t\tnote_duration = Fraction(2, 4)\n\n\n\n\t\tif last_note_duration == note_duration:  # Use d1\n\t\t\tself.log_dump(\"Using bars of last_note_duration because last_note_duration == note_duration\")\n\n\t\t\tfor bar_index in range(note_duration_to_bar_or_flag_amount(last_note_duration)):\n\t\t\t\tMathLine(self, [\"none_music_note_width\"],\n\t\t\t\t\t\t [f\"{last_dx + constants.graphics.note_head_width} + ({last_not_drawn_rests_this_beat} * \"\n\t\t\t\t\t\t\t\tf\"self.none_music_note_width)\",\n\t\t\t\t\t\t\tf\"{last_note_stem_y_points[1] - (bar_index * constants.graphics.note_flag_gap)}\",\n\t\t\t\t\t\t\tf\"{dx + constants.graphics.note_head_width} + ({not_drawn_rests_this_beat} * \"\n\t\t\t\t\t\t\t\tf\"self.none_music_note_width)\",\n\t\t\t\t\t\t\tf\"{note_stem_y_points[1] - (bar_index * constants.graphics.note_flag_gap)}\"],\n\t\t\t\t\t\t width=constants.graphics.note_stem_width)\n\n\n\t\telif last_note_duration < note_duration:  # Use d2, Flags d1\n\t\t\tself.log_dump(\"Using bars of note_duration and flags from last_note_duration because last_note_duration < \"\n\t\t\t\t\t\t  \"note_duration\")\n\n\t\t\tbar_amount = note_duration_to_bar_or_flag_amount(note_duration)\n\t\t\tflag_amount = note_duration_to_bar_or_flag_amount(last_note_duration) - bar_amount\n\n\t\t\tfor bar_index in range(bar_amount):\n\t\t\t\tMathLine(self, [\"none_music_note_width\"],\n\t\t\t\t\t\t [f\"{last_dx + constants.graphics.note_head_width} + ({last_not_drawn_rests_this_beat} * \"\n\t\t\t\t\t\t\t\tf\"self.none_music_note_width)\",\n\t\t\t\t\t\t\tf\"{last_note_stem_y_points[1] - (bar_index * constants.graphics.note_flag_gap)}\",\n\t\t\t\t\t\t\tf\"{dx + constants.graphics.note_head_width} + ({not_drawn_rests_this_beat} * \"\n\t\t\t\t\t\t\t\tf\"self.none_music_note_width)\",\n\t\t\t\t\t\t\tf\"{note_stem_y_points[1] - (bar_index * constants.graphics.note_flag_gap)}\"],\n\t\t\t\t\t\t width=constants.graphics.note_stem_width\n\t\t\t\t\t\t )\n\n\t\t\tfor flag_index in range(flag_amount):\n\t\t\t\tMathLine(self, [\"none_music_note_width\"],\n\t\t\t\t\t\t [f\"{last_dx + constants.graphics.note_head_width} + ({not_drawn_rests_this_beat} * \"\n\t\t\t\t\t\t\t\tf\"self.none_music_note_width)\",\n\t\t\t\t\t\t\tf\"\"\"{last_note_stem_y_points[1] - (flag_index * constants.graphics.note_flag_gap) - \n\t\t\t\t\t\t\t\t constants.graphics.note_flag_gap}\"\"\",\n\t\t\t\t\t\t\tf\"\"\"({dx + constants.graphics.note_head_width - ((dx - last_dx) / 2)} + \n\t\t\t\t\t\t\t\t({not_drawn_rests_this_beat} * self.none_music_note_width))\"\"\",\n\t\t\t\t\t\t\tf\"\"\"{note_stem_y_points[1] - (flag_index * constants.graphics.note_flag_gap) -\n\t\t\t\t\t\t\t\t ((note_stem_y_points[1] - last_note_stem_y_points[1]) / 2) -\n\t\t\t\t\t\t\t\t constants.graphics.note_flag_gap}\"\"\"],\n\t\t\t\t\t\t width=constants.graphics.note_stem_width)\n\n\n\t\telif last_note_duration > note_duration:  # Use d1, Flags d2\n\t\t\tself.log_dump(\"Using bars of last_note_duration and flags from note_duration because last_note_duration > \"\n\t\t\t\t\t\t  \"note_duration\")\n\n\t\t\tbar_amount = note_duration_to_bar_or_flag_amount(last_note_duration)\n\t\t\tflag_amount = note_duration_to_bar_or_flag_amount(note_duration) - bar_amount\n\n\t\t\tfor bar_index in range(bar_amount):\n\t\t\t\tMathLine(self, [\"none_music_note_width\"],\n\t\t\t\t\t\t [f\"{last_dx + constants.graphics.note_head_width} + ({last_not_drawn_rests_this_beat} * \"\n\t\t\t\t\t\t\t\tf\"self.none_music_note_width)\",\n\t\t\t\t\t\t\tf\"{last_note_stem_y_points[1] - (bar_index * constants.graphics.note_flag_gap)}\",\n\t\t\t\t\t\t\tf\"{dx + constants.graphics.note_head_width} + ({not_drawn_rests_this_beat} * \"\n\t\t\t\t\t\t\t\tf\"self.none_music_note_width)\",\n\t\t\t\t\t\t\tf\"{note_stem_y_points[1] - (bar_index * constants.graphics.note_flag_gap)}\"],\n\t\t\t\t\t\t width=constants.graphics.note_stem_width)\n\n\n\t\t\tfor flag_index in range(flag_amount):\n\t\t\t\tMathLine(self, [\"none_music_note_width\"],\n\t\t\t\t\t\t [f\"\"\"{last_dx + constants.graphics.note_head_width +\n\t\t\t\t\t\t\t   ((dx - last_dx) / 2)} + ({not_drawn_rests_this_beat} * \n\t\t\t\t\t\t\t\tself.none_music_note_width)\"\"\",\n\t\t\t\t\t\t\tf\"\"\"{last_note_stem_y_points[1] - (flag_index * constants.graphics.note_flag_gap) -\n\t\t\t\t\t\t\t\t ((last_note_stem_y_points[1] - note_stem_y_points[1]) / 2) -\n\t\t\t\t\t\t\t\t constants.graphics.note_flag_gap}\"\"\",\n\t\t\t\t\t\t\tf\"{dx + constants.graphics.note_head_width} + ({not_drawn_rests_this_beat} * \"\n\t\t\t\t\t\t\t\tf\"self.none_music_note_width)\",\n\t\t\t\t\t\t\tf\"\"\"{note_stem_y_points[1] - (flag_index * constants.graphics.note_flag_gap) -\n\t\t\t\t\t\t\t\t constants.graphics.note_flag_gap}\"\"\"],\n\t\t\t\t\t\t width=constants.graphics.note_stem_width)\n\n\n\n\n\t@push_name_to_logger_name_stack_custom(\"flags\")\n\tdef draw_note_flags(self, note_stem_y_points, note_duration, dx, not_drawn_rests_this_beat):\n\t\tself.log_dump(f\"Drawing flags on note with {note_duration} duration and is at ({dx}, {note_stem_y_points})\")\n\n\t\tif note_duration == Fraction(3, 4):\n\t\t\tself.log_dump(f\"Note has a duration of {note_duration} so gets a dot\")\n\n\t\t\tMathEllipse(self, [\"none_music_note_width\"],\n\t\t\t\t\t\t(f\"{dx + constants.graphics.note_dot_dpos[0]} + ({not_drawn_rests_this_beat} * \"\n\t\t\t\t\t\t   f\"self.none_music_note_width)\",\n\t\t\t\t\t\t   f\"{note_stem_y_points[0] + constants.graphics.note_dot_dpos[1]}\"),\n\t\t\t\t\t\tsize=constants.graphics.note_dot_size)\n\n\t\t\tnote_duration = Fraction(2, 4)\n\n\t\tflag_amount = note_duration_to_bar_or_flag_amount(note_duration)\n\t\tfor flag_index in range(flag_amount):\n\t\t\tMathLine(self, [\"none_music_note_width\"],\n\t\t\t\t\t [f\"{dx + constants.graphics.note_head_width} + ({not_drawn_rests_this_beat} * \"\n\t\t\t\t\t\t\t\tf\"self.none_music_note_width)\",\n\t\t\t\t\t\tf\"{note_stem_y_points[1] - (flag_index * constants.graphics.note_flag_gap)}\",\n\t\t\t\t\t\tf\"\"\"{dx + constants.graphics.note_head_width + constants.graphics.note_flag_dpos[0]} + \\\n\t\t\t\t\t\t\t({not_drawn_rests_this_beat} * self.none_music_note_width)\"\"\",\n\t\t\t\t\t\tf\"\"\"{note_stem_y_points[1] - (flag_index * constants.graphics.note_flag_gap) + \n\t\t\t\t\t\t\t constants.graphics.note_flag_dpos[1]}\"\"\"],\n\t\t\t\t\t width=constants.graphics.note_stem_width)\n\n\n\n\n\t@push_name_to_logger_name_stack_custom(\"rests\")\n\tdef draw_compressed_rests(self, beat_notes, dx, not_drawn_rests_this_beat):\n\t\tsub_beats_to_skip = 0\n\t\t_sub_beats_to_skip = 0\n\t\thad_not_rest = False\n\t\tdid_draw_rest = False\n\n\t\tfor note_index, notes in enumerate(beat_notes):\n\t\t\tif _sub_beats_to_skip > 0:\n\t\t\t\t_sub_beats_to_skip -= 1\n\n\n\t\t\telif not had_not_rest:\n\t\t\t\tif not notes:\n\n\t\t\t\t\tif note_index < 1 and all([beat_notes[note_index + n] == []\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t for n in range(1, 4)]):\n\t\t\t\t\t\tself.log_dump(f\"All sub beats are rests, drawing \"\n\t\t\t\t\t\t\t\t\t  f\"{constants.score.duration_to_text_duration[self.notes_per_beat / 4]}_rest\")\n\t\t\t\t\t\tsub_beats_to_skip += 3\n\t\t\t\t\t\t_sub_beats_to_skip += 3\n\t\t\t\t\t\tdraw_note(self, f\"{constants.score.duration_to_text_duration[self.notes_per_beat / 4]}_rest\",\n\t\t\t\t\t\t\t\t  dx, not_drawn_rests_this_beat)\n\n\t\t\t\t\telif note_index < len(beat_notes) - 1 and beat_notes[note_index + 1] == []:\n\t\t\t\t\t\tself.log_dump(f\"2 sub beats are rests, drawing \"\n\t\t\t\t\t\t\t\t\t  f\"{constants.score.duration_to_text_duration[self.notes_per_beat / 2]}_rest\")\n\t\t\t\t\t\tsub_beats_to_skip += 1\n\t\t\t\t\t\t_sub_beats_to_skip += 1\n\t\t\t\t\t\tdraw_note(self, f\"{constants.score.duration_to_text_duration[self.notes_per_beat / 2]}_rest\",\n\t\t\t\t\t\t\t\t  dx, not_drawn_rests_this_beat)\n\n\t\t\t\t\telse:\n\t\t\t\t\t\tself.log_dump(f\"1 sub beat is a rests, drawing \"\n\t\t\t\t\t\t\t\t\t  f\"{constants.score.duration_to_text_duration[self.notes_per_beat / 1]}_rest\")\n\n\t\t\t\t\t\tdraw_note(self, f\"{constants.score.duration_to_text_duration[self.notes_per_beat]}_rest\", dx,\n\t\t\t\t\t\t\t\t  not_drawn_rests_this_beat)\n\n\t\t\t\t\tdx += constants.graphics.note_width\n\t\t\t\t\tdid_draw_rest = True\n\n\t\t\t\telse:\n\t\t\t\t\thad_not_rest = True\n\n\t\tself.log_dump(f\"{sub_beats_to_skip} sub beats need to be skipped\")\n\n\t\treturn sub_beats_to_skip, dx, did_draw_rest\n\n\n\t@reset_logger_name_stack_for_function\n\t@push_name_to_logger_name_stack\n\tdef get_stem_y_points(self, notes) -> list[tuple[float, float]]:\n\t\tmusic_notes = [_notes for _notes in notes if _notes != []]\n\t\tself.log_dump(f\"There are {len(music_notes)} notes, looking for special rule\")\n\n\t\t# Zero Notes -------------\n\t\tif len(music_notes) == 0:\n\t\t\tself.log_dump(\"No music notes written / only rests, so no need for Bars or Flags\")\n\t\t\treturn []\n\n\t\t# One Note ---------------\n\t\telif len(music_notes) == 1:\n\t\t\tself.log_dump(f\"Special rule for 1 found\")\n\t\t\tret = [(float(min([constants.score.note_name_to_staff_level[note_name] for note_name in music_notes[0]]) *\n\t\t\t\t\tconstants.graphics.staff_gap + (constants.graphics.staff_gap / 2)),\n\n\t\t\t\t\tfloat(max([constants.score.note_name_to_staff_level[note_name] for note_name in music_notes[0]]) *\n\t\t\t\t\tconstants.graphics.staff_gap + (constants.graphics.staff_gap / 2) +\n\t\t\t\t\tconstants.graphics.note_stem_height)\n\t\t\t\t\t)]\n\t\t\tself.log_dump(f\"Got {ret}\")\n\n\t\t\treturn ret\n\n\t\t# Two Notes --------------\n\t\telif len(music_notes) == 2:\n\t\t\tself.log_dump(f\"Special rule for 2 found\")\n\t\t\tret = [(float(min([constants.score.note_name_to_staff_level[note_name] for note_name in _notes]) *\n\t\t\t\t\tconstants.graphics.staff_gap + (constants.graphics.staff_gap / 2)),\n\n\t\t\t\t\tfloat(max([constants.score.note_name_to_staff_level[note_name] for note_name in _notes]) *\n\t\t\t\t\tconstants.graphics.staff_gap + (constants.graphics.staff_gap / 2) +\n\t\t\t\t\tconstants.graphics.note_stem_height)\n\t\t\t\t\t) for _notes in music_notes]\n\t\t\tself.log_dump(f\"Got {ret}\")\n\n\t\t\treturn ret\n\n\n\t\t# More ----------------------\n\t\telse:\n\t\t\tself.log_dump(f\"No special rule found\")\n\t\t\tret = [(float(min([constants.score.note_name_to_staff_level[note_name] for note_name in _notes]) *\n\t\t\t\t\t\t  constants.graphics.staff_gap + (constants.graphics.staff_gap / 2)),\n\n\t\t\t\t\tfloat(max([constants.score.note_name_to_staff_level[note_name] for note_name in _notes]) *\n\t\t\t\t\t\t  constants.graphics.staff_gap + (constants.graphics.staff_gap / 2) +\n\t\t\t\t\t\t  constants.graphics.note_stem_height)\n\t\t\t\t\t) for _notes in music_notes]\n\n\t\t\thighest_y_up = 0\n\t\t\tfor y_down, y_up in ret:\n\t\t\t\tif y_up > highest_y_up:\n\t\t\t\t\thighest_y_up = y_up\n\n\t\t\tret = [(y_down, highest_y_up) for y_down, y_up in ret]\n\n\t\t\tself.log_dump(f\"Got {ret}\")\n\n\t\t\treturn ret\n\n", "description": "\n\tUsed by :class:`Section` for expanding the bar when the mouse is over it\n\t", "category": "graphics", "imports": ["from fractions import Fraction", "from math import log", "from typing import Optional", "from kivy.animation import Animation, AnimationTransition", "from kivy.atlas import Atlas", "from kivy.clock import Clock", "from kivy.core.window import Window", "from kivy.graphics import Canvas, Color", "from kivy.input import MotionEvent", "from kivy.properties import NumericProperty, OptionProperty, ListProperty, ReferenceListProperty, StringProperty", "from kivy.uix.relativelayout import RelativeLayout", "import constants", "from app.globalBindings import GlobalBindings", "from app.mathVertexInstructions import MathLine, MathEllipse, MathRectangle", "from app.misc import check_mode", "from app.popups.addSectionPopup import AddSectionPopup", "from app.uix.scoreContent.scoreContentWithPopup import ScoreContentWithPopup", "from logger import push_name_to_logger_name_stack, ClassWithLogger, reset_logger_name_stack_for_function, \\"]}, {"term": "def", "name": "draw_note", "data": "def draw_note(instance, note_name, x, not_drawn_rests_this_beat):\n\tnote_shape = note_name\n\n\tif note_name in [\"kick\", \"snare\", \"floor_tom\", \"middle_tom\", \"high_tom\"]:\n\t\tnote_shape = \"circle\"\n\n\n\tif note_shape in rest_textures.keys():\n\t\tMathRectangle(instance, [\"none_music_note_width\"],\n\t\t\t\t\t  [f\"{x} + ({not_drawn_rests_this_beat} * self.none_music_note_width)\",\n\t\t\t\t\t\t f\"0\"],\n\t\t\t\t\t  size=(constants.graphics.note_width, constants.graphics.staff_height),\n\t\t\t\t\t  texture=rest_textures[note_shape])\n\t\treturn x, 0\n\n\n\telif note_shape in note_head_textures.keys():\n\t\tMathRectangle(instance, [\"none_music_note_width\"],\n\t\t\t\t\t  [f\"{x} + ({not_drawn_rests_this_beat} * self.none_music_note_width)\",\n\t\t\t\t\t\t f\"{constants.score.note_name_to_staff_level[note_name] * constants.graphics.staff_gap}\"],\n\t\t\t\t\t  size=(constants.graphics.note_head_width, constants.graphics.staff_gap),\n\t\t\t\t\t  texture=note_head_textures[note_shape])\n\t\treturn x, constants.score.note_name_to_staff_level[note_name] * constants.graphics.staff_gap\n\n\n\n\n", "description": null, "category": "graphics", "imports": ["from fractions import Fraction", "from math import log", "from typing import Optional", "from kivy.animation import Animation, AnimationTransition", "from kivy.atlas import Atlas", "from kivy.clock import Clock", "from kivy.core.window import Window", "from kivy.graphics import Canvas, Color", "from kivy.input import MotionEvent", "from kivy.properties import NumericProperty, OptionProperty, ListProperty, ReferenceListProperty, StringProperty", "from kivy.uix.relativelayout import RelativeLayout", "import constants", "from app.globalBindings import GlobalBindings", "from app.mathVertexInstructions import MathLine, MathEllipse, MathRectangle", "from app.misc import check_mode", "from app.popups.addSectionPopup import AddSectionPopup", "from app.uix.scoreContent.scoreContentWithPopup import ScoreContentWithPopup", "from logger import push_name_to_logger_name_stack, ClassWithLogger, reset_logger_name_stack_for_function, \\"]}, {"term": "def", "name": "note_duration_to_bar_or_flag_amount", "data": "def note_duration_to_bar_or_flag_amount(fraction: Fraction):  # denominator = 2^n\n\tdenominator = fraction.denominator\n\n\t# 2^n = denominator\n\t# log(2^n) = log(denominator)\n\t# n* (log(2)) = log(denominator)\n\t# n = log(denominator) / log(2)\t<------ is what we need to do\n\n\n\n\t# if denominator = 8\n\n\t# 2^n = 8\n\t# log(2^n) = log(8)\n\t# n* (log(2)) = log(8)\n\t# n = log(8) / log(2)\n\t# n = 3\n\n\tn = log(denominator) / log(2)\n\n\t# if n is 1.0 or 2.0 then int(n) == 1 or 2 which still == n, but if it is 1.5 then it doesnt == int(n) which is 2\n\tassert n == int(n), f\"note_duration_to_bar_or_flag_amount has too \" \\\n\t\t\t\t\t\tf\"take a fraction that has a denominator that is 1, 2, 4, 8...  not {fraction.denominator}\"\n\treturn int(n)\n\n", "description": null, "category": "graphics", "imports": ["from fractions import Fraction", "from math import log", "from typing import Optional", "from kivy.animation import Animation, AnimationTransition", "from kivy.atlas import Atlas", "from kivy.clock import Clock", "from kivy.core.window import Window", "from kivy.graphics import Canvas, Color", "from kivy.input import MotionEvent", "from kivy.properties import NumericProperty, OptionProperty, ListProperty, ReferenceListProperty, StringProperty", "from kivy.uix.relativelayout import RelativeLayout", "import constants", "from app.globalBindings import GlobalBindings", "from app.mathVertexInstructions import MathLine, MathEllipse, MathRectangle", "from app.misc import check_mode", "from app.popups.addSectionPopup import AddSectionPopup", "from app.uix.scoreContent.scoreContentWithPopup import ScoreContentWithPopup", "from logger import push_name_to_logger_name_stack, ClassWithLogger, reset_logger_name_stack_for_function, \\"]}, {"term": "def", "name": "get_note_duration", "data": "def get_note_duration(notes, note_index, notes_per_beat):\n\tnotes_after_note_index = notes[note_index + 1:len(notes)]\n\n\ti = 1\n\tfor note in notes_after_note_index:\n\t\tif note:\n\t\t\tbreak\n\n\t\ti += 1\n\n\treturn Fraction(i, notes_per_beat)\n\n", "description": null, "category": "graphics", "imports": ["from fractions import Fraction", "from math import log", "from typing import Optional", "from kivy.animation import Animation, AnimationTransition", "from kivy.atlas import Atlas", "from kivy.clock import Clock", "from kivy.core.window import Window", "from kivy.graphics import Canvas, Color", "from kivy.input import MotionEvent", "from kivy.properties import NumericProperty, OptionProperty, ListProperty, ReferenceListProperty, StringProperty", "from kivy.uix.relativelayout import RelativeLayout", "import constants", "from app.globalBindings import GlobalBindings", "from app.mathVertexInstructions import MathLine, MathEllipse, MathRectangle", "from app.misc import check_mode", "from app.popups.addSectionPopup import AddSectionPopup", "from app.uix.scoreContent.scoreContentWithPopup import ScoreContentWithPopup", "from logger import push_name_to_logger_name_stack, ClassWithLogger, reset_logger_name_stack_for_function, \\"]}, {"term": "def", "name": "parse_notes_too_list", "data": "def parse_notes_too_list(string: str) -> list[list[str]]:\n\treturn [[note for note in notes.split(\",\")] for notes in string.split(\" \")]\n", "description": null, "category": "graphics", "imports": ["from fractions import Fraction", "from math import log", "from typing import Optional", "from kivy.animation import Animation, AnimationTransition", "from kivy.atlas import Atlas", "from kivy.clock import Clock", "from kivy.core.window import Window", "from kivy.graphics import Canvas, Color", "from kivy.input import MotionEvent", "from kivy.properties import NumericProperty, OptionProperty, ListProperty, ReferenceListProperty, StringProperty", "from kivy.uix.relativelayout import RelativeLayout", "import constants", "from app.globalBindings import GlobalBindings", "from app.mathVertexInstructions import MathLine, MathEllipse, MathRectangle", "from app.misc import check_mode", "from app.popups.addSectionPopup import AddSectionPopup", "from app.uix.scoreContent.scoreContentWithPopup import ScoreContentWithPopup", "from logger import push_name_to_logger_name_stack, ClassWithLogger, reset_logger_name_stack_for_function, \\"]}], [], [], [], [{"term": "class", "name": "TestVmOperations", "data": "class TestVmOperations(XMLTestCase):\n\t# just numbers, no particular meaning\n\tUPDATE_OFFSETS = [-3200, 3502, -2700, 3601]\n\tBASE_OFFSET = 42\n\n\tVNC_DEVICE = {'type': 'graphics', 'device': 'vnc', 'port': '-1'}\n\tSPICE_DEVICE = {'type': 'graphics', 'device': 'spice', 'port': '-1'}\n\n\tGRAPHIC_DEVICES = [\n\t\tSPICE_DEVICE,\n\t\tVNC_DEVICE,\n\t]\n\n\t@MonkeyPatch(libvirtconnection, 'get', lambda x: fake.Connection())\n\t@permutations([[define.NORMAL], [define.ERROR]])\n\tdef testTimeOffsetNotPresentByDefault(self, exitCode):\n\t\twith fake.VM() as testvm:\n\t\t\ttestvm.setDownStatus(exitCode, vmexitreason.GENERIC_ERROR)\n\t\t\tassert not ('timeOffset' in testvm.getStats())\n\n\t@MonkeyPatch(libvirtconnection, 'get', lambda x: fake.Connection())\n\t@permutations([[define.NORMAL], [define.ERROR]])\n\tdef testTimeOffsetRoundtrip(self, exitCode):\n\t\twith fake.VM({'timeOffset': self.BASE_OFFSET}) as testvm:\n\t\t\ttestvm.setDownStatus(exitCode, vmexitreason.GENERIC_ERROR)\n\t\t\tassert testvm.getStats()['timeOffset'] == self.BASE_OFFSET\n\n\t@MonkeyPatch(libvirtconnection, 'get', lambda x: fake.Connection())\n\t@permutations([[define.NORMAL], [define.ERROR]])\n\tdef testTimeOffsetRoundtriupAcrossInstances(self, exitCode):\n\t\t# bz956741\n\t\tlastOffset = 0\n\t\tfor offset in self.UPDATE_OFFSETS:\n\t\t\twith fake.VM({'timeOffset': lastOffset}) as testvm:\n\t\t\t\ttestvm.onRTCUpdate(offset)\n\t\t\t\ttestvm.setDownStatus(exitCode, vmexitreason.GENERIC_ERROR)\n\t\t\t\tvmOffset = testvm.getStats()['timeOffset']\n\t\t\t\tassert vmOffset == str(lastOffset + offset)\n\t\t\t\t# the field in getStats is str, not int\n\t\t\t\tlastOffset = int(vmOffset)\n\n\t@MonkeyPatch(libvirtconnection, 'get', lambda x: fake.Connection())\n\t@permutations([[define.NORMAL], [define.ERROR]])\n\tdef testTimeOffsetUpdateIfAbsent(self, exitCode):\n\t\t# bz956741 (-like, simpler case)\n\t\twith fake.VM() as testvm:\n\t\t\tfor offset in self.UPDATE_OFFSETS:\n\t\t\t\ttestvm.onRTCUpdate(offset)\n\t\t\t# beware of type change!\n\t\t\ttestvm.setDownStatus(exitCode, vmexitreason.GENERIC_ERROR)\n\t\t\tassert testvm.getStats()['timeOffset'] == \\\n\t\t\t\tstr(self.UPDATE_OFFSETS[-1])\n\n\t@MonkeyPatch(libvirtconnection, 'get', lambda x: fake.Connection())\n\t@permutations([[define.NORMAL], [define.ERROR]])\n\tdef testTimeOffsetUpdateIfPresent(self, exitCode):\n\t\twith fake.VM({'timeOffset': self.BASE_OFFSET}) as testvm:\n\t\t\tfor offset in self.UPDATE_OFFSETS:\n\t\t\t\ttestvm.onRTCUpdate(offset)\n\t\t\t# beware of type change!\n\t\t\ttestvm.setDownStatus(exitCode, vmexitreason.GENERIC_ERROR)\n\t\t\tassert testvm.getStats()['timeOffset'] == \\\n\t\t\t\tstr(self.BASE_OFFSET + self.UPDATE_OFFSETS[-1])\n\n\tdef testUpdateSingleDeviceGraphics(self):\n\t\tdevXmls = (\n\t\t\t'',\n\t\t\t'')\n\t\tfor device, devXml in zip(self.GRAPHIC_DEVICES, devXmls):\n\t\t\tgraphics_xml = (''.\n\t\t\t\t\t\t\tformat(**device))\n\t\t\tdomXml = '''\n\t\t\t\t\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestUpdateSingleDeviceGraphicsNoConnected", "data": "\tdef testUpdateSingleDeviceGraphicsNoConnected(self):\n\t\tgraphics_params = dict(_GRAPHICS_DEVICE_PARAMS)\n\t\tdel graphics_params['existingConnAction']\n\t\tdevXmls = (\n\t\t\t'',\n\t\t\t'')\n\t\tfor device, devXml in zip(self.GRAPHIC_DEVICES, devXmls):\n\t\t\tgraphics_xml = (''.\n\t\t\t\t\t\t\tformat(**device))\n\t\t\tdomXml = '''\n\t\t\t\t\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestUpdateMultipleDeviceGraphics", "data": "\tdef testUpdateMultipleDeviceGraphics(self):\n\t\tdevXmls = (\n\t\t\t'',\n\t\t\t'')\n\t\tdomXml = '''\n\t\t\t\n\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "f_updateGraphicsDevice", "data": "\tdef _updateGraphicsDevice(self, testvm, device_type, graphics_params):\n\t\tdef _check_ticket_params(domXML, conf, params):\n\t\t\tassert params == _TICKET_PARAMS\n\n\t\tdef _fake_set_vnc_pwd(username, pwd):\n\t\t\tpass\n\n\t\twith MonkeyPatchScope([(hooks, 'before_vm_set_ticket',\n\t\t\t\t\t\t\t\t_check_ticket_params),\n\t\t\t\t\t\t\t   (saslpasswd2, 'set_vnc_password',\n\t\t\t\t\t\t\t\t_fake_set_vnc_pwd)]):\n\t\t\tparams = {'graphicsType': device_type}\n\t\t\tparams.update(graphics_params)\n\t\t\treturn testvm.updateDevice(params)\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "f_verifyDeviceUpdate", "data": "\tdef _verifyDeviceUpdate(self, device, allDevices, domXml, devXml,\n\t\t\t\t\t\t\tgraphics_params):\n\t\twith fake.VM(xmldevices=allDevices) as testvm:\n\t\t\ttestvm._dom = fake.Domain(domXml)\n\n\t\t\tself._updateGraphicsDevice(testvm, device['device'],\n\t\t\t\t\t\t\t\t\t   graphics_params)\n\n\t\t\tself.assertXMLEqual(testvm._dom.devXml, devXml)\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestSetSaslPasswordInFips", "data": "\tdef testSetSaslPasswordInFips(self):\n\t\tgraphics_params = dict(_GRAPHICS_DEVICE_PARAMS)\n\t\tdel graphics_params['existingConnAction']\n\t\tdevice = self.GRAPHIC_DEVICES[1]  # VNC\n\t\tgraphics_xml = ('' %\n\t\t\t\t\t\t(device['device'],))\n\t\tdevice_xml = '%s' % (graphics_xml,)\n\n\t\twith fake.VM(xmldevices=graphics_xml) as testvm:\n\t\t\tdef _fake_set_vnc_pwd(username, pwd):\n\t\t\t\ttestvm.pwd = pwd\n\t\t\t\ttestvm.username = username\n\n\t\t\ttestvm._dom = fake.Domain(device_xml)\n\t\t\ttestvm.pwd = \"invalid\"\n\t\t\tparams = {'graphicsType': device['device']}\n\t\t\tparams.update(graphics_params)\n\t\t\tparams['params']['fips'] = 'true'\n\t\t\tparams['params']['vncUsername'] = 'vnc-123-456'\n\n\t\t\twith MonkeyPatchScope([(saslpasswd2, 'set_vnc_password',\n\t\t\t\t\t\t\t\t\t_fake_set_vnc_pwd)]):\n\t\t\t\ttestvm.updateDevice(params)\n\n\t\t\tassert password.unprotect(params['password']) == \\\n\t\t\t\ttestvm.pwd\n\t\t\tassert params['params']['vncUsername'] == testvm.username\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestClearSaslPasswordNoFips", "data": "\tdef testClearSaslPasswordNoFips(self):\n\t\tgraphics_params = dict(_GRAPHICS_DEVICE_PARAMS)\n\t\tdel graphics_params['existingConnAction']\n\t\tdevice = self.GRAPHIC_DEVICES[1]  # VNC\n\t\tgraphics_xml = ('' %\n\t\t\t\t\t\t(device['device'],))\n\t\tdevice_xml = '%s' % (graphics_xml,)\n\n\t\twith fake.VM(xmldevices=graphics_xml) as testvm:\n\t\t\tdef _fake_remove_pwd(username):\n\t\t\t\ttestvm.username = username\n\n\t\t\ttestvm._dom = fake.Domain(device_xml)\n\t\t\tparams = {'graphicsType': device['device']}\n\t\t\tparams.update(graphics_params)\n\t\t\tparams['params']['vncUsername'] = 'vnc-123-456'\n\n\t\t\twith MonkeyPatchScope([(saslpasswd2, 'remove_vnc_password',\n\t\t\t\t\t\t\t\t\t_fake_remove_pwd)]):\n\t\t\t\ttestvm.updateDevice(params)\n\n\t\t\tassert params['params']['vncUsername'] == testvm.username\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestDomainNotRunningWithoutDomain", "data": "\tdef testDomainNotRunningWithoutDomain(self):\n\t\twith fake.VM() as testvm:\n\t\t\tassert not testvm.isDomainRunning()\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestDomainNotRunningByState", "data": "\tdef testDomainNotRunningByState(self):\n\t\twith fake.VM() as testvm:\n\t\t\ttestvm._dom = fake.Domain(domState=libvirt.VIR_DOMAIN_SHUTDOWN)\n\t\t\tassert not testvm.isDomainRunning()\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestDomainIsRunning", "data": "\tdef testDomainIsRunning(self):\n\t\twith fake.VM() as testvm:\n\t\t\ttestvm._dom = fake.Domain(domState=libvirt.VIR_DOMAIN_RUNNING)\n\t\t\tassert testvm.isDomainRunning()\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestDomainIsReadyForCommands", "data": "\tdef testDomainIsReadyForCommands(self):\n\t\twith fake.VM() as testvm:\n\t\t\ttestvm._dom = fake.Domain()\n\t\t\tassert testvm.isDomainReadyForCommands()\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestIgnoreKnownErrors", "data": "\tdef testIgnoreKnownErrors(self, code, text):\n\t\tdef _fail(*args):\n\t\t\traise_libvirt_error(code, text)\n\n\t\twith fake.VM() as testvm:\n\t\t\tdom = fake.Domain()\n\t\t\tdom.controlInfo = _fail\n\t\t\ttestvm._dom = dom\n\t\t\tassert not testvm.isDomainReadyForCommands()\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestDomainNoneNotReadyForCommands", "data": "\tdef testDomainNoneNotReadyForCommands(self):\n\t\twith fake.VM() as testvm:\n\t\t\tassert not testvm.isDomainReadyForCommands()\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestReadyForCommandsRaisesLibvirtError", "data": "\tdef testReadyForCommandsRaisesLibvirtError(self):\n\t\tdef _fail(*args):\n\t\t\t# anything != NO_DOMAIN is good\n\t\t\traise_libvirt_error(libvirt.VIR_ERR_INTERNAL_ERROR,\n\t\t\t\t\t\t\t\t\"Fake internal error\")\n\n\t\twith fake.VM() as testvm:\n\t\t\tdom = fake.Domain()\n\t\t\tdom.controlInfo = _fail\n\t\t\ttestvm._dom = dom\n\t\t\twith pytest.raises(libvirt.libvirtError):\n\t\t\t\ttestvm.isDomainReadyForCommands()\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestReadPauseCodeDomainRunning", "data": "\tdef testReadPauseCodeDomainRunning(self):\n\t\twith fake.VM() as testvm:\n\t\t\ttestvm._dom = fake.Domain(domState=libvirt.VIR_DOMAIN_RUNNING)\n\t\t\tassert testvm._readPauseCode() == 'NOERR'\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestReadPauseCodeDomainPausedCrash", "data": "\tdef testReadPauseCodeDomainPausedCrash(self):\n\t\twith fake.VM() as testvm:\n\t\t\t# if paused for different reason we must not extend the disk\n\t\t\t# so anything else is ok\n\t\t\tdom = fake.Domain(domState=libvirt.VIR_DOMAIN_PAUSED,\n\t\t\t\t\t\t\t  domReason=libvirt.VIR_DOMAIN_PAUSED_CRASHED)\n\t\t\ttestvm._dom = dom\n\t\t\tassert testvm._readPauseCode() != 'ENOSPC'\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestReadPauseCodeDomainPausedENOSPC", "data": "\tdef testReadPauseCodeDomainPausedENOSPC(self):\n\t\twith fake.VM() as testvm:\n\t\t\tdom = fake.Domain(domState=libvirt.VIR_DOMAIN_PAUSED,\n\t\t\t\t\t\t\t  domReason=libvirt.VIR_DOMAIN_PAUSED_IOERROR)\n\t\t\tdom.setDiskErrors({'vda': libvirt.VIR_DOMAIN_DISK_ERROR_NO_SPACE,\n\t\t\t\t\t\t\t   'hdc': libvirt.VIR_DOMAIN_DISK_ERROR_NONE})\n\t\t\ttestvm._dom = dom\n\t\t\tassert testvm._readPauseCode() == 'ENOSPC'\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestReadPauseCodeDomainPausedEIO", "data": "\tdef testReadPauseCodeDomainPausedEIO(self):\n\t\twith fake.VM() as testvm:\n\t\t\tdom = fake.Domain(domState=libvirt.VIR_DOMAIN_PAUSED,\n\t\t\t\t\t\t\t  domReason=libvirt.VIR_DOMAIN_PAUSED_IOERROR)\n\t\t\tdom.setDiskErrors({'vda': libvirt.VIR_DOMAIN_DISK_ERROR_NONE,\n\t\t\t\t\t\t\t   'hdc': libvirt.VIR_DOMAIN_DISK_ERROR_UNSPEC})\n\t\t\ttestvm._dom = dom\n\t\t\tassert testvm._readPauseCode() == 'EIO'\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestSetCpuTuneQuote", "data": "\tdef testSetCpuTuneQuote(self, quota, offset):\n\t\twith fake.VM() as testvm:\n\t\t\t# we need a different behaviour with respect to\n\t\t\t# plain fake.Domain. Seems simpler to just add\n\t\t\t# a new special-purpose trivial fake here.\n\t\t\ttestvm._dom = ChangingSchedulerDomain(offset)\n\t\t\ttestvm.setCpuTuneQuota(quota)\n\t\t\tassert quota + offset == testvm._vcpuTuneInfo['vcpu_quota']\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestSetCpuTunePeriod", "data": "\tdef testSetCpuTunePeriod(self, period, offset):\n\t\twith fake.VM() as testvm:\n\t\t\t# same as per testSetCpuTuneQuota\n\t\t\ttestvm._dom = ChangingSchedulerDomain(offset)\n\t\t\ttestvm.setCpuTunePeriod(period)\n\t\t\tassert period + offset == testvm._vcpuTuneInfo['vcpu_period']\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestSetNumberOfVcpusFailed", "data": "\tdef testSetNumberOfVcpusFailed(self, virt_error, vdsm_error,\n\t\t\t\t\t\t\t\t   error_message):\n\t\tdef _fail(*args):\n\t\t\traise_libvirt_error(virt_error, error_message)\n\n\t\twith MonkeyPatchScope([(hooks, 'before_set_num_of_cpus',\n\t\t\t\t\t\t\t\tlambda: None)]):\n\t\t\twith fake.VM() as testvm:\n\t\t\t\tdom = fake.Domain()\n\t\t\t\tdom.setVcpusFlags = _fail\n\t\t\t\ttestvm._dom = dom\n\n\t\t\t\tres = testvm.setNumberOfCpus(4)  # random value\n\n\t\t\t\tassert res == response.error(vdsm_error)\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestUpdateDeviceGraphicsFailed", "data": "\tdef testUpdateDeviceGraphicsFailed(self):\n\t\twith fake.VM(devices=self.GRAPHIC_DEVICES) as testvm:\n\t\t\tmessage = 'fake timeout while setting ticket'\n\t\t\tdevice = 'spice'\n\t\t\tdomXml = '''\n\t\t\t\t\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "def_fail", "data": "\t\t\tdef _fail(*args):\n\t\t\t\traise virdomain.TimeoutError(defmsg=message)\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestAcpiShutdownDisconnected", "data": "\tdef testAcpiShutdownDisconnected(self):\n\t\twith fake.VM() as testvm:\n\t\t\ttestvm._dom = virdomain.Disconnected(vmid='testvm')\n\t\t\tassert response.is_error(testvm.acpiShutdown())\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestAcpiShutdownConnected", "data": "\tdef testAcpiShutdownConnected(self):\n\t\twith fake.VM() as testvm:\n\t\t\ttestvm._dom = fake.Domain(vmId='testvm')\n\t\t\tassert not response.is_error(testvm.acpiShutdown())\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestAcpiRebootDisconnected", "data": "\tdef testAcpiRebootDisconnected(self):\n\t\twith fake.VM() as testvm:\n\t\t\ttestvm._dom = virdomain.Disconnected(vmid='testvm')\n\t\t\tassert response.is_error(testvm.acpiReboot())\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestAcpiRebootConnected", "data": "\tdef testAcpiRebootConnected(self):\n\t\twith fake.VM() as testvm:\n\t\t\ttestvm._dom = fake.Domain(vmId='testvm')\n\t\t\tassert not response.is_error(testvm.acpiReboot())\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "ftestGetChunkedDrives", "data": "\tdef testGetChunkedDrives(self, disk_conf, expected):\n\t\twith fake.VM() as testvm:\n\t\t\tvda = storage.Drive(self.log, **drive_config(**disk_conf))\n\t\t\ttestvm._devices[hwclass.DISK] = [vda]\n\n\t\t\tdrives = [drive.name for drive in testvm.getChunkedDrives()]\n\t\t\tassert drives == expected\n\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "_mem_committed", "data": "def _mem_committed(mem_size_mb):\n\t\"\"\"\n\tLegacy algorithm found in oVirt <= 4.1\n\t\"\"\"\n\tmemory = mem_size_mb\n\tmemory += config.getint('vars', 'guest_ram_overhead')\n\treturn memory * MiB\n\n", "description": "\n\tLegacy algorithm found in oVirt <= 4.1\n\t", "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "class", "name": "ChangingSchedulerDomain", "data": "class ChangingSchedulerDomain(object):\n\n\tdef __init__(self, offset=10):\n\t\tself._offset = offset\n\t\tself._params = {}\n\n\tdef setSchedulerParameters(self, params):\n\t\tfor k, v in params.items():\n\t\t\tself._params[k] = int(v) + self._offset\n\n\tdef schedulerParameters(self):\n\t\treturn self._params\n\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "raise_libvirt_error", "data": "def raise_libvirt_error(code, message):\n\terr = libvirt.libvirtError(defmsg=message)\n\terr.err = [code]\n\traise err\n\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}, {"term": "def", "name": "drive_config", "data": "def drive_config(**kw):\n\t\"\"\" Return drive configuration updated from **kw \"\"\"\n\tconf = {\n\t\t'device': 'disk',\n\t\t'format': 'cow',\n\t\t'iface': 'virtio',\n\t\t'index': '0',\n\t\t'path': '/path/to/volume',\n\t\t'propagateErrors': 'off',\n\t\t'shared': 'none',\n\t\t'type': 'disk',\n\t}\n\tconf.update(kw)\n\treturn conf\n", "description": " Return drive configuration updated from **kw ", "category": "graphics", "imports": ["from __future__ import absolute_import", "from __future__ import division", "import libvirt", "from six.moves import zip", "from vdsm.common import define", "from vdsm.common import exception", "from vdsm.common import hooks", "from vdsm.common import libvirtconnection", "from vdsm.common import password", "from vdsm.common import response", "from vdsm.common.units import MiB", "from vdsm.config import config", "from vdsm.virt import saslpasswd2", "from vdsm.virt import virdomain", "from vdsm.virt import vmexitreason", "from vdsm.virt.vmdevices import hwclass", "from vdsm.virt.vmdevices import storage", "from monkeypatch import MonkeyPatch, MonkeyPatchScope", "from testlib import XMLTestCase", "from testlib import permutations, expandPermutations", "from testValidation import brokentest", "from . import vmfakelib as fake", "import pytest"]}], [], [{"term": "def", "name": "is_windows_64bit", "data": "def is_windows_64bit():\n\t\"\"\" \n\n\t\t\u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442 \u0430\u0440\u0445\u0438\u0442\u0435\u043a\u0442\u0443\u0440\u0443 \u041e\u0421.\n\n\t\t\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 True, \u0435\u0441\u043b\u0438 \u0430\u0440\u0445\u0438\u0442\u0435\u043a\u0442\u0443\u0440\u0430 x64.\n\n\t\"\"\"\n\n\tif \"PROCESSOR_ARCHITEW6432\" in os.environ:\n\t\treturn True\n\n\treturn os.environ[\"PROCESSOR_ARCHITECTURE\"].endswith(\"64\")\n\n\n\n\n", "description": " \n\n\t\t\u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442 \u0430\u0440\u0445\u0438\u0442\u0435\u043a\u0442\u0443\u0440\u0443 \u041e\u0421.\n\n\t\t\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 True, \u0435\u0441\u043b\u0438 \u0430\u0440\u0445\u0438\u0442\u0435\u043a\u0442\u0443\u0440\u0430 x64.\n\n\t", "category": "graphics", "imports": ["import io", "import os", "import sys", "import logging  # \u0414\u043b\u044f \u043b\u043e\u0433\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f", "import argparse  # \u0414\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430\u043c\u0438 \u043a\u043e\u043c\u0430\u043d\u0434\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438", "import graphics  # \u041e\u0442\u0440\u0438\u0441\u043e\u0432\u043a\u0430 \u0433\u0440\u0430\u0444\u0438\u043a\u0438", "import docx  # \u0420\u0430\u0431\u043e\u0442\u0430 \u0441 .docx \u0444\u0430\u0439\u043b\u0430\u043c\u0438", "from PIL import Image"]}, {"term": "def", "name": "main", "data": "def main(file, title_len=60, title_size=8):\n\t\"\"\"\n\n\t\u0417\u0430\u043f\u043e\u043b\u043d\u044f\u0435\u0442 \u0441\u043b\u043e\u0432\u0430\u0440\u044c \u0441 \u0434\u0430\u043d\u043d\u044b\u043c\u0438 \u0438\u0437 \u0440\u0435\u0444\u0435\u0440\u0430\u0442\u0430 \n\n\t\u0438 \u0444\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u0442 \u043e\u0431\u043b\u043e\u0436\u043a\u0438 \u0434\u043b\u044f \u043f\u043e\u0434\u043b\u0438\u043d\u043d\u0438\u043a\u0430 \u0438 \u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\u0430 CD\n\n\tfile - \u0438\u043c\u044f \u0444\u0430\u0439\u043b\u0430 \u0440\u0435\u0444\u0435\u0440\u0430\u0442\u0430\n\n\ttitle_len - \u043a\u043e\u043b-\u0432\u043e \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u043d\u0430 \u0441\u0442\u0440\u043e\u043a\u0443 \u0434\u043b\u044f \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u044f CD\n\n\ttitle_size - \u0440\u0430\u0437\u043c\u0435\u0440 \u0448\u0440\u0438\u0444\u0442\u0430 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u044f CD\n\n\t\"\"\"\n\n\n\n\tdef draw_text(win, point, text_string, text_size):\n\t\t\"\"\" \n\n\t\t\u041e\u0442\u0440\u0438\u0441\u043e\u0432\u044b\u0432\u0430\u0435\u0442 \u0442\u0435\u043a\u0441\u0442\n\n\t\twin - graphics.GraphWin - \u0445\u043e\u043b\u0441\u0442, \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u043e\u043c \u0431\u0443\u0434\u0435\u0442 \u043e\u0442\u0440\u0438\u0441\u043e\u0432\u0430\u043d \u0442\u0435\u043a\u0441\u0442 \n\n\t\tpoint - graphics.Point - \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0446\u0435\u043d\u0442\u0440\u0430 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430 \u0432 \u043a\u043e\u0442\u043e\u0440\u043e\u043c\n\n\t\t\t\t\t\t\t \u0431\u0443\u0434\u0435\u0442 \u043e\u0442\u0440\u0438\u0441\u043e\u0432\u0430\u043d \u0442\u0435\u043a\u0441\u0442\n\n\t\ttext_string - str\t\t   - \u0442\u0435\u043a\u0441\u0442 \u0434\u043b\u044f \u043e\u0442\u0440\u0438\u0441\u043e\u0432\u043a\u0438 ()\n\n\t\ttext_size - int\t\t   - \u0440\u0430\u0437\u043c\u0435\u0440 \u0448\u0440\u0438\u0444\u0442\u0430 \u0442\u0435\u043a\u0441\u0442\u0430\n\n\t\t\"\"\"\n\t\t\n\n\t\ttext = graphics.Text(point, text_string)\n\n\t\ttext.setSize(text_size)\n\n\t\ttext.draw(win)\n\n\n\n\ttry:\n\t\tdocument = docx.Document(file)  # \u041e\u0442\u043a\u0440\u044b\u0442\u0438\u0435 docx \u0444\u0430\u0439\u043b\u0430\n\n\texcept Exception as err:\n\t\tlogging.error(str(err))\n\n\t\tsys.exit()\n\n\n\n\tlabels = dict()  # \u0421\u043b\u043e\u0432\u0430\u0440\u044c \u0441 \u0434\u0430\u043d\u043d\u044b\u043c\u0438 \u0438\u0437 \u0441\u0447\u0438\u0442\u0430\u043d\u043d\u043e\u0433\u043e docx \u0444\u0430\u0439\u043b\u0430\n\n\n\n\ttable = document.tables[0]  # \u0412\u044b\u043d\u0438\u043c\u0430\u0435\u043c \u0442\u0430\u0431\u043b\u0438\u0446\u0443 \u0441 \u0434\u0430\u043d\u043d\u044b\u043c\u0438\n\n\n\n\t# \u041f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0438 \u0442\u0430\u0431\u043b\u0438\u0446\u044b table \u0438 \u0437\u0430\u043f\u043e\u043b\u043d\u044f\u0435\u043c \u0442\u0435\u043a\u0441\u0442\u043e\u043c \u0438\u0437 \u043f\u043e\u043b\u0435\u0439 \u0442\u0430\u0431\u043b\u0438\u0446\u044b \u0441\u043b\u043e\u0432\u0430\u0440\u044c labels\n\n\tfor row in table.rows:\n\t\t# \u0423\u0431\u0438\u0440\u0430\u0435\u043c \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u043f\u0435\u0440\u0435\u043d\u043e\u0441\u0430 \u0441\u0442\u0440\u043e\u043a \u0438\u0437 \u043f\u043e\u043b\u0435\u0439 \"\u041a\u043b\u044e\u0447\"\n\n\t\tkey = row.cells[1].text.replace(\"\\n\", \" \")\n\n\t\twhile key in labels.keys():\n\t\t\tkey = key + \"_\"\n\n\t\tlabels[key] = row.cells[2].text\n\n\n\n\tvolumes = 1  # \u0411\u0430\u0437\u043e\u0432\u043e\u0435 \u043a\u043e\u043b-\u0432\u043e \u0442\u043e\u043c\u043e\u0432\n\n\n\n\t# \u0421\u043f\u0438\u0441\u043e\u043a \u0441\u043b\u043e\u0432\u0430\u0440\u0435\u0439 \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0442\u043e\u043c\u0430\n\n\tdisks = []\n\n\n\n\t# \u041d\u0430\u0445\u043e\u0434\u0438\u043c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u044b\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 \u0440\u0435\u0444\u0435\u0440\u0430\u0442\u0430\n\n\tfor key in labels:\n\t\tif \"\u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0439\" in key.lower():\n\t\t\tregNum = key\n\n\t\t\tcontinue\n\n\t\telif \"\u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435\" in key.lower():\n\t\t\tname = key\n\n\t\t\tcontinue\n\n\t\telif \"\u0434\u0435\u0446\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439\" in key.lower():\n\t\t\tdecimalNum = key\n\n\t\t\tcontinue\n\n\t\telif \"\u0440\u0430\u0441\u0441\u044b\u043b\u043a\u0430\" in key.lower():\n\t\t\tcdType = key\n\n\t\t\tcontinue\n\n\t\telif \"\u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u0430\u044f\" in key.lower():\n\t\t\tksum = key\n\n\n\n\t# \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0447\u0442\u043e \u0432\u0441\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0435\u0439 \u0434\u0438\u0441\u043a\u0430 \u043f\u0440\u0438\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u044e\u0442 \u0432 \u0440\u0435\u0444\u0435\u0440\u0430\u0442\u0435\n\n\ttry:\n\t\tif regNum and name and decimalNum and cdType and ksum:\n\t\t\tpass\n\n\texcept Exception as err:\n\t\tlogging.error(str(err))\n\n\t\tsys.exit()\n\n\n\n\twhile volumes:\n\n\n\t\tdisks.append(dict())  # \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043d\u043e\u0432\u044b\u0439 \u0441\u043b\u043e\u0432\u0430\u0440\u044c \u0434\u043b\u044f \u0442\u043e\u043c\u0430\n\n\n\n\t\t# \u0417\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u0441\u043b\u043e\u0432\u0430\u0440\u044f \u0442\u043e\u043c\u0430\n\n\t\tdisks[volumes - 1][regNum] = labels[regNum]\n\n\n\n\t\tdisks[volumes - 1][name] = labels[name] + (\n\n\t\t\t\".\" if labels[name][-1] != \".\" else \"\")\n\t\t\t\n\n\t\tif \"\u0422\u043e\u043c \" + str(volumes) + \":\" in labels:\n\n\t\t\tdisks[volumes - 1][name] = (\n\n\t\t\t\tdisks[volumes - 1][name]\n\n\t\t\t\t+ \" \"\n\n\t\t\t\t+ labels[\"\u0422\u043e\u043c \" + str(volumes) + \":\"]\n\n\t\t\t\t+ (\".\" if labels[\"\u0422\u043e\u043c \" + str(volumes) + \":\"][-1] != \".\" else \"\"))\n\n\n\n\t\tdisks[volumes - 1][decimalNum] = labels[decimalNum]\n\n\t\tif \"\u0422\u043e\u043c \" + str(volumes) + \":_\" in labels:\n\n\t\t\tdisks[volumes - 1][decimalNum] = (\n\n\t\t\t\tdisks[volumes - 1][decimalNum] + labels[\"\u0422\u043e\u043c \" + str(volumes) + \":_\"])\n\n\n\n\t\t# \u041d\u0430\u0445\u043e\u0434\u0438\u043c \u0442\u0438\u043f \u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044f (CD, DVD \u0438 \u0442.\u043f.)\n\n\t\twords = labels[cdType].split()\n\n\t\tfor word in words:\n\n\t\t\tif \"D\" in word:\n\n\t\t\t\ts = word\n\n\t\t\t\tbreak\n\n\n\n\t\tdisks[volumes - 1][cdType] = s\n\n\n\n\t\tdisks[volumes - 1][ksum] = labels[ksum]\n\n\t\tif \"\u0422\u043e\u043c \" + str(volumes) + \":___\" in labels:\n\n\t\t\tdisks[volumes - 1][ksum] = (\n\n\t\t\t\tdisks[volumes - 1][ksum] + labels[\"\u0422\u043e\u043c \" + str(volumes) + \":___\"])\n\n\n\n\t\t# \u0415\u0441\u043b\u0438 \u043d\u0430\u0445\u043e\u0434\u0438\u043c \u043c\u0435\u0442\u043a\u0443 \"\u0422\u043e\u043c \u0425:\" - \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u0432\u0430\u0435\u043c \u043a\u043e\u043b-\u0432\u043e \u0442\u043e\u043c\u043e\u0432 \u043a \u043f\u0435\u0447\u0430\u0442\u0438\n\n\t\tif \"\u0422\u043e\u043c \" + str(volumes + 1) + \":\" in labels:\n\n\t\t\tvolumes += 1\n\n\t\telse:\n\n\t\t\tvolumes = 0\n\n\n\n\t# \u0424\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u043c \u043e\u0431\u043b\u043e\u0436\u043a\u0443 \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0442\u043e\u043c\u0430 \u0432 2\u0445 \u044d\u043a\u0437\u0435\u043c\u043f\u043b\u044f\u0440\u0430\u0445 - \u043f\u043e\u0434\u043b\u0438\u043d\u043d\u0438\u043a \u0438 \u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\n\n\tfor disk in disks:\n\n\n\n\t\t# \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u043c \u0445\u043e\u043b\u0441\u0442\n\n\t\twin = graphics.GraphWin(\"\u041e\u043a\u043d\u043e \u0434\u043b\u044f \u0433\u0440\u0430\u0444\u0438\u043a\u0438\", 448, 448)\n\n\n\n\t\t# \u0411\u043e\u043b\u044c\u0448\u0430\u044f \u043e\u043a\u0440\u0443\u0436\u043d\u043e\u0441\u0442\u044c\n\n\t\tobj = graphics.Circle(graphics.Point(224, 224), 224)\n\n\t\tobj.setOutline(\"white\")\n\n\t\tobj.setFill(\"#87CEFA\")\n\n\t\tobj.draw(win)\n\n\n\n\t\t# \u041c\u0430\u043b\u0430\u044f \u043e\u043a\u0440\u0443\u0436\u043d\u043e\u0441\u0442\u044c\n\n\t\tobj = graphics.Circle(graphics.Point(224, 224), 80)\n\n\t\tobj.setOutline(\"white\")\n\n\t\tobj.setFill(\"white\")\n\n\t\tobj.draw(win)\n\n\n\n\t\t# \u041f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a \u0434\u043b\u044f \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u044f \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u0438\n\n\t\tobj = graphics.Rectangle(graphics.Point(104, 36), graphics.Point(344, 55))\n\n\t\tobj.draw(win)\n\n\n\n\t\t# \u0422\u0435\u043a\u0441\u0442 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u044f \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u0438\n\n\t\tdraw_text(win, graphics.Point(224, 45), \"\u0424\u0413\u0423\u041f \u00ab\u0413\u043e\u0441\u041d\u0418\u0418\u0410\u0421\u00bb\", 10)\n\n\n\n\t\t# \u041f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a \u0434\u043b\u044f \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u044f CD\n\n\t\tobj = graphics.Rectangle(graphics.Point(80, 55), graphics.Point(368, 135))\n\n\t\tobj.draw(win)\n\n\n\n\t\t# \u0422\u0435\u043a\u0441\u0442 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u044f CD\n\n\t\t# \u0417\u0430\u043c\u0435\u043d\u044f\u0435\u043c '.' \u043d\u0430 '.'+'\\n'\n\n\t\ts = disk[name].split(\".\")\n\n\t\ts = \".\\n\".join(s)\n\n\n\n\t\t# \u0420\u0430\u0437\u0431\u0438\u0432\u0430\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0443 \u043d\u0430 \u0441\u043b\u043e\u0432\u0430 \u043f\u043e \u043f\u0440\u043e\u0431\u0435\u043b\u044c\u043d\u043e\u043c\u0443 \u0441\u0438\u043c\u0432\u043e\u043b\u0443 (\u0438 \u0441\u0438\u043c\u0432\u043e\u043b\u0443 \u043d\u043e\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438)\n\n\t\tstring = s.split()\n\n\n\n\t\t# \u041e\u0433\u0440\u0430\u043d\u0438\u0447\u0438\u0432\u0430\u0435\u043c \u0434\u043b\u0438\u043d\u0443 \u0441\u0442\u0440\u043e\u043a\u0438 title_len(60 \u043f\u043e \u0434\u0435\u0444\u043e\u043b\u0442\u0443) \u0441\u0438\u043c\u0432\u043e\u043b\u0430\u043c\u0438, \n\t\t# \u043f\u043e\u0441\u043b\u0435 \u0447\u0435\u0433\u043e \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u043c \u043f\u0435\u0447\u0430\u0442\u044c \u043d\u0430 \u043d\u043e\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435\n\n\t\tval = \"\"  # \u0421\u0442\u0440\u043e\u043a\u0430 \u0441 \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u0435\u043c \u0432 title_len \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432\n\n\t\tn = 1  # \u0421\u0447\u0435\u0442\u0447\u0438\u043a \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0430 \u043d\u0430 \u043d\u043e\u0432\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443\n\n\t\tfor word in string:\n\n\t\t\tif len(val) + len(word) > title_len * n:\n\n\t\t\t\tval += \"\\n\"\n\n\t\t\t\tn += 1\n\n\t\t\tval += word\n\n\t\t\tval += \" \"\n\n\n\n\t\t# \u0422\u0435\u043a\u0441\u0442 \"\u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b\" disk[\"\u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b/\u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430/\u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438:\"])\n\n\t\tdraw_text(win, graphics.Point(224, 85), val, title_size)\n\n\n\n\t\t# \u0422\u0435\u043a\u0441\u0442 \u0441 \u0434\u0435\u0446\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u043c\u0438 \u043d\u043e\u043c\u0435\u0440\u043e\u043c\u0430\u043c\u0438 \u0438\u0437 \u0440\u0435\u0444\u0435\u0440\u0430\u0442\u0430\n\n\t\tdraw_text(win, graphics.Point(224, 125), disk[decimalNum], 7) #graphics.Point(224, 125) - \u0434\u043b\u044f \u043e\u0434\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438 \u0441 \u0434\u0435\u0446\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u043c \u043d\u043e\u043c\u0435\u0440\u043e\u043c\n\n\n\n\t\t# \u041f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u043d\u0438\u043a \"\u0412\u0438\u0434 \u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044f\"\n\n\t\tobj = graphics.Rectangle(graphics.Point(20, 165), graphics.Point(140, 185))\n\n\t\tobj.draw(win)\n\n\t\tobj = graphics.Rectangle(graphics.Point(100, 165), graphics.Point(140, 185))\n\n\t\tobj.draw(win)\n\n\n\n\t\t# \u0422\u0435\u043a\u0441\u0442 \"\u0412\u0438\u0434 \u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044f\"\n\n\t\tdraw_text(win, graphics.Point(60, 175), \"\u0412\u0438\u0434 \u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044f\", 10)\n\n\n\n\t\t# \u041f\u0438\u0448\u0435\u043c \u0432\u0438\u0434 \u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044f\n\n\t\tdraw_text(win, graphics.Point(120, 175), disk[cdType], 10)\n\n\n\n\t\t# \u041f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u043d\u0438\u043a \"\u041f\u043e\u0434\u0440\u0430\u0437\u0434\u0435\u043b\u0435\u043d\u0438\u0435\"\n\n\t\tobj = graphics.Rectangle(graphics.Point(308, 165), graphics.Point(428, 185))\n\n\t\tobj.draw(win)\n\n\t\tobj = graphics.Rectangle(graphics.Point(388, 165), graphics.Point(428, 185))\n\n\t\tobj.draw(win)\n\n\n\n\t\t# \u0422\u0435\u043a\u0441\u0442 \"\u041f\u043e\u0434\u0440\u0430\u0437\u0434\u0435\u043b\u0435\u043d\u0438\u0435\"\n\n\t\tdraw_text(win, graphics.Point(348, 175), \"\u041f\u043e\u0434\u0440\u0430\u0437\u0434\u0435\u043b\u0435\u043d\u0438\u0435\", 10)\n\n\n\n\t\t# \u0422\u0435\u043a\u0441\u0442 \"0500\"\n\n\t\tdraw_text(win, graphics.Point(408, 175), \"0500\", 10)\n\n\n\n\t\t# \u041f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a \"\u041a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u0430\u044f \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0430\"\n\n\t\tobj = graphics.Rectangle(graphics.Point(15, 215), graphics.Point(135, 295))\n\n\t\tobj.draw(win)\n\n\t\tobj = graphics.Rectangle(graphics.Point(15, 215), graphics.Point(135, 240))\n\n\t\tobj.draw(win)\n\n\n\n\t\t# \u0422\u0435\u043a\u0441\u0442 \"\u041a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u0430\u044f \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0430\"\n\n\t\tdraw_text(win, graphics.Point(75, 230), \"\u041a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u0430\u044f \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0430\", 8)\n\n\n\n\t\t# \u0422\u0435\u043a\u0441\u0442 c \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u043e\u0439 \u0441\u0443\u043c\u043c\u043e\u0439 \u0438\u0437 \u0440\u0435\u0444\u0435\u0440\u0430\u0442\u0430\n\n\t\t# \u0420\u0430\u0437\u0431\u0438\u0432\u0430\u0435\u043c \u041a\u0421\u0443\u043c\u043c \u043d\u0430 \u0434\u0432\u0435 \u0441\u0442\u0440\u043e\u043a\u0438\n\n\t\ts = disk[ksum]\n\n\t\tl = len(s)\n\n\t\ts = \"\\n\".join([s[0 : l // 2], s[l // 2 : :]])\n\n\n\n\t\t# \u041f\u0438\u0448\u0435\u043c \u041a\u0441\u0443\u043c\u043c\n\n\t\tdraw_text(win, graphics.Point(75, 265), s, 10)\n\n\n\n\t\t# \u041f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a \u0441 \u043f\u043e\u0434\u043f\u0438\u0441\u044f\u043c\u0438 \u0412\u041f, \u041e\u0422\u041a\n\n\t\tobj = graphics.Rectangle(graphics.Point(314, 215), graphics.Point(432, 295))\n\n\t\tobj.draw(win)\n\n\t\tobj = graphics.Rectangle(graphics.Point(314, 215), graphics.Point(432, 235))\n\n\t\tobj.draw(win)\n\n\t\tobj = graphics.Rectangle(graphics.Point(314, 215), graphics.Point(432, 255))\n\n\t\tobj.draw(win)\n\n\t\tobj = graphics.Rectangle(graphics.Point(314, 215), graphics.Point(432, 275))\n\n\t\tobj.draw(win)\n\n\t\tobj = graphics.Rectangle(graphics.Point(314, 215), graphics.Point(360, 295))\n\n\t\tobj.draw(win)\n\n\n\n\t\t# \u0422\u0435\u043a\u0441\u0442 \"\u041e\u0422\u041a\", \"\u0412\u041f \u041c\u041e\", \"\u0414\u0430\u0442\u0430\"\n\n\t\tdraw_text(win, graphics.Point(337, 225), \"\u041e\u0422\u041a\", 10)\n\n\t\tdraw_text(win, graphics.Point(337, 245), \"\u0414\u0430\u0442\u0430\", 10)\n\n\t\tdraw_text(win, graphics.Point(337, 265), \"\u0412\u041f \u041c\u041e\", 10)\n\n\t\tdraw_text(win, graphics.Point(337, 285), \"\u0414\u0430\u0442\u0430\", 10)\n\n\n\n\t\t# \u041f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a \u0434\u043b\u044f \u043d\u043e\u043c\u0435\u0440\u0430 \u0442\u043e\u043c\u0430, \u0440\u0435\u0433. \u043d\u043e\u043c\u0435\u0440\u0430 \u0438 \u0432\u0438\u0434\u0430 \u042d\u0414\n\n\t\tobj = graphics.Rectangle(graphics.Point(78, 350), graphics.Point(370, 390))\n\n\t\tobj.draw(win)\n\n\t\tobj = graphics.Rectangle(graphics.Point(78, 350), graphics.Point(370, 370))\n\n\t\tobj.draw(win)\n\n\t\tobj = graphics.Rectangle(graphics.Point(150, 350), graphics.Point(300, 390))\n\n\t\tobj.draw(win)\n\n\n\n\t\t# \u0422\u0435\u043a\u0441\u0442 \"\u041d\u043e\u043c\u0435\u0440 \u0442\u043e\u043c\u0430/\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0442\u043e\u043c\u043e\u0432\"\n\n\t\tdraw_text(win, graphics.Point(114, 355), \"\u041d\u043e\u043c\u0435\u0440 \u0442\u043e\u043c\u0430/\", 8)\n\n\t\tdraw_text(win, graphics.Point(114, 365), \"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0442\u043e\u043c\u043e\u0432\", 8)\n\n\n\n\t\t# \u041f\u0438\u0448\u0435\u043c \u043d\u043e\u043c\u0435\u0440 \u0442\u043e\u043c\u0430\n\n\t\tt = f\"{disks.index(disk)+1}/{len(disks)}\"\n\n\t\tdraw_text(win, graphics.Point(114, 380), t, 8)\n\n\n\n\t\t# \u0422\u0435\u043a\u0441\u0442 \"\u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440\"\n\n\t\tdraw_text(win, graphics.Point(225, 360), \"\u0420\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440\", 8)\n\n\n\n\t\t# \u0412\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u0438\u0437 \u0440\u0435\u0444\u0435\u0440\u0430\u0442\u0430\n\n\t\tdraw_text(win, graphics.Point(225, 380), disk[regNum], 8)\n\n\n\n\t\t# \u0422\u0435\u043a\u0441\u0442 \"\u0412\u0438\u0434 \u042d\u0414\"\n\n\t\tdraw_text(win, graphics.Point(335, 360), \"\u0412\u0438\u0434 \u042d\u0414\", 8)\n\n\n\n\t\t# \u041f\u0438\u0448\u0435\u043c, \u0447\u0442\u043e \u0444\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u043c \u043f\u043e\u0434\u043b\u0438\u043d\u043d\u0438\u043a\n\n\t\tdraw_text(win, graphics.Point(335, 380), \"\u041f\", 8)\n\n\n\n\t\t# \u0421\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043f\u043e\u0434\u043b\u0438\u043d\u043d\u0438\u043a\u0430\n\n\t\t# \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u043c \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0432 \u0444\u043e\u0440\u043c\u0430\u0442 postscript\n\n\t\tps = win.postscript(colormode=\"color\", pageheight=448, pagewidth=448)\n\n\t\t# win.postscript(colormode='color', file=\"image.eps\")\n\n\t\t# \u041a\u043e\u0434\u0438\u0440\u0443\u0435\u043c \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u043d\u043e\u0435 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0432 \u0431\u0430\u0439\u0442\u044b\n\n\t\timg = Image.open(io.BytesIO(ps.encode(\"utf-8\")))\n\n\t\t# \u0427\u0442\u043e\u0431\u044b \u043d\u0435 \u043f\u043e\u0442\u0435\u0440\u044f\u0442\u044c \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0438 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0438 \u0432 .png \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u0432\u0430\u0435\u043c\n\n\t\t# postscript \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0432 8 \u0440\u0430\u0437\n\n\t\timg.load(scale=8)\n\n\t\t# \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0438\u0441\u0445\u043e\u0434\u043d\u044b\u0439 \u043c\u0430\u0441\u0448\u0442\u0430\u0431\n\n\t\timg = img.resize((1394, 1394), Image.BICUBIC)\n\n\t\t# \u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435\n\n\t\timg.save(\"label\" + str(disks.index(disk)) + \"_p.png\", \"png\", dpi=(300, 300))\n\n\n\n\t\t# \u0416\u0434\u0435\u043c \u043a\u043b\u0438\u043a\u0430 \u043c\u044b\u0448\u044c\u044e \u043d\u0430 \u043e\u043a\u043d\u0435\n\n\t\t# win.getMouse()\n\n\n\n\t\t# \u0417\u0430\u043a\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u043c \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a \"\u041a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u0430\u044f \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0430\" \u0434\u043b\u044f \u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\u0430\n\n\t\tobj = graphics.Rectangle(graphics.Point(15, 215), graphics.Point(135, 295))\n\n\t\tobj.draw(win)\n\n\t\tobj.setFill(\"#87CEFA\")\n\n\t\tobj = graphics.Rectangle(graphics.Point(15, 215), graphics.Point(135, 240))\n\n\t\tobj.draw(win)\n\n\n\n\t\t# \u0422\u0435\u043a\u0441\u0442 \"\u041a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u0430\u044f \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0430\"\n\n\t\tdraw_text(win, graphics.Point(75, 230), \"\u041a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u0430\u044f \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0430\", 8)\n\n\n\n\t\t# \u0417\u0430\u043a\u0440\u0430\u0448\u0438\u0432\u0430\u0435\u043c \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a \"\u0412\u0438\u0434 \u042d\u0414\"\n\n\t\tobj = graphics.Rectangle(graphics.Point(300, 370), graphics.Point(370, 390))\n\n\t\tobj.setFill(\"#87CEFA\")\n\n\t\tobj.draw(win)\n\n\n\n\t\t# \u041f\u0438\u0448\u0435\u043c, \u0447\u0442\u043e \u0444\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u043c \u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\n\n\t\tdraw_text(win, graphics.Point(335, 380), \"\u0414\", 8)\n\n\n\n\t\t# \u0416\u0434\u0435\u043c \u043a\u043b\u0438\u043a\u0430 \u043c\u044b\u0448\u044c\u044e \u043d\u0430 \u043e\u043a\u043d\u0435\n\n\t\t# win.getMouse()\n\n\n\n\t\t# \u0421\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\u0430\n\n\t\t# \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u043c \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0432 \u0444\u043e\u0440\u043c\u0430\u0442 postscript\n\n\t\tps = win.postscript(colormode=\"color\", pageheight=448, pagewidth=448)\n\n\t\t# win.postscript(colormode='color', file=\"image.eps\")\n\n\t\t# \u041a\u043e\u0434\u0438\u0440\u0443\u0435\u043c \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u043d\u043e\u0435 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0432 \u0431\u0430\u0439\u0442\u044b\n\n\t\timg = Image.open(io.BytesIO(ps.encode(\"utf-8\")))\n\n\t\t# \u0427\u0442\u043e\u0431\u044b \u043d\u0435 \u043f\u043e\u0442\u0435\u0440\u044f\u0442\u044c \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0438 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0438 \u0432 .png \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u0432\u0430\u0435\u043c\n\n\t\t# postscript \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0432 8 \u0440\u0430\u0437\n\n\t\timg.load(scale=8)\n\n\t\t# \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0438\u0441\u0445\u043e\u0434\u043d\u044b\u0439 \u043c\u0430\u0441\u0448\u0442\u0430\u0431\n\n\t\timg = img.resize((1394, 1394), Image.BICUBIC)\n\n\t\t# \u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435\n\n\t\timg.save(\"label\" + str(disks.index(disk)) + \"_d.png\", \"png\", dpi=(300, 300))\n\n\n\n\t\t#  \u0417\u0430\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u043e\u043a\u043d\u043e\n\n\t\twin.close()\n\n\n\n\n", "description": "\n\n\t\u0417\u0430\u043f\u043e\u043b\u043d\u044f\u0435\u0442 \u0441\u043b\u043e\u0432\u0430\u0440\u044c \u0441 \u0434\u0430\u043d\u043d\u044b\u043c\u0438 \u0438\u0437 \u0440\u0435\u0444\u0435\u0440\u0430\u0442\u0430 \n\n\t\u0438 \u0444\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u0442 \u043e\u0431\u043b\u043e\u0436\u043a\u0438 \u0434\u043b\u044f \u043f\u043e\u0434\u043b\u0438\u043d\u043d\u0438\u043a\u0430 \u0438 \u0434\u0443\u0431\u043b\u0438\u043a\u0430\u0442\u0430 CD\n\n\tfile - \u0438\u043c\u044f \u0444\u0430\u0439\u043b\u0430 \u0440\u0435\u0444\u0435\u0440\u0430\u0442\u0430\n\n\ttitle_len - \u043a\u043e\u043b-\u0432\u043e \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u043d\u0430 \u0441\u0442\u0440\u043e\u043a\u0443 \u0434\u043b\u044f \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u044f CD\n\n\ttitle_size - \u0440\u0430\u0437\u043c\u0435\u0440 \u0448\u0440\u0438\u0444\u0442\u0430 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u044f CD\n\n\t", "category": "graphics", "imports": ["import io", "import os", "import sys", "import logging  # \u0414\u043b\u044f \u043b\u043e\u0433\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f", "import argparse  # \u0414\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430\u043c\u0438 \u043a\u043e\u043c\u0430\u043d\u0434\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438", "import graphics  # \u041e\u0442\u0440\u0438\u0441\u043e\u0432\u043a\u0430 \u0433\u0440\u0430\u0444\u0438\u043a\u0438", "import docx  # \u0420\u0430\u0431\u043e\u0442\u0430 \u0441 .docx \u0444\u0430\u0439\u043b\u0430\u043c\u0438", "from PIL import Image"]}], [{"term": "def", "name": "move_screen", "data": "def move_screen():\n\tglobal speed\n\tglobal camera\n\tkeys = pygame.key.get_pressed()\n\tif keys[pygame.K_RIGHT]:\n\t\tcamera.move((speed, 0))\n\tif keys[pygame.K_LEFT]:\n\t\tcamera.move((-speed, 0))\n\tif keys[pygame.K_UP]:\n\t\tcamera.move((0, speed))\n\tif keys[pygame.K_DOWN]:\n\t\tcamera.move((0, -speed))\n\n\tif keys[pygame.K_a]:\n\t\tcamera.y_rotation += 5\n\tif keys[pygame.K_d]:\n\t\tcamera.y_rotation -= 5\n\n\tif keys[pygame.K_w]:\n\t\tcamera.x_rotation -= 5\n\tif keys[pygame.K_s]:\n\t\tcamera.x_rotation += 5\n\n\tif keys[pygame.K_q]:\n\t\tcamera.z_rotation += 5\n\tif keys[pygame.K_e]:\n\t\tcamera.z_rotation -= 5\n\n", "description": null, "category": "graphics", "imports": ["import graphics", "import manager", "from shape_types import *", "import pygame", "import user_input as ui"]}, {"term": "def", "name": "move_screen_with_mouse1", "data": "def move_screen_with_mouse1():\n\tglobal first_mouse_pos, original_cam_pos\n\tfirst_mouse_pos = pygame.mouse.get_pos()\n\toriginal_cam_pos = (camera.x, camera.y)\n\n", "description": null, "category": "graphics", "imports": ["import graphics", "import manager", "from shape_types import *", "import pygame", "import user_input as ui"]}, {"term": "def", "name": "move_screen_mouse2", "data": "def move_screen_mouse2():\n\tglobal first_mouse_pos, second_mouse_pos, original_cam_pos\n\tif pygame.mouse.get_pressed()[0]:\n\t\tsecond_mouse_pos = pygame.mouse.get_pos()\n\t\tcamera.x = original_cam_pos[0] + -(second_mouse_pos[0] - first_mouse_pos[0])\n\t\tcamera.y = original_cam_pos[1] + (second_mouse_pos[1] - first_mouse_pos[1])\n\n", "description": null, "category": "graphics", "imports": ["import graphics", "import manager", "from shape_types import *", "import pygame", "import user_input as ui"]}, {"term": "def", "name": "zoom", "data": "def zoom(event):\n\tglobal first_mouse_pos, second_mouse_pos\n\tif event.button == 4:\n\t\tcamera.z -= 10\n\telif event.button == 5:\n\t\tcamera.z += 10\n\n", "description": null, "category": "graphics", "imports": ["import graphics", "import manager", "from shape_types import *", "import pygame", "import user_input as ui"]}], [], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis widget is an easy starting point for generating multi-panel figures.\n\tExample::\n\t\n\t\tw = pg.GraphicsLayoutWidget()\n\t\tp1 = w.addPlot(row=0, col=0)\n\t\tp2 = w.addPlot(row=0, col=1)\n\t\tv = w.addViewBox(row=1, col=0, colspan=2)\n\t\n\tParameters\n\t----------\n\tparent : QWidget or None\n\t\tThe parent widget (see QWidget.__init__)\n\tshow : bool\n\t\tIf True, then immediately show the widget after it is created.\n\t\tIf the widget has no parent, then it will be shown inside a new window.\n\tsize : (width, height) tuple\n\t\tOptionally resize the widget. Note: if this widget is placed inside a\n\t\tlayout, then this argument has no effect.\n\ttitle : str or None\n\t\tIf specified, then set the window title for this widget.\n\tkargs : \n\t\tAll extra arguments are passed to \n\t\t:func:`GraphicsLayout.__init__() `\n\t\t\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, show=False, size=None, title=None, **kargs):\n\t\tmkQApp()\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n\t\t\n\t\tif size is not None:\n\t\t\tself.resize(*size)\n\t\t\t\n\t\tif title is not None:\n\t\t\tself.setWindowTitle(title)\n\t\t\t\n\t\tif show is True:\n\t\t\tself.show()\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis widget is an easy starting point for generating multi-panel figures.\n\tExample::\n\t\n\t\tw = pg.GraphicsLayoutWidget()\n\t\tp1 = w.addPlot(row=0, col=0)\n\t\tp2 = w.addPlot(row=0, col=1)\n\t\tv = w.addViewBox(row=1, col=0, colspan=2)\n\t\n\tParameters\n\t----------\n\tparent : QWidget or None\n\t\tThe parent widget (see QWidget.__init__)\n\tshow : bool\n\t\tIf True, then immediately show the widget after it is created.\n\t\tIf the widget has no parent, then it will be shown inside a new window.\n\tsize : (width, height) tuple\n\t\tOptionally resize the widget. Note: if this widget is placed inside a\n\t\tlayout, then this argument has no effect.\n\ttitle : str or None\n\t\tIf specified, then set the window title for this widget.\n\tkargs : \n\t\tAll extra arguments are passed to \n\t\t:func:`GraphicsLayout.__init__() `\n\t\t\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui, mkQApp", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [{"term": "class", "name": "PlannerBase", "data": "class PlannerBase(object):\n\n\t# This class implements the basic graphical support for the planners. In particular, it plots both the\n\t# occupancy grid (which shows the probability of occupancy) and the search grid (binary and used to\n\t#  plan the path).\n\t\n\tdef __init__(self, title, occupancyGrid):\n\t\tself.title = title\n\t\tself.occupancyGrid = occupancyGrid\n\t\tself.searchGrid = None\n\n\t\tself.robotRadius = rospy.get_param('robot_radius', 0.2)\n\n\t\trospy.loginfo(\"Occupancy grid dimensions = %dx%d\", occupancyGrid.getWidthInCells(), occupancyGrid.getHeightInCells())\n\n\t\tself.setupOccupancyGrid()\n\t\t\n\t\t# Graphics and debug output support\n\t\tself.showGraphics = True\n\t\tself.pauseTimeInSeconds = 0\n\t\tself.iterationsBetweenGraphicsUpdate = 10000\n\t\tself.iterationsSinceLastGraphicsUpdate = 0\n\t\tself.searchGridDrawer = None\n\t\tself.occupancyGridDrawer = None\n\t\tself.windowHeightInPixels = 700\n\t\tself.runInteractively = False\n\n\t# This method is called when first setting stuff up\n\tdef setupOccupancyGrid(self):\n\t\traise NotImplementedError()\n\n\t# This method is called if the occupancy grid changes\n\tdef handleChangeToOccupancyGrid(self):\n\t\traise NotImplementedError()\n\n\t# Pause for key presses?\n\tdef setRunInteractively(self, runInteractively):\n\n\t\t# Record the decision here. We can only configure the drawer if it's already been\n\t\t# created.\n\t\tself.runInteractively = runInteractively\n\t\tif self.searchGridDrawer is not None:\n\t\t\tself.searchGridDrawer.setRunInterctively(runInteractively)\n\t\t\n\t# Show graphics?\n\tdef setShowGraphics(self, showGraphics):\n\t\tself.showGraphics = showGraphics\n\n\t# Getter to get the graphics\n\tdef getPlannerDrawer(self):\n\t\treturn self.searchGridDrawer\n\t\t\n\t# Change the default window height in pixels\n\tdef setWindowHeightInPixels(self, windowHeightInPixels):\n\t\tself.windowHeightInPixels = windowHeightInPixels\n\t\t\n\t# Set the pause time. When a window is updated, how long\n\t# should we pause for? Default is 0s.\n\tdef setDrawingPauseTime(self, pauseTimeInSeconds):\n\t\tself.pauseTimeInSeconds = pauseTimeInSeconds\n\t\t\n\t# Set the number of iterations between drawning the window. The\n\t# default is 50\n\tdef setIterationsBetweenDrawing(self, iterationsBetweenGraphicsUpdate):\n\t\tself.iterationsBetweenGraphicsUpdate = iterationsBetweenGraphicsUpdate\n\n\t# Reset the graphics; clear and close the window and then open a new window\n\tdef resetGraphics(self):\n\t\t\n\t\tif (self.showGraphics == False):\n\t\t\treturn\n\t\t\n\t\t# If we don't have the drawers set up yet, create them\n\t\tif (self.searchGridDrawer is None):\n\t\t\tself.createPlannerDrawer()\n\t\t\tself.searchGridDrawer.setRunInteractively(self.runInteractively)\n\t\t\tself.searchGridDrawer.open()\n\t\t\tself.occupancyGridDrawer.open()\n\t\telse:\n\t\t\tself.searchGridDrawer.reset()\n\t\t\tself.occupancyGridDrawer.reset()\n\t\t\t\n\t\t# Draw the start and end points\n\t\tself.searchGridDrawer.setStartAndGoal(self.start, self.goal)\n\t\t\n\t\t# Now force an initial draw\n\t\tself.drawCurrentState(forceUpdate=True)\n\t\t\n\t# Draw the output and sleep for the pause time.\n\tdef drawCurrentState(self, forceUpdate=False):\n\n\t\t# If graphics is disabled, return\n\t\tif self.showGraphics is False:\n\t\t\treturn\n\n\t\t# This check is needed because this code can be called during initialisation,\n\t\t# when not everything has been set up yet\n\t\tif (self.searchGridDrawer is None) or (self.occupancyGridDrawer is None):\n\t\t\treturn\n\t\t\t\n\t\t# Check if we need to do an update - this happens either if we force an update,\n\t\t# or the override has been set\n\t\tself.iterationsSinceLastGraphicsUpdate = self.iterationsSinceLastGraphicsUpdate + 1\n\n\t\tif forceUpdate is False:\t \n\t\t\tif (self.iterationsSinceLastGraphicsUpdate < self.iterationsBetweenGraphicsUpdate):\n\t\t\t\treturn\n\n\t\t# Reset the draw counter\n\t\tself.iterationsSinceLastGraphicsUpdate = 0\n\n\t\tself.searchGridDrawer.update()\n\t\tself.occupancyGridDrawer.update()\n\t\ttime.sleep(self.pauseTimeInSeconds)\n\n\t# Create the drawers which show the planner's progress\n\tdef createPlannerDrawer(self):\n\t\tself.searchGridDrawer = SearchGridDrawer('Planner SG: ' + self.title, self.searchGrid, self.windowHeightInPixels)\n\t\tself.occupancyGridDrawer = OccupancyGridDrawer('Planner OG :' + self.title, self.occupancyGrid, self.windowHeightInPixels)\n\n\t# Set the pause time\n\tdef setPauseTime(self, pauseTimeInSeconds):\n\t\tself.pauseTimeInSeconds = pauseTimeInSeconds\n", "description": null, "category": "graphics", "imports": ["from occupancy_grid import OccupancyGrid", "from search_grid import SearchGrid", "from grid_drawer import *", "import time", "from collections import deque", "from cell import *", "from planned_path import PlannedPath", "from math import *"]}], [{"term": "class", "name": "ContourPlot", "data": "class ContourPlot(GraphicPrimitive):\n\t\"\"\"\n\tPrimitive class for the contour plot graphics type.  See\n\t``contour_plot?`` for help actually doing contour plots.\n\n\tINPUT:\n\n\t- ``xy_data_array`` - list of lists giving evaluated values of the function on the grid\n\n\t- ``xrange`` - tuple of 2 floats indicating range for horizontal direction\n\n\t- ``yrange`` - tuple of 2 floats indicating range for vertical direction\n\n\t- ``options`` - dict of valid plot options to pass to constructor\n\n\tEXAMPLES:\n\n\tNote this should normally be used indirectly via ``contour_plot``::\n\n\t\tsage: from sage.plot.contour_plot import ContourPlot\n\t\tsage: C = ContourPlot([[1,3],[2,4]],(1,2),(2,3),options={})\n\t\tsage: C\n\t\tContourPlot defined by a 2 x 2 data grid\n\t\tsage: C.xrange\n\t\t(1, 2)\n\n\tTESTS:\n\n\tWe test creating a contour plot::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: contour_plot(x^2-y^3+10*sin(x*y), (x, -4, 4), (y, -4, 4),plot_points=121,cmap='hsv')\n\t\tGraphics object consisting of 1 graphics primitive\n\t\"\"\"\n\tdef __init__(self, xy_data_array, xrange, yrange, options):\n\t\t\"\"\"\n\t\tInitializes base class ContourPlot.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: x,y = var('x,y')\n\t\t\tsage: C = contour_plot(x^2-y^3+10*sin(x*y), (x, -4, 4), (y, -4, 4),plot_points=121,cmap='hsv')\n\t\t\tsage: C[0].xrange\n\t\t\t(-4.0, 4.0)\n\t\t\tsage: C[0].options()['plot_points']\n\t\t\t121\n\t\t\"\"\"\n\t\tself.xrange = xrange\n\t\tself.yrange = yrange\n\t\tself.xy_data_array = xy_data_array\n\t\tself.xy_array_row = len(xy_data_array)\n\t\tself.xy_array_col = len(xy_data_array[0])\n\t\tGraphicPrimitive.__init__(self, options)\n\n\tdef get_minmax_data(self):\n\t\t\"\"\"\n\t\tReturns a dictionary with the bounding box data.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: x,y = var('x,y')\n\t\t\tsage: f(x,y) = x^2 + y^2\n\t\t\tsage: d = contour_plot(f, (3, 6), (3, 6))[0].get_minmax_data()\n\t\t\tsage: d['xmin']\n\t\t\t3.0\n\t\t\tsage: d['ymin']\n\t\t\t3.0\n\t\t\"\"\"\n\t\tfrom sage.plot.plot import minmax_data\n\t\treturn minmax_data(self.xrange, self.yrange, dict=True)\n\n\tdef _allowed_options(self):\n\t\t\"\"\"\n\t\tReturn the allowed options for the ContourPlot class.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: x,y = var('x,y')\n\t\t\tsage: C = contour_plot(x^2-y^2,(x,-2,2),(y,-2,2))\n\t\t\tsage: isinstance(C[0]._allowed_options(),dict)\n\t\t\tTrue\n\t\t\"\"\"\n\t\treturn {'plot_points':'How many points to use for plotting precision',\n\t\t\t\t'cmap':\"\"\"the name of a predefined colormap,\n\t\t\t\t\t\ta list of colors, or an instance of a\n\t\t\t\t\t\tmatplotlib Colormap. Type: import matplotlib.cm; matplotlib.cm.datad.keys()\n\t\t\t\t\t\tfor available colormap names.\"\"\",\n\t\t\t\t'colorbar': \"Include a colorbar indicating the levels\",\n\t\t\t\t'colorbar_options': \"a dictionary of options for colorbars\",\n\t\t\t\t'fill':'Fill contours or not',\n\t\t\t\t'legend_label':'The label for this item in the legend.',\n\t\t\t\t'contours':\"\"\"Either an integer specifying the number of\n\t\t\t\t\t\tcontour levels, or a sequence of numbers giving\n\t\t\t\t\t\tthe actual contours to use.\"\"\",\n\t\t\t\t'linewidths':'the width of the lines to be plotted',\n\t\t\t\t'linestyles':'the style of the lines to be plotted',\n\t\t\t\t'labels':'show line labels or not',\n\t\t\t\t'label_options':'a dictionary of options for the labels',\n\t\t\t\t'zorder':'The layer level in which to draw'}\n\n\tdef _repr_(self):\n\t\t\"\"\"\n\t\tString representation of ContourPlot primitive.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: x,y = var('x,y')\n\t\t\tsage: C = contour_plot(x^2-y^2,(x,-2,2),(y,-2,2))\n\t\t\tsage: c = C[0]; c\n\t\t\tContourPlot defined by a 100 x 100 data grid\n\t\t\"\"\"\n\t\treturn \"ContourPlot defined by a %s x %s data grid\"%(self.xy_array_row, self.xy_array_col)\n\n\tdef _render_on_subplot(self, subplot):\n\t\t\"\"\"\n\t\tTESTS:\n\n\t\tA somewhat random plot, but fun to look at::\n\n\t\t\tsage: x,y = var('x,y')\n\t\t\tsage: contour_plot(x^2-y^3+10*sin(x*y), (x, -4, 4), (y, -4, 4),plot_points=121,cmap='hsv')\n\t\t\tGraphics object consisting of 1 graphics primitive\n\t\t\"\"\"\n\t\tfrom sage.rings.integer import Integer\n\t\toptions = self.options()\n\t\tfill = options['fill']\n\t\tcontours = options['contours']\n\t\tif 'cmap' in options:\n\t\t\tcmap = get_cmap(options['cmap'])\n\t\telif fill or contours is None:\n\t\t\tcmap = get_cmap('gray')\n\t\telse:\n\t\t\tif isinstance(contours, (int, Integer)):\n\t\t\t\tcmap = get_cmap([(i,i,i) for i in xsrange(0,1,1/contours)])\n\t\t\telse:\n\t\t\t\tl = Integer(len(contours))\n\t\t\t\tcmap = get_cmap([(i,i,i) for i in xsrange(0,1,1/l)])\n\n\t\tx0,x1 = float(self.xrange[0]), float(self.xrange[1])\n\t\ty0,y1 = float(self.yrange[0]), float(self.yrange[1])\n\n\t\tif isinstance(contours, (int, Integer)):\n\t\t\tcontours = int(contours)\n\n\t\tCSF=None\n\t\tif fill:\n\t\t\tif contours is None:\n\t\t\t\tCSF=subplot.contourf(self.xy_data_array, cmap=cmap, extent=(x0,x1,y0,y1), label=options['legend_label'])\n\t\t\telse:\n\t\t\t\tCSF=subplot.contourf(self.xy_data_array, contours, cmap=cmap, extent=(x0,x1,y0,y1),extend='both', label=options['legend_label'])\n\n\t\tlinewidths = options.get('linewidths',None)\n\t\tif isinstance(linewidths, (int, Integer)):\n\t\t\tlinewidths = int(linewidths)\n\t\telif isinstance(linewidths, (list, tuple)):\n\t\t\tlinewidths = tuple(int(x) for x in linewidths)\n\n\t\tfrom sage.plot.misc import get_matplotlib_linestyle\n\t\tlinestyles = options.get('linestyles', None)\n\t\tif isinstance(linestyles, (list, tuple)):\n\t\t\tlinestyles = [get_matplotlib_linestyle(l, 'long') for l in linestyles]\n\t\telse:\n\t\t\tlinestyles = get_matplotlib_linestyle(linestyles, 'long')\n\t\tif contours is None:\n\t\t\tCS = subplot.contour(self.xy_data_array, cmap=cmap, extent=(x0,x1,y0,y1),\n\t\t\t\t\t\t\t\t linewidths=linewidths, linestyles=linestyles, label=options['legend_label'])\n\t\telse:\n\t\t\tCS = subplot.contour(self.xy_data_array, contours, cmap=cmap, extent=(x0,x1,y0,y1),\n\t\t\t\t\t\t\tlinewidths=linewidths, linestyles=linestyles, label=options['legend_label'])\n\t\tif options.get('labels', False):\n\t\t\tlabel_options = options['label_options']\n\t\t\tlabel_options['fontsize'] = int(label_options['fontsize'])\n\t\t\tif fill and label_options is None:\n\t\t\t\tlabel_options['inline']=False\n\t\t\tsubplot.clabel(CS, **label_options)\n\t\tif options.get('colorbar', False):\n\t\t\tcolorbar_options = options['colorbar_options']\n\t\t\tfrom matplotlib import colorbar\n\t\t\tcax,kwds=colorbar.make_axes_gridspec(subplot,**colorbar_options)\n\t\t\tif CSF is None:\n\t\t\t\tcb=colorbar.Colorbar(cax,CS, **kwds)\n\t\t\telse:\n\t\t\t\tcb=colorbar.Colorbar(cax,CSF, **kwds)\n\t\t\t\tcb.add_lines(CS)\n", "description": "\n\tPrimitive class for the contour plot graphics type.  See\n\t``contour_plot?`` for help actually doing contour plots.\n\n\tINPUT:\n\n\t- ``xy_data_array`` - list of lists giving evaluated values of the function on the grid\n\n\t- ``xrange`` - tuple of 2 floats indicating range for horizontal direction\n\n\t- ``yrange`` - tuple of 2 floats indicating range for vertical direction\n\n\t- ``options`` - dict of valid plot options to pass to constructor\n\n\tEXAMPLES:\n\n\tNote this should normally be used indirectly via ``contour_plot``::\n\n\t\tsage: from sage.plot.contour_plot import ContourPlot\n\t\tsage: C = ContourPlot([[1,3],[2,4]],(1,2),(2,3),options={})\n\t\tsage: C\n\t\tContourPlot defined by a 2 x 2 data grid\n\t\tsage: C.xrange\n\t\t(1, 2)\n\n\tTESTS:\n\n\tWe test creating a contour plot::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: contour_plot(x^2-y^3+10*sin(x*y), (x, -4, 4), (y, -4, 4),plot_points=121,cmap='hsv')\n\t\tGraphics object consisting of 1 graphics primitive\n\t", "category": "graphics", "imports": ["from sage.plot.primitive import GraphicPrimitive", "from sage.misc.decorators import options, suboptions", "from sage.plot.colors import rgbcolor, get_cmap", "from sage.misc.misc import xsrange", "import operator", "\t\tsage: from sage.plot.contour_plot import ContourPlot", "\t\tfrom sage.plot.plot import minmax_data", "\t\t\t\t\t\tmatplotlib Colormap. Type: import matplotlib.cm; matplotlib.cm.datad.keys()", "\t\tfrom sage.rings.integer import Integer", "\t\tfrom sage.plot.misc import get_matplotlib_linestyle", "\t\t\tfrom matplotlib import colorbar", "\t  Colormap. Type: ``import matplotlib.cm; matplotlib.cm.datad.keys()``", "\tfrom sage.plot.all import Graphics", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\timport numpy", "\tfrom sage.symbolic.expression import is_SymbolicEquation", "\t\tfrom sage.symbolic.expression import is_Expression", "\tfrom matplotlib.colors import ListedColormap", "\t\tsage: from sage.plot.contour_plot import equify", "\timport operator", "\tfrom sage.calculus.all import symbolic_expression", "\tfrom sage.symbolic.expression import is_Expression"]}, {"term": "def", "name": "contour_plot", "data": "def contour_plot(f, xrange, yrange, **options):\n\tr\"\"\"\n\t``contour_plot`` takes a function of two variables, `f(x,y)`\n\tand plots contour lines of the function over the specified\n\t``xrange`` and ``yrange`` as demonstrated below.\n\n\t``contour_plot(f, (xmin, xmax), (ymin, ymax), ...)``\n\n\tINPUT:\n\n\t- ``f`` -- a function of two variables\n\n\t- ``(xmin, xmax)`` -- 2-tuple, the range of ``x`` values OR 3-tuple\n\t  ``(x,xmin,xmax)``\n\n\t- ``(ymin, ymax)`` -- 2-tuple, the range of ``y`` values OR 3-tuple\n\t  ``(y,ymin,ymax)``\n\n\tThe following inputs must all be passed in as named parameters:\n\n\t- ``plot_points``  -- integer (default: 100); number of points to plot\n\t  in each direction of the grid.  For old computers, 25 is fine, but\n\t  should not be used to verify specific intersection points.\n\n\t- ``fill`` -- bool (default: ``True``), whether to color in the area\n\t  between contour lines\n\n\t- ``cmap`` -- a colormap (default: ``'gray'``), the name of\n\t  a predefined colormap, a list of colors or an instance of a matplotlib\n\t  Colormap. Type: ``import matplotlib.cm; matplotlib.cm.datad.keys()``\n\t  for available colormap names.\n\n\t- ``contours`` -- integer or list of numbers (default: ``None``):\n\t  If a list of numbers is given, then this specifies the contour levels\n\t  to use.  If an integer is given, then this many contour lines are\n\t  used, but the exact levels are determined automatically. If ``None``\n\t  is passed (or the option is not given), then the number of contour\n\t  lines is determined automatically, and is usually about 5.\n\n\t- ``linewidths`` -- integer or list of integer (default: None), if\n\t  a single integer all levels will be of the width given,\n\t  otherwise the levels will be plotted with the width in the order\n\t  given.  If the list is shorter than the number of contours, then\n\t  the widths will be repeated cyclically.\n\n\t- ``linestyles`` -- string or list of strings (default: None), the\n\t  style of the lines to be plotted, one of: ``\"solid\"``, ``\"dashed\"``,\n\t  ``\"dashdot\"``, ``\"dotted\"``, respectively ``\"-\"``, ``\"--\"``,\n\t  ``\"-.\"``, ``\":\"``.  If the list is shorter than the number of\n\t  contours, then the styles will be repeated cyclically.\n\n\t- ``labels`` -- boolean (default: False) Show level labels or not.\n\n\t  The following options are to adjust the style and placement of\n\t  labels, they have no effect if no labels are shown.\n\n\t  - ``label_fontsize`` -- integer (default: 9), the font size of the labels.\n\n\t  - ``label_colors`` -- string or sequence of colors (default:\n\t\tNone) If a string, gives the name of a single color with which\n\t\tto draw all labels.  If a sequence, gives the colors of the\n\t\tlabels.  A color is a string giving the name of one or a\n\t\t3-tuple of floats.\n\n\t  - ``label_inline`` -- boolean (default: False if fill is True,\n\t\totherwise True), controls whether the underlying contour is\n\t\tremoved or not.\n\n\t  - ``label_inline_spacing`` -- integer (default: 3), When inline,\n\t\tthis is the amount of contour that is removed from each side,\n\t\tin pixels.\n\n\t  - ``label_fmt`` -- a format string (default: \"%1.2f\"), this is\n\t\tused to get the label text from the level.  This can also be a\n\t\tdictionary with the contour levels as keys and corresponding\n\t\ttext string labels as values.  It can also be any callable which\n\t\treturns a string when called with a numeric contour level.\n\n\t- ``colorbar`` -- boolean (default: False) Show a colorbar or not.\n\n\t  The following options are to adjust the style and placement of\n\t  colorbars.  They have no effect if a colorbar is not shown.\n\n\t  - ``colorbar_orientation`` -- string (default: 'vertical'),\n\t\tcontrols placement of the colorbar, can be either 'vertical'\n\t\tor 'horizontal'\n\n\t  - ``colorbar_format`` -- a format string, this is used to format\n\t\tthe colorbar labels.\n\n\t  - ``colorbar_spacing`` -- string (default: 'proportional').  If\n\t\t'proportional', make the contour divisions proportional to\n\t\tvalues.  If 'uniform', space the colorbar divisions uniformly,\n\t\twithout regard for numeric values.\n\n\t- ``legend_label`` -- the label for this item in the legend\n\n\t-  ``region`` - (default: None) If region is given, it must be a function\n\t\tof two variables. Only segments of the surface where region(x,y) returns a\n\t\tnumber >0 will be included in the plot.\n\n\tEXAMPLES:\n\n\tHere we plot a simple function of two variables.  Note that\n\tsince the input function is an expression, we need to explicitly\n\tdeclare the variables in 3-tuples for the range::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: contour_plot(cos(x^2+y^2), (x, -4, 4), (y, -4, 4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere we change the ranges and add some options::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: contour_plot((x^2)*cos(x*y), (x, -10, 5), (y, -5, 5), fill=False, plot_points=150)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAn even more complicated plot::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: contour_plot(sin(x^2 + y^2)*cos(x)*sin(y), (x, -4, 4), (y, -4, 4),plot_points=150)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tSome elliptic curves, but with symbolic endpoints.  In the first\n\texample, the plot is rotated 90 degrees because we switch the\n\tvariables `x`, `y`::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: contour_plot(y^2 + 1 - x^3 - x, (y,-pi,pi), (x,-pi,pi))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(y^2 + 1 - x^3 - x, (x,-pi,pi), (y,-pi,pi))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can play with the contour levels::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: f(x,y) = x^2 + y^2\n\t\tsage: contour_plot(f, (-2, 2), (-2, 2))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (-2, 2), (-2, 2), contours=2, cmap=[(1,0,0), (0,1,0), (0,0,1)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (-2, 2), (-2, 2), contours=(0.1, 1.0, 1.2, 1.4), cmap='hsv')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (-2, 2), (-2, 2), contours=(1.0,), fill=False)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(x-y^2,(x,-5,5),(y,-3,3),contours=[-4,0,1])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can change the style of the lines::\n\n\t\tsage: contour_plot(f, (-2,2), (-2,2), fill=False, linewidths=10)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (-2,2), (-2,2), fill=False, linestyles='dashdot')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: P=contour_plot(x^2-y^2,(x,-3,3),(y,-3,3),contours=[0,1,2,3,4],\\\n\t\t...\tlinewidths=[1,5],linestyles=['solid','dashed'],fill=False)\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: P=contour_plot(x^2-y^2,(x,-3,3),(y,-3,3),contours=[0,1,2,3,4],\\\n\t\t...\tlinewidths=[1,5],linestyles=['solid','dashed'])\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: P=contour_plot(x^2-y^2,(x,-3,3),(y,-3,3),contours=[0,1,2,3,4],\\\n\t\t...\tlinewidths=[1,5],linestyles=['-',':'])\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can add labels and play with them::\n\n\t\tsage: contour_plot(y^2 + 1 - x^3 - x, (x,-pi,pi), (y,-pi,pi),  fill=False, cmap='hsv', labels=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: P=contour_plot(y^2 + 1 - x^3 - x, (x,-pi,pi), (y,-pi,pi), fill=False, cmap='hsv',\\\n\t\t...\t labels=True, label_fmt=\"%1.0f\", label_colors='black')\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: P=contour_plot(y^2 + 1 - x^3 - x, (x,-pi,pi), (y,-pi,pi), fill=False, cmap='hsv',labels=True,\\\n\t\t...\tcontours=[-4,0,4],  label_fmt={-4:\"low\", 0:\"medium\", 4: \"hi\"}, label_colors='black')\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: P=contour_plot(y^2 + 1 - x^3 - x, (x,-pi,pi), (y,-pi,pi), fill=False, cmap='hsv',labels=True,\\\n\t\t...\tcontours=[-4,0,4],  label_fmt=lambda x: \"$z=%s$\"%x, label_colors='black', label_inline=True, \\\n\t\t...\tlabel_fontsize=12)\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: P=contour_plot(y^2 + 1 - x^3 - x, (x,-pi,pi), (y,-pi,pi), \\\n\t\t...\tfill=False, cmap='hsv', labels=True, label_fontsize=18)\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: P=contour_plot(y^2 + 1 - x^3 - x, (x,-pi,pi), (y,-pi,pi), \\\n\t\t...\tfill=False, cmap='hsv', labels=True, label_inline_spacing=1)\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: P= contour_plot(y^2 + 1 - x^3 - x, (x,-pi,pi), (y,-pi,pi), \\\n\t\t...\tfill=False, cmap='hsv', labels=True, label_inline=False)\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can change the color of the labels if so desired::\n\n\t\tsage: contour_plot(f, (-2,2), (-2,2), labels=True, label_colors='red')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can add a colorbar as well::\n\n\t\tsage: f(x,y)=x^2-y^2\n\t\tsage: contour_plot(f, (x,-3,3), (y,-3,3), colorbar=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (x,-3,3), (y,-3,3), colorbar=True,colorbar_orientation='horizontal')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (x,-3,3), (y,-3,3), contours=[-2,-1,4],colorbar=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (x,-3,3), (y,-3,3), contours=[-2,-1,4],colorbar=True,colorbar_spacing='uniform')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (x,-3,3), (y,-3,3), contours=[0,2,3,6],colorbar=True,colorbar_format='%.3f')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (x,-3,3), (y,-3,3), labels=True,label_colors='red',contours=[0,2,3,6],colorbar=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (x,-3,3), (y,-3,3), cmap='winter', contours=20, fill=False, colorbar=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tThis should plot concentric circles centered at the origin::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: contour_plot(x^2+y^2-2,(x,-1,1), (y,-1,1))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tExtra options will get passed on to show(), as long as they are valid::\n\n\t\tsage: f(x, y) = cos(x) + sin(y)\n\t\tsage: contour_plot(f, (0, pi), (0, pi), axes=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tOne can also plot over a reduced region::\n\n\t\tsage: contour_plot(x**2-y**2, (x,-2, 2), (y,-2, 2),region=x-y,plot_points=300)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (0, pi), (0, pi)).show(axes=True) # These are equivalent\n\n\tNote that with ``fill=False`` and grayscale contours, there is the\n\tpossibility of confusion between the contours and the axes, so use\n\t``fill=False`` together with ``axes=True`` with caution::\n\n\t\tsage: contour_plot(f, (-pi, pi), (-pi, pi), fill=False, axes=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tTESTS:\n\n\tTo check that :trac:`5221` is fixed, note that this has three curves, not two::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: contour_plot(x-y^2,(x,-5,5),(y,-3,3),contours=[-4,-2,0], fill=False)\n\t\tGraphics object consisting of 1 graphics primitive\n\t\"\"\"\n\tfrom sage.plot.all import Graphics\n\tfrom sage.plot.misc import setup_for_eval_on_grid\n\n\tregion = options.pop('region')\n\tev = [f] if region is None else [f,region]\n\n\tF, ranges = setup_for_eval_on_grid(ev, [xrange, yrange], options['plot_points'])\n\tg = F[0]\n\txrange,yrange=[r[:2] for r in ranges]\n\n\txy_data_array = [[g(x, y) for x in xsrange(*ranges[0], include_endpoint=True)]\n\t\t\t\t\t\t\t  for y in xsrange(*ranges[1], include_endpoint=True)]\n\n\tif region is not None:\n\t\timport numpy\n\n\t\txy_data_array = numpy.ma.asarray(xy_data_array,dtype=float)\n\n\t\tm = F[1]\n\n\t\tmask = numpy.asarray([[m(x, y)<=0 for x in xsrange(*ranges[0], include_endpoint=True)]\n\t\t\t\t\t\t\t\t\t\t  for y in xsrange(*ranges[1], include_endpoint=True)],dtype=bool)\n\n\t\txy_data_array[mask] = numpy.ma.masked\n\n\tg = Graphics()\n\n\t# Reset aspect_ratio to 'automatic' in case scale is 'semilog[xy]'.\n\t# Otherwise matplotlib complains.\n\tscale = options.get('scale', None)\n\tif isinstance(scale, (list, tuple)):\n\t\tscale = scale[0]\n\tif scale == 'semilogy' or scale == 'semilogx':\n\t\toptions['aspect_ratio'] = 'automatic'\n\n\tg._set_extra_kwds(Graphics._extract_kwds_for_show(options, ignore=['xmin', 'xmax']))\n\tg.add_primitive(ContourPlot(xy_data_array, xrange, yrange, options))\n\treturn g\n", "description": "\n\t``contour_plot`` takes a function of two variables, `f(x,y)`\n\tand plots contour lines of the function over the specified\n\t``xrange`` and ``yrange`` as demonstrated below.\n\n\t``contour_plot(f, (xmin, xmax), (ymin, ymax), ...)``\n\n\tINPUT:\n\n\t- ``f`` -- a function of two variables\n\n\t- ``(xmin, xmax)`` -- 2-tuple, the range of ``x`` values OR 3-tuple\n\t  ``(x,xmin,xmax)``\n\n\t- ``(ymin, ymax)`` -- 2-tuple, the range of ``y`` values OR 3-tuple\n\t  ``(y,ymin,ymax)``\n\n\tThe following inputs must all be passed in as named parameters:\n\n\t- ``plot_points``  -- integer (default: 100); number of points to plot\n\t  in each direction of the grid.  For old computers, 25 is fine, but\n\t  should not be used to verify specific intersection points.\n\n\t- ``fill`` -- bool (default: ``True``), whether to color in the area\n\t  between contour lines\n\n\t- ``cmap`` -- a colormap (default: ``'gray'``), the name of\n\t  a predefined colormap, a list of colors or an instance of a matplotlib\n\t  Colormap. Type: ``import matplotlib.cm; matplotlib.cm.datad.keys()``\n\t  for available colormap names.\n\n\t- ``contours`` -- integer or list of numbers (default: ``None``):\n\t  If a list of numbers is given, then this specifies the contour levels\n\t  to use.  If an integer is given, then this many contour lines are\n\t  used, but the exact levels are determined automatically. If ``None``\n\t  is passed (or the option is not given), then the number of contour\n\t  lines is determined automatically, and is usually about 5.\n\n\t- ``linewidths`` -- integer or list of integer (default: None), if\n\t  a single integer all levels will be of the width given,\n\t  otherwise the levels will be plotted with the width in the order\n\t  given.  If the list is shorter than the number of contours, then\n\t  the widths will be repeated cyclically.\n\n\t- ``linestyles`` -- string or list of strings (default: None), the\n\t  style of the lines to be plotted, one of: ``\"solid\"``, ``\"dashed\"``,\n\t  ``\"dashdot\"``, ``\"dotted\"``, respectively ``\"-\"``, ``\"--\"``,\n\t  ``\"-.\"``, ``\":\"``.  If the list is shorter than the number of\n\t  contours, then the styles will be repeated cyclically.\n\n\t- ``labels`` -- boolean (default: False) Show level labels or not.\n\n\t  The following options are to adjust the style and placement of\n\t  labels, they have no effect if no labels are shown.\n\n\t  - ``label_fontsize`` -- integer (default: 9), the font size of the labels.\n\n\t  - ``label_colors`` -- string or sequence of colors (default:\n\t\tNone) If a string, gives the name of a single color with which\n\t\tto draw all labels.  If a sequence, gives the colors of the\n\t\tlabels.  A color is a string giving the name of one or a\n\t\t3-tuple of floats.\n\n\t  - ``label_inline`` -- boolean (default: False if fill is True,\n\t\totherwise True), controls whether the underlying contour is\n\t\tremoved or not.\n\n\t  - ``label_inline_spacing`` -- integer (default: 3), When inline,\n\t\tthis is the amount of contour that is removed from each side,\n\t\tin pixels.\n\n\t  - ``label_fmt`` -- a format string (default: \"%1.2f\"), this is\n\t\tused to get the label text from the level.  This can also be a\n\t\tdictionary with the contour levels as keys and corresponding\n\t\ttext string labels as values.  It can also be any callable which\n\t\treturns a string when called with a numeric contour level.\n\n\t- ``colorbar`` -- boolean (default: False) Show a colorbar or not.\n\n\t  The following options are to adjust the style and placement of\n\t  colorbars.  They have no effect if a colorbar is not shown.\n\n\t  - ``colorbar_orientation`` -- string (default: 'vertical'),\n\t\tcontrols placement of the colorbar, can be either 'vertical'\n\t\tor 'horizontal'\n\n\t  - ``colorbar_format`` -- a format string, this is used to format\n\t\tthe colorbar labels.\n\n\t  - ``colorbar_spacing`` -- string (default: 'proportional').  If\n\t\t'proportional', make the contour divisions proportional to\n\t\tvalues.  If 'uniform', space the colorbar divisions uniformly,\n\t\twithout regard for numeric values.\n\n\t- ``legend_label`` -- the label for this item in the legend\n\n\t-  ``region`` - (default: None) If region is given, it must be a function\n\t\tof two variables. Only segments of the surface where region(x,y) returns a\n\t\tnumber >0 will be included in the plot.\n\n\tEXAMPLES:\n\n\tHere we plot a simple function of two variables.  Note that\n\tsince the input function is an expression, we need to explicitly\n\tdeclare the variables in 3-tuples for the range::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: contour_plot(cos(x^2+y^2), (x, -4, 4), (y, -4, 4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere we change the ranges and add some options::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: contour_plot((x^2)*cos(x*y), (x, -10, 5), (y, -5, 5), fill=False, plot_points=150)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAn even more complicated plot::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: contour_plot(sin(x^2 + y^2)*cos(x)*sin(y), (x, -4, 4), (y, -4, 4),plot_points=150)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tSome elliptic curves, but with symbolic endpoints.  In the first\n\texample, the plot is rotated 90 degrees because we switch the\n\tvariables `x`, `y`::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: contour_plot(y^2 + 1 - x^3 - x, (y,-pi,pi), (x,-pi,pi))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(y^2 + 1 - x^3 - x, (x,-pi,pi), (y,-pi,pi))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can play with the contour levels::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: f(x,y) = x^2 + y^2\n\t\tsage: contour_plot(f, (-2, 2), (-2, 2))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (-2, 2), (-2, 2), contours=2, cmap=[(1,0,0), (0,1,0), (0,0,1)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (-2, 2), (-2, 2), contours=(0.1, 1.0, 1.2, 1.4), cmap='hsv')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (-2, 2), (-2, 2), contours=(1.0,), fill=False)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(x-y^2,(x,-5,5),(y,-3,3),contours=[-4,0,1])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can change the style of the lines::\n\n\t\tsage: contour_plot(f, (-2,2), (-2,2), fill=False, linewidths=10)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (-2,2), (-2,2), fill=False, linestyles='dashdot')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: P=contour_plot(x^2-y^2,(x,-3,3),(y,-3,3),contours=[0,1,2,3,4],\\\n\t\t...\tlinewidths=[1,5],linestyles=['solid','dashed'],fill=False)\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: P=contour_plot(x^2-y^2,(x,-3,3),(y,-3,3),contours=[0,1,2,3,4],\\\n\t\t...\tlinewidths=[1,5],linestyles=['solid','dashed'])\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: P=contour_plot(x^2-y^2,(x,-3,3),(y,-3,3),contours=[0,1,2,3,4],\\\n\t\t...\tlinewidths=[1,5],linestyles=['-',':'])\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can add labels and play with them::\n\n\t\tsage: contour_plot(y^2 + 1 - x^3 - x, (x,-pi,pi), (y,-pi,pi),  fill=False, cmap='hsv', labels=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: P=contour_plot(y^2 + 1 - x^3 - x, (x,-pi,pi), (y,-pi,pi), fill=False, cmap='hsv',\\\n\t\t...\t labels=True, label_fmt=\"%1.0f\", label_colors='black')\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: P=contour_plot(y^2 + 1 - x^3 - x, (x,-pi,pi), (y,-pi,pi), fill=False, cmap='hsv',labels=True,\\\n\t\t...\tcontours=[-4,0,4],  label_fmt={-4:\"low\", 0:\"medium\", 4: \"hi\"}, label_colors='black')\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: P=contour_plot(y^2 + 1 - x^3 - x, (x,-pi,pi), (y,-pi,pi), fill=False, cmap='hsv',labels=True,\\\n\t\t...\tcontours=[-4,0,4],  label_fmt=lambda x: \"$z=%s$\"%x, label_colors='black', label_inline=True, \\\n\t\t...\tlabel_fontsize=12)\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: P=contour_plot(y^2 + 1 - x^3 - x, (x,-pi,pi), (y,-pi,pi), \\\n\t\t...\tfill=False, cmap='hsv', labels=True, label_fontsize=18)\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: P=contour_plot(y^2 + 1 - x^3 - x, (x,-pi,pi), (y,-pi,pi), \\\n\t\t...\tfill=False, cmap='hsv', labels=True, label_inline_spacing=1)\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: P= contour_plot(y^2 + 1 - x^3 - x, (x,-pi,pi), (y,-pi,pi), \\\n\t\t...\tfill=False, cmap='hsv', labels=True, label_inline=False)\n\t\tsage: P\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can change the color of the labels if so desired::\n\n\t\tsage: contour_plot(f, (-2,2), (-2,2), labels=True, label_colors='red')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can add a colorbar as well::\n\n\t\tsage: f(x,y)=x^2-y^2\n\t\tsage: contour_plot(f, (x,-3,3), (y,-3,3), colorbar=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (x,-3,3), (y,-3,3), colorbar=True,colorbar_orientation='horizontal')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (x,-3,3), (y,-3,3), contours=[-2,-1,4],colorbar=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (x,-3,3), (y,-3,3), contours=[-2,-1,4],colorbar=True,colorbar_spacing='uniform')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (x,-3,3), (y,-3,3), contours=[0,2,3,6],colorbar=True,colorbar_format='%.3f')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (x,-3,3), (y,-3,3), labels=True,label_colors='red',contours=[0,2,3,6],colorbar=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (x,-3,3), (y,-3,3), cmap='winter', contours=20, fill=False, colorbar=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tThis should plot concentric circles centered at the origin::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: contour_plot(x^2+y^2-2,(x,-1,1), (y,-1,1))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tExtra options will get passed on to show(), as long as they are valid::\n\n\t\tsage: f(x, y) = cos(x) + sin(y)\n\t\tsage: contour_plot(f, (0, pi), (0, pi), axes=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tOne can also plot over a reduced region::\n\n\t\tsage: contour_plot(x**2-y**2, (x,-2, 2), (y,-2, 2),region=x-y,plot_points=300)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: contour_plot(f, (0, pi), (0, pi)).show(axes=True) # These are equivalent\n\n\tNote that with ``fill=False`` and grayscale contours, there is the\n\tpossibility of confusion between the contours and the axes, so use\n\t``fill=False`` together with ``axes=True`` with caution::\n\n\t\tsage: contour_plot(f, (-pi, pi), (-pi, pi), fill=False, axes=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tTESTS:\n\n\tTo check that :trac:`5221` is fixed, note that this has three curves, not two::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: contour_plot(x-y^2,(x,-5,5),(y,-3,3),contours=[-4,-2,0], fill=False)\n\t\tGraphics object consisting of 1 graphics primitive\n\t", "category": "graphics", "imports": ["from sage.plot.primitive import GraphicPrimitive", "from sage.misc.decorators import options, suboptions", "from sage.plot.colors import rgbcolor, get_cmap", "from sage.misc.misc import xsrange", "import operator", "\t\tsage: from sage.plot.contour_plot import ContourPlot", "\t\tfrom sage.plot.plot import minmax_data", "\t\t\t\t\t\tmatplotlib Colormap. Type: import matplotlib.cm; matplotlib.cm.datad.keys()", "\t\tfrom sage.rings.integer import Integer", "\t\tfrom sage.plot.misc import get_matplotlib_linestyle", "\t\t\tfrom matplotlib import colorbar", "\t  Colormap. Type: ``import matplotlib.cm; matplotlib.cm.datad.keys()``", "\tfrom sage.plot.all import Graphics", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\timport numpy", "\tfrom sage.symbolic.expression import is_SymbolicEquation", "\t\tfrom sage.symbolic.expression import is_Expression", "\tfrom matplotlib.colors import ListedColormap", "\t\tsage: from sage.plot.contour_plot import equify", "\timport operator", "\tfrom sage.calculus.all import symbolic_expression", "\tfrom sage.symbolic.expression import is_Expression"]}, {"term": "def", "name": "implicit_plot", "data": "def implicit_plot(f, xrange, yrange, **options):\n\tr\"\"\"\n\t``implicit_plot`` takes a function of two variables, `f(x,y)`\n\tand plots the curve `f(x,y) = 0` over the specified\n\t``xrange`` and ``yrange`` as demonstrated below.\n\n\t``implicit_plot(f, (xmin, xmax), (ymin, ymax), ...)``\n\n\t``implicit_plot(f, (x, xmin, xmax), (y, ymin, ymax), ...)``\n\n\tINPUT:\n\n\t- ``f`` -- a function of two variables or equation in two variables\n\n\t- ``(xmin, xmax)`` -- 2-tuple, the range of ``x`` values or ``(x,xmin,xmax)``\n\n\t- ``(ymin, ymax)`` -- 2-tuple, the range of ``y`` values or ``(y,ymin,ymax)``\n\n\tThe following inputs must all be passed in as named parameters:\n\n\t- ``plot_points`` -- integer (default: 150); number of points to plot\n\t  in each direction of the grid\n\n\t- ``fill`` -- boolean (default: ``False``); if ``True``, fill the region\n\t  `f(x,y) < 0`.\n\n\t- ``linewidth`` -- integer (default: None), if a single integer all levels\n\t  will be of the width given, otherwise the levels will be plotted with the\n\t  widths in the order given.\n\n\t- ``linestyle`` -- string (default: None), the style of the line to be\n\t  plotted, one of: ``\"solid\"``, ``\"dashed\"``, ``\"dashdot\"`` or\n\t  ``\"dotted\"``, respectively ``\"-\"``, ``\"--\"``, ``\"-.\"``, or ``\":\"``.\n\n\t- ``color`` -- string (default: ``blue``), the color of the plot. Colors are\n\t  defined in :mod:`sage.plot.colors`; try ``colors?`` to see them all.\n\n\t- ``legend_label`` -- the label for this item in the legend\n\n\t- ``base`` - (default: 10) the base of the logarithm if\n\t  a logarithmic scale is set. This must be greater than 1. The base\n\t  can be also given as a list or tuple ``(basex, basey)``.\n\t  ``basex`` sets the base of the logarithm along the horizontal\n\t  axis and ``basey`` sets the base along the vertical axis.\n\n\t- ``scale`` -- (default: ``\"linear\"``) string. The scale of the axes.\n\t  Possible values are ``\"linear\"``, ``\"loglog\"``, ``\"semilogx\"``,\n\t  ``\"semilogy\"``.\n\n\t  The scale can be also be given as single argument that is a list\n\t  or tuple ``(scale, base)`` or ``(scale, basex, basey)``.\n\n\t  The ``\"loglog\"`` scale sets both the horizontal and vertical axes to\n\t  logarithmic scale. The ``\"semilogx\"`` scale sets the horizontal axis\n\t  to logarithmic scale. The ``\"semilogy\"`` scale sets the vertical axis\n\t  to logarithmic scale. The ``\"linear\"`` scale is the default value\n\t  when :class:`~sage.plot.graphics.Graphics` is initialized.\n\n\tEXAMPLES:\n\n\tA simple circle with a radius of 2. Note that\n\tsince the input function is an expression, we need to explicitly\n\tdeclare the variables in 3-tuples for the range::\n\n\t\tsage: var(\"x y\")\n\t\t(x, y)\n\t\tsage: implicit_plot(x^2+y^2-2, (x,-3,3), (y,-3,3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tI can do the same thing, but using a callable function so I don't need\n\tto explicitly define the variables in the ranges, and filling the inside::\n\n\t\tsage: f(x,y) = x^2 + y^2 - 2\n\t\tsage: implicit_plot(f, (-3, 3), (-3, 3),fill=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tThe same circle but with a different line width::\n\n\t\tsage: implicit_plot(f, (-3,3), (-3,3), linewidth=6)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAnd again the same circle but this time with a dashdot border::\n\n\t\tsage: implicit_plot(f, (-3,3), (-3,3), linestyle='dashdot')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tYou can also plot an equation::\n\n\t\tsage: var(\"x y\")\n\t\t(x, y)\n\t\tsage: implicit_plot(x^2+y^2 == 2, (x,-3,3), (y,-3,3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tYou can even change the color of the plot::\n\n\t\tsage: implicit_plot(x^2+y^2 == 2, (x,-3,3), (y,-3,3), color=\"red\")\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere is a beautiful (and long) example which also tests that all\n\tcolors work with this::\n\n\t\tsage: G = Graphics()\n\t\tsage: counter = 0\n\t\tsage: for col in colors.keys(): # long time\n\t\t...\t   G += implicit_plot(x^2+y^2==1+counter*.1, (x,-4,4),(y,-4,4),color=col)\n\t\t...\t   counter += 1\n\t\tsage: G.show(frame=False)\n\n\tWe can define a level-`n` approximation of the boundary of the\n\tMandelbrot set::\n\n\t\tsage: def mandel(n):\n\t\t...\t   c = polygen(CDF, 'c')\n\t\t...\t   z = 0\n\t\t...\t   for i in range(n):\n\t\t...\t\t   z = z*z + c\n\t\t...\t   def f(x, y):\n\t\t...\t\t   val = z(CDF(x, y))\n\t\t...\t\t   return val.norm() - 4\n\t\t...\t   return f\n\n\tThe first-level approximation is just a circle::\n\n\t\tsage: implicit_plot(mandel(1), (-3, 3), (-3, 3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA third-level approximation starts to get interesting::\n\n\t\tsage: implicit_plot(mandel(3), (-2, 1), (-1.5, 1.5))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tThe seventh-level approximation is a degree 64 polynomial, and\n\t``implicit_plot`` does a pretty good job on this part of the curve.\n\t(``plot_points=200`` looks even better, but it takes over a second.)\n\n\t::\n\n\t\tsage: implicit_plot(mandel(7), (-0.3, 0.05), (-1.15, -0.9),plot_points=50)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWhen making a filled implicit plot using a python function rather than a\n\tsymbolic expression the user should increase the number of plot points to\n\tavoid artifacts::\n\n\t\tsage: implicit_plot(lambda x,y: x^2+y^2-2, (x,-3,3), (y,-3,3), fill=True, plot_points=500) # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAn example of an implicit plot on 'loglog' scale::\n\n\t\tsage: implicit_plot(x^2+y^2 == 200, (x,1,200), (y,1,200), scale='loglog')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tTESTS::\n\n\t\tsage: f(x,y) = x^2 + y^2 - 2\n\t\tsage: implicit_plot(f, (-3, 3), (-3, 3),fill=5)\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: fill=5 is not supported\n\t\"\"\"\n\tfrom sage.symbolic.expression import is_SymbolicEquation\n\tif is_SymbolicEquation(f):\n\t\tif f.operator() != operator.eq:\n\t\t\traise ValueError(\"input to implicit plot must be function or equation\")\n\t\tf = f.lhs() - f.rhs()\n\tlinewidths = options.pop('linewidth', None)\n\tlinestyles = options.pop('linestyle', None)\n\n\tif 'color' in options:\n\t\toptions['cmap']=[options.pop('color', None)]\n\n\tif options['fill'] is True:\n\t\toptions.pop('fill')\n\t\toptions.pop('contours',None)\n\t\toptions.pop('cmap',None)\n\t\tfrom sage.symbolic.expression import is_Expression\n\t\tif not is_Expression(f):\n\t\t\treturn region_plot(lambda x,y: f(x,y)<0, xrange, yrange,\n\t\t\t\t\t\t\t   borderwidth=linewidths, borderstyle=linestyles,\n\t\t\t\t\t\t\t   **options)\n\t\telse:\n\t\t\treturn region_plot(f<0, xrange, yrange, borderwidth=linewidths,\n\t\t\t\t\t\t\t   borderstyle=linestyles, **options)\n\telif options['fill'] is False:\n\t\treturn contour_plot(f, xrange, yrange, linewidths=linewidths,\n\t\t\t\t\t\t\tlinestyles=linestyles, **options)\n\telse:\n\t\traise ValueError(\"fill=%s is not supported\" % options['fill'])\n\n", "description": "\n\t``implicit_plot`` takes a function of two variables, `f(x,y)`\n\tand plots the curve `f(x,y) = 0` over the specified\n\t``xrange`` and ``yrange`` as demonstrated below.\n\n\t``implicit_plot(f, (xmin, xmax), (ymin, ymax), ...)``\n\n\t``implicit_plot(f, (x, xmin, xmax), (y, ymin, ymax), ...)``\n\n\tINPUT:\n\n\t- ``f`` -- a function of two variables or equation in two variables\n\n\t- ``(xmin, xmax)`` -- 2-tuple, the range of ``x`` values or ``(x,xmin,xmax)``\n\n\t- ``(ymin, ymax)`` -- 2-tuple, the range of ``y`` values or ``(y,ymin,ymax)``\n\n\tThe following inputs must all be passed in as named parameters:\n\n\t- ``plot_points`` -- integer (default: 150); number of points to plot\n\t  in each direction of the grid\n\n\t- ``fill`` -- boolean (default: ``False``); if ``True``, fill the region\n\t  `f(x,y) < 0`.\n\n\t- ``linewidth`` -- integer (default: None), if a single integer all levels\n\t  will be of the width given, otherwise the levels will be plotted with the\n\t  widths in the order given.\n\n\t- ``linestyle`` -- string (default: None), the style of the line to be\n\t  plotted, one of: ``\"solid\"``, ``\"dashed\"``, ``\"dashdot\"`` or\n\t  ``\"dotted\"``, respectively ``\"-\"``, ``\"--\"``, ``\"-.\"``, or ``\":\"``.\n\n\t- ``color`` -- string (default: ``blue``), the color of the plot. Colors are\n\t  defined in :mod:`sage.plot.colors`; try ``colors?`` to see them all.\n\n\t- ``legend_label`` -- the label for this item in the legend\n\n\t- ``base`` - (default: 10) the base of the logarithm if\n\t  a logarithmic scale is set. This must be greater than 1. The base\n\t  can be also given as a list or tuple ``(basex, basey)``.\n\t  ``basex`` sets the base of the logarithm along the horizontal\n\t  axis and ``basey`` sets the base along the vertical axis.\n\n\t- ``scale`` -- (default: ``\"linear\"``) string. The scale of the axes.\n\t  Possible values are ``\"linear\"``, ``\"loglog\"``, ``\"semilogx\"``,\n\t  ``\"semilogy\"``.\n\n\t  The scale can be also be given as single argument that is a list\n\t  or tuple ``(scale, base)`` or ``(scale, basex, basey)``.\n\n\t  The ``\"loglog\"`` scale sets both the horizontal and vertical axes to\n\t  logarithmic scale. The ``\"semilogx\"`` scale sets the horizontal axis\n\t  to logarithmic scale. The ``\"semilogy\"`` scale sets the vertical axis\n\t  to logarithmic scale. The ``\"linear\"`` scale is the default value\n\t  when :class:`~sage.plot.graphics.Graphics` is initialized.\n\n\tEXAMPLES:\n\n\tA simple circle with a radius of 2. Note that\n\tsince the input function is an expression, we need to explicitly\n\tdeclare the variables in 3-tuples for the range::\n\n\t\tsage: var(\"x y\")\n\t\t(x, y)\n\t\tsage: implicit_plot(x^2+y^2-2, (x,-3,3), (y,-3,3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tI can do the same thing, but using a callable function so I don't need\n\tto explicitly define the variables in the ranges, and filling the inside::\n\n\t\tsage: f(x,y) = x^2 + y^2 - 2\n\t\tsage: implicit_plot(f, (-3, 3), (-3, 3),fill=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tThe same circle but with a different line width::\n\n\t\tsage: implicit_plot(f, (-3,3), (-3,3), linewidth=6)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAnd again the same circle but this time with a dashdot border::\n\n\t\tsage: implicit_plot(f, (-3,3), (-3,3), linestyle='dashdot')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tYou can also plot an equation::\n\n\t\tsage: var(\"x y\")\n\t\t(x, y)\n\t\tsage: implicit_plot(x^2+y^2 == 2, (x,-3,3), (y,-3,3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tYou can even change the color of the plot::\n\n\t\tsage: implicit_plot(x^2+y^2 == 2, (x,-3,3), (y,-3,3), color=\"red\")\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere is a beautiful (and long) example which also tests that all\n\tcolors work with this::\n\n\t\tsage: G = Graphics()\n\t\tsage: counter = 0\n\t\tsage: for col in colors.keys(): # long time\n\t\t...\t   G += implicit_plot(x^2+y^2==1+counter*.1, (x,-4,4),(y,-4,4),color=col)\n\t\t...\t   counter += 1\n\t\tsage: G.show(frame=False)\n\n\tWe can define a level-`n` approximation of the boundary of the\n\tMandelbrot set::\n\n\t\tsage: def mandel(n):\n\t\t...\t   c = polygen(CDF, 'c')\n\t\t...\t   z = 0\n\t\t...\t   for i in range(n):\n\t\t...\t\t   z = z*z + c\n\t\t...\t   def f(x, y):\n\t\t...\t\t   val = z(CDF(x, y))\n\t\t...\t\t   return val.norm() - 4\n\t\t...\t   return f\n\n\tThe first-level approximation is just a circle::\n\n\t\tsage: implicit_plot(mandel(1), (-3, 3), (-3, 3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA third-level approximation starts to get interesting::\n\n\t\tsage: implicit_plot(mandel(3), (-2, 1), (-1.5, 1.5))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tThe seventh-level approximation is a degree 64 polynomial, and\n\t``implicit_plot`` does a pretty good job on this part of the curve.\n\t(``plot_points=200`` looks even better, but it takes over a second.)\n\n\t::\n\n\t\tsage: implicit_plot(mandel(7), (-0.3, 0.05), (-1.15, -0.9),plot_points=50)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWhen making a filled implicit plot using a python function rather than a\n\tsymbolic expression the user should increase the number of plot points to\n\tavoid artifacts::\n\n\t\tsage: implicit_plot(lambda x,y: x^2+y^2-2, (x,-3,3), (y,-3,3), fill=True, plot_points=500) # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAn example of an implicit plot on 'loglog' scale::\n\n\t\tsage: implicit_plot(x^2+y^2 == 200, (x,1,200), (y,1,200), scale='loglog')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tTESTS::\n\n\t\tsage: f(x,y) = x^2 + y^2 - 2\n\t\tsage: implicit_plot(f, (-3, 3), (-3, 3),fill=5)\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: fill=5 is not supported\n\t", "category": "graphics", "imports": ["from sage.plot.primitive import GraphicPrimitive", "from sage.misc.decorators import options, suboptions", "from sage.plot.colors import rgbcolor, get_cmap", "from sage.misc.misc import xsrange", "import operator", "\t\tsage: from sage.plot.contour_plot import ContourPlot", "\t\tfrom sage.plot.plot import minmax_data", "\t\t\t\t\t\tmatplotlib Colormap. Type: import matplotlib.cm; matplotlib.cm.datad.keys()", "\t\tfrom sage.rings.integer import Integer", "\t\tfrom sage.plot.misc import get_matplotlib_linestyle", "\t\t\tfrom matplotlib import colorbar", "\t  Colormap. Type: ``import matplotlib.cm; matplotlib.cm.datad.keys()``", "\tfrom sage.plot.all import Graphics", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\timport numpy", "\tfrom sage.symbolic.expression import is_SymbolicEquation", "\t\tfrom sage.symbolic.expression import is_Expression", "\tfrom matplotlib.colors import ListedColormap", "\t\tsage: from sage.plot.contour_plot import equify", "\timport operator", "\tfrom sage.calculus.all import symbolic_expression", "\tfrom sage.symbolic.expression import is_Expression"]}, {"term": "def", "name": "region_plot", "data": "def region_plot(f, xrange, yrange, plot_points, incol, outcol, bordercol, borderstyle, borderwidth, alpha, **options):\n\tr\"\"\"\n\t``region_plot`` takes a boolean function of two variables, `f(x,y)`\n\tand plots the region where f is True over the specified\n\t``xrange`` and ``yrange`` as demonstrated below.\n\n\t``region_plot(f, (xmin, xmax), (ymin, ymax), ...)``\n\n\tINPUT:\n\n\t- ``f`` -- a boolean function or a list of boolean functions of two variables\n\n\t- ``(xmin, xmax)`` -- 2-tuple, the range of ``x`` values OR 3-tuple\n\t  ``(x,xmin,xmax)``\n\n\t- ``(ymin, ymax)`` -- 2-tuple, the range of ``y`` values OR 3-tuple\n\t  ``(y,ymin,ymax)``\n\n\t- ``plot_points``  -- integer (default: 100); number of points to plot\n\t  in each direction of the grid\n\n\t- ``incol`` -- a color (default: ``'blue'``), the color inside the region\n\n\t- ``outcol`` -- a color (default: ``None``), the color of the outside\n\t  of the region\n\n\tIf any of these options are specified, the border will be shown as indicated,\n\totherwise it is only implicit (with color ``incol``) as the border of the\n\tinside of the region.\n\n\t - ``bordercol`` -- a color (default: ``None``), the color of the border\n\t   (``'black'`` if ``borderwidth`` or ``borderstyle`` is specified but not ``bordercol``)\n\n\t- ``borderstyle``  -- string (default: 'solid'), one of ``'solid'``,\n\t  ``'dashed'``, ``'dotted'``, ``'dashdot'``, respectively ``'-'``,\n\t  ``'--'``, ``':'``, ``'-.'``.\n\n\t- ``borderwidth``  -- integer (default: None), the width of the border in pixels\n\n\t- ``alpha`` -- (default: 1) How transparent the fill is. A number between 0 and 1.\n\n\t- ``legend_label`` -- the label for this item in the legend\n\n\t- ``base`` - (default: 10) the base of the logarithm if\n\t  a logarithmic scale is set. This must be greater than 1. The base\n\t  can be also given as a list or tuple ``(basex, basey)``.\n\t  ``basex`` sets the base of the logarithm along the horizontal\n\t  axis and ``basey`` sets the base along the vertical axis.\n\n\t- ``scale`` -- (default: ``\"linear\"``) string. The scale of the axes.\n\t  Possible values are ``\"linear\"``, ``\"loglog\"``, ``\"semilogx\"``,\n\t  ``\"semilogy\"``.\n\n\t  The scale can be also be given as single argument that is a list\n\t  or tuple ``(scale, base)`` or ``(scale, basex, basey)``.\n\n\t  The ``\"loglog\"`` scale sets both the horizontal and vertical axes to\n\t  logarithmic scale. The ``\"semilogx\"`` scale sets the horizontal axis\n\t  to logarithmic scale. The ``\"semilogy\"`` scale sets the vertical axis\n\t  to logarithmic scale. The ``\"linear\"`` scale is the default value\n\t  when :class:`~sage.plot.graphics.Graphics` is initialized.\n\n\n\tEXAMPLES:\n\n\tHere we plot a simple function of two variables::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: region_plot(cos(x^2+y^2) <= 0, (x, -3, 3), (y, -3, 3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere we play with the colors::\n\n\t\tsage: region_plot(x^2+y^3 < 2, (x, -2, 2), (y, -2, 2), incol='lightblue', bordercol='gray')\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tAn even more complicated plot, with dashed borders::\n\n\t\tsage: region_plot(sin(x)*sin(y) >= 1/4, (x,-10,10), (y,-10,10), incol='yellow', bordercol='black', borderstyle='dashed', plot_points=250)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tA disk centered at the origin::\n\n\t\tsage: region_plot(x^2+y^2<1, (x,-1,1), (y,-1,1))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA plot with more than one condition (all conditions must be true for the statement to be true)::\n\n\t\tsage: region_plot([x^2+y^2<1, x0, x>0, x^2+y^2<1], (x,-1.1, 1.1), (y,-1.1, 1.1), plot_points = 400)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere is another plot, with a huge border::\n\n\t\tsage: region_plot(x*(x-1)*(x+1)+y^2<0, (x, -3, 2), (y, -3, 3), incol='lightblue', bordercol='gray', borderwidth=10, plot_points=50)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tIf we want to keep only the region where x is positive::\n\n\t\tsage: region_plot([x*(x-1)*(x+1)+y^2<0, x>-1], (x, -3, 2), (y, -3, 3), incol='lightblue', plot_points=50)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere we have a cut circle::\n\n\t\tsage: region_plot([x^2+y^2<4, x>-1], (x, -2, 2), (y, -2, 2), incol='lightblue', bordercol='gray', plot_points=200)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tThe first variable range corresponds to the horizontal axis and\n\tthe second variable range corresponds to the vertical axis::\n\n\t\tsage: s,t=var('s,t')\n\t\tsage: region_plot(s>0,(t,-2,2),(s,-2,2))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: region_plot(s>0,(s,-2,2),(t,-2,2))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAn example of a region plot in 'loglog' scale::\n\n\t\tsage: region_plot(x^2+y^2<100, (x,1,10), (y,1,10), scale='loglog')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tTESTS:\n\n\tTo check that :trac:`16907` is fixed::\n\n\t\tsage: x, y = var('x, y')\n\t\tsage: disc1 = region_plot(x^2+y^2 < 1, (x, -1, 1), (y, -1, 1), alpha=0.5)\n\t\tsage: disc2 = region_plot((x-0.7)^2+(y-0.7)^2 < 0.5, (x, -2, 2), (y, -2, 2), incol='red', alpha=0.5)\n\t\tsage: disc1 + disc2\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tTo check that :trac:`18286` is fixed::\n\n\t\tsage: x, y = var('x, y')\n\t\tsage: region_plot([x == 0], (x, -1, 1), (y, -1, 1))\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: region_plot([x^2+y^2==1, x 1:\n\t\twarn(\"There are at least 2 equations; If the region is degenerated to points, plotting might show nothing.\")\n\t\tfeqs = [sum([fn**2 for fn in feqs])]\n\t\tneqs = 1\n\tif neqs and not bordercol:\n\t\tbordercol = incol\n\tif not f:\n\t\treturn implicit_plot(feqs[0], xrange, yrange, plot_points=plot_points, fill=False, \\\n\t\t\t\t\t\t\t linewidth=borderwidth, linestyle=borderstyle, color=bordercol, **options)\n\tf_all, ranges = setup_for_eval_on_grid(feqs + f, [xrange, yrange], plot_points)\n\txrange,yrange=[r[:2] for r in ranges]\n\n\txy_data_arrays = numpy.asarray([[[func(x, y) for x in xsrange(*ranges[0], include_endpoint=True)]\n\t\t\t\t\t\t\t\t\t for y in xsrange(*ranges[1], include_endpoint=True)]\n\t\t\t\t\t\t\t\t\tfor func in f_all[neqs::]],dtype=float)\n\txy_data_array=numpy.abs(xy_data_arrays.prod(axis=0))\n\t# Now we need to set entries to negative iff all\n\t# functions were negative at that point.\n\tneg_indices = (xy_data_arrays<0).all(axis=0)\n\txy_data_array[neg_indices]=-xy_data_array[neg_indices]\n\n\tfrom matplotlib.colors import ListedColormap\n\tincol = rgbcolor(incol)\n\tif outcol:\n\t\toutcol = rgbcolor(outcol)\n\t\tcmap = ListedColormap([incol, outcol])\n\t\tcmap.set_over(outcol, alpha=alpha)\n\telse:\n\t\toutcol = rgbcolor('white')\n\t\tcmap = ListedColormap([incol, outcol])\n\t\tcmap.set_over(outcol, alpha=0)\n\tcmap.set_under(incol, alpha=alpha)\n\n\tg = Graphics()\n\n\t# Reset aspect_ratio to 'automatic' in case scale is 'semilog[xy]'.\n\t# Otherwise matplotlib complains.\n\tscale = options.get('scale', None)\n\tif isinstance(scale, (list, tuple)):\n\t\tscale = scale[0]\n\tif scale == 'semilogy' or scale == 'semilogx':\n\t\toptions['aspect_ratio'] = 'automatic'\n\n\tg._set_extra_kwds(Graphics._extract_kwds_for_show(options, ignore=['xmin', 'xmax']))\n\n\tif neqs == 0:\n\t\tg.add_primitive(ContourPlot(xy_data_array, xrange,yrange,\n\t\t\t\t\t\t\t\tdict(contours=[-1e-20, 0, 1e-20], cmap=cmap, fill=True, **options)))\n\telse:\n\t\tmask = numpy.asarray([[elt > 0 for elt in rows] for rows in xy_data_array], dtype=bool)\n\t\txy_data_array = numpy.asarray([[f_all[0](x, y) for x in xsrange(*ranges[0], include_endpoint=True)]\n\t\t\t\t\t\t\t\t\t\tfor y in xsrange(*ranges[1], include_endpoint=True)], dtype=float)\n\t\txy_data_array[mask] = None\n\tif bordercol or borderstyle or borderwidth:\n\t\tcmap = [rgbcolor(bordercol)] if bordercol else ['black']\n\t\tlinestyles = [borderstyle] if borderstyle else None\n\t\tlinewidths = [borderwidth] if borderwidth else None\n\t\tg.add_primitive(ContourPlot(xy_data_array, xrange, yrange,\n\t\t\t\t\t\t\t\t\tdict(linestyles=linestyles, linewidths=linewidths,\n\t\t\t\t\t\t\t\t\t\t contours=[0], cmap=[bordercol], fill=False, **options)))\n\n\treturn g\n", "description": "\n\t``region_plot`` takes a boolean function of two variables, `f(x,y)`\n\tand plots the region where f is True over the specified\n\t``xrange`` and ``yrange`` as demonstrated below.\n\n\t``region_plot(f, (xmin, xmax), (ymin, ymax), ...)``\n\n\tINPUT:\n\n\t- ``f`` -- a boolean function or a list of boolean functions of two variables\n\n\t- ``(xmin, xmax)`` -- 2-tuple, the range of ``x`` values OR 3-tuple\n\t  ``(x,xmin,xmax)``\n\n\t- ``(ymin, ymax)`` -- 2-tuple, the range of ``y`` values OR 3-tuple\n\t  ``(y,ymin,ymax)``\n\n\t- ``plot_points``  -- integer (default: 100); number of points to plot\n\t  in each direction of the grid\n\n\t- ``incol`` -- a color (default: ``'blue'``), the color inside the region\n\n\t- ``outcol`` -- a color (default: ``None``), the color of the outside\n\t  of the region\n\n\tIf any of these options are specified, the border will be shown as indicated,\n\totherwise it is only implicit (with color ``incol``) as the border of the\n\tinside of the region.\n\n\t - ``bordercol`` -- a color (default: ``None``), the color of the border\n\t   (``'black'`` if ``borderwidth`` or ``borderstyle`` is specified but not ``bordercol``)\n\n\t- ``borderstyle``  -- string (default: 'solid'), one of ``'solid'``,\n\t  ``'dashed'``, ``'dotted'``, ``'dashdot'``, respectively ``'-'``,\n\t  ``'--'``, ``':'``, ``'-.'``.\n\n\t- ``borderwidth``  -- integer (default: None), the width of the border in pixels\n\n\t- ``alpha`` -- (default: 1) How transparent the fill is. A number between 0 and 1.\n\n\t- ``legend_label`` -- the label for this item in the legend\n\n\t- ``base`` - (default: 10) the base of the logarithm if\n\t  a logarithmic scale is set. This must be greater than 1. The base\n\t  can be also given as a list or tuple ``(basex, basey)``.\n\t  ``basex`` sets the base of the logarithm along the horizontal\n\t  axis and ``basey`` sets the base along the vertical axis.\n\n\t- ``scale`` -- (default: ``\"linear\"``) string. The scale of the axes.\n\t  Possible values are ``\"linear\"``, ``\"loglog\"``, ``\"semilogx\"``,\n\t  ``\"semilogy\"``.\n\n\t  The scale can be also be given as single argument that is a list\n\t  or tuple ``(scale, base)`` or ``(scale, basex, basey)``.\n\n\t  The ``\"loglog\"`` scale sets both the horizontal and vertical axes to\n\t  logarithmic scale. The ``\"semilogx\"`` scale sets the horizontal axis\n\t  to logarithmic scale. The ``\"semilogy\"`` scale sets the vertical axis\n\t  to logarithmic scale. The ``\"linear\"`` scale is the default value\n\t  when :class:`~sage.plot.graphics.Graphics` is initialized.\n\n\n\tEXAMPLES:\n\n\tHere we plot a simple function of two variables::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: region_plot(cos(x^2+y^2) <= 0, (x, -3, 3), (y, -3, 3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere we play with the colors::\n\n\t\tsage: region_plot(x^2+y^3 < 2, (x, -2, 2), (y, -2, 2), incol='lightblue', bordercol='gray')\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tAn even more complicated plot, with dashed borders::\n\n\t\tsage: region_plot(sin(x)*sin(y) >= 1/4, (x,-10,10), (y,-10,10), incol='yellow', bordercol='black', borderstyle='dashed', plot_points=250)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tA disk centered at the origin::\n\n\t\tsage: region_plot(x^2+y^2<1, (x,-1,1), (y,-1,1))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA plot with more than one condition (all conditions must be true for the statement to be true)::\n\n\t\tsage: region_plot([x^2+y^2<1, x0, x>0, x^2+y^2<1], (x,-1.1, 1.1), (y,-1.1, 1.1), plot_points = 400)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere is another plot, with a huge border::\n\n\t\tsage: region_plot(x*(x-1)*(x+1)+y^2<0, (x, -3, 2), (y, -3, 3), incol='lightblue', bordercol='gray', borderwidth=10, plot_points=50)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tIf we want to keep only the region where x is positive::\n\n\t\tsage: region_plot([x*(x-1)*(x+1)+y^2<0, x>-1], (x, -3, 2), (y, -3, 3), incol='lightblue', plot_points=50)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere we have a cut circle::\n\n\t\tsage: region_plot([x^2+y^2<4, x>-1], (x, -2, 2), (y, -2, 2), incol='lightblue', bordercol='gray', plot_points=200)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tThe first variable range corresponds to the horizontal axis and\n\tthe second variable range corresponds to the vertical axis::\n\n\t\tsage: s,t=var('s,t')\n\t\tsage: region_plot(s>0,(t,-2,2),(s,-2,2))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: region_plot(s>0,(s,-2,2),(t,-2,2))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAn example of a region plot in 'loglog' scale::\n\n\t\tsage: region_plot(x^2+y^2<100, (x,1,10), (y,1,10), scale='loglog')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tTESTS:\n\n\tTo check that :trac:`16907` is fixed::\n\n\t\tsage: x, y = var('x, y')\n\t\tsage: disc1 = region_plot(x^2+y^2 < 1, (x, -1, 1), (y, -1, 1), alpha=0.5)\n\t\tsage: disc2 = region_plot((x-0.7)^2+(y-0.7)^2 < 0.5, (x, -2, 2), (y, -2, 2), incol='red', alpha=0.5)\n\t\tsage: disc1 + disc2\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tTo check that :trac:`18286` is fixed::\n\n\t\tsage: x, y = var('x, y')\n\t\tsage: region_plot([x == 0], (x, -1, 1), (y, -1, 1))\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: region_plot([x^2+y^2==1, x 1:\n\t\twarn(\"There are at least 2 equations; If the region is degenerated to points, plotting might show nothing.\")\n\t\tfeqs = [sum([fn**2 for fn in feqs])]\n\t\tneqs = 1\n\tif neqs and not bordercol:\n\t\tbordercol = incol\n\tif not f:\n\t\treturn implicit_plot(feqs[0], xrange, yrange, plot_points=plot_points, fill=False, \\\n\t\t\t\t\t\t\t linewidth=borderwidth, linestyle=borderstyle, color=bordercol, **options)\n\tf_all, ranges = setup_for_eval_on_grid(feqs + f, [xrange, yrange], plot_points)\n\txrange,yrange=[r[:2] for r in ranges]\n\n\txy_data_arrays = numpy.asarray([[[func(x, y) for x in xsrange(*ranges[0], include_endpoint=True)]\n\t\t\t\t\t\t\t\t\t for y in xsrange(*ranges[1], include_endpoint=True)]\n\t\t\t\t\t\t\t\t\tfor func in f_all[neqs::]],dtype=float)\n\txy_data_array=numpy.abs(xy_data_arrays.prod(axis=0))\n\t# Now we need to set entries to negative iff all\n\t# functions were negative at that point.\n\tneg_indices = (xy_data_arrays<0).all(axis=0)\n\txy_data_array[neg_indices]=-xy_data_array[neg_indices]\n\n\tfrom matplotlib.colors import ListedColormap\n\tincol = rgbcolor(incol)\n\tif outcol:\n\t\toutcol = rgbcolor(outcol)\n\t\tcmap = ListedColormap([incol, outcol])\n\t\tcmap.set_over(outcol, alpha=alpha)\n\telse:\n\t\toutcol = rgbcolor('white')\n\t\tcmap = ListedColormap([incol, outcol])\n\t\tcmap.set_over(outcol, alpha=0)\n\tcmap.set_under(incol, alpha=alpha)\n\n\tg = Graphics()\n\n\t# Reset aspect_ratio to 'automatic' in case scale is 'semilog[xy]'.\n\t# Otherwise matplotlib complains.\n\tscale = options.get('scale', None)\n\tif isinstance(scale, (list, tuple)):\n\t\tscale = scale[0]\n\tif scale == 'semilogy' or scale == 'semilogx':\n\t\toptions['aspect_ratio'] = 'automatic'\n\n\tg._set_extra_kwds(Graphics._extract_kwds_for_show(options, ignore=['xmin', 'xmax']))\n\n\tif neqs == 0:\n\t\tg.add_primitive(ContourPlot(xy_data_array, xrange,yrange,\n\t\t\t\t\t\t\t\tdict(contours=[-1e-20, 0, 1e-20], cmap=cmap, fill=True, **options)))\n\telse:\n\t\tmask = numpy.asarray([[elt > 0 for elt in rows] for rows in xy_data_array], dtype=bool)\n\t\txy_data_array = numpy.asarray([[f_all[0](x, y) for x in xsrange(*ranges[0], include_endpoint=True)]\n\t\t\t\t\t\t\t\t\t\tfor y in xsrange(*ranges[1], include_endpoint=True)], dtype=float)\n\t\txy_data_array[mask] = None\n\tif bordercol or borderstyle or borderwidth:\n\t\tcmap = [rgbcolor(bordercol)] if bordercol else ['black']\n\t\tlinestyles = [borderstyle] if borderstyle else None\n\t\tlinewidths = [borderwidth] if borderwidth else None\n\t\tg.add_primitive(ContourPlot(xy_data_array, xrange, yrange,\n\t\t\t\t\t\t\t\t\tdict(linestyles=linestyles, linewidths=linewidths,\n\t\t\t\t\t\t\t\t\t\t contours=[0], cmap=[bordercol], fill=False, **options)))\n\n\treturn g\n", "category": "graphics", "imports": ["from sage.plot.primitive import GraphicPrimitive", "from sage.misc.decorators import options, suboptions", "from sage.plot.colors import rgbcolor, get_cmap", "from sage.misc.misc import xsrange", "import operator", "\t\tsage: from sage.plot.contour_plot import ContourPlot", "\t\tfrom sage.plot.plot import minmax_data", "\t\t\t\t\t\tmatplotlib Colormap. Type: import matplotlib.cm; matplotlib.cm.datad.keys()", "\t\tfrom sage.rings.integer import Integer", "\t\tfrom sage.plot.misc import get_matplotlib_linestyle", "\t\t\tfrom matplotlib import colorbar", "\t  Colormap. Type: ``import matplotlib.cm; matplotlib.cm.datad.keys()``", "\tfrom sage.plot.all import Graphics", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\timport numpy", "\tfrom sage.symbolic.expression import is_SymbolicEquation", "\t\tfrom sage.symbolic.expression import is_Expression", "\tfrom matplotlib.colors import ListedColormap", "\t\tsage: from sage.plot.contour_plot import equify", "\timport operator", "\tfrom sage.calculus.all import symbolic_expression", "\tfrom sage.symbolic.expression import is_Expression"]}, {"term": "def", "name": "equify", "data": "def equify(f):\n\t\"\"\"\n\tReturns the equation rewritten as a symbolic function to give\n\tnegative values when True, positive when False.\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.contour_plot import equify\n\t\tsage: var('x, y')\n\t\t(x, y)\n\t\tsage: equify(x^2 < 2)\n\t\tx^2 - 2\n\t\tsage: equify(x^2 > 2)\n\t\t-x^2 + 2\n\t\tsage: equify(x*y > 1)\n\t\t-x*y + 1\n\t\tsage: equify(y > 0)\n\t\t-y\n\t\tsage: f=equify(lambda x,y: x>y)\n\t\tsage: f(1,2)\n\t\t1\n\t\tsage: f(2,1)\n\t\t-1\n\t\"\"\"\n\timport operator\n\tfrom sage.calculus.all import symbolic_expression\n\tfrom sage.symbolic.expression import is_Expression\n\tif not is_Expression(f):\n\t\treturn lambda x,y: -1 if f(x,y) else 1\n\n\top = f.operator()\n\tif op is operator.gt or op is operator.ge:\n\t\treturn symbolic_expression(f.rhs() - f.lhs())\n\telse:\n\t\treturn symbolic_expression(f.lhs() - f.rhs())\n", "description": "\n\tReturns the equation rewritten as a symbolic function to give\n\tnegative values when True, positive when False.\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.contour_plot import equify\n\t\tsage: var('x, y')\n\t\t(x, y)\n\t\tsage: equify(x^2 < 2)\n\t\tx^2 - 2\n\t\tsage: equify(x^2 > 2)\n\t\t-x^2 + 2\n\t\tsage: equify(x*y > 1)\n\t\t-x*y + 1\n\t\tsage: equify(y > 0)\n\t\t-y\n\t\tsage: f=equify(lambda x,y: x>y)\n\t\tsage: f(1,2)\n\t\t1\n\t\tsage: f(2,1)\n\t\t-1\n\t", "category": "graphics", "imports": ["from sage.plot.primitive import GraphicPrimitive", "from sage.misc.decorators import options, suboptions", "from sage.plot.colors import rgbcolor, get_cmap", "from sage.misc.misc import xsrange", "import operator", "\t\tsage: from sage.plot.contour_plot import ContourPlot", "\t\tfrom sage.plot.plot import minmax_data", "\t\t\t\t\t\tmatplotlib Colormap. Type: import matplotlib.cm; matplotlib.cm.datad.keys()", "\t\tfrom sage.rings.integer import Integer", "\t\tfrom sage.plot.misc import get_matplotlib_linestyle", "\t\t\tfrom matplotlib import colorbar", "\t  Colormap. Type: ``import matplotlib.cm; matplotlib.cm.datad.keys()``", "\tfrom sage.plot.all import Graphics", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\timport numpy", "\tfrom sage.symbolic.expression import is_SymbolicEquation", "\t\tfrom sage.symbolic.expression import is_Expression", "\tfrom matplotlib.colors import ListedColormap", "\t\tsage: from sage.plot.contour_plot import equify", "\timport operator", "\tfrom sage.calculus.all import symbolic_expression", "\tfrom sage.symbolic.expression import is_Expression"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tlive = NUM_LIVES\n\n\t# Add the animation loop here!\n\twhile True:\n\t\tgraphics.ball.move(graphics.get_ball_dx(), graphics.get_ball_dy())\n\t\tpause(FRAME_RATE)\n\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\t\tgraphics.bounce_ball_x_direction()\n\t\tif graphics.ball.y <= 0 or graphics.ball.y + graphics.ball.height >= graphics.window.height:\n\t\t\tgraphics.bounce_ball_y_direction()\n\n\t\t# Check object the ball hits\n\t\tball_check_position1 = [graphics.ball.x, graphics.ball.y]\n\t\tball_check_position2 = [graphics.ball.x + graphics.ball.width, graphics.ball.y]\n\t\tball_check_position3 = [graphics.ball.x, graphics.ball.y + graphics.ball.height]\n\t\tball_check_position4 = [graphics.ball.x + graphics.ball.width, graphics.ball.y + graphics.ball.height]\n\t\tif not is_ball_hit(graphics, ball_check_position1):\n\t\t\tif not is_ball_hit(graphics, ball_check_position2):\n\t\t\t\tif not is_ball_hit(graphics, ball_check_position3):\n\t\t\t\t\tis_ball_hit(graphics, ball_check_position4)\n\n\t\tpause(FRAME_RATE)\n\n\t\t# manage lives\n\t\tif is_ball_missed_catch(graphics):\n\t\t\tlive -= 1\n\t\t\tgraphics.init_ball()\n\t\t\tif live <= 0:  # Game over la\n\t\t\t\tbreak\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}, {"term": "def", "name": "is_ball_hit", "data": "def is_ball_hit(graphics, position):\n\t\"\"\"\n\t\u78ba\u8a8d\u7403\u662f\u5426\u6709\u64ca\u4e2d\u7269\u4ef6\n\t:param graphics: class\u7684\u7269\u4ef6\n\t:param position: \u8981\u78ba\u8a8d\u7684\u64ca\u4e2d\u4f4d\u7f6e\n\t:return: \u662f\u5426\u7403\u64ca\u4e2dobject\n\t\"\"\"\n\tobj = graphics.window.get_object_at(position[0], position[1])\n\tif obj is None:\n\t\treturn False\n\telif obj == graphics.paddle:\n\t\tgraphics.bounce_ball_y_direction()\n\telse:  # object is brick\n\t\tgraphics.window.remove(obj)\n\t\tgraphics.bounce_ball_y_direction()\n\treturn True\n\n", "description": "\n\t\u78ba\u8a8d\u7403\u662f\u5426\u6709\u64ca\u4e2d\u7269\u4ef6\n\t:param graphics: class\u7684\u7269\u4ef6\n\t:param position: \u8981\u78ba\u8a8d\u7684\u64ca\u4e2d\u4f4d\u7f6e\n\t:return: \u662f\u5426\u7403\u64ca\u4e2dobject\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}, {"term": "def", "name": "is_ball_missed_catch", "data": "def is_ball_missed_catch(graphics):\n\t\"\"\"\n\t\u78ba\u8a8d\u7403\u662f\u5426\u6c92\u88ab\u677f\u5b50\u63a5\u4f4f\n\t:param graphics: class\u7684\u7269\u4ef6\n\t:return: \u7403\u662f\u5426\u8d85\u904ewindow\u5e95\u90e8\n\t\"\"\"\n\treturn graphics.ball.y + graphics.ball.height >= graphics.window.height\n\n", "description": "\n\t\u78ba\u8a8d\u7403\u662f\u5426\u6c92\u88ab\u677f\u5b50\u63a5\u4f4f\n\t:param graphics: class\u7684\u7269\u4ef6\n\t:return: \u7403\u662f\u5426\u8d85\u904ewindow\u5e95\u90e8\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [], [{"term": "class", "name": "classGraphicsPic:", "data": "class GraphicsPic:\n\n\tdef __init__(self, true_resolution):\n\t\tself.space_pic = pygame.transform.scale(pygame.image.load('graphics/Space_4.jpg').convert(), true_resolution)\n\n\t\tself.laser_pic_red = pygame.image.load('graphics/Laser_2_red.png').convert_alpha()\n\t\tself.laser_pic_green = pygame.image.load('graphics/Laser_2_green.png').convert_alpha()\n\t\tself.laser_pic_blue = pygame.image.load('graphics/Laser_2_blue.png').convert_alpha()\n\t\tself.laser_pic_yellow = pygame.image.load('graphics/Laser_2_yellow.png').convert_alpha()\n\n\t\tself.explosion_pic_red = \\\n\t\t\t[pygame.image.load('graphics/explosion_2/Missile_explosion_0_red.png').convert_alpha(),\n\t\t\t pygame.image.load('graphics/explosion_2/Missile_explosion_1_red.png').convert_alpha(),\n\t\t\t pygame.image.load('graphics/explosion_2/Missile_explosion_2_red.png').convert_alpha(),\n\t\t\t pygame.image.load('graphics/explosion_2/Missile_explosion_3_red.png').convert_alpha(),\n\t\t\t pygame.image.load('graphics/explosion_2/Missile_explosion_4_red.png').convert_alpha()]\n\t\tself.explosion_pic_green = \\\n\t\t\t[pygame.image.load('graphics/explosion_2/Missile_explosion_0_green.png').convert_alpha(),\n\t\t\t pygame.image.load('graphics/explosion_2/Missile_explosion_1_green.png').convert_alpha(),\n\t\t\t pygame.image.load('graphics/explosion_2/Missile_explosion_2_green.png').convert_alpha(),\n\t\t\t pygame.image.load('graphics/explosion_2/Missile_explosion_3_green.png').convert_alpha(),\n\t\t\t pygame.image.load('graphics/explosion_2/Missile_explosion_4_green.png').convert_alpha()]\n\t\tself.explosion_pic_blue = \\\n\t\t\t[pygame.image.load('graphics/explosion_2/Missile_explosion_0_blue.png').convert_alpha(),\n\t\t\t pygame.image.load('graphics/explosion_2/Missile_explosion_1_blue.png').convert_alpha(),\n\t\t\t pygame.image.load('graphics/explosion_2/Missile_explosion_2_blue.png').convert_alpha(),\n\t\t\t pygame.image.load('graphics/explosion_2/Missile_explosion_3_blue.png').convert_alpha(),\n\t\t\t pygame.image.load('graphics/explosion_2/Missile_explosion_4_blue.png').convert_alpha()]\n\t\tself.explosion_pic_yellow = \\\n\t\t\t[pygame.image.load('graphics/explosion_2/Missile_explosion_0_yellow.png').convert_alpha(),\n\t\t\t pygame.image.load('graphics/explosion_2/Missile_explosion_1_yellow.png').convert_alpha(),\n\t\t\t pygame.image.load('graphics/explosion_2/Missile_explosion_2_yellow.png').convert_alpha(),\n\t\t\t pygame.image.load('graphics/explosion_2/Missile_explosion_3_yellow.png').convert_alpha(),\n\t\t\t pygame.image.load('graphics/explosion_2/Missile_explosion_4_yellow.png').convert_alpha()]\n\n\t\tself.ship_s_img = pygame.image.load('graphics/cruiser.png').convert_alpha()\n\t\tself.ship_m_img = pygame.image.load('graphics/cargoship.png').convert_alpha()\n\t\tself.ship_l_img = pygame.image.load('graphics/destroyer.png').convert_alpha()\n\n\t\tself.sb_laser = pygame.image.load('graphics/Laser_2_red.png').convert_alpha()\n\n\t\tself.blank_num = pygame.image.load('graphics/numbers/gray.png').convert_alpha()\n\n\t\tself.white_num = [pygame.image.load('graphics/numbers/0_white.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/1_white.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/2_white.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/3_white.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/4_white.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/5_white.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/6_white.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/7_white.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/8_white.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/9_white.png').convert_alpha()]\n\n\t\tself.red_num = [pygame.image.load('graphics/numbers/0_red.png').convert_alpha(),\n\t\t\t\t\t\tpygame.image.load('graphics/numbers/1_red.png').convert_alpha(),\n\t\t\t\t\t\tpygame.image.load('graphics/numbers/2_red.png').convert_alpha(),\n\t\t\t\t\t\tpygame.image.load('graphics/numbers/3_red.png').convert_alpha(),\n\t\t\t\t\t\tpygame.image.load('graphics/numbers/4_red.png').convert_alpha(),\n\t\t\t\t\t\tpygame.image.load('graphics/numbers/5_red.png').convert_alpha(),\n\t\t\t\t\t\tpygame.image.load('graphics/numbers/6_red.png').convert_alpha(),\n\t\t\t\t\t\tpygame.image.load('graphics/numbers/7_red.png').convert_alpha(),\n\t\t\t\t\t\tpygame.image.load('graphics/numbers/8_red.png').convert_alpha(),\n\t\t\t\t\t\tpygame.image.load('graphics/numbers/9_red.png').convert_alpha()]\n\n\t\tself.green_num = [pygame.image.load('graphics/numbers/0_green.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/1_green.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/2_green.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/3_green.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/4_green.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/5_green.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/6_green.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/7_green.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/8_green.png').convert_alpha(),\n\t\t\t\t\t\t  pygame.image.load('graphics/numbers/9_green.png').convert_alpha()]\n\n\t\tself.blue_num = [pygame.image.load('graphics/numbers/0_blue.png').convert_alpha(),\n\t\t\t\t\t\t pygame.image.load('graphics/numbers/1_blue.png').convert_alpha(),\n\t\t\t\t\t\t pygame.image.load('graphics/numbers/2_blue.png').convert_alpha(),\n\t\t\t\t\t\t pygame.image.load('graphics/numbers/3_blue.png').convert_alpha(),\n\t\t\t\t\t\t pygame.image.load('graphics/numbers/4_blue.png').convert_alpha(),\n\t\t\t\t\t\t pygame.image.load('graphics/numbers/5_blue.png').convert_alpha(),\n\t\t\t\t\t\t pygame.image.load('graphics/numbers/6_blue.png').convert_alpha(),\n\t\t\t\t\t\t pygame.image.load('graphics/numbers/7_blue.png').convert_alpha(),\n\t\t\t\t\t\t pygame.image.load('graphics/numbers/8_blue.png').convert_alpha(),\n\t\t\t\t\t\t pygame.image.load('graphics/numbers/9_blue.png').convert_alpha()]\n\n\t\tself.yellow_num = [pygame.image.load('graphics/numbers/0_yellow.png').convert_alpha(),\n\t\t\t\t\t\t   pygame.image.load('graphics/numbers/1_yellow.png').convert_alpha(),\n\t\t\t\t\t\t   pygame.image.load('graphics/numbers/2_yellow.png').convert_alpha(),\n\t\t\t\t\t\t   pygame.image.load('graphics/numbers/3_yellow.png').convert_alpha(),\n\t\t\t\t\t\t   pygame.image.load('graphics/numbers/4_yellow.png').convert_alpha(),\n\t\t\t\t\t\t   pygame.image.load('graphics/numbers/5_yellow.png').convert_alpha(),\n\t\t\t\t\t\t   pygame.image.load('graphics/numbers/6_yellow.png').convert_alpha(),\n\t\t\t\t\t\t   pygame.image.load('graphics/numbers/7_yellow.png').convert_alpha(),\n\t\t\t\t\t\t   pygame.image.load('graphics/numbers/8_yellow.png').convert_alpha(),\n\t\t\t\t\t\t   pygame.image.load('graphics/numbers/9_yellow.png').convert_alpha()]\n\n\t\tself.scores_main = [pygame.image.load('graphics/Scores/Main/Circle_m_3.png').convert_alpha(),\n\t\t\t\t\t\t\tpygame.image.load('graphics/Scores/Main/Circle_m_3.png').convert_alpha()]\n\n\t\tself.scores_red = [pygame.image.load('graphics/Scores/Red/Circle_r_3.png').convert_alpha(),\n\t\t\t\t\t\t   pygame.image.load('graphics/Scores/Red/Circle_r_6.png').convert_alpha()]\n\n\t\tself.scores_green = [pygame.image.load('graphics/Scores/Green/Circle_g_3.png').convert_alpha(),\n\t\t\t\t\t\t\t pygame.image.load('graphics/Scores/Green/Circle_g_4.png').convert_alpha()]\n\n\t\tself.scores_blue = [pygame.image.load('graphics/Scores/Blue/Circle_b_2.png').convert_alpha(),\n\t\t\t\t\t\t\tpygame.image.load('graphics/Scores/Blue/Circle_b_4.png').convert_alpha()]\n\n\t\tself.scores_yellow = [pygame.image.load('graphics/Scores/Yellow/Circle_y_3.png').convert_alpha(),\n\t\t\t\t\t\t\t  pygame.image.load('graphics/Scores/Yellow/Circle_y_4.png').convert_alpha()]\n\n\t\tself.picture_fit = {'space': self.space_pic,\n\t\t\t\t\t\t\t'laser_red': self.laser_pic_red,\n\t\t\t\t\t\t\t'laser_green': self.laser_pic_green,\n\t\t\t\t\t\t\t'laser_blue': self.laser_pic_blue,\n\t\t\t\t\t\t\t'laser_yellow': self.laser_pic_yellow,\n\t\t\t\t\t\t\t'explosion_red': self.explosion_pic_red,\n\t\t\t\t\t\t\t'explosion_green': self.explosion_pic_green,\n\t\t\t\t\t\t\t'explosion_blue': self.explosion_pic_blue,\n\t\t\t\t\t\t\t'explosion_yellow': self.explosion_pic_yellow,\n\t\t\t\t\t\t\t'ship_s': self.ship_s_img,\n\t\t\t\t\t\t\t'ship_m': self.ship_m_img,\n\t\t\t\t\t\t\t'ship_l': self.ship_l_img,\n\t\t\t\t\t\t\t'sb_laser': self.sb_laser,\n\t\t\t\t\t\t\t'blank_num': self.blank_num,\n\t\t\t\t\t\t\t'white_num': self.white_num,\n\t\t\t\t\t\t\t'red_num': self.red_num,\n\t\t\t\t\t\t\t'green_num': self.green_num,\n\t\t\t\t\t\t\t'blue_num': self.blue_num,\n\t\t\t\t\t\t\t'yellow_num': self.yellow_num,\n\t\t\t\t\t\t\t'scores_main': self.scores_main,\n\t\t\t\t\t\t\t'scores_red': self.scores_red,\n\t\t\t\t\t\t\t'scores_green': self.scores_green,\n\t\t\t\t\t\t\t'scores_blue': self.scores_blue,\n\t\t\t\t\t\t\t'scores_yellow': self.scores_yellow\n\t\t\t\t\t\t\t}\n\n\tdef get_picture(self, picture_name):\n\t\treturn self.picture_fit[picture_name]\n", "description": null, "category": "graphics", "imports": ["import pygame"]}], [], [{"term": "def", "name": "drawRectangle", "data": "def drawRectangle(x, y, width, height):\n\tglobal sys_graphicsController\n\tsys_graphicsController.drawRectangle(x, y, width, height)\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input"]}, {"term": "def", "name": "drawCircle", "data": "def drawCircle(x, y, radius):\n\tglobal sys_graphicsController\n\tsys_graphicsController.drawCircle(x, y, radius)\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input"]}, {"term": "def", "name": "drawLine", "data": "def drawLine(x1, y1, x2, y2):\n\tglobal sys_graphicsController\n\tsys_graphicsController.drawLine(x1, y1, x2, y2)\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input"]}, {"term": "def", "name": "drawPoint", "data": "def drawPoint(x, y):\n\tglobal sys_graphicsController\n\tsys_graphicsController.drawPoint(x, y)\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input"]}, {"term": "def", "name": "drawString", "data": "def drawString(x, y, string):\n\tglobal sys_graphicsController\n\tsys_graphicsController.drawString(x, y, string)\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input"]}, {"term": "def", "name": "useColour", "data": "def useColour(r, g, b, a):\n\tglobal sys_graphicsController\n\tsys_graphicsController.useColour(r, g, b, a)\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input"]}, {"term": "def", "name": "clearScreen", "data": "def clearScreen():\n\tglobal sys_graphicsController\n\tsys_gameController.clearScreen()\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input"]}, {"term": "def", "name": "newFrame", "data": "def newFrame():\n\tglobal sys_graphicsController\n\tsys_gameController.newFrame()\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input"]}, {"term": "def", "name": "isMouseDown", "data": "def isMouseDown():\n\tglobal sys_inputController\n\treturn sys_inputController.isMouseDown()\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input"]}, {"term": "def", "name": "isKeyDown", "data": "def isKeyDown(key):\n\tglobal sys_inputController\n\treturn sys_inputController.isKeyDown(key)\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input"]}], [], [{"term": "class", "name": "GraphicsTest", "data": "class GraphicsTest(SampleBase):\r\n\tdef __init__(self, *args, **kwargs):\r\n\t\tsuper(GraphicsTest, self).__init__(*args, **kwargs)\r\n\r\n\tdef run(self):\r\n\t\tcanvas = self.matrix\r\n\t\tfont = graphics.Font()\r\n\t\tfont.LoadFont(\"../../../fonts/7x13.bdf\")\r\n\r\n\t\tred = graphics.Color(255, 0, 0)\r\n\t\tgraphics.DrawLine(canvas, 5, 5, 22, 13, red)\r\n\r\n\t\tgreen = graphics.Color(0, 255, 0)\r\n\t\tgraphics.DrawCircle(canvas, 15, 15, 10, green)\r\n\r\n\t\tblue = graphics.Color(0, 0, 255)\r\n\t\tgraphics.DrawText(canvas, font, 2, 10, blue, \"Text\")\r\n\r\n\t\ttime.sleep(10)   # show display for 10 seconds before exit\r\n\r\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase\r", "from rgbmatrix import graphics\r", "import time\r"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\n\tdx = graphics.get_x_speed()\n\tdy = graphics.get_y_speed()\n\n\tlives = NUM_LIVES\n\n\t# Add animation loop here!\n\twhile True:\n\t\tpause(FRAME_RATE)\n\n\t\tif graphics.start and lives > 0 and graphics.count > 0:\n\t\t\tgraphics.ball.move(dx, dy)\n\n\t\t\tif graphics.ball.y >= graphics.window.height:\n\t\t\t\tlives -= 1\n\t\t\t\tgraphics.reset_ball()\n\t\t\telse:\n\t\t\t\t# ball touches paddle or bricks\n\t\t\t\tif graphics.get_obj():\n\t\t\t\t\tif graphics.ball.y < graphics.window.height/2:  # bricks\n\t\t\t\t\t\tdy = -dy\n\t\t\t\t\telse:  # paddle\n\t\t\t\t\t\tif dy > 0:  # ensure won\u00e2\u20ac\u2122t stick on the paddle\n\t\t\t\t\t\t\tdy = -dy\n\t\t\t\t# ball touches the window\n\t\t\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\t\t\t\tdx = -dx\n\t\t\t\tif graphics.ball.y <= 0:\n\t\t\t\t\tdy = -dy\n\n\t\t\t# update ball velocity\n\t\t\tif graphics.score > 0 and graphics.score % 200 == 0:\n\t\t\t\tdy += 0.1\n\t\t\t\tgraphics.update_dy(dy)\n\n\t\telif lives <= 0:\n\t\t\t# game over\n\t\t\tlabel = GLabel('Game Over', x=0, y=graphics.window.height/2)\n\t\t\tlabel.font = '-48-bold'\n\t\t\tlabel.color = 'red'\n\t\t\tgraphics.window.add(label)\n\t\t\tgraphics.window.remove(graphics.ball)\n\t\t\tbreak\n\n\t\telif graphics.count <= 0:\n\t\t\t# you win\n\t\t\tlabel = GLabel('You Win!!!', x=0, y=graphics.window.height/2)\n\t\t\tlabel.font = '-48-bold'\n\t\t\tlabel.color = 'forestgreen'\n\t\t\tgraphics.window.add(label)\n\t\t\tgraphics.window.remove(graphics.ball)\n\t\t\tbreak\n\n\t# label animation\n\tlabel_dx = 1\n\twhile label.x <= graphics.window.width / 2 - 120:\n\t\tlabel.move(label_dx, 0)\n\t\tpause(10)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.graphics.gobjects import GLabel"]}], [{"term": "class", "name": "Display", "data": "class Display(object):\n\t\n\tWHITE = graphicsUtils.formatColor(1.0, 1.0, 1.0)\n\tRED = graphicsUtils.formatColor(1.0, 0.0, 0.0)\n\tGREEN = graphicsUtils.formatColor(0.16, 0.49, 0.31)\n\tBLUE = graphicsUtils.formatColor(0.0, 0.0, 1.0)\n\tBLACK = graphicsUtils.formatColor(0.0, 0.0, 0.0)\n\tGREY = graphicsUtils.formatColor(0.5, .5, 0.5)\n\t\n\tVISIBLE_CUTTOFF = 0.001\n\t\n\t\n\tpartDict = {}\n\tbeliefParts = []\n\tbeliefValue = []\n\tbeliefColor = []\n\tobservations = []\n\t\n\tgraphicsLock = threading.Lock()\n\t\n\tCOLORS = [\n\t\t'purple',\n\t\t'green',\n\t\t'teal',\n\t\t'red',\n\t\t'orange',\n\t\t'yellow'\n\t]\n\tCOLOR_HUES = {\n\t\t'purple' : 0.8,\n\t\t'green' : 0.3,\n\t\t'teal' : 0.49,\n\t\t'red' : 0.0,\n\t\t'orange' : 0.125,\n\t\t'yellow' : 0.21\n\t}\n\t\n\t@staticmethod\n\tdef initGraphics(layout):\n\t\tgraphicsUtils.begin_graphics(\n\t\t\twidth=layout.getWidth(), \n\t\t\theight=layout.getHeight(), \n\t\t\tcolor = Display.WHITE,\n\t\t\ttitle = Const.TITLE\n\t\t);\n\t\t\n\t@staticmethod\n\tdef endGraphics():\n\t\tgraphicsUtils.end_graphics()\n\n\t@staticmethod\n\tdef raiseEndGraphics():\n\t\tgraphicsUtils.raiseEndGraphics()\n\t\n\t@staticmethod\n\tdef drawCar(car):\n\t\tif car in Display.partDict:\n\t\t\tDisplay._remove(car)\n\t\tcolor = Display.GREY\n\t\tif car.isJunior():\n\t\t\tcolor = Display.BLACK\n\t\tparts = graphicsUtils.rectangle(\n\t\t\tcar.pos, Car.LENGTH, \n\t\t\tCar.WIDTH, \n\t\t\tcolor, \n\t\t\tcar.dir\n\t\t)\n\t\tDisplay.partDict[car] = parts\n\t\t\n\t@staticmethod\n\tdef drawObservation(obs):\n\t\tparts = Display.drawCircle(obs.pos, Observation.RADIUS)\n\t\tDisplay.partDict[obs] = parts\n\t\n\t@staticmethod\n\tdef drawSquare(pos, size, color):\n\t\treturn graphicsUtils.square(pos, size, color)\n\t\n\t@staticmethod\n\tdef drawFinish(block):\n\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.GREEN, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\n\t@staticmethod\n\tdef drawBlocks(blocks):\n\t\tfor block in blocks:\n\t\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.BLUE, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\t\n\t@staticmethod\n\tdef drawCircle(pos, radius):\n\t\treturn graphicsUtils.circle(pos, radius, Display.RED, Display.RED)\n\t\n\t@staticmethod\n\tdef drawBelief(model):\n\t\tDisplay.beliefVisible = []\n\t\tfor r in range(model.getBeliefRows()):\n\t\t\tbeliefValueRow = []\n\t\t\tbeliefPartRow = []\n\t\t\tbeliefColorRow = []\n\t\t\tfor c in range(model.getBeliefCols()):\n\t\t\t\tsquare = Display.drawBeliefSquare(r, c, 'purple', 0.0, model)\n\t\t\t\tbeliefPartRow.append(square)\n\t\t\t\tbeliefValueRow.append(0.0)\n\t\t\t\tbeliefColorRow.append(None)\n\t\t\tDisplay.beliefParts.append(beliefPartRow)\n\t\t\tDisplay.beliefValue.append(beliefValueRow)\n\t\t\tDisplay.beliefColor.append(beliefColorRow)\n\t\t\t\t\n\t@staticmethod\n\tdef drawBeliefSquare(row, col, color, value, model):\n\t\ttileSize = Const.BELIEF_TILE_SIZE\n\t\tx = col * tileSize + tileSize / 2.0\n\t\ty = row * tileSize + tileSize / 2.0\n\t\tif not model.inBounds(x, y): return None\n\t\tcolor = Display._getBeliefSquareColor(color, value)\n\t\treturn Display.drawSquare(Vec2d(x, y), tileSize, color)\n\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef getKeys():\n\t\t#print 'attempt get keys'\n\t\tDisplay._acquireLock()\n\t\t#print 'get keys'\n\t\tkeys = graphicsUtils.keys_waiting() + graphicsUtils.keys_pressed()\n\t\tDisplay._releaseLock()\n\t\treturn keys\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef graphicsSleep(timeToSleep):\n\t\tgraphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''for _ in range(int(timeToSleep / 0.005)):\n\t\t\t#print 'attempt sleep'\n\t\t\tDisplay._acquireLock()\n\t\t\t#print 'sleep'\n\t\t\tgraphicsUtils.sleep(0.001)\n\t\t\tDisplay._releaseLock()\n\t\t\ttime.sleep(0.004)'''\n\t\t\n\t\t#graphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''startWait = time.time()\n\t\tDisplay._acquireLock()\n\t\ttimeToSleep -= time.time() - startWait\n\t\tgraphicsUtils.refresh()\n\t\tif timeToSleep > 0:\n\t\t\tgraphicsUtils.sleep(timeToSleep)\n\t\tDisplay._releaseLock()'''\n\t\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef updateBelief(color, belief):\n\t\tDisplay._acquireLock()\n\t\ttotal = belief.getSum()\n\t\tif abs(total - 1.0) > 0.001:\n\t\t\traise Exception('belief does not sum to 1 ('+str(total)+'). Use the normalize method.')\n\t\tfor r in range(belief.getNumRows()):\n\t\t\tfor c in range(belief.getNumCols()):\n\t\t\t\tvalue = belief.getProb(r, c)\n\t\t\t\tDisplay._updateBeliefSquare(r, c, value, color)\n\t\tDisplay._releaseLock()\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef move(obj, delta):\n\t\t#print 'attempt move'\n\t\tDisplay._acquireLock()\n\t\t#print 'move'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.move_by(parts, delta.x, delta.y)\n\t\t#print 'end move'\n\t\tDisplay._releaseLock()\n\t\t\n\t# make thread safe\n\t@staticmethod\n\tdef rotate(obj, angle):\n\t\tif angle == 0: return\n\t\t#print 'attempt rotate'\n\t\tDisplay._acquireLock()\n\t\t#print 'rotate'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.rotate_by(parts, angle)\n\t\tDisplay._releaseLock()\n\t\t\t\t\n\t@staticmethod\n\tdef _getBeliefSquareColor(color, value):\n\t\tvalue = min(1.0, value * 15)\n\t\tsaturation = value\n\t\thue = Display.COLOR_HUES[color]\n\t\tr, g, b = colorsys.hsv_to_rgb(hue, saturation, 1.0)\n\t\tcolor = graphicsUtils.formatColor(r, g, b)\n\t\treturn color\t\t\n\t\n\t@staticmethod\n\tdef _isVisible(value):\n\t\treturn value >= Display.VISIBLE_CUTTOFF\n\t\n\t@staticmethod\n\tdef _updateBeliefSquare(r, c, value, colorName):\n\t\tpart = Display.beliefParts[r][c]\n\t\tif part == None: return\n\t\toldValue = Display.beliefValue[r][c]\n\t\toldColor = Display.beliefColor[r][c]\n\t\twasVisible = Display._isVisible(oldValue)\n\t\tisVisible = Display._isVisible(value) \n\t\tif not isVisible: value = 0.0\n\t\tif oldColor != colorName and oldValue >= value: return\n\t\tif not isVisible and not wasVisible: return\n\t\tcolor = Display._getBeliefSquareColor(colorName, value)\n\t\tgraphicsUtils.changeColor(part, color)\n\t\tDisplay.beliefValue[r][c] = value\n\t\tDisplay.beliefColor[r][c] = colorName\n\t\t\n\t@staticmethod\n\tdef _acquireLock():\n\t\treturn\n\t\t#print 'acquire'\n\t\treturn Display.graphicsLock.acquire()\n\t\n\t@staticmethod\n\tdef _releaseLock():\n\t\treturn\n\t\t#print 'release'\n\t\treturn Display.graphicsLock.release()\n\t \n\t####################################\n\t# Depreicated\n\t####################################\n\t\t\n\t@staticmethod\n\tdef _remove(obj):\n\t\tparts = Display.partDict[obj]\n\t\tgraphicsUtils.remove_from_screen(parts);\n\t\t\n\t@staticmethod\n\tdef redrawObservations(observations):\n\t\traise Exception('depreicated')\n\t\tfor obs in Display.observations:\n\t\t\tDisplay._remove(obs)\n\t\tfor obs in observations:\n\t\t\tDisplay.drawObservation(obs)\n\t\tDisplay.observations = observations\n", "description": null, "category": "graphics", "imports": ["from . import graphicsUtils", "from engine.model.car.car import Car", "from engine.const import Const", "from engine.model.observation import Observation", "from engine.vector import Vec2d", "import colorsys", "import threading"]}], [{"term": "class", "name": "GraphicsView", "data": "class GraphicsView (NSView):\n\tgraphicsContainer = objc.ivar('graphicsContainer')\n\tgraphicsKeyPath   = objc.ivar('graphicsKeyPath')\n\n\tselectionIndexesContainer = objc.ivar('selectionIndexesContainer') # GraphicsArrayController\n\tselectionIndexesKeyPath   = objc.ivar('selectionIndexesKeyPath')\n\n\toldGraphics = objc.ivar('oldGraphics')\n\n\tdef exposedBindings(self):\n\t\treturn [\"graphics\", \"selectedObjects\"]\n\n\tdef initWithFrame_(self, frameRect):\n\t\treturn super(GraphicsView, self).initWithFrame_(frameRect)\n\n\tdef graphics(self):\n\t\tif not self.graphicsContainer: return None\n\t\treturn self.graphicsContainer.valueForKeyPath_(self.graphicsKeyPath)\n\n\tdef selectionIndexes(self):\n\t\tif not self.selectionIndexesContainer: return None\n\t\treturn self.selectionIndexesContainer.valueForKeyPath_(self.selectionIndexesKeyPath)\n\n\tdef startObservingGraphics_(self, graphics):\n\t\tif not graphics: return\n\t\t# Register to observe each of the new graphics, and\n\t\t# each of their observable properties -- we need old and new\n\t\t# values for drawingBounds to figure out what our dirty rect\n\t\tfor newGraphic in graphics:\n\t\t\t# Register as observer for all the drawing-related properties\n\t\t\tnewGraphic.addObserver_forKeyPath_options_context_(\n\t\t\t\tself, \"drawingBounds\", (NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld),\n\t\t\t\tPropertyObservationContext)\n\t\t\tkeys = Circle.keysForNonBoundsProperties()\n\t\t\tfor key in keys:\n\t\t\t\tnewGraphic.addObserver_forKeyPath_options_context_(\n\t\t\t\t\tself, key, 0, PropertyObservationContext)\n\n\tdef stopObservingGraphics_(self, graphics):\n\t\tif graphics is None: return\n\t\tfor graphic in graphics:\n\t\t\tfor key in graphic.class__().keysForNonBoundsProperties():\n\t\t\t\tgraphic.removeObserver_forKeyPath_(self, key)\n\t\t\tgraphic.removeObserver_forKeyPath_(self, \"drawingBounds\")\n\n\tdef bind_toObject_withKeyPath_options_(self, bindingName, observableObject, observableKeyPath, options):\n\t\tif bindingName == \"graphics\":\n\t\t\tself.graphicsContainer = observableObject\n\t\t\tself.graphicsKeyPath = observableKeyPath\n\t\t\tself.graphicsContainer.addObserver_forKeyPath_options_context_(\n\t\t\t\t\tself, self.graphicsKeyPath, (NSKeyValueObservingOptionNew |\n\t\t\t\t\tNSKeyValueObservingOptionOld), GraphicsObservationContext)\n\t\t\tself.startObservingGraphics_(self.graphics())\n\n\t\telif bindingName == \"selectionIndexes\":\n\t\t\tself.selectionIndexesContainer = observableObject\n\t\t\tself.selectionIndexesKeyPath = observableKeyPath\n\t\t\tself.selectionIndexesContainer.addObserver_forKeyPath_options_context_(\n\t\t\t\tself, self.selectionIndexesKeyPath, 0, SelectionIndexesObservationContext)\n\t\tself.setNeedsDisplay_(True)\n\n\tdef unbind_(self, bindingName):\n\t\tif bindingName == \"graphics\":\n\t\t\tself.graphicsContainer.removeObserver_forKeyPath_(self, self.graphicsKeyPath)\n\t\t\tself.graphicsContainer = None\n\t\t\tself.graphicsKeyPath = None\n\t\tif bindingName == \"selectionIndexes\":\n\t\t\tself.selectionIndexesContainer.removeObserver_forKeyPath_(self, self.selectionIndexesKeyPath)\n\t\t\tself.seletionIndexesContainer = None\n\t\t\tself.selectionIndexesKeyPath = None\n\t\tself.setNeedsDisplay_(True)\n\n\tdef observeValueForKeyPath_ofObject_change_context_(self, keyPath, object, change, context):\n\t\tif context == GraphicsObservationContext:\n\t\t\t# Should be able to use\n\t\t\t# NSArray *oldGraphics = [change objectForKey:NSKeyValueChangeOldKey];\n\t\t\t# etc. but the dictionary doesn't contain old and new arrays...??\n\t\t\tnewGraphics = set(object.valueForKeyPath_(self.graphicsKeyPath))\n\t\t\tonlyNew = newGraphics - set(self.oldGraphics or [])\n\t\t\tself.startObservingGraphics_(onlyNew)\n\n\t\t\tif self.oldGraphics:\n\t\t\t\tremoved = set(self.oldGraphics) - newGraphics\n\t\t\t\tself.stopObservingGraphics_(removed)\n\n\t\t\tself.oldGraphics = newGraphics\n\n\t\t\t# could check drawingBounds of old and new, but...\n\t\t\tself.setNeedsDisplay_(True)\n\t\t\treturn\n\n\t\tif context == PropertyObservationContext:\n\t\t\tupdateRect = (0,)\n\t\t\t# Note: for Circle, drawingBounds is a dependent key of all the other\n\t\t\t# property keys except color, so we'll get this anyway...\n\t\t\tif keyPath == \"drawingBounds\":\n\t\t\t\tnewBounds = change.objectForKey_(NSKeyValueChangeNewKey)\n\t\t\t\toldBounds = change.objectForKey_(NSKeyValueChangeOldKey)\n\t\t\t\tupdateRect = NSUnionRect(newBounds, oldBounds)\n\t\t\telse:\n\t\t\t\tupdateRect = object.drawingBounds()\n\t\t\tupdateRect = NSMakeRect(updateRect.origin.x-1.0,\n\t\t\t\t\t\t\t\tupdateRect.origin.y-1.0,\n\t\t\t\t\t\t\t\tupdateRect.size.width+2.0,\n\t\t\t\t\t\t\t\tupdateRect.size.height+2.0)\n\t\t\tself.setNeedsDisplay_(True)\n\t\t\treturn\n\n\t\tif context == SelectionIndexesObservationContext:\n\t\t\tself.setNeedsDisplay_(True)\n\t\t\treturn\n\n\tdef drawRect_(self, rect):\n\t\tmyBounds = self.bounds()\n\t\tNSDrawLightBezel(myBounds, myBounds) # AppKit Function\n\t\tclipRect = NSBezierPath.bezierPathWithRect_(NSInsetRect(myBounds, 2.0, 2.0))\n\t\tclipRect.addClip()\n\n\t\t# Draw graphics\n\t\tgraphicsArray = self.graphics()\n\t\tif graphicsArray:\n\t\t\tfor graphic in graphicsArray:\n\t\t\t\tgraphicDrawingBounds = graphic.drawingBounds()\n\t\t\t\tif NSIntersectsRect(rect, graphicDrawingBounds):\n\t\t\t\t\tgraphic.drawInView_(self)\n\n\t\t# Draw a red box around items in the current selection.\n\t\t# Selection should be handled by the graphic, but this is a\n\t\t# shortcut simply for display.\n\n\t\tcurrentSelectionIndexes = self.selectionIndexes() # ist das wir ein Array im Indezes?\n\t\tif currentSelectionIndexes != None:\n\t\t\tpath = NSBezierPath.bezierPath()\n\t\t\tindex = currentSelectionIndexes.firstIndex()\n\t\t\twhile index != NSNotFound:\n\t\t\t\tgraphicDrawingBounds = graphicsArray[index].drawingBounds()\n\t\t\t\tif NSIntersectsRect(rect, graphicDrawingBounds):\n\t\t\t\t\tpath.appendBezierPathWithRect_(graphicDrawingBounds)\n\t\t\t\tindex = currentSelectionIndexes.indexGreaterThanIndex_(index)\n\n\t\t\tNSColor.redColor().set()\n\t\t\tpath.setLineWidth_(1.5)\n\t\t\tpath.stroke()\n\n\n\t\t# Fairly simple just to illustrate the point\n\tdef mouseDown_(self, event):\n\t\t# find out if we hit anything\n\t\tp = self.convertPoint_fromView_(event.locationInWindow(), None)\n\t\tfor aGraphic in self.graphics():\n\t\t\tif aGraphic.hitTest_isSelected_(p, False):\n\t\t\t\tbreak; # aGraphic soll spaeter einen Wert haben, falls es getroffene gibt!\n\t\telse:\n\t\t\taGraphic = None\n\n\t\t# if no graphic hit, then if extending selection do nothing\n\t\t# else set selection to nil\n\t\tif aGraphic is None:\n\t\t\tif not event.modifierFlags() & NSShiftKeyMask:\n\t\t\t\tself.selectionIndexesContainer.setValue_forKeyPath_(None, self.selectionIndexesKeyPath)\n\t\t\treturn\n\n\t\t# graphic hit\n\t\t# if not extending selection (Shift key down) then set\n\t\t# selection to this graphic\n\t\t# if extending selection, then:\n\t\t# - if graphic in selection remove it\n\t\t# - if not in selection add it\n\t\tgraphicIndex = self.graphics().index(aGraphic)\n\t\tif not event.modifierFlags() & NSShiftKeyMask:\n\t\t\tselection = NSIndexSet.indexSetWithIndex_(graphicIndex)\n\t\telse:\n\t\t\tif  self.selectionIndexes().containsIndex_(graphicIndex):\n\t\t\t\tselection = self.selectionIndexes().mutableCopy()\n\t\t\t\tselection.removeIndex_(graphicIndex)\n\t\t\telse:\n\t\t\t\tselection = self.selectionIndexes().mutableCopy()\n\t\t\t\tselection.addIndex_(graphicIndex)\n\n\t\tself.selectionIndexesContainer.setValue_forKeyPath_(selection, self.selectionIndexesKeyPath)\n\n", "description": null, "category": "graphics", "imports": ["import objc", "from objc import super", "from Cocoa import NSView, NSKeyValueObservingOptionNew, NSKeyValueObservingOptionOld", "from Cocoa import NSKeyValueChangeNewKey, NSKeyValueChangeOldKey, NSUnionRect, NSMakeRect", "from Cocoa import NSDrawLightBezel, NSBezierPath, NSNotFound, NSIntersectsRect, NSColor", "from Cocoa import NSShiftKeyMask, NSIndexSet, NSInsetRect", "from Circle import Circle"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tlives = NUM_LIVES\n\n\t# Add animation loop here!\n\twhile True:\n\t\tif graphics.start:\t\t\t\t\t  # when the mouse is clicked\n\t\t\t# pause(FRAME_RATE)\n\t\t\tgraphics.ball.move(graphics.get_dx(), graphics.get_dy())\n\n\t\t\t# when the ball hit the brick\n\t\t\tif graphics.ball_hit_brick():\n\t\t\t\tgraphics.set_dy(-graphics.get_dy())   # the ball bounce at the opposite direction (y coordinate)\n\t\t\t\tgraphics.brick_number -= 1\t\t\t# the remaining brick number\n\t\t\t\tif graphics.brick_number == 0:\t\t# if there's no brick remain\n\t\t\t\t\tgraphics.reset_ball()\t\t\t # the ball go to its original position\n\t\t\t\t\tbreak\t\t\t\t\t\t\t # end the game\n\n\t\t\t# when the ball hit the paddle\n\t\t\tif graphics.ball_hit_paddle():\n\t\t\t\tif graphics.get_dy() > 0:\n\t\t\t\t\tgraphics.set_dy(-graphics.get_dy())\n\n\t\t\t# when the ball hit the left or right side of the window\n\t\t\tif graphics.ball.x <= 0 or graphics.ball.x+graphics.ball.width >= graphics.window.width:\n\t\t\t\tgraphics.set_dx(-graphics.get_dx())\n\n\t\t\t# when the ball hit the ground(the bottom of the window\n\t\t\tif graphics.ball.y >= graphics.window.height:\n\t\t\t\tlives -= 1\n\t\t\t\tif lives > 0:\t\t\t\t\t\t# when there are still lives remain\n\t\t\t\t\tgraphics.reset_ball()\n\t\t\t\t\tgraphics.start = False\n\t\t\t\telse:\t\t\t\t\t\t\t\t# when there's no life remain\n\t\t\t\t\tbreak\t\t\t\t\t\t\t# end the game\n\n\t\t\t# when the ball hit the top of the window\n\t\t\telif graphics.ball.y <= 0:\n\t\t\t\tgraphics.set_dy(-graphics.get_dy())\n\t\tpause(FRAME_RATE)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [], [], [], [{"term": "class", "name": "GraphicsTest", "data": "class GraphicsTest(SampleBase):\n\tdef __init__(self, *args, **kwargs):\n\t\tsuper(GraphicsTest, self).__init__(*args, **kwargs)\n\n\tdef run(self):\n\t\tcanvas = self.matrix\n\t\tfont = graphics.Font()\n\t\tfont.LoadFont(\"../../../fonts/7x13.bdf\")\n\n\t\tred = graphics.Color(255, 0, 0)\n\t\tgraphics.DrawLine(canvas, 5, 5, 22, 13, red)\n\n\t\tgreen = graphics.Color(0, 255, 0)\n\t\tgraphics.DrawCircle(canvas, 15, 15, 10, green)\n\n\t\tblue = graphics.Color(0, 0, 255)\n\t\tgraphics.DrawText(canvas, font, 2, 10, blue, \"Text\")\n\n\t\ttime.sleep(10)   # show display for 10 seconds before exit\n\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "import time"]}], [{"term": "class", "name": "classSkymapEngine:", "data": "class SkymapEngine:\n\tdef __init__(self, graphics, language=EN, ra=0.0, dec=0.0, fieldradius=-1.0, lm_stars=13.8, lm_deepsky=12.5, caption=''):\n\t\t\"\"\"\n\t\tWidth is width of the map including the legend in mm.\n\t\t\"\"\"\n\t\tself.graphics = graphics\n\t\tself.config = EngineConfiguration()\n\n\t\tself.caption = ''\n\t\tself.language = language\n\t\tself.drawingwidth = self.graphics.gi_width\n\t\tself.drawingheight = self.graphics.gi_height\n\t\tself.min_radius = 1.0  # of deepsky symbols (mm)\n\n\t\tself.lm_stars = lm_stars\n\t\tself.lm_deepsky = lm_deepsky\n\n\t\tself.set_caption(caption)\n\t\tself.set_field(ra, dec, fieldradius)\n\n\t\tself.fieldcentre = None\n\t\tself.fc_sincos_dec = None\n\t\tself.fieldradius = None\n\t\tself.fieldsize = None\n\t\tself.scene_scale = None\n\t\tself.drawingscale = None\n\t\tself.legend_fontscale = None\n\t\tself.active_constellation = None\n\n\t\tself.w_mag_scale = None\n\t\tself.w_map_scale = None\n\t\tself.w_orientation = None\n\t\tself.w_coords = None\n\t\tself.w_dso_legend = None\n\t\tself.w_telrad = None\n\t\tself.w_eyepiece = None\n\t\tself.w_picker = None\n\t\tself.mirroring_graphics = None\n\t\tself.picked_dso = None\n\t\tself.star_mag_r_shift = 0\n\n\tdef set_field(self, ra, dec, fieldradius):\n\t\t\"\"\"\n\t\tProvide the RA, DEC, and radius of the map in radians. This method\n\t\tsets a new drawingscale and legend_fontscale\n\t\t\"\"\"\n\t\tself.fieldcentre = (ra, dec)\n\t\tself.fc_sincos_dec = (math.sin(dec), math.cos(dec))\n\t\tself.fieldradius = fieldradius\n\n\t\twh = max(self.drawingwidth, self.drawingheight)\n\n\t\tself.fieldsize = fieldradius * math.sqrt(self.drawingwidth**2 + self.drawingheight**2) / wh\n\n\t\tif self.config.no_margin:\n\t\t\tself.scene_scale = (wh - self.config.legend_linewidth) / wh\n\t\telse:\n\t\t\tself.scene_scale = BASE_SCALE\n\n\t\tself.drawingscale = self.scene_scale*wh/2.0/math.sin(fieldradius)\n\t\tself.legend_fontscale = min(self.config.legend_font_scale, wh/100.0)\n\t\tself.set_caption(self.caption)\n\n\tdef set_configuration(self, config):\n\t\tself.config = config\n\t\tself.star_mag_r_shift = 0\n\t\tif self.config.star_mag_shift > 0:\n\t\t\tself.star_mag_r_shift = self.magnitude_to_radius(self.lm_stars-self.config.star_mag_shift) - self.magnitude_to_radius(self.lm_stars)\n\n\tdef get_field_radius_mm(self):\n\t\treturn self.drawingscale * math.sin(self.fieldradius)\n\n\tdef get_field_rect_mm(self):\n\t\tx = self.scene_scale * self.drawingwidth / 2.0\n\t\ty = self.scene_scale * self.drawingheight / 2.0\n\t\treturn -x, -y, x, y\n\n\tdef set_language(self, language):\n\t\t\"\"\"\n\t\tSet the language for the legend.\n\t\t\"\"\"\n\t\tself.language = language\n\n\tdef set_caption(self, caption):\n\t\tself.caption = caption\n\t\tif caption != '':\n\t\t\tself.graphics.set_dimensions(self.drawingwidth,self.drawingheight + self.legend_fontscale*self.graphics.gi_fontsize*2.0)\n\n\tdef set_active_constellation(self, active_constellation):\n\t\tself.active_constellation = active_constellation\n\n\tdef draw_caption(self):\n\t\tif self.caption != '':\n\t\t\told_size = self.graphics.gi_fontsize\n\t\t\tfont_size = self.get_legend_font_size()\n\t\t\tself.graphics.set_font(self.graphics.gi_font, 2.0*font_size)\n\t\t\tself.graphics.text_centred(0, self.drawingwidth/2.0*BASE_SCALE + font_size, self.caption)\n\t\t\tself.graphics.set_font(self.graphics.gi_font, old_size)\n\n\tdef draw_field_border(self):\n\t\t\"\"\"\n\t\tDraw a circle representing the edge of the field of view.\n\t\t\"\"\"\n\t\tif self.config.show_field_border:\n\t\t\tself.graphics.set_linewidth(self.config.legend_linewidth)\n\t\t\tx1, y1, x2, y2 = self.get_field_rect_mm()\n\t\t\tself.graphics.line(x1, y1, x1, y2)\n\t\t\tself.graphics.line(x1, y2, x2, y2)\n\t\t\tself.graphics.line(x2, y2, x2, y1)\n\t\t\tself.graphics.line(x2, y1, x1, y1)\n\n\tdef get_legend_font_size(self):\n\t\treturn self.config.font_size * self.legend_fontscale\n\n\tdef draw_widgets(self):\n\t\t# Set the fontsize for the entire legend\n\t\tfontsize = self.get_legend_font_size()\n\t\tself.graphics.set_font(self.graphics.gi_font, fontsize=fontsize)\n\n\t\tx1, y1, x2, y2 = self.get_field_rect_mm()\n\n\t\tif self.config.fov_telrad:\n\t\t\tself.w_telrad.draw(self.graphics)\n\t\tif self.config.eyepiece_fov is not None:\n\t\t\tself.w_eyepiece.draw(self.graphics)\n\t\tif self.config.show_picker and self.config.picker_radius > 0:\n\t\t\tself.w_picker.draw(self.graphics)\n\t\tif self.config.show_mag_scale_legend:\n\t\t\tself.w_mag_scale.draw(self.graphics, x1, y1, self.config.legend_only)\n\t\tif self.config.show_map_scale_legend:\n\t\t\tself.w_map_scale.draw(self.graphics, x2, y1, self.config.legend_only)\n\t\tif self.config.show_orientation_legend:\n\t\t\tself.w_orientation.draw(self.graphics, x1, y2, self.config.legend_only)\n\t\tif self.config.show_coords_legend:\n\t\t\tself.w_coords.draw(self.graphics, left=x2-fontsize/2, bottom=y2-fontsize, ra=self.fieldcentre[0], dec=self.fieldcentre[1], legend_only=self.config.legend_only)\n\t\tif self.config.show_dso_legend:\n\t\t\tself.w_dso_legend.draw_dso_legend(self, self.graphics, self.config.legend_only)\n\n\tdef draw_deepsky_objects(self, deepsky_catalog, showing_dsos, hl_showing_dsos, dso_hide_filter, visible_dso_collector):\n\t\tif not self.config.show_deepsky:\n\t\t\treturn\n\n\t\t# Draw deep sky\n\t\t# print('Drawing deepsky...')\n\n\t\tdeepsky_list = deepsky_catalog.select_deepsky(self.fieldcentre, self.fieldsize, self.lm_deepsky)\n\n\t\tfiltered_showing_dsos = []\n\n\t\tif dso_hide_filter:\n\t\t\tdso_hide_filter_set = {dso for dso in dso_hide_filter}\n\t\telse:\n\t\t\tdso_hide_filter_set = {}\n\n\t\tif showing_dsos:\n\t\t\tfor dso in showing_dsos:\n\t\t\t\tif dso not in deepsky_list:\n\t\t\t\t\tfiltered_showing_dsos.append(dso)\n\t\t\t\tif dso in dso_hide_filter_set:\n\t\t\t\t\tdso_hide_filter_set.remove(dso)\n\n\t\tdeepsky_list.sort(key=lambda x: x.mag)\n\t\tdeepsky_list_ext = []\n\n\t\t# calc for deepsky objects from selection\n\t\tfor dso in deepsky_list:\n\t\t\tx, y = radec_to_xy(dso.ra, dso.dec, self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\t\t\tif dso.rlong is None:\n\t\t\t\trlong = self.min_radius\n\t\t\telse:\n\t\t\t\trlong = dso.rlong*self.drawingscale\n\t\t\t\tif rlong < self.min_radius:\n\t\t\t\t\trlong = self.min_radius\n\t\t\tdeepsky_list_ext.append((dso, x, y, rlong))\n\n\t\t# calc for deepsky objects from showing dsos\n\t\tfor dso in filtered_showing_dsos:\n\t\t\tif angular_distance((dso.ra, dso.dec), self.fieldcentre) < self.fieldsize:\n\t\t\t\tx, y, z = radec_to_xyz(dso.ra, dso.dec, self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\t\t\t\tif z > 0:\n\t\t\t\t\trlong = dso.rlong*self.drawingscale\n\t\t\t\t\tif rlong < self.min_radius:\n\t\t\t\t\t\trlong = self.min_radius\n\t\t\t\t\tdeepsky_list_ext.append((dso, x, y, rlong))\n\n\t\tlabel_potential = LabelPotential(self.get_field_radius_mm(), deepsky_list_ext)\n\n\t\t# print('Drawing objects...')\n\t\tpick_r = self.config.picker_radius if self.config.picker_radius > 0 else 0\n\t\tif pick_r > 0:\n\t\t\tpick_min_r = pick_r**2\n\t\t\tfor dso, x, y, rlong in deepsky_list_ext:\n\t\t\t\tif pick_r > 0 and abs(x) < pick_r and abs(y) < pick_r:\n\t\t\t\t\tr = x*x + y*y\n\t\t\t\t\tif r < pick_min_r:\n\t\t\t\t\t\tself.picked_dso = dso\n\t\t\t\t\t\tpick_min_r = r\n\n\t\tfor dso, x, y, rlong in deepsky_list_ext:\n\t\t\tif dso in dso_hide_filter_set:\n\t\t\t\tcontinue\n\n\t\t\tlabel = dso.label()\n\n\t\t\tif hl_showing_dsos and dso in showing_dsos:\n\t\t\t\tself.draw_dso_hightlight(x, y, rlong, label, visible_dso_collector)\n\n\t\t\trlong = dso.rlong if dso.rlong is not None else self.min_radius\n\t\t\trshort = dso.rshort if dso.rshort is not None else self.min_radius\n\t\t\trlong = rlong*self.drawingscale\n\t\t\trshort = rshort*self.drawingscale\n\t\t\tposangle = dso.position_angle+direction_ddec((dso.ra, dso.dec), self.fieldcentre, self.fc_sincos_dec)+0.5*np.pi\n\n\t\t\tif rlong <= self.min_radius:\n\t\t\t\trshort *= self.min_radius/rlong\n\t\t\t\trlong = self.min_radius\n\n\t\t\tlabel_ext = None\n\t\t\tif dso == self.picked_dso and dso.mag < 100.0:\n\t\t\t\tlabel_ext = '{:.2f}m'.format(dso.mag)\n\n\t\t\tlabel_length = self.graphics.text_width(label)\n\t\t\tlabelpos = -1\n\n\t\t\tlabelpos_list = []\n\t\t\tif dso.type == deepsky.G:\n\t\t\t\tlabelpos_list = self.galaxy_labelpos(x, y, rlong, rshort, posangle, label_length)\n\t\t\telif dso.type == deepsky.N:\n\t\t\t\tlabelpos_list = self.diffuse_nebula_labelpos(x, y, 2.0*rlong, 2.0*rshort, posangle, label_length)\n\t\t\telif dso.type in [deepsky.PN, deepsky.OC, deepsky.GC, deepsky.SNR, deepsky.GALCL]:\n\t\t\t\tlabelpos_list = self.circular_object_labelpos(x, y, rlong, label_length)\n\t\t\telif dso.type == deepsky.STARS:\n\t\t\t\tlabelpos_list = self.asterism_labelpos(x, y, rlong, label_length)\n\t\t\telse:\n\t\t\t\tlabelpos_list = self.unknown_object_labelpos(x, y, rlong, label_length)\n\n\t\t\tpot = 1e+30\n\t\t\tfor labelpos_index in range(len(labelpos_list)):\n\t\t\t\t[[x1, y1], [x2, y2], [x3, y3]] = labelpos_list[labelpos_index]\n\t\t\t\tpot1 = label_potential.compute_potential(x2, y2)\n\t\t\t\t# label_potential.compute_potential(x1,y1),\n\t\t\t\t# label_potential.compute_potential(x3,y3)])\n\t\t\t\tif pot1 < pot:\n\t\t\t\t\tpot = pot1\n\t\t\t\t\tlabelpos = labelpos_index\n\n\t\t\t[xx, yy] = labelpos_list[labelpos][1]\n\t\t\tlabel_potential.add_position(xx, yy, label_length)\n\n\t\t\tif dso.type == deepsky.G:\n\t\t\t\tself.galaxy(x, y, rlong, rshort, posangle, dso.mag, label, label_ext, labelpos)\n\t\t\telif dso.type == deepsky.N:\n\t\t\t\thas_outlines = False\n\t\t\t\tif self.config.show_nebula_outlines and dso.outlines is not None and rlong > self.min_radius:\n\t\t\t\t\thas_outlines = self.draw_dso_outlines(dso, x, y, rlong, rshort, posangle, label, label_ext, labelpos)\n\t\t\t\tif not has_outlines:\n\t\t\t\t\tself.diffuse_nebula(x, y, 2.0*rlong, 2.0*rshort, posangle, label, label_ext, labelpos)\n\t\t\telif dso.type == deepsky.PN:\n\t\t\t\tself.planetary_nebula(x, y, rlong, label, label_ext, labelpos)\n\t\t\telif dso.type == deepsky.OC:\n\t\t\t\tif self.config.show_nebula_outlines and dso.outlines is not None:\n\t\t\t\t\thas_outlines = self.draw_dso_outlines(dso, x, y, rlong, rshort)\n\t\t\t\tself.open_cluster(x, y, rlong, label, label_ext, labelpos)\n\t\t\telif dso.type == deepsky.GC:\n\t\t\t\tself.globular_cluster(x, y, rlong, label, label_ext, labelpos)\n\t\t\telif dso.type == deepsky.STARS:\n\t\t\t\tself.asterism(x, y, rlong, label, label_ext, labelpos)\n\t\t\telif dso.type == deepsky.SNR:\n\t\t\t\tself.supernova_remnant(x, y, rlong, label, label_ext, labelpos)\n\t\t\telif dso.type == deepsky.GALCL:\n\t\t\t\tself.galaxy_cluster(x, y, rlong, label, label_ext, labelpos)\n\t\t\telse:\n\t\t\t\tself.unknown_object(x, y, rlong, label, label_ext, labelpos)\n\n\t\t\tif visible_dso_collector is not None:\n\t\t\t\txs1, ys1 = x-rlong, y-rlong\n\t\t\t\txs2, ys2 = x+rlong, y+rlong\n\t\t\t\tif self.graphics.on_screen(xs1, ys1) or self.graphics.on_screen(xs2, ys2):\n\t\t\t\t\txp1, yp1 = self.mirroring_graphics.to_pixel(xs1, ys1)\n\t\t\t\t\txp2, yp2 = self.mirroring_graphics.to_pixel(xs2, ys2)\n\t\t\t\t\txp1, yp1, xp2, yp2 = self.align_rect_coords(xp1, yp1, xp2, yp2)\n\t\t\t\t\tvisible_dso_collector.append([rlong, label.replace(' ', ''), xp1, yp1, xp2, yp2])\n\t\t\t\t\tif self.picked_dso == dso:\n\t\t\t\t\t\tpick_xp1, pick_yp1 = self.mirroring_graphics.to_pixel(-pick_r, -pick_r)\n\t\t\t\t\t\tpick_xp2, pick_yp2 = self.mirroring_graphics.to_pixel(pick_r, pick_r)\n\t\t\t\t\t\tpick_xp1, pick_yp1, pick_xp2, pick_yp2 = self.align_rect_coords(pick_xp1, pick_yp1, pick_xp2, pick_yp2)\n\t\t\t\t\t\tvisible_dso_collector.append([rlong, label.replace(' ', ''), pick_xp1, pick_yp1, pick_xp2, pick_yp2])\n\n\tdef draw_dso_outlines(self, dso, x, y, rlong, rshort, posangle=None, label=None, label_ext=None,  labelpos=None):\n\t\tlev_shift = 0\n\t\thas_outlines = False\n\t\tdraw_label = True\n\t\tfor outl_lev in range(2, -1, -1):\n\t\t\toutlines_ar = dso.outlines[outl_lev]\n\t\t\tif outlines_ar:\n\t\t\t\thas_outlines = True\n\t\t\t\tfor outlines in outlines_ar:\n\t\t\t\t\tx_outl, y_outl = np_radec_to_xy(outlines[0], outlines[1], self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\t\t\t\t\tself.diffuse_nebula_outlines(x, y, x_outl, y_outl, outl_lev+lev_shift, 2.0*rlong, 2.0*rshort, posangle,\n\t\t\t\t\t\t\t\t\t\t\t\t label, label_ext, draw_label, labelpos)\n\t\t\t\t\tdraw_label = False\n\t\t\telse:\n\t\t\t\tlev_shift += 1\n\t\treturn has_outlines\n\n\tdef draw_unknown_nebula(self, unknown_nebulas):\n\t\tfor uneb in unknown_nebulas:\n\t\t\tra = (uneb.ra_min + uneb.ra_max) / 2.0\n\t\t\tdec = (uneb.dec_min + uneb.dec_max) / 2.0\n\t\t\tx, y, z = radec_to_xyz(ra, dec, self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\t\t\tif z <=0:\n\t\t\t\tcontinue\n\t\t\tfor outl_lev in range(3):\n\t\t\t\toutlines = uneb.outlines[outl_lev]\n\t\t\t\tif not outlines:\n\t\t\t\t\tcontinue\n\t\t\t\tfor outl in outlines:\n\t\t\t\t\tif z > 0:\n\t\t\t\t\t\tx_outl, y_outl = np_radec_to_xy(outl[0], outl[1], self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\t\t\t\t\t\tself.unknown_diffuse_nebula_outlines(x_outl, y_outl, outl_lev)\n\n\tdef draw_milky_way(self, milky_way_lines):\n\t\tself.graphics.save()\n\n\t\tx, y, z = np_radec_to_xyz(milky_way_lines[:, 0], milky_way_lines[:, 1], self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\t\tmulx = -1 if self.config.mirror_x else 1\n\t\tmuly = -1 if self.config.mirror_y else 1\n\t\tself.graphics.set_pen_rgb(self.config.milky_way_color)\n\t\tself.graphics.set_fill_rgb(self.config.milky_way_color)\n\t\tself.graphics.set_linewidth(self.config.milky_way_linewidth)\n\n\t\tpolygon = None\n\t\tfor i in range(len(x)-1):\n\t\t\tif milky_way_lines[i][2] == 0:\n\t\t\t\tif polygon is not None and len(polygon) > 2:\n\t\t\t\t\tself.graphics.polygon(polygon, DrawMode.BOTH)\n\t\t\t\tx1, y1, z1 = x[i].item(), y[i].item(), z[i].item()\n\t\t\t\tpolygon = None\n\t\t\t\tif z1 > 0:\n\t\t\t\t\tpolygon = [[mulx*x1, muly*y1]]\n\t\t\telse:\n\t\t\t\tx1, y1, z1 = x[i].item(), y[i].item(), z[i].item()\n\t\t\t\tif z1 > 0:\n\t\t\t\t\tif polygon is None:\n\t\t\t\t\t\tpolygon = []\n\t\t\t\t\tpolygon.append([mulx*x1, muly*y1])\n\n\t\tif polygon is not None and len(polygon) > 2:\n\t\t\tself.graphics.polygon(polygon, DrawMode.FILL)\n\n\t\tself.graphics.restore()\n\n\tdef draw_enhanced_milky_way(self, enhanced_milky_way, use_optimized_mw):\n\t\tself.graphics.save()\n\t\tself.graphics.antialias_off()\n\n\t\ttm = time()\n\n\t\tmw_points = enhanced_milky_way.mw_points\n\n\t\tx, y, z = np_radec_to_xyz(mw_points[:, 0], mw_points[:, 1], self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\t\tmulx = -1 if self.config.mirror_x else 1\n\t\tmuly = -1 if self.config.mirror_y else 1\n\n\t\tself.graphics.set_linewidth(0)\n\t\tfd = self.config.enhanced_milky_way_fade\n\n\t\tif use_optimized_mw:\n\t\t\tselected_polygons = enhanced_milky_way.select_opti_polygons(self.fieldcentre, self.fieldsize)\n\t\telse:\n\t\t\tselected_polygons = enhanced_milky_way.select_polygons(self.fieldcentre, self.fieldsize)\n\n\t\tfr_x1, fr_y1, fr_x2, fr_y2 = self.get_field_rect_mm()\n\n\t\ttotal_polygons = 0\n\t\tfor polygon_index in selected_polygons:\n\t\t\tif use_optimized_mw:\n\t\t\t\tpolygon, rgb = enhanced_milky_way.mw_opti_polygons[polygon_index]\n\t\t\telse:\n\t\t\t\tpolygon, rgb = enhanced_milky_way.mw_polygons[polygon_index]\n\n\t\t\txy_polygon = [(x[i].item() * mulx, y[i].item() * muly) for i in polygon]\n\t\t\tfor xp, yp in xy_polygon:\n\t\t\t\tif (xp >= fr_x1) and (xp <= fr_x2) and (yp >= fr_y1) and (yp <= fr_y2):\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tcontinue\n\n\t\t\tfrgb = (fd[0] + rgb[0] * fd[1], fd[2] + rgb[1] * fd[3], fd[4] + rgb[2] * fd[5])\n\t\t\ttotal_polygons += 1\n\t\t\tself.graphics.set_fill_rgb(frgb)\n\t\t\tself.graphics.polygon(xy_polygon, DrawMode.FILL)\n\n\t\tself.graphics.antialias_on()\n\t\tprint(\"Enhanced milky way draw within {} s. Total polygons={}\".format(str(time()-tm), total_polygons), flush=True)\n\t\tself.graphics.restore()\n\n\tdef draw_extra_objects(self,extra_positions):\n\t\t# Draw extra objects\n\t\t# print('Drawing extra objects...')\n\t\tfor rax, decx, label, labelpos in extra_positions:\n\t\t\tif angular_distance((rax, decx), self.fieldcentre) < self.fieldsize:\n\t\t\t\tx, y = radec_to_xy(rax, decx, self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\t\t\t\tself.unknown_object(x, y, self.min_radius, label, labelpos)\n\n\tdef draw_highlights(self, highlights, visible_dso_collector):\n\t\t# Draw highlighted objects\n\t\t# print('Drawing highlighted objects...')\n\n\t\tself.graphics.save()\n\n\t\tfor hl_def in highlights:\n\t\t\tself.graphics.set_pen_rgb(hl_def.color)\n\t\t\tself.graphics.set_linewidth(hl_def.line_width)\n\t\t\tfor rax, decx, object_name in hl_def.data:\n\t\t\t\tif angular_distance((rax, decx), self.fieldcentre) < self.fieldsize:\n\t\t\t\t\tx, y = radec_to_xy(rax, decx, self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\t\t\t\t\tif hl_def.style == 'cross':\n\t\t\t\t\t\tr = self.config.font_size * 2\n\t\t\t\t\t\tself.mirroring_graphics.line(x-r, y, x-r/2, y)\n\t\t\t\t\t\tself.mirroring_graphics.line(x+r, y, x+r/2, y)\n\t\t\t\t\t\tself.mirroring_graphics.line(x, y+r, x, y+r/2)\n\t\t\t\t\t\tself.mirroring_graphics.line(x, y-r, x, y-r/2)\n\t\t\t\t\telif hl_def.style == 'circle':\n\t\t\t\t\t\tr = self.config.font_size\n\t\t\t\t\t\tself.mirroring_graphics.circle(x, y, r)\n\t\t\t\t\t\tif object_name and visible_dso_collector is not None:\n\t\t\t\t\t\t\txs1, ys1 = x-r, y-r\n\t\t\t\t\t\t\txs2, ys2 = x+r, y+r\n\t\t\t\t\t\t\tif self.graphics.on_screen(xs1, ys1) or self.graphics.on_screen(xs2, ys2):\n\t\t\t\t\t\t\t\txp1, yp1 = self.mirroring_graphics.to_pixel(xs1, ys1)\n\t\t\t\t\t\t\t\txp2, yp2 = self.mirroring_graphics.to_pixel(xs2, ys2)\n\t\t\t\t\t\t\t\txp1, yp1, xp2, yp2 = self.align_rect_coords(xp1, yp1, xp2, yp2)\n\t\t\t\t\t\t\t\tvisible_dso_collector.append([r, object_name, xp1, yp1, xp2, yp2])\n\n\t\tself.graphics.restore()\n\n\tdef draw_dso_hightlight(self, x, y, rlong, dso_name, visible_dso_collector):\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_pen_rgb(self.config.dso_highlight_color)\n\t\tself.graphics.set_linewidth(self.config.dso_highlight_linewidth)\n\n\t\tr = self.config.font_size\n\t\tself.mirroring_graphics.circle(x, y, r)\n\t\txs1, ys1 = x-r, y-r\n\t\txs2, ys2 = x+r, y+r\n\t\tif visible_dso_collector is not None and (self.graphics.on_screen(xs1, ys1) or self.graphics.on_screen(xs2, ys2)):\n\t\t\txp1, yp1 = self.mirroring_graphics.to_pixel(xs1, ys1)\n\t\t\txp2, yp2 = self.mirroring_graphics.to_pixel(xs2, ys2)\n\t\t\txp1, yp1, xp2, yp2 = self.align_rect_coords(xp1, yp1, xp2, yp2)\n\t\t\tvisible_dso_collector.append([r, dso_name.replace(' ', ''), xp1, yp1, xp2, yp2])\n\n\t\tself.graphics.restore()\n\n\tdef draw_trajectory(self,trajectory):\n\t\t# Draw extra objects\n\t\t# print('Drawing trajectory...')\n\t\tself.graphics.save()\n\t\tself.graphics.set_pen_rgb(self.config.dso_color)\n\n\t\tfh = self.graphics.gi_fontsize\n\t\tx1 = None\n\t\ty1 = None\n\t\tz1 = None\n\t\tr = self.min_radius * 1.2 / 2**0.5\n\n\t\tfor i in range(0, len(trajectory)):\n\t\t\trax2, decx2, label2 = trajectory[i]\n\t\t\tx2, y2, z2 = radec_to_xyz(rax2, decx2, self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\n\t\t\tif i > 0:\n\t\t\t\tself.graphics.set_linewidth(self.config.constellation_linewidth)\n\t\t\t\tif z1 > 0 and z2 > 0:\n\t\t\t\t\tself.mirroring_graphics.line(x1, y1, x2, y2)\n\t\t\t\t\tself.draw_trajectory_tick(x1, y1, x2, y2)\n\t\t\t\t\tif i == 1:\n\t\t\t\t\t\tself.draw_trajectory_tick(x2, y2, x1, y1)\n\n\t\t\tself.mirroring_graphics.text_centred(x2, y2 - r - fh/2.0, label2)\n\n\t\t\tx1, y1, z1 = (x2, y2, z2)\n\n\t\tself.graphics.restore()\n\n\tdef draw_trajectory_tick(self, x1, y1, x2, y2):\n\t\tdx = x2-x1\n\t\tdy = y2-y1\n\t\tdr = math.sqrt(dx * dx + dy*dy)\n\t\tddx = dx * 1.0 / dr\n\t\tddy = dy * 1.0 / dr\n\t\tself.graphics.set_linewidth(1.5*self.config.constellation_linewidth)\n\t\tself.mirroring_graphics.line(x2-ddy, y2+ddx, x2+ddy, y2-ddx)\n\n\tdef magnitude_to_radius(self, magnitude):\n\t\t# radius = 0.13*1.35**(int(self.lm_stars)-magnitude)\n\t\tmag_d = self.lm_stars - np.clip(magnitude, a_min=None, a_max=self.lm_stars)\n\t\tmag_s = np.interp(mag_d, MAG_SCALE_X, MAG_SCALE_Y)\n\t\tradius = 0.1 * 1.33 ** mag_s + self.star_mag_r_shift\n\t\treturn radius\n\n\tdef draw_stars(self, star_catalog, allow_star_pick):\n\t\t# Select and draw stars\n\t\t# print('Drawing stars...')\n\n\t\tif allow_star_pick:\n\t\t\tpick_r = self.config.picker_radius if self.config.picker_radius > 0 else 0\n\t\telse:\n\t\t\tpick_r = 0\n\n\t\t# tm = time()\n\t\tselection = star_catalog.select_stars(self.fieldcentre, self.fieldsize, self.lm_stars)\n\t\tif selection is None or len(selection) == 0:\n\t\t\tprint('No stars found.')\n\t\t\treturn\n\n\t\t# print(\"Stars selection {} ms\".format(str(time()-tm)), flush=True)\n\t\tprint('{} stars in map.'.format(selection.shape[0]))\n\t\tprint('Faintest star: ' + str(round(max(selection['mag']), 2)))\n\n\t\t# tm = time()\n\t\tx, y = np_radec_to_xy(selection['ra'], selection['dec'], self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\n\t\t# print(\"Stars view positioning {} ms\".format(str(time()-tm)), flush=True)\n\n\t\tmag = selection['mag']\n\t\tbsc = selection['bsc']\n\n\t\tindices = np.argsort(mag)\n\t\tmagsorted = mag[indices]\n\t\trsorted = self.magnitude_to_radius(magsorted)\n\n\t\tif not self.config.star_colors:\n\t\t\t# self.graphics.set_pen_rgb((self.config.draw_color[0]/3, self.config.draw_color[0]/3, self.config.draw_color[0]/3))\n\t\t\tself.graphics.set_fill_rgb(self.config.draw_color)\n\n\t\tself.graphics.set_linewidth(0)\n\n\t\tstar_labels = []\n\t\tpick = None\n\t\tpick_min_r = pick_r**2\n\t\tx1, y1, x2, y2 = self.get_field_rect_mm()\n\t\tfor i in range(len(indices)):\n\t\t\tindex = indices[i]\n\t\t\txx, yy, rr = (x[index].item(), y[index].item(), rsorted[i].item(),)\n\t\t\tif (xx >= x1-rr) and (xx <= x2+rr) and (yy >= y1-rr) and (yy <= y2+rr):\n\t\t\t\tself.star(xx, yy, rr, star_catalog.get_star_color(selection[index]))\n\t\t\t\tif pick_r > 0 and abs(xx) < pick_r and abs(yy) < pick_r:\n\t\t\t\t\tr = xx*xx + yy*yy\n\t\t\t\t\tif r < pick_min_r:\n\t\t\t\t\t\tpick = (xx, yy, rr, mag[index], bsc[index])\n\t\t\t\t\t\tpick_min_r = r\n\t\t\t\telse:\n\t\t\t\t\tif self.config.show_star_labels:\n\t\t\t\t\t\tbsc_star = selection[index]['bsc']\n\t\t\t\t\t\tif bsc_star is not None:\n\t\t\t\t\t\t\tstar_labels.append((xx, yy, rr, bsc_star))\n\n\t\tif len(star_labels) > 0:\n\t\t\tself.draw_stars_labels(star_labels)\n\n\t\tif pick is not None:\n\t\t\tfn = self.graphics.gi_fontsize\n\t\t\tx, y, r, mag, bsc = pick\n\t\t\tself.graphics.set_font(self.graphics.gi_font, 0.9*fn)\n\t\t\tlabel =str(mag)\n\t\t\tif bsc is not None:\n\t\t\t\tif bsc.greek:\n\t\t\t\t\tlabel += '(' + STAR_LABELS[bsc.greek] + ' ' + bsc.constellation.capitalize() + ')'\n\t\t\t\telif bsc.flamsteed:\n\t\t\t\t\tlabel += '(' + str(bsc.flamsteed) + ')'\n\t\t\t\telif bsc.HD is not None:\n\t\t\t\t\tlabel += '(HD' + str(bsc.HD) + ')'\n\t\t\tself.draw_circular_object_label(x, y, r, label)\n\t\t\tself.graphics.set_font(self.graphics.gi_font, fn)\n\n\tdef draw_stars_labels(self, star_labels):\n\t\tfn = self.graphics.gi_fontsize\n\t\tprinted = {}\n\t\tbayer_fn = self.config.bayer_label_font_fac * fn\n\t\tflamsteed_fn = self.config.flamsteed_label_font_fac * fn\n\t\tfor x, y, r, star in star_labels:\n\t\t\tif isinstance(star, str):\n\t\t\t\tself.graphics.set_font(self.graphics.gi_font, 0.9*fn)\n\t\t\t\tself.draw_circular_object_label(x, y, r, star)\n\t\t\telse:\n\t\t\t\tslabel = star.greek\n\t\t\t\tif not slabel and self.config.show_flamsteed:\n\t\t\t\t\tslabel = star.flamsteed\n\t\t\t\tif slabel:\n\t\t\t\t\tprinted_labels = printed.setdefault(star.constellation, set())\n\t\t\t\t\tif slabel not in printed_labels:\n\t\t\t\t\t\tprinted_labels.add(slabel)\n\t\t\t\t\t\tif slabel in STAR_LABELS:\n\t\t\t\t\t\t\tself.graphics.set_font(self.graphics.gi_font, bayer_fn)\n\t\t\t\t\t\t\tslabel = STAR_LABELS.get(slabel)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tself.graphics.set_font(self.graphics.gi_font, flamsteed_fn)\n\t\t\t\t\t\tself.draw_circular_object_label(x, y, r, slabel)\n\n\t\tself.graphics.set_font(self.graphics.gi_font, fn)\n\n\tdef draw_constellations(self, constell_catalog, hl_constellation):\n\t\t# print('Drawing constellations...')\n\t\tif self.config.show_constellation_borders:\n\t\t\tself.draw_constellation_boundaries(constell_catalog, hl_constellation)\n\t\tif self.config.show_constellation_shapes:\n\t\t\tself.draw_constellation_shapes(constell_catalog)\n\n\tdef draw_grid_equatorial(self):\n\t\t# print('Drawing equatorial grid...')\n\t\tself.graphics.save()\n\t\tself.graphics.set_linewidth(self.config.grid_linewidth)\n\t\tself.graphics.set_pen_rgb(self.config.grid_color)\n\n\t\tself.draw_grid_ra()\n\t\tself.draw_grid_dec()\n\n\t\tself.graphics.restore()\n\n\tdef grid_dec_label(self, dec_minutes, label_fmt):\n\t\tdeg = abs(int(dec_minutes/60))\n\t\tminutes = abs(dec_minutes) - deg * 60\n\t\tif dec_minutes > 0:\n\t\t\tprefix = '+'\n\t\telif dec_minutes < 0:\n\t\t\tprefix = '-'\n\t\telse:\n\t\t\tprefix = ''\n\t\treturn prefix + label_fmt.format(deg, minutes)\n\n\tdef grid_ra_label(self, ra_minutes, label_fmt):\n\t\thrs = int(ra_minutes/60)\n\t\tmins = int(ra_minutes) % 60\n\t\tsecs = int(ra_minutes % 1 * 60)\n\t\treturn label_fmt.format(hrs, mins, secs)\n\n\tdef draw_grid_ra(self):\n\t\tprev_steps, prev_grid_minutes = (None, None)\n\t\tfor grid_minutes in DEC_GRID_SCALE:\n\t\t\tsteps = self.fieldradius / (np.pi * grid_minutes / (180 * 60))\n\t\t\tif steps < GRID_DENSITY:\n\t\t\t\tif prev_steps is not None:\n\t\t\t\t\tif prev_steps-GRID_DENSITY < GRID_DENSITY-steps:\n\t\t\t\t\t\tgrid_minutes = prev_grid_minutes\n\t\t\t\tbreak\n\t\t\tprev_steps, prev_grid_minutes = (steps, grid_minutes)\n\n\t\tdec_min = self.fieldcentre[1] - self.fieldradius\n\t\tdec_max = self.fieldcentre[1] + self.fieldradius\n\n\t\tlabel_fmt = '{}\u00b0' if grid_minutes >= 60 else '{}\u00b0{:02d}\\''\n\n\t\tdec_minutes = -90*60 + grid_minutes\n\n\t\twhile dec_minutes < 90*60:\n\t\t\tdec = np.pi * dec_minutes / (180*60)\n\t\t\tif (dec > dec_min) and (dec < dec_max):\n\t\t\t\tself.draw_grid_ra_line(dec, dec_minutes, label_fmt)\n\t\t\tdec_minutes += grid_minutes\n\n\tdef draw_grid_ra_line(self, dec, dec_minutes, label_fmt):\n\t\tdra = self.fieldradius / 10\n\t\tx11, y11, z11 = (None, None, None)\n\t\tagg_ra = 0\n\t\twhile True:\n\t\t\tx12, y12, z12 = radec_to_xyz(self.fieldcentre[0] + agg_ra, dec, self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\t\t\tx22, y22, z22 = radec_to_xyz(self.fieldcentre[0] - agg_ra, dec, self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\t\t\tif x11 is not None and z11 > 0 and z12 > 0:\n\t\t\t\tself.mirroring_graphics.line(x11, y11, x12, y12)\n\t\t\t\tself.mirroring_graphics.line(x21, y21, x22, y22)\n\t\t\tagg_ra = agg_ra + dra\n\t\t\tif agg_ra > np.pi:\n\t\t\t\tbreak\n\t\t\tif x12 < -self.drawingwidth/2:\n\t\t\t\ty = (y12-y11) * (self.drawingwidth/2 + x11) / (x11 - x12) + y11\n\t\t\t\tlabel = self.grid_dec_label(dec_minutes, label_fmt)\n\t\t\t\tself.graphics.save()\n\t\t\t\tself.mirroring_graphics.translate(-self.drawingwidth/2,y)\n\t\t\t\ttext_ang = math.atan2(y11-y12, x11-x12)\n\t\t\t\tself.mirroring_graphics.rotate(text_ang)\n\t\t\t\tfh = self.graphics.gi_fontsize\n\t\t\t\tif dec >= 0:\n\t\t\t\t\tself.graphics.text_right(2*fh/3, +fh/3, label)\n\t\t\t\telse:\n\t\t\t\t\tself.graphics.text_right(2*fh/3, -fh, label)\n\t\t\t\tself.graphics.restore()\n\t\t\t\tbreak\n\t\t\tx11, y11, z11 = (x12, y12, z12)\n\t\t\tx21, y21, z21 = (x22, y22, z22)\n\n\tdef draw_grid_dec(self):\n\t\tprev_steps, prev_grid_minutes = (None, None)\n\t\tfc_cos = math.cos(self.fieldcentre[1])\n\t\tfor grid_minutes in RA_GRID_SCALE:\n\t\t\tsteps = self.fieldradius / (fc_cos * (np.pi * grid_minutes / (12 * 60)))\n\t\t\tif steps < GRID_DENSITY:\n\t\t\t\tif prev_steps is not None:\n\t\t\t\t\tif prev_steps-GRID_DENSITY < GRID_DENSITY-steps:\n\t\t\t\t\t\tgrid_minutes = prev_grid_minutes\n\t\t\t\tbreak\n\t\t\tprev_steps, prev_grid_minutes = (steps, grid_minutes)\n\n\t\tmax_visible_dec = self.fieldcentre[1]+self.fieldradius if self.fieldcentre[1] > 0 else self.fieldcentre[1]-self.fieldradius;\n\t\tif max_visible_dec >= np.pi/2 or max_visible_dec <= -np.pi/2:\n\t\t\tra_size = 2*np.pi\n\t\telse:\n\t\t\tra_size = self.fieldradius / math.cos(max_visible_dec)\n\t\t\tif ra_size > 2*np.pi:\n\t\t\t\tra_size = 2*np.pi\n\n\t\tif grid_minutes >= 60:\n\t\t\tlabel_fmt = '{}h'\n\t\telif grid_minutes >= 1:\n\t\t\tlabel_fmt = '{}h{:02d}m'\n\t\telse:\n\t\t\tlabel_fmt = '{}h{:02d}m{:02d}s'\n\n\t\tra_minutes = 0\n\n\t\twhile ra_minutes <= 24*60:\n\t\t\tra = np.pi * ra_minutes / (12*60)\n\t\t\tif abs(self.fieldcentre[0]-ra) < ra_size or abs(self.fieldcentre[0]-2*np.pi-ra) < ra_size or abs(2*np.pi+self.fieldcentre[0]-ra) < ra_size:\n\t\t\t\tself.draw_grid_dec_line(ra, ra_minutes, label_fmt)\n\t\t\tra_minutes += grid_minutes\n\n\tdef draw_grid_dec_line(self, ra, ra_minutes, label_fmt):\n\t\tddec = self.fieldradius / 10\n\t\tx11, y11, z11 = (None, None, None)\n\t\tx21, y21, z21 = (None, None, None)\n\t\tagg_dec = 0\n\t\twhile True:\n\t\t\tx12, y12, z12 = radec_to_xyz(ra, self.fieldcentre[1] + agg_dec, self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\t\t\tx22, y22, z22 = radec_to_xyz(ra, self.fieldcentre[1] - agg_dec, self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\t\t\tif x11 is not None:\n\t\t\t\tif z11 > 0 and z12 > 0:\n\t\t\t\t\tself.mirroring_graphics.line(x11, y11, x12, y12)\n\t\t\t\tif z21 > 0 and z22 > 0:\n\t\t\t\t\tself.mirroring_graphics.line(x21, y21, x22, y22)\n\t\t\tagg_dec = agg_dec + ddec\n\t\t\tif agg_dec > np.pi/2:\n\t\t\t\tbreak\n\t\t\tif y12 > self.drawingheight/2 and y22 < -self.drawingheight/2:\n\t\t\t\tlabel = self.grid_ra_label(ra_minutes, label_fmt)\n\t\t\t\tself.graphics.save()\n\t\t\t\tif self.fieldcentre[1] <= 0:\n\t\t\t\t\tx = (x12-x11) * (self.drawingheight/2 - y11) / (y12 - y11) + x11\n\t\t\t\t\tself.mirroring_graphics.translate(x, self.drawingheight/2)\n\t\t\t\t\ttext_ang = math.atan2(y11-y12, x11-x12)\n\t\t\t\telse:\n\t\t\t\t\tx = (x22-x21) * (-self.drawingheight/2 - y21) / (y22 - y21) + x21\n\t\t\t\t\tself.mirroring_graphics.translate(x, -self.drawingheight/2)\n\t\t\t\t\ttext_ang = math.atan2(y21-y22, x21-x22)\n\t\t\t\tself.mirroring_graphics.rotate(text_ang)\n\t\t\t\tfh = self.graphics.gi_fontsize\n\t\t\t\tself.graphics.text_right(2*fh/3, fh/3, label)\n\t\t\t\tself.graphics.restore()\n\t\t\t\tbreak\n\t\t\tx11, y11, z11 = (x12, y12, z12)\n\t\t\tx21, y21, z21 = (x22, y22, z22)\n\n\tdef draw_constellation_shapes(self, constell_catalog):\n\t\tself.graphics.save()\n\t\tself.graphics.set_linewidth(self.config.constellation_linewidth)\n\t\tself.graphics.set_pen_rgb(self.config.constellation_lines_color)\n\n\t\tx1, y1, z1 = np_radec_to_xyz(constell_catalog.all_constell_lines[:, 0], constell_catalog.all_constell_lines[:, 1], self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\t\tx2, y2, z2 = np_radec_to_xyz(constell_catalog.all_constell_lines[:, 2], constell_catalog.all_constell_lines[:, 3], self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\n\t\tfor i in range(len(x1)):\n\t\t\tif z1[i] > 0 and z2[i] > 0:\n\t\t\t\tif self.config.constellation_linespace > 0:\n\t\t\t\t\tdx = x2[i] - x1[i]\n\t\t\t\t\tdy = y2[i] - y1[i]\n\t\t\t\t\tdr = math.sqrt(dx * dx + dy*dy)\n\t\t\t\t\tddx = dx * self.config.constellation_linespace / dr\n\t\t\t\t\tddy = dy * self.config.constellation_linespace / dr\n\t\t\t\t\tself.mirroring_graphics.line(x1[i] + ddx, y1[i] + ddy, x2[i] - ddx, y2[i] - ddy)\n\t\t\t\telse:\n\t\t\t\t\tself.mirroring_graphics.line(x1[i], y1[i], x2[i], y2[i])\n\n\t\tself.graphics.restore()\n\n\tdef draw_constellation_boundaries(self, constell_catalog, hl_constellation):\n\t\tself.graphics.save()\n\t\tself.graphics.set_dashed_line(0.6, 1.2)\n\n\t\tx, y, z = np_radec_to_xyz(constell_catalog.boundaries_points[:,0], constell_catalog.boundaries_points[:,1], self.fieldcentre, self.drawingscale, self.fc_sincos_dec)\n\n\t\thl_constellation = hl_constellation.upper() if hl_constellation else None\n\n\t\tfor index1, index2, cons1, cons2 in constell_catalog.boundaries_lines:\n\t\t\tif z[index1] > 0 and z[index2] > 0:\n\t\t\t\tif hl_constellation and (hl_constellation == cons1 or hl_constellation == cons2):\n\t\t\t\t\tself.graphics.set_pen_rgb(self.config.constellation_hl_border_color)\n\t\t\t\t\tself.graphics.set_linewidth(self.config.constellation_linewidth * 1.75)\n\t\t\t\telse:\n\t\t\t\t\tself.graphics.set_pen_rgb(self.config.constellation_border_color)\n\t\t\t\t\tself.graphics.set_linewidth(self.config.constellation_border_linewidth)\n\n\t\t\t\tself.mirroring_graphics.line(x[index1], y[index1], x[index2], y[index2])\n\n\t\tself.graphics.restore()\n\n\tdef make_map(self, used_catalogs, showing_dsos=None, hl_showing_dsos=False, highlights=None, dso_hide_filter=None,\n\t\t\t\t extra_positions=None, hl_constellation=None, trajectory=[], visible_objects=None, use_optimized_mw=False):\n\t\t\"\"\" Creates map using given graphics, params and config\n\t\tused_catalogs - UsedCatalogs data structure\n\t\tshowing_dso - DSO forced to be shown even if they don't pass the filter\n\t\thl_showing_dsos - True if showing dso will be highlighted\n\t\thighlights - list of HighlightDefinitions that will be marked\n\t\tdso_hide_filter - list of DSO to be hidden, except showing_dso\n\t\textra_positions - extra positions to be drawn\n\t\thl_constellation - constellation name that will be highlighted\n\t\ttrajectory - defined by list of points (ra, dec) points\n\t\tvisible_objects - output array containing list of object visible on the map\n\t\t\"\"\"\n\t\tvisible_dso_collector = [] if visible_objects is not None else None\n\t\tself.picked_dso = None\n\n\t\tif self.config.mirror_x or self.config.mirror_y:\n\t\t\tself.mirroring_graphics = MirroringGraphics(self.graphics, self.config.mirror_x, self.config.mirror_y)\n\t\telse:\n\t\t\tself.mirroring_graphics = self.graphics\n\n\t\tself.create_widgets()\n\n\t\tself.graphics.set_background_rgb(self.config.background_color)\n\n\t\tself.graphics.new()\n\n\t\tif not self.config.legend_only:\n\t\t\tself.graphics.clear()\n\n\t\tself.graphics.set_pen_rgb(self.config.draw_color)\n\t\tself.graphics.set_fill_rgb(self.config.draw_color)\n\t\tself.graphics.set_font(font=self.config.font, fontsize=self.config.font_size)\n\t\tself.graphics.set_linewidth(self.config.legend_linewidth)\n\n\t\tx1, y1, x2, y2 = self.get_field_rect_mm()\n\n\t\tw_mags_width, w_mags_heigth = self.w_mag_scale.get_size()\n\t\tw_maps_width, w_maps_height = self.w_map_scale.get_size()\n\n\t\tif not self.config.legend_only:\n\n\t\t\tif self.config.show_map_scale_legend or self.config.show_mag_scale_legend:\n\t\t\t\tclip_path = [(x2, y2)]\n\n\t\t\t\tif self.config.show_map_scale_legend:\n\t\t\t\t\tclip_path.extend([(x2, y1+w_maps_height),\n\t\t\t\t\t\t\t\t\t (x2-w_maps_width, y1+w_maps_height),\n\t\t\t\t\t\t\t\t\t (x2-w_maps_width, y1)])\n\t\t\t\telse:\n\t\t\t\t\tclip_path.append((x2, y1))\n\n\t\t\t\tif self.config.show_mag_scale_legend:\n\t\t\t\t\tclip_path.extend([(x1 + w_mags_width, y1),\n\t\t\t\t\t\t\t\t\t (x1 + w_mags_width, y1 + w_mags_heigth),\n\t\t\t\t\t\t\t\t\t (x1, y1 + w_mags_heigth)])\n\t\t\t\telse:\n\t\t\t\t\tclip_path.append((x1, y1))\n\n\t\t\t\tclip_path.append((x1, y2))\n\n\t\t\t\tself.graphics.clip_path(clip_path)\n\n\t\t\tif self.config.show_milky_way:\n\t\t\t\tself.draw_milky_way(used_catalogs.milky_way)\n\t\t\telif self.config.show_enhanced_milky_way:\n\t\t\t\tself.draw_enhanced_milky_way(used_catalogs.enhanced_milky_way, use_optimized_mw)\n\n\t\t\tif self.config.show_equatorial_grid:\n\t\t\t\t# tm = time()\n\t\t\t\tself.draw_grid_equatorial()\n\t\t\t\t# print(\"Equatorial grid within {} s\".format(str(time()-tm)), flush=True)\n\n\t\t\tif highlights:\n\t\t\t\tself.draw_highlights(highlights, visible_dso_collector)\n\n\t\t\tif used_catalogs.constellcatalog is not None:\n\t\t\t\t# tm = time()\n\t\t\t\tself.draw_constellations(used_catalogs.constellcatalog, hl_constellation)\n\t\t\t\t# print(\"constellations within {} s\".format(str(time()-tm)), flush=True)\n\n\t\t\tif used_catalogs.unknown_nebulas is not None:\n\t\t\t\tself.draw_unknown_nebula(used_catalogs.unknown_nebulas)\n\n\t\t\tif used_catalogs.deepskycatalog is not None:\n\t\t\t\t# tm = time()\n\t\t\t\tself.draw_deepsky_objects(used_catalogs.deepskycatalog, showing_dsos, hl_showing_dsos, dso_hide_filter, visible_dso_collector)\n\t\t\t\t# print(\"DSO within {} s\".format(str(time()-tm)), flush=True)\n\n\t\t\tif extra_positions:\n\t\t\t\tself.draw_extra_objects(extra_positions)\n\n\t\t\tif trajectory:\n\t\t\t\tself.draw_trajectory(trajectory)\n\n\t\t\tif used_catalogs.starcatalog is not None:\n\t\t\t\t# tm = time()\n\t\t\t\tself.draw_stars(used_catalogs.starcatalog, self.picked_dso is None)\n\t\t\t\t# print(\"Stars within {} s\".format(str(time()-tm)), flush=True)\n\n\t\t\tself.graphics.reset_clip()\n\n\t\t# print('Drawing legend')\n\t\tself.draw_caption()\n\n\t\t# print('Drawing widgets')\n\t\tself.draw_widgets()\n\n\t\t# Draw border of field-of-view\n\t\tself.draw_field_border()\n\n\t\t# tm = time()\n\t\tself.graphics.finish()\n\t\t# print(\"Rest {} ms\".format(str(time()-tm)), flush=True)\n\n\t\tif visible_dso_collector is not None:\n\t\t\tvisible_dso_collector.sort(key=lambda x: x[0])\n\t\t\tfor obj in visible_dso_collector:\n\t\t\t\tvisible_objects.extend([obj[1], obj[2], obj[3], obj[4], obj[5]])\n\n\tdef create_widgets(self):\n\t\tself.w_mag_scale = WidgetMagnitudeScale(self,\n\t\t\t\t\t\t\t\t\t\t\t\tlegend_fontsize=self.get_legend_font_size(),\n\t\t\t\t\t\t\t\t\t\t\t\tstars_in_scale=STARS_IN_SCALE,\n\t\t\t\t\t\t\t\t\t\t\t\tlm_stars=self.lm_stars,\n\t\t\t\t\t\t\t\t\t\t\t\tlegend_linewidth=self.config.legend_linewidth)\n\n\t\tself.w_map_scale = WidgetMapScale(drawingscale=self.drawingscale,\n\t\t\t\t\t\t\t\t\t\t  maxlength=self.drawingwidth/3.0,\n\t\t\t\t\t\t\t\t\t\t  legend_fontsize=self.get_legend_font_size(),\n\t\t\t\t\t\t\t\t\t\t  legend_linewidth=self.config.legend_linewidth)\n\n\t\tself.w_orientation = WidgetOrientation(legend_fontsize=self.get_legend_font_size(),\n\t\t\t\t\t\t\t\t\t\t\t   mirror_x=self.config.mirror_x,\n\t\t\t\t\t\t\t\t\t\t\t   mirror_y=self.config.mirror_y)\n\n\t\tself.w_coords = WidgetCoords(self.language)\n\t\tself.w_dso_legend = WidgetDsoLegend(self.language, self.drawingwidth, LEGEND_MARGIN)\n\t\tself.w_telrad = WidgetTelrad(self.drawingscale, self.config.telrad_linewidth, self.config.telrad_color)\n\t\tself.w_eyepiece = WidgetEyepiece(self.drawingscale, self.config.eyepiece_fov, self.config.eyepiece_linewidth, self.config.eyepiece_color)\n\t\tself.w_picker = WidgetPicker(self.config.picker_radius, self.config.picker_linewidth, self.config.picker_color)\n\n\tdef star(self, x, y, radius, star_color):\n\t\t\"\"\"\n\t\tFilled circle with boundary. Set fill colour and boundary\n\t\tcolour in advance using set_pen_rgb and set_fill_rgb\n\t\t\"\"\"\n\t\tif self.config.star_colors and star_color:\n\t\t\tself.graphics.set_fill_rgb(star_color)\n\n\t\tr = round(radius, 2)\n\t\tself.mirroring_graphics.circle(x, y, r, DrawMode.FILL)\n\n\tdef no_mirror_star(self, x, y, radius):\n\t\t\"\"\"\n\t\tFilled circle with boundary. Set fill colour and boundary\n\t\tcolour in advance using set_pen_rgb and set_fill_rgb\n\t\t\"\"\"\n\t\tr = int((radius + self.graphics.gi_linewidth/2.0)*100.0 + 0.5)/100.0\n\t\tself.graphics.circle(x, y, r, DrawMode.BOTH)\n\n\tdef open_cluster(self, x, y, radius, label, label_ext, labelpos):\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/40.0\n\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_pen_rgb(self.config.star_cluster_color)\n\t\tself.graphics.set_linewidth(self.config.open_cluster_linewidth)\n\t\tself.graphics.set_dashed_line(0.6, 0.4)\n\n\t\tself.mirroring_graphics.circle(x, y, r)\n\t\tif label_ext:\n\t\t\tlabel_fh = self.config.ext_label_font_fac * self.graphics.gi_fontsize\n\t\t\tself.graphics.set_font(self.graphics.gi_font, label_fh)\n\t\telse:\n\t\t\tlabel_fh = None\n\n\t\tself.draw_circular_object_label(x, y, r, label, labelpos, label_fh)\n\t\tif label_ext:\n\t\t\tself.draw_circular_object_label(x, y, r, label_ext, self.to_ext_labelpos(labelpos), label_fh)\n\t\tself.graphics.restore()\n\n\tdef galaxy_cluster(self, x, y, radius, label, label_ext, labelpos):\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/40.0\n\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_pen_rgb(self.config.galaxy_cluster_color)\n\t\tself.graphics.set_linewidth(self.config.galaxy_cluster_linewidth)\n\t\tself.graphics.set_dashed_line(0.5, 2.0)\n\n\t\tself.mirroring_graphics.circle(x, y, r)\n\t\tif label_ext:\n\t\t\tlabel_fh = self.config.ext_label_font_fac * self.graphics.gi_fontsize\n\t\t\tself.graphics.set_font(self.graphics.gi_font, label_fh)\n\t\telse:\n\t\t\tlabel_fh = None\n\n\t\tself.draw_circular_object_label(x, y, r, label, labelpos, label_fh)\n\t\tif label_ext:\n\t\t\tself.draw_circular_object_label(x, y, r, label_ext, self.to_ext_labelpos(labelpos), label_fh)\n\t\tself.graphics.restore()\n\n\tdef draw_asterism_label(self, x, y, label, labelpos, d, fh):\n\t\tif labelpos == 0 or labelpos == -1:\n\t\t\tself.mirroring_graphics.text_centred(x, y-d-2*fh/3.0, label)\n\t\telif labelpos == 1:\n\t\t\tself.mirroring_graphics.text_centred(x, y+d+fh/3.0, label)\n\t\telif labelpos == 2:\n\t\t\tself.mirroring_graphics.text_left(x-d-fh/6.0, y-fh/3.0, label)\n\t\telif labelpos == 3:\n\t\t\tself.mirroring_graphics.text_right(x+d+fh/6.0, y-fh/3.0, label)\n\n\tdef asterism(self, x, y, radius, label, label_ext, labelpos):\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/40.0\n\t\tw2 = 2**0.5\n\t\td = r/2.0*w2\n\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_pen_rgb(self.config.star_cluster_color)\n\t\tself.graphics.set_linewidth(self.config.open_cluster_linewidth)\n\t\tself.graphics.set_dashed_line(0.6, 0.4)\n\n\t\tdiff = self.graphics.gi_linewidth/2.0/w2\n\n\t\tself.mirroring_graphics.line(x-diff, y+d+diff, x+d+diff, y-diff)\n\t\tself.mirroring_graphics.line(x+d, y, x, y-d)\n\t\tself.mirroring_graphics.line(x+diff, y-d-diff, x-d-diff, y+diff)\n\t\tself.mirroring_graphics.line(x-d, y, x, y+d)\n\n\t\tif label_ext:\n\t\t\tlabel_fh = self.config.ext_label_font_fac * self.graphics.gi_fontsize\n\t\t\tself.graphics.set_font(self.graphics.gi_font, label_fh)\n\t\telse:\n\t\t\tlabel_fh = self.graphics.gi_fontsize\n\n\t\tif label:\n\t\t\tself.graphics.set_pen_rgb(self.config.label_color)\n\t\t\tself.draw_asterism_label(x, y, label, labelpos, d, label_fh)\n\n\t\tif label_ext:\n\t\t\tself.graphics.set_pen_rgb(self.config.label_color)\n\t\t\tself.draw_asterism_label(x, y, label_ext, self.to_ext_labelpos(labelpos), d, label_fh)\n\n\t\tself.graphics.restore()\n\n\tdef asterism_labelpos(self, x, y, radius=-1, label_length=0.0):\n\t\t\"\"\"\n\t\tx,y,radius, label_length in mm\n\t\treturns [[start, centre, end],()]\n\t\t\"\"\"\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/40.0\n\t\tw2 = 2**0.5\n\t\td = r/2.0*w2\n\t\tfh = self.graphics.gi_fontsize\n\t\tlabel_pos_list = []\n\t\tyy = y-d-2*fh/3.0\n\t\tlabel_pos_list.append([[x-label_length/2.0, yy], [x, yy], [x+label_length, yy]])\n\t\tyy = y+d+2*fh/3.0\n\t\tlabel_pos_list.append([[x-label_length/2.0, yy], [x, yy], [x+label_length, yy]])\n\t\txx = x-d-fh/6.0\n\t\tyy = y\n\t\tlabel_pos_list.append([[xx-label_length, yy], [xx-label_length/2.0, yy], [xx, yy]])\n\t\txx = x+d+fh/6.0\n\t\tyy = y\n\t\tlabel_pos_list.append([[xx, yy], [xx+label_length/2.0, yy], [xx+label_length, yy]])\n\t\treturn label_pos_list\n\n\tdef draw_galaxy_label(self, x, y, label, labelpos, rlong, rshort, fh):\n\t\tif labelpos == 0 or labelpos == -1:\n\t\t\tself.graphics.text_centred(0, -rshort-0.5*fh, label)\n\t\telif labelpos == 1:\n\t\t\tself.graphics.text_centred(0, +rshort+0.5*fh, label)\n\t\telif labelpos == 2:\n\t\t\tself.graphics.text_right(rlong+fh/6.0, -fh/3.0, label)\n\t\telif labelpos == 3:\n\t\t\tself.graphics.text_left(-rlong-fh/6.0, -fh/3.0, label)\n\n\tdef galaxy(self, x, y, rlong, rshort, posangle, mag, label, label_ext, labelpos):\n\t\t\"\"\"\n\t\tIf rlong != -1 and rshort == -1 =>   rshort <- rlong\n\t\tif rlong < 0.0 => standard galaxy\n\t\tlabelpos can be 0,1,2,3\n\t\t\"\"\"\n\t\trl = rlong\n\t\trs = rshort\n\t\tif rlong <= 0.0:\n\t\t\trl = self.drawingwidth/40.0\n\t\t\trs = rl/2.0\n\t\tif (rlong > 0.0) and (rshort < 0.0):\n\t\t\trl = rlong\n\t\t\trs = rlong/2.0\n\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_linewidth(self.config.dso_linewidth)\n\t\tif self.config.dso_dynamic_brightness and (mag is not None) and self.lm_deepsky >= 10.0 and label_ext is None:\n\t\t\tfac = self.lm_deepsky - 8.0\n\t\t\tif fac > 5:\n\t\t\t\tfac = 5.0\n\t\t\tdiff_mag = self.lm_deepsky - mag\n\t\t\tif diff_mag < 0:\n\t\t\t\tdiff_mag = 0\n\t\t\tif diff_mag > 5:\n\t\t\t\tdiff_mag = 5\n\t\t\tdso_intensity = 1.0 if diff_mag > fac else 0.5 + 0.5 * diff_mag / fac;\n\t\telse:\n\t\t\tdso_intensity = 1.0\n\n\t\tself.graphics.set_pen_rgb((self.config.galaxy_color[0]*dso_intensity,\n\t\t\t\t\t\t\t\t   self.config.galaxy_color[1]*dso_intensity,\n\t\t\t\t\t\t\t\t   self.config.galaxy_color[2]*dso_intensity))\n\n\t\tp = posangle\n\t\tif posangle >= 0.5*np.pi:\n\t\t\tp += np.pi\n\t\tif posangle < -0.5*np.pi:\n\t\t\tp -= np.pi\n\n\t\tself.mirroring_graphics.ellipse(x, y, rl, rs, p)\n\n\t\tif label or label_ext:\n\t\t\tself.mirroring_graphics.translate(x, y)\n\t\t\tself.mirroring_graphics.rotate(p)\n\t\t\tself.graphics.set_pen_rgb((self.config.label_color[0]*dso_intensity,\n\t\t\t\t\t\t\t\t\t   self.config.label_color[1]*dso_intensity,\n\t\t\t\t\t\t\t\t\t   self.config.label_color[2]*dso_intensity))\n\t\t\tif label_ext:\n\t\t\t\tlabel_fh = self.config.ext_label_font_fac * self.graphics.gi_fontsize\n\t\t\telse:\n\t\t\t\tlabel_fh = self.graphics.gi_fontsize\n\n\t\t\tself.graphics.set_font(self.graphics.gi_font, label_fh)\n\n\t\t\tif label:\n\t\t\t\tself.draw_galaxy_label(x, y, label, labelpos, rlong, rshort, label_fh)\n\t\t\tif label_ext:\n\t\t\t\tself.draw_galaxy_label(x, y, label_ext, self.to_ext_labelpos(labelpos), rlong, rshort, label_fh)\n\n\t\tself.graphics.restore()\n\n\tdef galaxy_labelpos(self, x, y, rlong=-1, rshort=-1, posangle=0.0, label_length=0.0):\n\t\trl = rlong\n\t\trs = rshort\n\t\tif rlong <= 0.0:\n\t\t\trl = self.drawingwidth/40.0\n\t\t\trs = rl/2.0\n\t\tif (rlong > 0.0) and (rshort < 0.0):\n\t\t\trl = rlong\n\t\t\trs = rlong/2.0\n\n\t\tp = posangle\n\t\tif posangle >= 0.5*np.pi:\n\t\t\tp += np.pi\n\t\tif posangle < -0.5*np.pi:\n\t\t\tp -= np.pi\n\n\t\tfh = self.graphics.gi_fontsize\n\t\tlabel_pos_list = []\n\n\t\tsp = math.sin(p)\n\t\tcp = math.cos(p)\n\n\t\thl = label_length/2.0\n\n\t\td = -rshort-0.5*fh\n\t\txc = x + d*sp\n\t\tyc = y - d*cp\n\t\txs = xc - hl*cp\n\t\tys = yc - hl*sp\n\t\txe = xc + hl*cp\n\t\tye = yc + hl*sp\n\t\tlabel_pos_list.append([[xs, ys], [xc, yc], [xe, ye]])\n\n\t\txc = x - d*sp\n\t\tyc = y + d*cp\n\t\txs = xc - hl*cp\n\t\tys = yc - hl*sp\n\t\txe = xc + hl*cp\n\t\tye = yc + hl*sp\n\t\tlabel_pos_list.append([[xs, ys], [xc, yc], [xe, ye]])\n\n\t\td = rlong+fh/6.0\n\t\txs = x + d*cp\n\t\tys = y + d*sp\n\t\txc = xs + hl*cp\n\t\tyc = ys + hl*sp\n\t\txe = xc + hl*cp\n\t\tye = yc + hl*sp\n\t\tlabel_pos_list.append([[xs, ys], [xc, yc], [xe, ye]])\n\n\t\txe = x - d*cp\n\t\tye = y - d*sp\n\t\txc = xe - hl*cp\n\t\tyc = ye - hl*sp\n\t\txs = xc - hl*cp\n\t\tys = yc - hl*sp\n\t\tlabel_pos_list.append([[xs, ys], [xc, yc], [xe, ye]])\n\t\treturn label_pos_list\n\n\tdef to_ext_labelpos(self, labelpos):\n\t\tif labelpos == 0:\n\t\t\treturn 1\n\t\tif labelpos == 1:\n\t\t\treturn 0\n\t\tif labelpos == 2:\n\t\t\treturn 3\n\t\tif labelpos == 3:\n\t\t\treturn 2\n\t\treturn 1\n\n\tdef draw_circular_object_label(self, x, y, r, label, labelpos=-1, fh=None):\n\t\tif fh is None:\n\t\t\tfh = self.graphics.gi_fontsize\n\t\tif label:\n\t\t\tself.graphics.set_pen_rgb(self.config.label_color)\n\t\t\targ = 1.0-2*fh/(3.0*r)\n\t\t\tif (arg < 1.0) and (arg > -1.0):\n\t\t\t\ta = math.acos(arg)\n\t\t\telse:\n\t\t\t\ta = 0.5*np.pi\n\t\t\tif labelpos == 0 or labelpos == -1:\n\t\t\t\tself.mirroring_graphics.text_right(x+math.sin(a)*r+fh/6.0, y-r, label)\n\t\t\telif labelpos == 1:\n\t\t\t\tself.mirroring_graphics.text_left(x-math.sin(a)*r-fh/6.0, y-r, label)\n\t\t\telif labelpos == 2:\n\t\t\t\tself.mirroring_graphics.text_right(x+math.sin(a)*r+fh/6.0, y+r-2*fh/3.0, label)\n\t\t\telif labelpos == 3:\n\t\t\t\tself.mirroring_graphics.text_left(x-math.sin(a)*r-fh/6.0, y+r-2*fh/3.0, label)\n\n\tdef circular_object_labelpos(self, x, y, radius=-1.0, label_length=0.0):\n\t\tfh = self.graphics.gi_fontsize\n\t\tr = radius\n\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/40.0\n\n\t\targ = 1.0-2*fh/(3.0*r)\n\n\t\tif (arg < 1.0) and (arg > -1.0):\n\t\t\ta = math.acos(arg)\n\t\telse:\n\t\t\ta = 0.5*np.pi\n\n\t\tlabel_pos_list = []\n\t\txs = x+math.sin(a)*r+fh/6.0\n\t\tys = y-r+fh/3.0\n\t\tlabel_pos_list.append([[xs, ys], [xs+label_length/2.0, ys], [xs+label_length, ys]])\n\t\txs = x-math.sin(a)*r-fh/6.0 - label_length\n\t\tlabel_pos_list.append([[xs, ys], [xs+label_length/2.0, ys], [xs+label_length, ys]])\n\n\t\txs = x+math.sin(a)*r+fh/6.0\n\t\tys = y+r-fh/3.0\n\t\tlabel_pos_list.append([[xs, ys], [xs+label_length/2.0, ys], [xs+label_length, ys]])\n\n\t\txs = x+math.sin(a)*r+fh/6.0\n\t\tys = y+r-fh/3.0\n\t\tlabel_pos_list.append([[xs, ys], [xs+label_length/2.0, ys], [xs+label_length, ys]])\n\t\treturn label_pos_list\n\n\tdef globular_cluster(self, x, y, radius, label, label_ext, labelpos):\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/40.0\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_linewidth(self.config.dso_linewidth)\n\t\tself.graphics.set_pen_rgb(self.config.star_cluster_color)\n\n\t\tself.mirroring_graphics.circle(x, y, r)\n\t\tself.mirroring_graphics.line(x-r, y, x+r, y)\n\t\tself.mirroring_graphics.line(x, y-r, x, y+r)\n\n\t\tif label_ext:\n\t\t\tlabel_fh = self.config.ext_label_font_fac * self.graphics.gi_fontsize\n\t\t\tself.graphics.set_font(self.graphics.gi_font, label_fh)\n\t\telse:\n\t\t\tlabel_fh = None\n\n\t\tself.draw_circular_object_label(x, y, r, label, labelpos, label_fh)\n\t\tif label_ext:\n\t\t\tself.draw_circular_object_label(x, y, r, label_ext, self.to_ext_labelpos(labelpos), label_fh)\n\n\t\tself.graphics.restore()\n\n\tdef diffuse_nebula(self, x, y, width, height, posangle, label, label_ext, labelpos):\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_linewidth(self.config.nebula_linewidth)\n\t\tself.graphics.set_pen_rgb(self.config.nebula_color)\n\n\t\td = 0.5*width\n\t\tif width < 0.0:\n\t\t\td = self.drawingwidth/40.0\n\t\td1 = d+self.graphics.gi_linewidth/2.0\n\n\t\tself.mirroring_graphics.line(x-d1, y+d, x+d1, y+d)\n\t\tself.mirroring_graphics.line(x+d, y+d, x+d, y-d)\n\t\tself.mirroring_graphics.line(x+d1, y-d, x-d1, y-d)\n\t\tself.mirroring_graphics.line(x-d, y-d, x-d, y+d)\n\n\t\tif label_ext:\n\t\t\tlabel_fh = self.config.ext_label_font_fac * self.graphics.gi_fontsize\n\t\t\tself.graphics.set_font(self.graphics.gi_font, label_fh)\n\t\telse:\n\t\t\tlabel_fh = self.graphics.gi_fontsize\n\n\t\tself.graphics.set_pen_rgb(self.config.label_color)\n\t\tif label:\n\t\t\tself.draw_diffuse_nebula_label(x, y, label, labelpos, d, label_fh)\n\t\tif label_ext:\n\t\t\tself.draw_diffuse_nebula_label(x, y, label_ext, self.to_ext_labelpos(labelpos), d, label_fh)\n\n\t\tself.graphics.restore()\n\n\tdef draw_diffuse_nebula_label(self, x, y, label, labelpos, d, fh):\n\t\tif labelpos == 0 or labelpos == -1:\n\t\t\tself.mirroring_graphics.text_centred(x, y-d-fh/2.0, label)\n\t\telif labelpos == 1:\n\t\t\tself.mirroring_graphics.text_centred(x, y+d+fh/2.0, label)\n\t\telif labelpos == 2:\n\t\t\tself.mirroring_graphics.text_left(x-d-fh/6.0, y-fh/3.0, label)\n\t\telif labelpos == 3:\n\t\t\tself.mirroring_graphics.text_right(x+d+fh/6.0, y-fh/3.0, label)\n\n\tdef diffuse_nebula_outlines(self, x, y, x_outl, y_outl, outl_lev, width, height, posangle, label, label_ext,\n\t\t\t\t\t\t\t\tdraw_label, labelpos=''):\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_linewidth(self.config.nebula_linewidth)\n\n\t\tif self.config.light_mode:\n\t\t\tfrac = 4 - 1.5 * outl_lev  # no logic, look nice in light mode\n\t\t\tpen_r = 1.0 - ((1.0 - self.config.nebula_color[0]) / frac)\n\t\t\tpen_g = 1.0 - ((1.0 - self.config.nebula_color[1]) / frac)\n\t\t\tpen_b = 1.0 - ((1.0 - self.config.nebula_color[2]) / frac)\n\t\telse:\n\t\t\tfrac = 4 - 1.5 * outl_lev  # no logic, look nice in dark mode\n\t\t\tpen_r = self.config.nebula_color[0] / frac\n\t\t\tpen_g = self.config.nebula_color[1] / frac\n\t\t\tpen_b = self.config.nebula_color[2] / frac\n\n\t\tself.graphics.set_pen_rgb((pen_r, pen_g, pen_b))\n\n\t\td = 0.5*width\n\t\tif width < 0.0:\n\t\t\td = self.drawingwidth/40.0\n\n\t\tfor i in range(len(x_outl)-1):\n\t\t\tself.mirroring_graphics.line(x_outl[i].item(), y_outl[i].item(), x_outl[i+1].item(), y_outl[i+1].item())\n\t\tself.mirroring_graphics.line(x_outl[len(x_outl)-1].item(), y_outl[len(x_outl)-1].item(), x_outl[0].item(), y_outl[0].item())\n\n\t\tif draw_label:\n\t\t\tif label_ext:\n\t\t\t\tlabel_fh = self.config.ext_label_font_fac * self.graphics.gi_fontsize\n\t\t\telse:\n\t\t\t\tlabel_fh = self.graphics.gi_fontsize * self.config.outlined_dso_label_font_fac\n\t\t\tself.graphics.set_font(self.graphics.gi_font, label_fh)\n\t\t\tself.graphics.set_pen_rgb(self.config.label_color)\n\t\t\tif label:\n\t\t\t\tself.draw_diffuse_nebula_label(x, y, label, labelpos, d, label_fh)\n\t\t\tif label_ext:\n\t\t\t\tself.draw_diffuse_nebula_label(x, y, label_ext, self.to_ext_labelpos(labelpos), d, label_fh)\n\n\t\tself.graphics.restore()\n\n\tdef unknown_diffuse_nebula_outlines(self, x_outl, y_outl, outl_lev):\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_linewidth(self.config.nebula_linewidth)\n\n\t\tif self.config.light_mode:\n\t\t\tfrac = 4 - 1.5 * outl_lev # no logic, look nice in light mode\n\t\t\tpen_r = 1.0 - ((1.0 - self.config.nebula_color[0]) / frac)\n\t\t\tpen_g = 1.0 - ((1.0 - self.config.nebula_color[1]) / frac)\n\t\t\tpen_b = 1.0 - ((1.0 - self.config.nebula_color[2]) / frac)\n\t\telse:\n\t\t\tfrac = 4 - 1.5 * outl_lev # no logic, look nice in dark mode\n\t\t\tpen_r = self.config.nebula_color[0] / frac\n\t\t\tpen_g = self.config.nebula_color[1] / frac\n\t\t\tpen_b = self.config.nebula_color[2] / frac\n\n\t\tself.graphics.set_pen_rgb((pen_r, pen_g, pen_b))\n\n\t\tfor i in range(len(x_outl)-1):\n\t\t\tself.mirroring_graphics.line(x_outl[i].item(), y_outl[i].item(), x_outl[i+1].item(), y_outl[i+1].item())\n\t\tself.mirroring_graphics.line(x_outl[len(x_outl)-1].item(), y_outl[len(x_outl)-1].item(), x_outl[0].item(), y_outl[0].item())\n\n\t\tself.graphics.restore()\n\n\tdef diffuse_nebula_labelpos(self, x, y, width=-1.0, height=-1.0, posangle=0.0, label_length=0.0):\n\t\td = 0.5*width\n\t\tif width < 0.0:\n\t\t\td = self.drawingwidth/40.0\n\t\tfh = self.graphics.gi_fontsize\n\n\t\tlabel_pos_list = []\n\t\txs = x - label_length/2.0\n\t\tys = y-d-fh/2.0\n\t\tlabel_pos_list.append([[xs, ys], [xs+label_length/2.0, ys], [xs+label_length, ys]])\n\n\t\tys = y+d+fh/2.0\n\t\tlabel_pos_list.append([[xs, ys], [xs+label_length/2.0, ys], [xs+label_length, ys]])\n\n\t\txs = x - d - fh/6.0 - label_length\n\t\tys = y\n\t\tlabel_pos_list.append([[xs, ys], [xs+label_length/2.0, ys], [xs+label_length, ys]])\n\n\t\txs = x + d + fh/6.0\n\t\tys = y\n\t\tlabel_pos_list.append([[xs, ys], [xs+label_length/2.0, ys], [xs+label_length, ys]])\n\t\treturn label_pos_list\n\n\tdef planetary_nebula(self, x, y, radius, label, label_ext, labelpos):\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/60.0\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_linewidth(self.config.dso_linewidth)\n\t\tself.graphics.set_pen_rgb(self.config.nebula_color)\n\n\t\tself.mirroring_graphics.circle(x, y, 0.75*r)\n\t\tself.mirroring_graphics.line(x-0.75*r, y, x-1.5*r, y)\n\t\tself.mirroring_graphics.line(x+0.75*r, y, x+1.5*r, y)\n\t\tself.mirroring_graphics.line(x, y+0.75*r, x, y+1.5*r)\n\t\tself.mirroring_graphics.line(x, y-0.75*r, x, y-1.5*r)\n\n\t\tif label_ext:\n\t\t\tlabel_fh = self.config.ext_label_font_fac * self.graphics.gi_fontsize\n\t\t\tself.graphics.set_font(self.graphics.gi_font, label_fh)\n\t\telse:\n\t\t\tlabel_fh = None\n\n\t\tself.draw_circular_object_label(x, y, r, label, labelpos, label_fh)\n\n\t\tif label_ext:\n\t\t\tself.draw_circular_object_label(x, y, r, label_ext, self.to_ext_labelpos(labelpos), label_fh)\n\n\t\tself.graphics.restore()\n\n\tdef supernova_remnant(self, x, y, radius, label, label_ext, labelpos):\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/40.0\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_linewidth(self.config.dso_linewidth)\n\t\tself.graphics.set_pen_rgb(self.config.nebula_color)\n\n\t\tself.mirroring_graphics.circle(x, y, r-self.graphics.gi_linewidth/2.0)\n\n\t\tif label_ext:\n\t\t\tlabel_fh = self.config.ext_label_font_fac * self.graphics.gi_fontsize\n\t\t\tself.graphics.set_font(self.graphics.gi_font, label_fh)\n\t\telse:\n\t\t\tlabel_fh = None\n\n\t\tself.draw_circular_object_label(x, y, r, label, labelpos, label_fh)\n\t\tif label_ext:\n\t\t\tself.draw_circular_object_label(x, y, r, label_ext, self.to_ext_labelpos(labelpos), label_fh)\n\n\t\tself.graphics.restore()\n\n\tdef unknown_object(self, x, y, radius, label, label_ext, labelpos):\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/40.0\n\n\t\tr /= 2**0.5\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_linewidth(self.config.dso_linewidth)\n\t\tself.graphics.set_pen_rgb(self.config.dso_color)\n\n\t\tself.mirroring_graphics.line(x-r, y+r, x+r, y-r)\n\t\tself.mirroring_graphics.line(x+r, y+r, x-r, y-r)\n\n\t\tfh = self.graphics.gi_fontsize\n\n\t\tif label != '':\n\t\t\tself.graphics.set_pen_rgb(self.config.label_color)\n\t\t\tif labelpos == 0:\n\t\t\t\tself.mirroring_graphics.text_right(x+r+fh/6.0, y-fh/3.0, label)\n\t\t\telif labelpos ==1:\n\t\t\t\tself.mirroring_graphics.text_left(x-r-fh/6.0, y-fh/3.0, label)\n\t\t\telif labelpos == 2:\n\t\t\t\tself.mirroring_graphics.text_centred(x, y + r + fh/2.0, label)\n\t\t\telse:\n\t\t\t\tself.mirroring_graphics.text_centred(x, y - r - fh/2.0, label)\n\t\tself.graphics.restore()\n\n\tdef unknown_object_labelpos(self, x, y, radius=-1, label_length=0.0):\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/40.0\n\t\tfh = self.graphics.gi_fontsize\n\t\tr /= 2**0.5\n\t\tlabel_pos_list = []\n\t\txs = x + r + fh/6.0\n\t\tys = y\n\t\tlabel_pos_list.append([[xs, ys], [xs+label_length/2.0, ys], [xs+label_length, ys]])\n\n\t\txs = x - r - fh/6.0 - label_length\n\t\tys = y\n\t\tlabel_pos_list.append([[xs, ys], [xs+label_length/2.0, ys], [xs+label_length, ys]])\n\n\t\txs = x - label_length/2.0\n\t\tys = y + r + fh/2.0\n\t\tlabel_pos_list.append([[xs, ys], [xs+label_length/2.0, ys], [xs+label_length, ys]])\n\n\t\txs = x - label_length/2.0\n\t\tys = y - r - fh/2.0\n\t\tlabel_pos_list.append([[xs, ys], [xs+label_length/2.0, ys], [xs+label_length, ys]])\n\t\treturn label_pos_list\n\n\tdef align_rect_coords(self, x1, y1, x2, y2):\n\t\tif x1 > x2:\n\t\t\tx1, x2 = x2, x1\n\t\tif y1 > y2:\n\t\t\ty1, y2 = y2, y1\n\t\treturn x1, y1, x2, y2\n\n", "description": "\n\t\tWidth is width of the map including the legend in mm.\n\t\t", "category": "graphics", "imports": ["import string", "import numpy as np", "import math", "from time import time", "from .label_potential import *", "from .astrocalc import *", "from .np_astrocalc import *", "from .constellation import *", "from .mirroring_graphics import *", "from .configuration import *", "from . import deepsky_object as deepsky", "from .graphics_interface import DrawMode", "from .widget_mag_scale import WidgetMagnitudeScale", "from .widget_map_scale import WidgetMapScale", "from .widget_orientation import WidgetOrientation", "from .widget_coords import WidgetCoords", "from .widget_dso_legend import WidgetDsoLegend", "from .widget_telrad import WidgetTelrad", "from .widget_eyepiece import WidgetEyepiece", "from .widget_picker import WidgetPicker", "\tfrom . import graphics_cairo", "\tfrom . import composite_star_catalog as sc"]}], [{"term": "def", "name": "fgettext", "data": "\tdef gettext(text):\n", "description": null, "category": "graphics", "imports": ["import os, sys, string", "\tfrom intl import gettext, dgettext, bindtextdomain", "\timport intl, locale", "import gtkutils", "import _sketch", "from _sketch import Point, Polar, PointType", "from _sketch import Rect, PointsToRect, UnionRects, IntersectRects, \\", "from _sketch import Trafo, Scale, Translation, Rotation, SingularMatrix, \\", "from _sketch import CreatePath, RectanglePath, RoundedRectanglePath, \\", "from _sketch import ContAngle, ContSmooth, ContSymmetrical, \\", "import config", "from skexceptions import *", "from undo import Undo, UndoList, CreateListUndo, CreateMultiUndo, UndoAfter, \\", "from connector import Connect, Disconnect, Issue, RemovePublisher, Subscribe, \\", "def _import_PIL():", "\t# First, try to import PIL as a package", "\t\timport PIL", "\t\timport PIL.Image", "\t\t\timport Image, ImageChops", "\t\t\twarn.warn(warn.USER, \"Can't import the Python Imaging Library\")", "\t\timport plugins", "\t\timport PIL", "_import_PIL()", "# from Graphics.base import GraphicsObject, Primitive", "from Graphics.arrow import StandardArrows, Arrow", "from Graphics.properties import Style, FillStyle, EmptyFillStyle, \\", "from Graphics.blend import MismatchError, Blend, BlendTrafo", "from Graphics.blendgroup import BlendGroup, CreateBlendGroup, \\", "from Graphics.color import CreateRGBColor, XRGBColor, CreateCMYKColor, \\", "from Graphics.compound import Compound, EditableCompound", "from Graphics.dashes import StandardDashes", "from Graphics.document import EditDocument, SelectionMode, EditMode", "from Graphics.font import GetFont", "from Graphics.gradient import MultiGradient, CreateSimpleGradient", "from Graphics.graphics import SimpleGC, GraphicsDevice, InvertingDevice, \\", "from Graphics.group import Group", "from Graphics.guide import GuideLine", "from Graphics.image import Image, load_image, ImageData", "from Graphics.layer import Layer, GuideLayer, GridLayer", "from Graphics.maskgroup import MaskGroup", "from Graphics.pattern import EmptyPattern, SolidPattern, HatchingPattern, \\", "from Graphics.plugobj import PluginCompound, TrafoPlugin", "from Graphics.rectangle import Rectangle, RectangleCreator", "from Graphics.ellipse import Ellipse, EllipseCreator", "from Graphics.bezier import PolyBezier, PolyBezierCreator, PolyLineCreator, \\", "from Graphics.psdevice import PostScriptDevice", "from Graphics.text import SimpleText, SimpleTextCreator, PathText", "\timport plugins", "\t\timport paxtkinter", "\t# import the standard scripts", "\t\t__import__(name)", "\timport pax", "\timport UI.skpixmaps, Graphics.graphics", "\timport UI.tkext, Graphics.color"]}, {"term": "def", "name": "fdgettext", "data": "\tdef dgettext(domain, text):\n", "description": null, "category": "graphics", "imports": ["import os, sys, string", "\tfrom intl import gettext, dgettext, bindtextdomain", "\timport intl, locale", "import gtkutils", "import _sketch", "from _sketch import Point, Polar, PointType", "from _sketch import Rect, PointsToRect, UnionRects, IntersectRects, \\", "from _sketch import Trafo, Scale, Translation, Rotation, SingularMatrix, \\", "from _sketch import CreatePath, RectanglePath, RoundedRectanglePath, \\", "from _sketch import ContAngle, ContSmooth, ContSymmetrical, \\", "import config", "from skexceptions import *", "from undo import Undo, UndoList, CreateListUndo, CreateMultiUndo, UndoAfter, \\", "from connector import Connect, Disconnect, Issue, RemovePublisher, Subscribe, \\", "def _import_PIL():", "\t# First, try to import PIL as a package", "\t\timport PIL", "\t\timport PIL.Image", "\t\t\timport Image, ImageChops", "\t\t\twarn.warn(warn.USER, \"Can't import the Python Imaging Library\")", "\t\timport plugins", "\t\timport PIL", "_import_PIL()", "# from Graphics.base import GraphicsObject, Primitive", "from Graphics.arrow import StandardArrows, Arrow", "from Graphics.properties import Style, FillStyle, EmptyFillStyle, \\", "from Graphics.blend import MismatchError, Blend, BlendTrafo", "from Graphics.blendgroup import BlendGroup, CreateBlendGroup, \\", "from Graphics.color import CreateRGBColor, XRGBColor, CreateCMYKColor, \\", "from Graphics.compound import Compound, EditableCompound", "from Graphics.dashes import StandardDashes", "from Graphics.document import EditDocument, SelectionMode, EditMode", "from Graphics.font import GetFont", "from Graphics.gradient import MultiGradient, CreateSimpleGradient", "from Graphics.graphics import SimpleGC, GraphicsDevice, InvertingDevice, \\", "from Graphics.group import Group", "from Graphics.guide import GuideLine", "from Graphics.image import Image, load_image, ImageData", "from Graphics.layer import Layer, GuideLayer, GridLayer", "from Graphics.maskgroup import MaskGroup", "from Graphics.pattern import EmptyPattern, SolidPattern, HatchingPattern, \\", "from Graphics.plugobj import PluginCompound, TrafoPlugin", "from Graphics.rectangle import Rectangle, RectangleCreator", "from Graphics.ellipse import Ellipse, EllipseCreator", "from Graphics.bezier import PolyBezier, PolyBezierCreator, PolyLineCreator, \\", "from Graphics.psdevice import PostScriptDevice", "from Graphics.text import SimpleText, SimpleTextCreator, PathText", "\timport plugins", "\t\timport paxtkinter", "\t# import the standard scripts", "\t\t__import__(name)", "\timport pax", "\timport UI.skpixmaps, Graphics.graphics", "\timport UI.tkext, Graphics.color"]}, {"term": "def", "name": "fbindtextdomain", "data": "\tdef bindtextdomain(*args):\n", "description": null, "category": "graphics", "imports": ["import os, sys, string", "\tfrom intl import gettext, dgettext, bindtextdomain", "\timport intl, locale", "import gtkutils", "import _sketch", "from _sketch import Point, Polar, PointType", "from _sketch import Rect, PointsToRect, UnionRects, IntersectRects, \\", "from _sketch import Trafo, Scale, Translation, Rotation, SingularMatrix, \\", "from _sketch import CreatePath, RectanglePath, RoundedRectanglePath, \\", "from _sketch import ContAngle, ContSmooth, ContSymmetrical, \\", "import config", "from skexceptions import *", "from undo import Undo, UndoList, CreateListUndo, CreateMultiUndo, UndoAfter, \\", "from connector import Connect, Disconnect, Issue, RemovePublisher, Subscribe, \\", "def _import_PIL():", "\t# First, try to import PIL as a package", "\t\timport PIL", "\t\timport PIL.Image", "\t\t\timport Image, ImageChops", "\t\t\twarn.warn(warn.USER, \"Can't import the Python Imaging Library\")", "\t\timport plugins", "\t\timport PIL", "_import_PIL()", "# from Graphics.base import GraphicsObject, Primitive", "from Graphics.arrow import StandardArrows, Arrow", "from Graphics.properties import Style, FillStyle, EmptyFillStyle, \\", "from Graphics.blend import MismatchError, Blend, BlendTrafo", "from Graphics.blendgroup import BlendGroup, CreateBlendGroup, \\", "from Graphics.color import CreateRGBColor, XRGBColor, CreateCMYKColor, \\", "from Graphics.compound import Compound, EditableCompound", "from Graphics.dashes import StandardDashes", "from Graphics.document import EditDocument, SelectionMode, EditMode", "from Graphics.font import GetFont", "from Graphics.gradient import MultiGradient, CreateSimpleGradient", "from Graphics.graphics import SimpleGC, GraphicsDevice, InvertingDevice, \\", "from Graphics.group import Group", "from Graphics.guide import GuideLine", "from Graphics.image import Image, load_image, ImageData", "from Graphics.layer import Layer, GuideLayer, GridLayer", "from Graphics.maskgroup import MaskGroup", "from Graphics.pattern import EmptyPattern, SolidPattern, HatchingPattern, \\", "from Graphics.plugobj import PluginCompound, TrafoPlugin", "from Graphics.rectangle import Rectangle, RectangleCreator", "from Graphics.ellipse import Ellipse, EllipseCreator", "from Graphics.bezier import PolyBezier, PolyBezierCreator, PolyLineCreator, \\", "from Graphics.psdevice import PostScriptDevice", "from Graphics.text import SimpleText, SimpleTextCreator, PathText", "\timport plugins", "\t\timport paxtkinter", "\t# import the standard scripts", "\t\t__import__(name)", "\timport pax", "\timport UI.skpixmaps, Graphics.graphics", "\timport UI.tkext, Graphics.color"]}, {"term": "def", "name": "_import_PIL", "data": "def _import_PIL():\n\t# Import PIL and work around some bugs...\n\t# First, try to import PIL as a package\n\ttry:\n\t\timport PIL\n\t\timport PIL.Image\n\t\t# Work around a bug in PIL 1.0 when used as a package\n\t\tif PIL.__path__[0] not in sys.path:\n\t\t\tsys.path.append(PIL.__path__[0])\n\texcept ImportError:\n\t\t# Must be an older PIL.\n\t\ttry:\n\t\t\timport Image, ImageChops\n\t\texcept:\n\t\t\twarn.warn(warn.USER, \"Can't import the Python Imaging Library\")\n\t\t\tsys.exit(1)\n\t\timport plugins\n\t\tplugins.create_packages('PIL')\n\t\timport PIL\n\t\tPIL.__path__.append(os.path.split(Image.__file__)[0])\n\t\tPIL.Image = Image\n\t\tPIL.ImageChops = ImageChops\n\t\tsys.modules['PIL.Image'] = Image\n\t\tsys.modules['PIL.ImageChops'] = ImageChops\n", "description": null, "category": "graphics", "imports": ["import os, sys, string", "\tfrom intl import gettext, dgettext, bindtextdomain", "\timport intl, locale", "import gtkutils", "import _sketch", "from _sketch import Point, Polar, PointType", "from _sketch import Rect, PointsToRect, UnionRects, IntersectRects, \\", "from _sketch import Trafo, Scale, Translation, Rotation, SingularMatrix, \\", "from _sketch import CreatePath, RectanglePath, RoundedRectanglePath, \\", "from _sketch import ContAngle, ContSmooth, ContSymmetrical, \\", "import config", "from skexceptions import *", "from undo import Undo, UndoList, CreateListUndo, CreateMultiUndo, UndoAfter, \\", "from connector import Connect, Disconnect, Issue, RemovePublisher, Subscribe, \\", "def _import_PIL():", "\t# First, try to import PIL as a package", "\t\timport PIL", "\t\timport PIL.Image", "\t\t\timport Image, ImageChops", "\t\t\twarn.warn(warn.USER, \"Can't import the Python Imaging Library\")", "\t\timport plugins", "\t\timport PIL", "_import_PIL()", "# from Graphics.base import GraphicsObject, Primitive", "from Graphics.arrow import StandardArrows, Arrow", "from Graphics.properties import Style, FillStyle, EmptyFillStyle, \\", "from Graphics.blend import MismatchError, Blend, BlendTrafo", "from Graphics.blendgroup import BlendGroup, CreateBlendGroup, \\", "from Graphics.color import CreateRGBColor, XRGBColor, CreateCMYKColor, \\", "from Graphics.compound import Compound, EditableCompound", "from Graphics.dashes import StandardDashes", "from Graphics.document import EditDocument, SelectionMode, EditMode", "from Graphics.font import GetFont", "from Graphics.gradient import MultiGradient, CreateSimpleGradient", "from Graphics.graphics import SimpleGC, GraphicsDevice, InvertingDevice, \\", "from Graphics.group import Group", "from Graphics.guide import GuideLine", "from Graphics.image import Image, load_image, ImageData", "from Graphics.layer import Layer, GuideLayer, GridLayer", "from Graphics.maskgroup import MaskGroup", "from Graphics.pattern import EmptyPattern, SolidPattern, HatchingPattern, \\", "from Graphics.plugobj import PluginCompound, TrafoPlugin", "from Graphics.rectangle import Rectangle, RectangleCreator", "from Graphics.ellipse import Ellipse, EllipseCreator", "from Graphics.bezier import PolyBezier, PolyBezierCreator, PolyLineCreator, \\", "from Graphics.psdevice import PostScriptDevice", "from Graphics.text import SimpleText, SimpleTextCreator, PathText", "\timport plugins", "\t\timport paxtkinter", "\t# import the standard scripts", "\t\t__import__(name)", "\timport pax", "\timport UI.skpixmaps, Graphics.graphics", "\timport UI.tkext, Graphics.color"]}, {"term": "def", "name": "RegisterCommands", "data": "def RegisterCommands(aclass):\n\tfor cmd in aclass.commands:\n\t\tcmd.SetClass(aclass)\n\tcommand_classes.append(aclass)\n\n", "description": null, "category": "graphics", "imports": ["import os, sys, string", "\tfrom intl import gettext, dgettext, bindtextdomain", "\timport intl, locale", "import gtkutils", "import _sketch", "from _sketch import Point, Polar, PointType", "from _sketch import Rect, PointsToRect, UnionRects, IntersectRects, \\", "from _sketch import Trafo, Scale, Translation, Rotation, SingularMatrix, \\", "from _sketch import CreatePath, RectanglePath, RoundedRectanglePath, \\", "from _sketch import ContAngle, ContSmooth, ContSymmetrical, \\", "import config", "from skexceptions import *", "from undo import Undo, UndoList, CreateListUndo, CreateMultiUndo, UndoAfter, \\", "from connector import Connect, Disconnect, Issue, RemovePublisher, Subscribe, \\", "def _import_PIL():", "\t# First, try to import PIL as a package", "\t\timport PIL", "\t\timport PIL.Image", "\t\t\timport Image, ImageChops", "\t\t\twarn.warn(warn.USER, \"Can't import the Python Imaging Library\")", "\t\timport plugins", "\t\timport PIL", "_import_PIL()", "# from Graphics.base import GraphicsObject, Primitive", "from Graphics.arrow import StandardArrows, Arrow", "from Graphics.properties import Style, FillStyle, EmptyFillStyle, \\", "from Graphics.blend import MismatchError, Blend, BlendTrafo", "from Graphics.blendgroup import BlendGroup, CreateBlendGroup, \\", "from Graphics.color import CreateRGBColor, XRGBColor, CreateCMYKColor, \\", "from Graphics.compound import Compound, EditableCompound", "from Graphics.dashes import StandardDashes", "from Graphics.document import EditDocument, SelectionMode, EditMode", "from Graphics.font import GetFont", "from Graphics.gradient import MultiGradient, CreateSimpleGradient", "from Graphics.graphics import SimpleGC, GraphicsDevice, InvertingDevice, \\", "from Graphics.group import Group", "from Graphics.guide import GuideLine", "from Graphics.image import Image, load_image, ImageData", "from Graphics.layer import Layer, GuideLayer, GridLayer", "from Graphics.maskgroup import MaskGroup", "from Graphics.pattern import EmptyPattern, SolidPattern, HatchingPattern, \\", "from Graphics.plugobj import PluginCompound, TrafoPlugin", "from Graphics.rectangle import Rectangle, RectangleCreator", "from Graphics.ellipse import Ellipse, EllipseCreator", "from Graphics.bezier import PolyBezier, PolyBezierCreator, PolyLineCreator, \\", "from Graphics.psdevice import PostScriptDevice", "from Graphics.text import SimpleText, SimpleTextCreator, PathText", "\timport plugins", "\t\timport paxtkinter", "\t# import the standard scripts", "\t\t__import__(name)", "\timport pax", "\timport UI.skpixmaps, Graphics.graphics", "\timport UI.tkext, Graphics.color"]}, {"term": "def", "name": "init_lib", "data": "def init_lib():\n\timport plugins\n\tconfig.load_user_preferences()\n\tIssue(None, const.INITIALIZE)\n", "description": null, "category": "graphics", "imports": ["import os, sys, string", "\tfrom intl import gettext, dgettext, bindtextdomain", "\timport intl, locale", "import gtkutils", "import _sketch", "from _sketch import Point, Polar, PointType", "from _sketch import Rect, PointsToRect, UnionRects, IntersectRects, \\", "from _sketch import Trafo, Scale, Translation, Rotation, SingularMatrix, \\", "from _sketch import CreatePath, RectanglePath, RoundedRectanglePath, \\", "from _sketch import ContAngle, ContSmooth, ContSymmetrical, \\", "import config", "from skexceptions import *", "from undo import Undo, UndoList, CreateListUndo, CreateMultiUndo, UndoAfter, \\", "from connector import Connect, Disconnect, Issue, RemovePublisher, Subscribe, \\", "def _import_PIL():", "\t# First, try to import PIL as a package", "\t\timport PIL", "\t\timport PIL.Image", "\t\t\timport Image, ImageChops", "\t\t\twarn.warn(warn.USER, \"Can't import the Python Imaging Library\")", "\t\timport plugins", "\t\timport PIL", "_import_PIL()", "# from Graphics.base import GraphicsObject, Primitive", "from Graphics.arrow import StandardArrows, Arrow", "from Graphics.properties import Style, FillStyle, EmptyFillStyle, \\", "from Graphics.blend import MismatchError, Blend, BlendTrafo", "from Graphics.blendgroup import BlendGroup, CreateBlendGroup, \\", "from Graphics.color import CreateRGBColor, XRGBColor, CreateCMYKColor, \\", "from Graphics.compound import Compound, EditableCompound", "from Graphics.dashes import StandardDashes", "from Graphics.document import EditDocument, SelectionMode, EditMode", "from Graphics.font import GetFont", "from Graphics.gradient import MultiGradient, CreateSimpleGradient", "from Graphics.graphics import SimpleGC, GraphicsDevice, InvertingDevice, \\", "from Graphics.group import Group", "from Graphics.guide import GuideLine", "from Graphics.image import Image, load_image, ImageData", "from Graphics.layer import Layer, GuideLayer, GridLayer", "from Graphics.maskgroup import MaskGroup", "from Graphics.pattern import EmptyPattern, SolidPattern, HatchingPattern, \\", "from Graphics.plugobj import PluginCompound, TrafoPlugin", "from Graphics.rectangle import Rectangle, RectangleCreator", "from Graphics.ellipse import Ellipse, EllipseCreator", "from Graphics.bezier import PolyBezier, PolyBezierCreator, PolyLineCreator, \\", "from Graphics.psdevice import PostScriptDevice", "from Graphics.text import SimpleText, SimpleTextCreator, PathText", "\timport plugins", "\t\timport paxtkinter", "\t# import the standard scripts", "\t\t__import__(name)", "\timport pax", "\timport UI.skpixmaps, Graphics.graphics", "\timport UI.tkext, Graphics.color"]}, {"term": "def", "name": "init_ui", "data": "def init_ui():\n\t# workaround for a threaded _tkinter in Python 1.5.2\n\tif sys.version[:5] >= '1.5.2':\n\t\timport paxtkinter\n\t\tsys.modules['_tkinter'] = paxtkinter\n\n\tinit_lib()\n\n\t# import the standard scripts\n\tfor name in config.preferences.standard_scripts:\n\t\t__import__(name)\n", "description": null, "category": "graphics", "imports": ["import os, sys, string", "\tfrom intl import gettext, dgettext, bindtextdomain", "\timport intl, locale", "import gtkutils", "import _sketch", "from _sketch import Point, Polar, PointType", "from _sketch import Rect, PointsToRect, UnionRects, IntersectRects, \\", "from _sketch import Trafo, Scale, Translation, Rotation, SingularMatrix, \\", "from _sketch import CreatePath, RectanglePath, RoundedRectanglePath, \\", "from _sketch import ContAngle, ContSmooth, ContSymmetrical, \\", "import config", "from skexceptions import *", "from undo import Undo, UndoList, CreateListUndo, CreateMultiUndo, UndoAfter, \\", "from connector import Connect, Disconnect, Issue, RemovePublisher, Subscribe, \\", "def _import_PIL():", "\t# First, try to import PIL as a package", "\t\timport PIL", "\t\timport PIL.Image", "\t\t\timport Image, ImageChops", "\t\t\twarn.warn(warn.USER, \"Can't import the Python Imaging Library\")", "\t\timport plugins", "\t\timport PIL", "_import_PIL()", "# from Graphics.base import GraphicsObject, Primitive", "from Graphics.arrow import StandardArrows, Arrow", "from Graphics.properties import Style, FillStyle, EmptyFillStyle, \\", "from Graphics.blend import MismatchError, Blend, BlendTrafo", "from Graphics.blendgroup import BlendGroup, CreateBlendGroup, \\", "from Graphics.color import CreateRGBColor, XRGBColor, CreateCMYKColor, \\", "from Graphics.compound import Compound, EditableCompound", "from Graphics.dashes import StandardDashes", "from Graphics.document import EditDocument, SelectionMode, EditMode", "from Graphics.font import GetFont", "from Graphics.gradient import MultiGradient, CreateSimpleGradient", "from Graphics.graphics import SimpleGC, GraphicsDevice, InvertingDevice, \\", "from Graphics.group import Group", "from Graphics.guide import GuideLine", "from Graphics.image import Image, load_image, ImageData", "from Graphics.layer import Layer, GuideLayer, GridLayer", "from Graphics.maskgroup import MaskGroup", "from Graphics.pattern import EmptyPattern, SolidPattern, HatchingPattern, \\", "from Graphics.plugobj import PluginCompound, TrafoPlugin", "from Graphics.rectangle import Rectangle, RectangleCreator", "from Graphics.ellipse import Ellipse, EllipseCreator", "from Graphics.bezier import PolyBezier, PolyBezierCreator, PolyLineCreator, \\", "from Graphics.psdevice import PostScriptDevice", "from Graphics.text import SimpleText, SimpleTextCreator, PathText", "\timport plugins", "\t\timport paxtkinter", "\t# import the standard scripts", "\t\t__import__(name)", "\timport pax", "\timport UI.skpixmaps, Graphics.graphics", "\timport UI.tkext, Graphics.color"]}, {"term": "def", "name": "init_modules_from_widget", "data": "def init_modules_from_widget(root):\n\timport pax\n\timport UI.skpixmaps, Graphics.graphics\n\timport UI.tkext, Graphics.color\n\tUI.tkext.InitFromTkapp(root.tk)\n\tif hasattr(root.tk, 'interpaddr'):\n\t\ttkwin = pax.name_to_window('.', root.tk.interpaddr())\n\telse:\n\t\ttkwin = pax.name_to_window('.', root.tk)\n\tGraphics.color.InitFromWidget(tkwin, root)\n\tGraphics.graphics.InitFromWidget(tkwin)\n\tUI.skpixmaps.InitFromWidget(tkwin)\n", "description": null, "category": "graphics", "imports": ["import os, sys, string", "\tfrom intl import gettext, dgettext, bindtextdomain", "\timport intl, locale", "import gtkutils", "import _sketch", "from _sketch import Point, Polar, PointType", "from _sketch import Rect, PointsToRect, UnionRects, IntersectRects, \\", "from _sketch import Trafo, Scale, Translation, Rotation, SingularMatrix, \\", "from _sketch import CreatePath, RectanglePath, RoundedRectanglePath, \\", "from _sketch import ContAngle, ContSmooth, ContSymmetrical, \\", "import config", "from skexceptions import *", "from undo import Undo, UndoList, CreateListUndo, CreateMultiUndo, UndoAfter, \\", "from connector import Connect, Disconnect, Issue, RemovePublisher, Subscribe, \\", "def _import_PIL():", "\t# First, try to import PIL as a package", "\t\timport PIL", "\t\timport PIL.Image", "\t\t\timport Image, ImageChops", "\t\t\twarn.warn(warn.USER, \"Can't import the Python Imaging Library\")", "\t\timport plugins", "\t\timport PIL", "_import_PIL()", "# from Graphics.base import GraphicsObject, Primitive", "from Graphics.arrow import StandardArrows, Arrow", "from Graphics.properties import Style, FillStyle, EmptyFillStyle, \\", "from Graphics.blend import MismatchError, Blend, BlendTrafo", "from Graphics.blendgroup import BlendGroup, CreateBlendGroup, \\", "from Graphics.color import CreateRGBColor, XRGBColor, CreateCMYKColor, \\", "from Graphics.compound import Compound, EditableCompound", "from Graphics.dashes import StandardDashes", "from Graphics.document import EditDocument, SelectionMode, EditMode", "from Graphics.font import GetFont", "from Graphics.gradient import MultiGradient, CreateSimpleGradient", "from Graphics.graphics import SimpleGC, GraphicsDevice, InvertingDevice, \\", "from Graphics.group import Group", "from Graphics.guide import GuideLine", "from Graphics.image import Image, load_image, ImageData", "from Graphics.layer import Layer, GuideLayer, GridLayer", "from Graphics.maskgroup import MaskGroup", "from Graphics.pattern import EmptyPattern, SolidPattern, HatchingPattern, \\", "from Graphics.plugobj import PluginCompound, TrafoPlugin", "from Graphics.rectangle import Rectangle, RectangleCreator", "from Graphics.ellipse import Ellipse, EllipseCreator", "from Graphics.bezier import PolyBezier, PolyBezierCreator, PolyLineCreator, \\", "from Graphics.psdevice import PostScriptDevice", "from Graphics.text import SimpleText, SimpleTextCreator, PathText", "\timport plugins", "\t\timport paxtkinter", "\t# import the standard scripts", "\t\t__import__(name)", "\timport pax", "\timport UI.skpixmaps, Graphics.graphics", "\timport UI.tkext, Graphics.color"]}], [], [{"term": "class", "name": "classUtils:\r", "data": "class Utils:\r\n\r\n\tdef print_df_types(df):\r\n\t\tprint(df.dtypes)\r\n\t\tprint('-' * 20 + 'exemplo tipo' + '-' * 20)\r\n\t\tprint(df.iloc[0])\r\n\t\tprint(df.shape)\r\n\r\n\tdef str_attributes_to_int(df):\r\n\t\tdf =df.str.replace('$', '')\r\n\t\tdf = df.str.replace(',', '')\r\n\t\tdf = df.astype(np.float32, copy=False)\r\n\t\treturn df\r\n\r\n\tdef labelencoder__attributes_to_int(df,column_name):\r\n\t\tlabelencoder = LabelEncoder()\r\n\t\tdf[column_name] = labelencoder.fit_transform(df[column_name])\r\n\t\treturn df\r\n\r\n\tdef limit(column_name):\r\n\t\tq1 = column_name.quantile(0.25)\r\n\t\tq3 = column_name.quantile(0.75)\r\n\t\tamplitude = q3 - q1\r\n\t\treturn q1 - 1.5 * amplitude, q3 + 1.5 * amplitude\r\n\r\n\tdef remove_outliers(df, column_name):\r\n\t\tnum_lines = df.shape[0]\r\n\t\tlim_inf, lim_sup = Utils.limit(df[column_name])\r\n\t\tdf = df.loc[(df[column_name] >= lim_inf) & (df[column_name] <= lim_sup), :]\r\n\t\treturn df, num_lines - df.shape[0]\r\n\r\n\tdef split_data(df, n_split):\r\n\t\tdf = resample(df, n_samples = n_split, random_state = 42)\r\n\t\treturn df\r\n\r\n\tdef selection(df, target_column):\r\n\t\ttarget = df[target_column].copy()\r\n\t\treturn target, df\r\n\r\n\tdef preparation(df, target_column):\r\n\t\tattributes = df.copy()\r\n\t\tattributes = attributes.drop(target_column,axis = 1 ,inplace = False)\r\n\t\ttarget = df[target_column].copy()\r\n\t\tattributes, target = SMOTE().fit_resample(attributes, target)\r\n\t\tattributes, target = shuffle(attributes, target)\r\n\t\tattributes = pd.DataFrame(attributes)\r\n\t\ttarget = pd.DataFrame(target)\r\n\r\n\t\tprint(attributes.info())\r\n\r\n\t\tattributes.shape, target.shape\r\n\r\n\t\treturn target.values, attributes.values\r\n\r\n\tdef analysis_continuous_attributes(df, column_name):\r\n\t\tgraphics.Graphics_utils.box_diagram(df[column_name])\r\n\t\tgraphics.Graphics_utils.histogram(df[column_name])\r\n\t\tdf, removed_lines = Utils.remove_outliers(df,column_name)\r\n\t\tprint('{} linhas removidas'.format(removed_lines))\r\n\t\tgraphics.Graphics_utils.histogram(df[column_name])\r\n\t\treturn df\r\n\r\n\tdef analysis_discrete_attributes(df, column_name):\r\n\t\tgraphics.Graphics_utils.box_diagram(df[column_name])\r\n\t\tgraphics.Graphics_utils.barr_graph(df[column_name])\r\n\t\tdf, removed_lines = Utils.remove_outliers(df, column_name)\r\n\t\tprint('{} linhas removidas'.format(removed_lines))\r\n\t\tgraphics.Graphics_utils.box_diagram(df[column_name])\r\n\t\tgraphics.Graphics_utils.barr_graph(df[column_name])\r\n\t\treturn df\r\n\r\n\tdef analysis_text_attributes(df, column_name, num):\r\n\t\tprint(df[column_name].value_counts())\r\n\t\tgraphics.Graphics_utils.text_attribute_graph(df, column_name)\r\n\t\ttable_property_types = df[column_name].value_counts()\r\n\t\tgroup_columns = []\r\n\t\tfor table_type in table_property_types.index:\r\n\t\t  if table_property_types[table_type] < num:\r\n\t\t\tgroup_columns.append(table_type)\r\n\t\tfor table_type in group_columns:\r\n\t\t  df.loc[df[column_name] == table_type,column_name] = 'Others'\r\n\t\tgraphics.Graphics_utils.text_attribute_graph(df, column_name)\r\n\t\treturn df\r\n\r\n\tdef create_new_attribute(col):\r\n\t\tnew_cat = []\r\n\t\tfor line in col:\r\n\t\t\tif line <= max((col) * 0.25):\r\n\t\t\t\tvalue = 0\r\n\t\t\telif line <= max((col) * 0.5):\r\n\t\t\t\tvalue = 1\r\n\t\t\telif line <= max((col) * 0.75):\r\n\t\t\t\tvalue = 2\r\n\t\t\telse:\r\n\t\t\t\tvalue = 3\r\n\t\t\tnew_cat.extend([value])\r\n", "description": null, "category": "graphics", "imports": ["import numpy as np\r", "import pandas as pd\r", "import graphics\r", "from sklearn.utils import shuffle\r", "from imblearn.over_sampling import SMOTE\r", "from sklearn import preprocessing\r", "from sklearn.preprocessing import OneHotEncoder\r", "from sklearn.preprocessing import LabelEncoder\r", "from sklearn.utils import resample\r"]}], [{"term": "def", "name": "main", "data": "def main():\n\targument_spec = ucs_argument_spec\n\targument_spec.update(\n\t\torg_dn=dict(type='str', default='org-root'),\n\t\tname=dict(required=True, type='str'),\n\t\tdescr=dict(type='str'),\n\t\tdescription=dict(type='str', aliases=['descr']),\n\t\tgraphics_card_mode=dict(type='str', choices=[\n\t\t\t'any-configuration',\n\t\t\t'compute',\n\t\t\t'graphics'\n\t\t]),\n\t\tstate=dict(\n\t\t\ttype='str', default='present',\n\t\t\tchoices=['present', 'absent']\n\t\t),\n\t)\n\n\tmodule = AnsibleModule(\n\t\targument_spec,\n\t\tsupports_check_mode=True,\n\t\trequired_if=[\n\t\t\t['state', 'present', ['name']],\n\t\t],\n\t)\n\n\t# UCSModule verifies ucsmsdk is present and exits on failure.\n\t# Imports are below for UCS object creation.\n\tucs = UCSModule(module)\n\tfrom importlib import import_module\n\tfrom ucsmsdk.ucscoreutils import get_meta_info\n\n\t# The Class(es) this module is managing\n\tmodule_file = 'ucsmsdk.mometa.compute.ComputeGraphicsCardPolicy'\n\tmodule_class = 'ComputeGraphicsCardPolicy'\n\tmo_module = import_module(module_file)\n\tmo_class = getattr(mo_module, module_class)\n\n\tMETA = get_meta_info(class_id=module_class)\n\n\terr = False\n\tchanged = False\n\trequested_state = module.params['state']\n\n\tkwargs = dict()\n\n\t# Manage Aliased Attributes\n\tfor attribute in ['descr:description']:\n\t\tattribute_alias = attribute.split(':')\n\t\tif module.params[attribute_alias[1]] is not None:\n\t\t\tkwargs[attribute_alias[0]] = module.params[attribute_alias[1]]\n\n\t# Manage Attributes\n\tfor attribute in [\n\t\t\t'graphics_card_mode', 'descr']:\n\t\tif module.params[attribute] is not None:\n\t\t\tkwargs[attribute] = module.params[attribute]\n\n\ttry:\n\t\tdn = (\n\t\t\tmodule.params['org_dn'] + '/' +\n\t\t\tMETA.rn[0:META.rn.rindex('-') + 1] +\n\t\t\tmodule.params['name']\n\t\t)\n\t\tmo = ucs.login_handle.query_dn(dn)\n\n\t\t# Determine state change\n\t\tif mo:\n\t\t\t# Object exists, if it should exist has anything changed?\n\t\t\tif requested_state == 'present':\n\t\t\t\t# Do some or all Object properties not match, that is a change\n\n\t\t\t\tif not mo.check_prop_match(**kwargs):\n\t\t\t\t\tchanged = True\n\n\t\t# Object does not exist but should, that is a change\n\t\telse:\n\t\t\tif requested_state == 'present':\n\t\t\t\tchanged = True\n\n\t\t# Object exists but should not, that is a change\n\t\tif mo and requested_state == 'absent':\n\t\t\tchanged = True\n\n\t\t# Apply state if not check_mode\n\t\tif changed and not module.check_mode:\n\t\t\tif requested_state == 'absent':\n\t\t\t\tucs.login_handle.remove_mo(mo)\n\t\t\telse:\n\t\t\t\tkwargs['parent_mo_or_dn'] = module.params['org_dn']\n\t\t\t\tkwargs['name'] = module.params['name']\n\n\t\t\t\tmo = mo_class(**kwargs)\n\t\t\t\tucs.login_handle.add_mo(mo, modify_present=True)\n\t\t\tucs.login_handle.commit()\n\n\texcept Exception as e:\n\t\terr = True\n\t\tucs.result['msg'] = \"setup error: %s \" % str(e)\n\n\tucs.result['changed'] = changed\n\tif err:\n\t\tmodule.fail_json(**ucs.result)\n\n\tmodule.exit_json(**ucs.result)\n\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import, division, print_function", "from ansible.module_utils.basic import AnsibleModule", "from ansible_collections.cisco.ucs.plugins.module_utils.ucs import (", "\tfrom importlib import import_module", "\tfrom ucsmsdk.ucscoreutils import get_meta_info", "\tmo_module = import_module(module_file)"]}], [{"term": "class", "name": "classgraphics_data:\r", "data": "class graphics_data:\r\n\tresolution_x = 1280\r\n\tresolution_y = 800\r\n\tfactor_x = int(resolution_x/320)\r\n\tfactor_y = int(resolution_y/200)\r\n\ttile_w = 16*factor_x\r\n\ttile_h = 16*factor_y\r\n\tscroll_x = 0.0\r\n\tscroll_y = 0.0\r\n\ttilemap_width = 1\r\n\ttilemap_height = 1\r\n\ttilemap = [0]\r\n\tsprite_x = [0 for i in range(256)]\r\n\tsprite_y = [0 for i in range(256)]\r\n\tsprite_c = [0 for i in range(256)]\r\n\tsprite_s = [0 for i in range(256)]\r\n\tsprites = 0\r\n\ti = 0\r\n\r\n\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "init_video", "data": "def init_video():\r\n\tgraphics = graphics_data()\r\n\tpygame.init()\r\n\tgraphics.screen = pygame.display.set_mode((graphics.resolution_x,graphics.resolution_y), pygame.FULLSCREEN|pygame.HWSURFACE|pygame.DOUBLEBUF, 32)\r\n\tgraphics.tileset = pygame.Surface((256*graphics.factor_x, 256*graphics.factor_y), pygame.HWSURFACE, 32)\r\n\tgraphics.tileset.fill((255, 0, 255))\r\n\tgraphics.spriteset = pygame.Surface((256*graphics.factor_x, 512*graphics.factor_y), pygame.HWSURFACE, 32)\r\n\tgraphics.spriteset.fill((255, 0, 255))\r\n\tgraphics.spriteset.set_colorkey((255, 0, 255, 255))\r\n\tf = data.load(\"tileset.png\")\r\n\tload_tileset(f, graphics)\r\n\r\n\t\r\n\treturn graphics\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "load_tileset", "data": "def load_tileset(file, graphics):\r\n\timg = pygame.image.load(file)\r\n\tbuff = pygame.Surface((256*graphics.factor_x, 256*graphics.factor_y), pygame.HWSURFACE, 32)\r\n\timg.convert(32, pygame.HWSURFACE)\r\n\ti = 0\r\n\twhile i < 256*graphics.factor_x:\r\n\t\tbuff.blit(img, (i, 0), (i/graphics.factor_x, 0, 1, 256))\r\n\t\ti += 1\r\n\ti = 0\r\n\twhile i < 256*graphics.factor_y:\r\n\t\tgraphics.tileset.blit(buff, (0, i), (0, i/graphics.factor_y, 256*graphics.factor_x, 1))\r\n\t\ti += 1\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "load_spriteset", "data": "def load_spriteset(file, graphics):\r\n\timg = pygame.image.load(file)\r\n\tbuff = pygame.Surface((256*graphics.factor_x, 512*graphics.factor_y), pygame.HWSURFACE, 32)\r\n\timg.convert(32, pygame.HWSURFACE)\r\n\ti = 0\r\n\twhile i < 256*graphics.factor_x:\r\n\t\tbuff.blit(img, (i, 256), (i/graphics.factor_x, 0, 1, 256))\r\n\t\tbuff.blit(img, (i, 0), (15 - ((i/graphics.factor_x)%16) + (i/graphics.factor_x/16)*16, 0, 1, 256))\r\n\t\ti += 1\r\n\ti = 0\r\n\twhile i < 256*graphics.factor_y:\r\n\t\tgraphics.spriteset.blit(buff, (0, i), (0, i/graphics.factor_y, 256*graphics.factor_x, 1))\r\n\t\tgraphics.spriteset.blit(buff, (0, i+256*graphics.factor_y), (0, i/graphics.factor_y + 256, 256*graphics.factor_x, 1))\r\n\t\ti += 1\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "draw_sprite", "data": "def draw_sprite(c, x, y, graphics):\r\n\tif graphics.sprites < 256:\r\n\t\tgraphics.sprite_x[graphics.sprites] = x\r\n\t\tgraphics.sprite_y[graphics.sprites] = y\r\n\t\tgraphics.sprite_c[graphics.sprites] = c\r\n\t\tgraphics.sprite_s[graphics.sprites] = 1\r\n\t\tgraphics.sprites += 1\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "draw_sprite_multi", "data": "def draw_sprite_multi(c, x, y, w, h, graphics):\r\n\ti3 = 0\r\n\ti2 = 0\r\n\twhile i2 < h:\r\n\t\ti = 0\r\n\t\twhile i < w:\r\n\t\t\tif graphics.sprites < 256:\r\n\t\t\t\tgraphics.sprite_x[graphics.sprites] = x + i*16\r\n\t\t\t\tgraphics.sprite_y[graphics.sprites] = y + i2*16\r\n\t\t\t\tgraphics.sprite_c[graphics.sprites] = c + i3\r\n\t\t\t\tgraphics.sprite_s[graphics.sprites] = 1\r\n\t\t\t\tgraphics.sprites += 1\r\n\t\t\ti3 += 1\r\n\t\t\ti += 1\r\n\t\ti2 += 1\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "draw_sprite_static", "data": "def draw_sprite_static(c, x, y, graphics):\r\n\tif graphics.sprites < 256:\r\n\t\tgraphics.sprite_x[graphics.sprites] = x\r\n\t\tgraphics.sprite_y[graphics.sprites] = y\r\n\t\tgraphics.sprite_c[graphics.sprites] = c\r\n\t\tgraphics.sprite_s[graphics.sprites] = 0\r\n\t\tgraphics.sprites += 1\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "draw_sprite_static_multi", "data": "def draw_sprite_static_multi(c, x, y, w, h, graphics):\r\n\ti3 = 0\r\n\ti2 = 0\r\n\twhile i2 < h:\r\n\t\ti = 0\r\n\t\twhile i < w:\r\n\t\t\tif graphics.sprites < 256:\r\n\t\t\t\tgraphics.sprite_x[graphics.sprites] = x + i*16\r\n\t\t\t\tgraphics.sprite_y[graphics.sprites] = y + i2*16\r\n\t\t\t\tgraphics.sprite_c[graphics.sprites] = c + i3\r\n\t\t\t\tgraphics.sprite_s[graphics.sprites] = 0\r\n\t\t\t\tgraphics.sprites += 1\r\n\t\t\ti3 += 1\r\n\t\t\ti += 1\r\n\t\ti2 += 1\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "free_video", "data": "def free_video():\r\n\tpygame.display.quit()\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}, {"term": "def", "name": "draw_screen", "data": "def draw_screen(graphics):\r\n\tx = 0\r\n\ttile_x = int(graphics.scroll_x/16)\r\n\twhile x < 21:\r\n\t\ty = 0\r\n\t\ttile_y = int(graphics.scroll_y/16)\r\n\t\twhile y < 14:\r\n\t\t\tif tile_x < graphics.tilemap_width \\\r\n\t\t\t  and tile_y < graphics.tilemap_height \\\r\n\t\t\t  and tile_x >= 0 \\\r\n\t\t\t  and tile_y >= 0:\r\n\t\t\t\ttile = graphics.tilemap[tile_y * graphics.tilemap_width + tile_x]\r\n\t\t\t\tgraphics.screen.blit(graphics.tileset, (x*graphics.tile_w - (graphics.scroll_x % 16)*graphics.factor_x, y*graphics.tile_h - (graphics.scroll_y % 16)*graphics.factor_y), ((tile%16)*graphics.tile_w, (tile/16)*graphics.tile_h, graphics.tile_w, graphics.tile_h))\r\n\t\t\ty += 1\r\n\t\t\ttile_y += 1\r\n\t\tx += 1\r\n\t\ttile_x += 1\r\n\ti=0\r\n\twhile i < graphics.sprites:\r\n\t\tgraphics.screen.blit(graphics.spriteset, ((graphics.sprite_x[i] - graphics.scroll_x*graphics.sprite_s[i])*graphics.factor_x, (graphics.sprite_y[i] - graphics.scroll_y*graphics.sprite_s[i])*graphics.factor_y), ((graphics.sprite_c[i]%16)*graphics.tile_w, (graphics.sprite_c[i]/16)*graphics.tile_h, graphics.tile_w, graphics.tile_h))\r\n\t\ti += 1\r\n\tgraphics.sprites = 0\r\n\t\r\n\tpygame.display.flip()\r\n\t\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import pygame\r"]}], [{"term": "class", "name": "WebPageGraphicsGenerator", "data": "class WebPageGraphicsGenerator( WebPageArtifactsGeneratorInterface ):\n\t\t\t\n\tdef __init__( self, timeOfRequest, outputLanguage ):\n\t\t\"\"\"\t\t\n\t\t\n\t\t\t@param timeOfRequest : Time at which the graphics are requested.\n\t\t\n\t\t\t@param outputLanguage : Language in which to output the graphics.\n\t\t\n\t\t\"\"\"\n\t\t\n\t\tself.timeOfRequest  = timeOfRequest\n\t\tself.outputLanguage = outputLanguage\n\t\t\n\t\tself.paths = StatsPaths()\n\t\tself.paths.setPaths()\n\t\t\t\t\n\tdef __generateAllGraphicsForGroups( self, graphicType ):\n\t\t\"\"\"\n\t\t\t\n\t\t\t@summary : Generated groups graphics based on the \n\t\t\t\t\t   specified graphicType.\n\t\t\t\n\t\t\t@summary graphicType : \"daily\", \"weekly\", \"monthly\", \"yearly\"\n\t\t\t\n\t\t\t@raise Exception: When graphicType is unknown.\n\t\t\t\t\t   \n\t\t\"\"\"\n\t\t\n\t\tconfigParameters = StatsConfigParameters( )\n\t\tconfigParameters.getAllParameters()\t   \n\t\t\t\n\t\tsupportedGraphicTypes = { \"daily\": \"-d\", \"weekly\":\"-w\", \"monthly\":\"-m\", \"yearly\":\"-y\" }\n\t\t\n\t\tif graphicType not in supportedGraphicTypes:\n\t\t\traise Exception( \"Unsupported graphicType detected in __generateAllGraphicsForGroups\" )\n\t\t\n\t\telse: \n\t\t\t\n\t\t\tfor group in configParameters.groupParameters.groups:\n\t\t\t\t\n\t\t\t\tgroupMembers, groupMachines, groupProducts, groupFileTypes = configParameters.groupParameters.getAssociatedParametersInStringFormat( group )\n\t\t\t\t\n\t\t\t\tgroupMachines = str(groupMachines).replace( \"[\", \"\" ).replace( \"]\", \"\" ).replace( \"'\", \"\" ).replace( '\"','' )\n\t\t\t\t \n\t\t\t\tif graphicType == \"daily\":\n\t\t\t\t\tcommands.getstatusoutput( '%sgenerateGnuGraphics.py -g %s -c %s --combineClients --copy -d \"%s\"  -m %s -f %s -p %s  -s 24 --outputLanguage %s' %( self.paths.STATSBIN, group, groupMembers, self.timeOfRequest, groupMachines, groupFileTypes, groupProducts, self.outputLanguage ) )\n\t\t\t\t\t#print  '%sgenerateGnuGraphics.py -g %s -c %s --combineClients --fixedCurrent --copy -d \"%s\"  -m %s -f %s -p %s  -s 24 --language %s' %( self.paths.STATSBIN, group, groupMembers, self.timeOfRequest, groupMachines, groupFileTypes, groupProducts, self.outputLanguage )\n\t\t\t\t\n\t\t\t\telse:\t\n\t\t\t\t\tcommands.getoutput(\"%sgenerateRRDGraphics.py %s --copy -f %s --machines '%s'  -c %s --date '%s' --fixedCurrent --language %s\" %( self.paths.STATSBIN, supportedGraphicTypes[ graphicType], groupFileTypes, groupMachines, group, self.timeOfRequest, self.outputLanguage ) )\n\t\t\t\t\tprint \"%sgenerateRRDGraphics.py %s --copy -f %s --machines '%s'  -c %s --date '%s' --fixedCurrent --language %s\" %( self.paths.STATSBIN, supportedGraphicTypes[ graphicType], groupFileTypes, groupMachines, group, self.timeOfRequest, self.outputLanguage )\t\n\t\t \n\t\t \n\tdef __generateAllRRDGraphicsForWebPage( self, graphicType, generateTotalsGraphics = True  ):\n\t\t\"\"\"\n\t\n\t\t\t@summary : This method generates new rrd graphics \n\t\t\t\t\t   based on the specified  graphics\n\t\t\t\n\t\t\t@param graphicType : daily weekly monthly or yearly\n\t\t\t\n\t\t\t@raise Exception : When graphicType is unknown.\n\t\t\t\n\t\t\"\"\"\n\t\t\n\t\tsupportedGraphicTypes = { \"daily\": \"-d\", \"weekly\":\"-w\", \"monthly\":\"-m\", \"yearly\":\"-y\" }\n\t\t\n\t\tif graphicType not in supportedGraphicTypes:\n\t\t\traise Exception( \"Unsupported graphicType detected in __generateAllGraphicsForGroups\" )\n\t\t\n\t\t\n\t\tconfigParameters = StatsConfigParameters( )\n\t\tconfigParameters.getAllParameters()\t\t\n\t\t\n\t\tmachineConfig = MachineConfigParameters()\n\t\tmachineConfig.getParametersFromMachineConfigurationFile()\n\t\tmachinePairs  = machineConfig.getListOfPairsAssociatedWithListOfTags(configParameters.sourceMachinesTags)  \n\t   \n\t\t\n\t\t\n\t\tfor machinePair in machinePairs:\n\t\t\tmachinePair = str(machinePair).replace( \"[\", \"\" ).replace( \"]\", \"\" ).replace( \" \", \"\" ).replace( \"'\", \"\" ).replace( '\"','' )\n\t\t\t#individual graphics \n\t\t\tcommands.getstatusoutput( \"%sgenerateRRDGraphics.py %s --copy -f tx --machines '%s' --havingRun --date '%s' --fixedCurrent --language %s\"\\\n\t\t\t\t\t\t\t\t\t   %(  self.paths.STATSBIN, supportedGraphicTypes[graphicType], machinePair, self.timeOfRequest, self.outputLanguage ) )\n\t\t\t\n\t\t\t# print \"%sgenerateRRDGraphics.py %s --copy -f tx --machines '%s' --havingRun --date '%s' --fixedCurrent --language %s\"\\\n\t\t\t\t\t\t\t\t\t   # %( self.paths.STATSBIN, supportedGraphicTypes[graphicType], machinePair, self.timeOfRequest, self.outputLanguage )\n\t\t\t\t\t\t\t\t\t  \n\t\t\tcommands.getstatusoutput( \"%sgenerateRRDGraphics.py %s --copy -f rx --machines '%s' --havingRun --date '%s' --fixedCurrent --language %s\"\\\n\t\t\t\t\t\t\t\t\t   %( self.paths.STATSBIN, supportedGraphicTypes[graphicType], machinePair, self.timeOfRequest, self.outputLanguage ) )\n\t\t\t\n\t\t\t# print  \"%sgenerateRRDGraphics.py %s --copy -f rx --machines '%s' --havingRun --date '%s' --fixedCurrent --language %s\"\\\n\t\t\t\t\t\t\t\t\t   # %( self.paths.STATSBIN, supportedGraphicTypes[graphicType], machinePair, self.timeOfRequest, self.outputLanguage )\n\t\t\t\n\t\t\tif generateTotalsGraphics == True :\n\t\t\t\t#print output\n\t\t\t\tcommands.getstatusoutput( '%sgenerateRRDGraphics.py %s --copy --totals -f \"rx\" --machines \"%s\" --havingRun  --fixedCurrent --date \"%s\" --language %s'\\\n\t\t\t\t\t\t\t\t\t\t   %( self.paths.STATSBIN, supportedGraphicTypes[graphicType], machinePair, self.timeOfRequest, self.outputLanguage ) )\n\t\t\t\t# print '%sgenerateRRDGraphics.py %s --copy --totals -f \"rx\" --machines \"%s\" --havingRun  --fixedCurrent --date \"%s\" --language %s'\\\n\t\t\t\t\t\t\t\t\t\t   # %( self.paths.STATSBIN, supportedGraphicTypes[graphicType], machinePair, self.timeOfRequest, self.outputLanguage )\n\t\t\t\t\t\t\t\t\t\t  \n\t\t\t\t\n\t\t\t\tcommands.getstatusoutput( '%sgenerateRRDGraphics.py %s --copy --totals -f \"tx\" --machines \"%s\" --havingRun  --fixedCurrent --date \"%s\" --language %s'\\\n\t\t\t\t\t\t\t\t\t\t   %( self.paths.STATSBIN, supportedGraphicTypes[graphicType], machinePair, self.timeOfRequest, self.outputLanguage ) )\n\t\t\t\t\n\t\t\t\t# print '%sgenerateRRDGraphics.py %s --copy --totals -f \"tx\" --machines \"%s\" --havingRun  --fixedCurrent --date \"%s\" --language %s'\\\n\t\t\t\t\t\t\t\t\t\t   # %( self.paths.STATSBIN, supportedGraphicTypes[graphicType], machinePair, self.timeOfRequest, self.outputLanguage )\n\t\t\n\t\t\n\t\t\n\tdef __generateAllMissingYearlyGraphicsSinceLasteUpdate( self, generateTotalsGraphics ):\n\t\t\"\"\"\n\t\t\t@summary : Generates the monthly graphics that were not \n\t\t\t\t\t   generated between last update and timeOfRequest\n\t\t\t\t\t   \n\t\t\t@param generateTotalsGraphics: Whether or not to generate the totals graphics.\n\t\t\t\n\t\t\"\"\"\n\t\t\n\t\tconfigParameters = StatsConfigParameters( )\n\t\tconfigParameters.getAllParameters()\t\n\t\tupdateManager = AutomaticUpdatesManager( configParameters.nbAutoUpdatesLogsToKeep, \"pxStatsStartup\" )\n\t\t\n\t\tmissingYears = updateManager.getMissingYearsBetweenUpdates( updateManager.getTimeOfLastUpdateInLogs(), self.timeOfRequest )\n\t\t\n\t\toldTimeOfRequest = self.timeOfRequest\n\t\t\n\t\tfor missingYear in missingYears:\n\t\t\tself.timeOfRequest = missingYear\n\t\t\tself.__generateAllRRDGraphicsForWebPage( \"yearly\", generateTotalsGraphics )\n\t\t\tself.__generateAllGraphicsForGroups( \"yearly\" )\n\t\t\t\n\t\tself.timeOfRequest = oldTimeOfRequest \n\t\t\n\t\t\n\t\t\t\n\tdef __generateAllMissingMonthlyGraphicsSinceLasteUpdate( self, generateTotalsGraphics ):\n\t\t\"\"\"\n\t\t\t@summary : Generates the monthly graphics that were not \n\t\t\t\t\t   generated between last update and timeOfRequest\n\t\t\t\t\t   \n\t\t\t@param generateTotalsGraphics: Whether or not to generate the totals graphics.  \n\t\t\"\"\"\n\t\t\n\t\tconfigParameters = StatsConfigParameters( )\n\t\tconfigParameters.getAllParameters()\t\n\t\tupdateManager = AutomaticUpdatesManager( configParameters.nbAutoUpdatesLogsToKeep, \"pxStatsStartup\" )\n\t\t\n\t\tmissingMonths = updateManager.getMissingMonthsBetweenUpdates( updateManager.getTimeOfLastUpdateInLogs(), self.timeOfRequest )\n\t\t\n\t\toldTimeOfRequest = self.timeOfRequest\n\t\t\n\t\tfor missingMonth in missingMonths:\n\t\t\tself.timeOfRequest = missingMonth\n\t\t\tself.__generateAllRRDGraphicsForWebPage( \"monthly\", generateTotalsGraphics )\n\t\t\tself.__generateAllGraphicsForGroups( \"monthly\" )\n\t\t\t\n\t\tself.timeOfRequest = oldTimeOfRequest\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\tdef __generateAllMissingWeeklyGraphicsSinceLasteUpdate( self, generateTotalsGraphics ):\n\t\t\"\"\"\n\t\t\t@summary : Generates the weekly graphics that were not \n\t\t\t\t\t   generated between last update and timeOfRequest\n\t\t\t\t\t   \n\t\t\t@param generateTotalsGraphics: Whether or not to generate the totals graphics.   \n\t\t\t\n\t\t\"\"\"\n\t\t\n\t\tconfigParameters = StatsConfigParameters( )\n\t\tconfigParameters.getAllParameters()\t\n\t\tupdateManager = AutomaticUpdatesManager( configParameters.nbAutoUpdatesLogsToKeep, \"pxStatsStartup\" )\n\t\t\n\t\tmissingWeeks = updateManager.getMissingWeeksBetweenUpdates( updateManager.getTimeOfLastUpdateInLogs(), self.timeOfRequest )\t\t\n\t\toldTimeOfRequest = self.timeOfRequest\n\t\t\n\t\tfor missingWeek in missingWeeks:\n\t\t\tself.timeOfRequest = missingWeek\n\t\t\tself.__generateAllRRDGraphicsForWebPage( \"weekly\", generateTotalsGraphics )\n\t\t\tself.__generateAllGraphicsForGroups( \"weekly\" )\n\t\t\n\t\tself.timeOfRequest = oldTimeOfRequest\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\tdef __generateAllMissingDailyGraphicsSinceLasteUpdate( self, generateTotalsGraphics ):\n\t\t\"\"\"\n\t\t\t@summary : generates the daily graphics that were not generated between \n\t\t\t\t\t   last update and timeOfRequest.\n\t\t\t\t\t   \n\t\t\t@param generateTotalsGraphics: Whether or not to generate the totals graphics.\t\t\t\n\t\t\"\"\"\n\t\t\n\t\tconfigParameters = StatsConfigParameters( )\n\t\tconfigParameters.getAllParameters()\t\n\t\tupdateManager = AutomaticUpdatesManager( configParameters.nbAutoUpdatesLogsToKeep, \"pxStatsStartup\" )\n\t\t\n\t\tmissingDays = updateManager.getMissingDaysBetweenUpdates( updateManager.getTimeOfLastUpdateInLogs(), self.timeOfRequest )\n\t\tmissingDays.append(self.timeOfRequest)\n\t\toldTimeOfRequest = self.timeOfRequest\n\t\t\n\t\tfor missingDay in missingDays[1:]:\n\t\t\tself.timeOfRequest = StatsDateLib.getIsoTodaysMidnight( missingDay )\n\t\t\tself.__generateAllForDailyWebPage( False, generateTotalsGraphics )\n\t\t\tself.__generateAllGraphicsForGroups( \"daily\" )\n\t\t\t\n\t\tself.timeOfRequest = oldTimeOfRequest\t\t\t\n\t  \n\t\t\t  \n\t\t\t\n\tdef __generateAllForDailyWebPage( self,  copyToColumbosFolder = True,\n\t\t\t\t\t\t\t\t\t  generateTotalsGraphics = True  ):\n\t\t\"\"\"\n\t\t\t@summary : Gets all the required daily graphs.\n\t\t\n\t\t\t@param getGraphicsMissingSinceLastUpdate : Whether or not to generate \n\t\t\t\t\t\t\t\t\t\t\t\t\t   the daily graphics that did \n\t\t\t\t\t\t\t\t\t\t\t\t\t   not get generated since the \n\t\t\t\t\t\t\t\t\t\t\t\t\t   last update.\n \n\t\t\t@param generateTotalsGraphics : Whether or not to generate the graphics \n\t\t\t\t\t\t\t\t\t\t\tdisplaying the totals for each clusters. \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t@todo : Add proper support for copyToColumbosFolder\n\t\t\t\t\twhen generateAllGraphics finally support \n\t\t\n\t\t\"\"\"\t\t  \n\t\t\n\t\tconfigParameters = StatsConfigParameters( )\n\t\tconfigParameters.getAllParameters()\t\t\n\t\t\n\t\tmachineConfig = MachineConfigParameters()\n\t\tmachineConfig.getParametersFromMachineConfigurationFile()\n\t\tmachinePairs  = machineConfig.getPairedMachinesAssociatedWithListOfTags(configParameters.sourceMachinesTags)\t \n\t\t\n\t\t\n\t\tfor machineTag in configParameters.sourceMachinesTags:\n\t\t\t\n\t\t\tlogins = []\n\t\t\t\n\t\t\tmachines = configParameters.detailedParameters.sourceMachinesForTag[machineTag]\n\t\t   \n\t\t\tfor machine in machines:\n\t\t\t\tlogins.append( machineConfig.getUserNameForMachine(machine) )\n\t\t\t   \n\t\t\tlogins   = str(logins).replace( \"[\", \"\" ).replace( \"]\", \"\" ).replace( \" \", \"\" )\n\t\t\tmachines = str(machines).replace( \"[\", \"\" ).replace( \"]\", \"\" ).replace( \" \", \"\" )\n\t\t\t\n\t\t\t\n\t\t\tif \",\" in machines :\n\t\t\t\t\n\t\t\t\toutput = commands.getoutput( \"%sgenerateAllGnuGraphicsForMachines.py -m '%s' -c  -l '%s' --date '%s' --outputLanguage %s \"\\\n\t\t\t\t\t\t\t\t\t%( self.paths.STATSBIN, machines.replace( \"'\",\"\" ), logins.replace( \"'\",\"\" ), self.timeOfRequest, self.outputLanguage) ) \n\t\t\t\t#print \"%sgenerateAllGnuGraphicsForMachines.py -m '%s' -c  -l '%s' --date '%s' --outputLanguage %s \"\\\n\t\t\t\t\t\t\t\t\t#%( self.paths.STATSBIN, machines.replace( \"'\",\"\" ), logins.replace( \"'\",\"\" ), self.timeOfRequest, self.outputLanguage ) \n\t\t\t\t#print output\t\t\t\t\t\n\t\t\telse:\n\t\t\t\toutput =  commands.getoutput( \"%sgenerateAllGnuGraphicsForMachines.py -i -m '%s' -l '%s'  --date '%s' --outputLanguage %s \"\n\t\t\t\t\t\t\t\t\t %( self.paths.STATSBIN, machines.replace( \"'\",\"\" ), logins.replace( \"'\",\"\" ), self.timeOfRequest, self.outputLanguage ) )\t\n\t\t\t\t#print \"%sgenerateAllGnuGraphicsForMachines.py -i -m '%s' -l '%s'  --date '%s' --outputLanguage %s \" %( self.paths.STATSBIN, machines.replace( \"'\",\"\" ), logins.replace( \"'\",\"\" ), self.timeOfRequest, self.outputLanguage )\n\t\t\t\t#print output\n\n\n\t\tif generateTotalsGraphics == True :\n\t\t\t\n\t\t\tfor machinePair in machinePairs:\n\t\t\n\t\t\t\t#Generate all the daily total graphs.\n\t\t\t\tcommands.getoutput( '%sgenerateRRDGraphics.py --copy --totals -f \"rx\" --machines \"%s\" -d --fixedCurrent --date \"%s\" --language %s'\\\n\t\t\t\t\t\t\t\t\t%( self.paths.STATSBIN, machinePair, self.timeOfRequest, self.outputLanguage) )\n\t\t\t\t#print '%sgenerateRRDGraphics.py --copy --totals -f \"rx\" --machines \"%s\" -d --fixedCurrent --date \"%s\" --language %s'\\\n\t\t\t\t#\t\t %( self.paths.STATSBIN, machinePair, self.timeOfRequest, self.outputLanguage)\n\t\t\t\t\t\t\t\t\t\t \n\t\t\t\tcommands.getoutput( '%sgenerateRRDGraphics.py --copy --totals -f \"tx\" --machines \"%s\" -d --fixedCurrent --date \"%s\" --language %s'\\\n\t\t\t\t\t\t\t\t\t%( self.paths.STATSBIN, machinePair, self.timeOfRequest, self.outputLanguage ) )\n\t\t\t\t#print '%sgenerateRRDGraphics.py --copy --totals -f \"tx\" --machines \"%s\" -d --fixedCurrent --date \"%s\" --language %s'\\\n\t\t\t\t#\t\t\t\t\t %( self.paths.STATSBIN, machinePair, self.timeOfRequest, self.outputLanguage )\n\t\t  \n\t\t  \n\t\t  \n\tdef generateAllForYearlyWebPage( self, getGraphicsMissingSinceLastUpdate = False, generateTotalsGraphics = True ): \n\t\t\"\"\"  \n\t\t\t@summary : Gets all the required weekly graphics\n\t\t\t\n\t\t\t@param getGraphicsMissingSinceLastUpdate : Whether or not to generate \n\t\t\t\t\t\t\t\t\t\t   the weekly graphics that did \n\t\t\t\t\t\t\t\t\t\t   not get generated since the \n\t\t\t\t\t\t\t\t\t\t   last update.\n\t\t\t\n\t\t\t@param generateTotalsGraphics : Whether or not to generate the graphics \n\t\t\t\t\t\t\t\t\t\t\tdisplaying the totals for each clusters. \n\t\t\"\"\"\n\t\t\n\t\tif getGraphicsMissingSinceLastUpdate == True :\n\t\t\tself.__generateAllMissingYearlyGraphicsSinceLasteUpdate( generateTotalsGraphics )\n\t\t\n\t\tself.__generateAllRRDGraphicsForWebPage( \"yearly\", generateTotalsGraphics= generateTotalsGraphics )\n\t\t\n\t\tself.__generateAllGraphicsForGroups( \"yearly\" )   \n\n\n\t\n\tdef generateAllForMonthlyWebPage( self, getGraphicsMissingSinceLastUpdate = False, generateTotalsGraphics = True ): \n\t\t\"\"\"  \n\t\t\t@summary : Gets all the required weekly graphics\n\t\t\t\n\t\t\t@param getGraphicsMissingSinceLastUpdate : Whether or not to generate \n\t\t\t\t\t\t\t\t\t\t\t\t\t   the weekly graphics that did \n\t\t\t\t\t\t\t\t\t\t\t\t\t   not get generated since the \n\t\t\t\t\t\t\t\t\t\t\t\t\t   last update.\n\t\t\t\t\t\t\t\t\t\t\t\t\t   \n\t\t\t@param generateTotalsGraphics : Whether or not to generate the graphics \n\t\t\t\t\t\t\t\t\t\t\tdisplaying the totals for each clusters. \n\t\t\"\"\"\n\t\t\n\t\tif getGraphicsMissingSinceLastUpdate == True : \n\t\t\tself.__generateAllMissingMonthlyGraphicsSinceLasteUpdate( generateTotalsGraphics )\n\t\t\n\t\tself.__generateAllRRDGraphicsForWebPage( \"monthly\", generateTotalsGraphics = generateTotalsGraphics )\n\t\t\n\t\tself.__generateAllGraphicsForGroups( \"monthly\" )\t  \n\t\n\t\n\t\t   \n\tdef generateAllForWeeklyWebPage( self, getGraphicsMissingSinceLastUpdate = False, generateTotalsGraphics = True ): \n\t\t\"\"\"  \n\t\t\t@summary : Gets all the required weekly graphics\n\t\t\t\n\t\t\t@param getGraphicsMissingSinceLastUpdate : Whether or not to generate \n\t\t\t\t\t\t\t\t\t\t\t\t\t   the weekly graphics that did \n\t\t\t\t\t\t\t\t\t\t\t\t\t   not get generated since the \n\t\t\t\t\t\t\t\t\t\t\t\t\t   last update.\n\t\t\t\t\t\t\t\t\t\t\t\t\t   \n\t\t\t@param generateTotalsGraphics : Whether or not to generate the graphics \n\t\t\t\t\t\t\t\t\t\t\tdisplaying the totals for each clusters. \n\t\t\"\"\"\n\t\t\n\t\tif getGraphicsMissingSinceLastUpdate == True : \n\t\t\tself.__generateAllMissingWeeklyGraphicsSinceLasteUpdate( generateTotalsGraphics )\n\n\t\tself.__generateAllRRDGraphicsForWebPage( \"weekly\", generateTotalsGraphics = generateTotalsGraphics )\n\t\t\n\t\tself.__generateAllGraphicsForGroups( \"weekly\" )\n\t\t\n\t\t\n\t\t\n\tdef generateAllForDailyWebPage( self, getGraphicsMissingSinceLastUpdate = False, \n\t\t\t\t\t\t\t\t\tcopyToColumbosFolder = True, generateTotalsGraphics = True  ):\t   \n\t\t\"\"\"\t\n\t\t\t@summary : Gets all the required daily graphs.\n\t\t\n\t\t\t@param getGraphicsMissingSinceLastUpdate : Whether or not to generate \n\t\t\t\t\t\t\t\t\t\t\t\t\t   the daily graphics that did \n\t\t\t\t\t\t\t\t\t\t\t\t\t   not get generated since the \n\t\t\t\t\t\t\t\t\t\t\t\t\t   last update.\n\t\t\t\n\t\t\t@param generateTotalsGraphics : Whether or not to generate the graphics \n\t\t\t\t\t\t\t\t\t\t\tdisplaying the totals for each clusters. \n\t\t\t\n\t\t\t@todo : Add proper support for copyToColumbosFolder\n\t\t\t\t\twhen generateAllGraphics finally support\n\t\t\t\t\t\t\t\t \n\t\t\"\"\"\n\t\t\n\t\tif getGraphicsMissingSinceLastUpdate == True :\n\t\t\tself.__generateAllMissingDailyGraphicsSinceLasteUpdate( generateTotalsGraphics )\n\t\t\t\n\t\tself.__generateAllForDailyWebPage( copyToColumbosFolder, generateTotalsGraphics)\t\n\t\tself.__generateAllGraphicsForGroups( \"daily\" )\n\n\n\tdef generateColumbosGraphics( self ):\t\t\n\t\t\"\"\"\n\t\t\t@summary : generates the columbo required by columbo.\n\t\t\t\n\t\t\"\"\"\n\t\t\n\t\tself.generateAllGraphicsForDailyWebPage( False, True, False )\n\t   \n\t\t\n\t\t\n\tdef generateAllForEverySupportedWebPages( self, getGraphicsMissingSinceLastUpdate, generateTotalsGraphics ):\n\t\t\"\"\"\n\t\t\t@summary : Gets all the graphics required by \n\t\t\t\t\t   the web pages.\n\n\t\t\t@param getGraphicsMissingSinceLastUpdate : Whether or not to generate \n\t\t\t\t\t\t\t\t\t\t\t\t\t   the daily graphics that did \n\t\t\t\t\t\t\t\t\t\t\t\t\t   not get generated since the \n\t\t\t\t\t\t\t\t\t\t\t\t\t   last update.\n\t\t\t\t\t\t\t\t\t\t\t\t\t   \n\t\t\t@param generateTotalsGraphics : Whether or not to generate the graphics \n\t\t\t\t\t\t\t\t\t\t\tdisplaying the totals for each clusters.\t\t\t\t\t\t\t\t\t\t\t\t\t   \n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t@warning: will not respect update frequencies\n\t\t\t\t\t  found in config file.\n\t\t\t\n\t\t\t@Note : we suppose here that the web pages\n\t\t\t\t\twill require graphics from all the machines\n\t\t\t\t\tspecified in the configuration file.\n\t\t\t   \n\t\t\t\t\t\t\t \n\t\t\"\"\"\t\t\n\n\t\tself.generateAllForDailyWebPage(getGraphicsMissingSinceLastUpdate, False, generateTotalsGraphics)\t\n\n\t\tself.generateAllForWeeklyWebPage(getGraphicsMissingSinceLastUpdate, generateTotalsGraphics)\t\t\t\n\n\t\tself.generateAllForMonthlyWebPage(getGraphicsMissingSinceLastUpdate, generateTotalsGraphics)\n\t\n\t\tself.generateAllForYearlyWebPage(getGraphicsMissingSinceLastUpdate, generateTotalsGraphics)\n\t\t\n  \n  \n\tdef generateAllForEverySupportedWebPagesBasedOnFrequenciesFoundInConfig( self ):\n\t\t\"\"\"\n\t\t\t@summary : Gets all the graphics required by \n\t\t\t\t\t   the web pages based on the update \n\t\t\t\t\t   frequencies found within the config file.\n\t\t\t\n\t\t\t@note: Supposes that the web pages\n\t\t\t\t\twill require graphics from all the machines\n\t\t\t\t\tspecified in the configuration file.\n\t   \n\t\t\"\"\"\n\t\t\n\t\tconfigParameters = StatsConfigParameters( )\n\t\tconfigParameters.getAllParameters()\t   \n\t\t\n\t\t\t\t\t\t\t\n\t\tupdateManager = AutomaticUpdatesManager( configParameters.nbAutoUpdatesLogsToKeep, \"pxStatsStartup\" )\n\t\t\n\t\trequiresUpdateFonctions = { \"hourly\": updateManager.isFirstUpdateOfTheHour,  \"daily\": updateManager.isFirstUpdateOfTheDay, \"weekly\": updateManager.isFirstUpdateOfTheWeek,\\\n\t\t\t\t\t\t\t\t\t\"monthly\": updateManager.isFirstUpdateOfTheMonth, \"yearly\": updateManager.isFirstUpdateOfTheYear\n\t\t\t\t\t\t\t\t  }\n\t\t\n\t\t#-------------------- print \"time of the request : \", self.timeOfRequest\n\t\t# print \"daily frequency : \", configParameters.timeParameters.dailyWebPageFrequency\n\t\t\n\t\tif requiresUpdateFonctions[ configParameters.timeParameters.dailyWebPageFrequency ](self.timeOfRequest) ==   True :\n\t\t\tself.generateAllForDailyWebPage( True, True, True )\n\t\t\n\t\t# print \"weekly frequency : \", configParameters.timeParameters.weeklyWebPageFrequency\n\t\tif requiresUpdateFonctions[ configParameters.timeParameters.weeklyWebPageFrequency ](self.timeOfRequest) ==  True :\n\t\t\t#print \"weeklies need to be updated.\"\n\t\t\tself.generateAllForWeeklyWebPage(  True, True )\t\n\t\t\n\t\t# print \"montlhly frequency : \", configParameters.timeParameters.monthlyWebPageFrequency\n\t\tif requiresUpdateFonctions[ configParameters.timeParameters.monthlyWebPageFrequency ](self.timeOfRequest) == True :\n\t\t\tself.generateAllForMonthlyWebPage(  True, True )\n\t\t\n\t\t# print \"yearly frequency : \", configParameters.timeParameters.yearlyWebPageFrequency\n\t\tif requiresUpdateFonctions[ configParameters.timeParameters.yearlyWebPageFrequency ](self.timeOfRequest) ==  True :\n\t\t\tself.generateAllForYearlyWebPage(   True, True )\n\t\t\n\t\t\n\t\t\n\t  \n\n", "description": "\t\t\n\t\t\n\t\t\t@param timeOfRequest : Time at which the graphics are requested.\n\t\t\n\t\t\t@param outputLanguage : Language in which to output the graphics.\n\t\t\n\t\t", "category": "graphics", "imports": ["import os, sys, commands", "from pxStats.lib.StatsConfigParameters import StatsConfigParameters", "from pxStats.lib.MachineConfigParameters import MachineConfigParameters", "from pxStats.lib.StatsPaths import StatsPaths", "from pxStats.lib.StatsDateLib import StatsDateLib", "from pxStats.lib.AutomaticUpdatesManager import AutomaticUpdatesManager", "from pxStats.lib.WebPageArtifactsGeneratorInterface import WebPageArtifactsGeneratorInterface"]}], [{"term": "class", "name": "classAnimationPlayer:", "data": "class AnimationPlayer:\n\tdef __init__(self):\n\t\tself.frames = {\n\t\t\t# magic\n\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\n\t\t\t'aura': import_folder('../graphics/particles/aura'),\n\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\n\t\t\t\n\t\t\t# attacks \n\t\t\t'claw': import_folder('../graphics/particles/claw'),\n\t\t\t'slash': import_folder('../graphics/particles/slash'),\n\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\n\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\n\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\n\n\t\t\t# monster deaths\n\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\n\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\n\t\t\t'spirit': import_folder('../graphics/particles/nova'),\n\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\n\t\t\t\n\t\t\t# leafs \n\t\t\t'leaf': (\n\t\t\t\timport_folder('../graphics/particles/leaf1'),\n\t\t\t\timport_folder('../graphics/particles/leaf2'),\n\t\t\t\timport_folder('../graphics/particles/leaf3'),\n\t\t\t\timport_folder('../graphics/particles/leaf4'),\n\t\t\t\timport_folder('../graphics/particles/leaf5'),\n\t\t\t\timport_folder('../graphics/particles/leaf6'),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\n\t\t\t\t),\n\n\t\t\t# pictures\n\t\t\t'pic1': import_folder('../graphics/particles/pic1'),\n\t\t\t'pic2': import_folder('../graphics/particles/pic2'),\n\t\t\t'pic3': import_folder('../graphics/particles/pic3'),\n\t\t\t'statue4': import_folder('../graphics/particles/statue4'),\n\t\t\t'statue5': import_folder('../graphics/particles/statue5'),\n\t\t\t'statue6': import_folder('../graphics/particles/statue6')\n\n\t\t\t}\n\t\n\tdef reflect_images(self,frames):\n\t\tnew_frames = []\n\n\t\tfor frame in frames:\n\t \t\tflipped_frame = pygame.transform.flip(frame,True,False)\n\t \t\tnew_frames.append(flipped_frame)\n\t\treturn new_frames\n\n\tdef create_grass_particles(self,pos,groups):\n\t \tanimation_frames = choice(self.frames['leaf'])\n\t \tParticleEffect(pos,animation_frames,groups, 'none', False)\n\n\tdef create_particles(self,animation_type,pos,groups, no_kill):\n\t\tanimation_frames = self.frames[animation_type]\n\t\tParticleEffect(pos,animation_frames,groups, animation_type, no_kill)\n", "description": null, "category": "graphics", "imports": ["import sys", "import time", "import pygame", "from support import import_folder", "from random import choice", "from debug import caption, pic", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))", "\t\t\t'pic1': import_folder('../graphics/particles/pic1'),", "\t\t\t'pic2': import_folder('../graphics/particles/pic2'),", "\t\t\t'pic3': import_folder('../graphics/particles/pic3'),", "\t\t\t'statue4': import_folder('../graphics/particles/statue4'),", "\t\t\t'statue5': import_folder('../graphics/particles/statue5'),", "\t\t\t'statue6': import_folder('../graphics/particles/statue6')"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\n\tdef __init__(self,pos,animation_frames,groups, animation_type, no_kill=False):\n\t\tsuper().__init__(groups)\n\t\tself.sprite_type = 'magic'\n\t\tself.frame_index = 0\n\t\tself.animation_speed = 0.15\n\t\tself.animation_type = animation_type\n\t\tself.frames = animation_frames\n\t\tself.image = self.frames[self.frame_index]\n\t\tself.rect = self.image.get_rect(center = pos)\n\t\tself.no_kill = no_kill\n\n\tdef animate(self):\n\t\tself.frame_index += self.animation_speed\n\t\tif self.frame_index >= len(self.frames):\n\t\t\tif self.no_kill:\n\t\t\t\treturn\n\t\t\tself.kill()\n\t\telse:\n\t\t\tself.image = self.frames[int(self.frame_index)]\n\n\tdef update(self):\n\t\tself.animate()\n", "description": null, "category": "graphics", "imports": ["import sys", "import time", "import pygame", "from support import import_folder", "from random import choice", "from debug import caption, pic", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))", "\t\t\t'pic1': import_folder('../graphics/particles/pic1'),", "\t\t\t'pic2': import_folder('../graphics/particles/pic2'),", "\t\t\t'pic3': import_folder('../graphics/particles/pic3'),", "\t\t\t'statue4': import_folder('../graphics/particles/statue4'),", "\t\t\t'statue5': import_folder('../graphics/particles/statue5'),", "\t\t\t'statue6': import_folder('../graphics/particles/statue6')"]}], [{"term": "def", "name": "show", "data": "def show(graphics, title=None, width=None, height=None, **options):\n\t\"\"\"\n\tShows given graphics in the viewer app.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics or pero.Control\n\t\t\tGraphics to be shown.\n\t\t\n\t\ttitle: str or None\n\t\t\tViewer frame title.\n\t\t\n\t\twidth: float or None\n\t\t\tViewer width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tViewer height in device units.\n\t\t\n\t\tstyle: str\n\t\t\tPresentation style of the ui.View. Recognized values are:\n\t\t\tfullscreen, sheet, popover and panel. If any touch events are\n\t\t\texpected to work, the fullscreen should be used.\n\t\"\"\"\n\t\n\t# show as image in console\n\tif not isinstance(graphics, Control):\n\t\texport(graphics, width=width, height=height, **options)\n\t\treturn\n\t\n\t# get style\n\tstyle = \"fullscreen\"\n\tif 'style' in options:\n\t\tstyle = options['style']\n\t\n\t# init main window\n\twindow = UIViewer()\n\t\n\t# set title\n\tif title is not None:\n\t\twindow.set_title(title)\n\t\n\t# check size\n\tif not width:\n\t\twidth = VIEWER_WIDTH\n\tif not height:\n\t\theight = VIEWER_HEIGHT\n\t\n\t# set size\n\twindow.set_size((width, height))\n\t\n\t# set graphics\n\twindow.set_content(graphics)\n\t\n\t# draw graphics\n\twindow.refresh()\n\t\n\t# start app\n\twindow.present(style)\n\n", "description": "\n\tShows given graphics in the viewer app.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics or pero.Control\n\t\t\tGraphics to be shown.\n\t\t\n\t\ttitle: str or None\n\t\t\tViewer frame title.\n\t\t\n\t\twidth: float or None\n\t\t\tViewer width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tViewer height in device units.\n\t\t\n\t\tstyle: str\n\t\t\tPresentation style of the ui.View. Recognized values are:\n\t\t\tfullscreen, sheet, popover and panel. If any touch events are\n\t\t\texpected to work, the fullscreen should be used.\n\t", "category": "graphics", "imports": ["import ui", "from .. control import Control", "from . enums import *", "from . canvas import UICanvas", "from . viewer import UIViewer"]}, {"term": "def", "name": "export", "data": "def export(graphics, path=None, width=None, height=None, **options):\n\t\"\"\"\n\tDraws given graphics as raster image into specified file or into Pythonista\n\tconsole.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tpath: str or None\n\t\t\tFull path of a file to save the image into. If set to None the image\n\t\t\tis displayed in the Pythonista console.\n\t\t\n\t\twidth: float or None\n\t\t\tImage width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage height in device units.\n\t\t\n\t\tdraw_scale: float\n\t\t\tDrawing scaling factor.\n\t\t\n\t\tline_scale: float\n\t\t\tLine scaling factor.\n\t\t\n\t\tfont_scale: float\n\t\t\tFont scaling factor.\n\t\"\"\"\n\t\n\t# get line scale\n\tline_scale = 1\n\tif 'line_scale' in options:\n\t\tline_scale = options['line_scale']\n\t\n\t# check size\n\tif not width:\n\t\twidth = EXPORT_WIDTH\n\tif not height:\n\t\theight = EXPORT_HEIGHT\n\t\n\t# open context\n\twith ui.ImageContext(width*line_scale, height*line_scale) as ctx:\n\t\t\n\t\t# init canvas\n\t\tcanvas = UICanvas(width=width, height=height)\n\t\t\n\t\tif 'draw_scale' in options:\n\t\t\tcanvas.draw_scale = options['draw_scale']\n\t\t\n\t\tif 'line_scale' in options:\n\t\t\tcanvas.line_scale = options['line_scale']\n\t\t\n\t\tif 'font_scale' in options:\n\t\t\tcanvas.font_scale = options['font_scale']\n\t\t\n\t\t# draw graphics\n\t\tgraphics.draw(canvas)\n\t\t\n\t\t# get image\n\t\timg = ctx.get_image()\n\t\t\n\t\t# save to file\n\t\tif path:\n\t\t\twith open(path, 'wb') as f:\n\t\t\t\tf.write(img.to_png())\n\t\t\n\t\t# show image\n\t\telse:\n\t\t\timg.show()\n", "description": "\n\tDraws given graphics as raster image into specified file or into Pythonista\n\tconsole.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tpath: str or None\n\t\t\tFull path of a file to save the image into. If set to None the image\n\t\t\tis displayed in the Pythonista console.\n\t\t\n\t\twidth: float or None\n\t\t\tImage width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage height in device units.\n\t\t\n\t\tdraw_scale: float\n\t\t\tDrawing scaling factor.\n\t\t\n\t\tline_scale: float\n\t\t\tLine scaling factor.\n\t\t\n\t\tfont_scale: float\n\t\t\tFont scaling factor.\n\t", "category": "graphics", "imports": ["import ui", "from .. control import Control", "from . enums import *", "from . canvas import UICanvas", "from . viewer import UIViewer"]}], [{"term": "class", "name": "classAnimationPlayer:\r", "data": "class AnimationPlayer:\r\n\tdef __init__(self):\r\n\t\tself.frames = {\r\n\t\t\t# magic\r\n\t\t\t'flame': import_folder('12 - particles/12 - particles/graphics/particles/flame/frames'),\r\n\t\t\t'aura': import_folder('12 - particles/12 - particles/graphics/particles/aura'),\r\n\t\t\t'heal': import_folder('12 - particles/12 - particles/graphics/particles/heal/frames'),\r\n\r\n\t\t\t# attacks\r\n\t\t\t'claw': import_folder('12 - particles/12 - particles/graphics/particles/claw'),\r\n\t\t\t'slash': import_folder('12 - particles/12 - particles/graphics/particles/slash'),\r\n\t\t\t'sparkle': import_folder('12 - particles/12 - particles/graphics/particles/sparkle'),\r\n\t\t\t'leaf_attack': import_folder('12 - particles/12 - particles/graphics/particles/leaf_attack'),\r\n\t\t\t'thunder': import_folder('12 - particles/12 - particles/graphics/particles/thunder'),\r\n\r\n\t\t\t# monster deaths\r\n\t\t\t'squid': import_folder('12 - particles/12 - particles/graphics/particles/smoke_orange'),\r\n\t\t\t'raccoon': import_folder('12 - particles/12 - particles/graphics/particles/raccoon'),\r\n\t\t\t'spirit': import_folder('12 - particles/12 - particles/graphics/particles/nova'),\r\n\t\t\t'bamboo': import_folder('12 - particles/12 - particles/graphics/particles/bamboo'),\r\n\r\n\t\t\t# leafs\r\n\t\t\t'leaf': (\r\n\t\t\t\timport_folder(\r\n\t\t\t\t\t'12 - particles/12 - particles/graphics/particles/leaf1'),\r\n\t\t\t\timport_folder(\r\n\t\t\t\t\t'12 - particles/12 - particles/graphics/particles/leaf2'),\r\n\t\t\t\timport_folder(\r\n\t\t\t\t\t'12 - particles/12 - particles/graphics/particles/leaf3'),\r\n\t\t\t\timport_folder(\r\n\t\t\t\t\t'12 - particles/12 - particles/graphics/particles/leaf4'),\r\n\t\t\t\timport_folder(\r\n\t\t\t\t\t'12 - particles/12 - particles/graphics/particles/leaf5'),\r\n\t\t\t\timport_folder(\r\n\t\t\t\t\t'12 - particles/12 - particles/graphics/particles/leaf6'),\r\n\t\t\t\tself.reflect_images(import_folder(\r\n\t\t\t\t\t'12 - particles/12 - particles/graphics/particles/leaf1')),\r\n\t\t\t\tself.reflect_images(import_folder(\r\n\t\t\t\t\t'12 - particles/12 - particles/graphics/particles/leaf2')),\r\n\t\t\t\tself.reflect_images(import_folder(\r\n\t\t\t\t\t'12 - particles/12 - particles/graphics/particles/leaf3')),\r\n\t\t\t\tself.reflect_images(import_folder(\r\n\t\t\t\t\t'12 - particles/12 - particles/graphics/particles/leaf4')),\r\n\t\t\t\tself.reflect_images(import_folder(\r\n\t\t\t\t\t'12 - particles/12 - particles/graphics/particles/leaf5')),\r\n\t\t\t\tself.reflect_images(import_folder(\r\n\t\t\t\t\t'12 - particles/12 - particles/graphics/particles/leaf6'))\r\n\t\t\t)\r\n\t\t}\r\n\r\n\tdef reflect_images(self, frames):\r\n\t\t# once proper direction, once reflected to get a varaiblity\r\n\t\tnew_frames = []\r\n\t\tfor frame in frames:\r\n\t\t\tflipped_frame = pygame.transform.flip(frame, True, False)\r\n\t\t\tnew_frames.append(flipped_frame)\r\n\t\treturn new_frames\r\n\r\n\tdef create_grass_particles(self, position, groups):\r\n\t\tanimation_frames = choice(self.frames['leaf'])\r\n\t\tParticleEffect(position, animation_frames, groups)\r\n\r\n\tdef create_attack_particles(self, animation_type, position, groups):\r\n\t\tanimation_frames = self.frames[animation_type]\r\n\t\tParticleEffect(position, animation_frames, groups)\r\n\r\n", "description": null, "category": "graphics", "imports": ["import pygame\r", "from support import import_folder\r", "from random import choice\r", "\t\t\t'flame': import_folder('12 - particles/12 - particles/graphics/particles/flame/frames'),\r", "\t\t\t'aura': import_folder('12 - particles/12 - particles/graphics/particles/aura'),\r", "\t\t\t'heal': import_folder('12 - particles/12 - particles/graphics/particles/heal/frames'),\r", "\t\t\t'claw': import_folder('12 - particles/12 - particles/graphics/particles/claw'),\r", "\t\t\t'slash': import_folder('12 - particles/12 - particles/graphics/particles/slash'),\r", "\t\t\t'sparkle': import_folder('12 - particles/12 - particles/graphics/particles/sparkle'),\r", "\t\t\t'leaf_attack': import_folder('12 - particles/12 - particles/graphics/particles/leaf_attack'),\r", "\t\t\t'thunder': import_folder('12 - particles/12 - particles/graphics/particles/thunder'),\r", "\t\t\t'squid': import_folder('12 - particles/12 - particles/graphics/particles/smoke_orange'),\r", "\t\t\t'raccoon': import_folder('12 - particles/12 - particles/graphics/particles/raccoon'),\r", "\t\t\t'spirit': import_folder('12 - particles/12 - particles/graphics/particles/nova'),\r", "\t\t\t'bamboo': import_folder('12 - particles/12 - particles/graphics/particles/bamboo'),\r", "\t\t\t\timport_folder(\r", "\t\t\t\timport_folder(\r", "\t\t\t\timport_folder(\r", "\t\t\t\timport_folder(\r", "\t\t\t\timport_folder(\r", "\t\t\t\timport_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\r\n\tdef __init__(self, position, animation_frames, groups):\r\n\t\t# this gives the particle effect a sprite type and allows flame to interact with the enemies\r\n\t\tself.sprite_type = 'magic'\r\n\t\tself.frame_index = 0\r\n\t\tself.animation_speed = 0.15\r\n\t\tself.frames = animation_frames\r\n\t\tself.image = self.frames[self.frame_index]\r\n\t\tself.rect = self.image.get_rect(center=position)\r\n\t\tsuper().__init__(groups)\r\n\r\n\t# we have a lot of particle and if pygame inputs everything when we destroy an enemy or a grass, the game will become very slow\r\n\r\n\tdef animate(self):\r\n\t\tself.frame_index += self.animation_speed\r\n\t\tif self.frame_index >= len(self.frames):\r\n\t\t\tself.kill()\r\n\t\telse:\r\n\t\t\t# increasing frame index, then we pick from the list but if we go beyond then we destroy the sprite so as to only run the animation one time\r\n\t\t\tself.image = self.frames[int(self.frame_index)]\r\n\r\n\tdef update(self):\r\n\t\tself.animate()\r\n", "description": null, "category": "graphics", "imports": ["import pygame\r", "from support import import_folder\r", "from random import choice\r", "\t\t\t'flame': import_folder('12 - particles/12 - particles/graphics/particles/flame/frames'),\r", "\t\t\t'aura': import_folder('12 - particles/12 - particles/graphics/particles/aura'),\r", "\t\t\t'heal': import_folder('12 - particles/12 - particles/graphics/particles/heal/frames'),\r", "\t\t\t'claw': import_folder('12 - particles/12 - particles/graphics/particles/claw'),\r", "\t\t\t'slash': import_folder('12 - particles/12 - particles/graphics/particles/slash'),\r", "\t\t\t'sparkle': import_folder('12 - particles/12 - particles/graphics/particles/sparkle'),\r", "\t\t\t'leaf_attack': import_folder('12 - particles/12 - particles/graphics/particles/leaf_attack'),\r", "\t\t\t'thunder': import_folder('12 - particles/12 - particles/graphics/particles/thunder'),\r", "\t\t\t'squid': import_folder('12 - particles/12 - particles/graphics/particles/smoke_orange'),\r", "\t\t\t'raccoon': import_folder('12 - particles/12 - particles/graphics/particles/raccoon'),\r", "\t\t\t'spirit': import_folder('12 - particles/12 - particles/graphics/particles/nova'),\r", "\t\t\t'bamboo': import_folder('12 - particles/12 - particles/graphics/particles/bamboo'),\r", "\t\t\t\timport_folder(\r", "\t\t\t\timport_folder(\r", "\t\t\t\timport_folder(\r", "\t\t\t\timport_folder(\r", "\t\t\t\timport_folder(\r", "\t\t\t\timport_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r"]}], [{"term": "class", "name": "ActionGraphics", "data": "class ActionGraphics(QGraphicsItem):\n\t\"\"\"\n\tThis class defines the graphics for displaying a action in the ActionMenuItem view.\n\t\"\"\"\n\t\n\tPEN_WIDTH = 1.0\n\tMIN_WIDTH = 200\n\tH_SPACE = PortGraphics.WIDTH * 2\n\tV_SPACE = 50\n\tTOTAL_PORT_WIDTH = PortGraphics.WIDTH + H_SPACE\n\tTOTAL_RECT_HEIGHT = PortGraphics.TOTAL_HEIGHT + V_SPACE\n\tMAX_HEIGHT = TOTAL_RECT_HEIGHT + PortGraphics.TOTAL_HEIGHT\n\t\n\tCOLOR = QColor(0, 76, 153)\n\t\n\tdef __init__(self, action: 'Action', parent=None) -> 'ActionGraphics':\n\t\t\"\"\"\n\t\tConstructs a Action Graphics object for the given action.\n\t\t\n\t\t:param action: The action for which this graphics item represents.\n\t\t:type action: Action\n\t\t:param parent: None\n\t\t:type parent: NoneType\n\t\t:return: The graphics of an action.\n\t\t:rtype: ActionGraphics\n\t\t\"\"\"\n\t\tQGraphicsItem.__init__(self, parent)\n\t\tself.setFlag(QGraphicsItem.ItemIsSelectable)\n\t\tself.setCursor(Qt.ArrowCursor)\n\t\tself._action = action\n\t\tQObject.connect(action, SIGNAL('updated()'), self.updateGraphics)\n\t\t\n\t\tself.color = ActionGraphics.COLOR\n\t\t\n\t\tself._inputPortGraphics = []\n\t\tself._outputPortGraphics = []\n\t\tself._wireGraphics = []\n\t\tself._actionGraphics = []\n\t\t\n\t\tself._inputPortMapping = {}\n\t\tself._outputPortMapping = {}\n\t\t\n\t\tself._interactivePorts = True\n\t\tActionGraphics.updateGraphics(self)\n\n\t\tself._width = 0\n\t\tself._height = 0\n\n\t\t\n\t@Slot()\n\tdef updateGraphics(self) -> None:\n\t\t\"\"\"\n\t\tUpdates all graphics and sub-graphics for this action.\n\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\tself.prepareGeometryChange()\n\t\tself.updatePortGraphics()\n\t\treturn QGraphicsItem.update(self)\n\n\tdef getAction(self):\n\t\t\"\"\"\n\t\tReturns the ActionGraphics' Action. Used by WireGraphics to get a reference to the ActionPipeline to add a wire.\n\n\t\t:return: The Action associated with the ActionGraphics.\n\t\t:rtype: Action\n\t\t\"\"\"\n\t\treturn self._action\n\t\n\tdef getPortGraphics(self, port: Port) -> PortGraphics:\n\t\t\"\"\"\n\t\tGets the port graphics for any port that is owned by this action.\n\t\t\n\t\t.. note:: This function returns None if the port was not found.\n\n\t\t:param port: The port to get the PortGraphics for.\n\t\t:type port: Port\n\t\t:return: The PortGraphics for the port\n\t\t:rtype: PortGraphics\n\t\t\"\"\"\n\t\tpm = {}  # pm: \"port Mapping\"\n\t\tpm.update(self._inputPortMapping)\n\t\tpm.update(self._outputPortMapping)\n\t\t\n\t\treturn pm.get(port, None)\n\n\tdef updatePortGraphics(self) -> None:\n\t\t\"\"\"\n\t\tCreates the port graphics for the action.\n\t\t\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\t\n\t\tdef synchronizePortList(myPortList: List['PortGraphics'], refPortList: List['Port'],\n\t\t\t\t\t\t\t\t mapping: Dict['Port', 'PortGraphics']) -> None:\n\t\t\t\"\"\"\n\t\t\tSynchronizes either the inputs our outputs of the port graphics with the\n\t\t\tcorresponding port list in the action.\n\n\t\t\t:param myPortList: The list of port graphics in this action to synchronize.\n\t\t\t:type myPortList: List['PortGraphics']\n\t\t\t:param refPortList: The list of ports to synchronize with from the reference action.\n\t\t\t:type refPortList: List['Port']\n\t\t\t:param mapping: Maps the ports in the wrapper to the corresponding port in the reference.\n\t\t\t:type mapping: Dict['Port', 'Port']\n\t\t\t:return: None\n\t\t\t:rtype: NoneType\n\t\t\t\"\"\"\n\t\t\t\n\t\t\tassert (myPortList is self._inputPortGraphics or myPortList is self._outputPortGraphics)\n\t\t\t\n\t\t\tnewOrdering = []\n\t\t\t\n\t\t\t# map all of the reference ports to port graphics.\n\t\t\tfor refPort in refPortList:\n\t\t\t\t\n\t\t\t\t# update any port graphics that are already in the mapping.\n\t\t\t\tif refPort in mapping:\n\t\t\t\t\tmapping[refPort].update()\n\t\t\t\t\n\t\t\t\t# create new ports that aren't already in the mapping.\n\t\t\t\telse:\n\t\t\t\t\tnewPortGraphics = PortGraphics(refPort, self, self._interactivePorts)\n\t\t\t\t\tmyPortList.append(newPortGraphics)\n\t\t\t\t\tmapping[refPort] = newPortGraphics\n\t\t\t\t\n\t\t\t\tnewOrdering.append(mapping[refPort])\n\t\t\t\n\t\t\t# remove any ports that don't exist in the reference action.\n\t\t\tfor portGraphics in myPortList[:]:\n\t\t\t\tif portGraphics not in newOrdering:\n\t\t\t\t\tmyPortList.remove(portGraphics)\n\t\t\t\t\tportGraphics.scene().removeItem(portGraphics)\n\t\t\t\n\t\t\t# maintain correct ordering of ports\n\t\t\tmyPortList.clear()\n\t\t\tfor port in newOrdering:\n\t\t\t\tmyPortList.append(port)\n\t\t\n\t\tsynchronizePortList(self._inputPortGraphics, self._action.getInputPorts(), self._inputPortMapping)\n\t\tsynchronizePortList(self._outputPortGraphics, self._action.getOutputPorts(), self._outputPortMapping)\n\t\tself.getActionRect(self._action.getInputPorts(), self._action.getOutputPorts())\n\t\tself.placePorts()\n\t\n\tdef boundingRect(self) -> QRectF:\n\t\t\"\"\"\n\t\tThis function defines the outer bounds of the actions icon.\n\t\t\n\t\t:return: Creates the bounds for the graphics.\n\t\t:rtype: QRectF\n\t\t\"\"\"\n\t\t\n\t\tinputPorts = self._action.getInputPorts()\n\t\toutputPorts = self._action.getOutputPorts()\n\t\t\n\t\tx,y,width,height = self.getActionRect(inputPorts,outputPorts)\n\t\t\n\t\tif inputPorts:\n\t\t\theight += PortGraphics.TOTAL_HEIGHT/2\n\t\t\ty -= PortGraphics.TOTAL_HEIGHT/2\n\t\tif outputPorts:\n\t\t\theight += PortGraphics.TOTAL_HEIGHT/2\n\t\t\t\n\t\twidth += ActionGraphics.PEN_WIDTH\n\t\theight += max(ActionGraphics.PEN_WIDTH, PortGraphics.REQUIRED_PEN_WIDTH)\n\t\t\n\t\treturn QRectF(x, y, width, height)\n\t\n\tdef getActionRect(self, inputPorts: QGraphicsItem, outputPorts: QGraphicsItem) -> list:\n\t\t\"\"\"\n\t\tGets the bounding rect of the action.\n\t\t\n\t\t:param inputPorts: Input ports added for the action.\n\t\t:type: QGraphicsItem\n\t\t:param outputPorts: Output ports added for the action.\n\t\t:type: QGraphicsItem\n\t\t:return: List of coordinates and dimensions for the bounding rect of the action.\n\t\t:rtype: list\n\t\t\"\"\"\n\t\thalfPenWidth = ActionGraphics.PEN_WIDTH / 2\n\t\tmaxPorts = max(len(inputPorts), len(outputPorts))\n\t\t\n\t\twidth = max(ActionGraphics.TOTAL_PORT_WIDTH * maxPorts, ActionGraphics.MIN_WIDTH)\n\t\theight = ActionGraphics.TOTAL_RECT_HEIGHT\n\t\t\n\t\tx = (-0.5 * width) - halfPenWidth\n\t\ty = (-0.5 * height) - halfPenWidth\n\t\t\n\t\tself._width = width\n\t\tself._height = height\n\t\t\n\t\treturn x, y, width, height\n\t\n\tdef updateActionRect(self) -> None:\n\t\t\"\"\"\n\t\tUpdates the action rectangle's width and height attributes\n\t\t\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\tinputPorts = self._action.getInputPorts()\n\t\toutputPorts = self._action.getOutputPorts()\n\t\t\n\t\tself.getActionRect(inputPorts, outputPorts)\n\t\t\n\tdef shape(self) -> QPainterPath:\n\t\t\"\"\"\n\t\tDefines the shape of the action icon.\n\t\t\n\t\t:return: Returns the shape of the action icon.\n\t\t:rtype: QPainterPath\n\t\t\"\"\"\n\t\treturn QGraphicsItem.shape(self)\n\t\n\tdef paint(self, painter: QPainter, option: QStyleOptionGraphicsItem, index: QWidget) -> None:\n\t\t\"\"\"\n\t\tPaint the graphics of the action with the ports.\n\n\t\t:param painter: This draws the widget.\n\t\t:type painter: QPainter\n\t\t:param option: Option for the style of graphic.\n\t\t:type option: QStyleOptionGraphicsItem\n\t\t:param index: Index for the painted graphic.\n\t\t:type index: QWidget\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\n\t\tself.placePorts()\n\t\tpainter.setBrush(self.color)\n\t\tx, y, width, height = self.getActionRect(self._action.getInputPorts(), self._action.getOutputPorts())\n\t\tpainter.drawRect(QRectF(x, y, width, height))\n\n\tdef placePorts(self) -> None:\n\t\t\"\"\"\n\t\tPlace the ports at the right positions on the actions.\n\t\t\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\t\n\t\tdef spread(y: int , portList: list) -> None:\n\t\t\t\"\"\"\n\t\t\tSpreads a single port list evenly.\n\t\t\t\n\t\t\t:param y: The coordinate the ports need to be placed.\n\t\t\t:type: int\n\t\t\t:param portList: The list of ports that need to be placed.\n\t\t\t:type: list\n\t\t\t:return: None\n\t\t\t:rtype: NoneType\n\t\t\t\"\"\"\n\t\t\toffset = 0 # offset from center\n\t\t\tif len(portList) % 2 == 0:\n\t\t\t\toffset = ActionGraphics.TOTAL_PORT_WIDTH / 2\n\t\t\t\t\n\t\t\thalfLen = (len(portList) - 1) / 2\n\t\t\tfor p in range(len(portList)):\n\t\t\t\tposIdx = math.ceil(halfLen + p)\n\t\t\t\tnegIdx = math.floor(halfLen - p)\n\t\t\t\t\n\t\t\t\tposShift = p * ActionGraphics.TOTAL_PORT_WIDTH + offset\n\t\t\t\tnegShift = -posShift\n\t\t\t\t\n\t\t\t\ttry:\n\t\t\t\t\tportList[posIdx].setPos(posShift, y)\n\t\t\t\t\tportList[negIdx].setPos(negShift, y)\n\t\t\t\texcept IndexError:\n\t\t\t\t\treturn\n\t\t\t\t\n\t\tspread(-self._height / 2, self._inputPortGraphics)\n\t\tspread(self._height / 2, self._outputPortGraphics)\n\n\tdef getHeight(self):\n\t\tself.updateActionRect()\n\t\treturn self._height\n\n\tdef getWidth(self):\n\t\tself.updateActionRect()\n\t\treturn self._width\n\n\tdef getPortGraphicsAtPos(self, x: float, y: float) -> 'PortGraphics':\n\t\t\"\"\"\n\t\tIf there is a port at the position x, y, return it. The port does not have to be the\n\t\titem with the greatest Z value. This is different from the scene.itemAt function which only\n\t\tgets the top item.\n\n\t\t:param x: the scene x coordinate.\n\t\t:type x: float\n\t\t:param y: the scene y coordinate.\n\t\t:type y: float\n\t\t:return: the port graphics item at position (x, y)\n\t\t:rtype: PortGraphics\n\t\t\"\"\"\n\t\trect = QRectF(x - 1, y - 1, 2, 2)\n\t\titems = self.scene().items(rect)\n\n\t\t# get the port graphics under the mouse if it exists.\n\t\tfor item in items:\n\t\t\tif type(item) == PortGraphics:\n\t\t\t\treturn item\n\t\treturn None\n\n\tdef mousePressEvent(self, event: QGraphicsSceneMouseEvent, emitSelected:bool = True):\n\t\t\"\"\"\n\t\tWhen a port is clicked, emit the entitySelected signal from the view.\n\t\t:param event: the mouse click event\n\t\t:type event: QGraphicsSceneMouseEvent\n\t\t:param emitSelected: Decide if we want to show the action's properties in the properties editor or not.\n\t\t:type emitSelected: bool\n\t\t:return: None\n\t\t\"\"\"\n\t\tevent.ignore()\n\n\t\tif emitSelected:\n\t\t\tself.scene().views()[0].entitySelected.emit(self._action)\n", "description": "\n\tThis class defines the graphics for displaying a action in the ActionMenuItem view.\n\t", "category": "graphics", "imports": ["import sys", "import math", "from typing import Dict, List", "from PySide2.QtWidgets import QGraphicsItem, QApplication, QGraphicsView, QGraphicsScene, \\", "from PySide2.QtGui import QPainter, QPainterPath, QColor, Qt", "from PySide2.QtCore import QRectF, Slot, SIGNAL, QObject", "from graphics.apim.portgraphics import PortGraphics", "from data.apim.action import Action", "from data.apim.componentaction import ComponentAction", "from data.apim.port import Port"]}], [{"term": "class", "name": "Describestheinteriorofagraphicsshapecomposedofrectanglesandpaths.Thisclasscannotbeinherited.", "data": " Describes the interior of a graphics shape composed of rectangles and paths. This class cannot be inherited.\n\n \n", "description": null, "category": "graphics", "imports": []}], [{"term": "def", "name": "main", "data": "def main():\n\t\"\"\"\n\textensive version:\n\t1. add scoreboard\n\t2. if click over 10 times, you can turn on autopilot mode\n\t\"\"\"\n\tglobal my_life\n\tgraphics = BreakoutGraphics()\n\tball = graphics.ball\n\twindow = graphics.window\n\tvx = vy = 0\n\t# Add animation loop here!\n\tcontroller = 0  # controller = 0 --> click can work\n\tremove_count = 0\n\tpara_paddle = 0  # Avoid ball too large, making sure that ball exit the paddle\n\n\twhile my_life > 0:\n\t\tif graphics.ball_detect_object():\n\t\t\tif graphics.paddle is not graphics.ball_detect_object() and graphics.scoreboard is not graphics.ball_detect_object() and graphics.autopilot is not graphics.ball_detect_object():  # detect bricks\n\t\t\t\tvy = -vy\n\t\t\t\twindow.remove(graphics.ball_detect_object())\n\t\t\t\tremove_count = remove_count + 1\n\t\t\t\tgraphics.add_score(remove_count)\n\n\t\t\t\tif remove_count == graphics.brick_rows * graphics.brick_columns:\n\t\t\t\t\tgraphics.add_text('You win!', graphics.window.width / 3.5, graphics.window.height / 2)\n\t\t\t\t\tbreak\n\t\t\telse:  # detect paddle\n\t\t\t\tif para_paddle == 0 and ball.y + ball.height <= graphics.paddle.y + graphics.paddle.height:\n\t\t\t\t\tvy = -vy\n\t\t\t\t\tpara_paddle = 1\n\t\telse:  # detect nothing\n\t\t\tpara_paddle = 0  # reset para_paddle, which means ball fully exit paddle\n\n\t\tif ball.x < 0 or ball.x > window.width - ball.width:  # hit the wall\n\t\t\tvx = -vx\n\t\tif ball.y <= 0:  # hit the upper floor\n\t\t\tvy = -vy\n\t\tif ball.y > window.height - ball.height:  # hit the ground floor\n\t\t\tmy_life = my_life - 1\n\t\t\tgraphics.ball_reset()\n\t\t\tvx = vy = 0\n\t\t\tcontroller = 0  # open click\n\n\t\tif controller == 0:\n\t\t\tif graphics.count == 1:\n\t\t\t\tvx = graphics.get_dx()\n\t\t\t\tvy = graphics.get_dy()\n\t\t\t\tgraphics.count = 0\n\t\t\t\tcontroller = 1\n\n\t\tball.move(vx, vy)\n\n\t\t# For autopilot\n\t\tif graphics.auto_count == 10:\n\t\t\tgraphics.ball_reset()\n\t\t\tvx = 10\n\t\t\tvy = -10\n\t\t\tgraphics.paddle.x = ball.x - ball.width/2 - (graphics.paddle.width/2 - ball.width/2)\n\t\t\tgraphics.paddle.fill_color = 'red'\n\t\t\tgraphics.add_autopilot()\n\t\tif graphics.auto_count >= 10:\n\t\t\tgraphics.paddle.move(vx, 0)\n\t\tpause(FRAME_RATE)\n\n\tgraphics.remove_ball()\n\tif remove_count != graphics.brick_rows * graphics.brick_columns:\n\t\tgraphics.add_text('GGGGGGGGGGGGG', graphics.window.width / 5, graphics.window.height / 2)\n\n", "description": "\n\textensive version:\n\t1. add scoreboard\n\t2. if click over 10 times, you can turn on autopilot mode\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from extensive_bg import BreakoutGraphics"]}], [], [], [], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\n\tdx = graphics.get_x_speed()\n\tdy = graphics.get_y_speed()\n\n\tlives = NUM_LIVES\n\n\t# Add animation loop here!\n\twhile True:\n\t\tpause(FRAME_RATE)\n\t\tif graphics.start and lives > 0 and graphics.count > 0:\n\t\t\tgraphics.ball.move(dx, dy)\n\n\t\t\tif graphics.ball.y + graphics.ball.height >= graphics.window.height:\n\t\t\t\tlives -= 1\n\t\t\t\tgraphics.reset_ball()\n\t\t\telse:\n\t\t\t\tif graphics.get_obj():\n\t\t\t\t\tdy = -dy\n\t\t\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\t\t\t\tdx = -dx\n\t\t\t\tif graphics.ball.y <= 0:\n\t\t\t\t\tdy = -dy\n\n\t\telif lives <= 0:\n\t\t\t# game over\n\t\t\tlabel = GLabel('Game Over', x=0, y=graphics.window.height/2)\n\t\t\tlabel.font = '-48-bold'\n\t\t\tlabel.color = 'red'\n\t\t\tgraphics.window.add(label)\n\t\t\tgraphics.window.remove(graphics.ball)\n\t\t\tbreak\n\t\telif graphics.count <= 0:\n\t\t\t# you win\n\t\t\tlabel = GLabel('You Win!!!', x=0, y=graphics.window.height/2)\n\t\t\tlabel.font = '-48-bold'\n\t\t\tlabel.color = 'forestgreen'\n\t\t\tgraphics.window.add(label)\n\t\t\tgraphics.window.remove(graphics.ball)\n\t\t\tbreak\n\n\t# move the label\n\tdx = 1\n\twhile label.x <= graphics.window.width / 2 - 120:\n\t\tlabel.move(dx, 0)\n\t\tpause(10)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.graphics.gobjects import GLabel"]}], [{"term": "class", "name": "RunText", "data": "class RunText(SampleBase):\n\t\n\tdef __init__(self, *args, **kwargs):\n\t\tsuper(RunText, self).__init__(*args, **kwargs)\n\t\tself.parser.add_argument(\"-t\", \"--text\", help=\"The text to scroll on the RGB LED panel\", default=\"Hello world!\")\n\n\n\tdef refresh(self):\n\t\tprint(Fore.RESET + Back.RESET)\n\t\ttrains = []\n\n\t\tq = self.getQ()\n\t\t# sbs = self.getSBS()\n\t\tfourfivesix = self.getFourFiveSix()\n\n\t\tfor train in fourfivesix[:20]:\n\t\t\ttrains.append(train)\n\n\t\tfor train in q[:20]:\n\t\t\ttrains.append(train)\n\n\t\t# for train in sbs[:20]:\n\t\t#\t trains.append(train)\n\n\t\tsort_on = 'timetech'\n\t\tdecorated = [(dict_[sort_on], dict_) for dict_ in trains]\n\t\tdecorated.sort()\n\t\ttrains = [dict_ for (key, dict_) in decorated]\n\t\t# trains.reverse()\n\n\t\ttrains = filter(lambda a: a['timetech'] \\\n\t\t\t\t\t\t< datetime.timedelta(minutes=-8), trains)  # or \"SBS\" in a['train']\n\t\ttrainstext = ''\n\t\tfor train in trains[:20]:\n\t\t\ttrainstext += train['train'] + ' arriving ' + train['time'] \\\n\t\t\t\t+ ''\n\n\t\t#self.printTrains(trains)\n\n\t\treturn trains[0]['train'] + ' arriving ' + trains[0]['time']\n\n\tdef printTrains(self,trains):\n\t\tos.system('clear')\n\t\tfor train in trains[:20]:\n\t\t\tprint(train['train'] + ' arriving ' + train['time'])\n\n\tdef getFourFiveSix(self):\n\t\tAPI_headers = {\"x-api-key\": config.SUBWAY_API_KEY}\n\t\tfourfivesix = []\n\t\t# response2 = requests.get('https://api-endpoint.mta.info/Dataservice/mtagtfsfeeds/nyct%2Fgtfs', headers=API_headers)\n\n\t\tfeed2 = gtfs_realtime_pb2.FeedMessage()\n\t\treq = Request('https://api-endpoint.mta.info/Dataservice/mtagtfsfeeds/nyct%2Fgtfs')\n\t\treq.add_header('x-api-key', config.SUBWAY_API_KEY)\n\t\tresponseMsg = urlopen(req)\n\t\t#feed2.ParseFromString(response2.content)\n\t\tfeed2.ParseFromString(responseMsg.read())\n\t\tfor entity in feed2.entity:\n\t\t\tif entity.HasField('trip_update'):\n\t\t\t\tfor stopUpdate in entity.trip_update.stop_time_update:\n\t\t\t\t\tif stopUpdate.stop_id == '626S':\n\n\t\t\t\t\t\t# print entity.trip_update.trip\n\n\t\t\t\t\t\tcurrenttime = datetime.datetime.now()\n\t\t\t\t\t\ttraintime = \\\n\t\t\t\t\t\t\tdatetime.datetime.fromtimestamp(stopUpdate.arrival.time)\n\t\t\t\t\t\ttimeuntiltrain = currenttime - traintime\n\t\t\t\t\t\ttraintimetext = ''\n\t\t\t\t\t\tif int(traintime.strftime('%H')) > 12:\n\t\t\t\t\t\t\ttraintimetext = \\\n\t\t\t\t\t\t\t\tstr(int(traintime.strftime('%H')) - 12) \\\n\t\t\t\t\t\t\t\t+ traintime.strftime(':%M') + ' PM'\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\ttraintimetext = traintime.strftime('%H:%M') \\\n\t\t\t\t\t\t\t\t+ ' AM'\n\t\t\t\t\t\tif entity.trip_update.trip.route_id == '4':\n\t\t\t\t\t\t\tfourfivesix.append({'train': '86th Street '\n\t\t\t\t\t\t\t\t\t+ Back.GREEN + Fore.WHITE + ' 4 '\n\t\t\t\t\t\t\t\t\t+ Fore.RESET + Back.RESET + ' South'\n\t\t\t\t\t\t\t\t\t,\n\t\t\t\t\t\t\t\t\t'time': humanize.naturaltime(timeuntiltrain)\n\t\t\t\t\t\t\t\t\t+ ' (' + traintimetext + ')',\n\t\t\t\t\t\t\t\t\t'timetech': timeuntiltrain, 'minutes': ((traintime - currenttime).seconds / 60)})\n\t\t\t\t\t\tif entity.trip_update.trip.route_id == '5':\n\t\t\t\t\t\t\tfourfivesix.append({'train': '86th Street '\n\t\t\t\t\t\t\t\t\t+ Back.GREEN + Fore.WHITE + ' 5 '\n\t\t\t\t\t\t\t\t\t+ Fore.RESET + Back.RESET + ' South'\n\t\t\t\t\t\t\t\t\t,\n\t\t\t\t\t\t\t\t\t'time': humanize.naturaltime(timeuntiltrain)\n\t\t\t\t\t\t\t\t\t+ ' (' + traintimetext + ')',\n\t\t\t\t\t\t\t\t\t'timetech': timeuntiltrain, 'minutes': ((traintime - currenttime).seconds / 60)})\n\t\t\t\t\t\tif entity.trip_update.trip.route_id == '6':\n\t\t\t\t\t\t\tfourfivesix.append({'train': '86th Street '\n\t\t\t\t\t\t\t\t\t+ Back.GREEN + Fore.WHITE + ' 6 '\n\t\t\t\t\t\t\t\t\t+ Fore.RESET + Back.RESET + ' South'\n\t\t\t\t\t\t\t\t\t,\n\t\t\t\t\t\t\t\t\t'time': humanize.naturaltime(timeuntiltrain)\n\t\t\t\t\t\t\t\t\t+ ' (' + traintimetext + ')',\n\t\t\t\t\t\t\t\t\t'timetech': timeuntiltrain, 'minutes': ((traintime - currenttime).seconds / 60)})\n\t\ttrains = []\t\t\n\t\tfor train in fourfivesix[:20]:\n\t\t\ttrains.append(train)\n\n\t\tsort_on = 'timetech'\n\t\tdecorated = [(dict_[sort_on], dict_) for dict_ in trains]\n\t\tdecorated.sort()\n\t\ttrains = [dict_ for (key, dict_) in decorated]\n\t\ttrains.reverse()\n\n\t\tfor train in trains:\n\t\t\tif int(train['minutes']) > 8:\n\t\t\t\treturn str(train['minutes']) + \" min\"\n\t\treturn \"0 min\" #fourfivesix\n\n\tdef getQ(self):\n\t\tAPI_headers = {\"x-api-key\": config.SUBWAY_API_KEY}\n\t\tq = []\n\t\treq = Request('https://api-endpoint.mta.info/Dataservice/mtagtfsfeeds/nyct%2Fgtfs-nqrw')\n\t\treq.add_header('x-api-key', config.SUBWAY_API_KEY)\n\t\tresponseMsg = urlopen(req)\n\n\t\tfeed = gtfs_realtime_pb2.FeedMessage()\n\t\tfeed.ParseFromString(responseMsg.read())\n\n\t\tfor entity in feed.entity:\n\t\t\tif entity.HasField('trip_update'):\n\t\t\t\tfor stopUpdate in entity.trip_update.stop_time_update:\n\t\t\t\t\tif stopUpdate.stop_id == 'Q04S':\n\t\t\t\t\t\tcurrenttime = datetime.datetime.now()\n\t\t\t\t\t\ttraintime = \\\n\t\t\t\t\t\t\tdatetime.datetime.fromtimestamp(stopUpdate.arrival.time)\n\t\t\t\t\t\ttimeuntiltrain = currenttime - traintime\n\t\t\t\t\t\ttraintimetext = ''\n\t\t\t\t\t\tif int(traintime.strftime('%H')) > 12:\n\t\t\t\t\t\t\ttraintimetext = \\\n\t\t\t\t\t\t\t\tstr(int(traintime.strftime('%H')) - 12) \\\n\t\t\t\t\t\t\t\t+ traintime.strftime(':%M') + ' PM'\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\ttraintimetext = traintime.strftime('%H:%M') \\\n\t\t\t\t\t\t\t\t+ ' AM'\n\t\t\t\t\t\tq.append({'train': '86th Street ' + Back.YELLOW\n\t\t\t\t\t\t\t\t + Fore.BLACK + ' Q ' + Fore.RESET\n\t\t\t\t\t\t\t\t + Back.RESET + ' South',\n\t\t\t\t\t\t\t\t 'time': humanize.naturaltime(timeuntiltrain)\n\t\t\t\t\t\t\t\t + ' (' + traintimetext + ')',\n\t\t\t\t\t\t\t\t 'timetech': timeuntiltrain, 'minutes': ((traintime - currenttime).seconds / 60)})\n\t\t\t\t\t\t#if (((traintime - currenttime).seconds / 60) > 8):\n\t\t\t\t\t\t\t#return str(((traintime - currenttime).seconds / 60)) + \" min\"\n\t\ttrains = []\t\t\n\t\tfor train in q[:20]:\n\t\t\ttrains.append(train)\n\n\t\tsort_on = 'timetech'\n\t\tdecorated = [(dict_[sort_on], dict_) for dict_ in trains]\n\t\tdecorated.sort()\n\t\ttrains = [dict_ for (key, dict_) in decorated]\n\t\ttrains.reverse()\n\n\t\tfor train in trains:\n\t\t\tif int(train['minutes']) > 8:\n\t\t\t\treturn str(train['minutes']) + \" min\"\n\t\treturn \"0 min\" #q\n\n\t# def getSBS(self):\n\t#\t sbs = []\n\t#\t response = \\\n\t#\t\t requests.get('http://gtfsrt.prod.obanyc.com/tripUpdates?key='\n\t#\t\t\t\t\t   + config.BUS_API_KEY)\n\n\t#\t feed = gtfs_realtime_pb2.FeedMessage()\n\t#\t feed.ParseFromString(response.content)\n\n\t#\t for entity in feed.entity:\n\t#\t\t if entity.HasField('trip_update'):\n\t#\t\t\t for stopUpdate in entity.trip_update.stop_time_update:\n\t#\t\t\t\t if stopUpdate.stop_id == '401922':\n\t#\t\t\t\t\t currenttime = datetime.datetime.now()\n\t#\t\t\t\t\t traintime = \\\n\t#\t\t\t\t\t\t datetime.datetime.fromtimestamp(stopUpdate.arrival.time)\n\t#\t\t\t\t\t timeuntiltrain = currenttime - traintime\n\t#\t\t\t\t\t traintimetext = ''\n\t#\t\t\t\t\t if int(traintime.strftime('%H')) > 12:\n\t#\t\t\t\t\t\t traintimetext = \\\n\t#\t\t\t\t\t\t\t str(int(traintime.strftime('%H')) - 12) \\\n\t#\t\t\t\t\t\t\t + traintime.strftime(':%M') + ' PM'\n\t#\t\t\t\t\t else:\n\t#\t\t\t\t\t\t traintimetext = traintime.strftime('%H:%M') \\\n\t#\t\t\t\t\t\t\t + ' AM'\n\t#\t\t\t\t\t sbs.append({'train': '86th Street ' + Back.BLUE\n\t#\t\t\t\t\t\t\t\t+ Fore.LIGHTRED_EX + 'SBS'\n\t#\t\t\t\t\t\t\t\t+ Fore.RESET + Back.RESET + ' West',\n\t#\t\t\t\t\t\t\t\t'time': humanize.naturaltime(timeuntiltrain)\n\t#\t\t\t\t\t\t\t\t+ ' (' + traintimetext + ')',\n\t#\t\t\t\t\t\t\t\t'timetech': timeuntiltrain})\n\t#\t return sbs\n\n\tdef drawCircle(self, canvas, offset, color):\n\t\tgraphics.DrawLine(canvas,7,0 + offset,11,0 + offset,color)\n\t\tgraphics.DrawLine(canvas,5,1 + offset,13,1 + offset,color)\n\t\tgraphics.DrawLine(canvas,4,2 + offset,14,2 + offset,color)\n\t\tgraphics.DrawLine(canvas,4,3 + offset,14,3 + offset,color)\n\t\tgraphics.DrawLine(canvas,3,4 + offset,15,4 + offset,color)\n\t\tgraphics.DrawLine(canvas,3,5 + offset,15,5 + offset,color)\n\t\tgraphics.DrawLine(canvas,3,6 + offset,15,6 + offset,color)\n\t\tgraphics.DrawLine(canvas,3,7 + offset,15,7 + offset,color)\n\t\tgraphics.DrawLine(canvas,3,8 + offset,15,8 + offset,color)\n\t\tgraphics.DrawLine(canvas,4,9 + offset,14,9 + offset,color)\n\t\tgraphics.DrawLine(canvas,4,10 + offset,14,10 + offset,color)\n\t\tgraphics.DrawLine(canvas,5,11 + offset,13,11 + offset,color)\n\t\tgraphics.DrawLine(canvas,7,12 + offset,11,12 + offset,color)\n\n\tdef draw4(self, canvas):\n\t\tgreen = graphics.Color(0, 120, 60)\n\t\tblack = graphics.Color(0,0,0)\n\t\twhite = graphics.Color(255, 255, 255)\n\t\tyellow = graphics.Color(252,204,10)\n\t\t\n\t\tself.drawCircle(canvas,2,green)\n\t\t\n\t\tself.drawCircle(canvas,17,yellow)\n\t\t\n\n\t\t\n\t\tgraphics.DrawLine(canvas, 10,5,10,5 ,white)\n\t\tgraphics.DrawLine(canvas,  9,6,10,6,white)\n\t\tgraphics.DrawLine(canvas,  8,7,8,7,white)\n\t\tgraphics.DrawLine(canvas,  10,7,10,7,white)\n\t\tgraphics.DrawLine(canvas,  7,8,7,8,white)\n\t\tgraphics.DrawLine(canvas,  10,8,10,8,white)\n\t\tgraphics.DrawLine(canvas,  7,9,11,9,white)\n\t\tgraphics.DrawLine(canvas,  10,10,10,10,white)\n\t\tgraphics.DrawLine(canvas,  10,11,10,11,white)\n\t\t\n\t\toffset = 17\n\t\t\n\t\tgraphics.DrawLine(canvas,8,3 + offset,10,3 + offset,black)\n\t\tgraphics.DrawLine(canvas,7,4 + offset,7,4 + offset,black)\n\t\tgraphics.DrawLine(canvas,11,4 + offset,11,4 + offset,black)\n\t\tgraphics.DrawLine(canvas,6,5 + offset,6,5 + offset,black)\n\t\tgraphics.DrawLine(canvas,12,5 + offset,12,5 + offset,black)\n\t\tgraphics.DrawLine(canvas,6,6 + offset,6,6 + offset,black)\n\t\tgraphics.DrawLine(canvas,12,6 + offset,12,6 + offset,black)\n\t\tgraphics.DrawLine(canvas,6,7 + offset,6,7 + offset,black)\n\t\tgraphics.DrawLine(canvas,10,7 + offset,10,7 + offset,black)\n\t\tgraphics.DrawLine(canvas,12,7 + offset,12,7 + offset,black)\n\t\tgraphics.DrawLine(canvas,7,8 + offset,7,8 + offset,black)\n\t\tgraphics.DrawLine(canvas,10,8 + offset,11,8 + offset,black)\n\t\tgraphics.DrawLine(canvas,8,9 + offset,9,9 + offset,black)\n\t\tgraphics.DrawLine(canvas,11,9 + offset,11,9 + offset,black)\n\n\tdef run(self):\n\t\tnumLoops = 0;\n\t\tself.matrix.brightness = 75\n\t\ttraintime = \"86th Q\" #self.refresh()\n\t\toffscreen_canvas = self.matrix.CreateFrameCanvas()\n\t\tfont = graphics.Font()\n\t\tfont.LoadFont('../rpi-rgb-led-matrix/rpi-rgb-led-matrix-58830f7bb5dfb47fc24f1fd26cd7c4e3a20f13f7/fonts/6x9.bdf')\n\t\ttextColor = graphics.Color(255, 255, 0)\n\t\tpos = 18\n\t\tmy_text = traintime\n\t\tyellow = graphics.Color(252,204,10)\n\t\tblack = graphics.Color(0,0,0)\n\t\twhite = graphics.Color(220, 220, 220)\n\t\tred = graphics.Color(204, 51, 0)\n\t\tgreen = graphics.Color(0, 120, 60)\n\t\torange = graphics.Color(230,138,0)\n\t\tsickgreen = graphics.Color(204,204,0)\n\t\tleft = True\n\t\twait = 10\n\t\t\n\t\tqTime = \"0 min\"\n\t\tfTime = \"0 min\"\n\t\tqTime = self.getQ()\n\t\tfTime = self.getFourFiveSix()\n\n\t\twhile True:\n\t\t\toffscreen_canvas.Clear()\n\t\t\t#len = graphics.DrawText(\n\t\t\t#\toffscreen_canvas,\n\t\t\t #   font,\n\t\t\t  #  pos,\n\t\t\t   # 30,\n\t\t\t\t#textColor,\n\t\t\t\t#my_text,\n\t\t\t\t#)\n", "description": null, "category": "graphics", "imports": ["import datetime", "import os", "import time", "import calendar", "from urllib2 import urlopen, Request", "from samplebase import SampleBase", "from rgbmatrix import graphics", "import config", "import humanize", "import requests", "from colorama import Back, Fore, Style", "from google.transit import gtfs_realtime_pb2"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\n\t# chances\n\tchance = NUM_LIVES\n\t# starter\n\tstarter = 0\n\n\t# Add animation loop here!\n\twhile True:\n\t\t# update\n\t\tif not graphics.click:\n\t\t\tvx = 0\n\t\t\tvy = 0\n\t\telse:\n\t\t\tif starter == 0:\n\t\t\t\tvx = graphics.horizontal_speed\n\t\t\t\tvy = graphics.vertical_speed\n\t\t\t\tstarter = 1\n\t\tgraphics.ball.move(vx, vy)\n\t\t# check\n\t\tif graphics.ball.x <= 0 or graphics.ball.x+graphics.ball.width >= graphics.window.width:\n\t\t\tvx = -vx\n\t\tif graphics.ball.y <= 0 or graphics.ball.y+graphics.ball.height >= graphics.window.height:\n\t\t\tvy = -vy\n\t\tif graphics.ball.y+graphics.ball.height >= graphics.window.height:\n\t\t\tchance = chance - 1\n\t\t\tgraphics.window.remove(graphics.ball)\n\t\t\tgraphics.window.add(graphics.ball,\n\t\t\t\t\t\t\t\tx=(graphics.window.width-graphics.ball.width)//2, y=(graphics.window.height-graphics.ball.height)//2)\n\t\t\tgraphics.click = False\n\t\t\tstarter = 0\n\t\t\tif chance == 0:\n\t\t\t\tgraphics.click = True\n\t\t\t\tbreak\n\n\t\twhile True:\n\t\t\tball_x1 = graphics.ball.x\n\t\t\tball_y1 = graphics.ball.y\n\t\t\tobject_1 = graphics.window.get_object_at(ball_x1, ball_y1)\n\t\t\tif object_1 is not None:\n\t\t\t\tvx = -vx\n\t\t\t\tvy = -vy\n\t\t\t\tif object_1 is graphics.paddle:\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tgraphics.window.remove(object_1)\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tball_x2 = graphics.ball.x + graphics.ball.width\n\t\t\t\tball_y2 = graphics.ball.y\n\t\t\t\tobject_2 = graphics.window.get_object_at(ball_x2, ball_y2)\n\t\t\t\tif object_2 is not None:\n\t\t\t\t\tvx = -vx\n\t\t\t\t\tvy = -vy\n\t\t\t\t\tif object_2 is graphics.paddle:\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tgraphics.window.remove(object_2)\n\t\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tball_x3 = graphics.ball.x\n\t\t\t\t\tball_y3 = graphics.ball.y + graphics.ball.height\n\t\t\t\t\tobject_3 = graphics.window.get_object_at(ball_x3, ball_y3)\n\t\t\t\t\tif object_3 is not None:\n\t\t\t\t\t\tvx = -vx\n\t\t\t\t\t\tvy = -vy\n\t\t\t\t\t\tif object_3 is graphics.paddle:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tgraphics.window.remove(object_3)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tball_x4 = graphics.ball.x\n\t\t\t\t\t\tball_y4 = graphics.ball.y + graphics.ball.height\n\t\t\t\t\t\tobject_4 = graphics.window.get_object_at(ball_x4, ball_y4)\n\t\t\t\t\t\tif object_4 is not None:\n\t\t\t\t\t\t\tvx = -vx\n\t\t\t\t\t\t\tvy = -vy\n\t\t\t\t\t\t\tif object_4 is graphics.paddle:\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tgraphics.window.remove(object_4)\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tbreak\n\n\t\t# pause\n\t\tpause(FRAME_RATE)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "class", "name": "Display", "data": "class Display(object):\n\t\n\tWHITE = graphicsUtils.formatColor(1.0, 1.0, 1.0)\n\tRED = graphicsUtils.formatColor(1.0, 0.0, 0.0)\n\tGREEN = graphicsUtils.formatColor(0.16, 0.49, 0.31)\n\tBLUE = graphicsUtils.formatColor(0.0, 0.0, 1.0)\n\tBLACK = graphicsUtils.formatColor(0.0, 0.0, 0.0)\n\tGREY = graphicsUtils.formatColor(0.5, .5, 0.5)\n\t\n\tVISIBLE_CUTTOFF = 0.001\n\t\n\t\n\tpartDict = {}\n\tbeliefParts = []\n\tbeliefValue = []\n\tbeliefColor = []\n\tobservations = []\n\t\n\tgraphicsLock = threading.Lock()\n\t\n\tCOLORS = [\n\t\t'purple',\n\t\t'green',\n\t\t'teal',\n\t\t'red',\n\t\t'orange',\n\t\t'yellow'\n\t]\n\tCOLOR_HUES = {\n\t\t'purple' : 0.8,\n\t\t'green' : 0.3,\n\t\t'teal' : 0.49,\n\t\t'red' : 0.0,\n\t\t'orange' : 0.125,\n\t\t'yellow' : 0.21\n\t}\n\t\n\t@staticmethod\n\tdef initGraphics(layout):\n\t\tgraphicsUtils.begin_graphics(\n\t\t\twidth=layout.getWidth(), \n\t\t\theight=layout.getHeight(), \n\t\t\tcolor = Display.WHITE,\n\t\t\ttitle = Const.TITLE\n\t\t);\n\t\t\n\t@staticmethod\n\tdef endGraphics():\n\t\tgraphicsUtils.end_graphics()\n\n\t@staticmethod\n\tdef raiseEndGraphics():\n\t\tgraphicsUtils.raiseEndGraphics()\n\t\n\t@staticmethod\n\tdef drawCar(car):\n\t\tif car in Display.partDict:\n\t\t\tDisplay._remove(car)\n\t\tcolor = Display.GREY\n\t\tif car.isJunior():\n\t\t\tcolor = Display.BLACK\n\t\tparts = graphicsUtils.rectangle(\n\t\t\tcar.pos, Car.LENGTH, \n\t\t\tCar.WIDTH, \n\t\t\tcolor, \n\t\t\tcar.dir\n\t\t)\n\t\tDisplay.partDict[car] = parts\n\t\t\n\t@staticmethod\n\tdef drawObservation(obs):\n\t\tparts = Display.drawCircle(obs.pos, Observation.RADIUS)\n\t\tDisplay.partDict[obs] = parts\n\t\n\t@staticmethod\n\tdef drawSquare(pos, size, color):\n\t\treturn graphicsUtils.square(pos, size, color)\n\t\n\t@staticmethod\n\tdef drawFinish(block):\n\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.GREEN, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\n\t@staticmethod\n\tdef drawBlocks(blocks):\n\t\tfor block in blocks:\n\t\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.BLUE, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\t\n\t@staticmethod\n\tdef drawCircle(pos, radius):\n\t\treturn graphicsUtils.circle(pos, radius, Display.RED, Display.RED)\n\t\n\t@staticmethod\n\tdef drawBelief(model):\n\t\tDisplay.beliefVisible = []\n\t\tfor r in range(model.getBeliefRows()):\n\t\t\tbeliefValueRow = []\n\t\t\tbeliefPartRow = []\n\t\t\tbeliefColorRow = []\n\t\t\tfor c in range(model.getBeliefCols()):\n\t\t\t\tsquare = Display.drawBeliefSquare(r, c, 'purple', 0.0, model)\n\t\t\t\tbeliefPartRow.append(square)\n\t\t\t\tbeliefValueRow.append(0.0)\n\t\t\t\tbeliefColorRow.append(None)\n\t\t\tDisplay.beliefParts.append(beliefPartRow)\n\t\t\tDisplay.beliefValue.append(beliefValueRow)\n\t\t\tDisplay.beliefColor.append(beliefColorRow)\n\t\t\t\t\n\t@staticmethod\n\tdef drawBeliefSquare(row, col, color, value, model):\n\t\ttileSize = Const.BELIEF_TILE_SIZE\n\t\tx = col * tileSize + tileSize / 2.0\n\t\ty = row * tileSize + tileSize / 2.0\n\t\tif not model.inBounds(x, y): return None\n\t\tcolor = Display._getBeliefSquareColor(color, value)\n\t\treturn Display.drawSquare(Vec2d(x, y), tileSize, color)\n\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef getKeys():\n\t\t#print 'attempt get keys'\n\t\tDisplay._acquireLock()\n\t\t#print 'get keys'\n\t\tkeys = graphicsUtils.keys_waiting() + graphicsUtils.keys_pressed()\n\t\tDisplay._releaseLock()\n\t\treturn keys\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef graphicsSleep(timeToSleep):\n\t\tgraphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''for _ in range(int(timeToSleep / 0.005)):\n\t\t\t#print 'attempt sleep'\n\t\t\tDisplay._acquireLock()\n\t\t\t#print 'sleep'\n\t\t\tgraphicsUtils.sleep(0.001)\n\t\t\tDisplay._releaseLock()\n\t\t\ttime.sleep(0.004)'''\n\t\t\n\t\t#graphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''startWait = time.time()\n\t\tDisplay._acquireLock()\n\t\ttimeToSleep -= time.time() - startWait\n\t\tgraphicsUtils.refresh()\n\t\tif timeToSleep > 0:\n\t\t\tgraphicsUtils.sleep(timeToSleep)\n\t\tDisplay._releaseLock()'''\n\t\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef updateBelief(color, belief):\n\t\tDisplay._acquireLock()\n\t\ttotal = belief.getSum()\n\t\tif abs(total - 1.0) > 0.001:\n\t\t\traise Exception('belief does not sum to 1 ('+str(total)+'). Use the normalize method.')\n\t\tfor r in range(belief.getNumRows()):\n\t\t\tfor c in range(belief.getNumCols()):\n\t\t\t\tvalue = belief.getProb(r, c)\n\t\t\t\tDisplay._updateBeliefSquare(r, c, value, color)\n\t\tDisplay._releaseLock()\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef move(obj, delta):\n\t\t#print 'attempt move'\n\t\tDisplay._acquireLock()\n\t\t#print 'move'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.move_by(parts, delta.x, delta.y)\n\t\t#print 'end move'\n\t\tDisplay._releaseLock()\n\t\t\n\t# make thread safe\n\t@staticmethod\n\tdef rotate(obj, angle):\n\t\tif angle == 0: return\n\t\t#print 'attempt rotate'\n\t\tDisplay._acquireLock()\n\t\t#print 'rotate'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.rotate_by(parts, angle)\n\t\tDisplay._releaseLock()\n\t\t\t\t\n\t@staticmethod\n\tdef _getBeliefSquareColor(color, value):\n\t\tvalue = min(1.0, value * 15)\n\t\tsaturation = value\n\t\thue = Display.COLOR_HUES[color]\n\t\tr, g, b = colorsys.hsv_to_rgb(hue, saturation, 1.0)\n\t\tcolor = graphicsUtils.formatColor(r, g, b)\n\t\treturn color\t\t\n\t\n\t@staticmethod\n\tdef _isVisible(value):\n\t\treturn value >= Display.VISIBLE_CUTTOFF\n\t\n\t@staticmethod\n\tdef _updateBeliefSquare(r, c, value, colorName):\n\t\tpart = Display.beliefParts[r][c]\n\t\tif part == None: return\n\t\toldValue = Display.beliefValue[r][c]\n\t\toldColor = Display.beliefColor[r][c]\n\t\twasVisible = Display._isVisible(oldValue)\n\t\tisVisible = Display._isVisible(value) \n\t\tif not isVisible: value = 0.0\n\t\tif oldColor != colorName and oldValue >= value: return\n\t\tif not isVisible and not wasVisible: return\n\t\tcolor = Display._getBeliefSquareColor(colorName, value)\n\t\tgraphicsUtils.changeColor(part, color)\n\t\tDisplay.beliefValue[r][c] = value\n\t\tDisplay.beliefColor[r][c] = colorName\n\t\t\n\t@staticmethod\n\tdef _acquireLock():\n\t\treturn\n\t\t#print 'acquire'\n\t\treturn Display.graphicsLock.acquire()\n\t\n\t@staticmethod\n\tdef _releaseLock():\n\t\treturn\n\t\t#print 'release'\n\t\treturn Display.graphicsLock.release()\n\t \n\t####################################\n\t# Depreicated\n\t####################################\n\t\t\n\t@staticmethod\n\tdef _remove(obj):\n\t\tparts = Display.partDict[obj]\n\t\tgraphicsUtils.remove_from_screen(parts);\n\t\t\n\t@staticmethod\n\tdef redrawObservations(observations):\n\t\traise Exception('depreicated')\n\t\tfor obs in Display.observations:\n\t\t\tDisplay._remove(obs)\n\t\tfor obs in observations:\n\t\t\tDisplay.drawObservation(obs)\n\t\tDisplay.observations = observations\n", "description": null, "category": "graphics", "imports": ["from . import graphicsUtils", "from engine.model.car.car import Car", "from engine.const import Const", "from engine.model.observation import Observation", "from engine.vector import Vec2d", "import colorsys", "import threading"]}], [{"term": "class", "name": "classAnimationPlayer:", "data": "class AnimationPlayer:\n\tdef __init__(self):\n\t\tself.frames = {\n\t\t\t# magic\n\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\n\t\t\t'aura': import_folder('../graphics/particles/aura'),\n\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\n\t\t\t\n\t\t\t# attacks \n\t\t\t'claw': import_folder('../graphics/particles/claw'),\n\t\t\t'slash': import_folder('../graphics/particles/slash'),\n\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\n\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\n\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\n\n\t\t\t# monster deaths\n\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\n\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\n\t\t\t'spirit': import_folder('../graphics/particles/nova'),\n\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\n\t\t\t\n\t\t\t# leafs \n\t\t\t'leaf': (\n\t\t\t\timport_folder('../graphics/particles/leaf1'),\n\t\t\t\timport_folder('../graphics/particles/leaf2'),\n\t\t\t\timport_folder('../graphics/particles/leaf3'),\n\t\t\t\timport_folder('../graphics/particles/leaf4'),\n\t\t\t\timport_folder('../graphics/particles/leaf5'),\n\t\t\t\timport_folder('../graphics/particles/leaf6'),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\n\t\t\t\t)\n\t\t\t}\n\t\n\tdef reflect_images(self,frames):\n\t\tnew_frames = []\n\n\t\tfor frame in frames:\n\t \t\tflipped_frame = pygame.transform.flip(frame,True,False)\n\t \t\tnew_frames.append(flipped_frame)\n\t\treturn new_frames\n\n\tdef create_grass_particles(self,pos,groups):\n\t \tanimation_frames = choice(self.frames['leaf'])\n\t \tParticleEffect(pos,animation_frames,groups)\n\n\tdef create_particles(self,animation_type,pos,groups):\n\t\tanimation_frames = self.frames[animation_type]\n\t\tParticleEffect(pos,animation_frames,groups)\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\n\tdef __init__(self,pos,animation_frames,groups):\n\t\tsuper().__init__(groups)\n\t\tself.sprite_type = 'magic'\n\t\tself.frame_index = 0\n\t\tself.animation_speed = 0.15\n\t\tself.frames = animation_frames\n\t\tself.image = self.frames[self.frame_index]\n\t\tself.rect = self.image.get_rect(center = pos)\n\n\tdef animate(self):\n\t\tself.frame_index += self.animation_speed\n\t\tif self.frame_index >= len(self.frames):\n\t\t\tself.kill()\n\t\telse:\n\t\t\tself.image = self.frames[int(self.frame_index)]\n\n\tdef update(self):\n\t\tself.animate()\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}], [{"term": "def", "name": "render_image", "data": "def render_image(file, size):\n\timage = pygame.image.load(file)\n\timage = pygame.transform.scale(image, size)\n\treturn image\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from params import DISPLAY_SIZE, SELECTOR_SIZE"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tlives = NUM_LIVES\n\tgraphics.set_user_live(lives)\n\tgraphics.live_update()\n\t# Add animation loop here!\n\twhile True:\n\t\tpause(FRAME_RATE)\n\t\tif graphics.game_switch is True:\n\t\t\tgraphics.ball.move(graphics.get_ball_x(), graphics.get_ball_y())\n\t\t\tgraphics.obj_detect()\n\t\t\tif graphics.obj_action() is True:\n\t\t\t\tgraphics.score_count()\n\t\t\tif graphics.ball_action() is True:\n\t\t\t\tgraphics.live_count()\n\t\t\t\tif graphics.game_over() is True:\n\t\t\t\t\tbreak\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "class", "name": ",bar_chart,Axesclassusage", "data": "  arrow, bar_chart, Axes class usage (see axes.py)\n", "description": null, "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "_plot", "data": "def _plot(funcs, xrange, parametric=False,\n\t\t\t  polar=False, fill=False, label='', randomize=True, **options):\n\t\"\"\"\n\tInternal function which does the actual plotting.\n\n\tINPUT:\n\n\t- ``funcs`` - function or list of functions to be plotted\n\t- ``xrange`` - two or three tuple of [input variable], min and max\n\t- ``parametric`` - (default: False) a boolean for whether\n\t  this is a parametric plot\n\t- ``polar`` - (default: False) a boolean for whether\n\t  this is a polar plot\n\t- ``fill`` - (default: False) an input for whether\n\t  this plot is filled\n\t- ``randomize`` - (default: True) a boolean for whether\n\t  to use random plot points\n\n\tThe following option is deprecated in favor of ``legend_label``:\n\n\t- ``label`` - (default: '') a string for the label\n\n\tAll other usual plot options are also accepted, and a number\n\tare required (see the example below) which are normally passed\n\tthrough the options decorator to :func:`plot`.\n\n\tOUTPUT:\n\n\t- A ``Graphics`` object\n\n\tEXAMPLES::\n\n\tSee :func:`plot` for many, many implicit examples.\n\tHere is an explicit one::\n\n\t\tsage: from sage.plot.plot import _plot\n\t\tsage: P = _plot(e^(-x^2),(-3,3),fill=True,color='red',plot_points=50,adaptive_tolerance=2,adaptive_recursion=True,exclude=None)\n\t\tsage: P.show(aspect_ratio='automatic')\n\n\tTESTS:\n\n\tMake sure that we get the right number of legend entries as the number of\n\tfunctions varies (:trac:`10514`)::\n\n\t\tsage: p1 = plot(1*x, legend_label='1x')\n\t\tsage: p2 = plot(2*x, legend_label='2x', color='green')\n\t\tsage: p1+p2\n\t\tGraphics object consisting of 2 graphics primitives\n\n\t::\n\n\t\tsage: len(p1.matplotlib().axes[0].legend().texts)\n\t\t1\n\t\tsage: len((p1+p2).matplotlib().axes[0].legend().texts)\n\t\t2\n\t\tsage: q1 = plot([sin(x), tan(x)], legend_label='trig')\n\t\tsage: len((q1).matplotlib().axes[0].legend().texts) # used to raise AttributeError\n\t\t1\n\t\tsage: q1\n\t\tGraphics object consisting of 2 graphics primitives\n\n\t::\n\n\tMake sure that we don't get multiple legend labels for plot segments\n\t(:trac:`11998`)::\n\n\t\tsage: p1 = plot(1/(x^2-1),(x,-2,2),legend_label=\"foo\",detect_poles=True)\n\t\tsage: len(p1.matplotlib().axes[0].legend().texts)\n\t\t1\n\t\tsage: p1.show(ymin=-10,ymax=10) # should be one legend\n\n\tParametric plots that get evaluated at invalid points should still\n\tplot properly (:trac:`13246`)::\n\n\t\tsage: parametric_plot((x, arcsec(x)), (x, -2, 2))\n\t\tGraphics object consisting of 2 graphics primitives\n\n\t\"\"\"\n\n\tfrom sage.plot.misc import setup_for_eval_on_grid\n\tif funcs == []:\n\t\treturn Graphics()\n\texcluded_points = []\n\tfuncs, ranges = setup_for_eval_on_grid(funcs, [xrange], options['plot_points'])\n\txmin, xmax, delta = ranges[0]\n\txrange=ranges[0][:2]\n\t#parametric_plot will be a list or tuple of two functions (f,g)\n\t#and will plotted as (f(x), g(x)) for all x in the given range\n\tif parametric:\n\t\tf, g = funcs\n\t#or we have only a single function to be plotted:\n\telse:\n\t\tf = funcs\n\n\t#check to see if funcs is a list of functions that will\n\t#be all plotted together.\n\tif isinstance(funcs, (list, tuple)) and not parametric:\n\t\tfrom sage.plot.colors import rainbow\n\t\trainbow_colors = rainbow(len(funcs))\n\n\t\tG = Graphics()\n\t\tfor i, h in enumerate(funcs):\n\t\t\tif isinstance(fill, dict):\n\t\t\t\tif i in fill:\n\t\t\t\t\tfill_entry = fill[i]\n\t\t\t\t\tif isinstance(fill_entry, list):\n\t\t\t\t\t\tif fill_entry[0] < len(funcs):\n\t\t\t\t\t\t\tfill_temp = funcs[fill_entry[0]]\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tfill_temp = None\n\t\t\t\t\telse:\n\t\t\t\t\t\tfill_temp = fill_entry\n\t\t\t\telse:\n\t\t\t\t\tfill_temp = None\n\t\t\telse:\n\t\t\t\tfill_temp = fill\n\n\t\t\toptions_temp = options.copy()\n\t\t\tfillcolor_temp = options_temp.pop('fillcolor', 'automatic')\n\t\t\tif i >= 1:\n\t\t\t\tlegend_label=options_temp.pop('legend_label', None) # legend_label popped so the label isn't repeated for nothing\n\t\t\tif fillcolor_temp == 'automatic':\n\t\t\t\tfillcolor_temp = rainbow_colors[i]\n\n\t\t\tG += plot(h, xrange, polar = polar, fill = fill_temp, \\\n\t\t\t\t\t  fillcolor = fillcolor_temp, **options_temp)\n\t\treturn G\n\n\tadaptive_tolerance = options.pop('adaptive_tolerance')\n\tadaptive_recursion = options.pop('adaptive_recursion')\n\tplot_points = int(options.pop('plot_points'))\n\n\texclude = options.pop('exclude')\n\tif exclude is not None:\n\t\tfrom sage.symbolic.expression import Expression\n\t\tif isinstance(exclude, Expression) and exclude.is_relational() == True:\n\t\t\tif len(exclude.variables()) > 1:\n\t\t\t\traise ValueError('exclude has to be an equation of only one variable')\n\t\t\tv = exclude.variables()[0]\n\t\t\tpoints = [e.right() for e in exclude.solve(v) if e.left() == v and (v not in e.right().variables())]\n\t\t\t# We are only interested in real solutions\n\t\t\tfor x in points:\n\t\t\t\ttry:\n\t\t\t\t\texcluded_points.append(float(x))\n\t\t\t\texcept TypeError:\n\t\t\t\t\tpass\n\t\t\texcluded_points.sort()\n\n\t\t# We should either have a list in excluded points or exclude\n\t\t# itself must be a list\n\t\telif isinstance(exclude, (list, tuple)):\n\t\t\texcluded_points = sorted(exclude)\n\t\telse:\n\t\t\traise ValueError('exclude needs to be a list of numbers or an equation')\n\n\t\t# We make sure that points plot points close to the excluded points are computed\n\t\tepsilon = 0.001*(xmax - xmin)\n\t\tinitial_points = reduce(lambda a,b: a+b,\n\t\t\t\t\t\t\t\t[[x - epsilon, x + epsilon]\n\t\t\t\t\t\t\t\t for x in excluded_points], [])\n\t\tdata = generate_plot_points(f, xrange, plot_points,\n\t\t\t\t\t\t\t\t\tadaptive_tolerance, adaptive_recursion,\n\t\t\t\t\t\t\t\t\trandomize, initial_points)\n\telse:\n\t\tdata = generate_plot_points(f, xrange, plot_points,\n\t\t\t\t\t\t\t\t\tadaptive_tolerance, adaptive_recursion,\n\t\t\t\t\t\t\t\t\trandomize)\n\n\n\tfor i in range(len(data)-1):\n\t\t# If the difference between consecutive x-values is more than\n\t\t# 2 times the difference between two consecutive plot points, then\n\t\t# add an exclusion point.\n\t\tif abs(data[i+1][0] - data[i][0]) > 2*abs(xmax - xmin)/plot_points:\n\t\t\texcluded_points.append((data[i][0] + data[i+1][0])/2)\n\n\tif parametric:\n\t\t# We need the original x-values to be able to exclude points in parametric plots\n\t\texclude_data = data\n\t\tnewdata = []\n\t\tfor x,fdata in data:\n\t\t\ttry:\n\t\t\t\tnewdata.append((fdata, g(x)))\n\t\t\texcept (ValueError, TypeError):\n\t\t\t\tnewdata.append((fdata, 0)) # append a dummy value 0\n\t\t\t\texcluded_points.append(x)\n\t\tdata = newdata\n\n\texcluded_points.sort(reverse=True)\n\tG = Graphics()\n\n\tfillcolor = options.pop('fillcolor', 'automatic')\n\tfillalpha = options.pop('fillalpha', 0.5)\n\n\t# TODO: Use matplotlib's fill and fill_between commands.\n\tif fill is not False and fill is not None:\n\t\tif parametric:\n\t\t\tfilldata = data\n\t\telse:\n\t\t\tif fill == 'axis' or fill is True:\n\t\t\t\tbase_level = 0\n\t\t\telif fill == 'min':\n\t\t\t\tbase_level = min(t[1] for t in data)\n\t\t\telif fill == 'max':\n\t\t\t\tbase_level = max(t[1] for t in data)\n\t\t\telif hasattr(fill, '__call__'):\n\t\t\t\tif fill == max or fill == min:\n\t\t\t\t\tif fill == max:\n\t\t\t\t\t\tfstr = 'max'\n\t\t\t\t\telse:\n\t\t\t\t\t\tfstr = 'min'\n\t\t\t\t\tmsg = \"WARNING: You use the built-in function %s for filling. You probably wanted the string '%s'.\" % (fstr, fstr)\n\t\t\t\t\tsage.misc.misc.verbose(msg, level=0)\n\t\t\t\tif not is_fast_float(fill):\n\t\t\t\t\tfill_f = fast_float(fill, expect_one_var=True)\n\t\t\t\telse:\n\t\t\t\t\tfill_f = fill\n\n\t\t\t\tfilldata = generate_plot_points(fill_f, xrange, plot_points, adaptive_tolerance, \\\n\t\t\t\t\t\t\t\t\t\t\t\tadaptive_recursion, randomize)\n\t\t\t\tfilldata.reverse()\n\t\t\t\tfilldata += data\n\t\t\telse:\n\t\t\t\ttry:\n\t\t\t\t\tbase_level = float(fill)\n\t\t\t\texcept TypeError:\n\t\t\t\t\tbase_level = 0\n\n\t\t\tif not hasattr(fill, '__call__') and polar:\n\t\t\t\tfilldata = generate_plot_points(lambda x: base_level, xrange, plot_points, adaptive_tolerance, \\\n\t\t\t\t\t\t\t\t\t\t\t\tadaptive_recursion, randomize)\n\t\t\t\tfilldata.reverse()\n\t\t\t\tfilldata += data\n\t\t\tif not hasattr(fill, '__call__') and not polar:\n\t\t\t\tfilldata = [(data[0][0], base_level)] + data + [(data[-1][0], base_level)]\n\n\t\tif fillcolor == 'automatic':\n\t\t\tfillcolor = (0.5, 0.5, 0.5)\n\t\tfill_options = {}\n\t\tfill_options['rgbcolor'] = fillcolor\n\t\tfill_options['alpha'] = fillalpha\n\t\tfill_options['thickness'] = 0\n\t\tif polar:\n\t\t\tfilldata = [(y*cos(x), y*sin(x)) for x, y in filldata]\n\t\tG += polygon(filldata, **fill_options)\n\n\t# We need the original data to be able to exclude points in polar plots\n\tif not parametric:\n\t\texclude_data = data\n\tif polar:\n\t\tdata = [(y*cos(x), y*sin(x)) for x, y in data]\n\n\tfrom sage.plot.all import line, text\n\n\tdetect_poles = options.pop('detect_poles', False)\n\tlegend_label = options.pop('legend_label', None)\n\tif excluded_points or detect_poles != False:\n\t\tstart_index = 0\n\t\t# setup for pole detection\n\t\tfrom sage.rings.all import RDF\n\t\tepsilon = 0.0001\n\t\tpole_options = {}\n\t\tpole_options['linestyle'] = '--'\n\t\tpole_options['thickness'] = 1\n\t\tpole_options['rgbcolor'] = '#ccc'\n\n\t\t# setup for exclusion points\n\t\texclusion_point = 0\n\t\tif excluded_points:\n\t\t\texclusion_point = excluded_points.pop()\n\n\t\tflag = True\n\t\tfor i in range(len(data)-1):\n\t\t\tx0, y0 = exclude_data[i]\n\t\t\tx1, y1 = exclude_data[i+1]\n\n\t\t\t# detect poles\n\t\t\tif (not (polar or parametric)) and detect_poles != False \\\n\t\t\t   and ((y1 > 0 and y0 < 0) or (y1 < 0 and y0 > 0)):\n\t\t\t\t# calculate the slope of the line segment\n\t\t\t\tdy = abs(y1-y0)\n\t\t\t\tdx = x1 - x0\n\t\t\t\talpha = (RDF(dy)/RDF(dx)).arctan()\n\t\t\t\tif alpha >= RDF(pi/2) - epsilon:\n\t\t\t\t\tG += line(data[start_index:i], **options)\n\t\t\t\t\tif detect_poles == 'show':\n\t\t\t\t\t\t# draw a vertical asymptote\n\t\t\t\t\t\tG += line([(x0, y0), (x1, y1)], **pole_options)\n\t\t\t\t\tstart_index = i+2\n\n\t\t\t# exclude points\n\t\t\tif x0 > exclusion_point:\n\t\t\t\twhile exclusion_point <= x1:\n\t\t\t\t\ttry:\n\t\t\t\t\t\texclusion_point = excluded_points.pop()\n\t\t\t\t\texcept IndexError:\n\t\t\t\t\t\t# all excluded points were considered\n\t\t\t\t\t\tflag = False\n\t\t\t\t\t\tbreak\n\n\t\t\telif flag and (x0 <= exclusion_point <= x1):\n\t\t\t\tG += line(data[start_index:i], **options)\n\t\t\t\tstart_index = i + 2\n\t\t\t\twhile exclusion_point <= x1:\n\t\t\t\t\ttry:\n\t\t\t\t\t\texclusion_point = excluded_points.pop()\n\t\t\t\t\texcept IndexError:\n\t\t\t\t\t\t# all excluded points were considered\n\t\t\t\t\t\tflag = False\n\t\t\t\t\t\tbreak\n\n\t\tG += line(data[start_index:], legend_label=legend_label, **options)\n\telse:\n\t\tG += line(data, legend_label=legend_label, **options)\n\n\t# Label?\n\tif label:\n\t\tfrom sage.misc.superseded import deprecation\n\t\tdeprecation(4342, \"Consider using legend_label instead\")\n\t\tlabel = '  '+str(label)\n\t\tG += text(label, data[-1], horizontal_alignment='left',\n\t\t\t\t  vertical_alignment='center')\n\n\treturn G\n\n\n\n", "description": "\n\tInternal function which does the actual plotting.\n\n\tINPUT:\n\n\t- ``funcs`` - function or list of functions to be plotted\n\t- ``xrange`` - two or three tuple of [input variable], min and max\n\t- ``parametric`` - (default: False) a boolean for whether\n\t  this is a parametric plot\n\t- ``polar`` - (default: False) a boolean for whether\n\t  this is a polar plot\n\t- ``fill`` - (default: False) an input for whether\n\t  this plot is filled\n\t- ``randomize`` - (default: True) a boolean for whether\n\t  to use random plot points\n\n\tThe following option is deprecated in favor of ``legend_label``:\n\n\t- ``label`` - (default: '') a string for the label\n\n\tAll other usual plot options are also accepted, and a number\n\tare required (see the example below) which are normally passed\n\tthrough the options decorator to :func:`plot`.\n\n\tOUTPUT:\n\n\t- A ``Graphics`` object\n\n\tEXAMPLES::\n\n\tSee :func:`plot` for many, many implicit examples.\n\tHere is an explicit one::\n\n\t\tsage: from sage.plot.plot import _plot\n\t\tsage: P = _plot(e^(-x^2),(-3,3),fill=True,color='red',plot_points=50,adaptive_tolerance=2,adaptive_recursion=True,exclude=None)\n\t\tsage: P.show(aspect_ratio='automatic')\n\n\tTESTS:\n\n\tMake sure that we get the right number of legend entries as the number of\n\tfunctions varies (:trac:`10514`)::\n\n\t\tsage: p1 = plot(1*x, legend_label='1x')\n\t\tsage: p2 = plot(2*x, legend_label='2x', color='green')\n\t\tsage: p1+p2\n\t\tGraphics object consisting of 2 graphics primitives\n\n\t::\n\n\t\tsage: len(p1.matplotlib().axes[0].legend().texts)\n\t\t1\n\t\tsage: len((p1+p2).matplotlib().axes[0].legend().texts)\n\t\t2\n\t\tsage: q1 = plot([sin(x), tan(x)], legend_label='trig')\n\t\tsage: len((q1).matplotlib().axes[0].legend().texts) # used to raise AttributeError\n\t\t1\n\t\tsage: q1\n\t\tGraphics object consisting of 2 graphics primitives\n\n\t::\n\n\tMake sure that we don't get multiple legend labels for plot segments\n\t(:trac:`11998`)::\n\n\t\tsage: p1 = plot(1/(x^2-1),(x,-2,2),legend_label=\"foo\",detect_poles=True)\n\t\tsage: len(p1.matplotlib().axes[0].legend().texts)\n\t\t1\n\t\tsage: p1.show(ymin=-10,ymax=10) # should be one legend\n\n\tParametric plots that get evaluated at invalid points should still\n\tplot properly (:trac:`13246`)::\n\n\t\tsage: parametric_plot((x, arcsec(x)), (x, -2, 2))\n\t\tGraphics object consisting of 2 graphics primitives\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "parametric_plot", "data": "def parametric_plot(funcs, *args, **kwargs):\n\tr\"\"\"\n\tPlot a parametric curve or surface in 2d or 3d.\n\n\t:func:`parametric_plot` takes two or three functions as a\n\tlist or a tuple and makes a plot with the first function giving the\n\t`x` coordinates, the second function giving the `y`\n\tcoordinates, and the third function (if present) giving the\n\t`z` coordinates.\n\n\tIn the 2d case, :func:`parametric_plot` is equivalent to the :func:`plot` command\n\twith the option ``parametric=True``.  In the 3d case, :func:`parametric_plot`\n\tis equivalent to :func:`~sage.plot.plot3d.parametric_plot3d.parametric_plot3d`.\n\tSee each of these functions for more help and examples.\n\n\tINPUT:\n\n\n\t-  ``funcs`` - 2 or 3-tuple of functions, or a vector of dimension 2 or 3.\n\n\t-  ``other options`` - passed to :func:`plot` or :func:`~sage.plot.plot3d.parametric_plot3d.parametric_plot3d`\n\n\n\tEXAMPLES: We draw some 2d parametric plots.  Note that the default aspect ratio\n\tis 1, so that circles look like circles. ::\n\n\t\tsage: t = var('t')\n\t\tsage: parametric_plot( (cos(t), sin(t)), (t, 0, 2*pi))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: parametric_plot( (sin(t), sin(2*t)), (t, 0, 2*pi), color=hue(0.6) )\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: parametric_plot((1, t), (t, 0, 4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tNote that in parametric_plot, there is only fill or no fill.\n\n\t::\n\n\t\tsage: parametric_plot((t, t^2), (t, -4, 4), fill = True)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tA filled Hypotrochoid::\n\n\t\tsage: parametric_plot([cos(x) + 2 * cos(x/4), sin(x) - 2 * sin(x/4)], (x,0, 8*pi), fill = True)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\t\tsage: parametric_plot( (5*cos(x), 5*sin(x), x), (x,-12, 12), plot_points=150, color=\"red\") # long time\n\t\tGraphics3d Object\n\n\t\tsage: y=var('y')\n\t\tsage: parametric_plot( (5*cos(x), x*y, cos(x*y)), (x, -4,4), (y,-4,4)) # long time`\n\t\tGraphics3d Object\n\n\t\tsage: t=var('t')\n\t\tsage: parametric_plot( vector((sin(t), sin(2*t))), (t, 0, 2*pi), color='green') # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: parametric_plot( vector([t, t+1, t^2]), (t, 0, 1)) # long time\n\t\tGraphics3d Object\n\n\tPlotting in logarithmic scale is possible with 2D plots. The keyword\n\t``aspect_ratio`` will be ignored if the scale is not ``'loglog'`` or\n\t``'linear'``.::\n\n\t\tsage: parametric_plot((x, x**2), (x, 1, 10), scale='loglog')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can also change the scale of the axes in the graphics just before\n\tdisplaying. In this case, the ``aspect_ratio`` must be specified as\n\t``'automatic'`` if the ``scale`` is set to ``'semilogx'`` or ``'semilogy'``. For\n\tother values of the ``scale`` parameter, any ``aspect_ratio`` can be\n\tused, or the keyword need not be provided.::\n\n\t\tsage: p = parametric_plot((x, x**2), (x, 1, 10))\n\t\tsage: p.show(scale='semilogy', aspect_ratio='automatic')\n\n\tTESTS::\n\n\t\tsage: parametric_plot((x, t^2), (x, -4, 4))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\n\t\tsage: parametric_plot((1, x+t), (x, -4, 4))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\n\t\tsage: parametric_plot((-t, x+t), (x, -4, 4))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\n\t\tsage: parametric_plot((1, x+t, y), (x, -4, 4), (t, -4, 4))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\n\t\tsage: parametric_plot((1, x, y), 0, 4)\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\t\"\"\"\n\tnum_ranges=0\n\tfor i in args:\n\t\tif isinstance(i, (list, tuple)):\n\t\t\tnum_ranges+=1\n\t\telse:\n\t\t\tbreak\n\n\tif num_ranges==0 and len(args)>=2:\n\t\tfrom sage.misc.superseded import deprecation\n\t\tdeprecation(7008, \"variable ranges to parametric_plot must be given as tuples, like (2,4) or (t,2,3)\")\n\t\targs=tuple(args)\n\t\tnum_ranges=1\n\n\tnum_funcs = len(funcs)\n\n\tnum_vars=len(sage.plot.misc.unify_arguments(funcs)[0])\n\tif num_vars>num_ranges:\n\t\traise ValueError(\"there are more variables than variable ranges\")\n\n\t# Reset aspect_ratio to 'automatic' in case scale is 'semilog[xy]'.\n\t# Otherwise matplotlib complains.\n\tscale = kwargs.get('scale', None)\n\tif isinstance(scale, (list, tuple)):\n\t\tscale = scale[0]\n\tif scale == 'semilogy' or scale == 'semilogx':\n\t\tkwargs['aspect_ratio'] = 'automatic'\n\n\tif num_funcs == 2 and num_ranges == 1:\n\t\tkwargs['parametric'] = True\n\t\treturn plot(funcs, *args, **kwargs)\n\telif (num_funcs == 3 and num_ranges <= 2):\n\t\treturn sage.plot.plot3d.parametric_plot3d.parametric_plot3d(funcs, *args, **kwargs)\n\telse:\n\t\traise ValueError(\"the number of functions and the number of variable ranges is not a supported combination for a 2d or 3d parametric plots\")\n", "description": "\n\tPlot a parametric curve or surface in 2d or 3d.\n\n\t:func:`parametric_plot` takes two or three functions as a\n\tlist or a tuple and makes a plot with the first function giving the\n\t`x` coordinates, the second function giving the `y`\n\tcoordinates, and the third function (if present) giving the\n\t`z` coordinates.\n\n\tIn the 2d case, :func:`parametric_plot` is equivalent to the :func:`plot` command\n\twith the option ``parametric=True``.  In the 3d case, :func:`parametric_plot`\n\tis equivalent to :func:`~sage.plot.plot3d.parametric_plot3d.parametric_plot3d`.\n\tSee each of these functions for more help and examples.\n\n\tINPUT:\n\n\n\t-  ``funcs`` - 2 or 3-tuple of functions, or a vector of dimension 2 or 3.\n\n\t-  ``other options`` - passed to :func:`plot` or :func:`~sage.plot.plot3d.parametric_plot3d.parametric_plot3d`\n\n\n\tEXAMPLES: We draw some 2d parametric plots.  Note that the default aspect ratio\n\tis 1, so that circles look like circles. ::\n\n\t\tsage: t = var('t')\n\t\tsage: parametric_plot( (cos(t), sin(t)), (t, 0, 2*pi))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: parametric_plot( (sin(t), sin(2*t)), (t, 0, 2*pi), color=hue(0.6) )\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: parametric_plot((1, t), (t, 0, 4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tNote that in parametric_plot, there is only fill or no fill.\n\n\t::\n\n\t\tsage: parametric_plot((t, t^2), (t, -4, 4), fill = True)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tA filled Hypotrochoid::\n\n\t\tsage: parametric_plot([cos(x) + 2 * cos(x/4), sin(x) - 2 * sin(x/4)], (x,0, 8*pi), fill = True)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\t\tsage: parametric_plot( (5*cos(x), 5*sin(x), x), (x,-12, 12), plot_points=150, color=\"red\") # long time\n\t\tGraphics3d Object\n\n\t\tsage: y=var('y')\n\t\tsage: parametric_plot( (5*cos(x), x*y, cos(x*y)), (x, -4,4), (y,-4,4)) # long time`\n\t\tGraphics3d Object\n\n\t\tsage: t=var('t')\n\t\tsage: parametric_plot( vector((sin(t), sin(2*t))), (t, 0, 2*pi), color='green') # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: parametric_plot( vector([t, t+1, t^2]), (t, 0, 1)) # long time\n\t\tGraphics3d Object\n\n\tPlotting in logarithmic scale is possible with 2D plots. The keyword\n\t``aspect_ratio`` will be ignored if the scale is not ``'loglog'`` or\n\t``'linear'``.::\n\n\t\tsage: parametric_plot((x, x**2), (x, 1, 10), scale='loglog')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can also change the scale of the axes in the graphics just before\n\tdisplaying. In this case, the ``aspect_ratio`` must be specified as\n\t``'automatic'`` if the ``scale`` is set to ``'semilogx'`` or ``'semilogy'``. For\n\tother values of the ``scale`` parameter, any ``aspect_ratio`` can be\n\tused, or the keyword need not be provided.::\n\n\t\tsage: p = parametric_plot((x, x**2), (x, 1, 10))\n\t\tsage: p.show(scale='semilogy', aspect_ratio='automatic')\n\n\tTESTS::\n\n\t\tsage: parametric_plot((x, t^2), (x, -4, 4))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\n\t\tsage: parametric_plot((1, x+t), (x, -4, 4))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\n\t\tsage: parametric_plot((-t, x+t), (x, -4, 4))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\n\t\tsage: parametric_plot((1, x+t, y), (x, -4, 4), (t, -4, 4))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\n\t\tsage: parametric_plot((1, x, y), 0, 4)\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "polar_plot", "data": "def polar_plot(funcs, *args, **kwds):\n\tr\"\"\"\n\t``polar_plot`` takes a single function or a list or\n\ttuple of functions and plots them with polar coordinates in the given\n\tdomain.\n\n\tThis function is equivalent to the :func:`plot` command with the options\n\t``polar=True`` and ``aspect_ratio=1``. For more help on options,\n\tsee the documentation for :func:`plot`.\n\n\tINPUT:\n\n\t- ``funcs`` - a function\n\t- other options are passed to plot\n\n\tEXAMPLES:\n\n\tHere is a blue 8-leaved petal::\n\n\t\tsage: polar_plot(sin(5*x)^2, (x, 0, 2*pi), color='blue')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA red figure-8::\n\n\t\tsage: polar_plot(abs(sqrt(1 - sin(x)^2)), (x, 0, 2*pi), color='red')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA green limacon of Pascal::\n\n\t\tsage: polar_plot(2 + 2*cos(x), (x, 0, 2*pi), color=hue(0.3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tSeveral polar plots::\n\n\t\tsage: polar_plot([2*sin(x), 2*cos(x)], (x, 0, 2*pi))\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tA filled spiral::\n\n\t\tsage: polar_plot(sqrt, 0, 2 * pi, fill = True)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tFill the area between two functions::\n\n\t\tsage: polar_plot(cos(4*x) + 1.5, 0, 2*pi, fill=0.5 * cos(4*x) + 2.5, fillcolor='orange')\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tFill the area between several spirals::\n\n\t\tsage: polar_plot([(1.2+k*0.2)*log(x) for k in range(6)], 1, 3 * pi, fill = {0: [1], 2: [3], 4: [5]})\n\t\tGraphics object consisting of 9 graphics primitives\n\n\tExclude points at discontinuities::\n\n\t\tsage: polar_plot(log(floor(x)), (x, 1, 4*pi), exclude = [1..12])\n\t\tGraphics object consisting of 12 graphics primitives\n\n\t\"\"\"\n\tkwds['polar']=True\n\treturn plot(funcs, *args, **kwds)\n", "description": "\n\t``polar_plot`` takes a single function or a list or\n\ttuple of functions and plots them with polar coordinates in the given\n\tdomain.\n\n\tThis function is equivalent to the :func:`plot` command with the options\n\t``polar=True`` and ``aspect_ratio=1``. For more help on options,\n\tsee the documentation for :func:`plot`.\n\n\tINPUT:\n\n\t- ``funcs`` - a function\n\t- other options are passed to plot\n\n\tEXAMPLES:\n\n\tHere is a blue 8-leaved petal::\n\n\t\tsage: polar_plot(sin(5*x)^2, (x, 0, 2*pi), color='blue')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA red figure-8::\n\n\t\tsage: polar_plot(abs(sqrt(1 - sin(x)^2)), (x, 0, 2*pi), color='red')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA green limacon of Pascal::\n\n\t\tsage: polar_plot(2 + 2*cos(x), (x, 0, 2*pi), color=hue(0.3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tSeveral polar plots::\n\n\t\tsage: polar_plot([2*sin(x), 2*cos(x)], (x, 0, 2*pi))\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tA filled spiral::\n\n\t\tsage: polar_plot(sqrt, 0, 2 * pi, fill = True)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tFill the area between two functions::\n\n\t\tsage: polar_plot(cos(4*x) + 1.5, 0, 2*pi, fill=0.5 * cos(4*x) + 2.5, fillcolor='orange')\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tFill the area between several spirals::\n\n\t\tsage: polar_plot([(1.2+k*0.2)*log(x) for k in range(6)], 1, 3 * pi, fill = {0: [1], 2: [3], 4: [5]})\n\t\tGraphics object consisting of 9 graphics primitives\n\n\tExclude points at discontinuities::\n\n\t\tsage: polar_plot(log(floor(x)), (x, 1, 4*pi), exclude = [1..12])\n\t\tGraphics object consisting of 12 graphics primitives\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "list_plot", "data": "def list_plot(data, plotjoined=False, **kwargs):\n\tr\"\"\"\n\t``list_plot`` takes either a list of numbers, a list of tuples, a numpy\n\tarray, or a dictionary and plots the corresponding points.\n\n\tIf given a list of numbers (that is, not a list of tuples or lists),\n\t``list_plot`` forms a list of tuples ``(i, x_i)`` where ``i`` goes from\n\t0 to ``len(data)-1`` and ``x_i`` is the ``i``-th data value, and puts\n\tpoints at those tuple values.\n\n\t``list_plot`` will plot a list of complex numbers in the obvious\n\tway; any numbers for which\n\t:func:`CC()` makes sense will\n\twork.\n\n\t``list_plot`` also takes a list of tuples ``(x_i, y_i)`` where ``x_i``\n\tand ``y_i`` are the ``i``-th values representing the ``x``- and\n\t``y``-values, respectively.\n\n\tIf given a dictionary, ``list_plot`` interprets the keys as\n\t`x`-values and the values as `y`-values.\n\n\tThe ``plotjoined=True`` option tells ``list_plot`` to plot a line\n\tjoining all the data.\n\n\tIt is possible to pass empty dictionaries, lists, or tuples to\n\t``list_plot``. Doing so will plot nothing (returning an empty plot).\n\n\tEXAMPLES::\n\n\t\tsage: list_plot([i^2 for i in range(5)]) # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere are a bunch of random red points::\n\n\t\tsage: r = [(random(),random()) for _ in range(20)]\n\t\tsage: list_plot(r,color='red')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tThis gives all the random points joined in a purple line::\n\n\t\tsage: list_plot(r, plotjoined=True, color='purple')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tYou can provide a numpy array.::\n\n\t\tsage: import numpy\n\t\tsage: list_plot(numpy.arange(10))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: list_plot(numpy.array([[1,2], [2,3], [3,4]]))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tPlot a list of complex numbers::\n\n\t\tsage: list_plot([1, I, pi + I/2, CC(.25, .25)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: list_plot([exp(I*theta) for theta in [0, .2..pi]])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tNote that if your list of complex numbers are all actually real,\n\tthey get plotted as real values, so this\n\n\t::\n\n\t\tsage: list_plot([CDF(1), CDF(1/2), CDF(1/3)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tis the same as ``list_plot([1, 1/2, 1/3])`` -- it produces a plot of\n\tthe points `(0,1)`, `(1,1/2)`, and `(2,1/3)`.\n\n\tIf you have separate lists of `x` values and `y` values which you\n\twant to plot against each other, use the ``zip`` command to make a\n\tsingle list whose entries are pairs of `(x,y)` values, and feed\n\tthe result into ``list_plot``::\n\n\t\tsage: x_coords = [cos(t)^3 for t in srange(0, 2*pi, 0.02)]\n\t\tsage: y_coords = [sin(t)^3 for t in srange(0, 2*pi, 0.02)]\n\t\tsage: list_plot(zip(x_coords, y_coords))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tIf instead you try to pass the two lists as separate arguments,\n\tyou will get an error message::\n\n\t\tsage: list_plot(x_coords, y_coords)\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tTypeError: The second argument 'plotjoined' should be boolean (True or False).  If you meant to plot two lists 'x' and 'y' against each other, use 'list_plot(zip(x,y))'.\n\n\tDictionaries with numeric keys and values can be plotted::\n\n\t\tsage: list_plot({22: 3365, 27: 3295, 37: 3135, 42: 3020, 47: 2880, 52: 2735, 57: 2550})\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tPlotting in logarithmic scale is possible for 2D list plots.\n\tThere are two different syntaxes available::\n\n\t\tsage: yl = [2**k for k in range(20)]\n\t\tsage: list_plot(yl, scale='semilogy')  # long time  # log axis on vertical\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: list_plot_semilogy(yl)\t   # same\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t.. warning::\n\n\t\tIf ``plotjoined`` is ``False`` then the axis that is in log scale\n\t\tmust have all points strictly positive. For instance, the following\n\t\tplot will show no points in the figure since the points in the\n\t\thorizontal axis starts from `(0,1)`.\n\n\t\t::\n\n\t\t\tsage: list_plot(yl, scale='loglog')\t\t # both axes are log\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tInstead this will work. We drop the point `(0,1)`.::\n\n\t\t\tsage: list_plot(zip(range(1,len(yl)), yl[1:]), scale='loglog') # long time \n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe use :func:`list_plot_loglog` and plot in a different base.::\n\n\t\tsage: list_plot_loglog(zip(range(1,len(yl)), yl[1:]), base=2) # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can also change the scale of the axes in the graphics just before\n\tdisplaying::\n\n\t\tsage: G = list_plot(yl) # long time\n\t\tsage: G.show(scale=('semilogy', 2)) # long time\n\n\tTESTS:\n\n\tWe check to see whether elements of the Symbolic Ring are properly\n\thandled; see :trac:`16378` ::\n\n\t\tsage: list_plot([1+I, 2+I])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: list_plot([1+I, 2, CC(3+I)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: list_plot([2, SR(1), CC(1+i)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe check to see that the x/y min/max data are set correctly::\n\n\t\tsage: d = list_plot([(100,100), (120, 120)]).get_minmax_data()\n\t\tsage: d['xmin']\n\t\t100.0\n\t\tsage: d['ymin']\n\t\t100.0\n\t\"\"\"\n\tfrom sage.plot.all import line, point\n\ttry:\n\t\tif not data:\n\t\t\treturn Graphics()\n\texcept ValueError: # numpy raises ValueError if it is not empty\n\t\tpass\n\tif not isinstance(plotjoined, bool):\n\t\traise TypeError(\"The second argument 'plotjoined' should be boolean \"\n\t\t\t\t\t\"(True or False).  If you meant to plot two lists 'x' \"\n\t\t\t\t\t\"and 'y' against each other, use 'list_plot(zip(x,y))'.\")\n\tif isinstance(data, dict):\n\t\tif plotjoined:\n\t\t\tlist_data = sorted(list(data.iteritems()))\n\t\telse:\n\t\t\tlist_data = list(data.iteritems())\n\t\treturn list_plot(list_data, plotjoined=plotjoined, **kwargs)\n\ttry:\n\t\tfrom sage.rings.all import RDF\n\t\ttmp = RDF(data[0])\n\t\tdata = list(enumerate(data))\n\texcept TypeError: # we can get this TypeError if the element is a list\n\t\t\t\t\t  # or tuple or numpy array, or an element of CC, CDF\n\t\t# We also want to avoid doing CC(data[0]) here since it will go\n\t\t# through if data[0] is really a tuple and every element of the\n\t\t# data will be converted to a complex and later converted back to\n\t\t# a tuple.\n\t\t# So, the only other check we need to do is whether data[0] is an\n\t\t# element of the Symbolic Ring.\n\t\tif data[0] in sage.symbolic.ring.SR:\n\t\t\tdata = list(enumerate(data))\n\n\ttry:\n\t\tif plotjoined:\n\t\t\treturn line(data, **kwargs)\n\t\telse:\n\t\t\treturn point(data, **kwargs)\n\texcept (TypeError, IndexError):\n\t\t# Assume we have complex-valued input and plot real and imaginary parts.\n\t\t# Need to catch IndexError because if data is, say, [(0, 1), (1, I)],\n\t\t# point3d() throws an IndexError on the (0,1) before it ever\n\t\t# gets to (1, I).\n\t\tfrom sage.rings.complex_field import ComplexField\n\t\tCC = ComplexField()\n\t\t# if we get here, we already did \"list(enumerate(data))\",\n\t\t# so look at z[1] in inner list\n\t\tdata = [(z.real(), z.imag()) for z in [CC(z[1]) for z in data]]\n\t\tif plotjoined:\n\t\t\treturn line(data, **kwargs)\n\t\telse:\n\t\t\treturn point(data, **kwargs)\n", "description": "\n\t``list_plot`` takes either a list of numbers, a list of tuples, a numpy\n\tarray, or a dictionary and plots the corresponding points.\n\n\tIf given a list of numbers (that is, not a list of tuples or lists),\n\t``list_plot`` forms a list of tuples ``(i, x_i)`` where ``i`` goes from\n\t0 to ``len(data)-1`` and ``x_i`` is the ``i``-th data value, and puts\n\tpoints at those tuple values.\n\n\t``list_plot`` will plot a list of complex numbers in the obvious\n\tway; any numbers for which\n\t:func:`CC()` makes sense will\n\twork.\n\n\t``list_plot`` also takes a list of tuples ``(x_i, y_i)`` where ``x_i``\n\tand ``y_i`` are the ``i``-th values representing the ``x``- and\n\t``y``-values, respectively.\n\n\tIf given a dictionary, ``list_plot`` interprets the keys as\n\t`x`-values and the values as `y`-values.\n\n\tThe ``plotjoined=True`` option tells ``list_plot`` to plot a line\n\tjoining all the data.\n\n\tIt is possible to pass empty dictionaries, lists, or tuples to\n\t``list_plot``. Doing so will plot nothing (returning an empty plot).\n\n\tEXAMPLES::\n\n\t\tsage: list_plot([i^2 for i in range(5)]) # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere are a bunch of random red points::\n\n\t\tsage: r = [(random(),random()) for _ in range(20)]\n\t\tsage: list_plot(r,color='red')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tThis gives all the random points joined in a purple line::\n\n\t\tsage: list_plot(r, plotjoined=True, color='purple')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tYou can provide a numpy array.::\n\n\t\tsage: import numpy\n\t\tsage: list_plot(numpy.arange(10))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: list_plot(numpy.array([[1,2], [2,3], [3,4]]))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tPlot a list of complex numbers::\n\n\t\tsage: list_plot([1, I, pi + I/2, CC(.25, .25)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: list_plot([exp(I*theta) for theta in [0, .2..pi]])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tNote that if your list of complex numbers are all actually real,\n\tthey get plotted as real values, so this\n\n\t::\n\n\t\tsage: list_plot([CDF(1), CDF(1/2), CDF(1/3)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tis the same as ``list_plot([1, 1/2, 1/3])`` -- it produces a plot of\n\tthe points `(0,1)`, `(1,1/2)`, and `(2,1/3)`.\n\n\tIf you have separate lists of `x` values and `y` values which you\n\twant to plot against each other, use the ``zip`` command to make a\n\tsingle list whose entries are pairs of `(x,y)` values, and feed\n\tthe result into ``list_plot``::\n\n\t\tsage: x_coords = [cos(t)^3 for t in srange(0, 2*pi, 0.02)]\n\t\tsage: y_coords = [sin(t)^3 for t in srange(0, 2*pi, 0.02)]\n\t\tsage: list_plot(zip(x_coords, y_coords))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tIf instead you try to pass the two lists as separate arguments,\n\tyou will get an error message::\n\n\t\tsage: list_plot(x_coords, y_coords)\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tTypeError: The second argument 'plotjoined' should be boolean (True or False).  If you meant to plot two lists 'x' and 'y' against each other, use 'list_plot(zip(x,y))'.\n\n\tDictionaries with numeric keys and values can be plotted::\n\n\t\tsage: list_plot({22: 3365, 27: 3295, 37: 3135, 42: 3020, 47: 2880, 52: 2735, 57: 2550})\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tPlotting in logarithmic scale is possible for 2D list plots.\n\tThere are two different syntaxes available::\n\n\t\tsage: yl = [2**k for k in range(20)]\n\t\tsage: list_plot(yl, scale='semilogy')  # long time  # log axis on vertical\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: list_plot_semilogy(yl)\t   # same\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t.. warning::\n\n\t\tIf ``plotjoined`` is ``False`` then the axis that is in log scale\n\t\tmust have all points strictly positive. For instance, the following\n\t\tplot will show no points in the figure since the points in the\n\t\thorizontal axis starts from `(0,1)`.\n\n\t\t::\n\n\t\t\tsage: list_plot(yl, scale='loglog')\t\t # both axes are log\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tInstead this will work. We drop the point `(0,1)`.::\n\n\t\t\tsage: list_plot(zip(range(1,len(yl)), yl[1:]), scale='loglog') # long time \n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe use :func:`list_plot_loglog` and plot in a different base.::\n\n\t\tsage: list_plot_loglog(zip(range(1,len(yl)), yl[1:]), base=2) # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can also change the scale of the axes in the graphics just before\n\tdisplaying::\n\n\t\tsage: G = list_plot(yl) # long time\n\t\tsage: G.show(scale=('semilogy', 2)) # long time\n\n\tTESTS:\n\n\tWe check to see whether elements of the Symbolic Ring are properly\n\thandled; see :trac:`16378` ::\n\n\t\tsage: list_plot([1+I, 2+I])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: list_plot([1+I, 2, CC(3+I)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: list_plot([2, SR(1), CC(1+i)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe check to see that the x/y min/max data are set correctly::\n\n\t\tsage: d = list_plot([(100,100), (120, 120)]).get_minmax_data()\n\t\tsage: d['xmin']\n\t\t100.0\n\t\tsage: d['ymin']\n\t\t100.0\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "plot_loglog", "data": "def plot_loglog(funcs, *args, **kwds):\n\t\"\"\"\n\tPlot graphics in 'loglog' scale, that is, both the horizontal and the\n\tvertical axes will be in logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1. The base can be also given as a list or tuple\n\t  ``(basex, basey)``.  ``basex`` sets the base of the logarithm along the\n\t  horizontal axis and ``basey`` sets the base along the vertical axis.\n\n\t- ``funcs`` -- any Sage object which is acceptable to the :func:`plot`.\n\n\tFor all other inputs, look at the documentation of :func:`plot`.\n\n\tEXAMPLES::\n\n\t\tsage: plot_loglog(exp, (1,10)) # plot in loglog scale with base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: plot_loglog(exp, (1,10), base=2.1) # long time # with base 2.1 on both axes\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: plot_loglog(exp, (1,10), base=(2,3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\"\"\"\n\treturn plot(funcs, *args, scale='loglog', **kwds)\n", "description": "\n\tPlot graphics in 'loglog' scale, that is, both the horizontal and the\n\tvertical axes will be in logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1. The base can be also given as a list or tuple\n\t  ``(basex, basey)``.  ``basex`` sets the base of the logarithm along the\n\t  horizontal axis and ``basey`` sets the base along the vertical axis.\n\n\t- ``funcs`` -- any Sage object which is acceptable to the :func:`plot`.\n\n\tFor all other inputs, look at the documentation of :func:`plot`.\n\n\tEXAMPLES::\n\n\t\tsage: plot_loglog(exp, (1,10)) # plot in loglog scale with base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: plot_loglog(exp, (1,10), base=2.1) # long time # with base 2.1 on both axes\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: plot_loglog(exp, (1,10), base=(2,3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "plot_semilogx", "data": "def plot_semilogx(funcs, *args, **kwds):\n\t\"\"\"\n\tPlot graphics in 'semilogx' scale, that is, the horizontal axis will be\n\tin logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1.\n\n\t- ``funcs`` -- any Sage object which is acceptable to the :func:`plot`.\n\n\tFor all other inputs, look at the documentation of :func:`plot`.\n\n\tEXAMPLES::\n\n\t\tsage: plot_semilogx(exp, (1,10)) # long time # plot in semilogx scale, base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: plot_semilogx(exp, (1,10), base=2) # with base 2\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\"\"\"\n\treturn plot(funcs, *args, scale='semilogx', **kwds)\n", "description": "\n\tPlot graphics in 'semilogx' scale, that is, the horizontal axis will be\n\tin logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1.\n\n\t- ``funcs`` -- any Sage object which is acceptable to the :func:`plot`.\n\n\tFor all other inputs, look at the documentation of :func:`plot`.\n\n\tEXAMPLES::\n\n\t\tsage: plot_semilogx(exp, (1,10)) # long time # plot in semilogx scale, base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: plot_semilogx(exp, (1,10), base=2) # with base 2\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "plot_semilogy", "data": "def plot_semilogy(funcs, *args, **kwds):\n\t\"\"\"\n\tPlot graphics in 'semilogy' scale, that is, the vertical axis will be\n\tin logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1.\n\n\t- ``funcs`` -- any Sage object which is acceptable to the :func:`plot`.\n\n\tFor all other inputs, look at the documentation of :func:`plot`.\n\n\tEXAMPLES::\n\n\t\tsage: plot_semilogy(exp, (1,10)) # long time # plot in semilogy scale, base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: plot_semilogy(exp, (1,10), base=2) # long time # with base 2\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\"\"\"\n\treturn plot(funcs, *args, scale='semilogy', **kwds)\n", "description": "\n\tPlot graphics in 'semilogy' scale, that is, the vertical axis will be\n\tin logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1.\n\n\t- ``funcs`` -- any Sage object which is acceptable to the :func:`plot`.\n\n\tFor all other inputs, look at the documentation of :func:`plot`.\n\n\tEXAMPLES::\n\n\t\tsage: plot_semilogy(exp, (1,10)) # long time # plot in semilogy scale, base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: plot_semilogy(exp, (1,10), base=2) # long time # with base 2\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "list_plot_loglog", "data": "def list_plot_loglog(data, plotjoined=False, **kwds):\n\t\"\"\"\n\tPlot the ``data`` in 'loglog' scale, that is, both the horizontal and the\n\tvertical axes will be in logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1. The base can be also given as a list or tuple\n\t  ``(basex, basey)``.  ``basex`` sets the base of the logarithm along the\n\t  horizontal axis and ``basey`` sets the base along the vertical axis.\n\n\tFor all other inputs, look at the documentation of :func:`list_plot`.\n\n\n\tEXAMPLES::\n\n\t\tsage: yl = [5**k for k in range(10)]; xl = [2**k for k in range(10)]\n\t\tsage: list_plot_loglog(zip(xl, yl)) # long time # plot in loglog scale with base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: list_plot_loglog(zip(xl, yl), base=2.1) # long time # with base 2.1 on both axes\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: list_plot_loglog(zip(xl, yl), base=(2,5)) # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t.. warning::\n\n\t\tIf ``plotjoined`` is ``False`` then the axis that is in log scale\n\t\tmust have all points strictly positive. For instance, the following\n\t\tplot will show no points in the figure since the points in the\n\t\thorizontal axis starts from `(0,1)`.\n\n\t\t::\n\n\t\t\tsage: yl = [2**k for k in range(20)]\n\t\t\tsage: list_plot_loglog(yl)\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tInstead this will work. We drop the point `(0,1)`.::\n\n\t\t\tsage: list_plot_loglog(zip(range(1,len(yl)), yl[1:]))\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\"\"\"\n\treturn list_plot(data, plotjoined=plotjoined, scale='loglog', **kwds)\n", "description": "\n\tPlot the ``data`` in 'loglog' scale, that is, both the horizontal and the\n\tvertical axes will be in logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1. The base can be also given as a list or tuple\n\t  ``(basex, basey)``.  ``basex`` sets the base of the logarithm along the\n\t  horizontal axis and ``basey`` sets the base along the vertical axis.\n\n\tFor all other inputs, look at the documentation of :func:`list_plot`.\n\n\n\tEXAMPLES::\n\n\t\tsage: yl = [5**k for k in range(10)]; xl = [2**k for k in range(10)]\n\t\tsage: list_plot_loglog(zip(xl, yl)) # long time # plot in loglog scale with base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: list_plot_loglog(zip(xl, yl), base=2.1) # long time # with base 2.1 on both axes\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: list_plot_loglog(zip(xl, yl), base=(2,5)) # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t.. warning::\n\n\t\tIf ``plotjoined`` is ``False`` then the axis that is in log scale\n\t\tmust have all points strictly positive. For instance, the following\n\t\tplot will show no points in the figure since the points in the\n\t\thorizontal axis starts from `(0,1)`.\n\n\t\t::\n\n\t\t\tsage: yl = [2**k for k in range(20)]\n\t\t\tsage: list_plot_loglog(yl)\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tInstead this will work. We drop the point `(0,1)`.::\n\n\t\t\tsage: list_plot_loglog(zip(range(1,len(yl)), yl[1:]))\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "list_plot_semilogx", "data": "def list_plot_semilogx(data, plotjoined=False, **kwds):\n\t\"\"\"\n\tPlot ``data`` in 'semilogx' scale, that is, the horizontal axis will be\n\tin logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1.\n\n\tFor all other inputs, look at the documentation of :func:`list_plot`.\n\n\tEXAMPLES::\n\n\t\tsage: yl = [2**k for k in range(12)]\n\t\tsage: list_plot_semilogx(zip(yl,yl))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t.. warning::\n\n\t\tIf ``plotjoined`` is ``False`` then the horizontal axis must have all\n\t\tpoints strictly positive. Otherwise the plot will come up empty.\n\t\tFor instance the following plot contains a point at `(0,1)`.\n\n\t\t::\n\n\t\t\tsage: yl = [2**k for k in range(12)]\n\t\t\tsage: list_plot_semilogx(yl) # plot is empty because of `(0,1)`\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tWe remove `(0,1)` to fix this.::\n\n\t\t\tsage: list_plot_semilogx(zip(range(1, len(yl)), yl[1:]))\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: list_plot_semilogx([(1,2),(3,4),(3,-1),(25,3)], base=2) # with base 2\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\"\"\"\n\treturn list_plot(data, plotjoined=plotjoined, scale='semilogx', **kwds)\n", "description": "\n\tPlot ``data`` in 'semilogx' scale, that is, the horizontal axis will be\n\tin logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1.\n\n\tFor all other inputs, look at the documentation of :func:`list_plot`.\n\n\tEXAMPLES::\n\n\t\tsage: yl = [2**k for k in range(12)]\n\t\tsage: list_plot_semilogx(zip(yl,yl))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t.. warning::\n\n\t\tIf ``plotjoined`` is ``False`` then the horizontal axis must have all\n\t\tpoints strictly positive. Otherwise the plot will come up empty.\n\t\tFor instance the following plot contains a point at `(0,1)`.\n\n\t\t::\n\n\t\t\tsage: yl = [2**k for k in range(12)]\n\t\t\tsage: list_plot_semilogx(yl) # plot is empty because of `(0,1)`\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tWe remove `(0,1)` to fix this.::\n\n\t\t\tsage: list_plot_semilogx(zip(range(1, len(yl)), yl[1:]))\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: list_plot_semilogx([(1,2),(3,4),(3,-1),(25,3)], base=2) # with base 2\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "list_plot_semilogy", "data": "def list_plot_semilogy(data, plotjoined=False, **kwds):\n\t\"\"\"\n\tPlot ``data`` in 'semilogy' scale, that is, the vertical axis will be\n\tin logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1.\n\n\tFor all other inputs, look at the documentation of :func:`list_plot`.\n\n\tEXAMPLES::\n\n\t\tsage: yl = [2**k for k in range(12)]\n\t\tsage: list_plot_semilogy(yl) # plot in semilogy scale, base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t.. warning::\n\n\t\tIf ``plotjoined`` is ``False`` then the vertical axis must have all\n\t\tpoints strictly positive. Otherwise the plot will come up empty.\n\t\tFor instance the following plot contains a point at `(1,0)`.\n\n\t\t::\n\n\t\t\tsage: xl = [2**k for k in range(12)]; yl = range(len(xl))\n\t\t\tsage: list_plot_semilogy(zip(xl,yl)) # plot empty due to (1,0)\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tWe remove `(1,0)` to fix this.::\n\n\t\t\tsage: list_plot_semilogy(zip(xl[1:],yl[1:]))\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\n\t::\n\n\t\tsage: list_plot_semilogy([2, 4, 6, 8, 16, 31], base=2) # with base 2\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\"\"\"\n\treturn list_plot(data, plotjoined=plotjoined, scale='semilogy', **kwds)\n", "description": "\n\tPlot ``data`` in 'semilogy' scale, that is, the vertical axis will be\n\tin logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1.\n\n\tFor all other inputs, look at the documentation of :func:`list_plot`.\n\n\tEXAMPLES::\n\n\t\tsage: yl = [2**k for k in range(12)]\n\t\tsage: list_plot_semilogy(yl) # plot in semilogy scale, base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t.. warning::\n\n\t\tIf ``plotjoined`` is ``False`` then the vertical axis must have all\n\t\tpoints strictly positive. Otherwise the plot will come up empty.\n\t\tFor instance the following plot contains a point at `(1,0)`.\n\n\t\t::\n\n\t\t\tsage: xl = [2**k for k in range(12)]; yl = range(len(xl))\n\t\t\tsage: list_plot_semilogy(zip(xl,yl)) # plot empty due to (1,0)\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tWe remove `(1,0)` to fix this.::\n\n\t\t\tsage: list_plot_semilogy(zip(xl[1:],yl[1:]))\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\n\t::\n\n\t\tsage: list_plot_semilogy([2, 4, 6, 8, 16, 31], base=2) # with base 2\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "to_float_list", "data": "def to_float_list(v):\n\t\"\"\"\n\tGiven a list or tuple or iterable v, coerce each element of v to a\n\tfloat and make a list out of the result.\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.plot import to_float_list\n\t\tsage: to_float_list([1,1/2,3])\n\t\t[1.0, 0.5, 3.0]\n\t\"\"\"\n\treturn [float(x) for x in v]\n\n", "description": "\n\tGiven a list or tuple or iterable v, coerce each element of v to a\n\tfloat and make a list out of the result.\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.plot import to_float_list\n\t\tsage: to_float_list([1,1/2,3])\n\t\t[1.0, 0.5, 3.0]\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "reshape", "data": "def reshape(v, n, m):\n\t\"\"\"\n\tHelper function for creating graphics arrays.\n\n\tThe input array is flattened and turned into an `n\\times m`\n\tarray, with blank graphics object padded at the end, if\n\tnecessary.\n\n\tINPUT:\n\n\t-  ``v`` - a list of lists or tuples\n\n\t-  ``n, m`` - integers\n\n\tOUTPUT:\n\n\tA list of lists of graphics objects\n\n\tEXAMPLES::\n\n\t\tsage: L = [plot(sin(k*x),(x,-pi,pi)) for k in range(10)]\n\t\tsage: graphics_array(L,3,4)  # long time (up to 4s on sage.math, 2012)\n\t\tGraphics Array of size 3 x 4\n\n\t::\n\n\t\tsage: M = [[plot(sin(k*x),(x,-pi,pi)) for k in range(3)],[plot(cos(j*x),(x,-pi,pi)) for j in [3..5]]]\n\t\tsage: graphics_array(M,6,1)  # long time (up to 4s on sage.math, 2012)\n\t\tGraphics Array of size 6 x 1\n\n\tTESTS::\n\n\t\tsage: L = [plot(sin(k*x),(x,-pi,pi)) for k in [1..3]]\n\t\tsage: graphics_array(L,0,-1) # indirect doctest\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: array sizes must be positive\n\t\"\"\"\n\tif not (n > 0 and m > 0):\n\t\traise ValueError('array sizes must be positive')\n\tG = Graphics()\n\tG.axes(False)\n\tif len(v) == 0:\n\t\treturn [[G]*m]*n\n\n\tif not isinstance(v[0], Graphics):\n\t\t# a list of lists -- flatten it\n\t\tv = sum([list(x) for x in v], [])\n\n\t# Now v should be a single list.\n\t# First, make it have the right length.\n\tv = list(v)   # do not mutate the argument\n\tfor i in xrange(n*m - len(v)):\n\t\tv.append(G)\n\n\t# Next, create a list of lists out of it.\n\tL = []\n\tk = 0\n\tfor i in range(n):\n\t\tw = []\n\t\tfor j in range(m):\n\t\t\tw.append(v[k])\n\t\t\tk += 1\n\t\tL.append(w)\n\n\treturn L\n", "description": "\n\tHelper function for creating graphics arrays.\n\n\tThe input array is flattened and turned into an `n\\times m`\n\tarray, with blank graphics object padded at the end, if\n\tnecessary.\n\n\tINPUT:\n\n\t-  ``v`` - a list of lists or tuples\n\n\t-  ``n, m`` - integers\n\n\tOUTPUT:\n\n\tA list of lists of graphics objects\n\n\tEXAMPLES::\n\n\t\tsage: L = [plot(sin(k*x),(x,-pi,pi)) for k in range(10)]\n\t\tsage: graphics_array(L,3,4)  # long time (up to 4s on sage.math, 2012)\n\t\tGraphics Array of size 3 x 4\n\n\t::\n\n\t\tsage: M = [[plot(sin(k*x),(x,-pi,pi)) for k in range(3)],[plot(cos(j*x),(x,-pi,pi)) for j in [3..5]]]\n\t\tsage: graphics_array(M,6,1)  # long time (up to 4s on sage.math, 2012)\n\t\tGraphics Array of size 6 x 1\n\n\tTESTS::\n\n\t\tsage: L = [plot(sin(k*x),(x,-pi,pi)) for k in [1..3]]\n\t\tsage: graphics_array(L,0,-1) # indirect doctest\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: array sizes must be positive\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "graphics_array", "data": "def graphics_array(array, nrows=None, ncols=None):\n\tr\"\"\"\n\t``graphics_array`` take a list of lists (or tuples) of\n\tgraphics objects and plots them all on one canvas (single plot).\n\n\tINPUT:\n\n\t- ``array`` -- a list of lists or tuples. The graphics objects to\n\t   combine into a graphics array.\n\n\t- ``nrows, ncols`` -- (optional) integers. If both are given then\n\t   the input array is flattened and turned into an ``nrows`` x\n\t   ``ncols`` array, with blank graphics objects padded at the end,\n\t   if necessary. If only one is specified, the other is chosen\n\t   automatically.\n\n\tEXAMPLE: Make some plots of `\\sin` functions::\n\n\t\tsage: f(x) = sin(x)\n\t\tsage: g(x) = sin(2*x)\n\t\tsage: h(x) = sin(4*x)\n\t\tsage: p1 = plot(f,(-2*pi,2*pi),color=hue(0.5)) # long time\n\t\tsage: p2 = plot(g,(-2*pi,2*pi),color=hue(0.9)) # long time\n\t\tsage: p3 = parametric_plot((f,g),(0,2*pi),color=hue(0.6)) # long time\n\t\tsage: p4 = parametric_plot((f,h),(0,2*pi),color=hue(1.0)) # long time\n\n\tNow make a graphics array out of the plots::\n\n\t\tsage: graphics_array(((p1,p2),(p3,p4))) # long time\n\t\tGraphics Array of size 2 x 2\n\n\tOne can also name the array, and then use :meth:`~sage.plot.graphics.GraphicsArray.show`\n\tor :meth:`~sage.plot.graphics.GraphicsArray.save`::\n\n\t\tsage: ga = graphics_array(((p1,p2),(p3,p4))) # long time\n\t\tsage: ga.show() # long time\n\n\tHere we give only one row::\n\n\t\tsage: p1 = plot(sin,(-4,4))\n\t\tsage: p2 = plot(cos,(-4,4))\n\t\tsage: g = graphics_array([p1, p2]); print g\n\t\tGraphics Array of size 1 x 2\n\t\tsage: g.show()\n\n\tIt is possible to use ``figsize`` to change the size of the plot\n\tas a whole::\n\n\t\tsage: L = [plot(sin(k*x),(x,-pi,pi)) for k in [1..3]]\n\t\tsage: G = graphics_array(L)\n\t\tsage: G.show(figsize=[5,3])  # smallish and compact\n\t\tsage: G.show(figsize=[10,20])  # bigger and tall and thin; long time (2s on sage.math, 2012)\n\t\tsage: G.show(figsize=8)  # figure as a whole is a square\n\n\tSpecifying only the number of rows or the number of columns\n\tcomputes the other dimension automatically::\n\n\t\tsage: ga = graphics_array([plot(sin)] * 10, nrows=3)\n\t\tsage: ga.nrows(), ga.ncols()\n\t\t(3, 4)\n\t\tsage: ga = graphics_array([plot(sin)] * 10, ncols=3)\n\t\tsage: ga.nrows(), ga.ncols()\n\t\t(4, 3)\n\t\"\"\"\n\t# TODO: refactor the whole array flattening and reshaping into a class\n\tif nrows is None and ncols is None:\n\t\tpass\n\telif nrows is not None and ncols is not None:\n\t\tnrows = int(nrows)\n\t\tncols = int(ncols)\n\t\tarray = reshape(array, nrows, ncols)\n\telse:\n\t\t# nrows is None xor ncols is None\n\t\tif len(array) > 0 and isinstance(array[0], Graphics):\n\t\t\tlength = len(array)\n\t\telse:\n\t\t\tlength = sum(map(len, array))\n\t\tif nrows is None:\n\t\t\tncols = int(ncols)\n\t\t\tnrows = length // ncols + 1\n\t\telif ncols is None:\n\t\t\tnrows = int(nrows)\n\t\t\tncols = length // nrows + 1\n\t\telse:\n\t\t\tassert False\n\t\tarray = reshape(array, nrows, ncols)\n\treturn GraphicsArray(array)\n", "description": "\n\t``graphics_array`` take a list of lists (or tuples) of\n\tgraphics objects and plots them all on one canvas (single plot).\n\n\tINPUT:\n\n\t- ``array`` -- a list of lists or tuples. The graphics objects to\n\t   combine into a graphics array.\n\n\t- ``nrows, ncols`` -- (optional) integers. If both are given then\n\t   the input array is flattened and turned into an ``nrows`` x\n\t   ``ncols`` array, with blank graphics objects padded at the end,\n\t   if necessary. If only one is specified, the other is chosen\n\t   automatically.\n\n\tEXAMPLE: Make some plots of `\\sin` functions::\n\n\t\tsage: f(x) = sin(x)\n\t\tsage: g(x) = sin(2*x)\n\t\tsage: h(x) = sin(4*x)\n\t\tsage: p1 = plot(f,(-2*pi,2*pi),color=hue(0.5)) # long time\n\t\tsage: p2 = plot(g,(-2*pi,2*pi),color=hue(0.9)) # long time\n\t\tsage: p3 = parametric_plot((f,g),(0,2*pi),color=hue(0.6)) # long time\n\t\tsage: p4 = parametric_plot((f,h),(0,2*pi),color=hue(1.0)) # long time\n\n\tNow make a graphics array out of the plots::\n\n\t\tsage: graphics_array(((p1,p2),(p3,p4))) # long time\n\t\tGraphics Array of size 2 x 2\n\n\tOne can also name the array, and then use :meth:`~sage.plot.graphics.GraphicsArray.show`\n\tor :meth:`~sage.plot.graphics.GraphicsArray.save`::\n\n\t\tsage: ga = graphics_array(((p1,p2),(p3,p4))) # long time\n\t\tsage: ga.show() # long time\n\n\tHere we give only one row::\n\n\t\tsage: p1 = plot(sin,(-4,4))\n\t\tsage: p2 = plot(cos,(-4,4))\n\t\tsage: g = graphics_array([p1, p2]); print g\n\t\tGraphics Array of size 1 x 2\n\t\tsage: g.show()\n\n\tIt is possible to use ``figsize`` to change the size of the plot\n\tas a whole::\n\n\t\tsage: L = [plot(sin(k*x),(x,-pi,pi)) for k in [1..3]]\n\t\tsage: G = graphics_array(L)\n\t\tsage: G.show(figsize=[5,3])  # smallish and compact\n\t\tsage: G.show(figsize=[10,20])  # bigger and tall and thin; long time (2s on sage.math, 2012)\n\t\tsage: G.show(figsize=8)  # figure as a whole is a square\n\n\tSpecifying only the number of rows or the number of columns\n\tcomputes the other dimension automatically::\n\n\t\tsage: ga = graphics_array([plot(sin)] * 10, nrows=3)\n\t\tsage: ga.nrows(), ga.ncols()\n\t\t(3, 4)\n\t\tsage: ga = graphics_array([plot(sin)] * 10, ncols=3)\n\t\tsage: ga.nrows(), ga.ncols()\n\t\t(4, 3)\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "var_and_list_of_values", "data": "def var_and_list_of_values(v, plot_points):\n\t\"\"\"\n\tINPUT:\n\n\n\t-  ``v`` - (v0, v1) or (var, v0, v1); if the former\n\t   return the range of values between v0 and v1 taking plot_points\n\t   steps; if var is given, also return var.\n\n\t-  ``plot_points`` - integer = 2 (the endpoints)\n\n\n\tOUTPUT:\n\n\n\t-  ``var`` - a variable or None\n\n\t-  ``list`` - a list of floats\n\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.plot import var_and_list_of_values\n\t\tsage: var_and_list_of_values((var('theta'), 2, 5),  5)\n\t\tdoctest:...: DeprecationWarning: var_and_list_of_values is deprecated.  Please use sage.plot.misc.setup_for_eval_on_grid; note that that function has slightly different calling and return conventions which make it more generally applicable\n\t\tSee http://trac.sagemath.org/7008 for details.\n\t\t(theta, [2.0, 2.75, 3.5, 4.25, 5.0])\n\t\tsage: var_and_list_of_values((2, 5),  5)\n\t\t(None, [2.0, 2.75, 3.5, 4.25, 5.0])\n\t\tsage: var_and_list_of_values((var('theta'), 2, 5),  2)\n\t\t(theta, [2.0, 5.0])\n\t\tsage: var_and_list_of_values((2, 5),  2)\n\t\t(None, [2.0, 5.0])\n\t\"\"\"\n\tfrom sage.misc.superseded import deprecation\n\tdeprecation(7008, \"var_and_list_of_values is deprecated.  Please use sage.plot.misc.setup_for_eval_on_grid; note that that function has slightly different calling and return conventions which make it more generally applicable\")\n\tplot_points = int(plot_points)\n\tif plot_points < 2:\n\t\traise ValueError(\"plot_points must be greater than 1\")\n\tif not isinstance(v, (tuple, list)):\n\t\traise TypeError(\"v must be a tuple or list\")\n\tif len(v) == 3:\n\t\tvar = v[0]\n\t\ta, b = v[1], v[2]\n\telif len(v) == 2:\n\t\tvar = None\n\t\ta, b = v\n\telse:\n\t\traise ValueError(\"parametric value range must be a list or tuple of length 2 or 3.\")\n\n\ta = float(a)\n\tb = float(b)\n\tif plot_points == 2:\n\t\treturn var, [a, b]\n\telse:\n\t\tstep = (b-a)/float(plot_points-1)\n\t\tvalues = [a + step*i for i in xrange(plot_points)]\n\t\treturn var, values\n\n\n", "description": "\n\tINPUT:\n\n\n\t-  ``v`` - (v0, v1) or (var, v0, v1); if the former\n\t   return the range of values between v0 and v1 taking plot_points\n\t   steps; if var is given, also return var.\n\n\t-  ``plot_points`` - integer = 2 (the endpoints)\n\n\n\tOUTPUT:\n\n\n\t-  ``var`` - a variable or None\n\n\t-  ``list`` - a list of floats\n\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.plot import var_and_list_of_values\n\t\tsage: var_and_list_of_values((var('theta'), 2, 5),  5)\n\t\tdoctest:...: DeprecationWarning: var_and_list_of_values is deprecated.  Please use sage.plot.misc.setup_for_eval_on_grid; note that that function has slightly different calling and return conventions which make it more generally applicable\n\t\tSee http://trac.sagemath.org/7008 for details.\n\t\t(theta, [2.0, 2.75, 3.5, 4.25, 5.0])\n\t\tsage: var_and_list_of_values((2, 5),  5)\n\t\t(None, [2.0, 2.75, 3.5, 4.25, 5.0])\n\t\tsage: var_and_list_of_values((var('theta'), 2, 5),  2)\n\t\t(theta, [2.0, 5.0])\n\t\tsage: var_and_list_of_values((2, 5),  2)\n\t\t(None, [2.0, 5.0])\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "setup_for_eval_on_grid", "data": "def setup_for_eval_on_grid(v, xrange, yrange, plot_points):\n\t\"\"\"\n\tThis function is deprecated.  Please use\n\t``sage.plot.misc.setup_for_eval_on_grid`` instead.  Please note that\n\tthat function has slightly different calling and return\n\tconventions which make it more generally applicable.\n\n\tINPUT:\n\n\n\t-  ``v`` - a list of functions\n\n\t-  ``xrange`` - 2 or 3 tuple (if 3, first is a\n\t   variable)\n\n\t-  ``yrange`` - 2 or 3 tuple\n\n\t-  ``plot_points`` - a positive integer\n\n\n\tOUTPUT:\n\n\n\t-  ``g`` - tuple of fast callable functions\n\n\t-  ``xstep`` - step size in xdirection\n\n\t-  ``ystep`` - step size in ydirection\n\n\t-  ``xrange`` - tuple of 2 floats\n\n\t-  ``yrange`` - tuple of 2 floats\n\n\n\tEXAMPLES::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: sage.plot.plot.setup_for_eval_on_grid([x^2 + y^2], (x,0,5), (y,0,pi), 11)\n\t\tdoctest:...: DeprecationWarning: sage.plot.plot.setup_for_eval_on_grid is deprecated.  Please use sage.plot.misc.setup_for_eval_on_grid; note that that function has slightly different calling and return conventions which make it more generally applicable\n\t\tSee http://trac.sagemath.org/7008 for details.\n\t\t([],\n\t\t 0.5,\n\t\t 0.3141592653589793,\n\t\t (0.0, 5.0),\n\t\t (0.0, 3.141592653589793))\n\n\tWe always plot at least two points; one at the beginning and one at the end of the ranges.\n\n\t::\n\n\t\tsage: sage.plot.plot.setup_for_eval_on_grid([x^2+y^2], (x,0,1), (y,-1,1), 1)\n\t\t([],\n\t\t1.0,\n\t\t2.0,\n\t\t(0.0, 1.0),\n\t\t(-1.0, 1.0))\n\n\n\t\"\"\"\n\tfrom sage.misc.superseded import deprecation\n\tdeprecation(7008, \"sage.plot.plot.setup_for_eval_on_grid is deprecated.  Please use sage.plot.misc.setup_for_eval_on_grid; note that that function has slightly different calling and return conventions which make it more generally applicable\")\n\n\tfrom sage.plot.misc import setup_for_eval_on_grid as setup\n\tg, ranges=setup(v, [xrange, yrange], plot_points)\n\treturn list(g), ranges[0][2], ranges[1][2], ranges[0][:2], ranges[1][:2]\n\n", "description": "\n\tThis function is deprecated.  Please use\n\t``sage.plot.misc.setup_for_eval_on_grid`` instead.  Please note that\n\tthat function has slightly different calling and return\n\tconventions which make it more generally applicable.\n\n\tINPUT:\n\n\n\t-  ``v`` - a list of functions\n\n\t-  ``xrange`` - 2 or 3 tuple (if 3, first is a\n\t   variable)\n\n\t-  ``yrange`` - 2 or 3 tuple\n\n\t-  ``plot_points`` - a positive integer\n\n\n\tOUTPUT:\n\n\n\t-  ``g`` - tuple of fast callable functions\n\n\t-  ``xstep`` - step size in xdirection\n\n\t-  ``ystep`` - step size in ydirection\n\n\t-  ``xrange`` - tuple of 2 floats\n\n\t-  ``yrange`` - tuple of 2 floats\n\n\n\tEXAMPLES::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: sage.plot.plot.setup_for_eval_on_grid([x^2 + y^2], (x,0,5), (y,0,pi), 11)\n\t\tdoctest:...: DeprecationWarning: sage.plot.plot.setup_for_eval_on_grid is deprecated.  Please use sage.plot.misc.setup_for_eval_on_grid; note that that function has slightly different calling and return conventions which make it more generally applicable\n\t\tSee http://trac.sagemath.org/7008 for details.\n\t\t([],\n\t\t 0.5,\n\t\t 0.3141592653589793,\n\t\t (0.0, 5.0),\n\t\t (0.0, 3.141592653589793))\n\n\tWe always plot at least two points; one at the beginning and one at the end of the ranges.\n\n\t::\n\n\t\tsage: sage.plot.plot.setup_for_eval_on_grid([x^2+y^2], (x,0,1), (y,-1,1), 1)\n\t\t([],\n\t\t1.0,\n\t\t2.0,\n\t\t(0.0, 1.0),\n\t\t(-1.0, 1.0))\n\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "minmax_data", "data": "def minmax_data(xdata, ydata, dict=False):\n\t\"\"\"\n\tReturns the minimums and maximums of xdata and ydata.\n\n\tIf dict is False, then minmax_data returns the tuple (xmin, xmax,\n\tymin, ymax); otherwise, it returns a dictionary whose keys are\n\t'xmin', 'xmax', 'ymin', and 'ymax' and whose values are the\n\tcorresponding values.\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.plot import minmax_data\n\t\tsage: minmax_data([], [])\n\t\t(-1, 1, -1, 1)\n\t\tsage: minmax_data([-1, 2], [4, -3])\n\t\t(-1, 2, -3, 4)\n\t\tsage: d = minmax_data([-1, 2], [4, -3], dict=True)\n\t\tsage: list(sorted(d.items()))\n\t\t[('xmax', 2), ('xmin', -1), ('ymax', 4), ('ymin', -3)]\n\t\"\"\"\n\txmin = min(xdata) if len(xdata) > 0 else -1\n\txmax = max(xdata) if len(xdata) > 0 else 1\n\tymin = min(ydata) if len(ydata) > 0 else -1\n\tymax = max(ydata) if len(ydata) > 0 else 1\n\tif dict:\n\t\treturn {'xmin':xmin, 'xmax':xmax,\n\t\t\t\t'ymin':ymin, 'ymax':ymax}\n\telse:\n\t\treturn xmin, xmax, ymin, ymax\n", "description": "\n\tReturns the minimums and maximums of xdata and ydata.\n\n\tIf dict is False, then minmax_data returns the tuple (xmin, xmax,\n\tymin, ymax); otherwise, it returns a dictionary whose keys are\n\t'xmin', 'xmax', 'ymin', and 'ymax' and whose values are the\n\tcorresponding values.\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.plot import minmax_data\n\t\tsage: minmax_data([], [])\n\t\t(-1, 1, -1, 1)\n\t\tsage: minmax_data([-1, 2], [4, -3])\n\t\t(-1, 2, -3, 4)\n\t\tsage: d = minmax_data([-1, 2], [4, -3], dict=True)\n\t\tsage: list(sorted(d.items()))\n\t\t[('xmax', 2), ('xmin', -1), ('ymax', 4), ('ymin', -3)]\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "adaptive_refinement", "data": "def adaptive_refinement(f, p1, p2, adaptive_tolerance=0.01, adaptive_recursion=5, level=0):\n\tr\"\"\"\n\tThe adaptive refinement algorithm for plotting a function ``f``. See\n\tthe docstring for plot for a description of the algorithm.\n\n\tINPUT:\n\n\n\t-  ``f`` - a function of one variable\n\n\t-  ``p1, p2`` - two points to refine between\n\n\t-  ``adaptive_recursion`` - (default: 5) how many\n\t   levels of recursion to go before giving up when doing adaptive\n\t   refinement. Setting this to 0 disables adaptive refinement.\n\n\t-  ``adaptive_tolerance`` - (default: 0.01) how large\n\t   a relative difference should be before the adaptive refinement\n\t   code considers it significant; see documentation for generate_plot_points\n\t   for more information.  See the documentation for :func:`plot` for more\n\t   information on how the adaptive refinement algorithm works.\n\n\tOUTPUT:\n\n\n\t-  ``list`` - a list of points to insert between ``p1`` and\n\t   ``p2`` to get a better linear approximation between them\n\n\n\tTESTS::\n\n\t\tsage: from sage.plot.plot import adaptive_refinement\n\t\tsage: adaptive_refinement(sin, (0,0), (pi,0), adaptive_tolerance=0.01, adaptive_recursion=0)\n\t\t[]\n\t\tsage: adaptive_refinement(sin, (0,0), (pi,0), adaptive_tolerance=0.01)\n\t\t[(0.125*pi, 0.3826834323650898), (0.1875*pi, 0.5555702330196022), (0.25*pi, 0.7071067811865475), (0.3125*pi, 0.8314696123025452), (0.375*pi, 0.9238795325112867), (0.4375*pi, 0.9807852804032304), (0.5*pi, 1.0), (0.5625*pi, 0.9807852804032304), (0.625*pi, 0.9238795325112867), (0.6875*pi, 0.8314696123025455), (0.75*pi, 0.7071067811865476), (0.8125*pi, 0.5555702330196022), (0.875*pi, 0.3826834323650899)]\n\n\tThis shows that lowering ``adaptive_tolerance`` and raising\n\t``adaptive_recursion`` both increase the number of subdivision\n\tpoints, though which one creates more points is heavily\n\tdependent upon the function being plotted.\n\n\t::\n\n\t\tsage: x = var('x')\n\t\tsage: f(x) = sin(1/x)\n\t\tsage: n1 = len(adaptive_refinement(f, (0,0), (pi,0), adaptive_tolerance=0.01)); n1\n\t\t15\n\t\tsage: n2 = len(adaptive_refinement(f, (0,0), (pi,0), adaptive_recursion=10, adaptive_tolerance=0.01)); n2\n\t\t79\n\t\tsage: n3 = len(adaptive_refinement(f, (0,0), (pi,0), adaptive_tolerance=0.001)); n3\n\t\t26\n\t\"\"\"\n\tif level >= adaptive_recursion:\n\t\treturn []\n\n\tx = (p1[0] + p2[0])/2.0\n\tmsg = ''\n\n\ttry:\n\t\ty = float(f(x))\n\t\tif str(y) in ['nan', 'NaN', 'inf', '-inf']:\n\t\t\tsage.misc.misc.verbose(\"%s\\nUnable to compute f(%s)\"%(msg, x),1)\n\t\t\t# give up for this branch\n\t\t\treturn []\n\n\texcept (ZeroDivisionError, TypeError, ValueError, OverflowError) as msg:\n\t\tsage.misc.misc.verbose(\"%s\\nUnable to compute f(%s)\"%(msg, x), 1)\n\t\t# give up for this branch\n\t\treturn []\n\n\t# this distance calculation is not perfect.\n\tif abs((p1[1] + p2[1])/2.0 - y) > adaptive_tolerance:\n\t\treturn adaptive_refinement(f, p1, (x, y),\n\t\t\t\t\tadaptive_tolerance=adaptive_tolerance,\n\t\t\t\t\tadaptive_recursion=adaptive_recursion,\n\t\t\t\t\tlevel=level+1) \\\n\t\t\t\t\t+ [(x, y)] + \\\n\t\t\tadaptive_refinement(f, (x, y), p2,\n\t\t\t\t\tadaptive_tolerance=adaptive_tolerance,\n\t\t\t\t\tadaptive_recursion=adaptive_recursion,\n\t\t\t\t\tlevel=level+1)\n\telse:\n\t\treturn []\n", "description": "\n\tThe adaptive refinement algorithm for plotting a function ``f``. See\n\tthe docstring for plot for a description of the algorithm.\n\n\tINPUT:\n\n\n\t-  ``f`` - a function of one variable\n\n\t-  ``p1, p2`` - two points to refine between\n\n\t-  ``adaptive_recursion`` - (default: 5) how many\n\t   levels of recursion to go before giving up when doing adaptive\n\t   refinement. Setting this to 0 disables adaptive refinement.\n\n\t-  ``adaptive_tolerance`` - (default: 0.01) how large\n\t   a relative difference should be before the adaptive refinement\n\t   code considers it significant; see documentation for generate_plot_points\n\t   for more information.  See the documentation for :func:`plot` for more\n\t   information on how the adaptive refinement algorithm works.\n\n\tOUTPUT:\n\n\n\t-  ``list`` - a list of points to insert between ``p1`` and\n\t   ``p2`` to get a better linear approximation between them\n\n\n\tTESTS::\n\n\t\tsage: from sage.plot.plot import adaptive_refinement\n\t\tsage: adaptive_refinement(sin, (0,0), (pi,0), adaptive_tolerance=0.01, adaptive_recursion=0)\n\t\t[]\n\t\tsage: adaptive_refinement(sin, (0,0), (pi,0), adaptive_tolerance=0.01)\n\t\t[(0.125*pi, 0.3826834323650898), (0.1875*pi, 0.5555702330196022), (0.25*pi, 0.7071067811865475), (0.3125*pi, 0.8314696123025452), (0.375*pi, 0.9238795325112867), (0.4375*pi, 0.9807852804032304), (0.5*pi, 1.0), (0.5625*pi, 0.9807852804032304), (0.625*pi, 0.9238795325112867), (0.6875*pi, 0.8314696123025455), (0.75*pi, 0.7071067811865476), (0.8125*pi, 0.5555702330196022), (0.875*pi, 0.3826834323650899)]\n\n\tThis shows that lowering ``adaptive_tolerance`` and raising\n\t``adaptive_recursion`` both increase the number of subdivision\n\tpoints, though which one creates more points is heavily\n\tdependent upon the function being plotted.\n\n\t::\n\n\t\tsage: x = var('x')\n\t\tsage: f(x) = sin(1/x)\n\t\tsage: n1 = len(adaptive_refinement(f, (0,0), (pi,0), adaptive_tolerance=0.01)); n1\n\t\t15\n\t\tsage: n2 = len(adaptive_refinement(f, (0,0), (pi,0), adaptive_recursion=10, adaptive_tolerance=0.01)); n2\n\t\t79\n\t\tsage: n3 = len(adaptive_refinement(f, (0,0), (pi,0), adaptive_tolerance=0.001)); n3\n\t\t26\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "generate_plot_points", "data": "def generate_plot_points(f, xrange, plot_points=5, adaptive_tolerance=0.01, adaptive_recursion=5, randomize = True, initial_points = None):\n\tr\"\"\"\n\tCalculate plot points for a function f in the interval xrange.  The\n\tadaptive refinement algorithm is also automatically invoked with a\n\t*relative* adaptive tolerance of adaptive_tolerance; see below.\n\n\tINPUT:\n\n\t- ``f`` - a function of one variable\n\n\t- ``p1, p2`` - two points to refine between\n\n\t- ``plot_points`` - (default: 5) the minimal number of plot points. (Note\n\t  however that in any actual plot a number is passed to this, with default\n\t  value 200.)\n\n\t- ``adaptive_recursion`` - (default: 5) how many levels of recursion to go\n\t  before giving up when doing adaptive refinement.  Setting this to 0\n\t  disables adaptive refinement.\n\n\t- ``adaptive_tolerance`` - (default: 0.01) how large the relative difference\n\t  should be before the adaptive refinement code considers it significant.  If\n\t  the actual difference is greater than adaptive_tolerance*delta, where delta\n\t  is the initial subinterval size for the given xrange and plot_points, then\n\t  the algorithm will consider it significant.\n\n\t- ``initial_points`` - (default: None) a list of points that should be evaluated.\n\n\tOUTPUT:\n\n\t- a list of points (x, f(x)) in the interval xrange, which approximate\n\t  the function f.\n\n\tTESTS::\n\n\t\tsage: from sage.plot.plot import generate_plot_points\n\t\tsage: generate_plot_points(sin, (0, pi), plot_points=2, adaptive_recursion=0)\n\t\t[(0.0, 0.0), (3.141592653589793, 1.2246...e-16)]\n\n\t\tsage: from sage.plot.plot import generate_plot_points\n\t\tsage: generate_plot_points(lambda x: x^2, (0, 6), plot_points=2, adaptive_recursion=0, initial_points = [1,2,3])\n\t\t[(0.0, 0.0), (1.0, 1.0), (2.0, 4.0), (3.0, 9.0), (6.0, 36.0)]\n\n\t\tsage: generate_plot_points(sin(x).function(x), (-pi, pi), randomize=False)\n\t\t[(-3.141592653589793, -1.2246...e-16), (-2.748893571891069,\n\t\t-0.3826834323650899), (-2.356194490192345, -0.707106781186547...),\n\t\t(-2.1598449493429825, -0.831469612302545...), (-1.9634954084936207,\n\t\t-0.9238795325112867), (-1.7671458676442586, -0.9807852804032304),\n\t\t(-1.5707963267948966, -1.0), (-1.3744467859455345,\n\t\t-0.9807852804032304), (-1.1780972450961724, -0.9238795325112867),\n\t\t(-0.9817477042468103, -0.831469612302545...), (-0.7853981633974483,\n\t\t-0.707106781186547...), (-0.39269908169872414, -0.3826834323650898),\n\t\t(0.0, 0.0), (0.39269908169872414, 0.3826834323650898),\n\t\t(0.7853981633974483, 0.707106781186547...), (0.9817477042468103,\n\t\t0.831469612302545...), (1.1780972450961724, 0.9238795325112867),\n\t\t(1.3744467859455345, 0.9807852804032304), (1.5707963267948966, 1.0),\n\t\t(1.7671458676442586, 0.9807852804032304), (1.9634954084936207,\n\t\t0.9238795325112867), (2.1598449493429825, 0.831469612302545...),\n\t\t(2.356194490192345, 0.707106781186547...), (2.748893571891069,\n\t\t0.3826834323650899), (3.141592653589793, 1.2246...e-16)]\n\n\tThis shows that lowering adaptive_tolerance and raising\n\tadaptive_recursion both increase the number of subdivision points.\n\t(Note that which creates more points is heavily dependent on the\n\tparticular function plotted.)\n\n\t::\n\n\t\tsage: x = var('x')\n\t\tsage: f(x) = sin(1/x)\n\t\tsage: [len(generate_plot_points(f, (-pi, pi), plot_points=16, adaptive_tolerance=i, randomize=False)) for i in [0.01, 0.001, 0.0001]]\n\t\t[97, 161, 275]\n\n\t\tsage: [len(generate_plot_points(f, (-pi, pi), plot_points=16, adaptive_recursion=i, randomize=False)) for i in [5, 10, 15]]\n\t\t[97, 499, 2681]\n\t\"\"\"\n\tfrom sage.plot.misc import setup_for_eval_on_grid\n\tignore, ranges = setup_for_eval_on_grid([], [xrange], plot_points)\n\txmin, xmax, delta = ranges[0]\n\tdata = srange(*ranges[0], include_endpoint=True)\n\n\trandom = current_randstate().python_random().random\n\n\tfor i in range(len(data)):\n\t\txi = data[i]\n\t\t# Slightly randomize the interior sample points if\n\t\t# randomize is true\n\t\tif randomize and i > 0 and i < plot_points-1:\n\t\t\txi += delta*(random() - 0.5)\n\t\t\tdata[i] = xi\n\n\t# add initial points\n\tif isinstance(initial_points, list):\n\t\tdata = sorted(data + initial_points)\n\n\texceptions = 0; msg=''\n\texception_indices = []\n\tfor i in range(len(data)):\n\t\txi = data[i]\n\n\t\ttry:\n\t\t\tdata[i] = (float(xi), float(f(xi)))\n\t\t\tif str(data[i][1]) in ['nan', 'NaN', 'inf', '-inf']:\n\t\t\t\tsage.misc.misc.verbose(\"%s\\nUnable to compute f(%s)\"%(msg, xi),1)\n\t\t\t\texceptions += 1\n\t\t\t\texception_indices.append(i)\n\n\t\texcept (ArithmeticError, TypeError, ValueError) as msg:\n\t\t\tsage.misc.misc.verbose(\"%s\\nUnable to compute f(%s)\"%(msg, xi),1)\n\n\t\t\tif i == 0: # Given an error for left endpoint, try to move it in slightly\n\t\t\t\tfor j in range(1, 99):\n\t\t\t\t\txj = xi + delta*j/100.0\n\t\t\t\t\ttry:\n\t\t\t\t\t\tdata[i] = (float(xj), float(f(xj)))\n\t\t\t\t\t\t# nan != nan\n\t\t\t\t\t\tif data[i][1] != data[i][1]:\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tbreak\n\t\t\t\t\texcept (ArithmeticError, TypeError, ValueError) as msg:\n\t\t\t\t\t\tpass\n\t\t\t\telse:\n\t\t\t\t\texceptions += 1\n\t\t\t\t\texception_indices.append(i)\n\n\t\t\telif i == plot_points-1: # Given an error for right endpoint, try to move it in slightly\n\t\t\t\tfor j in range(1, 99):\n\t\t\t\t\txj = xi - delta*j/100.0\n\t\t\t\t\ttry:\n\t\t\t\t\t\tdata[i] = (float(xj), float(f(xj)))\n\t\t\t\t\t\t# nan != nan\n\t\t\t\t\t\tif data[i][1] != data[i][1]:\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tbreak\n\t\t\t\t\texcept (ArithmeticError, TypeError, ValueError) as msg:\n\t\t\t\t\t\tpass\n\t\t\t\telse:\n\t\t\t\t\texceptions += 1\n\t\t\t\t\texception_indices.append(i)\n\t\t\telse:\n\t\t\t\texceptions += 1\n\t\t\t\texception_indices.append(i)\n\n\tdata = [data[i] for i in range(len(data)) if i not in exception_indices]\n\n\t# calls adaptive refinement\n\ti, j = 0, 0\n\tadaptive_tolerance = delta * float(adaptive_tolerance)\n\tadaptive_recursion = int(adaptive_recursion)\n\n\twhile i < len(data) - 1:\n\t   for p in adaptive_refinement(f, data[i], data[i+1],\n\t\t\t\t\t\t\t\t\t adaptive_tolerance=adaptive_tolerance,\n\t\t\t\t\t\t\t\t\t adaptive_recursion=adaptive_recursion):\n\t\t\tdata.insert(i+1, p)\n\t\t\ti += 1\n\t   i += 1\n\n\tif (len(data) == 0 and exceptions > 0) or exceptions > 10:\n\t\tsage.misc.misc.verbose(\"WARNING: When plotting, failed to evaluate function at %s points.\"%exceptions, level=0)\n\t\tsage.misc.misc.verbose(\"Last error message: '%s'\"%msg, level=0)\n\n\treturn data\n", "description": "\n\tCalculate plot points for a function f in the interval xrange.  The\n\tadaptive refinement algorithm is also automatically invoked with a\n\t*relative* adaptive tolerance of adaptive_tolerance; see below.\n\n\tINPUT:\n\n\t- ``f`` - a function of one variable\n\n\t- ``p1, p2`` - two points to refine between\n\n\t- ``plot_points`` - (default: 5) the minimal number of plot points. (Note\n\t  however that in any actual plot a number is passed to this, with default\n\t  value 200.)\n\n\t- ``adaptive_recursion`` - (default: 5) how many levels of recursion to go\n\t  before giving up when doing adaptive refinement.  Setting this to 0\n\t  disables adaptive refinement.\n\n\t- ``adaptive_tolerance`` - (default: 0.01) how large the relative difference\n\t  should be before the adaptive refinement code considers it significant.  If\n\t  the actual difference is greater than adaptive_tolerance*delta, where delta\n\t  is the initial subinterval size for the given xrange and plot_points, then\n\t  the algorithm will consider it significant.\n\n\t- ``initial_points`` - (default: None) a list of points that should be evaluated.\n\n\tOUTPUT:\n\n\t- a list of points (x, f(x)) in the interval xrange, which approximate\n\t  the function f.\n\n\tTESTS::\n\n\t\tsage: from sage.plot.plot import generate_plot_points\n\t\tsage: generate_plot_points(sin, (0, pi), plot_points=2, adaptive_recursion=0)\n\t\t[(0.0, 0.0), (3.141592653589793, 1.2246...e-16)]\n\n\t\tsage: from sage.plot.plot import generate_plot_points\n\t\tsage: generate_plot_points(lambda x: x^2, (0, 6), plot_points=2, adaptive_recursion=0, initial_points = [1,2,3])\n\t\t[(0.0, 0.0), (1.0, 1.0), (2.0, 4.0), (3.0, 9.0), (6.0, 36.0)]\n\n\t\tsage: generate_plot_points(sin(x).function(x), (-pi, pi), randomize=False)\n\t\t[(-3.141592653589793, -1.2246...e-16), (-2.748893571891069,\n\t\t-0.3826834323650899), (-2.356194490192345, -0.707106781186547...),\n\t\t(-2.1598449493429825, -0.831469612302545...), (-1.9634954084936207,\n\t\t-0.9238795325112867), (-1.7671458676442586, -0.9807852804032304),\n\t\t(-1.5707963267948966, -1.0), (-1.3744467859455345,\n\t\t-0.9807852804032304), (-1.1780972450961724, -0.9238795325112867),\n\t\t(-0.9817477042468103, -0.831469612302545...), (-0.7853981633974483,\n\t\t-0.707106781186547...), (-0.39269908169872414, -0.3826834323650898),\n\t\t(0.0, 0.0), (0.39269908169872414, 0.3826834323650898),\n\t\t(0.7853981633974483, 0.707106781186547...), (0.9817477042468103,\n\t\t0.831469612302545...), (1.1780972450961724, 0.9238795325112867),\n\t\t(1.3744467859455345, 0.9807852804032304), (1.5707963267948966, 1.0),\n\t\t(1.7671458676442586, 0.9807852804032304), (1.9634954084936207,\n\t\t0.9238795325112867), (2.1598449493429825, 0.831469612302545...),\n\t\t(2.356194490192345, 0.707106781186547...), (2.748893571891069,\n\t\t0.3826834323650899), (3.141592653589793, 1.2246...e-16)]\n\n\tThis shows that lowering adaptive_tolerance and raising\n\tadaptive_recursion both increase the number of subdivision points.\n\t(Note that which creates more points is heavily dependent on the\n\tparticular function plotted.)\n\n\t::\n\n\t\tsage: x = var('x')\n\t\tsage: f(x) = sin(1/x)\n\t\tsage: [len(generate_plot_points(f, (-pi, pi), plot_points=16, adaptive_tolerance=i, randomize=False)) for i in [0.01, 0.001, 0.0001]]\n\t\t[97, 161, 275]\n\n\t\tsage: [len(generate_plot_points(f, (-pi, pi), plot_points=16, adaptive_recursion=i, randomize=False)) for i in [5, 10, 15]]\n\t\t[97, 499, 2681]\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}], [{"term": "class", "name": "classAnimationPlayer:", "data": "class AnimationPlayer:\n\tdef __init__(self):\n\t\tself.frames = {\n\t\t\t# magic\n\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\n\t\t\t'aura': import_folder('../graphics/particles/aura'),\n\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\n\n\t\t\t# attacks\n\t\t\t'claw': import_folder('../graphics/particles/claw'),\n\t\t\t'slash': import_folder('../graphics/particles/slash'),\n\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\n\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\n\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\n\n\t\t\t# monster deaths\n\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\n\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\n\t\t\t'spirit': import_folder('../graphics/particles/nova'),\n\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\n\n\t\t\t# leafs\n\t\t\t'leaf': (\n\t\t\t\timport_folder('../graphics/particles/leaf1'),\n\t\t\t\timport_folder('../graphics/particles/leaf2'),\n\t\t\t\timport_folder('../graphics/particles/leaf3'),\n\t\t\t\timport_folder('../graphics/particles/leaf4'),\n\t\t\t\timport_folder('../graphics/particles/leaf5'),\n\t\t\t\timport_folder('../graphics/particles/leaf6'),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\n\t\t\t)\n\t\t}\n\n\t@staticmethod\n\tdef reflect_images(frames):\n\t\tnew_frames = []\n\t\tfor frame in frames:\n\t\t\tflipped_frame = pygame.transform.flip(frame, True, False)\n\t\t\tnew_frames.append(flipped_frame)\n\t\treturn new_frames\n\n\tdef create_grass_particles(self, pos, groups):\n\t\tanimation_frames = choice(self.frames['leaf'])\n\t\tParticleEffect(pos, animation_frames, groups)\n\n\tdef create_particles(self, animation_type, pos, groups):\n\t\tanimation_frames = self.frames[animation_type]\n\t\tParticleEffect(pos, animation_frames, groups)\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\n\tdef __init__(self, pos, animation_frames, groups):\n\t\tsuper().__init__(groups)\n\t\tself.frame_index = 0\n\t\tself.animation_speed = 0.15\n\t\tself.frames = animation_frames\n\t\tself.image = self.frames[self.frame_index]\n\t\tself.rect = self.image.get_rect(center=pos)\n\n\tdef animate(self):\n\t\tself.frame_index += self.animation_speed\n\t\tif self.frame_index >= len(self.frames):\n\t\t\tself.kill()\n\t\telse:\n\t\t\tself.image = self.frames[int(self.frame_index)]\n\n\tdef update(self):\n\t\tself.animate()\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}], [{"term": "class", "name": "Slider", "data": "class Slider(QSlider):\n\tNothing, Forward, Backward = 0, 1, -1\n\tdirectionChanged = pyqtSignal(int)\n\tdef __init__(self, parent=None):\n\t\tQSlider.__init__(self, parent)\n\t\tself._direction = Slider.Nothing\n\t\tself.last = self.value()/self.maximum()\n\t\tself.valueChanged.connect(self.onValueChanged)\n\n\tdef onValueChanged(self, value):\n\t\tcurrent = value/self.maximum()\n\t\tdirection = Slider.Forward if self.last < current else Slider.Backward\n\t\tif self._direction != direction:\n\t\t\tself.directionChanged.emit(direction)\n\t\t\tself._direction = direction\n\t\tself.last = current\n\n\tdef direction(self):\n\t\treturn self._direction\n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "setUpGraphicsViewSubWindow", "data": "def setUpGraphicsViewSubWindow(self):\n\t\"\"\"\n\tThis function creates a subwindow with a vertical layout &\n\ta missing image label.\n\n\tInput Parameters\n\t****************\n\tself - an object reference to the WEASEL interface.\n\n\tOutput Parameters\n\t*****************\n\tlayout - PyQt5 QVBoxLayout vertical layout box\n\tlblImageMissing - Label displaying the text 'Missing Image'. Hidden \n\t\t\t\t\t\tuntil WEASEL tries to display a missing image\n\tsubWindow - An QMdiSubWindow subwindow\n\t\"\"\"\n\ttry:\n\t\tlogger.info(\"DisplayImageDrawRIO.setUpGraphicsViewSubWindow called\")\n\t\tsubWindow = QMdiSubWindow(self)\n\t\tsubWindow.setObjectName = 'image_viewer'\n\t\tsubWindow.setWindowFlags(Qt.CustomizeWindowHint | \n\t\t\t\t\t\t\t\t\t  Qt.WindowCloseButtonHint | \n\t\t\t\t\t\t\t\t\t  Qt.WindowMinimizeButtonHint)\n\t\t\n\t\t\n\t\theight, width = self.getMDIAreaDimensions()\n\t\tsubWindow.setGeometry(0,0,width*0.6,height)\n\t\tself.mdiArea.addSubWindow(subWindow)\n\t\t\n\t\tlayout = QVBoxLayout()\n\t\twidget = QWidget()\n\t\twidget.setLayout(layout)\n\t\tsubWindow.setWidget(widget)\n\t\t\n\t\tlblImageMissing = QLabel(\"Image Missing\")\n\t\tlblImageMissing.hide()\n\t\tlayout.addWidget(lblImageMissing)\n\t\thbox = QHBoxLayout()\n\t\thbox.setContentsMargins(0, 0, 0, 0)\n\t\tlayout.addLayout(hbox)\n\t\tsubWindow.show()\n\t\treturn hbox, layout, lblImageMissing, subWindow\n\texcept Exception as e:\n\t\t\tprint('Error in DisplayImageDrawRIO.setUpGraphicsViewSubWindow: ' + str(e))\n\t\t\tlogger.error('Error in DisplayImageDrawRIO.setUpGraphicsViewSubWindow: ' + str(e))\n\n", "description": "\n\tThis function creates a subwindow with a vertical layout &\n\ta missing image label.\n\n\tInput Parameters\n\t****************\n\tself - an object reference to the WEASEL interface.\n\n\tOutput Parameters\n\t*****************\n\tlayout - PyQt5 QVBoxLayout vertical layout box\n\tlblImageMissing - Label displaying the text 'Missing Image'. Hidden \n\t\t\t\t\t\tuntil WEASEL tries to display a missing image\n\tsubWindow - An QMdiSubWindow subwindow\n\t", "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "addNewROItoDropDownList", "data": "def addNewROItoDropDownList(newRegion, roiCombo):\n\tlogger.info(\"DisplayImageDrawROI.addNewROItoDropDownList called.\")\n\tnoDuplicate = True\n\tfor count in range(roiCombo.count()):\n\t\t if roiCombo.itemText(count) == newRegion:\n\t\t\t noDuplicate = False\n\t\t\t break\n\tif noDuplicate:\n\t\troiCombo.blockSignals(True)\n\t\troiCombo.addItem(newRegion)\n\t\troiCombo.setCurrentIndex(roiCombo.count() - 1)\n\t\troiCombo.blockSignals(False)\n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "setUpLevelsSpinBoxes", "data": "def setUpLevelsSpinBoxes(layout, graphicsView, cmbROIs, imageSlider = None):\n\tlogger.info(\"DisplayImageDrawROI.setUpLevelsSpinBoxes called.\")\n\tspinBoxIntensity = QDoubleSpinBox()\n\tspinBoxContrast = QDoubleSpinBox()\n\t\n\tlblIntensity = QLabel(\"Centre (Intensity)\")\n\tlblContrast = QLabel(\"Width (Contrast)\")\n\tlblIntensity.setAlignment(Qt.AlignRight | Qt.AlignVCenter)\n\tlblContrast.setAlignment(Qt.AlignRight | Qt.AlignVCenter)\n\t\n\tspinBoxIntensity.setMinimum(-100000.00)\n\tspinBoxContrast.setMinimum(-100000.00)\n\tspinBoxIntensity.setMaximum(1000000000.00)\n\tspinBoxContrast.setMaximum(1000000000.00)\n\tspinBoxIntensity.setWrapping(True)\n\tspinBoxContrast.setWrapping(True)\n\n\tgroupBoxLevels = QGroupBox('Image Levels')\n\tgridLayoutLevels = QGridLayout()\n\tgridLayoutLevels.setHorizontalSpacing(10)\n\tgroupBoxLevels.setLayout(gridLayoutLevels)\n\tlayout.addWidget(groupBoxLevels)\n\t\n\tgridLayoutLevels.addWidget(lblIntensity, 0,0)\n\tgridLayoutLevels.addWidget(spinBoxIntensity, 0, 1)\n\tgridLayoutLevels.addWidget(lblContrast, 0,2)\n\tgridLayoutLevels.addWidget(spinBoxContrast, 0,3)\n\tgridLayoutLevels.setHorizontalSpacing(10)\n\t\n\tspinBoxIntensity.valueChanged.connect(lambda: updateImageLevels(graphicsView,\n\t\t\t\tspinBoxIntensity.value(), spinBoxContrast.value(),  cmbROIs, imageSlider))\n\tspinBoxContrast.valueChanged.connect(lambda: updateImageLevels(graphicsView,\n\t\t\t\tspinBoxIntensity.value(), spinBoxContrast.value(), cmbROIs, imageSlider))  \n\tlayout.addLayout(gridLayoutLevels) \n\treturn spinBoxIntensity, spinBoxContrast\n\t\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "updateImageLevels", "data": "def updateImageLevels(graphicsView, intensity, contrast, cmbROIs, imageSlider = None):\n\tlogger.info(\"DisplayImageDrawROI.updateImageLevels called.\")\n\ttry:\n\t\tif imageSlider:\n\t\t\timageNumber = imageSlider.value()\n\t\telse:\n\t\t\timageNumber = 1\n\t\tmask = graphicsView.dictROIs.getMask(cmbROIs.currentText(), imageNumber)\n\t\tgraphicsView.graphicsItem.updateImageLevels(intensity, contrast, mask)\n\texcept Exception as e:\n\t\t\tprint('Error in DisplayImageDrawROI.updateImageLevels when imageNumber={}: '.format(imageNumber) + str(e))\n\t\t\tlogger.error('Error in DisplayImageDrawROI.updateImageLevels: ' + str(e))\n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "setUpROIButtons", "data": "def setUpROIButtons(self, layout, pixelDataLabel, roiMeanLabel, graphicsView, zoomSlider, zoomLabel, imageSlider=None):\n\ttry:\n\t\tlogger.info(\"DisplayImageDrawROI.setUpPixelDataWidget called.\")\n\t\tbuttonList = []\n\t\tlblCmbROIs =  QLabel(\"ROIs\")\n\t\tcmbROIs = QComboBox()\n\t\tcmbROIs.setDuplicatesEnabled(False)\n\t\tcmbROIs.addItem(\"region1\")\n\t\tcmbROIs.setCurrentIndex(0)\n\n\t\tbtnDeleteROI = QPushButton() \n\t\tbtnDeleteROI.setToolTip('Delete the current ROI')\n\t\tbtnDeleteROI.clicked.connect(graphicsView.deleteROI)\n\t\tbtnDeleteROI.setIcon(QIcon(QPixmap(DELETE_ICON)))\n\t\t\n\t\tbtnNewROI = QPushButton() \n\t\tbtnNewROI.setToolTip('Add a new ROI')\n\t\tbtnNewROI.clicked.connect(graphicsView.newROI)\n\t\tbtnNewROI.setIcon(QIcon(QPixmap(NEW_ICON)))\n\n\t\tbtnResetROI = QPushButton()\n\t\tbtnResetROI.setToolTip('Clears the ROI from the image')\n\t\tbtnResetROI.clicked.connect(graphicsView.resetROI)\n\t\tbtnResetROI.setIcon(QIcon(QPixmap(RESET_ICON)))\n\n\t\tbtnSaveROI = QPushButton()\n\t\tbtnSaveROI.setToolTip('Saves the ROI in DICOM format')\n\t\tbtnSaveROI.clicked.connect(lambda: saveROI(self, cmbROIs.currentText(), graphicsView))\n\t\tbtnSaveROI.setIcon(QIcon(QPixmap(SAVE_ICON)))\n\n\t\tbtnLoad = QPushButton()\n\t\tbtnLoad.setToolTip('Loads existing ROIs')\n\t\tbtnLoad.clicked.connect(lambda: loadROI(self, cmbROIs, graphicsView))\n\t\tbtnLoad.setIcon(QIcon(QPixmap(LOAD_ICON)))\n\n\t\tbtnErase = QPushButton()\n\t\tbuttonList.append(btnErase)\n\t\tbtnErase.setToolTip(\"Erase the ROI\")\n\t\tbtnErase.setCheckable(True)\n\t\tbtnErase.setIcon(QIcon(QPixmap(ERASOR_CURSOR)))\n\n\t\tbtnDraw = QPushButton()\n\t\tbuttonList.append(btnDraw)\n\t\tbtnDraw.setToolTip(\"Draw an ROI\")\n\t\tbtnDraw.setCheckable(True)\n\t\tbtnDraw.setIcon(QIcon(QPixmap(PEN_CURSOR)))\n\n\t\tbtnZoom = QPushButton()\n\t\tbuttonList.append(btnZoom)\n\t\tbtnZoom.setToolTip(\"Zoom in/Zoom out of the image\")\n\t\tbtnZoom.setCheckable(True)\n\t\tbtnZoom.setIcon(QIcon(QPixmap(MAGNIFYING_GLASS_CURSOR)))\n\n\n\t\tbtnErase.clicked.connect(lambda checked: eraseROI(btnErase, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchecked, graphicsView, buttonList))\n\t\tbtnDraw.clicked.connect(lambda checked: drawROI(btnDraw, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  checked, graphicsView, buttonList))\n\t\tbtnZoom.clicked.connect(lambda checked: zoomImage(btnZoom, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  checked, graphicsView, buttonList))\n\t\n\n\t\tcmbROIs.setStyleSheet('QComboBox {font: 12pt Arial}')\n\n\t\tcmbROIs.currentIndexChanged.connect(\n\t\t\tlambda: reloadImageInNewImageItem(cmbROIs, graphicsView, pixelDataLabel, \n\t\t\t\t\t\t\t\t  roiMeanLabel, self, buttonList, btnDraw, btnErase, \n\t\t\t\t\t\t\t\t  zoomSlider, zoomLabel, imageSlider))\n\n\t\tcmbROIs.editTextChanged.connect( lambda text: roiNameChanged(cmbROIs, graphicsView, text))\n\t\tcmbROIs.setToolTip(\"Displays a list of ROIs created\")\n\t\tcmbROIs.setEditable(True)\n\t\tcmbROIs.setInsertPolicy(QComboBox.InsertAtCurrent)\n\n\t\tgroupBoxROI = QGroupBox('ROI')\n\t\tlayout.addWidget(groupBoxROI)\n\t\tlayoutROI = QHBoxLayout(groupBoxROI)\n\t\t\n\t\tlayoutROI.addWidget(lblCmbROIs,alignment=Qt.AlignRight, )\n\t\tlayoutROI.addWidget(cmbROIs,  alignment=Qt.AlignLeft,)\n\t\tlayoutROI.addWidget(btnNewROI, alignment=Qt.AlignLeft, )\n\t\tlayoutROI.addWidget(btnResetROI,  alignment=Qt.AlignLeft,)\n\t\tlayoutROI.addWidget(btnDeleteROI,  alignment=Qt.AlignLeft,)\n\t\tlayoutROI.addWidget(btnSaveROI,  alignment=Qt.AlignLeft,)\n\t\tlayoutROI.addWidget(btnLoad,  alignment=Qt.AlignLeft,)\n\t\tlayoutROI.addWidget(btnDraw,  alignment=Qt.AlignLeft,)\n\t\tlayoutROI.addWidget(btnErase, alignment=Qt.AlignLeft,)\n\t\tlayoutROI.addWidget(btnZoom,  alignment=Qt.AlignLeft,)\n\t\t\n\t\treturn cmbROIs, buttonList, btnDraw, btnErase\n\texcept Exception as e:\n\t\t   print('Error in DisplayImageDrawROI.setUpROIButtons: ' + str(e))\n\t\t   logger.error('Error in DisplayImageDrawROI.setUpROIButtons: ' + str(e))  \n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "setPixelDataLabels", "data": "def setPixelDataLabels(layout):\n\ttry:\n\t\tlogger.info(\"DisplayImageDrawROI.setPixelDataLabels called.\")\n\t\tpixelDataLabel = QLabel(\"Pixel data\")\n\t\troiMeanLabel = QLabel(\"ROI Mean Value\")\n\n\t\tgroupBoxPixelData = QGroupBox('Pixel/ROI Data')\n\t\tlayout.addWidget(groupBoxPixelData)\n\t\tlayoutPixelData = QHBoxLayout(groupBoxPixelData)\n\n\t\tlayoutPixelData.addWidget(pixelDataLabel)\n\t\tlayoutPixelData.addWidget(roiMeanLabel)\n\t\treturn pixelDataLabel, roiMeanLabel\n\texcept Exception as e:\n\t\t   print('Error in DisplayImageDrawROI.setPixelDataLabels: ' + str(e))\n\t\t   logger.error('Error in DisplayImageDrawROI.setPixelDataLabels: ' + str(e))  \n\n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "setEraseButtonColour", "data": "def setEraseButtonColour(setRed, btnDraw, btnErase):\n\tlogger.info(\"DisplayImageDrawRIO.setEraseButtonColour called\")\n\tif setRed:\n\t\t   btnErase.setStyleSheet(\"background-color: red\")\n\t\t   btnDraw.setStyleSheet(\n\t\t\t\"background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #CCCCBB, stop: 1 #FFFFFF)\"\n\t\t\t )\n\telse:\n\t\t   btnErase.setStyleSheet(\n\t\t\t \"background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #CCCCBB, stop: 1 #FFFFFF)\"\n\t\t\t )\n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "setDrawButtonColour", "data": "def setDrawButtonColour(setRed, btnDraw, btnErase):\n\tlogger.info(\"DisplayImageDrawRIO.setDrawButtonColour called\")\n\tif setRed:\n\t\t   btnDraw.setStyleSheet(\"background-color: red\")\n\t\t   btnErase.setStyleSheet(\n\t\t\t\"background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #CCCCBB, stop: 1 #FFFFFF)\"\n\t\t\t )\n\telse:\n\t\t   btnDraw.setStyleSheet(\n\t\t\t \"background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #CCCCBB, stop: 1 #FFFFFF)\"\n\t\t\t )\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "setButtonsToDefaultStyle", "data": "def setButtonsToDefaultStyle(buttonList):\n\tlogger.info(\"DisplayImageDrawRIO.setButtonsToDefaultStyle called\")\n\ttry:\n\t\tlogger.info(\"DisplayImageDrawROI.setButtonsToDefaultStyle called.\")\n\t\tQApplication.setOverrideCursor(QCursor(Qt.ArrowCursor))\n\t\tif buttonList:\n\t\t\tfor button in buttonList:\n\t\t\t\tbutton.setStyleSheet(\n\t\t\t\t \"background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #CCCCBB, stop: 1 #FFFFFF)\"\n\t\t\t\t )\n\texcept Exception as e:\n\t\t\tprint('Error in DisplayImageDrawROI.setButtonsToDefaultStyle: ' + str(e))\n\t\t\tlogger.error('Error in DisplayImageDrawROI.setButtonsToDefaultStyle: ' + str(e))  \n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "zoomImage", "data": "def zoomImage(btn, checked, graphicsView, buttonList):\n\tlogger.info(\"DisplayImageDrawROI.zoomImage called.\")\n\tif checked:\n\t\tsetButtonsToDefaultStyle(buttonList)\n\t\tgraphicsView.setZoomEnabled(True)\n\t\tgraphicsView.graphicsItem.drawEnabled = False\n\t\tgraphicsView.graphicsItem.eraseEnabled = False\n\t\tbtn.setStyleSheet(\"background-color: red\")\n\telse:\n\t\tQApplication.setOverrideCursor(QCursor(Qt.ArrowCursor))\n\t\tgraphicsView.setZoomEnabled(False)\n\t\tbtn.setStyleSheet(\n\t\t \"background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #CCCCBB, stop: 1 #FFFFFF)\"\n\t\t )\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "drawROI", "data": "def drawROI(btn, checked, graphicsView, buttonList):\n\tlogger.info(\"DisplayImageDrawROI.drawROI called.\")\n\tif checked:\n\t\tsetButtonsToDefaultStyle(buttonList)\n\t\tgraphicsView.drawROI()\n\t\tbtn.setStyleSheet(\"background-color: red\")\n\telse:\n\t\tQApplication.setOverrideCursor(QCursor(Qt.ArrowCursor))\n\t\tgraphicsView.graphicsItem.drawEnabled = False\n\t\tbtn.setStyleSheet(\n\t\t \"background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #CCCCBB, stop: 1 #FFFFFF)\"\n\t\t )\n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "eraseROI", "data": "def eraseROI(btn, checked, graphicsView, buttonList):\n\tlogger.info(\"DisplayImageDrawROI.eraseROI called.\")\n\tif checked:\n\t\tsetButtonsToDefaultStyle(buttonList)\n\t\tgraphicsView.eraseROI()\n\t\tbtn.setStyleSheet(\"background-color: red\")\n\telse:\n\t\tQApplication.setOverrideCursor(QCursor(Qt.ArrowCursor))\n\t\tgraphicsView.graphicsItem.eraseEnabled = False\n\t\tbtn.setStyleSheet(\n\t\t \"background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #CCCCBB, stop: 1 #FFFFFF)\"\n\t\t )\n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "setUpImageEventHandlers", "data": "def setUpImageEventHandlers(self, graphicsView, pixelDataLabel, btnDraw, btnErase,\n\t\t\t\t\t\t\troiMeanLabel, cmbROIs, buttonList, zoomSlider, zoomLabel, imageSlider=None):\n\tlogger.info(\"DisplayImageDrawROI.setUpImageEventHandlers called.\")\n\tgraphicsView.graphicsItem.sigMouseHovered.connect(\n\tlambda: displayImageDataUnderMouse(graphicsView, pixelDataLabel))\n\n\tgraphicsView.graphicsItem.sigMaskCreated.connect(\n\t\tlambda:storeMaskData(graphicsView, cmbROIs.currentText(), imageSlider))\n\n\tgraphicsView.graphicsItem.sigMaskCreated.connect(\n\t\tlambda: displayROIMeanAndStd(self, roiMeanLabel, graphicsView, cmbROIs, imageSlider))\n\n\tgraphicsView.graphicsItem.sigMaskEdited.connect(\n\t\tlambda:replaceMask(graphicsView, cmbROIs.currentText(), imageSlider))\n\n\tgraphicsView.graphicsItem.sigMaskEdited.connect(\n\t\tlambda:storeMaskData(graphicsView, cmbROIs.currentText(), imageSlider))\n\n\tgraphicsView.sigContextMenuDisplayed.connect(lambda:setButtonsToDefaultStyle(buttonList))\n\n\tgraphicsView.sigReloadImage.connect(lambda:reloadImageInNewImageItem(cmbROIs, graphicsView, pixelDataLabel, \n\t\t\t\t\t\t\t  roiMeanLabel, self, buttonList, btnDraw, btnErase, zoomSlider, \n\t\t\t\t\t\t\t  zoomLabel, imageSlider ))\n\n\tgraphicsView.sigROIDeleted.connect(lambda:deleteROITidyUp(self, cmbROIs, graphicsView, \n\t\t\t  pixelDataLabel, roiMeanLabel, buttonList, btnDraw, btnErase,  \n\t\t\t  zoomSlider, zoomLabel, imageSlider))\n\n\tgraphicsView.sigSetDrawButtonRed.connect(lambda setRed:setDrawButtonColour(setRed, btnDraw, btnErase))\n\n\tgraphicsView.sigSetEraseButtonRed.connect(lambda setRed:setEraseButtonColour(setRed, btnDraw, btnErase))\n\n\tgraphicsView.sigROIChanged.connect(lambda:setButtonsToDefaultStyle(buttonList))\n\tgraphicsView.sigROIChanged.connect(lambda:updateROIName(graphicsView, cmbROIs))\n\tgraphicsView.sigNewROI.connect(lambda newROIName:addNewROItoDropDownList(newROIName, cmbROIs))\n\tgraphicsView.sigUpdateZoom.connect(lambda increment:updateZoomSlider(zoomSlider, zoomLabel, increment))\n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "updateROIName", "data": "def updateROIName(graphicsView, cmbROIs):\n\tlogger.info(\"DisplayImageDrawROI.updateROIName called.\")\n\tgraphicsView.currentROIName = cmbROIs.currentText()\n\t\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "setUpGraphicsView", "data": "def setUpGraphicsView(hbox):\n\ttry:\n\t\tlogger.info(\"DisplayImageDrawROI.setUpGraphicsView called.\")\n\t\tzoomSlider = Slider(Qt.Vertical)\n\t\tzoomLabel = QLabel(\"100%\")\n\t\tgraphicsView = GraphicsView()\n\t\thbox.addWidget(graphicsView)\n\n\t\tzoomSlider.setMinimum(0)\n\t\tzoomSlider.setMaximum(20)\n\t\tzoomSlider.setSingleStep(1)\n\t\tzoomSlider.setTickPosition(QSlider.TicksBothSides)\n\t\tzoomSlider.setTickInterval(1)\n\t\tzoomSlider.valueChanged.connect(lambda: graphicsView.zoomImage(zoomSlider.direction()))\n\n\t\tgroupBoxZoom = QGroupBox('Zoom')\n\t\tlayoutZoom = QVBoxLayout()\n\t\tgroupBoxZoom.setLayout(layoutZoom)\n\t\tlayoutZoom.addWidget(zoomSlider)\n\t\tlayoutZoom.addWidget(zoomLabel)\n\t\thbox.addWidget(groupBoxZoom)\n\t\treturn graphicsView, zoomSlider, zoomLabel\n\texcept Exception as e:\n\t\t\tprint('Error in DisplayImageDrawROI.setUpGraphicsView: ' + str(e))\n\t\t\tlogger.error('Error in DisplayImageDrawROI.setUpGraphicsViewe: ' + str(e))  \n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "displayImageDataUnderMouse", "data": "def displayImageDataUnderMouse(graphicsView, pixelDataLabel):\n\t\tlogger.info(\"DisplayImageDrawROI.displayImageDataUnderMouse called\")\n\t\txCoord = graphicsView.graphicsItem.xMouseCoord\n\t\tyCoord = graphicsView.graphicsItem.yMouseCoord\n\t\tpixelColour = graphicsView.graphicsItem.pixelColour\n\t\tpixelValue = graphicsView.graphicsItem.pixelValue\n\t\tstr =\"Pixel value {}, Pixel colour {} @ X = {}, Y = {}\".format(pixelValue, pixelColour,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  xCoord, yCoord)\n\t\tpixelDataLabel.setText(str)\n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "getRoiMeanAndStd", "data": "def getRoiMeanAndStd(mask, pixelArray):\n\tlogger.info(\"DisplayImageDrawROI.getRoiMeanAndStd called\")\n\tmean = round(np.mean(np.extract(mask, pixelArray)), 3)\n\tstd = round(np.std(np.extract(mask, pixelArray)), 3)\n\treturn mean, std\n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "displayROIMeanAndStd", "data": "def displayROIMeanAndStd(self, roiMeanLabel, graphicsView, cmbROIs, imageSlider=None):\n\t\tlogger.info(\"DisplayImageDrawROI.displayROIMeanAndStd called\")\n\t\tif imageSlider:\n\t\t\timageNumber = imageSlider.value()\n\t\telse:\n\t\t\timageNumber = 1\n\t\tpixelArray = readDICOM_Image.returnPixelArray(self.selectedImagePath)\n\t\tregionName = cmbROIs.currentText()\n\t\tmask = graphicsView.dictROIs.getMask(regionName, imageNumber)\n\t\tif mask is not None:\n\t\t\tmean, std = getRoiMeanAndStd(mask, pixelArray)\n\t\t\tstr =\"ROI mean = {}, standard deviation = {}\".format(mean, std)\n\t\telse:\n\t\t\tstr = \"\"\n\t\troiMeanLabel.setText(str)\n\t\t\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "storeMaskData", "data": "def storeMaskData(graphicsView, regionName, imageSlider=None):\n\t\tlogger.info(\"DisplayImageDrawROI.storeMaskData called\")\n\t\tif imageSlider:\n\t\t\timageNumber = imageSlider.value()\n\t\telse:\n\t\t\timageNumber = 1\n\t\tmask = graphicsView.graphicsItem.getMaskData()\n\t\tgraphicsView.dictROIs.addRegion(regionName, mask, imageNumber)\n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "replaceMask", "data": "def replaceMask(graphicsView, regionName, imageSlider=None):\n\t\tlogger.info(\"DisplayImageDrawROI.replaceMask called\")\n\t\tif imageSlider:\n\t\t\timageNumber = imageSlider.value()\n\t\telse:\n\t\t\timageNumber = 1\n\t\tmask = graphicsView.graphicsItem.getMaskData()\n\t\tgraphicsView.dictROIs.replaceMask(regionName, mask, imageNumber)\n\t\t\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "imageROISliderMoved", "data": "def imageROISliderMoved(self, seriesName, imageList, imageSlider,\n\t\t\t\t\t\tlblImageMissing, pixelDataLabel, roiMeanLabel,\n\t\t\t\t\t\tcmbROIs,  btnDraw, btnErase,\n\t\t\t\t\t\tspinBoxIntensity, spinBoxContrast,  \n\t\t\t\t\t\tgraphicsView, subWindow, buttonList, zoomSlider, zoomLabel):\n\t\t\"\"\"On the Multiple Image with ROI Display sub window, this\n\t\tfunction is called when the image slider is moved. \n\t\tIt causes the next image in imageList to be displayed\"\"\"\n\t\ttry:\n\t\t\tlogger.info(\"DisplayImageDrawROI.imageROISliderMoved called\")\n\t\t\timageNumber = imageSlider.value()\n\n\t\t\tcurrentImageNumber = imageNumber - 1\n\t\t\tif currentImageNumber >= 0:\n\t\t\t\tself.selectedImagePath = imageList[currentImageNumber]\n\t\t\t\t#print(\"imageSliderMoved before={}\".format(self.selectedImagePath))\n\t\t\t\tpixelArray = readDICOM_Image.returnPixelArray(self.selectedImagePath)\n\t\t\t\tsetButtonsToDefaultStyle(buttonList)\n\t\t\t\tif pixelArray is None:\n\t\t\t\t\tlblImageMissing.show()\n\t\t\t\t\tgraphicsView.setImage(np.array([[0,0,0],[0,0,0]]))\n\t\t\t\telse:\n\t\t\t\t\treloadImageInNewImageItem(cmbROIs, graphicsView, pixelDataLabel, \n\t\t\t\t\t\t\t  roiMeanLabel, self, buttonList, btnDraw, btnErase, zoomSlider, \n\t\t\t\t\t\t\t  zoomLabel, imageSlider) \n\t\t\t\t\tspinBoxIntensity.blockSignals(True)\n\t\t\t\t\tspinBoxIntensity.setValue(graphicsView.graphicsItem.intensity)\n\t\t\t\t\tspinBoxIntensity.blockSignals(False)\n\t\t\t\t\tspinBoxContrast.blockSignals(True)\n\t\t\t\t\tspinBoxContrast.setValue(graphicsView.graphicsItem.contrast)\n\t\t\t\t\tspinBoxContrast.blockSignals(False)\n\t\t\t\t\tsetUpImageEventHandlers(self, graphicsView, pixelDataLabel, \n\t\t\t\t\t\t\t\t\t\t\tbtnDraw, btnErase,\n\t\t\t\t\t\t\t\t\t\t\troiMeanLabel, cmbROIs, buttonList,\n\t\t\t\t\t\t\t\t\t\t\tzoomSlider, zoomLabel,\n\t\t\t\t\t\t\t\t\t\t imageSlider)\n\n\t\t\t\tsubWindow.setWindowTitle(seriesName + ' - ' \n\t\t\t\t\t\t + os.path.basename(self.selectedImagePath))\n\t\t\t   # print(\"imageSliderMoved after={}\".format(self.selectedImagePath))\n\t\texcept Exception as e:\n\t\t\tprint('Error in DisplayImageDrawROI.imageROISliderMoved: ' + str(e))\n\t\t\tlogger.error('Error in DisplayImageDrawROI.imageROISliderMoved: ' + str(e))\n\n", "description": "On the Multiple Image with ROI Display sub window, this\n\t\tfunction is called when the image slider is moved. \n\t\tIt causes the next image in imageList to be displayed", "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "reloadImageInNewImageItem", "data": "def reloadImageInNewImageItem(cmbROIs, graphicsView, pixelDataLabel, \n\t\t\t\t\t\t\t  roiMeanLabel, self, buttonList, \n\t\t\t\t\t\t\t  btnDraw, btnErase, zoomSlider, zoomLabel,\n\t\t\t\t\t\t\t  imageSlider=None ):\n\ttry:\n\t\tlogger.info(\"DisplayImageDrawROI.reloadImageInNewImageItem called\")\n\t\tgraphicsView.dictROIs.setPreviousRegionName(cmbROIs.currentText())\n\n\t\tif imageSlider:\n\t\t\timageNumber = imageSlider.value()\n\t\telse:\n\t\t\timageNumber = 1\n\n\t\tpixelArray = readDICOM_Image.returnPixelArray(self.selectedImagePath)\n\t\tmask = graphicsView.dictROIs.getMask(cmbROIs.currentText(), imageNumber)\n\t\tgraphicsView.setImage(pixelArray, mask)\n\t\tpixelDataLabel.setText(\"Pixel Data:\") \n\t\troiMeanLabel.setText(\"ROI Mean Value:\") \n\t\tsetUpImageEventHandlers(self, graphicsView, pixelDataLabel, \n\t\t\t\t\t\t\t\tbtnDraw, btnErase, roiMeanLabel,\n\t\t\t\t\t\t\t\t\t cmbROIs, buttonList, zoomSlider, zoomLabel, imageSlider)\n\texcept Exception as e:\n\t\t   print('Error in DisplayImageDrawROI.reloadImageInNewImageItem: ' + str(e))\n\t\t   logger.error('Error in DisplayImageDrawROI.reloadImageInNewImageItem: ' + str(e))\n\t\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "deleteROITidyUp", "data": "def deleteROITidyUp(self, cmbROIs, graphicsView, \n\t\t\t  pixelDataLabel, roiMeanLabel, buttonList, btnDraw, btnErase, zoomSlider,\n\t\t\t  zoomLabel, imageSlider=None):\n\tlogger.info(\"DisplayImageDrawROI.deleteROITidyUp called\")\n\t\n\treloadImageInNewImageItem(cmbROIs, graphicsView, pixelDataLabel, \n\t\t\t\t\t\t\t  roiMeanLabel, self, buttonList, btnDraw, btnErase, zoomSlider,\n\t\t\t\t\t\t\t zoomLabel, imageSlider) \n\tdisplayROIMeanAndStd(self, roiMeanLabel, graphicsView, cmbROIs, imageSlider)\n\tif cmbROIs.currentIndex() == 0 and cmbROIs.count() == 1: \n\t\tcmbROIs.clear()\n\t\tcmbROIs.addItem(\"region1\")\n\t\tcmbROIs.setCurrentIndex(0) \n\t\tpixelDataLabel.clear()\n\t\troiMeanLabel.clear()\n\telse:\n\t\tif imageSlider:\n\t\t\timageNumber = imageSlider.value()\n\t\telse:\n\t\t\timageNumber = 1\n\t\tcmbROIs.blockSignals(True)\n\t\tcmbROIs.removeItem(cmbROIs.currentIndex())\n\t\tcmbROIs.blockSignals(False)\n\t\tmask = graphicsView.dictROIs.getMask(cmbROIs.currentText(), imageNumber)\n\t\tgraphicsView.graphicsItem.reloadMask(mask)\n \n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "loadROI", "data": "def loadROI(self, cmbROIs, graphicsView):\n\ttry:\n\t\tlogger.info(\"DisplayImageDrawROI.loadROI called\")\n\t\t# The following workflow is assumed:\n\t\t#   1. The user first loads a series of DICOM images\n\t\t#   2. Then the user loads the series of ROIs that are superimposed upon the images\n\n\t\t# Prompt Windows to select Series\n\t\t# paramDict = {\"Series\":\"dropdownlist\"}\n\t\tparamDict = {\"Series\":\"listview\"}\n\t\thelpMsg = \"Select a Series with ROI\"\n\t\tstudyID = self.selectedStudy\n\t\tstudy = self.objXMLReader.getStudy(studyID)\n\t\tlistSeries = [series.attrib['id'] for series in study] # if 'ROI' in series.attrib['id']]\n\t\tinputDlg = inputDialog.ParameterInputDialog(paramDict, title= \"Load ROI\", helpText=helpMsg, lists=[listSeries])\n\t\tlistParams = inputDlg.returnListParameterValues()\n\t\tif inputDlg.closeInputDialog() == False:\n\t\t\t# for series ID in listParams[0]: # more than 1 ROI may be selected\n\t\t\tseriesID = listParams[0][0] # Temporary, only the first ROI\n\t\t\timagePathList = self.objXMLReader.getImagePathList(studyID, seriesID)\n\t\t\tmaskList = []\n\t\t\t# Consider DICOM Tag SegmentSequence[:].SegmentLabel as some 3rd software do\n\t\t\tif hasattr(readDICOM_Image.getDicomDataset(imagePathList[0]), \"ContentDescription\"):\n\t\t\t\tregion = readDICOM_Image.getSeriesTagValues(imagePathList, \"ContentDescription\")[0][0]\n\t\t\telse:\n\t\t\t\tregion = \"new_region_number\"\n\n\t\t\t# Affine re-adjustment\n\t\t\t# It takes longer to load with this, so we could do an if/else involving Affine\n\t\t\tfor dicomFile in self.imageList:\n\t\t\t\tdataset_original = readDICOM_Image.getDicomDataset(dicomFile)\n\t\t\t\ttempArray = np.zeros(np.shape(readDICOM_Image.getPixelArray(dataset_original)))\n\t\t\t\tfor maskFile in imagePathList:\n\t\t\t\t\tdataset = readDICOM_Image.getDicomDataset(maskFile)\n\t\t\t\t\tmaskArray = readDICOM_Image.getPixelArray(dataset)\n\t\t\t\t\tmaskArray[maskArray != 0] = 1\n\t\t\t\t\taffineResults = readDICOM_Image.mapMaskToImage(maskArray, dataset, dataset_original)\n\t\t\t\t\tfor coordinates in affineResults:\n\t\t\t\t\t\ttempArray[coordinates] = 1\n\t\t\t\t\t#tempArray = np.add(tempArray, np.transpose(affineResults))\n\t\t\t\t#np.where(tempArray > 1, tempArray, 1)\n\t\t\t\tmaskList.append(tempArray)\n\n\t\t\t# First populate the ROI_Storage data structure in a loop\n\t\t\tfor imageNumber in range(len(maskList)):\n\t\t\t\tgraphicsView.dictROIs.addRegion(region, np.array(maskList[imageNumber]).astype(bool), imageNumber + 1)\n\n\t\t\t# Second populate the dropdown list of region names\n\t\t\tcmbROIs.blockSignals(True)\n\t\t\t#remove previous contents of ROI dropdown list\n\t\t\tcmbROIs.clear()  \n\t\t\tcmbROIs.addItems(graphicsView.dictROIs.getListOfRegions())\n\t\t\tcmbROIs.blockSignals(False)\n\n\t\t\t# Redisplay the current image to show the mask\n\t\t\tmask = graphicsView.dictROIs.getMask(region, 1)\n\t\t\tgraphicsView.graphicsItem.reloadMask(mask)\n\t\t\n\texcept Exception as e:\n\t\t\tprint('Error in DisplayImageDrawROI.loadROI: ' + str(e))\n\t\t\tlogger.error('Error in DisplayImageDrawROI.loadROI: ' + str(e)) \n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "saveROI", "data": "def saveROI(self, regionName, graphicsView):\n\ttry:\n\t\t# Save Current ROI\n\t\tlogger.info(\"DisplayImageDrawROI.saveROI called\")\n\t\tmaskList = graphicsView.dictROIs.dictMasks[regionName] # Will return a list of boolean masks\n\t\tmaskList = [np.array(mask, dtype=np.int) for mask in maskList] # Convert each 2D boolean to 0s and 1s\n\t\tsuffix = str(\"_ROI_\"+ regionName)\n\t\tif len(maskList) > 1:\n\t\t\tinputPath = self.imageList\n\t\telse:\n\t\t\tinputPath = [self.selectedImagePath]\n\t\t# Saving Progress message\n\t\tmessageWindow.displayMessageSubWindow(self,\n\t\t\t\"Saving ROIs into a new DICOM Series ({} files)\".format(len(inputPath)),\n\t\t\t\"Export ROIs\")\n\t\tmessageWindow.setMsgWindowProgBarMaxValue(self, len(inputPath))\n\t\tids = saveDICOM_Image.generateUIDs(readDICOM_Image.getDicomDataset(inputPath[0]))\n\t\tseriesID = ids[0]\n\t\tseriesUID = ids[1]\n\t\t#outputPath = []\n\t\t#for image in inputPath:\n\t\tfor index, path in enumerate(inputPath):\n\t\t\t#outputPath.append(saveDICOM_Image.returnFilePath(image, suffix))\n\t\t\tmessageWindow.setMsgWindowProgBarValue(self, index)\n\t\t\toutputPath = saveDICOM_Image.returnFilePath(path, suffix)\n\t\t\tsaveDICOM_Image.saveNewSingleDicomImage(outputPath, path, maskList[index], suffix, series_id=seriesID, series_uid=seriesUID, parametric_map=\"SEG\")\n\t\t\ttreeSeriesID = interfaceDICOMXMLFile.insertNewImageInXMLFile(self, path, outputPath, suffix)\n\t\t#saveDICOM_Image.saveDicomNewSeries(outputPath, inputPath, maskList, suffix, parametric_map=\"SEG\") # Consider Enhanced DICOM for parametric_map\n\t\t#seriesID = interfaceDICOMXMLFile.insertNewSeriesInXMLFile(self, inputPath, outputPath, suffix)\n\t\tmessageWindow.setMsgWindowProgBarValue(self, len(inputPath))\n\t\tmessageWindow.closeMessageSubWindow(self)\n\t\ttreeView.refreshDICOMStudiesTreeView(self, newSeriesName=treeSeriesID)\n\t\tQMessageBox.information(self, \"Export ROIs\", \"Image Saved\")\n\texcept Exception as e:\n\t\t\tprint('Error in DisplayImageDrawROI.saveROI: ' + str(e))\n\t\t\tlogger.error('Error in DisplayImageDrawROI.saveROI: ' + str(e)) \n\n\t# Save all ROIs\n\t#for label, mask in dictROIs.dictMasks.items():\n\n\t# Test Affine\n\t#inputPath1 = ['C:\\\\Users\\\\md1jgra\\\\Desktop\\\\Joao-3-scanners-2019\\\\test-affine\\\\1.2.840.113619.6.408.218238138221875479893414809240658168986-15-1-test.dcm']\n\t#outputPath = ['C:\\\\Users\\\\md1jgra\\\\Desktop\\\\Joao-3-scanners-2019\\\\test-affine\\\\1.2.840.113619.6.408.218238138221875479893414809240658168986-15-1-test-mask.dcm']\n\t#newMask = []\n\t#for index, file in enumerate(inputPath1):\n\t#\tdataset = readDICOM_Image.getDicomDataset(file)\n\t#\tdataset_original = readDICOM_Image.getDicomDataset(inputPath[index])\n\t#\tnewMask.append(readDICOM_Image.mapMaskToImage(maskList[index], dataset, dataset_original))\n\t#saveDICOM_Image.saveDicomNewSeries(outputPath, inputPath1, newMask, suffix, parametric_map=\"SEG\")\n\t#seriesID = interfaceDICOMXMLFile.insertNewSeriesInXMLFile(self, inputPath1, outputPath, suffix)\n\t#treeView.refreshDICOMStudiesTreeView(self, newSeriesName=seriesID)\n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "roiNameChanged", "data": "def roiNameChanged(cmbROIs, graphicsView, newText):\n\ttry:\n\t\tlogger.info(\"DisplayImageDrawROI.roiNameChanged called\")\n\t\tcurrentIndex = cmbROIs.currentIndex()\n\t\t#Prevent spaces in new ROI name\n\t\tif ' ' in newText:\n\t\t\tnewText = newText.replace(\" \", \"\")\n\t\t\tprint(\"newText={}\".format(newText))\n\t\t\tcmbROIs.setItemText(currentIndex, newText)\n\t\t\tcmbROIs.setCurrentText(newText)\n\t\tindex = cmbROIs.findText(newText);\n\t\tif index == -1:\n\t\t\tcmbROIs.setItemText(currentIndex, newText);\n\t\t\tnameChangedOK = graphicsView.dictROIs.renameDictionaryKey(newText)\n\t\t\t#dictROIs.printContentsDictMasks()\n\t\t\tif nameChangedOK == False:\n\t\t\t\tmsgBox = QMessageBox()\n\t\t\t\tmsgBox.setWindowTitle(\"ROI Name Change\")\n\t\t\t\tmsgBox.setText(\"This name is already in use\")\n\t\t\t\tmsgBox.exec()\n\t\t\t\tcmbROIs.setCurrentText(graphicsView.dictROIs.prevRegionName)\n\texcept Exception as e:\n\t\t\tprint('Error in DisplayImageDrawROI.roiNameChanged: ' + str(e))\n\t\t\tlogger.error('Error in DisplayImageDrawROI.roiNameChanged: ' + str(e)) \n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "updateZoomSlider", "data": "def updateZoomSlider(zoomSlider, zoomLabel, increment):\n\tlogger.info(\"DisplayImageDrawRIO.updateZoomSlider called\")\n\t#print(\"updateZoomSlider increment={}\".format(increment))\n\tzoomSlider.blockSignals(True)\n\tif increment == 0:\n\t\tzoomSlider.setValue(0)\n\t\tzoomLabel.setText(\"100%\")\n\telse:\n\t\tnewValue = zoomSlider.value() + increment\n\t\tnewZoomValue = 100 + (newValue * 25)\n\t\tzoomLabel.setText(\"\" + str(newZoomValue) + \"%\")\n\t\tif zoomSlider.value() < zoomSlider.maximum() and increment > 0:\n\t\t\tzoomSlider.setValue(newValue)\n\t\telif zoomSlider.value() > zoomSlider.minimum() and increment < 0:\n\t\t\tzoomSlider.setValue(newValue)\n\tzoomSlider.blockSignals(False)\n\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "displayImageROISubWindow", "data": "def displayImageROISubWindow(self, derivedImagePath=None):\n\t\"\"\"\n\tCreates a subwindow that displays one DICOM image and allows the creation of an ROI on it \n\t\"\"\"\n\ttry:\n\t\tlogger.info(\"DisplayImageDrawROI displayImageROISubWindow called\")\n\t\tpixelArray = readDICOM_Image.returnPixelArray(self.selectedImagePath)\n\t\t\n\t\thbox, layout, lblImageMissing, subWindow = setUpGraphicsViewSubWindow(self)\n\t\twindowTitle = displayImageCommon.getDICOMFileData(self)\n\t\tsubWindow.setWindowTitle(windowTitle)\n\n\t\tgraphicsView, zoomSlider, zoomLabel = setUpGraphicsView(hbox)\n\n\t \n\t\tpixelDataLabel, roiMeanLabel = setPixelDataLabels(layout)\n\t\t(cmbROIs, buttonList, \n\t\t\tbtnDraw, btnErase) = setUpROIButtons(self, layout, pixelDataLabel, roiMeanLabel, graphicsView, zoomSlider, zoomLabel)\n\t\t   \n\t\tspinBoxIntensity, spinBoxContrast = setUpLevelsSpinBoxes(layout, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgraphicsView, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcmbROIs)\n\t\tif pixelArray is None:\n\t\t\tlblImageMissing.show()\n\t\t\tgraphicsView.setImage(np.array([[0,0,0],[0,0,0]]))  \n\t\telse:\n\t\t\tgraphicsView.setImage(pixelArray)\n\n\t\tspinBoxIntensity.blockSignals(True)\n\t\tspinBoxIntensity.setValue(graphicsView.graphicsItem.intensity)\n\t\tspinBoxIntensity.blockSignals(False)\n\t\tspinBoxContrast.blockSignals(True)\n\t\tspinBoxContrast.setValue(graphicsView.graphicsItem.contrast)\n\t\tspinBoxContrast.blockSignals(False)\n\t\t\t\n\t\tsetUpImageEventHandlers(self, graphicsView, pixelDataLabel, \n\t\t\t\t\t\t\t\t\t\tbtnDraw, btnErase,\n\t\t\t\t\t\t\t\t\t\troiMeanLabel, cmbROIs, buttonList,\n\t\t\t\t\t\t\t\t\t\tzoomSlider, zoomLabel)\n\t   \n\t\t\n\texcept (IndexError, AttributeError):\n\t\t\tsubWindow.close()\n\t\t\tmsgBox = QMessageBox()\n\t\t\tmsgBox.setWindowTitle(\"View a DICOM series or image with an ROI\")\n\t\t\tmsgBox.setText(\"Select either a series or an image\")\n\t\t\tmsgBox.exec()\n\texcept Exception as e:\n\t\tprint('Error in DisplayImageDrawROI.displayImageROISubWindow: ' + str(e))\n\t\tlogger.error('Error in DisplayImageDrawROI.displayImageROISubWindow: ' + str(e)) \n\n", "description": "\n\tCreates a subwindow that displays one DICOM image and allows the creation of an ROI on it \n\t", "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}, {"term": "def", "name": "displayMultiImageROISubWindow", "data": "def displayMultiImageROISubWindow(self, imageList, studyName, \n\t\t\t\t\t seriesName, sliderPosition = -1):\n\t\t\"\"\"\n\t\tCreates a subwindow that displays all the DICOM images in a series. \n\t\tA slider allows the user to navigate  through the images.  \n\t\tThe user may create an ROI on the series of images.\n\t\t\"\"\"\n\t\ttry:\n\t\t\tlogger.info(\"DisplayImageDrawROI.displayMultiImageROISubWindow called\")\n\t\t\thbox, layout, lblImageMissing, subWindow = setUpGraphicsViewSubWindow(self)\n\t\t\t\n\t\t\timageSlider = QSlider(Qt.Horizontal)\n\t\t\timageSlider.setMinimum(1)\n\t\t\timageSlider.setMaximum(len(imageList))\n\t\t\tif sliderPosition == -1:\n\t\t\t\timageSlider.setValue(1)\n\t\t\telse:\n\t\t\t\timageSlider.setValue(sliderPosition)\n\t\t\timageSlider.setSingleStep(1)\n\t\t\timageSlider.setTickPosition(QSlider.TicksBothSides)\n\t\t\timageSlider.setTickInterval(1)\n\n\t\t\tgraphicsView, zoomSlider, zoomLabel = setUpGraphicsView(hbox)\n\t\t\tgraphicsView.dictROIs = ROIs(NumImages=len(imageList))\n\t\t\tpixelDataLabel, roiMeanLabel = setPixelDataLabels(layout)\n\t\t\tcmbROIs, buttonList, btnDraw, btnErase = setUpROIButtons(self, layout, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpixelDataLabel, roiMeanLabel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgraphicsView, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tzoomSlider, zoomLabel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageSlider)\n\t\t\tspinBoxIntensity, spinBoxContrast = setUpLevelsSpinBoxes(layout, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t graphicsView, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t cmbROIs, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t imageSlider)\n\n\t\t\tlayout.addWidget(imageSlider)\n\t\t\timageSlider.valueChanged.connect(\n\t\t\t\t  lambda: imageROISliderMoved(self, seriesName, \n\t\t\t\t\t\t\t\t\t\t\t\t   imageList, \n\t\t\t\t\t\t\t\t\t\t\t\t   imageSlider,\n\t\t\t\t\t\t\t\t\t\t\t\t   lblImageMissing, pixelDataLabel,\n\t\t\t\t\t\t\t\t\t\t\t\t   roiMeanLabel, cmbROIs,\n\t\t\t\t\t\t\t\t\t\t\t\t   btnDraw, btnErase,\n\t\t\t\t\t\t\t\t\t\t\t\t   spinBoxIntensity, \n\t\t\t\t\t\t\t\t\t\t\t\t   spinBoxContrast,\n\t\t\t\t\t\t\t\t\t\t\t\t   graphicsView, subWindow, buttonList, zoomSlider,\n\t\t\t\t\t\t\t\t\t\t\t\t   zoomLabel))\n\t\t  \n\t\t\timageROISliderMoved(self, seriesName, \n\t\t\t\t\t\t\t\t\timageList, \n\t\t\t\t\t\t\t\t\timageSlider,\n\t\t\t\t\t\t\t\t\tlblImageMissing, \n\t\t\t\t\t\t\t\t\tpixelDataLabel, \n\t\t\t\t\t\t\t\t\troiMeanLabel, cmbROIs,\n\t\t\t\t\t\t\t\t\tbtnDraw, btnErase,\n\t\t\t\t\t\t\t\t\tspinBoxIntensity, \n\t\t\t\t\t\t\t\t\tspinBoxContrast,\n\t\t\t\t\t\t\t\t\tgraphicsView, subWindow, buttonList, zoomSlider, zoomLabel)\t   \n\t\texcept (IndexError, AttributeError):\n\t\t\t\tsubWindow.close()\n\t\t\t\tmsgBox = QMessageBox()\n\t\t\t\tmsgBox.setWindowTitle(\"View a DICOM series or image with an ROI\")\n\t\t\t\tmsgBox.setText(\"Select either a series or an image\")\n\t\t\t\tmsgBox.exec()\t\n\t\texcept Exception as e:\n\t\t\tprint('Error in displayMultiImageROISubWindow: ' + str(e))\n", "description": "\n\t\tCreates a subwindow that displays all the DICOM images in a series. \n\t\tA slider allows the user to navigate  through the images.  \n\t\tThe user may create an ROI on the series of images.\n\t\t", "category": "graphics", "imports": ["from PyQt5 import QtCore ", "from PyQt5 import QtWidgets", "from PyQt5.QtGui import QPixmap, QIcon, QCursor", "from PyQt5.QtCore import (Qt, pyqtSignal)", "from PyQt5.QtWidgets import (QApplication,", "import os", "import scipy", "import matplotlib.pyplot as plt", "from matplotlib import cm", "import numpy as np", "import CoreModules.WEASEL.styleSheet as styleSheet", "import CoreModules.WEASEL.readDICOM_Image as readDICOM_Image", "import CoreModules.WEASEL.saveDICOM_Image as saveDICOM_Image", "import CoreModules.WEASEL.TreeView  as treeView", "import CoreModules.WEASEL.DisplayImageCommon as displayImageCommon", "import CoreModules.WEASEL.MessageWindow as messageWindow", "import CoreModules.WEASEL.InputDialog as inputDialog", "import CoreModules.WEASEL.InterfaceDICOMXMLFile as interfaceDICOMXMLFile", "from CoreModules.freeHandROI.GraphicsView import GraphicsView", "from CoreModules.freeHandROI.ROI_Storage import ROIs ", "#import gc", "import logging"]}], [], [], [{"term": "class", "name": "classPath:", "data": "class Path:\n\t# PATH VARS\n\tFONT_PATH = os.path.join('assets', 'fonts')\n\tEXPLOSION_PATH = os.path.join('assets', 'graphics', 'explosion')\n\tGRAPHICS_PATH = os.path.join('assets', 'graphics')\n\tSOUND_PATH = os.path.join('assets', 'sounds')\n\n\t# load music\n\tGAME_MUSIC_PATH = resource_path(os.path.join(SOUND_PATH, 'ingame.wav'))\n\tMENU_MUSIC_PATH = resource_path(os.path.join(SOUND_PATH, 'menu.wav'))\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "import os", "from utils.resource_path import resource_path", "from utils.assets import Assets"]}, {"term": "class", "name": "classFont:", "data": "class Font:\n\t# FONT VARS\n\tedit_undo_font = Assets.font.load(Path.FONT_PATH, 'edit_undo.ttf')\n\tneue_font = Assets.font.load(Path.FONT_PATH, 'neue.ttf')\n\tkarmatic_arcade_font = Assets.font.load(\n\t\tPath.FONT_PATH, 'karmatic_arcade.ttf')\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "import os", "from utils.resource_path import resource_path", "from utils.assets import Assets"]}, {"term": "class", "name": "classImage:", "data": "class Image:\n\tTITLE_LOGO = Assets.image.scale(Path.GRAPHICS_PATH, 'title_logo.png', 2/7)\n\n\t# Load Enemy Ships\n\tEASY_SPACE_SHIP = Assets.image.load(Path.GRAPHICS_PATH, 'easy.png')\n\tMEDIUM_SPACE_SHIP = Assets.image.load(Path.GRAPHICS_PATH, 'medium.png')\n\tHARD_SPACE_SHIP = Assets.image.load(Path.GRAPHICS_PATH, 'hard.png')\n\tBOSS_SHIP = Assets.image.load(Path.GRAPHICS_PATH, 'boss.png')\n\n\tUFO_SPACE_SHIP = Assets.image.scale(Path.GRAPHICS_PATH, 'ufo.png', 1/7)\n\n\t# Load Player\n\tPLAYER_SPACE_SHIP = Assets.image.load(\n\t\tPath.GRAPHICS_PATH, 'retro-spaceship.png')\n\tPLAYER_LASER = Assets.image.load(\n\t\tPath.GRAPHICS_PATH, 'pixel_laser_cosmic.png')\n\n\t# Load Lasers\n\tRED_LASER = Assets.image.load(Path.GRAPHICS_PATH, 'pixel_laser_red.png')\n\tBLUE_LASER = Assets.image.load(Path.GRAPHICS_PATH, 'pixel_laser_blue.png')\n\tGREEN_LASER = Assets.image.load(\n\t\tPath.GRAPHICS_PATH, 'pixel_laser_green.png')\n\tFLAME_LASER = Assets.image.load(\n\t\tPath.GRAPHICS_PATH, 'pixel_laser_flame.png')\n\n\t# Load audio image\n\tVOL_ICON = Assets.image.load(Path.GRAPHICS_PATH, 'audio.png')\n\tMUTE_ICON = Assets.image.load(Path.GRAPHICS_PATH, 'mute.png')\n\n\tDEMON_ICON = Assets.image.scale(Path.GRAPHICS_PATH, 'demon.png', 1/11)\n\n\t# Screen Images\n\tCONTROL_IMAGE = Assets.image.load(Path.GRAPHICS_PATH, 'joystick.png')\n\tTROPHY_IMAGE = Assets.image.load(Path.GRAPHICS_PATH, 'trophy.png')\n\tSHIPS_IMAGE = Assets.image.scale(Path.GRAPHICS_PATH, 'medium.png', 5/6)\n\tSHIPS_IMAGE_2 = Assets.image.scale(Path.GRAPHICS_PATH, 'hard.png', 3/4)\n\tTOOLBOX_IMAGE = Assets.image.scale(Path.GRAPHICS_PATH, 'toolbox.png', 1/2)\n\n\tTOOLS_IMAGE = Assets.image.scale(Path.GRAPHICS_PATH, 'tools.png', 1/4)\n\tTOOLS_IMAGE = pygame.transform.rotate(TOOLS_IMAGE, -45)\n\n\tGO_BACK_IMAGE = Assets.image.scale(\n\t\tPath.GRAPHICS_PATH, 'back_arrow.png', 6/25)\n\n\tEXIT_IMAGE = Assets.image.scale(Path.GRAPHICS_PATH, 'exit_button.png', 1/3)\n\n\t# Other Images\n\tHEART_IMAGE = Assets.image.scale(Path.GRAPHICS_PATH, 'heart.png', 1)\n\tSTAR_IMAGE = Assets.image.scale(Path.GRAPHICS_PATH, 'star.png', 1/4)\n\tSKULL_IMAGE = Assets.image.scale(Path.GRAPHICS_PATH, 'skull.png', 1/58)\n\tSKULL_IMAGE_2 = Assets.image.scale(Path.GRAPHICS_PATH, 'skull.png', 1/54)\n\tWON_IMAGE = Assets.image.scale(Path.GRAPHICS_PATH, 'won.png', 5/20)\n\n\tPLUS_IMAGE = Assets.image.scale(Path.GRAPHICS_PATH, 'plus.png', 1/6)\n\tMINUS_IMAGE = Assets.image.scale(Path.GRAPHICS_PATH, 'minus.png', 1/6)\n\n\tPAUSE_IMAGE = Assets.image.scale(Path.GRAPHICS_PATH, 'pause.png', 2/7)\n\tPLAY_IMAGE = Assets.image.scale(Path.GRAPHICS_PATH, 'play.png', 2/7)\n\tPLAY_IMAGE_2 = Assets.image.scale(Path.GRAPHICS_PATH, 'play.png', 1/2.9)\n\n\tHOME_IMAGE = Assets.image.scale(Path.GRAPHICS_PATH, 'home.png', 2/5)\n\tNEXT_IMAGE = Assets.image.scale(Path.GRAPHICS_PATH, 'next_button.png', 1/3)\n\tBACK_IMAGE = Assets.image.scale(Path.GRAPHICS_PATH, 'back_button.png', 1/3)\n\tLEVELS_IMAGE = Assets.image.scale(\n\t\tPath.GRAPHICS_PATH, 'levels_button.png', 1/3)\n\tSCORE_IMAGE = Assets.image.scale(\n\t\tPath.GRAPHICS_PATH, 'score_button.png', 1/3)\n\tKILLS_IMAGE = Assets.image.scale(\n\t\tPath.GRAPHICS_PATH, 'kills_button.png', 1/3)\n\n\tMOUSE = Assets.image.scale(Path.GRAPHICS_PATH, 'mouse.png', 1/2)\n\tLEFT_MOUSE_CLICK = Assets.image.scale(\n\t\tPath.GRAPHICS_PATH, 'left_click_mouse.png', 1/2)\n\tRIGHT_MOUSE_CLICK = Assets.image.scale(\n\t\tPath.GRAPHICS_PATH, 'right_click_mouse.png', 1/2)\n\n\tWASD_KEYS = Assets.image.scale(Path.GRAPHICS_PATH, 'wasd_keys.png', 1/2)\n\tARROW_KEYS = Assets.image.scale(Path.GRAPHICS_PATH, 'arrow_keys.png', 1/2)\n\tBACKSPACE_KEY = Assets.image.scale(\n\t\tPath.GRAPHICS_PATH, 'backspace_key.png', 1/2)\n\tSPACEBAR_KEY = Assets.image.scale(\n\t\tPath.GRAPHICS_PATH, 'spacebar_key.png', 1/2)\n\tPLUS_KEY = Assets.image.scale(Path.GRAPHICS_PATH, 'plus_key.png', 1/2)\n\tMINUS_KEY = Assets.image.scale(Path.GRAPHICS_PATH, 'minus_key.png', 1/2)\n\tP_KEY = Assets.image.scale(Path.GRAPHICS_PATH, 'p_key.png', 1/2)\n\tF_KEY = Assets.image.scale(Path.GRAPHICS_PATH, 'f_key.png', 1/2)\n\tM_KEY = Assets.image.scale(Path.GRAPHICS_PATH, 'mute_key.png', 1/2)\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "import os", "from utils.resource_path import resource_path", "from utils.assets import Assets"]}, {"term": "class", "name": "classSound:", "data": "class Sound:\n\tPLAYER_LASER_SOUND = Assets.sound.load(Path.SOUND_PATH, 'ownlaser.wav')\n\tENEMY_LASER_SOUND = Assets.sound.load(Path.SOUND_PATH, 'enemylaser.wav')\n\tEXPLODE_SOUND = Assets.sound.load(Path.SOUND_PATH, 'explode.wav')\n\tLASER_HIT_SOUND = Assets.sound.load(Path.SOUND_PATH, 'laser_hit.wav')\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "import os", "from utils.resource_path import resource_path", "from utils.assets import Assets"]}, {"term": "class", "name": "classColors:", "data": "class Colors:\n\tWHITE = (255, 255, 255)\n\tBLACK = (0, 0, 0)\n\tBACKGROUND_BLACK = (7, 8, 16)\n\tBLUE = (0, 0, 255)\n\tGREEN = (0, 255, 0)\n\tGREEN2 = (0, 209, 0)\n\tRED = (255, 0, 0)\n\tYELLOW = (255, 255, 0)\n\tCYAN = (0, 255, 255)\n\tMAGENTA = (255, 0, 255)\n\tPURPLE = (131, 1, 123)\n\tORANGE = (238, 98, 17)\n\tGREY = (200, 200, 200)\n\tTRANS = (1, 1, 1)\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "import os", "from utils.resource_path import resource_path", "from utils.assets import Assets"]}, {"term": "class", "name": "classText:", "data": "class Text:\n\tSHIPS = 'SHIPS'\n\tSETTINGS = 'SETTINGS'\n\tCONTROLS = 'CONTROLS'\n\tSCOREBOARD = 'SCOREBOARD'\n", "description": null, "category": "graphics", "imports": ["import pygame", "import os", "from utils.resource_path import resource_path", "from utils.assets import Assets"]}], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, **kargs):\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [{"term": "class", "name": "spritedb", "data": "class spritedb(object):\n\t\"\"\" The sprite database is a database of all known Xargon sprites.\n\tIt provides a lookup from the sprite ID and sub-id to the correct\n\tsprite type.\n\t\"\"\"\n\n\tdef addsprite(self, sprtype, subtype, sprite):\n\t\t\"\"\" Adds a sprite into the database. Creates the applicable\n\t\tsub-list as needed.\n\n\t\tsprtype -- the sprite type number (from the map object record)\n\t\tsubtype -- the sprite sub-type number (also from the map object record)\n\t\tsprite -- a sprite object describing how to draw this sprite.\n\t\t\"\"\"\n\t\tif sprtype not in self.sprites:\n\t\t\tself.sprites[sprtype] = {}\n\t\tself.sprites[sprtype][subtype] = sprite\n\n\tdef __init__(self, graphics, epnum):\n\t\t\"\"\" Loads the sprite database according to the provided\n\t\tgraphics file and episode number.\n\t\t\"\"\"\n\t\tself.sprites = {}\n\n\t\t# Manually-defined sprites (i.e. special handling needed\n\t\tself.addsprite(0, 4, sprite(graphics.records[6].images[9], yoffs=-8)) # Player\n\n\t\t# Keys and Locks:\n\t\tfor i in range (4):\n\t\t\tself.addsprite(9, i, sprite(graphics.records[31].images[32+i],\n\t\t\t\txoffs=6, yoffs=8, hidelabel=True)) # Lock\n\t\t\tself.addsprite(20, i, sprite(graphics.records[31].images[i*8])) # Key\n\n\t\t# Text sprites:\n\t\tself.addsprite(6, 0, textsprite(ImageFont.load(\"font2.pil\"), graphics))\n\t\tself.addsprite(7, 0, textsprite(ImageFont.load(\"font1.pil\"), graphics))\n\n\t\t# Variant of Compound and semi-transparent for hidden platform(s)\n\t\tself.addsprite(11, 0, variablesprite({\n\t\t\t2: graphics.semitransparent(\n\t\t\t   graphics.compositeimage((16, 32), [(0, 0, 8, 18),\n\t\t\t   (0, 16, 8, 21)]), 128),\n\t\t\t4: graphics.semitransparent(\n\t\t\t   graphics.compositeimage((48, 32), [(0, 0, 11, 1),\n\t\t\t   (16, 0, 11, 1), (0, 16, 11, 2), (16, 16, 11, 2),\n\t\t\t   (32, 0, 11, 19), (32, 16, 11, 19)]), 128),\n\t\t\t6: graphics.semitransparent(\n\t\t\t   graphics.compositeimage((32, 16), [(0, 0, 25, 14),\n\t\t\t   (16, 0, 25, 15)]), 128),\n\t\t\t7: graphics.semitransparent(\n\t\t\t   graphics.compositeimage((32, 16), [(0, 0, 51, 10),\n\t\t\t   (16, 0, 51, 11)]), 128) }\n\t\t\t ))\n\n\t\t# Simple sprite mapping. Stage sprites, then Map sprites\n\t\tfor (sprtype, subtype, recnum, imagenum) in [(0, 0, 6, 10), # Menu Player\n\t\t\t\t(4, 0, 40, 20), # Mine\n\t\t\t\t(16, 0, 36, 13), (16, 1, 36, 13), # Elevator Platform\n\t\t\t\t(18, 0, 36, 0), # Manual Elevator\n\t\t\t\t(21, 0, 37, 33), # Health Pickup\n\t\t\t\t(22, 0, 30, 28), # Emerald\n\t\t\t\t(24, 0, 34, 0), # EPIC Points\n\t\t\t\t(28, 6, 40, 21), # Diving Pod\n\t\t\t\t(28, 0, 30, 15), (28, 4, 30, 17), (28, 5, 30, 18),\n\t\t\t\t(28, 7, 30, 20), (28, 8, 30, 21), (28, 9, 30, 22), # Powerups\n\t\t\t\t(28, 1, 30, 16), # Purple Key\n\t\t\t\t(30, 0, 51, 9), (30, 1, 51, 8), # Ceiling Switch\n\t\t\t\t(31, 0, 51, 14), (31, 1, 51, 14), # Hidden Spikey Creature\n\t\t\t\t(33, 28, 37, 28), # Fireball\n\t\t\t\t(38, 0, 30, 50), (38, 1, 30, 51), (38, 2, 30, 52), # Menu Bullets\n\t\t\t\t(40, 0, 30, 62), # Star\n\t\t\t\t(42, 0, 37, 29), # Green Gem\n\t\t\t\t(42, 1, 37, 30), # Purple Gem\n\t\t\t\t(42, 2, 37, 31), # Red Gem\n\t\t\t\t(42, 3, 37, 32), # Yellow Gem\n\t\t\t\t(44, 0, 15, 2), # Stalagtite\n\t\t\t\t(45, 0, 36, 19), # Boulder Trap\n\t\t\t\t(48, 0, 40, 16), (48, 1, 40, 17), # Bubbles\n\t\t\t\t(51, 0, 36, 33), # Clouds\n\t\t\t\t(72, 0, 55, 0), (72, 1, 55, 1), (72, 2, 55, 2), # Pillar\n\t\t\t\t(72, 7, 55, 3), (72, 8, 55, 4), (72, 9, 55, 5), (72, 10, 55, 6), # Foliage\n\t\t\t\t(72, 4, 36, 35), (72, 11, 36, 36), # Exit Sign\n\t\t\t\t(72, 13, 38, 3), (72, 14, 38, 4), # Reactors\n\t\t\t\t(72, 15, 38, 5), (72, 16, 38, 6), # To Reactor\n\t\t\t\t(74, 0, 59, 9), # Ceiling Turret\n\t\t\t\t(78, 0, 50, 0), # Climbing Monster\n\t\t\t\t(81, 0, 39, 22), # Water Bed Creature\n\t\t\t\t(84, 0, 30, 31), (84, 1, 30, 32), (84, 2, 30, 33), # Artefacts\n\t\t\t\t(87, 0, 38, 0), (87, 1, 38, 1), # The Mighty Xargon!\n\t\t\t\t(88, 0, 47, 18), (88, 1, 47, 19),\n\t\t\t\t(88, 2, 47, 20), (88, 3, 47, 21), (88, 6, 47, 24) # Map images\n\t\t\t\t]:\n\t\t\tself.addsprite(sprtype, subtype, sprite(graphics.records[recnum].images[imagenum]))\n\n\t\t# Simple mapping to hide info label:\n\t\tfor (sprtype, subtype, recnum, imagenum) in [\n\t\t\t\t(13, 0, 36, 2), # Springboard\n\t\t\t\t(49, 0, 48, 12), # Torch\n\t\t\t\t]:\n\t\t\tself.addsprite(sprtype, subtype, sprite(graphics.records[recnum].images[imagenum],\n\t\t\t\thidelabel=True))\n\n\t\t# Map Images that need alignment:\n\t\tfor (sprtype, subtype, recnum, imagenum) in [\n\t\t\t\t(5, 0, 47, 8), # Map Player\n\t\t\t\t(88, 4, 47, 22), (88, 5, 47, 23)]:\n\t\t\tself.addsprite(sprtype, subtype, sprite(\n\t\t\t\tgraphics.records[recnum].images[imagenum], xoffs=4))\n\t\tself.addsprite(88, -1, sprite(\n\t\t\tgraphics.records[47].images[16], xoffs=2, yoffs=2))\n\n\t\t# Xargon's castle:\n\t\tif epnum == 3:\n\t\t\tself.addsprite(88, 7,  sprite(graphics.records[47].images[25], yoffs=6, xoffs=4))\n\t\t\tself.addsprite(88, 8,  sprite(graphics.records[47].images[26], yoffs=6, xoffs=10))\n\t\t\tself.addsprite(88, 9,  sprite(graphics.records[47].images[27]))\n\t\t\tself.addsprite(88, 10, sprite(graphics.records[47].images[28], xoffs=4))\n\t\t\tself.addsprite(88, 11, sprite(graphics.records[47].images[29], xoffs=10))\n\t\t\tself.addsprite(88, 12, sprite(graphics.records[47].images[30]))\n\n\t\t# Silvertongue\n\t\tfor i in range (25):\n\t\t\tself.addsprite(23, i, sprite(graphics.records[45].images[1]))\n\n\t\t# Crushing Ceilings:\n\t\tfor i in range (16):\n\t\t\tself.addsprite(15, i, sprite(graphics.records[36].images[6]))\n\n\t\t# Illusionary Walls:\n\t\tself.addsprite(72, 3, sprite(graphics.semitransparent(\n\t\t\t\tgraphics.records[20].images[8], 160) ))\n\t\tself.addsprite(72, 5, sprite(graphics.semitransparent(\n\t\t\t\tgraphics.records[11].images[23], 160) ))\n\t\tself.addsprite(72, 6, sprite(graphics.semitransparent(\n\t\t\t\tgraphics.records[19].images[15], 160) ))\n\t\tself.addsprite(72, 12, sprite(graphics.semitransparent(\n\t\t\t\tgraphics.records[19].images[16], 160) ))\n\n\t\t# Treasures (+ contents)\n\t\ttreasurelookup = {0 : graphics.records[37].images[24],\n\t\t\t1 : graphics.records[37].images[25],\n\t\t\t2 : graphics.records[37].images[26],\n\t\t\t3 : graphics.records[37].images[27] }\n\n\t\tfor (sprtype, subtype, crecnum, cimagenum) in [\n\t\t\t\t(26, 0, 37, 33), # Health\n\t\t\t\t(26, 1, 37, 2), # Grapes\n\t\t\t\t(26, 2, 37, 6), # Cherry\n\t\t\t\t(26, 3, 37, 8), # Strawberries\n\t\t\t\t(26, 4, 37, 14), # Orange\n\t\t\t\t(26, 5, 37, 3), # Epic Disk\n\t\t\t\t(26, 6, 31, 0), # Yellow Key\n\t\t\t\t(26, 7, 31, 8), # Green Key\n\t\t\t\t(26, 8, 31, 16), # Red Key\n\t\t\t\t(26, 9, 31, 24), # Blue Key\n\t\t\t\t(26, 10, 30, 21), # High-jump shoes\n\t\t\t\t(26, 11, 30, 28), # Emerald\n\t\t\t\t(26, 12, 48, 2), # Nitro!\n\t\t\t\t(26, 13, 36, 29) # Empty\n\t\t\t\t]:\n\t\t\tself.addsprite(sprtype, subtype, variablesprite(treasurelookup,\n\t\t\t\tcontents=graphics.records[crecnum].images[cimagenum]))\n\n\t\t# Pickup Switches:\n\t\tself.addsprite(12, 0, variablesprite({\n\t\t\t0 : graphics.records[30].images[19],\n\t\t\t1 : graphics.records[51].images[0]},\n\t\t\tlabelpref=\"TR \", labeloffs = (0, 4)) )\n\n\t\t# Toggle Switches:\n\t\tself.addsprite(29, 0, sprite(graphics.records[36].images[23],\n\t\t\tlabelpref = \"SW \"))\n\t\tself.addsprite(29, 1, sprite(graphics.records[36].images[24],\n\t\t\tlabelpref = \"SW \"))\n\n\t\t# Timers:\n\t\tfor i in [30, 40, 50, 60]:\n\t\t\tself.addsprite(73, i, sprite(graphics.records[30].images[19],\n\t\t\t\tlabelpref=\"Timer \", labeloffs = (-4, 4)) )\n\n\t\t# Menu Flame Jets:\n\t\tself.addsprite(47, 0, variablesprite({\n\t\t\t6 : graphics.records[48].images[3],\n\t\t\t8 : graphics.records[48].images[4]},\n\t\t\tfield='info', hidelabel=True))\n\n\t\t# Bouncing Balls:\n\t\tfor i in range(2):\n\t\t\tself.addsprite(46, i, variablesprite({\n\t\t\t\t0 : graphics.records[51].images[4],\n\t\t\t\t1 : graphics.records[51].images[5],\n\t\t\t\t2 : graphics.records[51].images[6],\n\t\t\t\t3 : graphics.records[51].images[7]},\n\t\t\t\tfield='info', hidelabel=True))\n\n\t\t# Spikes:\n\t\tself.addsprite(59, 0, variablesprite({\n\t\t\t0 : graphics.records[36].images[28],\n\t\t\t1 : graphics.records[36].images[32]},\n\t\t\tfield='variant', hidelabel=True))\n\n\t\t# Ceiling Spear\n\t\tfor i in range(3):\n\t\t\tself.addsprite(43, i, variablesprite({\n\t\t\t\t0 : graphics.records[36].images[9],\n\t\t\t\t1 : graphics.records[36].images[12]},\n\t\t\t\toffsets={0: (0, 0), 1:(0, -4) },\n\t\t\t\tfield='variant', hidelabel=True))\n\n\t\t# Snake Face\n\t\tself.addsprite(50, 0, variablesprite({\n\t\t\t0 : graphics.records[60].images[1],\n\t\t\t1 : graphics.records[60].images[4]},\n\t\t\toffsets={0: (0, 0), 1:(-8, 0) },\n\t\t\thidelabel = True))\n\n\n\t\t# Monsters:\n\t\t# Assumed Convention: > 0 -- Right, <= 0 -- Left\n\t\t# Clawface Monster\n\t\tself.addsprite(25, 0, variablesprite({\n\t\t\t0 : graphics.records[35].images[2],\n\t\t\t2 : graphics.records[35].images[10],\n\t\t\t} ))\n\n\t\t# Brute\n\t\tself.addsprite(55, 0, variablesprite({\n\t\t\t-4 : graphics.records[61].images[12],\n\t\t\t-3 : graphics.records[61].images[11],\n\t\t\t-2 : graphics.records[61].images[10],\n\t\t\t-1 : graphics.records[61].images[9],\n\t\t\t0 : graphics.records[61].images[8],\n\t\t\t1 : graphics.records[61].images[0],\n\t\t\t2 : graphics.records[61].images[1],\n\t\t\t3 : graphics.records[61].images[2],\n\t\t\t4 : graphics.records[61].images[3]\n\t\t\t} ))\n\n\t\t# Centipede Monster\n\t\tself.addsprite(52, 7, sprite(graphics.compositeimage((76, 22), [(0, 0, 52, 0),\n\t\t\t(16, 5, 52, 1), (24, 5, 52, 2), (32, 5, 52, 3), (40, 5, 52, 4),\n\t\t\t(48, 5, 52, 5), (56, 5, 52, 6), (64, 7, 52, 7)] )))\n\n\t\t# Alien Rat Thing\n\t\tself.addsprite(53, 0, variablesprite({\n\t\t\t-1 : graphics.records[58].images[2],\n\t\t\t0 : graphics.records[58].images[1],\n\t\t\t2 : graphics.records[58].images[6]\n\t\t\t} ))\n\n\t\tif epnum == 3:\n\t\t\t# Snake-like thing\n\t\t\tself.addsprite(54, 0, variablesprite({\n\t\t\t\t-3 : graphics.records[42].images[3],\n\t\t\t\t-2 : graphics.records[42].images[2],\n\t\t\t\t-1 : graphics.records[42].images[1],\n\t\t\t\t0 : graphics.records[42].images[0],\n\t\t\t\t2 : graphics.records[42].images[5],\n\t\t\t\t4 : graphics.records[42].images[6]\n\t\t\t\t} ))\n\n\t\tif epnum == 2:\n\t\t\t# Goo Monster\n\t\t\tself.addsprite(56, 0, sprite(graphics.records[46].images[2]))\n\n\t\tif epnum != 1:\n\t\t\t# Mini Dino\n\t\t\tself.addsprite(58, 0, variablesprite({\n\t\t\t\t-2 : graphics.records[56].images[6],\n\t\t\t\t-1 : graphics.records[56].images[5],\n\t\t\t\t0 : graphics.records[56].images[4],\n\t\t\t\t1 : graphics.records[56].images[1],\n\t\t\t\t2 : graphics.records[56].images[0],\n\t\t\t\t} ))\n\n\t\t# Flying Robots\n\t\tself.addsprite(60, 0, sprite(graphics.records[59].images[1]))\n\t\tself.addsprite(60, 1, sprite(graphics.records[59].images[4]))\n\t\tself.addsprite(60, 2, sprite(graphics.records[59].images[7]))\n\n\t\t# Shrimp\n\t\tself.addsprite(64, 0, variablesprite({\n\t\t\t0 : graphics.records[39].images[2],\n\t\t\t2 : graphics.records[39].images[10],\n\t\t\t} ))\n\n\t\t# Evil Cloak Guy\n\t\tfor i in range(2):\n\t\t\tself.addsprite(65, i, variablesprite({\n\t\t\t\t0 : graphics.records[54].images[5],\n\t\t\t\t2 : graphics.records[54].images[0],\n\t\t\t\t} ))\n\n\t\t# Eel\n\t\tself.addsprite(67, 0, variablesprite({\n\t\t\t-3 : graphics.records[39].images[14],\n\t\t\t0 : graphics.records[39].images[15],\n\t\t\t2 : graphics.records[39].images[20]\n\t\t\t} ))\n\n\t\t# Big Fish\n\t\tself.addsprite(68, 0, variablesprite({\n\t\t\t-3 : graphics.records[40].images[8],\n\t\t\t-2 : graphics.records[40].images[7],\n\t\t\t0 : graphics.records[40].images[6],\n\t\t\t2 : graphics.records[40].images[11],\n\t\t\t3 : graphics.records[40].images[12],\n\t\t\t4 : graphics.records[40].images[13]\n\t\t\t} ))\n\n\n\t\tif epnum != 1:\n\t\t\t# Bat\n\t\t\tself.addsprite(69, 0, sprite(graphics.records[56].images[8]))\n\n\t\t\tself.addsprite(70, 0, variablesprite({\n\t\t\t\t0 : graphics.records[63].images[4],\n\t\t\t\t2 : graphics.records[63].images[1],\n\t\t\t\t} ))\n\n\n\t\t# Skull Slug!\n\t\tif epnum != 2:\n\t\t\tself.addsprite(75, 0, variablesprite({\n\t\t\t\t-1 : graphics.records[62].images[2],\n\t\t\t\t0 : graphics.records[62].images[0],\n\t\t\t\t1 : graphics.records[62].images[5],\n\t\t\t\t2 : graphics.records[62].images[3]\n\t\t\t\t}, hidelabel=True ))\n\n\t\t# Bee!\n\t\tself.addsprite(77, 0, variablesprite({\n\t\t\t-2 : graphics.records[32].images[1],\n\t\t\t-1 : graphics.records[32].images[1],\n\t\t\t0 : graphics.records[32].images[0],\n\t\t\t1 : graphics.records[32].images[3],\n\t\t\t2 : graphics.records[32].images[2]\n\t\t\t} ))\n\n\t\t# Spider!\n\t\tself.addsprite(79, 0, variablesprite({\n\t\t\t-3 : graphics.records[43].images[12],\n\t\t\t-2 : graphics.records[43].images[11],\n\t\t\t-1 : graphics.records[43].images[10],\n\t\t\t0 : graphics.records[43].images[9],\n\t\t\t1 : graphics.records[43].images[0],\n\t\t\t2 : graphics.records[43].images[1],\n\t\t\t3 : graphics.records[43].images[2],\n\t\t\t4 : graphics.records[43].images[3]\n\t\t\t} ))\n\n\t\t# Robot with Treads\n\t\tself.addsprite(82, 0, variablesprite({\n\t\t\t-4 : graphics.records[59].images[21],\n\t\t\t-3 : graphics.records[59].images[21],\n\t\t\t-2 : graphics.records[59].images[20],\n\t\t\t-1 : graphics.records[59].images[19],\n\t\t\t0 : graphics.records[59].images[18],\n\t\t\t1 : graphics.records[59].images[14],\n\t\t\t2 : graphics.records[59].images[15],\n\t\t\t3 : graphics.records[59].images[16],\n\t\t\t4 : graphics.records[59].images[17],\n\t\t\t} ))\n\n\t\t# Small fish\n\t\tself.addsprite(83, 0, variablesprite({\n\t\t\t0 : graphics.records[40].images[22],\n\t\t\t2 : graphics.records[40].images[26]\n\t\t\t} ))\n\n\t\t# Pickups appear to be in the same order as their corresponding record.\n\t\t# There are two types of pickups: normal and hidden.\n\t\tfor subtype in range(24):\n\t\t\tself.addsprite(33, subtype, sprite(graphics.records[37].images[subtype],\n\t\t\t\thidelabel=True))\n\t\t\tself.addsprite(73, subtype, sprite(graphics.semitransparent(\n\t\t\t\tgraphics.records[37].images[subtype], 128) ))\n\n\t\t# Special case for 73, Variant 4 appears to be the pickup item.\n\t\t# Other variants appear to be:\n\t\t# 0 : Unused??\n\t\t# 1 : Flaming Face Jet (Down) (Invisible)\n\t\t# 2 : Flaming Lava Jet (Up) (Invisible)\n\t\t# 3 : Robot Spawner\n\t\t# 5 : Slug Spawner\n\t\t# These alternate forms only appear to show up for subtypes 0 and 1,\n\t\t# so they will be added just for these two numbers:\n\n\t\t# Episode 2 doesn't have the skull slug, so we need an alternate\n\t\t# sprite so it doesn't crash.\n\t\tif epnum != 2:\n\t\t\tslugspawner = graphics.compositeimage((32, 14),\n\t\t\t\t\t[(2, 0, 62, 2), (-3, 0, 62, 0)])\n\t\telse:\n\t\t\tslugspawner = graphics.records[30].images[19]\n\n\t\tfor i in range(2):\n\t\t\tself.addsprite(73, i, variablesprite({\n\t\t\t\t0 : graphics.records[30].images[19],\n\t\t\t\t1 : graphics.records[30].images[19],\n\t\t\t\t2 : graphics.records[30].images[19],\n\t\t\t\t3 : graphics.compositeimage((32, 32), [(0, 0, 59, 1),\n\t\t\t\t   (16, 0, 59, 4), (8, 12, 59, 1)]),\n\t\t\t\t4 : graphics.semitransparent(\n\t\t\t\t\tgraphics.records[37].images[i], 128),\n\t\t\t\t5 : slugspawner},\n\t\t\t\tfield='variant', hidelabel=True))\n\n\t\t# Story Scenes:\n\t\tif epnum == 1:\n\t\t\tfor subtype in range(24):\n\t\t\t\tself.addsprite(85, subtype, sprite(graphics.records[56].images[subtype]))\n\t\t\t\tself.addsprite(86, subtype, sprite(graphics.records[57].images[subtype]))\n\t\telif epnum == 3:\n\t\t\t# Fake sprite for the ending scene (which does not appear to have a sprite OR use Tiles):\n\t\t\ttilelist = []\n\t\t\tfor x in range(10):\n\t\t\t\tfor y in range(10):\n\t\t\t\t\ttilelist.append( (x*16, y*16, 57, x + 10*y) )\n\t\t\tself.addsprite(1000, 0, sprite(graphics.compositeimage((160, 160), tilelist)))\n\n\t\t# Empty sprites:\n\t\t# -------------------------\n\t\t# For future reference, possible meanings are:\n\t\t# 17-# (and other numbers): Start? Warp?\n\t\t# 63-# Start?\n\t\tfor sprtype in [17, 63]:\n\t\t\tfor subtype in range(-1, 11):\n\t\t\t\tself.addsprite(sprtype, subtype, sprite(graphics.records[30].images[19],\n\t\t\t\t\thidelabel=True))\n\n\t\tfor sprtype, subtype in [\n\t\t\t\t(19,0), # Map label? (TODO: Implement via compound sprite?)\n\t\t\t\t(8, 0), (8, 1), # Switchable Pillar Wall\n\t\t\t\t]:\n\t\t\tself.addsprite(sprtype, subtype, sprite(graphics.records[30].images[19]))\n\n\t\tfor sprtype, subtype in [\n\t\t\t\t(71,0), (71,1), # Sign & Popup Message?\n\t\t\t\t(9, -1) # Locked Map Gate\n\t\t\t\t]:\n\t\t\tself.addsprite(sprtype, subtype, sprite(graphics.records[30].images[19],\n\t\t\t\thidelabel=True))\n\n\n\t\t# Warp Doorways:\n\t\tself.addsprite(61, 0, sprite(graphics.records[30].images[19],\n\t\t\tlabeloffs = (4, 4))) # Out Door\n\t\tself.addsprite(62, 0, sprite(graphics.records[30].images[19],\n\t\t\tlabelpref='To ', labeloffs = (0, 4))) # In Door\n\n\t\t# Cache a reference to the graphics object for future use\n\t\tself.graphics = graphics\n\n\tdef drawsprite(self, mappicture, objrec, mapdata):\n\t\t\"\"\" Draws the sprite described by the map object record into the\n\t\tmap image.\n\n\t\tmappicture -- the in-progress map image\n\t\tobjrec -- the object record for the sprite to be drawn\n\t\tmapdata -- a reference back to the data that is being mapped.\n\t\t\"\"\"\n\t\ttry:\n\t\t\t# Create a debug sprite when a sprite is unknown\n\t\t\tif objrec.sprtype not in self.sprites or \\\n\t\t\t\t\tobjrec.subtype not in self.sprites[objrec.sprtype]:\n\t\t\t\tself.addsprite(objrec.sprtype, objrec.subtype, sprite(\n\t\t\t\t\tself.graphics.debugimage(objrec.sprtype, objrec.subtype,\n\t\t\t\t\tobjrec.width, objrec.height)))\n\n\t\t\t# Draw the sprite\n\t\t\tself.sprites[objrec.sprtype][objrec.subtype].draw(mappicture, objrec, mapdata)\n\n\t\texcept:\n\t\t\tprint(\"Problem with Sprite {}, Type {}, Appearance {}, Variant {} at ({}, {})\".format(\n\t\t\t\tobjrec.sprtype, objrec.subtype, objrec.appearance, objrec.variant,\n\t\t\t\tobjrec.x, objrec.y))\n\t\t\ttraceback.print_exc()\n\n", "description": " The sprite database is a database of all known Xargon sprites.\n\tIt provides a lookup from the sprite ID and sub-id to the correct\n\tsprite type.\n\t", "category": "graphics", "imports": ["import traceback", "from PIL import ImageFont, ImageDraw"]}, {"term": "class", "name": "sprite", "data": "class sprite(object):\n\t\"\"\" Sprite object which represents a standard Xargon sprite. It\n\tcontains enough information to render the sprite into the map.\n\t\"\"\"\n\tdef __init__(self, image, xoffs=0, yoffs=0, hidelabel=False,\n\t\t\tlabelpref='', labeloffs=(-8, -8)):\n\t\t\"\"\" Initializes this sprite according to the following info:\n\n\t\timage -- the PIL image for the sprite\n\t\txoffs -- an X offset (in pixels) to shift this sprite by\n\t\tyoffs -- an Y offset (in pixels) to shift this sprite by\n\t\thidelabel -- if true, and this sprite has an info value\n\t\t\t\t\t (typically for switches), it is still not drawn.\n\t\tlabelpref -- if a label is drawn for this sprite, this prefix\n\t\t\t\t\t text is added first.\n\t\tlabeloffs -- a tuple specifying how far from the upper-left\n\t\t\t\t\t corner of the sprite to start the upper-left corner\n\t\t\t\t\t of the label text.\n\t\t\"\"\"\n\n\t\tself.image = image\n\t\tself.xoffs = xoffs\n\t\tself.yoffs = yoffs\n\t\tself.hidelabel = hidelabel\n\t\tself.labelpref = labelpref\n\t\tself.labeloffs = labeloffs\n\n\tdef draw(self, mappicture, objrec, mapdata):\n\t\t\"\"\" Draws this sprite into the in-progress map image:\n\n\t\tmappicture -- the in-progress map image\n\t\tobjrec -- the object record for the sprite to be drawn\n\t\tmapdata -- a reference back to the data that is being mapped.\n\t\t\"\"\"\n\n\t\t# When pasting masked images, need to specify the mask for the paste.\n\t\t# RGBA images can be used as their own masks.\n\t\tmappicture.paste(self.image, (objrec.x +self.xoffs,\n\t\t\tobjrec.y +self.yoffs), self.image)\n\n\t\tif objrec.info > 0 and objrec.info < 90 and not self.hidelabel:\n\t\t\ttext = \"{}{}\".format(self.labelpref, objrec.info)\n\n\t\t\t# Draw the text 5 times to create an outline\n\t\t\t# (4 x black then 1 x white)\n\t\t\tpen = ImageDraw.Draw(mappicture)\n\t\t\tfor offset, colour in [( (-1,-1), (0,0,0) ),\n\t\t\t\t\t( (-1,1), (0,0,0) ),\n\t\t\t\t\t( (1,-1), (0,0,0) ),\n\t\t\t\t\t( (1,1), (0,0,0) ),\n\t\t\t\t\t( (0,0), (255,255,255) )]:\n\t\t\t\tpen.text( (objrec.x +self.xoffs +offset[0] +self.labeloffs[0],\n\t\t\t\t\tobjrec.y +self.yoffs +offset[1] +self.labeloffs[0]),\n\t\t\t\t\ttext, font=markupfont, fill=colour)\n\n", "description": " Sprite object which represents a standard Xargon sprite. It\n\tcontains enough information to render the sprite into the map.\n\t", "category": "graphics", "imports": ["import traceback", "from PIL import ImageFont, ImageDraw"]}, {"term": "class", "name": "textsprite", "data": "class textsprite(sprite):\n\t\"\"\" A sprite intended to draw text into the map \"\"\"\n\n\tdef __init__(self, font, graphics):\n\t\t\"\"\" Initializes this sprite according to the following info:\n\n\t\timage -- the PIL image for the sprite\n\t\txoffs -- an X offset (in pixels) to shift this sprite by\n\t\tyoffs -- an Y offset (in pixels) to shift this sprite by\n\t\thidelabel -- if true, and this sprite has an info value\n\t\t\t\t\t (typically for switches), it is still not drawn.\n\t\tlabelpref -- if a label is drawn for this sprite, this prefix\n\t\t\t\t\t text is added first.\n\t\tlabeloffs -- a tuple specifying how far from the upper-left\n\t\t\t\t\t corner of the sprite to start the upper-left corner\n\t\t\t\t\t of the label text.\n\t\t\"\"\"\n\t\tself.font = font\n\t\tself.graphics = graphics\n\n\tdef draw(self, mappicture, objrec, mapdata):\n\t\t\"\"\" Draws this sprite into the in-progress map image:\n\n\t\tmappicture -- the in-progress map image\n\t\tobjrec -- the object record for the sprite to be drawn\n\t\tmapdata -- a reference back to the data that is being mapped.\n\t\t\"\"\"\n\n\t\tpen = ImageDraw.Draw(mappicture)\n\n\t\tif objrec.appearance == 8:\n\t\t\t# Simulate multi-colour appearance by creating a fake shadow effect\n\t\t\tpen.text((objrec.x, objrec.y), mapdata.getstring(objrec.stringref),\n\t\t\t\t\tfont=self.font, fill=self.graphics.getcolour(14))\n\t\t\tpen.text((objrec.x-1, objrec.y), mapdata.getstring(objrec.stringref),\n\t\t\t\t\tfont=self.font, fill=self.graphics.getcolour(6))\n\t\telse:\n\t\t\tpen.text((objrec.x, objrec.y), mapdata.getstring(objrec.stringref),\n\t\t\t\t\tfont=self.font, fill=self.graphics.getcolour(objrec.appearance))\n\n", "description": " A sprite intended to draw text into the map ", "category": "graphics", "imports": ["import traceback", "from PIL import ImageFont, ImageDraw"]}, {"term": "class", "name": "variablesprite", "data": "class variablesprite(sprite):\n\t\"\"\" A sprite whos apperance changes due to some field other than the\n\tsub-type. The sprite is indexed according to the specified field\n\tand the correct image is drawn into the world.\n\t\"\"\"\n\n\tdef __init__(self, imagelookup, contents=None, field='appearance',\n\t\t\toffsets=None, hidelabel=False, labelpref='', labeloffs=(-8, -8)):\n\t\t\"\"\" Initializes this variable sprite according to the following info:\n\n\t\timagelookup -- A dictionary of PIL images to use, keyed by\n\t\t\t\t\t   numbers in the lookup field of the object record.\n\t\tcontents -- For treasure boxes. This is a secondary image that\n\t\t\t\t\tis drawn above the main image to indicate what this\n\t\t\t\t\tbox actually contains.\n\t\toffsets -- a lookup of offset tuples, keyed by the numbers in\n\t\t\t\t   the lookup field of the object record. The selected\n\t\t\t\t   offset is used to shift the resulting image.\n\t\thidelabel -- if true, and this sprite has an info value\n\t\t\t\t\t (typically for switches), it is still not drawn.\n\t\tlabelpref -- if a label is drawn for this sprite, this prefix\n\t\t\t\t\t text is added first.\n\t\tlabeloffs -- a tuple specifying how far from the upper-left\n\t\t\t\t\t corner of the sprite to start the upper-left corner\n\t\t\t\t\t of the label text.\n\t\t\"\"\"\n\n\t\t# Create a lookup of possible boxes\n\t\tself.types = imagelookup\n\t\tself.xoffs = 0\n\t\tself.yoffs = 0\n\t\tself.contents = contents\n\t\tself.offsets = offsets\n\t\tself.field = field\n\t\tself.hidelabel = hidelabel\n\t\tself.labelpref = labelpref\n\t\tself.labeloffs = labeloffs\n\n\tdef draw(self, mappicture, objrec, mapdata):\n\t\t\"\"\" Draws this sprite into the in-progress map image:\n\n\t\tmappicture -- the in-progress map image\n\t\tobjrec -- the object record for the sprite to be drawn\n\t\tmapdata -- a reference back to the data that is being mapped.\n\t\t\"\"\"\n\n\t\t# Pick the correct image then use the parent routine to draw the box\n\t\tself.image = self.types[objrec.__dict__[self.field]]\n\t\tif self.offsets != None:\n\t\t\t(self.xoffs, self.yoffs) = self.offsets[objrec.__dict__[self.field]]\n\t\tsuper(variablesprite, self).draw(mappicture, objrec, mapdata)\n\n\t\t# Place contents immediately above the current sprite\n\t\tif self.contents != None:\n\t\t\tmappicture.paste(self.contents, (objrec.x +self.xoffs,\n\t\t\t\tobjrec.y +self.yoffs - self.contents.size[1]), self.contents)\n", "description": " A sprite whos apperance changes due to some field other than the\n\tsub-type. The sprite is indexed according to the specified field\n\tand the correct image is drawn into the world.\n\t", "category": "graphics", "imports": ["import traceback", "from PIL import ImageFont, ImageDraw"]}], [{"term": "def", "name": "ConstructFilenameAndPath", "data": "def ConstructFilenameAndPath():\r\n\tglobal gFilenameAndPath\r\n\tif gFilenameAndPath == U\"\":\r\n\t\tif PtIsInternalRelease():\r\n\t\t\t# check for local file\r\n\t\t\tlocalNameAndPath = U\"init/\" + gFilename\r\n\t\t\tif PtFileExists(localNameAndPath):\r\n\t\t\t\tgFilenameAndPath = localNameAndPath\r\n\t\t\t\tprint U\"xIniDisplay::ConstructFilenameAndPath(): Using internal \\\"\" + gFilenameAndPath + U\"\\\" file\"\r\n\t\t\t\treturn\r\n\t\t# otherwise, use the standard init path\r\n\t\tgFilenameAndPath = PtGetInitPath() + U\"/\" + gFilename\r\n\t\tprint U\"xIniDisplay::ConstructFilenameAndPath(): Using user-level \\\"\" + gFilenameAndPath + U\"\\\" file\"\r\n", "description": null, "category": "graphics", "imports": ["import string\r", "import xIniHelper\r", "from Plasma import *\r"]}, {"term": "def", "name": "WriteIni", "data": "def WriteIni():\r\n\tglobal gIniFile\r\n\tif gIniFile:\r\n\t\tConstructFilenameAndPath()\r\n\t\tgIniFile.writeFile(gFilenameAndPath)\r\n", "description": null, "category": "graphics", "imports": ["import string\r", "import xIniHelper\r", "from Plasma import *\r"]}, {"term": "def", "name": "ReadIni", "data": "def ReadIni():\r\n\tglobal gIniFile\r\n\tConstructFilenameAndPath()\r\n\tgIniFile = xIniHelper.iniFile(gFilenameAndPath)\r\n\tif gIniFile.isEmpty():\r\n\t\t# add defaults\r\n\t\tgIniFile.addEntry(\"# This is an auto-generated file.\")\r\n\t\tgIniFile.addEntry(\"\\n\")\r\n\t\tgIniFile.addEntry(kGraphicsWidth + \" 800\")\r\n\t\tgIniFile.addEntry(kGraphicsHeight + \" 600\")\r\n\t\tgIniFile.addEntry(kGraphicsColorDepth + \" 32\")\r\n\t\tgIniFile.addEntry(kGraphicsWindowed + \" false\")\r\n\t\tgIniFile.addEntry(kGraphicsTextureQuality + \" 2\")\r\n\t\tgIniFile.addEntry(kGraphicsAntiAliasLevel + \" 0\")\r\n\t\tgIniFile.addEntry(kGraphicsAnisotropicLevel + \" 0\")\r\n\t\tgIniFile.addEntry(kGraphicsQualityLevel + \" 2\")\r\n\t\tgIniFile.addEntry(kGraphicsShadows + \" true\")\r\n\t\tgIniFile.addEntry(kGraphicsVerticalSync + \" false\")\r\n\t\tgIniFile.addEntry(kGraphicsShadowQuality + \" 0\")\r\n\t\tgIniFile.writeFile(gFilenameAndPath)\r\n\r\n\telse:\r\n\t\tiniChanged = 0\r\n\t\tfor idx in range(len(CmdList)):\r\n\t\t\tcmd = CmdList[idx]\r\n\t\t\tentry,idx = gIniFile.findByCommand(cmd)\r\n\t\t\tif not entry:\r\n\t\t\t\tgIniFile.addEntry(cmd + \" \" + DefaultsList[idx])\r\n\t\t\t\tiniChanged = 1\r\n\r\n\t\tif iniChanged:\r\n\t\t\tConstructFilenameAndPath()\r\n\t\t\tgIniFile.writeFile(gFilenameAndPath)\r\n", "description": null, "category": "graphics", "imports": ["import string\r", "import xIniHelper\r", "from Plasma import *\r"]}, {"term": "def", "name": "SetGraphicsOptions", "data": "def SetGraphicsOptions(width, heigth, colordepth, windowed, texquality, aaLevel, anisoLevel, qualityLevel, useShadows, vsync, shadowqual):\r\n\tif gIniFile:\r\n\t\tparamList = [width, heigth, colordepth, windowed, texquality, aaLevel, anisoLevel, qualityLevel, useShadows, vsync, shadowqual]\r\n\t\tfor idx in range(len(CmdList)):\r\n\t\t\tentry,junk = gIniFile.findByCommand(CmdList[idx])\r\n\t\t\tval = str(paramList[idx])\r\n\t\t\tif entry:\r\n\t\t\t\tentry.setValue(0, val)\r\n\t\t\telse:\r\n\t\t\t\tgIniFile.addEntry(\"%s %s\" % (CmdList[idx], val))\r\n", "description": null, "category": "graphics", "imports": ["import string\r", "import xIniHelper\r", "from Plasma import *\r"]}, {"term": "def", "name": "GetGraphicsOptions", "data": "def GetGraphicsOptions():\r\n\toptsList = {}\r\n\tif gIniFile:\r\n\t\tfor cmd in CmdList:\r\n\t\t\tentry,idx = gIniFile.findByCommand(cmd)\r\n\t\t\tif entry:\r\n\t\t\t\tvalue = entry.getValue(0)\r\n\t\t\t\tif value:\r\n\t\t\t\t\ttry:\r\n\t\t\t\t\t\toptsList[cmd] = int(value)\r\n\t\t\t\t\texcept ValueError:\r\n\t\t\t\t\t\toptsList[cmd] = value\r\n\treturn optsList\r\n", "description": null, "category": "graphics", "imports": ["import string\r", "import xIniHelper\r", "from Plasma import *\r"]}], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, **kargs):\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [{"term": "class", "name": "GraphicsView", "data": "class GraphicsView(QGraphicsView):\n\tsigContextMenuDisplayed = QtCore.Signal()\n\tsigReloadImage =  QtCore.Signal()\n\tsigROIDeleted = QtCore.Signal()\n\tsigSetDrawButtonRed = QtCore.Signal(bool)\n\tsigSetEraseButtonRed = QtCore.Signal(bool)\n\tsigROIChanged = QtCore.Signal()\n\tsigNewROI = QtCore.Signal(str)\n\tsigUpdateZoom = QtCore.Signal(int)\n\n\n\tdef __init__(self): \n\t\tsuper(GraphicsView, self).__init__()\n\t\tself.scene = QGraphicsScene(self)\n\t\tself._zoom = 0\n\t\tself.graphicsItem = None\n\t\tself.setScene(self.scene)\n\t\tself.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)\n\t\tself.setResizeAnchor(QGraphicsView.AnchorUnderMouse)\n\t\tself.zoomEnabled = False\n\t\tself.currentROIName = None\n\t\tself.dictROIs = ROIs()\n\t\tself.menu = QMenu()\n\t\t#Following commented out to not display vertical and\n\t\t#horizontal scroll bars\n\t\t#self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n\t\t#self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n\t\t#self.setDragMode(QGraphicsView.ScrollHandDrag)\n\n\n\tdef setZoomEnabled(self, boolValue):\n\t\tself.zoomEnabled = boolValue\n\t\tself.graphicsItem.zoomEnabled = boolValue\n\n\n\tdef setImage(self, pixelArray, mask = None):\n\t\ttry:\n\t\t\tlogger.info(\"GraphicsView.setImage called\")\n\t\t\tprint(\"GraphicsView.setImage called\")\n\t\t\tif self.graphicsItem is not None:\n\t\t\t\tself.graphicsItem = None\n\t\t\t\tself.scene.clear()\n\n\t\t\tself.graphicsItem = GraphicsItem(pixelArray, mask)\n\t\t\tself.fitInView(self.graphicsItem, Qt.KeepAspectRatio) \n\t\t\tself.scene.addItem(self.graphicsItem)\n\t\t\tself.reapplyZoom()\n\t\t\tself.graphicsItem.sigZoomIn.connect(lambda: self.zoomFromMouseClicks(ZOOM_IN))\n\t\t\tself.graphicsItem.sigZoomOut.connect(lambda: self.zoomFromMouseClicks(ZOOM_OUT))\n\t\texcept Exception as e:\n\t\t\tprint('Error in GraphicsView.setImage: ' + str(e))\n\n\n\tdef reapplyZoom(self):\n\t\tprint(\"reapplyZoom self._zoom={}\".format(self._zoom))\n\t\tif self._zoom > 0:\n\t\t\tfactor = 1.25\n\t\t\ttotalFactor = factor**self._zoom\n\t\t\tself.scale(totalFactor, totalFactor)\n\n\n\tdef zoomFromMouseClicks(self, zoomValue):\n\t\tif self.zoomEnabled:\n\t\t\tself.zoomImage(zoomValue)\n\t\n\n\tdef fitImageToViewPort(self):\n\t\tself.zoomImage(ZOOM_IN)\n\t\tself.zoomImage(ZOOM_OUT)\n\n\n\tdef zoomImage(self, zoomValue):\n\t\tif zoomValue > 0:\n\t\t\tfactor = 1.25\n\t\t\tself._zoom += 1\n\t\t\t#print(\"+self._zoom={}\".format(self._zoom))\n\t\t\tincrement = 1\n\t\telse:\n\t\t\tfactor = 0.8\n\t\t\tself._zoom -= 1\n\t\t\tincrement = -1\n\t\t\t#print(\"-self._zoom={}\".format(self._zoom))\n\t\tif self._zoom > 0:\n\t\t\tself.scale(factor, factor)\n\t\telif self._zoom == 0:\n\t\t\tself.fitItemInView()\n\t\t\tincrement = 0\n\t\telse:\n\t\t\tself._zoom = 0\n\t\t\tincrement = 0\n\t\tself.sigUpdateZoom.emit(increment)\n\n\n\tdef wheelEvent(self, event):\n\t\tself.zoomImage(event.angleDelta().y())\n\n\n\tdef fitItemInView(self):#, scale=True\n\t\ttry:\n\t\t\tlogger.info(\"GraphicsView.fitItemInView called\")\n\t\t\tprint(\"GraphicsView.fitItemInView called\")\n\t\t\tif self.graphicsItem is not None:\n\t\t\t\trect = QRectF(self.graphicsItem.pixMap.rect())\n\t\t\t\tprint(\"GraphicsView.fitItemInView called rect ={}\".format(rect))\n\t\t\t\tif not rect.isNull():\n\t\t\t\t\tself.setSceneRect(rect)\n\t\t\t\t\tunity = self.transform().mapRect(QRectF(0, 0, 1, 1))\n\t\t\t\t\tprint(\"GraphicsView.fitItemInView called unity ={}\".format(unity))\n\t\t\t\t\tself.scale(1 / unity.width(), 1 / unity.height())\n\t\t\t\t\tviewrect = self.viewport().rect()\n\t\t\t\t\tprint(\"GraphicsView.fitItemInView called viewrect ={}\".format(viewrect))\n\t\t\t\t\tscenerect = self.transform().mapRect(rect)\n\t\t\t\t\tprint(\"GraphicsView.fitItemInView called scenerect ={}\".format(scenerect))\n\t\t\t\t\tfactor = min(viewrect.width() / scenerect.width(),\n\t\t\t\t\t\t\t\t\tviewrect.height() / scenerect.height())\n\t\t\t\t\tself.scale(factor, factor)\n\t\t\t\t\tprint(\"GraphicsView.fitItemInView factor={}\".format(factor))\n\t\t\t\t\tprint(\"****************************************************\")\n\t\t\t\t\tself._zoom = 0\n\t\texcept Exception as e:\n\t\t\tprint('Error in GraphicsView.fitItemInView: ' + str(e))\n\n\n\tdef toggleDragMode(self):\n\t\tif self.dragMode() == QGraphicsView.ScrollHandDrag:\n\t\t\tself.setDragMode(QGraphicsView.NoDrag)\n\t\telse:\n\t\t\tself.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n\t\t\tself.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n\t\t\tself.setDragMode(QGraphicsView.ScrollHandDrag)\n\n\n\tdef contextMenuEvent(self, event):\n\t\t#display pop-up context menu when the right mouse button is pressed\n\t\t#as long as zoom is not enabled\n\t\tif not self.zoomEnabled:\n\t\t\tself.menu.clear()\n\t\t\tself.sigContextMenuDisplayed.emit()\n\t\t\tzoomIn = QAction('Zoom In', None)\n\t\t\tzoomOut = QAction('Zoom Out', None)\n\t\t\tzoomIn.triggered.connect(lambda: self.zoomImage(ZOOM_IN))\n\t\t\tzoomOut.triggered.connect(lambda: self.zoomImage(ZOOM_OUT))\n\n\t\t\tdrawROI = QAction(QIcon(PEN_CURSOR), 'Draw', None)\n\t\t\tdrawROI.setToolTip(\"Draw an ROI\")\n\t\t\tdrawROI.triggered.connect(lambda: self.drawROI(True))\n\n\t\t\teraseROI  = QAction(QIcon(ERASOR_CURSOR), 'Erasor', None)\n\t\t\teraseROI.setToolTip(\"Erase the ROI\")\n\t\t\teraseROI.triggered.connect(lambda: self.eraseROI(True))\n\n\t\t\tnewROI  = QAction(QIcon(NEW_ICON),'New ROI', None)\n\t\t\tnewROI.setToolTip(\"Create a new ROI\")\n\t\t\tnewROI.triggered.connect(self.newROI)\n\n\t\t\tresetROI  = QAction(QIcon(RESET_ICON),'Reset ROI', None)\n\t\t\tresetROI.setToolTip(\"Clear drawn ROI from the image\")\n\t\t\tresetROI.triggered.connect(self.resetROI)\n\n\t\t\tdeleteROI  = QAction(QIcon(DELETE_ICON), 'Delete ROI', None)\n\t\t\tdeleteROI.setToolTip(\"Delete drawn ROI from the image\")\n\t\t\tdeleteROI.triggered.connect(self.deleteROI)\n\t\t\t\n\t\t\tself.menu.addAction(zoomIn)\n\t\t\tself.menu.addAction(zoomOut)\n\t\t\tself.menu.addSeparator()\n\t\t\tself.menu.addAction(drawROI)\n\t\t\tself.menu.addAction(eraseROI)\n\t\t\tself.menu.addSeparator()\n\t\t\tself.menu.addAction(newROI)\n\t\t\tself.menu.addAction(resetROI)\n\t\t\tself.menu.addAction(deleteROI)\n\t\t\tself.menu.exec_(event.globalPos())  \n\n\t\n\tdef drawROI(self, fromContextMenu = False):\n\t\tif not self.graphicsItem.drawEnabled:\n\t\t\tif fromContextMenu:\n\t\t\t\tself.sigSetDrawButtonRed.emit(True)\n\t\t\tself.graphicsItem.drawEnabled = True\n\t\t\tself.setZoomEnabled(False)\n\t\t\tself.graphicsItem.eraseEnabled = False\n\t\telse:\n\t\t\tself.graphicsItem.drawEnabled = False\n\t\t\tif fromContextMenu:\n\t\t\t\tself.sigSetDrawButtonRed.emit(False)\n\n\n\tdef eraseROI(self, fromContextMenu = False):\n\t\tif not self.graphicsItem.eraseEnabled:\n\t\t\tif fromContextMenu:\n\t\t\t\tself.sigSetEraseButtonRed.emit(True)\n\t\t\tself.graphicsItem.drawEnabled = False\n\t\t\tself.setZoomEnabled(False)\n\t\t\tself.graphicsItem.eraseEnabled = True\n\t\telse:\n\t\t\tself.graphicsItem.eraseEnabled = False\n\t\t\tif fromContextMenu:\n\t\t\t\tself.sigSetEraseButtonRed.emit(False)\n\t\t\t\n\n\tdef newROI(self):\n\t\ttry:\n\t\t\tlogger.info(\"GraphicsView.newROI called\")\n\t\t\tself.sigROIChanged.emit()\n\t\t\tif self.dictROIs.hasRegionGotMask(self.currentROIName):\n\t\t\t\tnewRegion = self.dictROIs.getNextRegionName()\n\t\t\t\tself.sigNewROI.emit(newRegion)\n\t\t\t\tself.graphicsItem.reloadImage()\n\t\t\telse:\n\t\t\t\tmsgBox = QMessageBox()\n\t\t\t\tmsgBox.setWindowTitle(\"Add new ROI\")\n\t\t\t\tmsgBox.setText(\n\t\t\t\t\t\"You must add ROIs to the current region before creating a new one\")\n\t\t\t\tmsgBox.exec()\n\t\texcept Exception as e:\n\t\t\tprint('Error in GraphicsView.newROI: ' + str(e))\n\n\n\tdef resetROI(self):\n\t\ttry:\n\t\t\tself.sigROIChanged.emit()\n\t\t\tlogger.info(\"GraphicsView.resetROI called\")\n\t\t\tself.dictROIs.deleteMask(self.currentROIName)\n\t\t\tself.sigReloadImage.emit()\n\t\texcept Exception as e:\n\t\t\tprint('Error in GraphicsView.resetROI: ' + str(e))\n\n\n\tdef deleteROI(self):\n\t\ttry:\n\t\t\tself.sigROIChanged.emit()\n\t\t\tlogger.info(\"GraphicsView.deleteROI called\")\n\t\t\tself.dictROIs.deleteMask(self.currentROIName)\n\t\t\tself.sigROIDeleted.emit()\n\t\texcept Exception as e:\n", "description": null, "category": "graphics", "imports": ["from PyQt5.QtCore import QRectF, Qt,  QCoreApplication", "from PyQt5 import QtCore ", "from PyQt5.QtWidgets import (QGraphicsView, QGraphicsScene, QMenu, QMessageBox,", "from PyQt5.QtGui import QPixmap, QCursor, QIcon", "from .GraphicsItem import GraphicsItem", "from .ROI_Storage import ROIs ", "import logging"]}], [{"term": "class", "name": "classGraphics:", "data": "class Graphics:\n\tdef __init__(self):\n\t\tself.len_x = 58\n\t\tself.len_y = 27\n\t\tself.default_buffer = [[\" \" for _ in range(self.len_x)] for _ in range(self.len_y)]\n\t\tself.buffer = deepcopy(self.default_buffer)\n\t\tself.border_x = [\"+\"] + [\"~\" for _ in range(self.len_x)] + [\"+\"]\n\t\tself.border_y = [\"|\"] * self.len_y\n\t\t\n\tdef print_buffer(self):\n\t\tres = self.set_border()\n\t\tfor line in res:\n\t\t\tprint(\"\".join(line))\n\t\n\tdef reset_buffer(self):\n\t\tself.buffer = deepcopy(self.default_buffer)\n\t\n\tdef set_border(self):\n\t\tres = [[self.border_y[i]] + self.buffer[i] + [self.border_y[i]] for i in range(self.len_y)]\n\t\treturn [self.border_x] + res + [self.border_x]\n\t\t\n\tdef draw(self, obj, x, y):\n\t\th = len(obj)\n\t\tfor dy in range(h):\n\t\t\tw = len(obj[dy])\n\t\t\tself.buffer[y + dy][x:x+w] = obj[dy]\n\t\n\tdef right_justify(self, obj, y):\n\t\tm = len(obj[0])\n\t\tfor line in obj:\n\t\t\tif len(line) > m:\n\t\t\t\tm = len(line)\n\t\treturn (obj, self.len_x-m, y)\n\t\n\tdef to_obj(self, s):\n\t\treturn [list(s)]\n\t\n\tdef arr_to_obj(self, arr):\n\t\treturn [list(s) for s in arr]\n", "description": null, "category": "graphics", "imports": ["import random", "from enum import Enum", "from copy import deepcopy"]}, {"term": "class", "name": "classGame:", "data": "class Game:\n\tclass Winner(Enum):\n\t\t_no_winner = 0\n\t\t_p_a_winner = 1\n\t\t_p_b_winner = 2\n\t\t_tie_winner = 3\n\t\n\tclass Flow(Enum):\n\t\t_normal = 0\n\t\t_break = 1\n\t\t_continue = 2\n\t\n\tdef __init__(self, deck):\n\t\tself._no_winner = self.Winner._no_winner\n\t\tself._p_a_winner = self.Winner._p_a_winner\n\t\tself._p_b_winner = self.Winner._p_b_winner\n\t\tself._tie_winner = self.Winner._tie_winner\n\t\t\n\t\tself._normal = self.Flow._normal\n\t\tself._break = self.Flow._break\n\t\tself._continue = self.Flow._continue\n\t\t\n\t\tself.default_deck = deck[:]\n\t\tself.deck = []\n\t\tself.p_a_grave = []\n\t\tself.p_b_grave = []\n\t\tself.p_a = []\n\t\tself.p_b = []\n\t\tself.p_a_play = []\n\t\tself.p_b_play = []\n\t\tself.graphics = Graphics()\n\t\t\n\t\tself.troops_text = \"# of troops: \"\n\t\tself.grave_text = \"Grave: \"\n\t\tself.win_sprite = \"<======}~+\"\n\t\tself.loss_sprite = \"+~{======>\"\n\t\tself.tie_sprite = \"+~{======>!!<======}~+\"\n\t\tself.victory_sprite = [\n\t\t\t\"\t   ..\",\n\t\t\t\"\to^/()\\\\^o\",\n\t\t\t\" o.^|\\\\/\\\\/\\\\/|^.o\",\n\t\t\t\"o\\\\*`'.\\\\||/.'`*/o\",\n\t\t\t\" \\\\/\\\\\\\\\\\\\\\\\\\\/////\\\\/\",\n\t\t\t\"  {><><[]><><}\",\n\t\t\t\"   \\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\"\n\t\t]\n\t\tself.defeat_sprite = [\n\t\t\t\"\t\t\t\to^/()\\\\^o\",\n\t\t\t\"\t   /`\to.^|\\\\/\\\\/\\\\/|^.o\",\n\t\t\t\"\\\\.....//----o\\\\*`'.\\\\|-------------------.\",\n\t\t\t\"/`````\\\\\\\\-----\\\\/\\\\\\\\\\\\\\\\\\\\--------------------`\",\n\t\t\t\"\t   \\\\.\t {><><[]><><}\",\n\t\t\t\"\t\t\t   \\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\"\n\t\t]\n\t\n\tdef shuffle(self, arr):\n\t\trandom.shuffle(arr)\n\t\n\tdef new_game(self):\n\t\tself.deck = self.default_deck[:]\n\t\tself.shuffle(self.deck)\n\t\t\n\t\tfor i in range(len(self.deck)):\n\t\t\tif i%2:\n\t\t\t\tself.p_b = [self.deck[i]] + self.p_b\n\t\t\telse:\n\t\t\t\tself.p_a = [self.deck[i]] + self.p_a\n\t\tself.deck = []\n\t\t\n\t\tobj = self.graphics.to_obj(\"War card game is starting!\")\n\t\tself.graphics.draw(obj, 16, 12)\n\t\t\n\t\tobj = self.graphics.to_obj(\"Press enter to continue.\")\n\t\tself.graphics.draw(obj, 17, 14)\n\t\t\n\t\tself.graphics.print_buffer()\n\t\tself.graphics.reset_buffer()\n\t\t\n\t\tinput(\"Press enter.\")\n\t\t\n\t\tself.basic_graphics()\n\t\tself.graphics.print_buffer()\n\t\tself.graphics.reset_buffer()\n\t\n\tdef draw_cards(self):\n\t\tself.p_a_play += [self.p_a.pop(0)]\n\t\tself.p_b_play += [self.p_b.pop(0)]\n\t\n\tdef clear_field(self, to):\n\t\tto += self.p_a_play + self.p_b_play\n\t\tself.p_a_play, self.p_b_play = [], []\n\t\n\tdef get_winner(self):\n\t\tif len(self.p_a) == len(self.p_b) == 0 == len(self.p_a_grave) == len(self.p_b_grave):\n\t\t\treturn self._tie_winner\n\t\telif len(self.p_a) == 0 == len(self.p_a_grave):\n\t\t\treturn self._p_b_winner\n\t\telif len(self.p_b) == 0 == len(self.p_b_grave):\n\t\t\treturn self._p_a_winner\n\t\telse:\n\t\t\treturn self._no_winner\n\t\n\tdef basic_graphics(self):\n\t\t# p_a\n\t\ttmp = self.troops_text+str(len(self.p_a))\n\t\tobj = self.graphics.to_obj(tmp)\n\t\tself.graphics.draw(obj, 0, 0)\n\t\t\n\t\ttmp = self.grave_text+str(len(self.p_a_grave))\n\t\tobj = self.graphics.to_obj(tmp)\n\t\tself.graphics.draw(obj, 0, 1)\n\t\t\n\t\t# p_b\n\t\ttmp = self.troops_text+str(len(self.p_b))\n\t\tobj = self.graphics.to_obj(tmp)\n\t\tself.graphics.draw(*self.graphics.right_justify(obj, 26))\n\t\t\n\t\ttmp = self.grave_text+str(len(self.p_b_grave))\n\t\tobj = self.graphics.to_obj(tmp)\n\t\tself.graphics.draw(*self.graphics.right_justify(obj, 25))\n\t\n\tdef needs_shuffle(self):\n\t\ta = len(self.p_a) == 0 and len(self.p_a_grave) > 0\n\t\tb = len(self.p_b) == 0 and len(self.p_b_grave) > 0\n\t\t\n\t\treturn (a, b)\n\t\n\tdef player_shuffle(self, a, b):\n\t\tif a:\n\t\t\tself.shuffle(self.p_a_grave)\n\t\t\tself.p_a += self.p_a_grave\n\t\t\tself.p_a_grave = []\n\t\tif b:\n\t\t\tself.shuffle(self.p_b_grave)\n\t\t\tself.p_b += self.p_b_grave\n\t\t\tself.p_b_grave = []\n\t\n\tdef display_shuffle_text(self, a, b):\n\t\tif a or b:\n\t\t\tinput(\"Shuffling...\")\n\t\t\t\n\t\t\tself.basic_graphics()\n\t\t\tobj = self.graphics.to_obj(\"Shuffled\")\n\t\t\tself.graphics.draw(obj, 25, 13)\n\t\t\t\n\t\t\tself.graphics.print_buffer()\n\t\t\tself.graphics.reset_buffer()\n\t\n\tdef draw_swords(self, v):\n\t\t# Put cards into proper grave, unless there's a war\n\t\tif v > 0:\n\t\t\tobj = self.graphics.to_obj(self.win_sprite)\n\t\t\tself.graphics.draw(obj, 19, 13)\n\t\telif v < 0:\n\t\t\tobj = self.graphics.to_obj(self.loss_sprite)\n\t\t\tself.graphics.draw(obj, 29, 13)\n\t\telse:\n\t\t\tobj = self.graphics.to_obj(self.tie_sprite)\n\t\t\tself.graphics.draw(obj, 18, 13)\n\t\n\tdef draw_field(self, ap, bp, modified = False):\n\t\tnm = not modified\n\t\t\n\t\ta = ap[-1]\n\t\tb = bp[-1]\n\t\t\n\t\tla = len(ap)\n\t\tlb = len(bp)\n\t\tlas = len(str(la - 1)) if nm else len(str(la))\n\t\t\n\t\t# Check if there's a war\n\t\ttmp = str(a)\n\t\tobj = self.graphics.to_obj(tmp)\n\t\tobj_ = self.graphics.to_obj(str(b))\n\t\tif la == 1 and nm:\n\t\t\t# If not, draw normally\n\t\t\tself.graphics.draw(obj, 27-(len(tmp))+1, 12)\n\t\t\tself.graphics.draw(obj_, 30, 14)\n\t\telse:\n\t\t\t# If so, show the stakes\n\t\t\tif nm:\n\t\t\t\tself.graphics.draw(obj, 27-(len(tmp))+1, 11)\n\t\t\t\tself.graphics.draw(obj_, 30, 15)\n\t\t\t\n\t\t\ttmp = str(la - 1) if nm else str(la)\n\t\t\tobj = self.graphics.to_obj(tmp+\">\")\n\t\t\tself.graphics.draw(obj, 27-las+1, 12)\n\t\t\t\n\t\t\ttmp = str(lb - 1) if nm else str(lb)\n\t\t\tobj = self.graphics.to_obj(\"<\"+tmp)\n\t\t\tself.graphics.draw(obj, 30, 14)\n\t\n\tdef print_end(self):\n\t\tres = self.get_winner()\n\t\tif res is self._no_winner:\n\t\t\tobj = self.graphics.to_obj(\"Game  quit\")\n\t\t\tself.graphics.draw(obj, 24, 18)\n\t\telif res is self._p_a_winner:\n\t\t\tobj = self.graphics.to_obj(\"You won!\")\n\t\t\tself.graphics.draw(obj, 25, 18)\n\t\t\t\n\t\t\tobj = self.graphics.to_obj(\"Out of troops!\")\n\t\t\tself.graphics.draw(*self.graphics.right_justify(obj, 24))\n\t\t\t\n\t\t\tobj = self.graphics.arr_to_obj(self.victory_sprite)\n\t\t\tself.graphics.draw(obj, 21, 3)\n\t\telif res is self._p_b_winner:\n\t\t\tobj = self.graphics.to_obj(\"You lost..\")\n\t\t\tself.graphics.draw(obj, 24, 18)\n\t\t\t\n\t\t\tobj = self.graphics.to_obj(\"Out of troops!\")\n\t\t\tself.graphics.draw(obj, 0, 2)\n\t\t\t\n\t\t\tobj = self.graphics.arr_to_obj(self.defeat_sprite)\n\t\t\tself.graphics.draw(obj, 9, 3)\n\t\telse:\n\t\t\tobj = self.graphics.to_obj(\"Tied  game\")\n\t\t\tself.graphics.draw(obj, 24, 18)\n\t\t\t\n\t\t\tobj = self.graphics.to_obj(\"Out of troops!\")\n\t\t\tself.graphics.draw(*self.graphics.right_justify(obj, 24))\n\t\t\t\n\t\t\tobj = self.graphics.to_obj(\"Out of troops!\")\n\t\t\tself.graphics.draw(obj, 0, 2)\n\t\n\tdef parse_command(self, inp):\n\t\t# Low-effort and inefficient.. but its just a few commands!\n\t\tif len(inp) > 0:\n\t\t\tif inp[0] == \"q\":\n\t\t\t\treturn self._break\n\t\t\telif inp[0] == \"peek\":\n\t\t\t\tan = self.p_a[0] if len(self.p_a) > 0 else None\n\t\t\t\tbn = self.p_b[0] if len(self.p_b) > 0 else None\n\t\t\t\tprint(\"a: {}, b: {}\".format(an, bn))\n\t\t\t\treturn self._continue\n\t\t\telif inp[0] == \"set\" and len(inp) >= 3:\n\t\t\t\tselected = None\n\t\t\t\tif inp[1] == \"a\":\n\t\t\t\t\tselected = self.p_a\n\t\t\t\telif inp[1] == \"b\":\n\t\t\t\t\tselected = self.p_b\n\t\t\t\ttry:\n\t\t\t\t\tselected[0] = int(inp[2])\n\t\t\t\texcept:\n\t\t\t\t\tpass\n\t\t\telif inp[0] == \"win\":\n\t\t\t\tself.p_b = []\n\t\t\t\tself.p_b_grave = []\n\t\t\t\treturn self._break\n\t\t\telif inp[0] == \"lose\":\n\t\t\t\tself.p_a = []\n\t\t\t\tself.p_a_grave = []\n\t\t\t\treturn self._break\n\t\treturn self._normal\n\t\n\tdef start_game_loop(self):\n\t\tinp = None\n\t\twhile self.get_winner() is self._no_winner:\n\t\t\t# Commands\n\t\t\tinp = input().split()\n\t\t\tflow = self.parse_command(inp)\n\t\t\t\n\t\t\tif flow is self._break:\n\t\t\t\tbreak\n\t\t\telif flow is self._continue:\n\t\t\t\tcontinue\n\t\t\t\n\t\t\t# Game logic\n\t\t\t\n\t\t\t# Draw cards\n\t\t\tself.draw_cards()\n\t\t\t\n\t\t\ta = self.p_a_play[-1]\n\t\t\tb = self.p_b_play[-1]\n\t\t\tv = a - b\n\t\t\t\n\t\t\tself.draw_swords(v)\n\t\t\tself.draw_field(self.p_a_play, self.p_b_play)\n\t\t\t\n\t\t\tif a == b:\n\t\t\t\t# War happened! Each side puts in 3 cards\n\t\t\t\ti = 0\n\t\t\t\tshuffled = False\n\t\t\t\twhile i < 3:\n\t\t\t\t\t# Check if shuffling is needed\n\t\t\t\t\tneed_shuffle = self.needs_shuffle()\n\t\t\t\t\tself.player_shuffle(*need_shuffle)\n\t\t\t\t\tif need_shuffle[0] or need_shuffle[1]:\n\t\t\t\t\t\tshuffled = True\n\t\t\t\t\t\n\t\t\t\t\t# Check if game is over\n\t\t\t\t\tif not self.get_winner() is self._no_winner:\n\t\t\t\t\t\tbreak\n\t\t\t\t\t\n\t\t\t\t\t# Put in a card for each side\n\t\t\t\t\tself.draw_cards()\n\t\t\t\t\t\n\t\t\t\t\t# Increment\n\t\t\t\t\ti += 1\n\t\t\t\t\n\t\t\t\tif shuffled:\n\t\t\t\t\tobj = self.graphics.to_obj(\"Shuffled during war.\")\n\t\t\t\t\tself.graphics.draw(obj, 19, 18)\n\t\t\t\n\t\t\t# Put cards to grave, unless there's a war\n\t\t\tif a > b:\n\t\t\t\tself.clear_field(self.p_a_grave)\n\t\t\telif a < b:\n\t\t\t\tself.clear_field(self.p_b_grave)\n\t\t\t\n\t\t\t# Print graphics\n\t\t\tself.basic_graphics()\n\t\t\tself.graphics.print_buffer()\n\t\t\tself.graphics.reset_buffer()\n\t\t\t\n\t\t\t# Shuffle if needed\n\t\t\tneed_shuffle = self.needs_shuffle()\n\t\t\tself.player_shuffle(*need_shuffle)\n\t\t\tself.display_shuffle_text(*need_shuffle)\n\t\t\n\t\t# Aftergame stuff\n\t\tif not (inp == [\"q\"] or inp == [\"win\"] or inp == [\"lose\"]):\n\t\t\tinput(\"Game ended.\")\n\t\t\n\t\tself.basic_graphics()\n\t\tself.print_end()\n\t\t\n\t\t# Check if there was a war\n\t\tif len(self.p_a_play) > 0:\n\t\t\tself.draw_swords(0)\n\t\t\t\n\t\t\t# Don't print field if player ran out of cards during a war\n\t\t\twar = len(self.p_a_play) % 4 != 0\n\t\t\tself.draw_field(self.p_a_play, self.p_b_play, war)\n\t\t\n\t\tself.graphics.print_buffer()\n\t\tself.graphics.reset_buffer()\n\t\t\n\t\tinput()\n\n\n", "description": null, "category": "graphics", "imports": ["import random", "from enum import Enum", "from copy import deepcopy"]}], [{"term": "class", "name": "GraphicsView", "data": "class GraphicsView(NSView):\n\tgraphicsContainer = ivar(u'graphicsContainer')\n\tgraphicsKeyPath   = ivar(u'graphicsKeyPath')\n\n\tselectionIndexesContainer = ivar(u'selectionIndexesContainer') # GraphicsArrayController\n\tselectionIndexesKeyPath   = ivar(u'selectionIndexesKeyPath')\n\n\toldGraphics = ivar(u'oldGraphics')\n\n\tdef exposedBindings(self):\n\t\treturn [u\"graphics\", u\"selectedObjects\"]\n\n\tdef initWithFrame_(self, frameRect):\n\t\treturn super(GraphicsView, self).initWithFrame_(frameRect)\n\t\t\n\tdef graphics(self):\n\t\tif not self.graphicsContainer: return None\n\t\treturn self.graphicsContainer.valueForKeyPath_(self.graphicsKeyPath)\n\t\t\n\tdef selectionIndexes(self):\n\t\tif not self.selectionIndexesContainer: return None\n\t\treturn self.selectionIndexesContainer.valueForKeyPath_(self.selectionIndexesKeyPath)\n\t\t\n\tdef startObservingGraphics_(self, graphics):\n\t\tif not graphics: return\n\t\t# Register to observe each of the new graphics, and\n\t\t# each of their observable properties -- we need old and new\n\t\t# values for drawingBounds to figure out what our dirty rect\n\t\tfor newGraphic in graphics:\n\t\t\t# Register as observer for all the drawing-related properties\n\t\t\tnewGraphic.addObserver_forKeyPath_options_context_(\n\t\t\t\tself, u\"drawingBounds\", (NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld), \n\t\t\t\tPropertyObservationContext)\n\t\t\tkeys = Circle.keysForNonBoundsProperties()\n\t\t\tfor key in keys:\n\t\t\t\tnewGraphic.addObserver_forKeyPath_options_context_(\n\t\t\t\t\tself, key, 0, PropertyObservationContext)\n\t\t\t\t\t\n\tdef stopObservingGraphics_(self, graphics):\n\t\tif graphics is None: return\n\t\tfor graphic in graphics:\n\t\t\tfor key in graphic.class__().keysForNonBoundsProperties():\n\t\t\t\tgraphic.removeObserver_forKeyPath_(self, key)\n\t\t\tgraphic.removeObserver_forKeyPath_(self, u\"drawingBounds\")\n\t\t\n\tdef bind_toObject_withKeyPath_options_(self, bindingName, observableObject, observableKeyPath, options):\n\t\tif bindingName == u\"graphics\":\n\t\t\tself.graphicsContainer = observableObject\n\t\t\tself.graphicsKeyPath = observableKeyPath\n\t\t\tself.graphicsContainer.addObserver_forKeyPath_options_context_(\n\t\t\t\t\tself, self.graphicsKeyPath, (NSKeyValueObservingOptionNew |\n\t\t\t\t\tNSKeyValueObservingOptionOld), GraphicsObservationContext)\n\t\t\tself.startObservingGraphics_(self.graphics())\n\t\t\t\n\t\telif bindingName == u\"selectionIndexes\":\n\t\t\tself.selectionIndexesContainer = observableObject\n\t\t\tself.selectionIndexesKeyPath = observableKeyPath\n\t\t\tself.selectionIndexesContainer.addObserver_forKeyPath_options_context_(\n\t\t\t\tself, self.selectionIndexesKeyPath, 0, SelectionIndexesObservationContext)\n\t\tself.setNeedsDisplay_(True)\n\t\t\n\tdef unbind_(self, bindingName):\n\t\tif bindingName == u\"graphics\":\n\t\t\tself.graphicsContainer.removeObserver_forKeyPath_(self, self.graphicsKeyPath)\n\t\t\tself.graphicsContainer = None\n\t\t\tself.graphicsKeyPath = None\n\t\tif bindingName == u\"selectionIndexes\":\n\t\t\tself.selectionIndexesContainer.removeObserver_forKeyPath_(self, self.selectionIndexesKeyPath)\n\t\t\tself.seletionIndexesContainer = None\n\t\t\tself.selectionIndexesKeyPath = None\n\t\tself.setNeedsDisplay_(True)\n\n\tdef observeValueForKeyPath_ofObject_change_context_(self, keyPath, object, change, context):\n\t\tif context == GraphicsObservationContext:\n\t\t\t# Should be able to use\n\t\t\t# NSArray *oldGraphics = [change objectForKey:NSKeyValueChangeOldKey];\n\t\t\t# etc. but the dictionary doesn't contain old and new arrays...??\n\t\t\tnewGraphics = Set(object.valueForKeyPath_(self.graphicsKeyPath))\n\t\t\tonlyNew = newGraphics - Set(self.oldGraphics)\n\t\t\tself.startObservingGraphics_(onlyNew)\n\t\t\t\n\t\t\tif self.oldGraphics:\n\t\t\t\tremoved = Set(self.oldGraphics) - newGraphics\n\t\t\t\tself.stopObservingGraphics_(removed)\n\t\t\t\n\t\t\tself.oldGraphics = newGraphics\n\t\t\t\n\t\t\t# could check drawingBounds of old and new, but...\n\t\t\tself.setNeedsDisplay_(True)\n\t\t\treturn\n\t\t\n\t\tif context == PropertyObservationContext:\n\t\t\tupdateRect = (0,)\n\t\t\t# Note: for Circle, drawingBounds is a dependent key of all the other\n\t\t\t# property keys except color, so we'll get this anyway...\n\t\t\tif keyPath == u\"drawingBounds\":\n\t\t\t\tnewBounds = change.objectForKey_(NSKeyValueChangeNewKey)\n\t\t\t\toldBounds = change.objectForKey_(NSKeyValueChangeOldKey)\n\t\t\t\tupdateRect = NSUnionRect(newBounds, oldBounds)\n\t\t\telse:\n\t\t\t\tupdateRect = object.drawingBounds()\n\t\t\tupdateRect = NSMakeRect(updateRect.origin.x-1.0,\n\t\t\t\t\t\t\t\tupdateRect.origin.y-1.0,\n\t\t\t\t\t\t\t\tupdateRect.size.width+2.0,\n\t\t\t\t\t\t\t\tupdateRect.size.height+2.0)\n\t\t\tself.setNeedsDisplay_(True)\n\t\t\treturn\n\t\t\t\n\t\tif context == SelectionIndexesObservationContext:\n\t\t\tself.setNeedsDisplay_(True)\n\t\t\treturn\n\n\tdef drawRect_(self, rect):\n\t\tmyBounds = self.bounds()\n\t\tNSDrawLightBezel(myBounds, myBounds) # AppKit Function\n\t\tclipRect = NSBezierPath.bezierPathWithRect_(NSInsetRect(myBounds, 2.0, 2.0))\n\t\tclipRect.addClip()\n\t\t\n\t\t# Draw graphics\n\t\tgraphicsArray = self.graphics()\n\t\tif graphicsArray:\n\t\t\tfor graphic in graphicsArray:\n\t\t\t\tgraphicDrawingBounds = graphic.drawingBounds()\n\t\t\t\tif NSIntersectsRect(rect, graphicDrawingBounds):\n\t\t\t\t\tgraphic.drawInView_(self)\n\t\t\n\t\t# Draw a red box around items in the current selection.\n\t\t# Selection should be handled by the graphic, but this is a\n\t\t# shortcut simply for display.\n\t\t\n\t\tcurrentSelectionIndexes = self.selectionIndexes() # ist das wir ein Array im Indezes?\n\t\tif currentSelectionIndexes != None:\n\t\t\tpath = NSBezierPath.bezierPath()\n\t\t\tindex = currentSelectionIndexes.firstIndex()\n\t\t\twhile index != NSNotFound:\n\t\t\t\tgraphicDrawingBounds = graphicsArray[index].drawingBounds()\n\t\t\t\tif NSIntersectsRect(rect, graphicDrawingBounds):\n\t\t\t\t\tpath.appendBezierPathWithRect_(graphicDrawingBounds)\n\t\t\t\tindex = currentSelectionIndexes.indexGreaterThanIndex_(index)\n\t\t\t\t\t\n\t\t\tNSColor.redColor().set()\n\t\t\tpath.setLineWidth_(1.5)\n\t\t\tpath.stroke()\n\n\t\t\t\n\t\t# Fairly simple just to illustrate the point\n\tdef mouseDown_(self, event):\t\t\n\t\t# find out if we hit anything\n\t\tp = self.convertPoint_fromView_(event.locationInWindow(), None)\n\t\tfor aGraphic in self.graphics():\n\t\t\tif aGraphic.hitTest_isSelected_(p, False):\n\t\t\t\tbreak; # aGraphic soll spaeter einen Wert haben, falls es getroffene gibt!\n\t\telse:\n\t\t\taGraphic = None\n\t\t\t\t\n\t\t# if no graphic hit, then if extending selection do nothing\n\t\t# else set selection to nil\n\t\tif aGraphic == None:\n\t\t\tif not event.modifierFlags() & NSShiftKeyMask:\n\t\t\t\tself.selectionIndexesContainer.setValue_forKeyPath_(None, self.selectionIndexesKeyPath)\n\t\t\treturn\n\t\t\t\n\t\t# graphic hit\n\t\t# if not extending selection (Shift key down) then set\n\t\t# selection to this graphic\n\t\t# if extending selection, then:\n\t\t# - if graphic in selection remove it\n\t\t# - if not in selection add it\n\t\tgraphicIndex = self.graphics().index(aGraphic)\n\t\tif not event.modifierFlags() & NSShiftKeyMask:\n\t\t\tselection = NSIndexSet.indexSetWithIndex_(graphicIndex)\n\t\telse:\n\t\t\tif  self.selectionIndexes().containsIndex_(graphicIndex):\n\t\t\t\tselection = self.selectionIndexes().mutableCopy()\n\t\t\t\tselection.removeIndex_(graphicIndex)\n\t\t\telse:\n\t\t\t\tselection = self.selectionIndexes().mutableCopy()\n\t\t\t\tselection.addIndex_(graphicIndex)\n\t\tself.selectionIndexesContainer.setValue_forKeyPath_(selection, self.selectionIndexesKeyPath)\n\n", "description": null, "category": "graphics", "imports": ["from Foundation import *", "from AppKit import *", "from objc import ivar", "from Circle import Circle", "from sets import Set"]}], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, **kargs):\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, **kargs):\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [], [], [{"term": "class", "name": "GraphicsTest", "data": "class GraphicsTest(SampleBase):\n\tdef __init__(self, *args, **kwargs):\n\t\tsuper(GraphicsTest, self).__init__(*args, **kwargs)\n\n\tdef run(self):\n\t\tcanvas = self.matrix\n\t\tfont = graphics.Font()\n\t\tfont.LoadFont(\"../../../fonts/7x13.bdf\")\n\n\t\tred = graphics.Color(255, 0, 0)\n\t\tgraphics.DrawLine(canvas, 5, 5, 22, 13, red)\n\n\t\tgreen = graphics.Color(0, 255, 0)\n\t\tgraphics.DrawCircle(canvas, 15, 15, 10, green)\n\n\t\tblue = graphics.Color(0, 0, 255)\n\t\tgraphics.DrawText(canvas, font, 2, 10, blue, \"Text\")\n\n\t\ttime.sleep(10)   # show display for 10 seconds before exit\n\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "import time"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\t# Add animation loop here!\n\twhile True:\n\t\tglobal NUM_LIVES\n\t\tgraphics.check_collision()\n\t\tgraphics.remove_brick()\n\t\tif graphics.double_score_exist is True:\n\t\t\tgraphics.double_score.move(0, 7)\n\t\t\tgraphics.double_score_switch()\n\t\t\tif graphics.double_score_start is True:\n\t\t\t\tgraphics.double_score_exec()\n\t\tif graphics.shorten_paddle_exist is True:\n\t\t\tgraphics.shorten_paddle.move(0, 7)\n\t\t\tgraphics.shorten_paddle_switch()\n\t\t\tif graphics.shorten_paddle_start is True:\n\t\t\t\tgraphics.shorten_paddle_exec()\n\t\tif graphics.no_bricks():\n\t\t\tgraphics.win_game()\n\t\t\tbreak\n\t\tif graphics.ball.x <= 0 or (graphics.ball.x + graphics.ball.width) > graphics.window.width:\n\t\t\tgraphics.set_velocity_x()\n\t\telif graphics.ball.y <= 0:\n\t\t\tgraphics.set_velocity_y()\n\t\tdx = graphics.get_velocity_x()\n\t\tdy = graphics.get_velocity_y()\n\t\tgraphics.ball.move(dx, dy)\n\t\tgraphics.update_score()\n\t\tif graphics.ball.y > graphics.window.height:\n\t\t\tNUM_LIVES -= 1\n\t\t\tif NUM_LIVES == 2:\n\t\t\t\tgraphics.window.remove(graphics.heart3)\n\t\t\t\tgraphics.reset_ball()\n\t\t\telif NUM_LIVES == 1:\n\t\t\t\tgraphics.window.remove(graphics.heart2)\n\t\t\t\tgraphics.reset_ball()\n\t\t\telif NUM_LIVES <= 0:\n\t\t\t\tgraphics.window.remove(graphics.heart1)\n\t\t\t\tgraphics.game_over()\n\t\t\t\tbreak\n\t\tpause(FRAME_RATE)\n\n\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics_extension import BreakoutGraphics"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tlives = NUM_LIVES\n\n\twhile True:\t\t\t\t\t\t\t\t\t\t\t\t\t\t # main while loop\n\t\tpause(1)\n\t\tif lives == 0:\t\t\t\t\t\t\t\t\t\t\t\t  # lost game condition\n\t\t\tprint(f'game over! left brick:{graphics.brick_num}')\n\t\t\tbreak\n\n\t\twhile graphics.is_running:\t\t\t\t\t\t\t\t\t  # while loop of running the ball\n\t\t\tpause(FRAME_RATE)\n\t\t\tgraphics.ball.move(graphics.vx, graphics.vy)\t\t\t\t# ball move per frame rate\n\n\t\t\t# lost lives\n\t\t\tif graphics.ball.y > graphics.window.height:\t\t\t\t# when ball falls out of window, lives-1\n\t\t\t\tlives -= 1\n\t\t\t\tif lives > 0:\t\t\t\t\t\t\t\t\t\t   # when have lives, reset game\n\t\t\t\t\tgraphics.is_running = False\n\t\t\t\tbreak\n\n\t\t\tif graphics.brick_num == 0:\n\t\t\t\tgraphics.is_running = False\t\t\t\t\t\t\t # win game condition\n\t\t\t\tprint('Clear')\n\t\t\t\tbreak\n\n\t\t\t#  3 wall rebound\n\t\t\tif not 0 <= graphics.ball.x <= graphics.window.width-graphics.ball.width:\n\t\t\t\tgraphics.vx *= -1\n\t\t\tif not 0 <= graphics.ball.y:\n\t\t\t\tgraphics.vy *= -1\n\n\t\t\t# def up, down, left ,right 4 point of ball\n\t\t\tball_u = graphics.window.get_object_at(graphics.ball.x+graphics.ball.width/2, graphics.ball.y-1)\n\t\t\tball_d = graphics.window.get_object_at(\n\t\t\t\tgraphics.ball.x+graphics.ball.width/2, graphics.ball.y+graphics.ball.height+1)\n\t\t\tball_l = graphics.window.get_object_at(graphics.ball.x-1, graphics.ball.y+graphics.ball.height/2)\n\t\t\tball_r = graphics.window.get_object_at(\n\t\t\t\tgraphics.ball.x+graphics.ball.width+1, graphics.ball.y+graphics.ball.height/2)\n\n\t\t\tnot_brick = [graphics.paddle, graphics.ball]\t\t\t\t# not brick list (can't remove by ball touch)\n\n\t\t\t# check what point touch something then rebound, and if it's brick, remove it\n\t\t\tif ball_d is not None and graphics.vy > 0:\t\t\t\t  # when ball move down and touch something\n\t\t\t\tgraphics.vy *= -1\t\t\t\t\t\t\t\t\t   # y axis rebound\n\t\t\t\tif ball_d not in not_brick:\n\t\t\t\t\tgraphics.window.remove(ball_d)\t\t\t\t\t  # remove brick which touched by ball\n\t\t\t\t\tgraphics.brick_num -= 1\t\t\t\t\t\t\t # brick_num -1\n\t\t\telif ball_l is not None and graphics.vx < 0:\n\t\t\t\tgraphics.vx *= -1\n\t\t\t\tif ball_l not in not_brick:\n\t\t\t\t\tgraphics.window.remove(ball_l)\n\t\t\t\t\tgraphics.brick_num -= 1\n\t\t\telif ball_r is not None and graphics.vx > 0:\n\t\t\t\tgraphics.vx *= -1\n\t\t\t\tif ball_r not in not_brick:\n\t\t\t\t\tgraphics.window.remove(ball_r)\n\t\t\t\t\tgraphics.brick_num -= 1\n\t\t\telif ball_u is not None and graphics.vy < 0:\n\t\t\t\tgraphics.vy *= -1\n\t\t\t\tif ball_u not in not_brick:\n\t\t\t\t\tgraphics.window.remove(ball_u)\n\t\t\t\t\tgraphics.brick_num -= 1\n\n\t\t\t# don't like below condition\n\t\t\t# ball_ul = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y)\n\t\t\t# ball_ur = graphics.window.get_object_at(graphics.ball.x+graphics.ball.width, graphics.ball.y)\n\t\t\t# ball_dl = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y+graphics.ball.height)\n\t\t\t# ball_dr = graphics.window.get_object_at(\n\t\t\t#\t graphics.ball.x+graphics.ball.height, graphics.ball.y+graphics.ball.height)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "class", "name": "TGraphicsObject", "data": "class TGraphicsObject( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateGraphicsObject( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.GraphicsObject_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.GraphicsObject_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TFont", "data": "class TFont( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateFont( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Font_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Font_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TPen", "data": "class TPen( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreatePen( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Pen_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Pen_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBrush", "data": "class TBrush( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBrush( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Brush_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Brush_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TCanvas", "data": "class TCanvas( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateCanvas( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Canvas_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Canvas_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TGraphic", "data": "class TGraphic( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateGraphic( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Graphic_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Graphic_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TPicture", "data": "class TPicture( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreatePicture( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Picture_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Picture_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafileCanvas", "data": "class TMetafileCanvas( TCanvas ):\r\n\tdef Create( Self, AMetafile, ReferenceDevice ):\r\n\t\treturn _Graphics.CreateMetafileCanvas( Self, AMetafile, ReferenceDevice )\r\n\r\n\tdef CreateWithComment( Self, AMetafile, ReferenceDevice, CreatedBy, Description ):\r\n\t\treturn _Graphics.CreateWithCommentMetafileCanvas( Self, AMetafile, ReferenceDevice, CreatedBy, Description )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.MetafileCanvas_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.MetafileCanvas_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TSharedImage", "data": "class TSharedImage(TObject):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateSharedImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.SharedImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.SharedImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafileImage", "data": "class TMetafileImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateMetafileImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.MetafileImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.MetafileImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafile", "data": "class TMetafile( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateMetafile( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Metafile_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Metafile_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBitmapImage", "data": "class TBitmapImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBitmapImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.BitmapImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.BitmapImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBitmap", "data": "class TBitmap( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBitmap( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Bitmap_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Bitmap_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TIconImage", "data": "class TIconImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateIconImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.IconImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.IconImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TIcon", "data": "class TIcon( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateIcon( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Icon_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Icon_SetAttr( Self, Key, Value )\r\n\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}], [{"term": "class", "name": "TGraphicsObject", "data": "class TGraphicsObject( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateGraphicsObject( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.GraphicsObject_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.GraphicsObject_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TFont", "data": "class TFont( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateFont( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Font_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Font_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TPen", "data": "class TPen( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreatePen( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Pen_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Pen_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBrush", "data": "class TBrush( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBrush( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Brush_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Brush_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TCanvas", "data": "class TCanvas( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateCanvas( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Canvas_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Canvas_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TGraphic", "data": "class TGraphic( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateGraphic( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Graphic_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Graphic_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TPicture", "data": "class TPicture( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreatePicture( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Picture_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Picture_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafileCanvas", "data": "class TMetafileCanvas( TCanvas ):\r\n\tdef Create( Self, AMetafile, ReferenceDevice ):\r\n\t\treturn _Graphics.CreateMetafileCanvas( Self, AMetafile, ReferenceDevice )\r\n\r\n\tdef CreateWithComment( Self, AMetafile, ReferenceDevice, CreatedBy, Description ):\r\n\t\treturn _Graphics.CreateWithCommentMetafileCanvas( Self, AMetafile, ReferenceDevice, CreatedBy, Description )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.MetafileCanvas_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.MetafileCanvas_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TSharedImage", "data": "class TSharedImage(TObject):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateSharedImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.SharedImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.SharedImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafileImage", "data": "class TMetafileImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateMetafileImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.MetafileImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.MetafileImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafile", "data": "class TMetafile( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateMetafile( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Metafile_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Metafile_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBitmapImage", "data": "class TBitmapImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBitmapImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.BitmapImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.BitmapImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBitmap", "data": "class TBitmap( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBitmap( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Bitmap_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Bitmap_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TIconImage", "data": "class TIconImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateIconImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.IconImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.IconImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TIcon", "data": "class TIcon( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateIcon( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Icon_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Icon_SetAttr( Self, Key, Value )\r\n\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}], [], [], [], [], [{"term": "class", "name": "classAnimationPlayer:", "data": "class AnimationPlayer:\n\tdef __init__(self):\n\t\tself.frames = {\n\t\t\t# magic\n\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\n\t\t\t'aura': import_folder('../graphics/particles/aura'),\n\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\n\t\t\t\n\t\t\t# attacks \n\t\t\t'claw': import_folder('../graphics/particles/claw'),\n\t\t\t'slash': import_folder('../graphics/particles/slash'),\n\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\n\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\n\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\n\n\t\t\t# monster deaths\n\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\n\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\n\t\t\t'spirit': import_folder('../graphics/particles/nova'),\n\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\n\t\t\t\n\t\t\t# leafs \n\t\t\t'leaf': (\n\t\t\t\timport_folder('../graphics/particles/leaf1'),\n\t\t\t\timport_folder('../graphics/particles/leaf2'),\n\t\t\t\timport_folder('../graphics/particles/leaf3'),\n\t\t\t\timport_folder('../graphics/particles/leaf4'),\n\t\t\t\timport_folder('../graphics/particles/leaf5'),\n\t\t\t\timport_folder('../graphics/particles/leaf6'),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\n\t\t\t\t)\n\t\t\t}\n\t\n\tdef reflect_images(self,frames):\n\t\tnew_frames = []\n\n\t\tfor frame in frames:\n\t \t\tflipped_frame = pygame.transform.flip(frame,True,False)\n\t \t\tnew_frames.append(flipped_frame)\n\t\treturn new_frames\n\n\tdef create_grass_particles(self,pos,groups):\n\t \tanimation_frames = choice(self.frames['leaf'])\n\t \tParticleEffect(pos,animation_frames,groups)\n\n\tdef create_particles(self,animation_type,pos,groups):\n\t\tanimation_frames = self.frames[animation_type]\n\t\tParticleEffect(pos,animation_frames,groups)\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\n\tdef __init__(self,pos,animation_frames,groups):\n\t\tsuper().__init__(groups)\n\t\tself.sprite_type = 'magic'\n\t\tself.frame_index = 0\n\t\tself.animation_speed = 0.15\n\t\tself.frames = animation_frames\n\t\tself.image = self.frames[self.frame_index]\n\t\tself.rect = self.image.get_rect(center = pos)\n\n\tdef animate(self):\n\t\tself.frame_index += self.animation_speed\n\t\tif self.frame_index >= len(self.frames):\n\t\t\tself.kill()\n\t\telse:\n\t\t\tself.image = self.frames[int(self.frame_index)]\n\n\tdef update(self):\n\t\tself.animate()\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}], [{"term": "class", "name": "GraphicsObject", "data": "class GraphicsObject(GraphicsItem, QtGui.QGraphicsObject):\n\t\"\"\"\n\t**Bases:** :class:`GraphicsItem `, :class:`QtGui.QGraphicsObject`\n\n\tExtension of QGraphicsObject with some useful methods (provided by :class:`GraphicsItem `)\n\t\"\"\"\n\t_qtBaseClass = QtGui.QGraphicsObject\n\tdef __init__(self, *args):\n\t\tself.__inform_view_on_changes = True\n\t\tQtGui.QGraphicsObject.__init__(self, *args)\n\t\tself.setFlag(self.GraphicsItemFlag.ItemSendsGeometryChanges)\n\t\tGraphicsItem.__init__(self)\n\t\t\n\tdef itemChange(self, change, value):\n\t\tret = super().itemChange(change, value)\n\t\tif change in [self.GraphicsItemChange.ItemParentHasChanged, self.GraphicsItemChange.ItemSceneHasChanged]:\n\t\t\tself.parentChanged()\n\t\ttry:\n\t\t\tinform_view_on_change = self.__inform_view_on_changes\n\t\texcept AttributeError:\n\t\t\t# It's possible that the attribute was already collected when the itemChange happened\n\t\t\t# (if it was triggered during the gc of the object).\n\t\t\tpass\n\t\telse:\n\t\t\tif inform_view_on_change and change in [self.GraphicsItemChange.ItemPositionHasChanged, self.GraphicsItemChange.ItemTransformHasChanged]:\n\t\t\t\tself.informViewBoundsChanged()\n\t\t\t\n\t\t## workaround for pyqt bug:\n\t\t## http://www.riverbankcomputing.com/pipermail/pyqt/2012-August/031818.html\n\t\tif QT_LIB == 'PyQt5' and change == self.GraphicsItemChange.ItemParentChange and isinstance(ret, QtGui.QGraphicsItem):\n\t\t\tret = sip.cast(ret, QtGui.QGraphicsItem)\n\n\t\treturn ret\n", "description": "\n\t**Bases:** :class:`GraphicsItem `, :class:`QtGui.QGraphicsObject`\n\n\tExtension of QGraphicsObject with some useful methods (provided by :class:`GraphicsItem `)\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui, QT_LIB", "\tfrom ..Qt import sip", "from .GraphicsItem import GraphicsItem"]}], [{"term": "class", "name": "GraphicManager", "data": "class GraphicManager(object):\n\tdef __init__(self):\n\t\tpygame.init()\n\t\tsize = width, height = 1000, 768\n\t\tself.black = 0, 0, 0\n\t\tself.screen = pygame.display.set_mode(size)\n\t\tself.graphicsList = []\n\t\tself.graphicsListG = []\n\t\tself.graphicsDict = {}\n\t\tself.recordDict = {}\n\t\tself.recording = False\n\n\tdef addGraphic(self, name, x, y, gain, offset):\n\t\tgraphic = DataGraphic(100, 100, x, y, gain, offset, name)\n\t\tself.graphicsList.append(graphic)\n\t\tself.graphicsListG.append(graphic)\n\t\tself.graphicsDict[name] = graphic\n\t\tself.recordDict[name] = [] #Prepere the graphic to be possibili recorded\n\n\tdef showGraphics(self):\n\t\tfor graphic in self.graphicsList:\n\t\t\tgraphic.showPoints(self.screen)\n\n\tdef updateGraphic(self, name, value):\n\t\tself.graphicsDict[name].update(value)\n\t\tif self.recording:\n\t\t\tself.recordDict[name].append(value)\n\t\n\tdef startRecording(self):\n\t\t#clean the recordDict\n\t\tfor key in self.recordDict:\n\t\t\tself.recordDict[key] = []\n\t\tself.recording = True\n\n\tdef stopRecording(self):\n\t\tself.recording = False\n\t\tarq = open('signals/teste.txt','w')\n\t\tfor name in self.recordDict:\n\t\t\tarq.write(name + ';' + str(self.graphicsDict[name].length) + ';' +  str(self.graphicsDict[name].height) + ';' +  str(self.graphicsDict[name].x) +';' +  str(self.graphicsDict[name].y) + ';' +  str(self.graphicsDict[name].gain)+'\\n')\n\t\t\tfor value in self.recordDict[name]:\n\t\t\t\tarq.write(str(value)+';')\n\t\t\tarq.write('\\n')\n\t\tarq.close()\n\n\tdef show(self):\n\t\tfor event in pygame.event.get():\n\t\t\tif event.type == pygame.QUIT: \n\t\t\t\tsys.exit()\n\t\t\tif event.type == pygame.KEYDOWN:\n\t\t\t\tif event.key == pygame.K_r:\n\t\t\t\t\tif self.recording:\n\t\t\t\t\t\tself.stopRecording()\n\t\t\t\t\t\tprint 'stopRecording'\n\t\t\t\t\telse:\n\t\t\t\t\t\tself.startRecording()\n\t\t\t\t\t\tprint 'startRecording'\n\t\t\t\tif event.key == pygame.K_g:\n\t\t\t\t\tself.graphicsList = []\n\t\t\t\t\tfor graphic in self.graphicsListG:\n\t\t\t\t\t\tgraphic.length = 100\n\t\t\t\t\t\tgraphic.height = 100\n\t\t\t\t\t\tgraphic.x = graphic.xInit\n\t\t\t\t\t\tgraphic.y = graphic.yInit\n\t\t\t\t\t\tgraphic.initialShow = True\n\t\t\t\t\t\tself.graphicsList.append(graphic)\n\t\t\t\tmods = pygame.key.get_mods()\n\t\t\t\tif mods & pygame.KMOD_SHIFT:\n\t\t\t\t\tif event.key == pygame.K_0:\n\t\t\t\t\t\tself.graphicsList = [self.graphicsListG[0]]\n\t\t\t\t\t\tself.graphicBig()\n\t\t\t\t\tif event.key == pygame.K_1:\n\t\t\t\t\t\tself.graphicsList = [self.graphicsListG[1]]\n\t\t\t\t\t\tself.graphicBig()\n\n\t\t\t\t\tif event.key == pygame.K_2:\n\t\t\t\t\t\tself.graphicsList = [self.graphicsListG[2]]\n\t\t\t\t\t\tself.graphicBig()\n\n\t\t\t\t\tif event.key == pygame.K_3:\n\t\t\t\t\t\tself.graphicsList = [self.graphicsListG[3]]\n\t\t\t\t\t\tself.graphicBig()\n\n\t\t\t\t\tif event.key == pygame.K_4:\n\t\t\t\t\t\tself.graphicsList = [self.graphicsListG[4]]\n\t\t\t\t\t\tself.graphicBig()\n\n\t\t\t\t\tif event.key == pygame.K_5:\n\t\t\t\t\t\tself.graphicsList = [self.graphicsListG[5]]\n\t\t\t\t\t\tself.graphicBig()\n\n\t\t\t\t\tif event.key == pygame.K_6:\n\t\t\t\t\t\tself.graphicsList = [self.graphicsListG[6]]\n\t\t\t\t\t\tself.graphicBig()\n\n\t\t\t\t\tif event.key == pygame.K_7:\n\t\t\t\t\t\tself.graphicsList = [self.graphicsListG[7]]\n\t\t\t\t\t\tself.graphicBig()\n\n\t\t\t\t\tif event.key == pygame.K_8:\n\t\t\t\t\t\tself.graphicsList = [self.graphicsListG[8]]\n\t\t\t\t\t\tself.graphicBig()\n\n\t\t\t\t\tif event.key == pygame.K_9:\n\t\t\t\t\t\tself.graphicsList = [self.graphicsListG[9]]\n\t\t\t\t\t\tself.graphicBig()\n\n\t\t\t\t\tif event.key == pygame.K_a:\n\t\t\t\t\t\tself.graphicsList = [self.graphicsListG[10]]\n\t\t\t\t\t\tself.graphicBig()\n\n\t\t\t\t\tif event.key == pygame.K_b:\n\t\t\t\t\t\tself.graphicsList = [self.graphicsListG[11]]\n\t\t\t\t\t\tself.graphicBig()\n\n\t\t\t\t\tif event.key == pygame.K_c:\n\t\t\t\t\t\tself.graphicsList = [self.graphicsListG[12]]\n\t\t\t\t\t\tself.graphicBig()\n\n\t\t\t\t\tif event.key == pygame.K_d:\n\t\t\t\t\t\tself.graphicsList = [self.graphicsListG[13]]\n\t\t\t\t\t\tself.graphicBig()\n\n\t\t\t\t\tif event.key == pygame.K_e:\n\t\t\t\t\t\tself.graphicsList = [self.graphicsListG[14]]\n\t\t\t\t\t\tself.graphicBig()\n\n\t\t\t\t\tif event.key == pygame.K_f:\n\t\t\t\t\t\tself.graphicsList = [self.graphicsListG[15]]\n\t\t\t\t\t\tself.graphicBig()\n\n\t\t\t\t\tif event.key == pygame.K_g:\n\t\t\t\t\t\tself.graphicsList = [self.graphicsListG[16]]\n\t\t\t\t\t\tself.graphicBig()\n\n\t\t\t\t\t\t\n\t\tself.screen.fill(self.black)\n\t\tself.showGraphics()\n\t\tpygame.display.flip()\n\tdef graphicBig(self):\n\t\tself.graphicsList[0].length = 500\n\t\tself.graphicsList[0].x = 10\n\t\tself.graphicsList[0].y = 10\n\t\tself.graphicsList[0].height = 500\n\t\tself.graphicsList[0].initialShow = True\n\n", "description": null, "category": "graphics", "imports": ["import sys, pygame", "from DataGraphic import *"]}], [{"term": "class", "name": "classbutton:\r", "data": "class button:\r\n\t'''Used to determine the cell that was clicked'''\r\n\tdef wasClicked(point, cell_list, width):\r\n\t\t\"\"\"Returns the cell clicked\r\n\t\t\tParameters:\r\n\t\t\t\tpoint: The point that a user clicked\r\n\t\t\t\tcell_list: list of cells to search through\r\n\t\t\t\twidth: width of each cell\r\n\t\t\"\"\"\r\n\t\tfor cell in cell_list: #iterates through the list of cells\r\n\t\t\tif ((cell[0] - width) <= point[0] <= (cell[0] + width)) \\\r\n\t\t\tand ((cell[1] - width) <= point[1] <= (cell[1] + width)):\r\n\t\t\t\treturn cell #returns if the point clicked is in the cell\r\n", "description": "Returns the cell clicked\r\n\t\t\tParameters:\r\n\t\t\t\tpoint: The point that a user clicked\r\n\t\t\t\tcell_list: list of cells to search through\r\n\t\t\t\twidth: width of each cell\r\n\t\t", "category": "graphics", "imports": ["import graphics\r", "import random\r", "import time\r"]}, {"term": "class", "name": "classbackground:\r", "data": "class background:\r\n\t'''Used to set the window background'''\r\n\tdef set_background(win):\r\n\t\t'''Colors the window background\r\n\t\tParameters:\r\n\t\t\twin: the window to draw to\r\n\t\t'''\r\n\t\twin.setBackground('grey') #sets background color to grey\r\n\r\n\t\tboard = graphics.Rectangle(graphics.Point(10,10), graphics.Point(690,690))\r\n\t\tboard.setFill('white')\r\n\t\tboard.draw(win) #draws a white rectangle to be the board\r\n\r\n\tdef create_board(win, difficulty, celllist):\r\n\t\t'''Draws the game board\r\n\t\tParameters:\r\n\t\t\tdifficulty: is 1/10th the width and height of each cell\r\n\t\t\twin: the window to draw to\r\n\t\t'''\r\n\t\tcolor_list = ['pink', 'orange', 'yellow', 'light green', 'light blue', 'purple', 'white']\r\n\r\n\t\t#grid_outline is a list lines that outline the game board\r\n\t\tgrid_outline = [graphics.Line(graphics.Point(10,10),graphics.Point(10,690)),\r\n\t\tgraphics.Line(graphics.Point(10,10),graphics.Point(690,10)),\r\n\t\tgraphics.Line(graphics.Point(10,690),graphics.Point(690,690)),\r\n\t\tgraphics.Line(graphics.Point(690,10),graphics.Point(690,690))]\r\n\r\n\t\tfor line in grid_outline: #iterates over every outline and draws it\r\n\t\t\t\tline.draw(win)\r\n\r\n\t\tcolorful_board = False\r\n\t\tif difficulty > 4: #if there aren't too many cells\r\n\t\t\tcolorful_board = background.ask_colorful(win)\r\n\t\tif colorful_board == True:\r\n\t\t\tcolor = 0\r\n\t\t\tfor cell in celllist:\r\n\t\t\t\tcolored_cell = graphics.Rectangle(graphics.Point(cell[0] - 5 * \\\r\n\t\t\t\t\tdifficulty, cell[1] + 5 *difficulty), \\\r\n\t\t\t\t\tgraphics.Point(cell[0] + 5 * difficulty, cell[1] - 5 * difficulty))\r\n\t\t\t\tcolored_cell.setFill(color_list[color % 7])\r\n\t\t\t\tcolored_cell.draw(win)\r\n\t\t\t\tcolor += 1\r\n\t\telse: #otherwise don't make the cells colorful\r\n\t\t\t#iterates over the number of grid lines to be drawn for \r\n\t\t\t\t#that difficulty and draws them\r\n\t\t\tfor line in range(680 // int(10 * difficulty)):\r\n\t\t\t\tgraphics.Line(graphics.Point((10 + (difficulty  * 10) * line), 10), \\\r\n\t\t\t\t\tgraphics.Point((10 + (difficulty  * 10) * line), 690)).draw(win)\r\n\t\t\t\tgraphics.Line(graphics.Point(10, (10 + (difficulty  * 10) * line)), \\\r\n\t\t\t\t\tgraphics.Point(690, (10 + (difficulty  * 10) * line))).draw(win)\r\n\r\n\tdef ask_colorful(win):\r\n\t\t'''Asks the user if they want to play again and returns 'yes' or 'No'\r\n\t\tParameters:\r\n\t\t\twin: the window to draw to\r\n\t\t'''\r\n\t\t#creates a rectangle that asks Play again? on the screen\r\n\t\tcolorboard = graphics.Rectangle(graphics.Point(270, 250),\\\r\n\t\t\tgraphics.Point(430, 330))\r\n\t\tcolorboard.setFill('light blue')\r\n\t\ttcolor = graphics.Text(graphics.Point(350, 290), \"Colorful Board?\")\r\n\t\ttcolor.setSize(18)\r\n\t\ttcolor.setFill('black')\r\n\t\tcolorboard.draw(win)\r\n\t\ttcolor.draw(win)\r\n\r\n\t\t#creates another rect. that asks quit\r\n\t\tboring = graphics.Rectangle(graphics.Point(270, 380),\\\r\n\t\t\tgraphics.Point(430, 460))\r\n\t\tboring.setFill('grey')\r\n\t\ttboring = graphics.Text(graphics.Point(350, 420), \"Plain Boring Board?\")\r\n\t\ttboring.setSize(18)\r\n\t\ttboring.setFill('black')\r\n\t\tboring.draw(win)\r\n\t\ttboring.draw(win)\r\n\r\n\t\t#waits for user to click either Quit or Play again? and\r\n\t\t\t#returns the cooresponding value\r\n\t\tcolor = 'idk'\r\n\r\n\t\twhile color == 'idk': \r\n\t\t\tmouse = win.getMouse()\r\n\t\t\tif 270 < mouse.getX() < 430:\r\n\t\t\t\tif 250 < mouse.getY() < 330:\r\n\t\t\t\t\tcolor = True\r\n\t\t\t\tif 380 < mouse.getY() < 460:\r\n\t\t\t\t\tcolor = False\r\n\t\t\r\n\t\tcolorboard.undraw()\r\n\t\ttcolor.undraw()\r\n\t\tboring.undraw()\r\n\t\ttboring.undraw()\r\n\r\n\t\treturn color\r\n\r\n", "description": null, "category": "graphics", "imports": ["import graphics\r", "import random\r", "import time\r"]}, {"term": "class", "name": "classplay_minesweeper_again:\r", "data": "class play_minesweeper_again:\r\n\t'''Used to ask the user if they want to play the game again'''\r\n\tdef ask(win, already_drawn):\r\n\t\t'''Asks the user if they want to play again and returns 'yes' or 'No'\r\n\t\tParameters:\r\n\t\t\twin: the window to draw to\r\n\t\t'''\r\n\t\tif already_drawn == 'no':\r\n\t\t\t#creates a rectangle that asks Play again? on the screen\r\n\t\t\tplay_again = graphics.Rectangle(graphics.Point(230, 380),\\\r\n\t\t\t\tgraphics.Point(330, 460))\r\n\t\t\tplay_again.setFill('grey')\r\n\t\t\ttplay = graphics.Text(graphics.Point(280, 420), \"Play again?\")\r\n\t\t\ttplay.setSize(18)\r\n\t\t\ttplay.setFill('black')\r\n\t\t\tplay_again.draw(win)\r\n\t\t\ttplay.draw(win)\r\n\r\n\t\t\t#creates another rect. that asks quit\r\n\t\t\tquit = graphics.Rectangle(graphics.Point(370, 380),\\\r\n\t\t\t\tgraphics.Point(470, 460))\r\n\t\t\tquit.setFill('grey')\r\n\t\t\ttq = graphics.Text(graphics.Point(420, 420), \"Quit\")\r\n\t\t\ttq.setSize(18)\r\n\t\t\ttq.setFill('red')\r\n\t\t\tquit.draw(win)\r\n\t\t\ttq.draw(win)\r\n\r\n\t\t#waits for user to click either Quit or Play again? and\r\n\t\t\t#returns the cooresponding value\r\n\t\tplay_again = 'idk'\r\n\r\n\r\n\t\twhile play_again == 'idk': \r\n\t\t\tmouse = win.getMouse()\r\n\t\t\tif 380 < mouse.getY() < 460:\r\n\t\t\t\tif 230 < mouse.getX() < 330:\r\n\t\t\t\t\tplay_again = 'Yes'\r\n\t\t\t\tif 370 < mouse.getX() < 470:\r\n\t\t\t\t\tplay_again = 'No'\r\n\t\t\treturn play_again\r\n", "description": null, "category": "graphics", "imports": ["import graphics\r", "import random\r", "import time\r"]}, {"term": "class", "name": "classanimations:\r", "data": "class animations:\r\n\t'''A class of various animations used frequently'''\r\n\tdef bombs(win, point, size):\r\n\t\t'''Draws a bomb\r\n\t\tParameters:\r\n\t\t\twin: the window to draw to\r\n\t\t\tpoint: the point to draw the bomb to\r\n\t\t'''\r\n\t\tbomb = graphics.Circle(graphics.Point(point[0], point[1]), int(size))\r\n\t\tbomb.setFill('red')\r\n\t\tstem = graphics.Rectangle(graphics.Point(point[0], point[1]), \\\r\n\t\t\tgraphics.Point(point[0], point[1] - (size * 3/2)))\r\n\t\tstem.draw(win)\r\n\t\tbomb.draw(win)\r\n\r\n\tdef flag(size, cell_to_flag):\r\n\t\t'''Draws a flag\r\n\t\tParameters:\r\n\t\t\tsize: the size of the flag to draw\r\n\t\t\tcell_to_flag: the cell that is to be flagged\r\n\t\t'''\r\n\r\n\t\tflag = graphics.Polygon(graphics.Point(cell_to_flag[0], cell_to_flag[1]), \\\r\n\t\t graphics.Point(cell_to_flag[0] + size, cell_to_flag[1]), \\\r\n\t\t graphics.Point(cell_to_flag[0], cell_to_flag[1] - size), \\\r\n\t\t graphics.Point(cell_to_flag[0], cell_to_flag[1] + size))\r\n\t\tflag.setFill('red')\r\n\t\t\r\n\t\treturn flag\r\n\r\n\tdef explosion(won, point, size, win, color = 'red'):\r\n\t\t'''Draws an explosion\r\n\t\tParameters:\r\n\t\t\twon: if the player has won or not\r\n\t\t\tpoint: the point at which to draw the explosion\r\n\t\t\tsize: the size of which to draw it\r\n\t\t\twin: the window to draw it\r\n\t\t\tcolor: the color explosion to draw, defaults to red\r\n\t\t'''\r\n\t\texplosion = graphics.Polygon(graphics.Point(point[0] + size * 2, point[1]), \\\r\n\t\t\tgraphics.Point(point[0] + size/2, point[1] + size/2), \\\r\n\t\t\tgraphics.Point(point[0], point[1] + size * 2), \\\r\n\t\t\tgraphics.Point(point[0] - size/2, point[1] + size/2), \\\r\n\t\t\tgraphics.Point(point[0] - size * 2, point[1]), \\\r\n\t\t\tgraphics.Point(point[0] - size/2, point[1] - size/2), \\\r\n\t\t\tgraphics.Point(point[0], point[1] - size * 2), \\\r\n\t\t\tgraphics.Point(point[0] + size/2, point[1] - size/2),)\r\n\r\n\t\tif won == True:\r\n\t\t\texplosion.setFill('yellow')\r\n\t\telse:\r\n\t\t\texplosion.setFill(color)\r\n\r\n\t\texplosion.draw(win)\r\n", "description": null, "category": "graphics", "imports": ["import graphics\r", "import random\r", "import time\r"]}, {"term": "class", "name": "classcell:\r", "data": "class cell:\r\n\t'''Sets up the cells and difficulty of the game'''\r\n\tdef cells(difficulty):\r\n\t\t'''is a list of lists with the coordinates for the center\r\n\t\tof each cell in it and returns it\r\n\t\tParameters:\r\n\t\t\tdifficulty: the type of board/ cell list to return\r\n\t\t'''\r\n\t\tif difficulty == 17:\r\n\t\t\tpoints = (95,265,435,605)\r\n\t\telif difficulty == 6.8:\r\n\t\t\tpoints = (44,112,180,248,316,384,452,520,588,656)\r\n\t\telif difficulty == 13.6:\r\n\t\t\tpoints = (78,214,350,486,622)\r\n\t\telif difficulty == 4:\r\n\t\t\tpoints = (30,70,110,150,190,230,270,310,350,390,430,470,510,550,590,630,670)\r\n\t\telif difficulty == 2:\r\n\t\t\tpoints = (20,40,60,80,100,120,140,160,180,200,220,240,260,280,300,\\\r\n\t\t\t\t320,340,360,380,400,420,440,460,480,500,520,540,560,580,600,\\\r\n\t\t\t\t620,640,660,680)\r\n\t\telif difficulty == 1:\r\n\t\t\tpoints = (15,25,35,45,55,65,75,85,95,105,115,125,135,145,155,165,175,185,195,\\\r\n\t\t\t\t205,215,225,235,245,255,265,275,285,295,305,315,325,335,345,355,365,375,385,395,\\\r\n\t\t\t\t405,415,425,435,445,455,465,475,485,495,505,515,525,535,545,555,565,575,585,595,\\\r\n\t\t\t\t605,615,625,635,645,655,665,675,685)\r\n\r\n\t\tcells = []\r\n\r\n\t\t#loop that appends cells with: an item in the list with everything else in the list\r\n\t\tfor a in points: \r\n\t\t\tfor b in points:\r\n\t\t\t\tnew_cell = (a,b)\r\n\t\t\t\tcells.append(new_cell)\r\n\r\n\t\treturn cells\r\n\r\n\tdef set_bombs(difficulty):\r\n\t\t'''Randomly sets bombs to coordinates in the coorisponding difficulty level\r\n\t\tand returns a list of the bomb cells\r\n\t\tParameters:\r\n\t\t\tdifficulty: used to determine the coorisponding amount of bombs to set\r\n\t\t'''\r\n\t\tbombcell = []\r\n\t\tif difficulty == 17:\r\n\t\t\ttotal_bombs = 0\r\n\t\t\twhile total_bombs != 4:\r\n\t\t\t\tpossible = (random.randrange(95,606,170), random.randrange(95,606,170))\r\n\t\t\t\tif possible == (95, 95):\r\n\t\t\t\t\t'do nothing'\r\n\t\t\t\tif possible not in bombcell:\r\n\t\t\t\t\tbombcell.append(possible)\r\n\t\t\t\t\ttotal_bombs += 1\r\n\r\n\t\tif difficulty == 6.8:\r\n\t\t\ttotal_bombs = 0\r\n\t\t\twhile total_bombs != 20:\r\n\t\t\t\tpossible = (random.randrange(44,656,68), random.randrange(44,656,68))\r\n\t\t\t\tif possible == (44,44):\r\n\t\t\t\t\t'do nothing'\r\n\t\t\t\telif possible not in bombcell:\r\n\t\t\t\t\tbombcell.append(possible)\r\n\t\t\t\t\ttotal_bombs += 1\r\n\r\n\t\tif difficulty == 13.6:\r\n\t\t\ttotal_bombs = 0\r\n\t\t\twhile total_bombs != 6:\r\n\t\t\t\tpossible = (random.randrange(78,622,136), random.randrange(78,622,136))\r\n\t\t\t\tif possible == (78, 78):\r\n\t\t\t\t\t'do nothing'\r\n\t\t\t\telif possible not in bombcell:\r\n\t\t\t\t\tbombcell.append(possible)\r\n\t\t\t\t\ttotal_bombs += 1\r\n\r\n\t\tif difficulty == 4:\r\n\t\t\ttotal_bombs = 0\r\n\t\t\twhile total_bombs != 60:\r\n\t\t\t\tpossible = (random.randrange(30,670,40), random.randrange(30,670,40))\r\n\t\t\t\tif possible == (30, 30):\r\n\t\t\t\t\t'do nothing'\r\n\t\t\t\telif possible not in bombcell:\r\n\t\t\t\t\tbombcell.append(possible)\r\n\t\t\t\t\ttotal_bombs += 1\r\n\r\n\t\tif difficulty == 2:\r\n\t\t\ttotal_bombs = 0\r\n\t\t\twhile total_bombs != 300:\r\n\t\t\t\tpossible = (random.randrange(20,680,20), random.randrange(20,680,20))\r\n\t\t\t\tif possible == (20, 20):\r\n\t\t\t\t\t'do nothing'\r\n\t\t\t\telif possible not in bombcell:\r\n\t\t\t\t\tbombcell.append(possible)\r\n\t\t\t\t\ttotal_bombs += 1\r\n\r\n\t\tif difficulty == 1:\r\n\t\t\ttotal_bombs = 0\r\n\t\t\twhile total_bombs != 700:\r\n\t\t\t\tpossible = (random.randrange(15,685,10), random.randrange(15,685,10))\r\n\t\t\t\tif possible == (15, 15):\r\n\t\t\t\t\t'do nothing'\r\n\t\t\t\telif possible not in bombcell:\r\n\t\t\t\t\tbombcell.append(possible)\r\n\t\t\t\t\ttotal_bombs += 1\r\n\r\n\t\treturn bombcell\r\n\r\n\tdef get_nums(difficulty, celllist, bomblist):\r\n\t\t'''generates the amount of bombs around each cell\r\n\t\tand returns a dictionary containing each cell as the key\r\n\t\tand the key value as the amount of bombs around it\r\n\t\tParameters:\r\n\t\t\tdifficulty: to determine the neighbors around each cell\r\n\t\t\tcelllist: the list of cells to gen numbers for\r\n\t\t\tbomblist: the list of bombs\r\n\t\t'''\r\n\t\tcell_num_dict = {}\r\n\r\n\t\ta = difficulty * 10\r\n\r\n\t\tneighbors = ((-a,a),(0,a),(a,a),(a,0),(a,-a),(0,-a),(-a,-a),(-a,0))\r\n\t\t#generates a list of neighbors cooresponding to the difficulty level\r\n\r\n\t\tfor cell in celllist:\r\n\t\t\tif (cell[0], cell[1]) not in bomblist: #only iterates over non-bomb cells\r\n\t\t\t\tnumb_bombs = 0 #initalizes number of bombs to zero\r\n\t\t\t\tfor neigh in neighbors: #iterates over the list of neighboring cells\r\n\t\t\t\t\tif ((cell[0] + neigh[0]) > 10) and ((cell[0] + neigh[0]) < 690) \\\r\n\t\t\t\t\tand ((cell[1] + neigh[1]) > 10) and ((cell[1] + neigh[1]) < 690):\r\n\t\t\t\t\t\t#asks if the neighboring cell is in the valid grid space\r\n\t\t\t\t\t\tfor bomb in bomblist: #iterates over the list of bombs\r\n\t\t\t\t\t\t\tif int(cell[0] + neigh[0]) == bomb[0]\\\r\n\t\t\t\t\t\t\t and int(cell[1] + neigh[1]) == bomb[1]: \r\n\t\t\t\t\t\t\t #if the cell's neighbor equals a bomb\r\n\t\t\t\t\t\t\t\tnumb_bombs += 1 #add another bomb to the amount\r\n\t\t\t\tcell_num_dict[(cell[0], cell[1])] = numb_bombs #add the cell as the key and\r\n\t\t\t\t\t#number of bombs as the key value to the dictionary\r\n\t\t\telse: #if it cell is a bomb\r\n\t\t\t\tcell_num_dict[(cell[0], cell[1])] = ''\r\n\t\t\t\t#add the cell as key and bomb as the key value to the dictionary\r\n\r\n\t\treturn cell_num_dict\r\n\r\n\tdef difficulty(win):\r\n\t\t'''Used to ask the user the desired difficulty/size of board\r\n\t\tand returns the cooresponding value\r\n\t\tParameters:\r\n\t\t\twin: window to draw to\r\n\t\t'''\r\n\t\t#difficulty1\r\n\t\tdifficulty1 = graphics.Rectangle(graphics.Point(150, 310),\\\r\n\t\t\tgraphics.Point(250, 390))\r\n\t\tdifficulty1.setFill('black')\r\n\t\ttdif1 = graphics.Text(graphics.Point(200, 350), \"4 Bombs\")\r\n\t\ttdif1.setSize(18)\r\n\t\ttdif1.setFill('white')\r\n\t\tdifficulty1.draw(win)\r\n\t\ttdif1.draw(win)\r\n\r\n\t\t#difficulty2\r\n\t\tdifficulty2 = graphics.Rectangle(graphics.Point(300, 310),\\\r\n\t\t\tgraphics.Point(400, 390))\r\n\t\tdifficulty2.setFill('black')\r\n\t\ttdif2 = graphics.Text(graphics.Point(350, 350), \"6 Bombs\")\r\n\t\ttdif2.setSize(18)\r\n\t\ttdif2.setFill('white')\r\n\t\tdifficulty2.draw(win)\r\n\t\ttdif2.draw(win)\r\n\r\n\t\t#difficulty3\r\n\t\tdifficulty3 = graphics.Rectangle(graphics.Point(450, 310),\\\r\n\t\t\tgraphics.Point(550, 390))\r\n\t\tdifficulty3.setFill('black')\r\n\t\ttdif3 = graphics.Text(graphics.Point(500, 350), \"20 Bombs\")\r\n\t\ttdif3.setSize(18)\r\n\t\ttdif3.setFill('pink')\r\n\t\tdifficulty3.draw(win)\r\n\t\ttdif3.draw(win)\r\n\r\n\t\t#difficulty4\r\n\t\tdifficulty4 = graphics.Rectangle(graphics.Point(150, 410),\\\r\n\t\t\tgraphics.Point(250, 490))\r\n\t\tdifficulty4.setFill('black')\r\n\t\ttdif4 = graphics.Text(graphics.Point(200, 450), \"60 Bombs\")\r\n\t\ttdif4.setSize(18)\r\n\t\ttdif4.setFill('pink')\r\n\t\tdifficulty4.draw(win)\r\n\t\ttdif4.draw(win)\r\n\r\n\t\t#difficulty5\r\n\t\tdifficulty5 = graphics.Rectangle(graphics.Point(300, 410),\\\r\n\t\t\tgraphics.Point(400, 490))\r\n\t\tdifficulty5.setFill('black')\r\n\t\ttdif5 = graphics.Text(graphics.Point(350, 450), \"300 Bombs\")\r\n\t\ttdif5.setSize(18)\r\n\t\ttdif5.setFill('red')\r\n\t\tdifficulty5.draw(win)\r\n\t\ttdif5.draw(win)\r\n\r\n\t\t#difficulty6\r\n\t\tdifficulty6 = graphics.Rectangle(graphics.Point(450, 410),\\\r\n\t\t\tgraphics.Point(550, 490))\r\n\t\tdifficulty6.setFill('black')\r\n\t\ttdif6 = graphics.Text(graphics.Point(500, 450), \"700 Bombs\")\r\n\t\ttdif6.setSize(18)\r\n\t\ttdif6.setFill('red')\r\n\t\tdifficulty6.draw(win)\r\n\t\ttdif6.draw(win)\r\n\r\n\t\t#select difficulty text\r\n\t\tselect_text = graphics.Text(graphics.Point(350, 200), \"Select Your\")\r\n\t\tselect_text.setSize(30)\r\n\t\tselect_text.draw(win)\r\n\t\tdif_text = graphics.Text(graphics.Point(350, 240), \"Difficulty\")\r\n\t\tdif_text.setSize(30)\r\n\t\tdif_text.setStyle('bold italic')\r\n\t\tdif_text.draw(win)\r\n\r\n\t\tdifficulty = 0\r\n\r\n\t\t#keep asking for a level difficulty until user chooses\r\n\t\twhile difficulty == 0:\r\n\t\t\tmouse = win.getMouse()\r\n\t\t\tif 310 < mouse.getY() < 390:\r\n\t\t\t\tif 150 < mouse.getX() < 250:\r\n\t\t\t\t\tdifficulty = 17\r\n\t\t\t\tif 300 < mouse.getX() < 400:\r\n\t\t\t\t\tdifficulty = 13.6\r\n\t\t\t\tif 450 < mouse.getX() < 550:\r\n\t\t\t\t\tdifficulty = 6.8\r\n\t\t\tif 410 < mouse.getY() < 490:\r\n\t\t\t\tif 150 < mouse.getX() < 250:\r\n\t\t\t\t\tdifficulty = 4\r\n\t\t\t\tif 300 < mouse.getX() < 400:\r\n\t\t\t\t\tdifficulty = 2\r\n\t\t\t\tif 450 < mouse.getX() < 550:\r\n\t\t\t\t\tdifficulty = 1\r\n\r\n\t\t\tif difficulty in (17,13.6,6.8,4,2,1):\r\n\t\t\t\tdifficulty1.undraw()\r\n\t\t\t\ttdif1.undraw()\r\n\t\t\t\tdifficulty2.undraw()\r\n\t\t\t\ttdif2.undraw()\r\n\t\t\t\tdifficulty3.undraw()\r\n\t\t\t\ttdif3.undraw()\r\n\t\t\t\tdifficulty4.undraw()\r\n\t\t\t\ttdif4.undraw()\r\n\t\t\t\tdifficulty5.undraw()\r\n\t\t\t\ttdif5.undraw()\r\n\t\t\t\tdifficulty6.undraw()\r\n\t\t\t\ttdif6.undraw()\r\n\t\t\t\tselect_text.undraw()\r\n\t\t\t\tdif_text.undraw()\r\n\t\t\t\treturn difficulty\r\n", "description": null, "category": "graphics", "imports": ["import graphics\r", "import random\r", "import time\r"]}, {"term": "class", "name": "classGame:\r", "data": "class Game:\r\n\t'''\r\n\tThe main Game class that constructs the game and plays it\r\n\t'''\r\n\tdef __init__(self):\r\n\t\t'''constructs the initial game by calling functions\r\n\t\t'''\r\n\t\t#creates window\r\n\t\tself.win = graphics.GraphWin(\"Minesweeper 9000\", 700, 700)\r\n\r\n\t\t#asks user for desired difficulty level\r\n\t\tself.difficult_level = cell.difficulty(self.win)\r\n\r\n\t\t#initialize the win lose conditions, the lists\r\n\t\t#of revealed and flagged cells, and set the exploded bomb cell to none\r\n\t\tself.won = False\r\n\t\tself.bomb = False\r\n\t\tself.revealed_cells = []\r\n\t\tself.flagged = {}\r\n\t\tself.exploded_bomb = None\r\n\r\n\t\t#sets the background\r\n\t\tbackground.set_background(self.win)\r\n\r\n\t\t#creates the cell list, bomb list, and cell number dictionary with the difficulty\r\n\t\tself.celllist = cell.cells(self.difficult_level)\r\n\t\tself.bomblist = cell.set_bombs(self.difficult_level)\r\n\t\tself.cell_nums = cell.get_nums(self.difficult_level, self.celllist, self.bomblist)\r\n\r\n\t\t#set grid and colors\r\n\t\tbackground.create_board(self.win, self.difficult_level, self.celllist)\r\n\r\n\tdef reveal(self, cell_to_reveal):\r\n\t\t'''Reveals a cells number value or a bomb\r\n\t\tParameters:\r\n\t\t\tcell_to_reveal: the cell to reveal bomb or number\r\n\t\t'''\r\n\t\t#if the cell is invalid, end function\r\n\t\tif cell_to_reveal == None:\r\n\t\t\treturn\r\n\t\t\r\n\t\t#if the cell is a bomb, explode the cell and stop the function\r\n\t\tif self.cell_nums[cell_to_reveal] == '':\r\n\t\t\tanimations.bombs(self.win, cell_to_reveal, self.difficult_level)\r\n\t\t\tself.bomb = True\r\n\t\t\tself.exploded_bomb = cell_to_reveal\r\n\t\t\treturn\r\n\r\n\t\t#draws the number of surrounding bombs according to the self.cell_nums dictionary value\r\n\t\ttext = graphics.Text(graphics.Point(cell_to_reveal[0],cell_to_reveal[1]), \\\r\n\t\t\tself.cell_nums[cell_to_reveal])\r\n\t\ttext.setFill('black')\r\n\t\ttext.draw(self.win)\r\n\r\n\t\t#adds cell to revealed cell list\r\n\t\tself.revealed_cells.append(cell_to_reveal)\r\n\r\n\t\t#generates a list of neighbors depending on difficulty level\r\n\t\ta = self.difficult_level * 10\r\n\t\tneighbors = ((-a,a),(0,a),(a,a),(a,0),(a,-a),(0,-a),(-a,-a),(-a,0))\r\n\r\n\t\tif self.cell_nums[cell_to_reveal] == 0: #if the cell has zero bombs around it\r\n\t\t\tfor neigh in neighbors: #iterate over the neighbors\r\n\t\t\t\tif ((cell_to_reveal[0] + neigh[0]) > 10) and \\\r\n\t\t\t\t((cell_to_reveal[0] + neigh[0]) < 690) and \\\r\n\t\t\t\t((cell_to_reveal[1] + neigh[1]) > 10) and \\\r\n\t\t\t\t((cell_to_reveal[1] + neigh[1]) < 690): #if the neighbor is in bounds\r\n\t\t\t\t\tif ((cell_to_reveal[0] + neigh[0]), (cell_to_reveal[1] + neigh[1]))\\\r\n\t\t\t\t\t not in self.revealed_cells: #if the neighboring cell is not already revealed\r\n\t\t\t\t\t\tself.reveal((cell_to_reveal[0] + neigh[0], cell_to_reveal[1] + neigh[1]))\r\n\t\t\t\t\t\t#recursively call reveal on the neighbording cell\r\n\r\n\tdef cell_clicked(self):\r\n\t\t'''Searchs for the cell that was clicked and how it was\r\n\t\tand returns a list containing the cell that was clicked\r\n\t\tor flags the cooresponding cell and returns\r\n\t\tParameters:\r\n\t\t\tNone\r\n\t\t'''\r\n\t\tclick = self.win.getMouseWithButton()\r\n\t\twidth = self.difficult_level * 5\r\n\r\n\t\tpoint = (int(click[0].getX()),int(click[0].getY()))\r\n\r\n\t\tif click[1] == 2 or click[1] == 3: #if user inputs a right click\r\n\t\t\tfor cell in self.cell_nums: #iterate over the cells\r\n\t\t\t\tcell_to_flag = button.wasClicked(point, self.celllist, width) #get cell that was clicked\r\n\t\t\t\tif cell_to_flag != None: #if cell is a legal cell (not on the border)\r\n\t\t\t\t\tif cell_to_flag not in self.flagged: #if not already flagged\r\n\t\t\t\t\t\tif cell_to_flag not in self.revealed_cells: #if cell is not already revealed\r\n\t\t\t\t\t\t\tself.flagged[cell_to_flag] = \\\r\n\t\t\t\t\t\t\t\tanimations.flag(self.difficult_level, cell_to_flag)\r\n\t\t\t\t\t\t\tself.flagged[cell_to_flag].draw(self.win) #draw a flag at in the cell\r\n\t\t\t\t\t\t\treturn('', 2) #end the function\r\n\t\t\t\t\telse: #if already drawn, undraw\r\n\t\t\t\t\t\tself.flagged[cell_to_flag].undraw()\r\n\t\t\t\t\t\tdel self.flagged[cell_to_flag] #delete flagged cell from the dictionary\r\n\t\t\t\t\t\treturn('', 2) #end the function\r\n\t\telse: #if user inputs a left click\r\n\t\t\tcell_to_reveal = button.wasClicked(point, self.celllist, width)\r\n\t\t\tif cell_to_reveal not in self.flagged: #if the clicked spot is not a flagged cell\r\n\t\t\t\treturn (cell_to_reveal, 1) #return the cell and the type of click\r\n\r\n\r\n\t\treturn(None, 2) #if runs function and if and else statements fail, won't crash program\r\n\r\n\tdef close(self):\r\n\t\t'''Closes the window\r\n\t\tParameters:\r\n\t\t\tNone\r\n\t\t'''\r\n\t\tself.win.close()\r\n\r\n\tdef winner(self):\r\n\t\t'''Called if the player wins the game and congratulates them\r\n\t\twith celebratory explosions\r\n\t\tParameters:\r\n\t\t\tNone\r\n\t\t'''\r\n\t\t#draws celebratory explosions around\r\n\t\tfor size in range(0,30,4):\r\n\t\t\tanimations.explosion(self.won, (370,200), size + 50, self.win)\r\n\t\t\tanimations.explosion(self.won, (200,500), size + 20, self.win)\r\n\t\t\tanimations.explosion(self.won, (580,450), size + 40, self.win)\r\n\t\t\tanimations.explosion(self.won, (75,75), size, self.win)\r\n\r\n\t\t#congratulates the player\r\n\t\tcongratsbackground = graphics.Rectangle(graphics.Point(250,310), \\\r\n\t\t\tgraphics.Point(450,355))\r\n\t\tcongrats = graphics.Text(graphics.Point(350,332), 'Congrats!')\r\n\t\tcongrats.setFill('black')\r\n\t\tcongrats.setStyle('bold italic')\r\n\t\tcongrats.setSize(36)\r\n\t\tcongratsbackground.setFill('white')\r\n\t\tcongratsbackground.draw(self.win)\r\n\t\tcongrats.draw(self.win)\r\n\r\n\tdef loser(self):\r\n\t\t'''Called if the user loses and draws explosions and\r\n\t\tencouraging phrases\r\n\t\tParameters:\r\n\t\t\tNone\r\n\t\t'''\r\n\t\tfor size in range(0,20,4):\r\n\t\t\tanimations.explosion(False, (200,500), size + 20, self.win)\r\n\t\t\tanimations.explosion(False, (580,450), size + 40, self.win)\r\n\t\t\tanimations.explosion(False, (75,75), size, self.win)\r\n\r\n\t\tfailbackground = graphics.Rectangle(graphics.Point(250,310), \\\r\n\t\t\tgraphics.Point(450,355))\r\n\t\tfail = graphics.Text(graphics.Point(350,332), 'FAIL')\r\n\t\tfail.setFill('black')\r\n\t\tfail.setStyle('bold italic')\r\n\t\tfail.setSize(36)\r\n\t\tfailbackground.setFill('white')\r\n\t\tfailbackground.draw(self.win)\r\n\t\tfail.draw(self.win)\r\n\r\n\t\t#mean titles to sass the player for loosing\r\n\t\tmean = graphics.Text(graphics.Point(200,150), 'Do it again, but... uh... better...')\r\n\t\tmean.setFill('black')\r\n\t\tmean.setStyle('bold')\r\n\t\tmean.setSize(12)\r\n\t\tmean.draw(self.win)\r\n\r\n\t\tmean2 = graphics.Text(graphics.Point(500,550), \"Hint: don't click the bombs\")\r\n\t\tmean2.setFill('black')\r\n\t\tmean2.setStyle('bold')\r\n\t\tmean2.setSize(12)\r\n\t\tmean2.draw(self.win)\r\n\r\n\t\tmean3 = graphics.Text(graphics.Point(100,510), \"Having fun yet?\")\r\n\t\tmean3.setFill('black')\r\n\t\tmean3.setStyle('bold')\r\n\t\tmean3.setSize(12)\r\n\t\tmean3.draw(self.win)\r\n\r\n\tdef play(self):\r\n\t\t'''Is the main game loop and will coordinate\r\n\t\tall the other functions and determine if the player\r\n\t\thas won\r\n\t\tParameters:\r\n\t\t\tNone\r\n\t\t'''\r\n\t\twhile self.won != True and self.bomb != True: #while player hasn't hit a bomb or won\r\n\t\t\tcell = self.cell_clicked() #get the cell clicked\r\n\t\t\tif cell == None: #if the click returns an illegal click, don't crash\r\n\t\t\t\t'do nothing'\r\n\t\t\telif cell[0] == None:#if the click returns an illegal click, don't crash\r\n\t\t\t\t'do nothing' \r\n\t\t\telif cell[1] == 1: #if the click was a left click\r\n\t\t\t\tif cell[0] not in self.revealed_cells: #if the cell is not already revealed\r\n\t\t\t\t\tself.reveal(cell[0]) #reveal the cell\r\n\r\n\t\t\t#the win condition: if the number of revealed equals \r\n\t\t\t#the number of cells minus the number of bombs\r\n\t\t\tif len(self.celllist) - len(self.bomblist) == len(self.revealed_cells):\r\n\t\t\t\tself.won = True\r\n\r\n\t\t#After the while loop is broken:\r\n\r\n\t\t#if the player won\r\n\t\tif self.won == True:\r\n\t\t\t#if there aren't too many cells\r\n\t\t\tif self.difficult_level > 3:\r\n\t\t\t\t#undraw the flags\r\n\t\t\t\tfor flag in self.flagged:\r\n\t\t\t\t\tself.flagged[flag].undraw()\r\n\t\t\t\t#draw the bombs\r\n\t\t\t\tfor cell in self.bomblist:\r\n\t\t\t\t\tself.reveal(cell)\r\n\t\t\t\r\n\t\t\t#run the winner code\r\n\t\t\tself.winner()\r\n\t\t\r\n\t\t#if the player hit a bomb\r\n\t\telse:\r\n\t\t\tfor size in range(0,30,4): #explode the cell they hit\r\n\t\t\t\tanimations.explosion(False, self.exploded_bomb, size + 50, self.win, 'orange')\r\n\t\t\r\n\t\t\t#pause for a second\r\n\t\t\ttime.sleep(.3)\r\n\t\t\t\r\n\t\t\t#if there aren't too many cells\r\n\t\t\tif self.difficult_level > 3:\r\n\t\t\t\t#undraw the flags\r\n\t\t\t\tfor flag in self.flagged:\r\n\t\t\t\t\tself.flagged[flag].undraw()\r\n\t\t\t\t#reveal the bombs\r\n\t\t\t\tfor i in self.bomblist:\r\n\t\t\t\t\tself.reveal(i)\r\n\r\n\t\t\t#run the losing code\r\n\t\t\tself.loser()\r\n\r\n\t\t#pause the code for .3 seconds and then continue\r\n\t\ttime.sleep(.3)\r\n\r\n\t\tplayAgain = 'idk'\r\n\t\talready_drawn = 'no'\r\n\t\t#ask if the player wants to play again and respond accordingly\r\n\t\twhile playAgain == 'idk':\r\n\t\t\tplayAgain = play_minesweeper_again.ask(self.win, already_drawn)\r\n\t\t\talready_drawn = 'yes'\r\n\t\tif playAgain == \"Yes\":\r\n\t\t\tself.close()\r\n\t\t\tgame = Game()\r\n\t\t\tgame.play()\r\n\t\telse:\r\n\t\t\tself.close\r\n", "description": null, "category": "graphics", "imports": ["import graphics\r", "import random\r", "import time\r"]}, {"term": "def", "name": "main", "data": "def main():\r\n\t'''Constructs a Minesweeper game by calling Game\r\n\t'''\r\n\tminesweeper = Game()\r\n\tminesweeper.play()\r\n", "description": null, "category": "graphics", "imports": ["import graphics\r", "import random\r", "import time\r"]}], [{"term": "def", "name": "main", "data": "def main():\r\n\tgraphics = BreakoutGraphics(number_lives=NUM_LIVES)\r\n\tcount_lives = 0  # number of out_ball\r\n\tcount_bricks = 0  # number of bricks player hit\r\n\t# Add animation loop here!\r\n\twhile True:\r\n\t\tpause(FRAME_RATE)\r\n\t\tgraphics.ball.move(graphics.get_dx(), graphics.get_dy())\r\n\t\tif graphics.ball_hit_thing() is not None:  # hit the paddle or brick\r\n\t\t\tif graphics.ball_hit_thing() is not graphics.paddle:  # hit the brick\r\n\t\t\t\tgraphics.chang_dy_direction()\r\n\t\t\t\tgraphics.window.remove(graphics.ball_hit_thing())\r\n\t\t\t\tcount_bricks += 1\r\n\t\t\t\tgraphics.scoreboard.text = 'Score: '+str(count_bricks)\r\n\t\t\t\tif count_bricks == graphics.bricks_number:  # clear all bricks\r\n\t\t\t\t\tbreak\r\n\t\t\telse:  # hit the paddle\r\n\t\t\t\tif graphics.get_dy() > 0:  # makes ball do not stick on the paddle\r\n\t\t\t\t\tgraphics.chang_dy_direction()\r\n\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.r * 2 >= graphics.window.width:\r\n\t\t\t# between two sides of window\r\n\t\t\tgraphics.chang_dx_direction()\r\n\t\tif graphics.ball.y <= 0:  # up_side of window\r\n\t\t\tgraphics.chang_dy_direction()\r\n\t\tif graphics.ball.y >= graphics.window.height:  # ball is out of window\r\n\t\t\tgraphics.reset_ball()\r\n\t\t\tcount_lives += 1\r\n\t\t\tgraphics.liveboard.text = graphics.remain_lives(count_lives, NUM_LIVES)\r\n\t\t\tgraphics.window.add(graphics.liveboard, graphics.window.width - graphics.liveboard.width,\r\n\t\t\t\t\t\t\t\tgraphics.liveboard.height)\r\n\t\t\tif count_lives == NUM_LIVES:\r\n\t\t\t\tgraphics.liveboard.text = 'Game Over!'\r\n\t\t\t\tgraphics.window.add(graphics.liveboard, graphics.window.width - graphics.liveboard.width,\r\n\t\t\t\t\t\t\t\t\tgraphics.liveboard.height)\r\n\t\t\t\tbreak\r\n\r\n\r\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause\r", "from breakoutGraphics_extention import BreakoutGraphics\r"]}], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis widget is an easy starting point for generating multi-panel figures.\n\tExample::\n\t\n\t\tw = pg.GraphicsLayoutWidget()\n\t\tp1 = w.addPlot(row=0, col=0)\n\t\tp2 = w.addPlot(row=0, col=1)\n\t\tv = w.addViewBox(row=1, col=0, colspan=2)\n\t\n\tParameters\n\t----------\n\tparent : QWidget or None\n\t\tThe parent widget (see QWidget.__init__)\n\tshow : bool\n\t\tIf True, then immediately show the widget after it is created.\n\t\tIf the widget has no parent, then it will be shown inside a new window.\n\tsize : (width, height) tuple\n\t\tOptionally resize the widget. Note: if this widget is placed inside a\n\t\tlayout, then this argument has no effect.\n\ttitle : str or None\n\t\tIf specified, then set the window title for this widget.\n\tkargs : \n\t\tAll extra arguments are passed to \n\t\t:func:`GraphicsLayout.__init__() `\n\t\t\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, show=False, size=None, title=None, **kargs):\n\t\tmkQApp()\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n\t\t\n\t\tif size is not None:\n\t\t\tself.resize(*size)\n\t\t\t\n\t\tif title is not None:\n\t\t\tself.setWindowTitle(title)\n\t\t\t\n\t\tif show is True:\n\t\t\tself.show()\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis widget is an easy starting point for generating multi-panel figures.\n\tExample::\n\t\n\t\tw = pg.GraphicsLayoutWidget()\n\t\tp1 = w.addPlot(row=0, col=0)\n\t\tp2 = w.addPlot(row=0, col=1)\n\t\tv = w.addViewBox(row=1, col=0, colspan=2)\n\t\n\tParameters\n\t----------\n\tparent : QWidget or None\n\t\tThe parent widget (see QWidget.__init__)\n\tshow : bool\n\t\tIf True, then immediately show the widget after it is created.\n\t\tIf the widget has no parent, then it will be shown inside a new window.\n\tsize : (width, height) tuple\n\t\tOptionally resize the widget. Note: if this widget is placed inside a\n\t\tlayout, then this argument has no effect.\n\ttitle : str or None\n\t\tIf specified, then set the window title for this widget.\n\tkargs : \n\t\tAll extra arguments are passed to \n\t\t:func:`GraphicsLayout.__init__() `\n\t\t\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui, mkQApp", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [], [{"term": "class", "name": "GraphicsTest", "data": "class GraphicsTest(SampleBase):\n\tdef __init__(self, *args, **kwargs):\n\t\tsuper(GraphicsTest, self).__init__(*args, **kwargs)\n\n\tdef run(self):\n\t\tcanvas = self.matrix\n\t\tfont = graphics.Font()\n\t\tfont.LoadFont(\"../../../fonts/7x13.bdf\")\n\n\t\tred = graphics.Color(255, 0, 0)\n\t\tgraphics.DrawLine(canvas, 5, 5, 22, 13, red)\n\n\t\tgreen = graphics.Color(0, 255, 0)\n\t\tgraphics.DrawCircle(canvas, 15, 15, 10, green)\n\n\t\tblue = graphics.Color(0, 0, 255)\n\t\tgraphics.DrawText(canvas, font, 2, 10, blue, \"Text\")\n\n\t\ttime.sleep(10)   # show display for 10 seconds before exit\n\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "import time"]}], [], [{"term": "def", "name": "create_example_graphics_export", "data": "def create_example_graphics_export():\n\tx = [2 * math.pi * i / 100 for i in range(100)]\n\ty = [math.sin(c) for c in x]\n\tgr.begingraphics(GRAPHICS_FILENAME)\n\tpygr.plot(x, y)\n\tgr.endgraphics()\n\twith open(GRAPHICS_FILENAME, \"rb\") as f:\n\t\tgraphics_data = f.read()\n\tbase64_encoded_graphics_data = b64encode(graphics_data)\n\twith open(GRAPHICS_FILENAME, \"wb\") as f:\n\t\tf.write(base64_encoded_graphics_data)\n\n", "description": null, "category": "graphics", "imports": ["import math", "import gr", "from base64 import b64encode", "from gr import pygr"]}, {"term": "def", "name": "main", "data": "def main():\n\tcreate_example_graphics_export()\n\n", "description": null, "category": "graphics", "imports": ["import math", "import gr", "from base64 import b64encode", "from gr import pygr"]}], [], [{"term": "class", "name": "classLatexParser:", "data": "class LatexParser:\n\tdef __init__(self, connector, settings):\n\n\t\tself._course_information = {\n\t\t\t'course_code': '',\n\t\t\t'course_version': '',\n\t\t\t'table': 'Questions',\n\t\t\t'language': 'ENG',\n\t\t}\n\t\tself._file_info = {\n\t\t\t'filepath': '',\n\t\t\t'filename': '',\n\t\t}\n\n\t\tself.Settings = settings\n\n\t\tself._question_error = 0\n\n\t\tself.question_list = []\n\t\tself.questions_without_Goal = []\n\n\t\tself._temp_package_store = []\n\n\t\tself.bibliography_parser = BibParser()\n\t\tself._bibliography_paths = []\n\n\t\tself._points = re.compile('\\[(.+?)\\]')\n\n\t\tself._cite = re.compile(r'\\\\cite(?P\\[.*?\\])*'\n\t\t\t\t\t\t\t\tr'(?P\\{.+?\\})')\n\n\t\tself._include_graphics = re.compile(r'\\\\includegraphics(?P\\[.*?\\])*'\n\t\t\t\t\t\t\t\t\t\t\tr'(?P\\{.+?\\})')\n\n\t\tself._package_requirement = re.compile(r'\\\\usepackage(?P\\[.*?\\])*'\n\t\t\t\t\t\t\t\t\t\t\t   r'(?P\\{.+?\\})')\n\n\t\tself._bibliography_path = re.compile('(\\\\bibliography|\\\\addbibresource)\\{(.+?)\\}')\n\n\t\tself.parse_points = re.compile(r'(?P[0-9]*)?(?P\\\\half)*')\n\n\t\tself._question_exist = False\n\n\t\tself.cnx = connector\n\t\tself.ExamDB = None\n\n\tdef set_examdb(self, examdb):\n\t\tself.ExamDB = examdb\n\t\treturn\n\n\tdef run(self, data, usable):\n\t\tself.parse(data, usable)\n\t\tself.check_questions_for_declarations()\n\t\treturn\n\n\tdef parse_from_file(self, filename, course, course_version):\n\t\tself._course_information['course_code'] = course\n\t\tself._course_information['course_version'] = course_version\n\t\tdata = \"\"\n\n\t\tself._file_info['filepath'] = os.path.dirname(filename)\n\t\tself._file_info['filename'] = os.path.basename(filename)\n\n\t\twith codecs.open(filename, 'r', 'utf8') as fp:\n\t\t\tdata += fp.read()\n\n\t\tself.run(data, True)\n\n\t\treturn self.question_list\n\n\tdef parse_data(self, data, course, course_version, usable):\n\t\tself._course_information['course_code'] = course\n\t\tself._course_information['course_version'] = course_version\n\t\tself.run(data, usable)\n\n\t\treturn self.question_list\n\n\tdef database_query(self, query):\n\t\t# noinspection PyUnresolvedReferences\n\t\tself.cursor.execute(query)\n\t\tif 'SELECT' in query:\n\t\t\t# noinspection PyUnresolvedReferences\n\t\t\treturn self.cursor.fetchall()\n\n\t\telse:\n\t\t\tself.cnx.commit()\n\t\t\treturn\n\n\t@staticmethod\n\tdef search_keyword(key, data):\n\t\tkeyword = re.escape(key)\n\t\tpattern = re.compile(r'(.*%s.*)' % keyword)\n\n\t\tif pattern.search(data):\n\t\t\treturn True\n\t\treturn False\n\n\tdef set_usable(self, question):\n\t\t\"\"\"\n\t\tMethod used for setting a question as usable or not. If error exist, set question as unusable, otherwise usable.\n\t\t:param question: The question object\n\t\t:return:\n\t\t\"\"\"\n\t\tif self._question_error > 0:\n\t\t\tquestion.set_usable(False)\n\t\telse:\n\t\t\tquestion.set_usable(True)\n\n\tdef add_points(self, question, line):\n\t\tif not question:\n\t\t\treturn\n\t\tif not line:\n\t\t\treturn\n\n\t\t_total_points = 0\n\t\tpo = self._points.findall(line)\n\t\tif po:\n\t\t\t_parsed_points = self.parse_points.search(po[0])\n\t\t\tif _parsed_points.group('number'):\n\t\t\t\t_total_points += int(_parsed_points.group('number'))\n\n\t\t\telif _parsed_points.group('half'):\n\t\t\t\t_total_points += 0.5\n\t\t\telse:\n\t\t\t\twarnings.warn('Invalid point')\n\t\t\t\t_messagedia = MessageDialogWindow()\n\t\t\t\t_messagedia.information_dialogue('Invalid Points',\n\t\t\t\t\t\t\t\t\t\t\t\t 'Points given isn\\'t valid')\n\t\t\t\tself._question_error += 1\n\t\t\t\tself.set_usable(question)\n\t\t\t\treturn\n\n\t\tquestion.append_points(_total_points)\n\t\tself.set_usable(question)\n\n\tdef check_points(self, question):\n\t\tif question.get_points() == 0:\n\t\t\tself._question_error += 1\n\t\t\twarnings.warn('Question don\\'t have any points set')\n\n\tdef check_questions_for_declarations(self):\n\t\tcursor = self.cnx.cursor()\n\t\tcursor.execute(\"SELECT distinct * \\\n\t\t\t\t\t\t\tFROM Declarations\")\n\t\tdeclarations = cursor.fetchall()\n\t\tcursor.close()\n\n\t\tfor q in self.question_list:\n\t\t\tfor d in declarations:\n\t\t\t\tif self.search_keyword(d[2], q.get_question_code()) \\\n\t\t\t\t\t\tis not False:\n\t\t\t\t\tq.append_declaration_requirement(d[0])\n\t\treturn\n\n\tdef retrieve_goal_by_label(self, question, line):\n\t\trelabel = re.compile(r'\\\\label\\{q:(.+?)\\}')\n\t\tlabel = relabel.findall(line)\n\t\tcursor = self.cnx.cursor()\n\n\t\ttry:\n\t\t\tmodlabel = '%' + label[0] + '%'\n\n\t\t\tcursor.execute(\"SELECT goal \"\n\t\t\t\t\t\t   \"FROM ILO \"\n\t\t\t\t\t\t   \"WHERE course_code='%s' \"\n\t\t\t\t\t\t   \"AND course_version='%s' \"\n\t\t\t\t\t\t   \"AND (ILO.tags) LIKE ('%s')\"\n\t\t\t\t\t\t   % (self._course_information['course_code'],\n\t\t\t\t\t\t\t  self._course_information['course_version'],\n\t\t\t\t\t\t\t  modlabel)\n\t\t\t\t\t\t   )\n\t\t\tgoal = cursor.fetchall()\n\t\t\tcursor.close()\n\n\t\t\tif not goal:  # If no goal has been identified, raise a warning and mark question as not usable\n\t\t\t\twarnings.warn('LabelError')\n\t\t\t\t_messagedia = MessageDialogWindow()\n\n\t\t\t\t_messagedia.information_dialogue('Label Error',\n\t\t\t\t\t\t\t\t\t\t\t\t 'Unable to find a course goal for label %s' % (label[0],))\n\t\t\t\tself._question_error += 1\n\t\t\t\tself.set_usable(question)\n\n\t\t\telse:\n\t\t\t\tquestion.append_to_ilo(goal[0][0])\n\t\t\t\tquestion.set_course_information(self._course_information['course_code'],\n\t\t\t\t\t\t\t\t\t\t\t\tself._course_information['course_version'])\n\n\t\t\t\tquestion.append_tags(label[0])\n\t\t\t\tself.set_usable(question)\n\t\t\treturn\n\n\t\texcept IndexError as err:\n\t\t\tprint(err)\n\t\t\treturn\n\n\tdef _new_question(self, line, usable):\n\t\t\"\"\"\n\t\tCreates a new question object\n\t\t:param line: The line to parse\n\t\t:return: object from class Question()\n\t\t\"\"\"\n\t\t_question = None\n\n\t\tif not self._question_exist:  # First occurrence of question in file\n\t\t\t_question = Question()\n\t\t\tif not usable:\n\t\t\t\tself._question_error = 1\n\t\t\telse:\n\t\t\t\tself._question_error = 0\n\n\t\t\t# Check if package requirement exists.\n\t\t\tif self._temp_package_store:\n\t\t\t\tfor _p in self._temp_package_store:\n\t\t\t\t\t_question.append_package_requirement(_p[0], _p[1])\n\t\t\t\tself._temp_package_store = []\n\n\t\t\tself.question_list.append(_question)\n\t\t\tself._question_exist = True\n\n\t\telif self._question_exist:  # New _question in file\n\t\t\t_question = Question()\n\t\t\tself._question_error = 0\n\n\t\t\tif self._temp_package_store:\n\t\t\t\tfor _p in self._temp_package_store:\n\t\t\t\t\t_question.append_package_requirement(_p[0], _p[1])\n\t\t\t\tself._temp_package_store = []\n\n\t\t\tself.question_list.append(_question)\n\n\t\tif self._points.search(line):\n\t\t\tself.add_points(_question, line)\n\n\t\treturn _question\n\n\tdef append_citation(self, line):\n\t\t\"\"\"\n\t\tParse line for citation, and returns the Bibliography-ID. Used to generate bibtex-file.\n\t\t:param line: Text to be parsed\n\t\t:return: List of Bibliography_dicts in form [{'optional': [],'bibliography': '',}]\n\t\t\"\"\"\n\t\tif not line:\n\t\t\treturn None\n\n\t\tif not self._cite.search(line):\n\t\t\treturn None\n\n\t\t_optionals = None\n\t\t_citations = []\n\n\t\tbibliography = self._cite.findall(line)\n\n\t\tfor _bib in bibliography:\n\t\t\t_bibliography_requirement = {'optional': [],\n\t\t\t\t\t\t\t\t\t\t 'bibliography': '',\n\t\t\t\t\t\t\t\t\t\t }\n\t\t\tif _bib[0]:\n\t\t\t\t_optionals = re.sub('\\[|\\]', '', _bib[0])\n\n\t\t\t_bibliography_requirement['bibliography'] = re.sub('\\{|\\}', '', _bib[1])\n\t\t\tif _optionals:\n\t\t\t\tfor opt in _optionals.split(','):\n\t\t\t\t\t_bibliography_requirement['optional'].append(opt)\n\t\t\t_citations.append(_bibliography_requirement)\n\n\t\treturn _citations\n\n\tdef _append_graphics(self, line, question):\n\t\t\"\"\"\n\t\tParse line for \\includegraphics, if not in work dir, move graphics and rewrite file path.\n\t\t:param line: line to be parsed\n\t\t:param question: question to append graphics requirement to\n\t\t:return: Modified line with new search path.\n\t\t\"\"\"\n\n\t\t# TODO: Handle relative paths, add and remove from DB.\n\t\t_graphics_data = {\n\t\t\t'graphics_path': '',\n\t\t\t'graphics_id': '',\n\t\t\t'optional': '',\n\t\t}\n\n\t\t_graphics_path = self._include_graphics.search(line)\n\n\t\tif _graphics_path.group('optional'):\n\t\t\t_graphics_data['optional'] = re.sub('\\[|\\]', '',\n\t\t\t\t\t\t\t\t\t\t\t\t_graphics_path.group('optional'))\n\n\t\t\t_graphics_data['graphics_path'] = re.sub('\\{|\\}', '',\n\t\t\t\t\t\t\t\t\t\t\t\t\t _graphics_path.group('graphics_path'))\n\n\t\t_graphics_dirname = os.path.dirname(_graphics_data['graphics_path'])\n\t\t_graphics_filename = os.path.basename(_graphics_data['graphics_path'])\n\n\t\t_graphics = Graphics()\n\n\t\tif self.ExamDB.graphics_exist(_graphics_filename):\n\t\t\t_graphics.load_from_database(*self.ExamDB.get_graphics(_graphics_filename)[0])\n\t\t\t_graphics.set_optional(_graphics_data['optional'])\n\n\t\telse:\n\t\t\t_new_filepath = self.Settings.get_program_path() + '/' + 'Courses/' + \\\n\t\t\t\t\t\t\tself._course_information['course_code'] + '/' + 'Graphics/'\n\n\t\t\tif not os.path.isdir(_new_filepath):  # If folder don't exist, create it.\n\t\t\t\ttry:\n\t\t\t\t\tos.makedirs(_new_filepath, exist_ok=True)\n\t\t\t\texcept OSError:\n\t\t\t\t\tprint('Unable to create filepath %s' % _new_filepath)\n\n\t\t\t_given_path = urlparse(_graphics_data['graphics_path'])\n\n\t\t\tif _given_path.scheme in ['http', 'https', 'ftp']:  # IS URL\n\t\t\t\t_new_abs_filename = os.path.join(_new_filepath, _graphics_filename)\n\t\t\t\ttry:\n\t\t\t\t\turlretrieve(_graphics_data['graphics_path'],\n\t\t\t\t\t\t\t\t_new_abs_filename)\n\t\t\t\texcept OSError:\n\t\t\t\t\tprint('Unable to save graphics from URL: %s' %\n\t\t\t\t\t\t  (_graphics_data['graphics_path']))\n\n\t\t\telse:  # Is local file\n\t\t\t\t# Deal with relative filepaths when importing files.\n\t\t\t\tif not _graphics_dirname:  # If graphics is in workdir\n\t\t\t\t\t_graphics_dirname = self._file_info['filepath']\n\n\t\t\t\tif not os.path.isdir(_graphics_dirname):  # If graphics is in relative filepath\n\t\t\t\t\t_graphics_dirname = os.path.relpath(_graphics_dirname, self._file_info['filepath'])\n\n\t\t\t\t_old_abs_filename = os.path.join(_graphics_dirname, _graphics_filename)\n\n\t\t\t\t_new_abs_filename = os.path.join(_new_filepath, _graphics_filename)\n\n\t\t\t\tif not os.path.isfile(_new_abs_filename):\n\t\t\t\t\ttry:\n\t\t\t\t\t\tshutil.copy(_old_abs_filename, _new_abs_filename)\n\n\t\t\t\t\texcept FileNotFoundError:\n\t\t\t\t\t\tprint('File not found')\n\n\t\t\t# Add graphics to DB\n\t\t\t_graphics.set_id(_graphics_filename)\n\t\t\t_graphics.set_optional(_graphics_data['optional'])\n\t\t\t_graphics.set_uri(_new_abs_filename)\n\t\t\t_graphics.set_connector(self.cnx)\n\t\t\t_graphics.insert_into_database()\n\n\t\tif question:\n\t\t\tquestion.append_graphics_requirement(_graphics.get_id())\n\n\t\treturn _graphics.generate_include_code()\n\n\tdef _append_package(self, line):\n\t\t\"\"\"\n\t\tParse line for package requirement\n\t\t:param line: Line to be parsed\n\t\t:return:\n\t\t\"\"\"\n\t\t_package = self._package_requirement.search(line)\n\n\t\t_pack_req = {'optional': None,\n\t\t\t\t\t 'package': '',\n\t\t\t\t\t }\n\n\t\tif _package.group('optional'):\n\t\t\t_pack_req['optional'] = re.sub('\\[|\\]', '',\n\t\t\t\t\t\t\t\t\t\t   _package.group('optional'))\n\n\t\t_pack_req['package'] = re.sub('\\{|\\}', '',\n\t\t\t\t\t\t\t\t\t  _package.group('package'))\n\t\tif self.ExamDB:\n\t\t\t# Retrieive package ID, if package don't exist, None is returned.\n\t\t\tif _pack_req['package'] is None:\n\t\t\t\treturn\n\n\t\t\t_csv_packages = _pack_req['package'].split(',')\n\n\t\t\tfor _p in _csv_packages:\n\t\t\t\t_id = self.ExamDB.package_exist(_p)\n\t\t\t\tif not _id:\n\t\t\t\t\t# If package previously don't exist, add package to DB.\n\t\t\t\t\t_new_package = Package()\n\t\t\t\t\t_new_package.set_id(self.ExamDB.gen_id(\"package\"))\n\t\t\t\t\t_new_package.set_package_data(_pack_req['package'])\n\t\t\t\t\t_new_package.set_options(_pack_req['optional'])\n\t\t\t\t\t_new_package.set_connector(self.cnx)\n\t\t\t\t\t_new_package.insert_into_database()\n\t\t\t\t\t_id = _new_package.get_id()\n\n\t\t\t\t# Add package ID and _question specific optionals as package requirement.\n\t\t\t\tself._temp_package_store.append([_id, _pack_req['optional']])\n\n\t@staticmethod\n\tdef _question_append_line(_question, line):\n\t\t\"\"\"\n\t\tAppend question line\n\t\t:param _question: The question object that the line should be appended to\n\t\t:param line: The question line that should be appended\n\t\t:return:\n\t\t\"\"\"\n\t\t_ignore_ilo_info = re.compile(r'(\\\\emph\\{\\(ILO: (.+?)\\)\\})')\n\t\tif _ignore_ilo_info.search(line):\n\t\t\tline = re.sub(r'(\\\\emph\\{\\(ILO: (.+?)\\)\\})', '', line)\n\t\t_question.append_question(line)\n\n\t@staticmethod\n\tdef _question_append_solution(_question, line):\n\t\t\"\"\"\n\t\tAppend solution to question\n\t\t:param _question: The question object that solution line should be appended to\n\t\t:param line: The line containing part of the solution.\n\t\t:return:\n\t\t\"\"\"\n\t\t_ignore_question_id = re.compile(r'(\\\\textbf\\{for question (.+?) \\})')\n\t\tif not _ignore_question_id.search(line):\n\t\t\tif _question:\n\t\t\t\t_question.append_answer(line)\n\n\tdef append_bibliography(self, line, question=None):\n\t\t\"\"\"\n\t\tRead a bibliography file and add each bibtex entry to DB.\n\t\t:param line: Line containing searchpath for bibtex file.\n\t\t:param question: Question to append bibliography requirement to\n\t\t:return:\n\t\t\"\"\"\n\t\t# Load bibliography from _question\n\t\tpath = self._bibliography_path.search(line)\n\t\tbibpath = path.group(2)\n\t\tbiblist = self.bibliography_parser.load_bibtex_from_file(bibpath)\n\t\tif self.ExamDB:\n\t\t\tfor bib in biblist:\n\t\t\t\tif not self.ExamDB.bibliography_exist(\n\t\t\t\t\t\tbib.get_bibliography_id()):\n\t\t\t\t\tbib.set_connector(self.cnx)\n\t\t\t\t\tbib.insert_into_database()\n\n\t\t\t\tif question:\n\t\t\t\t\tquestion.append_bibliography_requirement(bib.get_bibliography_id())\n\n\tdef parse(self, data, usable):\n\t\t_solution_exist = False\n\t\t_graphics_exist = False\n\n\t\t_relabel = re.compile(r'\\\\label\\{q:(.+?)\\}')\n\t\t_new_question = re.compile(r'\\\\question')\n\t\t_begin_questions = re.compile(r'\\\\begin\\{questions\\}')\n\t\t_end_questions = re.compile(r'\\\\end\\{questions\\}')\n\t\t_start_solution = re.compile(r'(\\\\begin\\{solution\\})')\n\t\t_part_question = re.compile(r'\\\\part')\n\t\t_end_solution = re.compile(r'(\\\\end\\{solution\\})')\n\n\t\t_question = None\n\t\tfor line in data.splitlines(True):\n\t\t\tif self._package_requirement.search(line):\n\t\t\t\tself._append_package(line)\n\n\t\t\telif _begin_questions.search(line):  # If encountering \\begin{questions},\n\t\t\t\t# indicates a full exam is being loaded.\n\t\t\t\tself._temp_package_store = []\n\t\t\t\t_question = None  # Ensure that question is removed.\n\n\t\t\telif _end_questions.search(line):\n\t\t\t\t_question = None\n\n\t\t\telif _new_question.search(line):  # search for '\\question' in line.\n\t\t\t\t_question = self._new_question(line, usable)\n\t\t\t\tself._question_append_line(_question, line)\n\t\t\t\tif _relabel.search(line):\n\t\t\t\t\tself.retrieve_goal_by_label(_question, line)\n\n\t\t\telif _part_question.search(line):\n\t\t\t\tif self._points.search(line):\n\t\t\t\t\tself.add_points(_question, line)\n\t\t\t\t\tself._question_append_line(_question, line)\n\n\t\t\telif _relabel.search(line):\n\t\t\t\tself.retrieve_goal_by_label(_question, line)\n\t\t\t\tself._question_append_line(_question, line)\n\n\t\t\telif self._cite.search(line):\n\t\t\t\tif _question:\n\t\t\t\t\t_citations = self.append_citation(line)\n\t\t\t\t\tfor _bib in _citations:\n\t\t\t\t\t\t_question.append_bibliography_requirement(_bib)\n\n\t\t\t\t\tif _solution_exist:\n\t\t\t\t\t\tself._question_append_solution(_question, line)\n\t\t\t\t\telse:\n\t\t\t\t\t\tself._question_append_line(_question, line)\n\n\t\t\telif _start_solution.search(line):  # Find solution to _question\n\t\t\t\tself.check_points(_question)\n\t\t\t\t_solution_exist = True\n\n\t\t\telif _end_solution.search(line):  # Find solution to _question\n\t\t\t\t_solution_exist = False\n\n\t\t\telif _solution_exist:\n\t\t\t\tself._question_append_solution(_question, line)\n\n\t\t\telif self._include_graphics.search(line):\n\t\t\t\tline = self._append_graphics(line, _question)\n\t\t\t\tif _solution_exist:\n\t\t\t\t\tself._question_append_solution(_question, line)\n\t\t\t\telse:\n\t\t\t\t\tself._question_append_line(_question, line)\n\n\t\t\telif self._bibliography_path.search(line):\n\t\t\t\tif _question:\n\t\t\t\t\tself.append_bibliography(line, _question)\n\n\t\t\telif _question and not _solution_exist:\n\t\t\t\tself._question_append_line(_question, line)\n\n\t\tif not _graphics_exist:\n\t\t\tif _question:\n\t\t\t\t_question.set_graphics_requirement('')\n\n\t\treturn True\n", "description": "\n\t\tMethod used for setting a question as usable or not. If error exist, set question as unusable, otherwise usable.\n\t\t:param question: The question object\n\t\t:return:\n\t\t", "category": "graphics", "imports": ["import re", "from ExamClasses.QuestionClass import Question", "from ExamClasses.PackageClass import Package", "from ExamClasses.GraphicsClass import Graphics", "from Parser.BibParser import BibParser", "from GUI.Messagedialogue import MessageDialogWindow", "import codecs", "import os", "from urllib.parse import urlparse", "from urllib.request import urlretrieve", "import shutil", "import warnings", "\t\t\t\t# Deal with relative filepaths when importing files."]}], [{"term": "def", "name": "proceed_events", "data": "def proceed_events():\n\n\n\twhile engine.events_queue:\n\t\tevent = engine.poll_event()\n\t\tif event:\n\t\t\tif type(event) is DrawStaticEvent:\n\n\t\t\t\tname = event.name\n\t\t\t\tx1 = event.x1\n\t\t\t\ty1 = event.y1\n\n\t\t\t\tif 'anchor' in event.__dict__:\n\t\t\t\t\tanchor = event.anchor\n\t\t\t\telse:\n\t\t\t\t\tanchor = (0, 0)\n\n\t\t\t\tif 'rectangle' in event.__dict__:\n\t\t\t\t\trectangle = event.rectangle\n\t\t\t\telse:\n\t\t\t\t\trectangle = sf.Rectangle((0, 0), (S, S)) # None\n\n\t\t\t\t# ~print('RRECTANGLE:', rectangle)\n\n\t\t\t\trenderer.draw_static(name, x1=x1, y1=y1, anchor=anchor, rectangle=rectangle)\n\n\t\t\t\tsf.sleep(sf.milliseconds(10))\n\n\t\t\tif type(event) is DrawTextureEvent:\n\n\t\t\t\ttexture = event.texture\n\n\t\t\t\twindow.draw(sf.Sprite(texture))\n\n\n\t\t\telif type(event) is DisplayEvent:\n\t\t\t\twindow.display()\n\n\t\t\telif type(event) is DrawMapEvent:\n\n\t\t\t\tlayer = event.layer\n\n\t\t\t\trenderer.render_prerendered_map(layer)\n\n\t\t\telif type(event) is ClearCanvasEvent:\n\t\t\t\twindow.clear(sf.Color.BLUE)\n\n\n\t\t\telif type(event) is UpdateMapLayerEvent:\n\n\t\t\t\tx1 = event.x1\n\t\t\t\ty1 = event.y1\n\t\t\t\ttexture = event.texture\n\t\t\t\tlayer = event.layer\n\n\t\t\t\tgraphics.update_map_layer(x1=x1, y1=y1, texture=texture, layer=layer)\n\n\n\t\t\telif type(event) is ShowHealthEvent:\n\n\t\t\t\tobjid = event.objid\n\n\t\t\t\tdata = engine.containers[objid].data\n\n\t\t\t\thealth = data[attributes.id]['attributes']['health']\n\n\t\t\t\tux = data[movement.id]['x']\n\t\t\t\tuy = data[movement.id]['y']\n\n\t\t\t\tx1 = t['hex_x'](ux, uy, S)\n\t\t\t\ty1 = t['hex_y'](ux, uy, S)\n\n\t\t\t\thealthbar = sf.RectangleShape()\n\t\t\t\thealthbar.outline_color = sf.Color.BLACK\n\t\t\t\thealthbar.fill_color = sf.Color.RED\n\t\t\t\thealthbar.outline_thickness = 2\n\t\t\t\thealthbar.size=(health*0.4*S/100, S//10)\n\t\t\t\thealthbar.origin = (health*0.4*S/100//2, S//20)\n\t\t\t\thealthbar.position = (x1, y1-S//2-15)\n\n\n\t\t\t\twindow.draw(healthbar)\n\t\t\t\t# ~window.display()\n\n\n\n\t\t\telif type(event) is CloseEvent:\n\t\t\t\texit()\n\n\n\t\t\telif type(event) is UpdateSceneEvent:\n\n\t\t\t\tpass\n\n\n\n\n\n\n\n", "description": null, "category": "graphics", "imports": ["#~ import pdb", "import numbers", "from engine.engine import Engine", "from models.unit import Unit", "from models.map import Map", "from models.container import Container", "from components.movement import Movement", "from components.attributes import Attributes", "from components.graphics import Graphics", "from components.renderer import Renderer", "from events.events import *", "from support.support import *", "import sfml as sf", "#~ from sfml import sf", "from random import randint as rnd", "#~ import threading", "#~ import multiprocessing as mp"]}], [{"term": "class", "name": "GraphicsPage", "data": "class GraphicsPage(ConfigurationPageBase, Ui_GraphicsPage):\n\t\"\"\"\n\tClass implementing the Printer configuration page.\n\t\"\"\"\n\tdef __init__(self):\n\t\t\"\"\"\n\t\tConstructor\n\t\t\"\"\"\n\t\tConfigurationPageBase.__init__(self)\n\t\tself.setupUi(self)\n\t\tself.setObjectName(\"GraphicsPage\")\n\t\t\n\t\t# set initial values\n\t\tself.graphicsFont = Preferences.getGraphics(\"Font\")\n\t\tself.graphicsFontSample.setFont(self.graphicsFont)\n\t\t\n\tdef save(self):\n\t\t\"\"\"\n\t\tPublic slot to save the Printer configuration.\n\t\t\"\"\"\n\t\tPreferences.setGraphics(\"Font\", self.graphicsFont)\n\t\t\n\t@pyqtSignature(\"\")\n\tdef on_graphicsFontButton_clicked(self):\n\t\t\"\"\"\n\t\tPrivate method used to select the font for the graphics items.\n\t\t\"\"\"\n\t\tself.graphicsFont = self.selectFont(self.graphicsFontSample, self.graphicsFont)\n\t\t\n\tdef polishPage(self):\n\t\t\"\"\"\n\t\tPublic slot to perform some polishing actions.\n\t\t\"\"\"\n\t\tself.graphicsFontSample.setFont(self.graphicsFont)\n", "description": "\n\tClass implementing the Printer configuration page.\n\t", "category": "graphics", "imports": ["from PyQt4.QtCore import pyqtSignature", "from ConfigurationPageBase import ConfigurationPageBase", "from Ui_GraphicsPage import Ui_GraphicsPage", "import Preferences"]}, {"term": "def", "name": "create", "data": "def create(dlg):\n\t\"\"\"\n\tModule function to create the configuration page.\n\t\n\t@param dlg reference to the configuration dialog\n\t\"\"\"\n\tpage = GraphicsPage()\n\treturn page\n", "description": "\n\tModule function to create the configuration page.\n\t\n\t@param dlg reference to the configuration dialog\n\t", "category": "graphics", "imports": ["from PyQt4.QtCore import pyqtSignature", "from ConfigurationPageBase import ConfigurationPageBase", "from Ui_GraphicsPage import Ui_GraphicsPage", "import Preferences"]}], [{"term": "def", "name": "main", "data": "def main():\n\tloadList = [\n\t\t{\"name\" : \"avatar\", \"path\" : \"./avatar.jpg\"},\n\t\t{\"name\" : \"girl\", \"path\" : \"./girl.jpg\"}\n\t]\n\n\tLoadManage.load(loadList, None, demoInit)\n", "description": null, "category": "graphics", "imports": ["from pylash.core import init, addChild", "from pylash.loaders import LoadManage", "from pylash.display import Bitmap, BitmapData, Shape, Sprite"]}, {"term": "def", "name": "demoInit", "data": "def demoInit(result):\n\tm1 = Shape()\n\tm1.graphics.beginFill()\n\tm1.graphics.drawRect(50, 50, 100, 100)\n\tm1.graphics.drawCircle(25, 25, 25)\n\tm1.graphics.moveTo(200, 25)\n\tm1.graphics.lineTo(150, 125)\n\tm1.graphics.lineTo(250, 150)\n\tm1.graphics.closePath()\n\tm1.graphics.drawRect(40, 175, 150, 150)\n\tm1.graphics.drawCircle(250, 225, 50)\n\n\timg1 = Bitmap(BitmapData(result[\"avatar\"]))\n\timg1.mask = m1\n\taddChild(img1)\n\n\timg1_bg = Bitmap(BitmapData(result[\"avatar\"]))\n\timg1_bg.alpha = 0.3\n\taddChild(img1_bg)\n\n\n\tm2 = Shape()\n\tm2.graphics.beginFill()\n\tm2.graphics.drawRect(100, 100, 200, 200)\n\tm2.graphics.drawCircle(200, 200, 50)\n\n\timg2 = Bitmap(BitmapData(result[\"girl\"]))\n\timg2.x = 320\n\timg2.mask = m2\n\taddChild(img2)\n\n\timg2_bg = Bitmap(BitmapData(result[\"girl\"]))\n\timg2_bg.x = 320\n\timg2_bg.alpha = 0.3\n\taddChild(img2_bg)\n", "description": null, "category": "graphics", "imports": ["from pylash.core import init, addChild", "from pylash.loaders import LoadManage", "from pylash.display import Bitmap, BitmapData, Shape, Sprite"]}], [{"term": "def", "name": "random", "data": "def random():\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input", "from java.util import Random"]}, {"term": "def", "name": "drawRectangle", "data": "def drawRectangle(x, y, width, height):\n\tglobal sys_graphicsController\n\tsys_graphicsController.drawRectangle(x, y, width, height)\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input", "from java.util import Random"]}, {"term": "def", "name": "drawCircle", "data": "def drawCircle(x, y, radius):\n\tglobal sys_graphicsController\n\tsys_graphicsController.drawCircle(x, y, radius)\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input", "from java.util import Random"]}, {"term": "def", "name": "drawLine", "data": "def drawLine(x1, y1, x2, y2):\n\tglobal sys_graphicsController\n\tsys_graphicsController.drawLine(x1, y1, x2, y2)\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input", "from java.util import Random"]}, {"term": "def", "name": "drawPoint", "data": "def drawPoint(x, y):\n\tglobal sys_graphicsController\n\tsys_graphicsController.drawPoint(x, y)\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input", "from java.util import Random"]}, {"term": "def", "name": "drawString", "data": "def drawString(x, y, string):\n\tglobal sys_graphicsController\n\tsys_graphicsController.drawString(x, y, string)\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input", "from java.util import Random"]}, {"term": "def", "name": "useColour", "data": "def useColour(r, g, b, a):\n\tglobal sys_graphicsController\n\tsys_graphicsController.useColour(r, g, b, a)\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input", "from java.util import Random"]}, {"term": "def", "name": "clearScreen", "data": "def clearScreen():\n\tglobal sys_graphicsController\n\tsys_gameController.clearScreen()\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input", "from java.util import Random"]}, {"term": "def", "name": "newFrame", "data": "def newFrame():\n\tglobal sys_graphicsController\n\tsys_gameController.newFrame()\n\tclearScreen()\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input", "from java.util import Random"]}, {"term": "def", "name": "isMouseDown", "data": "def isMouseDown():\n\tglobal sys_inputController\n\treturn sys_inputController.isMouseDown()\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input", "from java.util import Random"]}, {"term": "def", "name": "isKeyDown", "data": "def isKeyDown(key):\n\tglobal sys_inputController\n\treturn sys_inputController.isKeyDown(key)\n", "description": null, "category": "graphics", "imports": ["from core import GraphicsController", "from core import GameController", "from core import Input", "from java.util import Random"]}], [{"term": "def", "name": "_swig_setattr_nondynamic", "data": "def _swig_setattr_nondynamic(self,class_type,name,value,static=1):\n\tif (name == \"thisown\"): return self.this.own(value)\n\tif (name == \"this\"):\n\t\tif type(value).__name__ == 'PySwigObject':\n\t\t\tself.__dict__[name] = value\n\t\t\treturn\n\tmethod = class_type.__swig_setmethods__.get(name,None)\n\tif method: return method(self,value)\n\tif (not static) or hasattr(self,name):\n\t\tself.__dict__[name] = value\n\telse:\n\t\traise AttributeError(\"You cannot add attributes to %s\" % self)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "def", "name": "_swig_setattr", "data": "def _swig_setattr(self,class_type,name,value):\n\treturn _swig_setattr_nondynamic(self,class_type,name,value,0)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "def", "name": "_swig_getattr", "data": "def _swig_getattr(self,class_type,name):\n\tif (name == \"thisown\"): return self.this.own()\n\tmethod = class_type.__swig_getmethods__.get(name,None)\n\tif method: return method(self)\n\traise AttributeError,name\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "def", "name": "_swig_repr", "data": "def _swig_repr(self):\n\ttry: strthis = \"proxy of \" + self.this.__repr__()\n\texcept: strthis = \"\"\n\treturn \"<%s.%s; %s >\" % (self.__class__.__module__, self.__class__.__name__, strthis,)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGFloatArray", "data": "class CGFloatArray(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGFloatArray, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGFloatArray, name)\n\t__repr__ = _swig_repr\n\tdef __init__(self, *args): \n\t\tthis = _CoreGraphics.new_CGFloatArray(*args)\n\t\ttry: self.this.append(this)\n\t\texcept: self.this = this\n\t__swig_destroy__ = _CoreGraphics.delete_CGFloatArray\n\t__del__ = lambda self : None;\n\tdef __getitem__(*args): return _CoreGraphics.CGFloatArray___getitem__(*args)\n\tdef __setitem__(*args): return _CoreGraphics.CGFloatArray___setitem__(*args)\n\tdef cast(*args): return _CoreGraphics.CGFloatArray_cast(*args)\n\t__swig_getmethods__[\"frompointer\"] = lambda x: _CoreGraphics.CGFloatArray_frompointer\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CFType", "data": "class CFType(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CFType, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CFType, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CFType\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGAffineTransform", "data": "class CGAffineTransform(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGAffineTransform, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGAffineTransform, name)\n\t__repr__ = _swig_repr\n\t__swig_setmethods__[\"a\"] = _CoreGraphics.CGAffineTransform_a_set\n\t__swig_getmethods__[\"a\"] = _CoreGraphics.CGAffineTransform_a_get\n\tif _newclass:a = _swig_property(_CoreGraphics.CGAffineTransform_a_get, _CoreGraphics.CGAffineTransform_a_set)\n\t__swig_setmethods__[\"b\"] = _CoreGraphics.CGAffineTransform_b_set\n\t__swig_getmethods__[\"b\"] = _CoreGraphics.CGAffineTransform_b_get\n\tif _newclass:b = _swig_property(_CoreGraphics.CGAffineTransform_b_get, _CoreGraphics.CGAffineTransform_b_set)\n\t__swig_setmethods__[\"c\"] = _CoreGraphics.CGAffineTransform_c_set\n\t__swig_getmethods__[\"c\"] = _CoreGraphics.CGAffineTransform_c_get\n\tif _newclass:c = _swig_property(_CoreGraphics.CGAffineTransform_c_get, _CoreGraphics.CGAffineTransform_c_set)\n\t__swig_setmethods__[\"d\"] = _CoreGraphics.CGAffineTransform_d_set\n\t__swig_getmethods__[\"d\"] = _CoreGraphics.CGAffineTransform_d_get\n\tif _newclass:d = _swig_property(_CoreGraphics.CGAffineTransform_d_get, _CoreGraphics.CGAffineTransform_d_set)\n\t__swig_setmethods__[\"tx\"] = _CoreGraphics.CGAffineTransform_tx_set\n\t__swig_getmethods__[\"tx\"] = _CoreGraphics.CGAffineTransform_tx_get\n\tif _newclass:tx = _swig_property(_CoreGraphics.CGAffineTransform_tx_get, _CoreGraphics.CGAffineTransform_tx_set)\n\t__swig_setmethods__[\"ty\"] = _CoreGraphics.CGAffineTransform_ty_set\n\t__swig_getmethods__[\"ty\"] = _CoreGraphics.CGAffineTransform_ty_get\n\tif _newclass:ty = _swig_property(_CoreGraphics.CGAffineTransform_ty_get, _CoreGraphics.CGAffineTransform_ty_set)\n\tdef translate(*args): return _CoreGraphics.CGAffineTransform_translate(*args)\n\tdef scale(*args): return _CoreGraphics.CGAffineTransform_scale(*args)\n\tdef rotate(*args): return _CoreGraphics.CGAffineTransform_rotate(*args)\n\tdef invert(*args): return _CoreGraphics.CGAffineTransform_invert(*args)\n\tdef concat(*args): return _CoreGraphics.CGAffineTransform_concat(*args)\n\tdef equalToTransform(*args): return _CoreGraphics.CGAffineTransform_equalToTransform(*args)\n\tdef transformIsIdentity(*args): return _CoreGraphics.CGAffineTransform_transformIsIdentity(*args)\n\tdef __init__(self, *args): \n\t\tthis = _CoreGraphics.new_CGAffineTransform(*args)\n\t\ttry: self.this.append(this)\n\t\texcept: self.this = this\n\t__swig_destroy__ = _CoreGraphics.delete_CGAffineTransform\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPoint", "data": "class CGPoint(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPoint, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPoint, name)\n\t__repr__ = _swig_repr\n\t__swig_setmethods__[\"x\"] = _CoreGraphics.CGPoint_x_set\n\t__swig_getmethods__[\"x\"] = _CoreGraphics.CGPoint_x_get\n\tif _newclass:x = _swig_property(_CoreGraphics.CGPoint_x_get, _CoreGraphics.CGPoint_x_set)\n\t__swig_setmethods__[\"y\"] = _CoreGraphics.CGPoint_y_set\n\t__swig_getmethods__[\"y\"] = _CoreGraphics.CGPoint_y_get\n\tif _newclass:y = _swig_property(_CoreGraphics.CGPoint_y_get, _CoreGraphics.CGPoint_y_set)\n\tdef equalToPoint(*args): return _CoreGraphics.CGPoint_equalToPoint(*args)\n\tdef applyAffineTransform(*args): return _CoreGraphics.CGPoint_applyAffineTransform(*args)\n\tdef __init__(self, *args): \n\t\tthis = _CoreGraphics.new_CGPoint(*args)\n\t\ttry: self.this.append(this)\n\t\texcept: self.this = this\n\t__swig_destroy__ = _CoreGraphics.delete_CGPoint\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGSize", "data": "class CGSize(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGSize, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGSize, name)\n\t__repr__ = _swig_repr\n\t__swig_setmethods__[\"width\"] = _CoreGraphics.CGSize_width_set\n\t__swig_getmethods__[\"width\"] = _CoreGraphics.CGSize_width_get\n\tif _newclass:width = _swig_property(_CoreGraphics.CGSize_width_get, _CoreGraphics.CGSize_width_set)\n\t__swig_setmethods__[\"height\"] = _CoreGraphics.CGSize_height_set\n\t__swig_getmethods__[\"height\"] = _CoreGraphics.CGSize_height_get\n\tif _newclass:height = _swig_property(_CoreGraphics.CGSize_height_get, _CoreGraphics.CGSize_height_set)\n\tdef equalToSize(*args): return _CoreGraphics.CGSize_equalToSize(*args)\n\tdef applyAffineTransform(*args): return _CoreGraphics.CGSize_applyAffineTransform(*args)\n\tdef __init__(self, *args): \n\t\tthis = _CoreGraphics.new_CGSize(*args)\n\t\ttry: self.this.append(this)\n\t\texcept: self.this = this\n\t__swig_destroy__ = _CoreGraphics.delete_CGSize\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGRect", "data": "class CGRect(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGRect, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGRect, name)\n\t__repr__ = _swig_repr\n\t__swig_setmethods__[\"origin\"] = _CoreGraphics.CGRect_origin_set\n\t__swig_getmethods__[\"origin\"] = _CoreGraphics.CGRect_origin_get\n\tif _newclass:origin = _swig_property(_CoreGraphics.CGRect_origin_get, _CoreGraphics.CGRect_origin_set)\n\t__swig_setmethods__[\"size\"] = _CoreGraphics.CGRect_size_set\n\t__swig_getmethods__[\"size\"] = _CoreGraphics.CGRect_size_get\n\tif _newclass:size = _swig_property(_CoreGraphics.CGRect_size_get, _CoreGraphics.CGRect_size_set)\n\tdef getMinX(*args): return _CoreGraphics.CGRect_getMinX(*args)\n\tdef getMidX(*args): return _CoreGraphics.CGRect_getMidX(*args)\n\tdef getMaxX(*args): return _CoreGraphics.CGRect_getMaxX(*args)\n\tdef getMinY(*args): return _CoreGraphics.CGRect_getMinY(*args)\n\tdef getMidY(*args): return _CoreGraphics.CGRect_getMidY(*args)\n\tdef getMaxY(*args): return _CoreGraphics.CGRect_getMaxY(*args)\n\tdef getWidth(*args): return _CoreGraphics.CGRect_getWidth(*args)\n\tdef getHeight(*args): return _CoreGraphics.CGRect_getHeight(*args)\n\tdef equalToRect(*args): return _CoreGraphics.CGRect_equalToRect(*args)\n\tdef standardize(*args): return _CoreGraphics.CGRect_standardize(*args)\n\tdef isEmpty(*args): return _CoreGraphics.CGRect_isEmpty(*args)\n\tdef isNull(*args): return _CoreGraphics.CGRect_isNull(*args)\n\tdef isInfinite(*args): return _CoreGraphics.CGRect_isInfinite(*args)\n\tdef inset(*args): return _CoreGraphics.CGRect_inset(*args)\n\tdef integral(*args): return _CoreGraphics.CGRect_integral(*args)\n\tdef union(*args): return _CoreGraphics.CGRect_Union(*args)\n\tdef intersection(*args): return _CoreGraphics.CGRect_intersection(*args)\n\tdef offset(*args): return _CoreGraphics.CGRect_offset(*args)\n\tdef divide(*args): return _CoreGraphics.CGRect_divide(*args)\n\tdef containsPoint(*args): return _CoreGraphics.CGRect_containsPoint(*args)\n\tdef containsRect(*args): return _CoreGraphics.CGRect_containsRect(*args)\n\tdef intersectsRect(*args): return _CoreGraphics.CGRect_intersectsRect(*args)\n\tdef applyAffineTransform(*args): return _CoreGraphics.CGRect_applyAffineTransform(*args)\n\tdef __init__(self, *args): \n\t\tthis = _CoreGraphics.new_CGRect(*args)\n\t\ttry: self.this.append(this)\n\t\texcept: self.this = this\n\t__swig_destroy__ = _CoreGraphics.delete_CGRect\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGColorSpace", "data": "class CGColorSpace(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGColorSpace, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGColorSpace, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGColorSpace\n\t__del__ = lambda self : None;\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGDataConsumer", "data": "class CGDataConsumer(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGDataConsumer, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGDataConsumer, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGDataConsumer\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGDataProvider", "data": "class CGDataProvider(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGDataProvider, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGDataProvider, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGDataProvider\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGImage", "data": "class CGImage(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGImage, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGImage, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGImage\n\t__del__ = lambda self : None;\n\tdef isMask(*args): return _CoreGraphics.CGImage_isMask(*args)\n\tdef getWidth(*args): return _CoreGraphics.CGImage_getWidth(*args)\n\tdef getHeight(*args): return _CoreGraphics.CGImage_getHeight(*args)\n\tdef getBitsPerComponent(*args): return _CoreGraphics.CGImage_getBitsPerComponent(*args)\n\tdef getBitsPerPixel(*args): return _CoreGraphics.CGImage_getBitsPerPixel(*args)\n\tdef getBytesPerRow(*args): return _CoreGraphics.CGImage_getBytesPerRow(*args)\n\tdef getColorSpace(*args): return _CoreGraphics.CGImage_getColorSpace(*args)\n\tdef getAlphaInfo(*args): return _CoreGraphics.CGImage_getAlphaInfo(*args)\n\tdef getDataProvider(*args): return _CoreGraphics.CGImage_getDataProvider(*args)\n\tdef getDecode(*args): return _CoreGraphics.CGImage_getDecode(*args)\n\tdef getShouldInterpolate(*args): return _CoreGraphics.CGImage_getShouldInterpolate(*args)\n\tdef getRenderingIntent(*args): return _CoreGraphics.CGImage_getRenderingIntent(*args)\n\tdef getBitmapInfo(*args): return _CoreGraphics.CGImage_getBitmapInfo(*args)\n\tdef createWithImageInRect(*args): return _CoreGraphics.CGImage_createWithImageInRect(*args)\n\tdef createWithMask(*args): return _CoreGraphics.CGImage_createWithMask(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGShading", "data": "class CGShading(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGShading, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGShading, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGShading\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPattern", "data": "class CGPattern(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPattern, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPattern, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGPattern\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGColor", "data": "class CGColor(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGColor, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGColor, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGColor\n\t__del__ = lambda self : None;\n\tdef equalToColor(*args): return _CoreGraphics.CGColor_equalToColor(*args)\n\tdef getNumberOfComponents(*args): return _CoreGraphics.CGColor_getNumberOfComponents(*args)\n\tdef getComponents(*args): return _CoreGraphics.CGColor_getComponents(*args)\n\tdef getAlpha(*args): return _CoreGraphics.CGColor_getAlpha(*args)\n\tdef getColorSpace(*args): return _CoreGraphics.CGColor_getColorSpace(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPath", "data": "class CGPath(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPath, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPath, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGPath\n\t__del__ = lambda self : None;\n\tdef equalToPath(*args): return _CoreGraphics.CGPath_equalToPath(*args)\n\tdef isEmpty(*args): return _CoreGraphics.CGPath_isEmpty(*args)\n\tdef isRect(*args): return _CoreGraphics.CGPath_isRect(*args)\n\tdef getCurrentPoint(*args): return _CoreGraphics.CGPath_getCurrentPoint(*args)\n\tdef getBoundingBox(*args): return _CoreGraphics.CGPath_getBoundingBox(*args)\n\tdef containsPoint(*args): return _CoreGraphics.CGPath_containsPoint(*args)\n\tdef moveToPoint(*args): return _CoreGraphics.CGPath_moveToPoint(*args)\n\tdef addLineToPoint(*args): return _CoreGraphics.CGPath_addLineToPoint(*args)\n\tdef addQuadCurveToPoint(*args): return _CoreGraphics.CGPath_addQuadCurveToPoint(*args)\n\tdef addCurveToPoint(*args): return _CoreGraphics.CGPath_addCurveToPoint(*args)\n\tdef closeSubpath(*args): return _CoreGraphics.CGPath_closeSubpath(*args)\n\tdef addRect(*args): return _CoreGraphics.CGPath_addRect(*args)\n\tdef addRects(*args): return _CoreGraphics.CGPath_addRects(*args)\n\tdef addLines(*args): return _CoreGraphics.CGPath_addLines(*args)\n\tdef addEllipseInRect(*args): return _CoreGraphics.CGPath_addEllipseInRect(*args)\n\tdef addArc(*args): return _CoreGraphics.CGPath_addArc(*args)\n\tdef addArcToPoint(*args): return _CoreGraphics.CGPath_addArcToPoint(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGContext", "data": "class CGContext(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGContext, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGContext, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGContext\n\t__del__ = lambda self : None;\n\tdef saveGState(*args): return _CoreGraphics.CGContext_saveGState(*args)\n\tdef restoreGState(*args): return _CoreGraphics.CGContext_restoreGState(*args)\n\tdef scaleCTM(*args): return _CoreGraphics.CGContext_scaleCTM(*args)\n\tdef translateCTM(*args): return _CoreGraphics.CGContext_translateCTM(*args)\n\tdef rotateCTM(*args): return _CoreGraphics.CGContext_rotateCTM(*args)\n\tdef concatCTM(*args): return _CoreGraphics.CGContext_concatCTM(*args)\n\tdef getCTM(*args): return _CoreGraphics.CGContext_getCTM(*args)\n\tdef setLineWidth(*args): return _CoreGraphics.CGContext_setLineWidth(*args)\n\tdef setLineCap(*args): return _CoreGraphics.CGContext_setLineCap(*args)\n\tdef setLineJoin(*args): return _CoreGraphics.CGContext_setLineJoin(*args)\n\tdef setMiterLimit(*args): return _CoreGraphics.CGContext_setMiterLimit(*args)\n\tdef setLineDash(*args): return _CoreGraphics.CGContext_setLineDash(*args)\n\tdef setFlatness(*args): return _CoreGraphics.CGContext_setFlatness(*args)\n\tdef setAlpha(*args): return _CoreGraphics.CGContext_setAlpha(*args)\n\tdef setBlendMode(*args): return _CoreGraphics.CGContext_setBlendMode(*args)\n\tdef beginPath(*args): return _CoreGraphics.CGContext_beginPath(*args)\n\tdef moveToPoint(*args): return _CoreGraphics.CGContext_moveToPoint(*args)\n\tdef addLineToPoint(*args): return _CoreGraphics.CGContext_addLineToPoint(*args)\n\tdef addCurveToPoint(*args): return _CoreGraphics.CGContext_addCurveToPoint(*args)\n\tdef addQuadCurveToPoint(*args): return _CoreGraphics.CGContext_addQuadCurveToPoint(*args)\n\tdef closePath(*args): return _CoreGraphics.CGContext_closePath(*args)\n\tdef addRect(*args): return _CoreGraphics.CGContext_addRect(*args)\n\tdef addRects(*args): return _CoreGraphics.CGContext_addRects(*args)\n\tdef addLines(*args): return _CoreGraphics.CGContext_addLines(*args)\n\tdef addEllipseInRect(*args): return _CoreGraphics.CGContext_addEllipseInRect(*args)\n\tdef addArc(*args): return _CoreGraphics.CGContext_addArc(*args)\n\tdef addArcToPoint(*args): return _CoreGraphics.CGContext_addArcToPoint(*args)\n\tdef addPath(*args): return _CoreGraphics.CGContext_addPath(*args)\n\tdef replacePathWithStrokedPath(*args): return _CoreGraphics.CGContext_replacePathWithStrokedPath(*args)\n\tdef isPathEmpty(*args): return _CoreGraphics.CGContext_isPathEmpty(*args)\n\tdef getPathCurrentPoint(*args): return _CoreGraphics.CGContext_getPathCurrentPoint(*args)\n\tdef getPathBoundingBox(*args): return _CoreGraphics.CGContext_getPathBoundingBox(*args)\n\tdef pathContainsPoint(*args): return _CoreGraphics.CGContext_pathContainsPoint(*args)\n\tdef drawPath(*args): return _CoreGraphics.CGContext_drawPath(*args)\n\tdef fillPath(*args): return _CoreGraphics.CGContext_fillPath(*args)\n\tdef eoFillPath(*args): return _CoreGraphics.CGContext_eoFillPath(*args)\n\tdef strokePath(*args): return _CoreGraphics.CGContext_strokePath(*args)\n\tdef fillRect(*args): return _CoreGraphics.CGContext_fillRect(*args)\n\tdef fillRects(*args): return _CoreGraphics.CGContext_fillRects(*args)\n\tdef strokeRect(*args): return _CoreGraphics.CGContext_strokeRect(*args)\n\tdef strokeRectWithWidth(*args): return _CoreGraphics.CGContext_strokeRectWithWidth(*args)\n\tdef clearRect(*args): return _CoreGraphics.CGContext_clearRect(*args)\n\tdef fillEllipseInRect(*args): return _CoreGraphics.CGContext_fillEllipseInRect(*args)\n\tdef strokeEllipseInRect(*args): return _CoreGraphics.CGContext_strokeEllipseInRect(*args)\n\tdef strokeLineSegments(*args): return _CoreGraphics.CGContext_strokeLineSegments(*args)\n\tdef clip(*args): return _CoreGraphics.CGContext_clip(*args)\n\tdef eoClip(*args): return _CoreGraphics.CGContext_eoClip(*args)\n\tdef clipToMask(*args): return _CoreGraphics.CGContext_clipToMask(*args)\n\tdef clipToRect(*args): return _CoreGraphics.CGContext_clipToRect(*args)\n\tdef clipToRects(*args): return _CoreGraphics.CGContext_clipToRects(*args)\n\tdef setFillColorWithColor(*args): return _CoreGraphics.CGContext_setFillColorWithColor(*args)\n\tdef setStrokeColorWithColor(*args): return _CoreGraphics.CGContext_setStrokeColorWithColor(*args)\n\tdef setFillColorSpace(*args): return _CoreGraphics.CGContext_setFillColorSpace(*args)\n\tdef setStrokeColorSpace(*args): return _CoreGraphics.CGContext_setStrokeColorSpace(*args)\n\tdef setFillColor(*args): return _CoreGraphics.CGContext_setFillColor(*args)\n\tdef setStrokeColor(*args): return _CoreGraphics.CGContext_setStrokeColor(*args)\n\tdef setFillPattern(*args): return _CoreGraphics.CGContext_setFillPattern(*args)\n\tdef setStrokePattern(*args): return _CoreGraphics.CGContext_setStrokePattern(*args)\n\tdef setPatternPhase(*args): return _CoreGraphics.CGContext_setPatternPhase(*args)\n\tdef setGrayFillColor(*args): return _CoreGraphics.CGContext_setGrayFillColor(*args)\n\tdef setGrayStrokeColor(*args): return _CoreGraphics.CGContext_setGrayStrokeColor(*args)\n\tdef setRGBFillColor(*args): return _CoreGraphics.CGContext_setRGBFillColor(*args)\n\tdef setRGBStrokeColor(*args): return _CoreGraphics.CGContext_setRGBStrokeColor(*args)\n\tdef setCMYKFillColor(*args): return _CoreGraphics.CGContext_setCMYKFillColor(*args)\n\tdef setCMYKStrokeColor(*args): return _CoreGraphics.CGContext_setCMYKStrokeColor(*args)\n\tdef setRenderingIntent(*args): return _CoreGraphics.CGContext_setRenderingIntent(*args)\n\tdef drawImage(*args): return _CoreGraphics.CGContext_drawImage(*args)\n\tdef drawLayerInRect(*args): return _CoreGraphics.CGContext_drawLayerInRect(*args)\n\tdef drawLayerAtPoint(*args): return _CoreGraphics.CGContext_drawLayerAtPoint(*args)\n\tdef getInterpolationQuality(*args): return _CoreGraphics.CGContext_getInterpolationQuality(*args)\n\tdef setInterpolationQuality(*args): return _CoreGraphics.CGContext_setInterpolationQuality(*args)\n\tdef setShadowWithColor(*args): return _CoreGraphics.CGContext_setShadowWithColor(*args)\n\tdef setShadow(*args): return _CoreGraphics.CGContext_setShadow(*args)\n\tdef drawShading(*args): return _CoreGraphics.CGContext_drawShading(*args)\n\tdef setCharacterSpacing(*args): return _CoreGraphics.CGContext_setCharacterSpacing(*args)\n\tdef setTextPosition(*args): return _CoreGraphics.CGContext_setTextPosition(*args)\n\tdef getTextPosition(*args): return _CoreGraphics.CGContext_getTextPosition(*args)\n\tdef setTextMatrix(*args): return _CoreGraphics.CGContext_setTextMatrix(*args)\n\tdef getTextMatrix(*args): return _CoreGraphics.CGContext_getTextMatrix(*args)\n\tdef setTextDrawingMode(*args): return _CoreGraphics.CGContext_setTextDrawingMode(*args)\n\tdef setFontSize(*args): return _CoreGraphics.CGContext_setFontSize(*args)\n\tdef selectFont(*args): return _CoreGraphics.CGContext_selectFont(*args)\n\tdef showText(*args): return _CoreGraphics.CGContext_showText(*args)\n\tdef showGlyphs(*args): return _CoreGraphics.CGContext_showGlyphs(*args)\n\tdef showTextAtPoint(*args): return _CoreGraphics.CGContext_showTextAtPoint(*args)\n\tdef showGlyphsAtPoint(*args): return _CoreGraphics.CGContext_showGlyphsAtPoint(*args)\n\tdef drawPlainTextInRect(*args): return _CoreGraphics.CGContext_drawPlainTextInRect(*args)\n\tdef drawRTFTextInRect(*args): return _CoreGraphics.CGContext_drawRTFTextInRect(*args)\n\tdef drawDocFormatTextInRect(*args): return _CoreGraphics.CGContext_drawDocFormatTextInRect(*args)\n\tdef drawWordMLFormatTextInRect(*args): return _CoreGraphics.CGContext_drawWordMLFormatTextInRect(*args)\n\tdef drawHTMLTextInRect(*args): return _CoreGraphics.CGContext_drawHTMLTextInRect(*args)\n\tdef drawPDFDocument(*args): return _CoreGraphics.CGContext_drawPDFDocument(*args)\n\tdef beginPage(*args): return _CoreGraphics.CGContext_beginPage(*args)\n\tdef endPage(*args): return _CoreGraphics.CGContext_endPage(*args)\n\tdef flush(*args): return _CoreGraphics.CGContext_flush(*args)\n\tdef synchronize(*args): return _CoreGraphics.CGContext_synchronize(*args)\n\tdef setShouldAntialias(*args): return _CoreGraphics.CGContext_setShouldAntialias(*args)\n\tdef setAllowsAntialiasing(*args): return _CoreGraphics.CGContext_setAllowsAntialiasing(*args)\n\tdef setShouldSmoothFonts(*args): return _CoreGraphics.CGContext_setShouldSmoothFonts(*args)\n\tdef beginTransparencyLayer(*args): return _CoreGraphics.CGContext_beginTransparencyLayer(*args)\n\tdef endTransparencyLayer(*args): return _CoreGraphics.CGContext_endTransparencyLayer(*args)\n\tdef getUserSpaceToDeviceSpaceTransform(*args): return _CoreGraphics.CGContext_getUserSpaceToDeviceSpaceTransform(*args)\n\tdef convertPointToDeviceSpace(*args): return _CoreGraphics.CGContext_convertPointToDeviceSpace(*args)\n\tdef convertPointToUserSpace(*args): return _CoreGraphics.CGContext_convertPointToUserSpace(*args)\n\tdef convertSizeToDeviceSpace(*args): return _CoreGraphics.CGContext_convertSizeToDeviceSpace(*args)\n\tdef convertSizeToUserSpace(*args): return _CoreGraphics.CGContext_convertSizeToUserSpace(*args)\n\tdef CGContextConvertRectToDeviceSpace(*args): return _CoreGraphics.CGContext_CGContextConvertRectToDeviceSpace(*args)\n\tdef convertRectToUserSpace(*args): return _CoreGraphics.CGContext_convertRectToUserSpace(*args)\n\tdef finish(self):\n\t  self.flush ()\n\t  if self.thisown:\n\t\t_CoreGraphics.delete_CGContext (self)\n\t\tself.thisown = 0; \n\tdef getData(*args): return _CoreGraphics.CGContext_getData(*args)\n\tdef getWidth(*args): return _CoreGraphics.CGContext_getWidth(*args)\n\tdef getHeight(*args): return _CoreGraphics.CGContext_getHeight(*args)\n\tdef getBitsPerComponent(*args): return _CoreGraphics.CGContext_getBitsPerComponent(*args)\n\tdef getBitsPerPixel(*args): return _CoreGraphics.CGContext_getBitsPerPixel(*args)\n\tdef getBytesPerRow(*args): return _CoreGraphics.CGContext_getBytesPerRow(*args)\n\tdef getColorSpace(*args): return _CoreGraphics.CGContext_getColorSpace(*args)\n\tdef getAlphaInfo(*args): return _CoreGraphics.CGContext_getAlphaInfo(*args)\n\tdef createImage(*args): return _CoreGraphics.CGContext_createImage(*args)\n\tdef writeToDataConsumer(*args): return _CoreGraphics.CGContext_writeToDataConsumer(*args)\n\tdef writeToFile(*args): return _CoreGraphics.CGContext_writeToFile(*args)\n\tdef setURLForRect(*args): return _CoreGraphics.CGContext_setURLForRect(*args)\n\tdef addDestinationAtPoint(*args): return _CoreGraphics.CGContext_addDestinationAtPoint(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPDFDictionary", "data": "class CGPDFDictionary(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPDFDictionary, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPDFDictionary, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\tdef getCount(*args): return _CoreGraphics.CGPDFDictionary_getCount(*args)\n\tdef getKeys(*args): return _CoreGraphics.CGPDFDictionary_getKeys(*args)\n\tdef getBoolean(*args): return _CoreGraphics.CGPDFDictionary_getBoolean(*args)\n\tdef getInteger(*args): return _CoreGraphics.CGPDFDictionary_getInteger(*args)\n\tdef getNumber(*args): return _CoreGraphics.CGPDFDictionary_getNumber(*args)\n\tdef getName(*args): return _CoreGraphics.CGPDFDictionary_getName(*args)\n\tdef getString(*args): return _CoreGraphics.CGPDFDictionary_getString(*args)\n\tdef getArray(*args): return _CoreGraphics.CGPDFDictionary_getArray(*args)\n\tdef getDictionary(*args): return _CoreGraphics.CGPDFDictionary_getDictionary(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPDFArray", "data": "class CGPDFArray(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPDFArray, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPDFArray, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\tdef getCount(*args): return _CoreGraphics.CGPDFArray_getCount(*args)\n\tdef getNull(*args): return _CoreGraphics.CGPDFArray_getNull(*args)\n\tdef getBoolean(*args): return _CoreGraphics.CGPDFArray_getBoolean(*args)\n\tdef getInteger(*args): return _CoreGraphics.CGPDFArray_getInteger(*args)\n\tdef getNumber(*args): return _CoreGraphics.CGPDFArray_getNumber(*args)\n\tdef getName(*args): return _CoreGraphics.CGPDFArray_getName(*args)\n\tdef getString(*args): return _CoreGraphics.CGPDFArray_getString(*args)\n\tdef getArray(*args): return _CoreGraphics.CGPDFArray_getArray(*args)\n\tdef getDictionary(*args): return _CoreGraphics.CGPDFArray_getDictionary(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPDFContentStream", "data": "class CGPDFContentStream(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPDFContentStream, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPDFContentStream, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGPDFContentStream\n\t__del__ = lambda self : None;\n\tdef retain(*args): return _CoreGraphics.CGPDFContentStream_retain(*args)\n\tdef release(*args): return _CoreGraphics.CGPDFContentStream_release(*args)\n\tdef getStreams(*args): return _CoreGraphics.CGPDFContentStream_getStreams(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPDFOperatorTable", "data": "class CGPDFOperatorTable(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPDFOperatorTable, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPDFOperatorTable, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGPDFOperatorTable\n\t__del__ = lambda self : None;\n\tdef retain(*args): return _CoreGraphics.CGPDFOperatorTable_retain(*args)\n\tdef release(*args): return _CoreGraphics.CGPDFOperatorTable_release(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPDFScanner", "data": "class CGPDFScanner(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPDFScanner, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPDFScanner, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGPDFScanner\n\t__del__ = lambda self : None;\n\tdef release(*args): return _CoreGraphics.CGPDFScanner_release(*args)\n\tdef scan(*args): return _CoreGraphics.CGPDFScanner_scan(*args)\n\tdef getContentStream(*args): return _CoreGraphics.CGPDFScanner_getContentStream(*args)\n\tdef popObject(*args): return _CoreGraphics.CGPDFScanner_popObject(*args)\n\tdef popBoolean(*args): return _CoreGraphics.CGPDFScanner_popBoolean(*args)\n\tdef popInteger(*args): return _CoreGraphics.CGPDFScanner_popInteger(*args)\n\tdef popNumber(*args): return _CoreGraphics.CGPDFScanner_popNumber(*args)\n\tdef popName(*args): return _CoreGraphics.CGPDFScanner_popName(*args)\n\tdef popString(*args): return _CoreGraphics.CGPDFScanner_popString(*args)\n\tdef popArray(*args): return _CoreGraphics.CGPDFScanner_popArray(*args)\n\tdef popDictionary(*args): return _CoreGraphics.CGPDFScanner_popDictionary(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPDFStream", "data": "class CGPDFStream(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPDFStream, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPDFStream, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\tdef getDictionary(*args): return _CoreGraphics.CGPDFStream_getDictionary(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPDFPage", "data": "class CGPDFPage(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPDFPage, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPDFPage, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGPDFPage\n\t__del__ = lambda self : None;\n\tdef getDocument(*args): return _CoreGraphics.CGPDFPage_getDocument(*args)\n\tdef getPageNumber(*args): return _CoreGraphics.CGPDFPage_getPageNumber(*args)\n\tdef getBoxRect(*args): return _CoreGraphics.CGPDFPage_getBoxRect(*args)\n\tdef getRotationAngle(*args): return _CoreGraphics.CGPDFPage_getRotationAngle(*args)\n\tdef getDrawingTransform(*args): return _CoreGraphics.CGPDFPage_getDrawingTransform(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPDFDocument", "data": "class CGPDFDocument(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPDFDocument, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPDFDocument, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGPDFDocument\n\t__del__ = lambda self : None;\n\tdef getVersion(*args): return _CoreGraphics.CGPDFDocument_getVersion(*args)\n\tdef isEncrypted(*args): return _CoreGraphics.CGPDFDocument_isEncrypted(*args)\n\tdef unlockWithPassword(*args): return _CoreGraphics.CGPDFDocument_unlockWithPassword(*args)\n\tdef isUnlocked(*args): return _CoreGraphics.CGPDFDocument_isUnlocked(*args)\n\tdef allowsPrinting(*args): return _CoreGraphics.CGPDFDocument_allowsPrinting(*args)\n\tdef allowsCopying(*args): return _CoreGraphics.CGPDFDocument_allowsCopying(*args)\n\tdef getNumberOfPages(*args): return _CoreGraphics.CGPDFDocument_getNumberOfPages(*args)\n\tdef getPage(*args): return _CoreGraphics.CGPDFDocument_getPage(*args)\n\tdef getCatalog(*args): return _CoreGraphics.CGPDFDocument_getCatalog(*args)\n\tdef getInfo(*args): return _CoreGraphics.CGPDFDocument_getInfo(*args)\n\tdef getID(*args): return _CoreGraphics.CGPDFDocument_getID(*args)\n\tdef getMediaBox(*args): return _CoreGraphics.CGPDFDocument_getMediaBox(*args)\n\tdef getCropBox(*args): return _CoreGraphics.CGPDFDocument_getCropBox(*args)\n\tdef getBleedBox(*args): return _CoreGraphics.CGPDFDocument_getBleedBox(*args)\n\tdef getTrimBox(*args): return _CoreGraphics.CGPDFDocument_getTrimBox(*args)\n\tdef getArtBox(*args): return _CoreGraphics.CGPDFDocument_getArtBox(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPSConverter", "data": "class CGPSConverter(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPSConverter, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPSConverter, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGPSConverter\n\t__del__ = lambda self : None;\n\tdef convert(*args): return _CoreGraphics.CGPSConverter_convert(*args)\n\tdef abort(*args): return _CoreGraphics.CGPSConverter_abort(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}], [{"term": "class", "name": "GraphicsTest", "data": "class GraphicsTest(SampleBase):\n\tdef __init__(self, *args, **kwargs):\n\t\tsuper(GraphicsTest, self).__init__(*args, **kwargs)\n\n\tdef run(self):\n\t\tcanvas = self.matrix\n\t\tfont = graphics.Font()\n\t\tfont.LoadFont(\"../../../fonts/7x13.bdf\")\n\n\t\tred = graphics.Color(255, 0, 0)\n\t\tgraphics.DrawLine(canvas, 5, 5, 22, 13, red)\n\n\t\tgreen = graphics.Color(0, 255, 0)\n\t\tgraphics.DrawCircle(canvas, 15, 15, 10, green)\n\n\t\tblue = graphics.Color(0, 0, 255)\n\t\tgraphics.DrawText(canvas, font, 2, 10, blue, \"Text\")\n\n\t\ttime.sleep(10)   # show display for 10 seconds before exit\n\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "import time"]}], [{"term": "class", "name": "MultiGraphics", "data": "class MultiGraphics(WithEqualityById, SageObject):\n\tr\"\"\"\n\tBase class for objects composed of :class:`~sage.plot.graphics.Graphics`\n\tobjects.\n\n\tBoth the display and the output to a file of ``MultiGraphics`` objects\n\tare governed by the method :meth:`save`, which is called by the rich output\n\tdisplay manager, via\n\t:meth:`~sage.repl.rich_output.display_manager.DisplayManager.graphics_from_save`.\n\n\tThe user interface is through the functions\n\t:func:`~sage.plot.plot.multi_graphics` (generic multi-graphics) and\n\t:func:`~sage.plot.plot.graphics_array` (subclass :class:`GraphicsArray`).\n\n\tINPUT:\n\n\t- ``graphics_list`` -- a list of graphics along with their positions on the\n\t  common canvas; each element of ``graphics_list`` is either\n\n\t  - a pair ``(graphics, position)``, where ``graphics`` is a\n\t\t:class:`~sage.plot.graphics.Graphics` object and ``position`` is the\n\t\t4-tuple ``(left, bottom, width, height)`` specifying the location and\n\t\tsize of the graphics on the canvas, all quantities being in fractions\n\t\tof the canvas width and height\n\n\t  - or a single :class:`~sage.plot.graphics.Graphics` object; its position\n\t\tis then assumed to occupy the whole canvas, except for some padding;\n\t\tthis corresponds to the default position\n\t\t``(left, bottom, width, height) = (0.125, 0.11, 0.775, 0.77)``\n\n\tEXAMPLES:\n\n\tA multi-graphics made from two graphics objects::\n\n\t\tsage: g1 = plot(sin(x^3), (x, -pi, pi))\n\t\tsage: g2 = circle((0,0), 1, color='red')\n\t\tsage: G = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tsage: G\n\t\tMultigraphics with 2 elements\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**3), (x, -pi, pi))\n\t\tg2 = circle((0,0), 1, color='red')\n\t\tG = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tsphinx_plot(G)\n\n\tSince no position was given for ``g1``, it occupies the whole canvas.\n\tMoreover, we note that ``g2`` has been drawn over ``g1`` with a white\n\tbackground. To have a transparent background instead, one has to construct\n\t``g2`` with the keyword ``transparent`` set to ``True``::\n\n\t\tsage: g2 = circle((0,0), 1, color='red', transparent=True)\n\t\tsage: G = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tsage: G\n\t\tMultigraphics with 2 elements\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**3), (x, -pi, pi))\n\t\tg2 = circle((0,0), 1, color='red', transparent=True)\n\t\tG = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tsphinx_plot(G)\n\n\tWe can add a new graphics object to G via the method :meth:`append`::\n\n\t\tsage: g3 = complex_plot(zeta, (-20, 10), (-20, 20),\n\t\t....:\t\t\t\t   axes_labels=['$x$', '$y$'], frame=True)\n\t\tsage: G.append(g3, pos=(0.63, 0.12, 0.3, 0.3))\n\t\tsage: G\n\t\tMultigraphics with 3 elements\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**3), (x, -pi, pi))\n\t\tg2 = circle((0,0), 1, color='red', transparent=True)\n\t\tG = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tg3 = complex_plot(zeta, (-20, 10), (-20, 20), \\\n\t\t\t\t\t\t  axes_labels=['$x$', '$y$'], frame=True)\n\t\tG.append(g3, pos=(0.63, 0.12, 0.3, 0.3))\n\t\tsphinx_plot(G)\n\n\tWe can access the individual elements composing ``G`` with the\n\tsquare-bracket operator::\n\n\t\tsage: print(G[0])\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: G[0] is g1\n\t\tTrue\n\t\tsage: G[1] is g2\n\t\tTrue\n\t\tsage: G[2] is g3\n\t\tTrue\n\n\t``G[:]`` returns the full list of graphics objects composing ``G``::\n\n\t\tsage: G[:]\n\t\t[Graphics object consisting of 1 graphics primitive,\n\t\t Graphics object consisting of 1 graphics primitive,\n\t\t Graphics object consisting of 1 graphics primitive]\n\t\tsage: len(G)\n\t\t3\n\n\t\"\"\"\n\tdef __init__(self, graphics_list):\n\t\tr\"\"\"\n\t\tInitialize the attributes common to all MultiGraphics objects.\n\n\t\tTESTS::\n\n\t\t\tsage: from sage.plot.multigraphics import MultiGraphics\n\t\t\tsage: G = MultiGraphics([])\n\t\t\tsage: print(G)\n\t\t\tMultigraphics with 0 element\n\t\t\tsage: c = circle((0,0), 1)\n\t\t\tsage: G = MultiGraphics([c, (c, (0.7, 0.6, 0.2, 0.2))])\n\t\t\tsage: print(G)\n\t\t\tMultigraphics with 2 elements\n\n\t\t\"\"\"\n\t\tself._glist = []\n\t\tself._positions = []\n\t\t#\n\t\tfor ins in graphics_list:\n\t\t\tif isinstance(ins, Graphics):\n\t\t\t\tself.append(ins)  # default position\n\t\t\telse:\n\t\t\t\tif not isinstance(ins, (list, tuple)) or len(ins) != 2:\n\t\t\t\t\traise TypeError(\"a pair (Graphics, position) is \"\n\t\t\t\t\t\t\t\t\t\"expected, not {}\".format(ins))\n\t\t\t\tself.append(ins[0], pos=ins[1])\n\n\tdef _repr_(self):\n\t\tr\"\"\"\n\t\tRepresentation of ``self``.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: c = circle((0,0), 1)\n\t\t\tsage: G = graphics_array([c, c, c])\n\t\t\tsage: G._repr_()\n\t\t\t'Graphics Array of size 1 x 3'\n\t\t\tsage: G\n\t\t\tGraphics Array of size 1 x 3\n\n\t\t\"\"\"\n\t\treturn str(self)\n\n\tdef _rich_repr_(self, display_manager, **kwds):\n\t\tr\"\"\"\n\t\tRich Output Magic Method.\n\n\t\tSee :mod:`sage.repl.rich_output` for details.\n\n\t\t.. TODO::\n\n\t\t   This method is identical to Graphics._rich_repr_ so it could be\n\t\t   inherited from a common base class\n\n\t\tEXAMPLES::\n\n\t\t\tsage: from sage.repl.rich_output import get_display_manager\n\t\t\tsage: dm = get_display_manager()\n\t\t\tsage: G = graphics_array([Graphics(), Graphics()], 1, 2)\n\t\t\tsage: G._rich_repr_(dm)\n\t\t\tOutputImagePng container\n\n\t\t\"\"\"\n\t\ttypes = display_manager.types\n\t\tprefer_raster = (\n\t\t\t('.png', types.OutputImagePng),\n\t\t\t('.jpg', types.OutputImageJpg),\n\t\t\t('.gif', types.OutputImageGif),\n\t\t)\n\t\tprefer_vector = (\n\t\t\t('.svg', types.OutputImageSvg),\n\t\t\t('.pdf', types.OutputImagePdf),\n\t\t)\n\t\tgraphics = display_manager.preferences.graphics\n\t\tif graphics == 'disable':\n\t\t\treturn\n\t\telif graphics == 'raster' or graphics is None:\n\t\t\tpreferred = prefer_raster + prefer_vector\n\t\telif graphics == 'vector':\n\t\t\tpreferred = prefer_vector + prefer_raster\n\t\telse:\n\t\t\traise ValueError('unknown graphics output preference')\n\t\tfor file_ext, output_container in preferred:\n\t\t\tif output_container in display_manager.supported_output():\n\t\t\t\treturn display_manager.graphics_from_save(\n\t\t\t\t\tself.save, kwds, file_ext, output_container)\n\n\tdef __getitem__(self, i):\n\t\tr\"\"\"\n\t\tReturn the ``i``th element of the list of graphics composing ``self``.\n\n\t\tEXAMPLES:\n\n\t\tWe can access and view individual plots::\n\n\t\t\tsage: L = [[plot(x^2)], [plot(x^3)]]\n\t\t\tsage: G = graphics_array(L)\n\t\t\tsage: G[1]\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tAnother example::\n\n\t\t\tsage: L = [plot(sin(k*x), (x,-pi,pi)) + circle((k,k), 1,\n\t\t\t....:\t\t   color='red') for k in range(10)]\n\t\t\tsage: G = graphics_array(L, 5, 2)\n\t\t\tsage: G[3]\n\t\t\tGraphics object consisting of 2 graphics primitives\n\n\t\t\"\"\"\n\t\treturn self._glist[i]\n\n\tdef __setitem__(self, i, g):\n\t\tr\"\"\"\n\t\tSet the ``i``th element of the list of graphics composing ``self``.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: L = [[plot(x^2)], [plot(x^3)]]\n\t\t\tsage: G = graphics_array(L)\n\t\t\tsage: G[1] # the plot of x^3\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tNow we change it::\n\n\t\t\tsage: G[1] = circle((1,1), 2) + points([(1,2), (3,2), (5,5)],\n\t\t\t....:\t\t\t\t\t\t\t\t  color='purple')\n\t\t\tsage: G[1] # a circle and some purple points\n\t\t\tGraphics object consisting of 2 graphics primitives\n\n\t\t\"\"\"\n\t\tself._glist[i] = g\n\n\tdef __len__(self):\n\t\tr\"\"\"\n\t\tTotal number of Graphics objects composing ``self``.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: L = [circle((0,0), n) for n in range(6)]\n\t\t\tsage: G = graphics_array(L, 2, 3)\n\t\t\tsage: len(G)\n\t\t\t6\n\n\t\t\"\"\"\n\t\treturn len(self._glist)\n\n\tdef matplotlib(self, figure=None, figsize=None, **kwds):\n\t\tr\"\"\"\n\t\tConstruct or modify a Matplotlib figure by drawing ``self`` on it.\n\n\t\tINPUT:\n\n\t\t- ``figure`` -- (default: ``None``) Matplotlib figure (class\n\t\t  ``matplotlib.figure.Figure``) on which ``self`` is to be displayed;\n\t\t  if ``None``, the figure will be created from the parameter\n\t\t  ``figsize``\n\n\t\t- ``figsize`` -- (default: ``None``) width or [width, height] in inches\n\t\t  of the Matplotlib figure in case ``figure`` is ``None``; if\n\t\t  ``figsize`` is ``None``, Matplotlib's default (6.4 x 4.8 inches) is\n\t\t  used\n\n\t\t- ``kwds`` -- options passed to the\n\t\t  :meth:`~sage.plot.graphics.Graphics.matplotlib` method of\n\t\t  each graphics object constituting ``self``\n\n\t\tOUTPUT:\n\n\t\t- a ``matplotlib.figure.Figure`` object; if the argument ``figure`` is\n\t\t  provided, this is the same object as ``figure``.\n\n\t\tEXAMPLES:\n\n\t\tLet us consider a :class:`GraphicsArray` object with 3 elements::\n\n\t\t\tsage: G = graphics_array([plot(sin(x^k), (x, 0, 3))\n\t\t\t....:\t\t\t\t\t for k in range(1, 4)])\n\n\t\tIf ``matplotlib()`` is invoked without any argument, a Matplotlib\n\t\tfigure is created and contains the 3 graphics element of the array\n\t\tas 3 Matplotlib ``Axes``::\n\n\t\t\tsage: fig = G.matplotlib()\n\t\t\tsage: fig\n\t\t\t\n\t\t\tsage: type(fig)\n\t\t\t\n\n\t\tSpecifying the figure size (in inches)::\n\n\t\t\tsage: G.matplotlib(figsize=(8., 5.))\n\t\t\t\n\n\t\tIf a single number is provided for ``figsize``, it is considered to be\n\t\tthe width; the height is then computed according to Matplotlib's\n\t\tdefault aspect ratio (4/3)::\n\n\t\t\tsage: G.matplotlib(figsize=8.)\n\t\t\t\n\n\t\tAn example of use with a preexisting created figure, created by\n\t\t``pyplot``::\n\n\t\t\tsage: import matplotlib.pyplot as plt\n\t\t\tsage: fig1 = plt.figure(1)\n\t\t\tsage: fig1\n\t\t\t\n\t\t\tsage: fig_out = G.matplotlib(figure=fig1)\n\t\t\tsage: fig_out\n\t\t\t\n\n\t\tNote that the output figure is the same object as the input one::\n\n\t\t\tsage: fig_out is fig1\n\t\t\tTrue\n\n\t\tIt has however been modified by ``G.matplotlib(figure=fig1)``, which\n\t\thas added 3 new ``Axes`` to it.\n\n\t\tAnother example, with a figure created from scratch, via Matplolib's\n\t\t``Figure``::\n\n\t\t\tsage: from matplotlib.figure import Figure\n\t\t\tsage: fig2 = Figure()\n\t\t\tsage: fig2\n\t\t\t\n\t\t\tsage: G.matplotlib(figure=fig2)\n\t\t\t\n\t\t\tsage: fig2\n\t\t\t\n\n\t\t\"\"\"\n\t\tfrom matplotlib.figure import Figure\n\t\tglist = self._glist\n\t\tif len(glist) == 0:\t   # for an empty MultiGraphics, we create\n\t\t\tglist = [Graphics()]  # a 1-element list with an empty graphics\n\t\t# If no Matplotlib figure is provided, it is created here:\n\t\tif figure is None:\n\t\t\tif figsize is not None:\n\t\t\t\tfigsize = _parse_figsize(figsize)\n\t\t\tfigure = Figure(figsize=figsize)\n\t\tglobal do_verify\n\t\tdo_verify = True\n\t\tfor i, g in enumerate(glist):\n\t\t\t# Options for g.matplotlib():\n\t\t\toptions = {}\n\t\t\toptions.update(Graphics.SHOW_OPTIONS)  # default options for show()\n\t\t\toptions['legend_options'] = Graphics.LEGEND_OPTIONS  # default leg.\n\t\t\toptions.update(g._extra_kwds)  # options set in g\n\t\t\toptions.update(kwds)\n\t\t\t# We get rid of options that are not relevant for g.matplotlib():\n\t\t\toptions.pop('dpi', None)\n\t\t\toptions.pop('fig_tight', None)\n\t\t\ttransparent = options.pop('transparent', None)\n\t\t\t# Creating the Matplotlib Axes object \"subplot\" on the figure:\n\t\t\tsubplot = self._add_subplot(figure, i)\n\t\t\t# and drawing g on it:\n\t\t\tg.matplotlib(figure=figure, sub=subplot, verify=do_verify,\n\t\t\t\t\t\t **options)\n\t\t\tif transparent:\n\t\t\t\tsubplot.set_facecolor('none')\n\t\treturn figure\n\n\tdef save(self, filename, figsize=None, **kwds):\n\t\tr\"\"\"\n\t\tSave ``self`` to a file, in various formats.\n\n\t\tINPUT:\n\n\t\t- ``filename`` -- (string) the file name; the image format is given by\n\t\t  the extension, which can be one of the following:\n\n\t\t\t* ``.eps``,\n\n\t\t\t* ``.pdf``,\n\n\t\t\t* ``.png``,\n\n\t\t\t* ``.ps``,\n\n\t\t\t* ``.sobj`` (for a Sage object you can load later),\n\n\t\t\t* ``.svg``,\n\n\t\t\t* empty extension will be treated as ``.sobj``.\n\n\t\t- ``figsize`` -- (default: ``None``) width or [width, height] in inches\n\t\t  of the Matplotlib figure; if none is provided, Matplotlib's default\n\t\t  (6.4 x 4.8 inches) is used\n\n\t\t- ``kwds`` -- keyword arguments, like ``dpi=...``, passed to the\n\t\t  plotter, see :meth:`show`\n\n\t\tEXAMPLES::\n\n\t\t\tsage: F = tmp_filename(ext='.png')\n\t\t\tsage: L = [plot(sin(k*x), (x,-pi,pi)) for k in [1..3]]\n\t\t\tsage: G = graphics_array(L)\n\t\t\tsage: G.save(F, dpi=500, axes=False)\n\n\t\tTESTS::\n\n\t\t\tsage: graphics_array([]).save(F)\n\t\t\tsage: graphics_array([[]]).save(F)\n\n\t\t\"\"\"\n\t\tfrom matplotlib import rcParams\n\t\text = os.path.splitext(filename)[1].lower()\n\t\tif ext in ['', '.sobj']:\n\t\t\tSageObject.save(self, filename)\n\t\telif ext not in ALLOWED_EXTENSIONS:\n\t\t\traise ValueError(\"allowed file extensions for images are '\" +\n\t\t\t\t\t\t\t \"', '\".join(ALLOWED_EXTENSIONS) + \"'!\")\n\t\telse:\n\t\t\trc_backup = (rcParams['ps.useafm'], rcParams['pdf.use14corefonts'],\n\t\t\t\t\t\t rcParams['text.usetex'])  # save the rcParams\n\t\t\tfigure = self.matplotlib(figsize=figsize, **kwds)\n\t\t\ttransparent = kwds.get('transparent',\n\t\t\t\t\t\t\t\t   Graphics.SHOW_OPTIONS['transparent'])\n\t\t\tfig_tight = kwds.get('fig_tight',\n\t\t\t\t\t\t\t\t Graphics.SHOW_OPTIONS['fig_tight'])\n\t\t\tdpi = kwds.get('dpi', Graphics.SHOW_OPTIONS['dpi'])\n\t\t\t# One can output in PNG, PS, EPS, PDF, PGF, or SVG format,\n\t\t\t# depending on the file extension.\n\t\t\t# PGF is handled by a different backend\n\t\t\tif ext == '.pgf':\n\t\t\t\tfrom sage.misc.sage_ostools import have_program\n\t\t\t\tlatex_implementations = [i for i in [\"xelatex\", \"pdflatex\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t \"lualatex\"]\n\t\t\t\t\t\t\t\t\t\t if have_program(i)]\n\t\t\t\tif not latex_implementations:\n\t\t\t\t\traise ValueError(\"Matplotlib requires either xelatex, \"\n\t\t\t\t\t\t\t\t\t \"lualatex, or pdflatex.\")\n\t\t\t\tif latex_implementations[0] == \"pdflatex\":\n\t\t\t\t\t# use pdflatex and set font encoding as per\n\t\t\t\t\t# Matplotlib documentation:\n\t\t\t\t\t# https://matplotlib.org/users/pgf.html#pgf-tutorial\n\t\t\t\t\tpgf_options = {\"pgf.texsystem\": \"pdflatex\",\n\t\t\t\t\t\t\t\t   \"pgf.preamble\": [\n\t\t\t\t\t\t\t\t\t  r\"\\usepackage[utf8x]{inputenc}\",\n\t\t\t\t\t\t\t\t\t  r\"\\usepackage[T1]{fontenc}\"\n\t\t\t\t\t\t\t\t\t  ]}\n\t\t\t\telse:\n\t\t\t\t\tpgf_options = {\"pgf.texsystem\": latex_implementations[0]}\n\t\t\t\trcParams.update(pgf_options)\n\t\t\t\tfrom matplotlib.backends.backend_pgf import FigureCanvasPgf\n\t\t\t\tfigure.set_canvas(FigureCanvasPgf(figure))\n\t\t\t# Matplotlib looks at the file extension to see what the renderer\n\t\t\t# should be. The default is FigureCanvasAgg for PNG's because this\n\t\t\t# is by far the most common type of files rendered, like in the\n\t\t\t# notebook, for example. If the file extension is not '.png', then\n\t\t\t# Matplotlib will handle it.\n\t\t\telse:\n\t\t\t\tfrom matplotlib.backends.backend_agg import FigureCanvasAgg\n\t\t\t\tfigure.set_canvas(FigureCanvasAgg(figure))\n\t\t\tif isinstance(self, GraphicsArray):\n\t\t\t\t# tight_layout adjusts the *subplot* parameters so ticks aren't\n\t\t\t\t# cut off, etc.\n\t\t\t\tfigure.tight_layout()\n\t\t\topts = dict(dpi=dpi, transparent=transparent)\n\t\t\tif fig_tight is True:\n\t\t\t\topts['bbox_inches'] = 'tight'\n\t\t\tfigure.savefig(filename, **opts)\n\t\t\t# Restore the rcParams to the original, possibly user-set values\n\t\t\t(rcParams['ps.useafm'], rcParams['pdf.use14corefonts'],\n\t\t\t rcParams['text.usetex']) = rc_backup\n\n\tdef save_image(self, filename=None, *args, **kwds):\n\t\tr\"\"\"\n\t\tSave an image representation of ``self``.  The image type is\n\t\tdetermined by the extension of the filename.  For example,\n\t\tthis could be ``.png``, ``.jpg``, ``.gif``, ``.pdf``,\n\t\t``.svg``.  Currently this is implemented by calling the\n\t\t:meth:`save` method of self, passing along all arguments and\n\t\tkeywords.\n\n\t\t.. NOTE::\n\n\t\t\tNot all image types are necessarily implemented for all\n\t\t\tgraphics types.  See :meth:`save` for more details.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: plots = [[plot(m*cos(x + n*pi/4), (x, 0, 2*pi))\n\t\t\t....:\t\t   for n in range(3)] for m in range(1,3)]\n\t\t\tsage: G = graphics_array(plots)\n\t\t\tsage: G.save_image(tmp_filename(ext='.png'))\n\n\t\t\"\"\"\n\t\tself.save(filename, *args, **kwds)\n\n\tdef _latex_(self, **kwds):\n\t\tr\"\"\"\n\t\tReturn a string plotting ``self`` with PGF.\n\n\t\tINPUT:\n\n\t\tAll keyword arguments will be passed to the plotter.\n\n\t\tOUTPUT:\n\n\t\tA string of PGF commands to plot ``self``\n\n\t\tEXAMPLES::\n\n\t\t\tsage: A = graphics_array([plot(sin), plot(cos)])\n\t\t\tsage: A._latex_()[:40]  # not tested (see comment below)\n\t\t\t'%% Creator: Matplotlib, PGF backend\\n%%\\n%'\n\n\t\tThe above doctest fails on macOS due to the following Matplotlib issue: https://github.com/matplotlib/matplotlib/issues/10307\n\n\t\t\"\"\"\n\t\ttmpfilename = tmp_filename(ext='.pgf')\n\t\tself.save(filename=tmpfilename, **kwds)\n\t\twith open(tmpfilename, \"r\") as tmpfile:\n\t\t\tlatex_list = tmpfile.readlines()\n\t\treturn ''.join(latex_list)\n\n\tdef show(self, **kwds):\n\t\tr\"\"\"\n\t\tShow ``self`` immediately.\n\n\t\tThis method attempts to display the graphics immediately,\n\t\twithout waiting for the currently running code (if any) to\n\t\treturn to the command line. Be careful, calling it from within\n\t\ta loop will potentially launch a large number of external\n\t\tviewer programs.\n\n\t\tOPTIONAL INPUT:\n\n\t\t- ``dpi`` -- dots per inch\n\n\t\t- ``figsize`` -- width or [width, height] of the figure, in inches; the\n\t\t  default is 6.4 x 4.8 inches\n\n\t\t- ``axes`` -- boolean; if ``True``, all individual graphics are\n\t\t  endowed with axes; if ``False``, all axes are removed (this overrides\n\t\t  the ``axes`` option set in each graphics)\n\n\t\t- ``frame`` -- boolean; if ``True``, all individual graphics are\n\t\t  drawn with a frame around them; if ``False``, all frames are removed\n\t\t  (this overrides the ``frame`` option set in each graphics)\n\n\t\t- ``fontsize`` -- positive integer, the size of fonts for the axes\n\t\t  labels (this overrides the ``fontsize`` option set in each graphics)\n\n\t\tOUTPUT:\n\n\t\tThis method does not return anything. Use :meth:`save` if you\n\t\twant to save the figure as an image.\n\n\t\tEXAMPLES:\n\n\t\tThis draws a graphics array with four trig plots and no axes in any of\n\t\tthe plots and a figure width of 4 inches::\n\n\t\t\tsage: G = graphics_array([[plot(sin), plot(cos)],\n\t\t\t....:\t\t\t\t\t [plot(tan), plot(sec)]])\n\t\t\tsage: G.show(axes=False, figsize=4)\n\n\t\t.. PLOT::\n\n\t\t\tG = graphics_array([[plot(sin), plot(cos)], \\\n\t\t\t\t\t\t\t\t[plot(tan), plot(sec)]])\n\t\t\tsphinx_plot(G, axes=False, figsize=4)\n\n\t\tSame thing with a frame around each individual graphics::\n\n\t\t\tsage: G.show(axes=False, frame=True, figsize=4)\n\n\t\t.. PLOT::\n\n\t\t\tG = graphics_array([[plot(sin), plot(cos)], \\\n\t\t\t\t\t\t\t\t[plot(tan), plot(sec)]])\n\t\t\tsphinx_plot(G, axes=False, frame=True, figsize=4)\n\n\t\tActually, many options are possible; for instance, we may set\n\t\t``fontsize`` and ``gridlines``::\n\n\t\t\tsage: G.show(axes=False, frame=True, figsize=4, fontsize=8,\n\t\t\t....:\t\tgridlines='major')\n\n\t\t.. PLOT::\n\n\t\t\tG = graphics_array([[plot(sin), plot(cos)], \\\n\t\t\t\t\t\t\t\t[plot(tan), plot(sec)]])\n\t\t\tsphinx_plot(G, axes=False, frame=True, figsize=4, fontsize=8, \\\n\t\t\t\t\t\tgridlines='major')\n\n\t\t\"\"\"\n\t\tfrom sage.repl.rich_output import get_display_manager\n\t\tdm = get_display_manager()\n\t\tdm.display_immediately(self, **kwds)\n\n\tdef plot(self):\n\t\tr\"\"\"\n\t\tReturn ``self`` since ``self`` is already a graphics object.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: g1 = plot(cos, 0, 1)\n\t\t\tsage: g2 = circle((0,0), 1)\n\t\t\tsage: G = multi_graphics([g1, g2])\n\t\t\tsage: G.plot() is G\n\t\t\tTrue\n\n\t\t\"\"\"\n\t\treturn self\n\n\tdef inset(self, graphics, pos=None, fontsize=None):\n\t\tr\"\"\"\n\t\tAdd a graphics object as an inset.\n\n\t\tINPUT:\n\n\t\t- ``graphics`` -- the graphics object (instance of :class:`Graphics`)\n\t\t  to be added as an inset\n\n\t\t- ``pos`` -- (default: ``None``) 4-tuple\n\t\t  ``(left, bottom, width, height)`` specifying the location and\n\t\t  relative size of the inset on the canvas, all quantities being\n\t\t  expressed in fractions of the canvas width and height; if ``None``,\n\t\t  the value ``(0.7, 0.7, 0.2, 0.2)`` is used\n\n\t\t- ``fontsize`` -- (default: ``None``)  integer, font size (in points)\n\t\t  for the inset; if ``None``, the value of 6 points is used, unless\n\t\t  ``fontsize`` has been explicitly set in the construction of\n\t\t  ``graphics`` (in this case, it is not overwritten here)\n\n\t\tOUTPUT:\n\n\t\t- instance of :class:`~sage.plot.multigraphics.MultiGraphics`\n\n\t\tEXAMPLES:\n\n\t\tLet us consider a graphics array of 2 elements::\n\n\t\t\tsage: G = graphics_array([plot(sin, (0, 2*pi)),\n\t\t\t....:\t\t\t\t\t plot(cos, (0, 2*pi))])\n\t\t\tsage: G\n\t\t\tGraphics Array of size 1 x 2\n\n\t\t.. PLOT::\n\n\t\t\tG = graphics_array([plot(sin, (0, 2*pi)), plot(cos, (0, 2*pi))])\n\t\t\tsphinx_plot(G)\n\n\t\tand add some inset at the default position::\n\n\t\t\tsage: c = circle((0,0), 1, color='red', thickness=2, frame=True)\n\t\t\tsage: G.inset(c)\n\t\t\tMultigraphics with 3 elements\n\n\t\t.. PLOT::\n\n\t\t\tG = graphics_array([plot(sin, (0, 2*pi)), plot(cos, (0, 2*pi))])\n\t\t\tc = circle((0,0), 1, color='red', thickness=2, frame=True)\n\t\t\tsphinx_plot(G.inset(c))\n\n\t\tWe may customize the position and font size of the inset::\n\n\t\t\tsage: G.inset(c, pos=(0.3, 0.7, 0.2, 0.2), fontsize=8)\n\t\t\tMultigraphics with 3 elements\n\n\t\t.. PLOT::\n\n\t\t\tG = graphics_array([plot(sin, (0, 2*pi)), plot(cos, (0, 2*pi))])\n\t\t\tc = circle((0,0), 1, color='red', thickness=2, frame=True)\n\t\t\tsphinx_plot(G.inset(c, pos=(0.3, 0.7, 0.2, 0.2), fontsize=8))\n\n\t\t\"\"\"\n\t\tif pos is None:\n\t\t\tpos = (0.7, 0.7, 0.2, 0.2)\n\t\tif fontsize is not None:\n\t\t\tgraphics._extra_kwds['fontsize'] = fontsize\n\t\telif 'fontsize' not in graphics._extra_kwds:\n\t\t\tgraphics._extra_kwds['fontsize'] = 6\n\t\tcurrent = []  # list of current pairs (graphics, position)\n\t\tfor i, g in enumerate(self._glist):\n\t\t\tcurrent.append((g, self.position(i)))\n\t\tresu = MultiGraphics(current)\n\t\tresu.append(graphics, pos=pos)\n\t\treturn resu\n\n\t#\n\t# Methods to reimplement in derived classes:\n\t#\n\tdef __str__(self):\n\t\tr\"\"\"\n\t\tString representation of ``self``\n\n\t\tEXAMPLES::\n\n\t\t\tsage: from sage.plot.multigraphics import MultiGraphics\n\t\t\tsage: G = MultiGraphics([])\n\t\t\tsage: G.__str__()\n\t\t\t'Multigraphics with 0 element'\n\t\t\tsage: str(G)\n\t\t\t'Multigraphics with 0 element'\n\t\t\tsage: c = circle((0,0), 1)\n\t\t\tsage: G = MultiGraphics([c])\n\t\t\tsage: str(G)\n\t\t\t'Multigraphics with 1 element'\n\t\t\tsage: G = MultiGraphics([c, c, c])\n\t\t\tsage: str(G)\n\t\t\t'Multigraphics with 3 elements'\n\n\t\t\"\"\"\n\t\tn = len(self._glist)\n\t\tif n <= 1:\n\t\t\treturn \"Multigraphics with {} element\".format(n)\n\t\treturn \"Multigraphics with {} elements\".format(n)\n\n\tdef _add_subplot(self, figure, index, **options):\n\t\tr\"\"\"\n\t\tAdd a subplot to a given Matplotlib ``Figure``, the position of\n\t\twhich is governed by a given element of ``self``.\n\n\t\tThis method encapsulates the Matplotlib method ``Figure.add_axes``\n\t\tand is intended to be called by :meth:`MultiGraphics.save`.\n\n\t\tINPUT:\n\n\t\t- ``figure`` -- a Matplotlib ``Figure`` object\n\t\t- ``index`` -- integer specifiying the element of ``self``\n\t\t- ``options`` -- extra options to be passed to ``Figure.add_axes``\n\n\t\tOUTPUT:\n\n\t\t- a Matplotlib ``Axes`` object\n\n\t\tEXAMPLES::\n\n\t\t\tsage: g0 = circle((0,0), 1)\n\t\t\tsage: g1 = plot(sin)\n\t\t\tsage: G = multi_graphics([g0, (g1, (0.2, 0.3, 0.4, 0.1))])\n\t\t\tsage: from matplotlib.figure import Figure\n\t\t\tsage: fig = Figure()\n\t\t\tsage: fig\n\t\t\t\n\t\t\tsage: ax0 = G._add_subplot(fig, 0)\n\t\t\tsage: type(ax0)\n\t\t\t\n\t\t\tsage: fig\n\t\t\t\n\t\t\tsage: ax1 = G._add_subplot(fig, 1)\n\t\t\tsage: fig\n\t\t\t\n\n\t\tTESTS::\n\n\t\t\tsage: [ax0, ax1] == fig.get_axes()\n\t\t\tTrue\n\t\t\tsage: G.position(1)\n\t\t\t(0.2, 0.3, 0.4, 0.1)\n\t\t\tsage: ax1.get_position().bounds  # tol 1.0e-13\n\t\t\t(0.2, 0.3, 0.4000000000000001, 0.10000000000000003)\n\n\t\t\"\"\"\n\t\t# Note: using label=str(index) ensures that a new Axes is generated\n\t\t# for each element of ``self``, even if some elements share the same\n\t\t# positions\n\t\treturn figure.add_axes(self._positions[index], label=str(index),\n\t\t\t\t\t\t\t   **options)\n\n\tdef position(self, index):\n\t\tr\"\"\"\n\t\tReturn the position and relative size of an element of ``self`` on the\n\t\tcanvas.\n\n\t\tINPUT:\n\n\t\t- ``index`` -- integer specifiying which element of ``self``\n\n\t\tOUTPUT:\n\n\t\t- a 4-tuple ``(left, bottom, width, height)`` giving the location and\n\t\t  relative size of the element on the canvas, all quantities being\n\t\t  expressed in fractions of the canvas width and height\n\n\t\tEXAMPLES::\n\n\t\t\tsage: g1 = plot(sin(x^2), (x, 0, 4))\n\t\t\tsage: g2 = circle((0,0), 1, rgbcolor='red', fill=True, axes=False)\n\t\t\tsage: G = multi_graphics([g1, (g2, (0.15, 0.2, 0.1, 0.15))])\n\t\t\tsage: G.position(0)  # tol 1.0e-13\n\t\t\t(0.125, 0.11, 0.775, 0.77)\n\t\t\tsage: G.position(1)  # tol 1.0e-13\n\t\t\t(0.15, 0.2, 0.1, 0.15)\n\n\t\t\"\"\"\n\t\treturn self._positions[index]\n\n\tdef append(self, graphics, pos=None):\n\t\tr\"\"\"\n\t\tAppend a graphics object to ``self``.\n\n\t\tINPUT:\n\n\t\t- ``graphics`` -- the graphics object (instance of :class:`Graphics`)\n\t\t  to be added to ``self``\n\n\t\t- ``pos`` -- (default: ``None``) 4-tuple\n\t\t  ``(left, bottom, width, height)`` specifying the location and size\n\t\t  of ``graphics`` on the canvas, all quantities being in fractions of\n\t\t  the canvas width and height; if ``None``, ``graphics`` is assumed to\n\t\t  occupy the whole canvas, except for some padding; this corresponds to\n\t\t  the default position\n\t\t  ``(left, bottom, width, height) = (0.125, 0.11, 0.775, 0.77)``\n\n\t\tEXAMPLES:\n\n\t\tLet us consider a multigraphics with 2 elements::\n\n\t\t\tsage: g1 = plot(chebyshev_T(4, x), (x, -1, 1), title='n=4')\n\t\t\tsage: g2 = plot(chebyshev_T(8, x), (x, -1, 1), title='n=8',\n\t\t\t....:\t\t   color='red')\n\t\t\tsage: G = multi_graphics([(g1, (0.125, 0.2, 0.4, 0.4)),\n\t\t\t....:\t\t\t\t\t (g2, (0.55, 0.4, 0.4, 0.4))])\n\t\t\tsage: G\n\t\t\tMultigraphics with 2 elements\n\n\t\t.. PLOT::\n\n\t\t\tg1 = plot(chebyshev_T(4, x), (x, -1, 1), title='n=4')\n\t\t\tg2 = plot(chebyshev_T(8, x), (x, -1, 1), title='n=8', color='red')\n\t\t\tG = multi_graphics([(g1, (0.125, 0.2, 0.4, 0.4)), \\\n\t\t\t\t\t\t\t\t(g2, (0.55, 0.4, 0.4, 0.4))])\n\t\t\tsphinx_plot(G)\n\n\t\tWe append a third plot to it::\n\n\t\t\tsage: g3 = plot(chebyshev_T(16, x), (x, -1, 1), title='n=16',\n\t\t\t....:\t\t   color='brown')\n\t\t\tsage: G.append(g3, pos=(0.55, 0.11, 0.4, 0.15))\n\t\t\tsage: G\n\t\t\tMultigraphics with 3 elements\n\n\t\t.. PLOT::\n\n\t\t\tg1 = plot(chebyshev_T(4, x), (x, -1, 1), title='n=4')\n\t\t\tg2 = plot(chebyshev_T(8, x), (x, -1, 1), title='n=8', color='red')\n\t\t\tG = multi_graphics([(g1, (0.125, 0.2, 0.4, 0.4)), \\\n\t\t\t\t\t\t\t\t(g2, (0.55, 0.4, 0.4, 0.4))])\n\t\t\tg3 = plot(chebyshev_T(16, x), (x, -1, 1), title='n=16', \\\n\t\t\t\t\t  color='brown')\n\t\t\tG.append(g3, pos=(0.55, 0.11, 0.4, 0.15))\n\t\t\tsphinx_plot(G)\n\n\t\tWe may use ``append`` to add a title::\n\n\t\t\tsage: title = text(\"Chebyshev polynomials\", (0, 0), fontsize=16,\n\t\t\t....:\t\t\t  axes=False)\n\t\t\tsage: G.append(title, pos=(0.18, 0.8, 0.7, 0.1))\n\t\t\tsage: G\n\t\t\tMultigraphics with 4 elements\n\n\t\t.. PLOT::\n\n\t\t\tg1 = plot(chebyshev_T(4, x), (x, -1, 1), title='n=4')\n\t\t\tg2 = plot(chebyshev_T(8, x), (x, -1, 1), title='n=8', color='red')\n\t\t\tG = multi_graphics([(g1, (0.125, 0.2, 0.4, 0.4)), \\\n\t\t\t\t\t\t\t\t(g2, (0.55, 0.4, 0.4, 0.4))])\n\t\t\tg3 = plot(chebyshev_T(16, x), (x, -1, 1), title='n=16', \\\n\t\t\t\t\t  color='brown')\n\t\t\tG.append(g3, pos=(0.55, 0.11, 0.4, 0.15))\n\t\t\ttitle = text(\"Chebyshev polynomials\", (0, 0), fontsize=16, \\\n\t\t\t\t\t\t axes=False)\n\t\t\tG.append(title, pos=(0.18, 0.8, 0.7, 0.1))\n\t\t\tsphinx_plot(G)\n\n\t\t.. SEEALSO::\n\n\t\t\t:meth:`inset`\n\n\t\t\"\"\"\n\t\tfrom matplotlib import rcParams\n\t\tif not isinstance(graphics, Graphics):\n\t\t\traise TypeError(\"a Graphics object is expected, \"\n\t\t\t\t\t\t\t\"not {}\".format(graphics))\n\t\tif pos is None:\n\t\t\t# Default position:\n\t\t\tleft = rcParams['figure.subplot.left']\n\t\t\tbottom = rcParams['figure.subplot.bottom']\n\t\t\twidth = rcParams['figure.subplot.right'] - left\n\t\t\theight = rcParams['figure.subplot.top'] - bottom\n\t\t\tpos = (left, bottom, width, height)\n\t\telif not isinstance(pos, (list, tuple)) or len(pos) != 4:\n\t\t\traise TypeError(\"pos must be a 4-tuple, not {}\".format(pos))\n\t\tpos = tuple(float(p) for p in pos)\n\t\tself._glist.append(graphics)\n\t\tself._positions.append(pos)\n\n", "description": "\n\tBase class for objects composed of :class:`~sage.plot.graphics.Graphics`\n\tobjects.\n\n\tBoth the display and the output to a file of ``MultiGraphics`` objects\n\tare governed by the method :meth:`save`, which is called by the rich output\n\tdisplay manager, via\n\t:meth:`~sage.repl.rich_output.display_manager.DisplayManager.graphics_from_save`.\n\n\tThe user interface is through the functions\n\t:func:`~sage.plot.plot.multi_graphics` (generic multi-graphics) and\n\t:func:`~sage.plot.plot.graphics_array` (subclass :class:`GraphicsArray`).\n\n\tINPUT:\n\n\t- ``graphics_list`` -- a list of graphics along with their positions on the\n\t  common canvas; each element of ``graphics_list`` is either\n\n\t  - a pair ``(graphics, position)``, where ``graphics`` is a\n\t\t:class:`~sage.plot.graphics.Graphics` object and ``position`` is the\n\t\t4-tuple ``(left, bottom, width, height)`` specifying the location and\n\t\tsize of the graphics on the canvas, all quantities being in fractions\n\t\tof the canvas width and height\n\n\t  - or a single :class:`~sage.plot.graphics.Graphics` object; its position\n\t\tis then assumed to occupy the whole canvas, except for some padding;\n\t\tthis corresponds to the default position\n\t\t``(left, bottom, width, height) = (0.125, 0.11, 0.775, 0.77)``\n\n\tEXAMPLES:\n\n\tA multi-graphics made from two graphics objects::\n\n\t\tsage: g1 = plot(sin(x^3), (x, -pi, pi))\n\t\tsage: g2 = circle((0,0), 1, color='red')\n\t\tsage: G = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tsage: G\n\t\tMultigraphics with 2 elements\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**3), (x, -pi, pi))\n\t\tg2 = circle((0,0), 1, color='red')\n\t\tG = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tsphinx_plot(G)\n\n\tSince no position was given for ``g1``, it occupies the whole canvas.\n\tMoreover, we note that ``g2`` has been drawn over ``g1`` with a white\n\tbackground. To have a transparent background instead, one has to construct\n\t``g2`` with the keyword ``transparent`` set to ``True``::\n\n\t\tsage: g2 = circle((0,0), 1, color='red', transparent=True)\n\t\tsage: G = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tsage: G\n\t\tMultigraphics with 2 elements\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**3), (x, -pi, pi))\n\t\tg2 = circle((0,0), 1, color='red', transparent=True)\n\t\tG = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tsphinx_plot(G)\n\n\tWe can add a new graphics object to G via the method :meth:`append`::\n\n\t\tsage: g3 = complex_plot(zeta, (-20, 10), (-20, 20),\n\t\t....:\t\t\t\t   axes_labels=['$x$', '$y$'], frame=True)\n\t\tsage: G.append(g3, pos=(0.63, 0.12, 0.3, 0.3))\n\t\tsage: G\n\t\tMultigraphics with 3 elements\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**3), (x, -pi, pi))\n\t\tg2 = circle((0,0), 1, color='red', transparent=True)\n\t\tG = multi_graphics([g1, (g2, (0.2, 0.55, 0.3, 0.3))])\n\t\tg3 = complex_plot(zeta, (-20, 10), (-20, 20), \\\n\t\t\t\t\t\t  axes_labels=['$x$', '$y$'], frame=True)\n\t\tG.append(g3, pos=(0.63, 0.12, 0.3, 0.3))\n\t\tsphinx_plot(G)\n\n\tWe can access the individual elements composing ``G`` with the\n\tsquare-bracket operator::\n\n\t\tsage: print(G[0])\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: G[0] is g1\n\t\tTrue\n\t\tsage: G[1] is g2\n\t\tTrue\n\t\tsage: G[2] is g3\n\t\tTrue\n\n\t``G[:]`` returns the full list of graphics objects composing ``G``::\n\n\t\tsage: G[:]\n\t\t[Graphics object consisting of 1 graphics primitive,\n\t\t Graphics object consisting of 1 graphics primitive,\n\t\t Graphics object consisting of 1 graphics primitive]\n\t\tsage: len(G)\n\t\t3\n\n\t", "category": "graphics", "imports": ["import os", "from sage.misc.fast_methods import WithEqualityById", "from sage.structure.sage_object import SageObject", "from sage.misc.temporary_file import tmp_filename", "from .graphics import Graphics, ALLOWED_EXTENSIONS, _parse_figsize", "\t\t\tsage: from sage.plot.multigraphics import MultiGraphics", "\t\t\tsage: from sage.repl.rich_output import get_display_manager", "\t\t\tsage: import matplotlib.pyplot as plt", "\t\t\tsage: from matplotlib.figure import Figure", "\t\tfrom matplotlib.figure import Figure", "\t\tfrom matplotlib import rcParams", "\t\t\t\tfrom sage.misc.sage_ostools import have_program", "\t\t\t\tfrom matplotlib.backends.backend_pgf import FigureCanvasPgf", "\t\t\t\tfrom matplotlib.backends.backend_agg import FigureCanvasAgg", "\t\tfrom sage.repl.rich_output import get_display_manager", "\t\t\tsage: from sage.plot.multigraphics import MultiGraphics", "\t\t\tsage: from matplotlib.figure import Figure", "\t\tfrom matplotlib import rcParams", "\t\t\tsage: from sage.plot.multigraphics import GraphicsArray", "\t\t\tsage: from matplotlib.figure import Figure", "\t\t\tsage: from sage.plot.multigraphics import GraphicsArray", "\t\t\tfrom matplotlib.backends.backend_agg import FigureCanvasAgg"]}, {"term": "class", "name": "GraphicsArray", "data": "class GraphicsArray(MultiGraphics):\n\tr\"\"\"\n\tThis class implements 2-dimensional graphical objects that constitute\n\tan array of :class:`~sage.plot.graphics.Graphics` drawn on a single\n\tcanvas.\n\n\tThe user interface is through the function\n\t:func:`~sage.plot.plot.graphics_array`.\n\n\tINPUT:\n\n\t- ``array`` -- either a list of lists of\n\t  :class:`~sage.plot.graphics.Graphics` elements (generic case) or a\n\t  single list of :class:`~sage.plot.graphics.Graphics` elements (case of a\n\t  single-row array)\n\n\tEXAMPLES:\n\n\tAn array made of four graphics objects::\n\n\t\tsage: g1 = plot(sin(x^2), (x, 0, 6), axes_labels=['$x$', '$y$'],\n\t\t....:\t\t   axes=False, frame=True, gridlines='minor')\n\t\tsage: y = var('y')\n\t\tsage: g2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3),\n\t\t....:\t\t\t\t\t  aspect_ratio=1)\n\t\tsage: g3 = graphs.DodecahedralGraph().plot()\n\t\tsage: g4 = polar_plot(sin(5*x)^2, (x, 0, 2*pi), color='green',\n\t\t....:\t\t\t\t fontsize=8) \\\n\t\t....:\t  + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1,\n\t\t....:\t\t\t   legend_label='pink')\n\t\tsage: g4.set_legend_options(loc='upper right')\n\t\tsage: G = graphics_array([[g1, g2], [g3, g4]])\n\t\tsage: G\n\t\tGraphics Array of size 2 x 2\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**2), (x, 0, 6), axes_labels=['$x$', '$y$'], \\\n\t\t\t\t  axes=False, frame=True, gridlines='minor')\n\t\ty = var('y')\n\t\tg2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3), \\\n\t\t\t\t\t\t\t aspect_ratio=1)\n\t\tg3 = graphs.DodecahedralGraph().plot()\n\t\tg4 = polar_plot(sin(5*x)**2, (x, 0, 2*pi), color='green', fontsize=8) \\\n\t\t\t + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1, \\\n\t\t\t\t\t  legend_label='pink')\n\t\tg4.set_legend_options(loc='upper right')\n\t\tG = graphics_array([[g1, g2], [g3, g4]])\n\t\tsphinx_plot(G)\n\n\tIf one constructs the graphics array from a single list of graphics\n\tobjects, one obtains a single-row array::\n\n\t\tsage: G = graphics_array([g1, g2, g3, g4])\n\t\tsage: G\n\t\tGraphics Array of size 1 x 4\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**2), (x, 0, 6), axes_labels=['$x$', '$y$'], \\\n\t\t\t\t  axes=False, frame=True, gridlines='minor')\n\t\ty = var('y')\n\t\tg2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3), \\\n\t\t\t\t\t\t\t aspect_ratio=1)\n\t\tg3 = graphs.DodecahedralGraph().plot()\n\t\tg4 = polar_plot(sin(5*x)**2, (x, 0, 2*pi), color='green', fontsize=8) \\\n\t\t\t + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1, \\\n\t\t\t\t\t  legend_label='pink')\n\t\tg4.set_legend_options(loc='upper right')\n\t\tG = graphics_array([g1, g2, g3, g4])\n\t\tsphinx_plot(G)\n\n\tWe note that the overall aspect ratio of the figure is 4/3 (the default),\n\twhich makes ``g1`` elongated, while the aspect ratio of ``g2``, which has\n\tbeen specified with the parameter ``aspect_ratio=1`` is preserved. To get\n\ta better aspect ratio for the whole figure, one can use the option\n\t``figsize`` in the method :meth:`~MultiGraphics.show`::\n\n\t\tsage: G.show(figsize=[8, 3])\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**2), (x, 0, 6), axes_labels=['$x$', '$y$'], \\\n\t\t\t\t  axes=False, frame=True, gridlines='minor')\n\t\ty = var('y')\n\t\tg2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3), \\\n\t\t\t\t\t\t\t aspect_ratio=1)\n\t\tg3 = graphs.DodecahedralGraph().plot()\n\t\tg4 = polar_plot(sin(5*x)**2, (x, 0, 2*pi), color='green', fontsize=8) \\\n\t\t\t + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1, \\\n\t\t\t\t\t  legend_label='pink')\n\t\tg4.set_legend_options(loc='upper right')\n\t\tG = graphics_array([g1, g2, g3, g4])\n\t\tsphinx_plot(G, figsize=[8, 3])\n\n\tWe can access individual elements of the graphics array with the\n\tsquare-bracket operator::\n\n\t\tsage: G = graphics_array([[g1, g2], [g3, g4]])  # back to the 2x2 array\n\t\tsage: print(G)\n\t\tGraphics Array of size 2 x 2\n\t\tsage: G[0] is g1\n\t\tTrue\n\t\tsage: G[1] is g2\n\t\tTrue\n\t\tsage: G[2] is g3\n\t\tTrue\n\t\tsage: G[3] is g4\n\t\tTrue\n\n\tNote that with respect to the square-bracket operator, ``G`` is considered\n\tas a flattened list of graphics objects, not as an array. For instance,\n\t``G[0, 1]`` throws an error::\n\n\t\tsage: G[0, 1]  # py3 (error message is slightly different with Python 2)\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tTypeError: list indices must be integers or slices, not tuple\n\n\t``G[:]`` returns the full (flattened) list of graphics objects composing\n\t``G``::\n\n\t\tsage: G[:]\n\t\t[Graphics object consisting of 1 graphics primitive,\n\t\tGraphics object consisting of 1 graphics primitive,\n\t\tGraphics object consisting of 51 graphics primitives,\n\t\tGraphics object consisting of 2 graphics primitives]\n\n\tThe total number of Graphics objects composing the array is returned\n\tby the function ``len``::\n\n\t\tsage: len(G)\n\t\t4\n\n\tThe square-bracket operator can be used to replace elements in the array::\n\n\t\tsage: G[0] = g4\n\t\tsage: G\n\t\tGraphics Array of size 2 x 2\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**2), (x, 0, 6), axes_labels=['$x$', '$y$'], \\\n\t\t\t\t  axes=False, frame=True, gridlines='minor')\n\t\ty = var('y')\n\t\tg2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3), \\\n\t\t\t\t\t\t\t aspect_ratio=1)\n\t\tg3 = graphs.DodecahedralGraph().plot()\n\t\tg4 = polar_plot(sin(5*x)**2, (x, 0, 2*pi), color='green', fontsize=8) \\\n\t\t\t + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1, \\\n\t\t\t\t\t  legend_label='pink')\n\t\tg4.set_legend_options(loc='upper right')\n\t\tG = graphics_array([[g1, g2], [g3, g4]])\n\t\tG[0] = g4\n\t\tsphinx_plot(G)\n\n\t\"\"\"\n\tdef __init__(self, array):\n\t\tr\"\"\"\n\t\tConstruct a ``GraphicsArray``.\n\n\t\tTESTS::\n\n\t\t\tsage: from sage.plot.multigraphics import GraphicsArray\n\t\t\tsage: g = circle((0,0), 1)  # a Graphics object\n\t\t\tsage: G = GraphicsArray([[g, g], [g, g]])\n\t\t\tsage: print(G)\n\t\t\tGraphics Array of size 2 x 2\n\n\t\tConstruction from a single list ==> 1-row array::\n\n\t\t\tsage: G = GraphicsArray([g, g, g])\n\t\t\tsage: print(G)\n\t\t\tGraphics Array of size 1 x 3\n\t\t\tsage: G = GraphicsArray([g])\n\t\t\tsage: print(G)\n\t\t\tGraphics Array of size 1 x 1\n\n\t\tEmpty array::\n\n\t\t\tsage: G = GraphicsArray([])\n\t\t\tsage: print(G)\n\t\t\tGraphics Array of size 0 x 0\n\t\t\tsage: len(G)\n\t\t\t0\n\t\t\tsage: G = GraphicsArray([[]])\n\t\t\tsage: print(G)\n\t\t\tGraphics Array of size 1 x 0\n\t\t\tsage: len(G)\n\t\t\t0\n\n\t\tCheck treatment of wrong inputs::\n\n\t\t\tsage: G = GraphicsArray([[g, g], [g]])\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tTypeError: array must be a list of equal-size lists of Graphics\n\t\t\t objects, not [[Graphics object consisting of 1 graphics primitive,\n\t\t\t Graphics object consisting of 1 graphics primitive],\n\t\t\t [Graphics object consisting of 1 graphics primitive]]\n\t\t\tsage: G = GraphicsArray(g)\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tTypeError: array must be a list of lists of Graphics objects, not\n\t\t\t Graphics object consisting of 1 graphics primitive\n\t\t\tsage: G = GraphicsArray([g, x])\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tTypeError: every element of array must be a Graphics object\n\n\t\t\"\"\"\n\t\tMultiGraphics.__init__(self, [])\n\t\tif not isinstance(array, (list, tuple)):\n\t\t\traise TypeError(\"array must be a list of lists of Graphics \"\n\t\t\t\t\t\t\t\"objects, not {}\".format(array))\n\t\tarray = list(array)\n\t\tself._rows = len(array)\n\t\tif self._rows > 0:\n\t\t\tif not isinstance(array[0], (list, tuple)):\n\t\t\t\tarray = [array]\n\t\t\t\tself._rows = 1\n\t\t\tself._cols = len(array[0])\n\t\telse:\n\t\t\tself._cols = 0\n\t\tfor row in array:  # basically flatten the list\n\t\t\tif not isinstance(row, (list, tuple)) or len(row) != self._cols:\n\t\t\t\traise TypeError(\"array must be a list of equal-size lists of \"\n\t\t\t\t\t\t\t\t\"Graphics objects, not {}\".format(array))\n\t\t\tfor g in row:\n\t\t\t\tif not isinstance(g, Graphics):\n\t\t\t\t\traise TypeError(\"every element of array must be a \"\n\t\t\t\t\t\t\t\t\t\"Graphics object\")\n\t\t\t\tself._glist.append(g)\n\t\t# self._positions is not initialized since most of the time, it is not\n\t\t# not used. It is required only by the method inset(); it is then\n\t\t# initialized by the method position().\n\n\tdef __str__(self):\n\t\tr\"\"\"\n\t\tString representation of the graphics array.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: c = circle((0,0), 1)\n\t\t\tsage: G = graphics_array([c]*6, 2, 3)\n\t\t\tsage: G.__str__()\n\t\t\t'Graphics Array of size 2 x 3'\n\t\t\tsage: str(G)\n\t\t\t'Graphics Array of size 2 x 3'\n\n\t\t\"\"\"\n\t\treturn \"Graphics Array of size {} x {}\".format(self._rows, self._cols)\n\n\tdef _add_subplot(self, figure, index, **options):\n\t\tr\"\"\"\n\t\tAdd a subplot to a given Matplotlib ``Figure``, the position of\n\t\twhich is governed by a given element of ``self``.\n\n\t\tThis method encapsulates the Matplotlib method ``Figure.add_subplot``\n\t\tand is intended to be called by :meth:`MultiGraphics.save`.\n\n\t\tINPUT:\n\n\t\t- ``figure`` -- a Matplotlib ``Figure`` object\n\t\t- ``index`` -- integer specifiying the element of ``self``\n\t\t- ``options`` -- extra options to be passed to ``Figure.add_subplot``\n\n\t\tOUTPUT:\n\n\t\t- a Matplotlib ``Axes`` object\n\n\t\tEXAMPLES::\n\n\t\t\tsage: c = circle((0,0), 1)\n\t\t\tsage: G = graphics_array([c, c])\n\t\t\tsage: from matplotlib.figure import Figure\n\t\t\tsage: fig = Figure()\n\t\t\tsage: ax1 = G._add_subplot(fig, 0)\n\t\t\tsage: type(ax1)\n\t\t\t\n\t\t\tsage: ax2 = G._add_subplot(fig, 1)\n\t\t\tsage: fig.get_axes() == [ax1, ax2]\n\t\t\tTrue\n\n\t\t\"\"\"\n\t\tif self._rows == 0 or self._cols == 0:\n\t\t\trows = 1\n\t\t\tcols = 1\n\t\telse:\n\t\t\trows = self._rows\n\t\t\tcols = self._cols\n\t\t# index --> index + 1 for Figure.add_subplot:\n\t\treturn figure.add_subplot(rows, cols, index + 1, **options)\n\n\tdef nrows(self):\n\t\tr\"\"\"\n\t\tNumber of rows of the graphics array.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: R = rainbow(6)\n\t\t\tsage: L = [plot(x^n, (x,0,1), color=R[n]) for n in range(6)]\n\t\t\tsage: G = graphics_array(L, 2, 3)\n\t\t\tsage: G.nrows()\n\t\t\t2\n\t\t\tsage: graphics_array(L).nrows()\n\t\t\t1\n\n\t\t\"\"\"\n\t\treturn self._rows\n\n\tdef ncols(self):\n\t\tr\"\"\"\n\t\tNumber of columns of the graphics array.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: R = rainbow(6)\n\t\t\tsage: L = [plot(x^n, (x,0,1), color=R[n]) for n in range(6)]\n\t\t\tsage: G = graphics_array(L, 2, 3)\n\t\t\tsage: G.ncols()\n\t\t\t3\n\t\t\tsage: graphics_array(L).ncols()\n\t\t\t6\n\t\t\"\"\"\n\t\treturn self._cols\n\n\tdef append(self, g):\n\t\tr\"\"\"\n\t\tAppend a graphics to the array.\n\n\t\tCurrently not implemented.\n\n\t\tTESTS::\n\n\t\t\tsage: from sage.plot.multigraphics import GraphicsArray\n\t\t\tsage: c = circle((0,0), 1)\n\t\t\tsage: G = GraphicsArray([c, c])\n\t\t\tsage: G.append(c)\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tNotImplementedError: Appending to a graphics array is not yet\n\t\t\t implemented\n\n\t\t\"\"\"\n\t\t# Not clear if there is a way to do this\n\t\traise NotImplementedError('Appending to a graphics array is not '\n\t\t\t\t\t\t\t\t  'yet implemented')\n\n\tdef position(self, index):\n\t\tr\"\"\"\n\t\tReturn the position and relative size of an element of ``self`` on the\n\t\tcanvas.\n\n\t\tINPUT:\n\n\t\t- ``index`` -- integer specifiying which element of ``self``\n\n\t\tOUTPUT:\n\n\t\t- a 4-tuple ``(left, bottom, width, height)`` giving the location and\n\t\t  relative size of the element on the canvas, all quantities being\n\t\t  expressed in fractions of the canvas width and height\n\n\t\tEXAMPLES::\n\n\t\t\tsage: g1 = plot(sin(x), (x, -pi, pi))\n\t\t\tsage: g2 = circle((0,1), 1.)\n\t\t\tsage: G = graphics_array([g1, g2])\n\t\t\tsage: G.position(0)  # tol 5.0e-3\n\t\t\t(0.025045451349937315,\n\t\t\t 0.03415488992713045,\n\t\t\t 0.4489880779745068,\n\t\t\t 0.9345951100728696)\n\t\t\tsage: G.position(1)  # tol 5.0e-3\n\t\t\t(0.5170637412999687,\n\t\t\t 0.20212705964722733,\n\t\t\t 0.4489880779745068,\n\t\t\t 0.5986507706326758)\n\n\t\t\"\"\"\n\t\tif not self._positions:\n\t\t\t# self._positions must be generated, by invoking get_position() on\n\t\t\t# each of the Axes of the Matplotlib figure corresponding to self:\n\t\t\tfrom matplotlib.backends.backend_agg import FigureCanvasAgg\n\t\t\tfigure = self.matplotlib()\n\t\t\tfigure.set_canvas(FigureCanvasAgg(figure))\n\t\t\tfigure.tight_layout()\n\t\t\taxes = figure.get_axes()\n\t\t\tself._positions = [ax.get_position().bounds for ax in axes]\n\t\treturn self._positions[index]\n", "description": "\n\tThis class implements 2-dimensional graphical objects that constitute\n\tan array of :class:`~sage.plot.graphics.Graphics` drawn on a single\n\tcanvas.\n\n\tThe user interface is through the function\n\t:func:`~sage.plot.plot.graphics_array`.\n\n\tINPUT:\n\n\t- ``array`` -- either a list of lists of\n\t  :class:`~sage.plot.graphics.Graphics` elements (generic case) or a\n\t  single list of :class:`~sage.plot.graphics.Graphics` elements (case of a\n\t  single-row array)\n\n\tEXAMPLES:\n\n\tAn array made of four graphics objects::\n\n\t\tsage: g1 = plot(sin(x^2), (x, 0, 6), axes_labels=['$x$', '$y$'],\n\t\t....:\t\t   axes=False, frame=True, gridlines='minor')\n\t\tsage: y = var('y')\n\t\tsage: g2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3),\n\t\t....:\t\t\t\t\t  aspect_ratio=1)\n\t\tsage: g3 = graphs.DodecahedralGraph().plot()\n\t\tsage: g4 = polar_plot(sin(5*x)^2, (x, 0, 2*pi), color='green',\n\t\t....:\t\t\t\t fontsize=8) \\\n\t\t....:\t  + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1,\n\t\t....:\t\t\t   legend_label='pink')\n\t\tsage: g4.set_legend_options(loc='upper right')\n\t\tsage: G = graphics_array([[g1, g2], [g3, g4]])\n\t\tsage: G\n\t\tGraphics Array of size 2 x 2\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**2), (x, 0, 6), axes_labels=['$x$', '$y$'], \\\n\t\t\t\t  axes=False, frame=True, gridlines='minor')\n\t\ty = var('y')\n\t\tg2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3), \\\n\t\t\t\t\t\t\t aspect_ratio=1)\n\t\tg3 = graphs.DodecahedralGraph().plot()\n\t\tg4 = polar_plot(sin(5*x)**2, (x, 0, 2*pi), color='green', fontsize=8) \\\n\t\t\t + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1, \\\n\t\t\t\t\t  legend_label='pink')\n\t\tg4.set_legend_options(loc='upper right')\n\t\tG = graphics_array([[g1, g2], [g3, g4]])\n\t\tsphinx_plot(G)\n\n\tIf one constructs the graphics array from a single list of graphics\n\tobjects, one obtains a single-row array::\n\n\t\tsage: G = graphics_array([g1, g2, g3, g4])\n\t\tsage: G\n\t\tGraphics Array of size 1 x 4\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**2), (x, 0, 6), axes_labels=['$x$', '$y$'], \\\n\t\t\t\t  axes=False, frame=True, gridlines='minor')\n\t\ty = var('y')\n\t\tg2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3), \\\n\t\t\t\t\t\t\t aspect_ratio=1)\n\t\tg3 = graphs.DodecahedralGraph().plot()\n\t\tg4 = polar_plot(sin(5*x)**2, (x, 0, 2*pi), color='green', fontsize=8) \\\n\t\t\t + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1, \\\n\t\t\t\t\t  legend_label='pink')\n\t\tg4.set_legend_options(loc='upper right')\n\t\tG = graphics_array([g1, g2, g3, g4])\n\t\tsphinx_plot(G)\n\n\tWe note that the overall aspect ratio of the figure is 4/3 (the default),\n\twhich makes ``g1`` elongated, while the aspect ratio of ``g2``, which has\n\tbeen specified with the parameter ``aspect_ratio=1`` is preserved. To get\n\ta better aspect ratio for the whole figure, one can use the option\n\t``figsize`` in the method :meth:`~MultiGraphics.show`::\n\n\t\tsage: G.show(figsize=[8, 3])\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**2), (x, 0, 6), axes_labels=['$x$', '$y$'], \\\n\t\t\t\t  axes=False, frame=True, gridlines='minor')\n\t\ty = var('y')\n\t\tg2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3), \\\n\t\t\t\t\t\t\t aspect_ratio=1)\n\t\tg3 = graphs.DodecahedralGraph().plot()\n\t\tg4 = polar_plot(sin(5*x)**2, (x, 0, 2*pi), color='green', fontsize=8) \\\n\t\t\t + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1, \\\n\t\t\t\t\t  legend_label='pink')\n\t\tg4.set_legend_options(loc='upper right')\n\t\tG = graphics_array([g1, g2, g3, g4])\n\t\tsphinx_plot(G, figsize=[8, 3])\n\n\tWe can access individual elements of the graphics array with the\n\tsquare-bracket operator::\n\n\t\tsage: G = graphics_array([[g1, g2], [g3, g4]])  # back to the 2x2 array\n\t\tsage: print(G)\n\t\tGraphics Array of size 2 x 2\n\t\tsage: G[0] is g1\n\t\tTrue\n\t\tsage: G[1] is g2\n\t\tTrue\n\t\tsage: G[2] is g3\n\t\tTrue\n\t\tsage: G[3] is g4\n\t\tTrue\n\n\tNote that with respect to the square-bracket operator, ``G`` is considered\n\tas a flattened list of graphics objects, not as an array. For instance,\n\t``G[0, 1]`` throws an error::\n\n\t\tsage: G[0, 1]  # py3 (error message is slightly different with Python 2)\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tTypeError: list indices must be integers or slices, not tuple\n\n\t``G[:]`` returns the full (flattened) list of graphics objects composing\n\t``G``::\n\n\t\tsage: G[:]\n\t\t[Graphics object consisting of 1 graphics primitive,\n\t\tGraphics object consisting of 1 graphics primitive,\n\t\tGraphics object consisting of 51 graphics primitives,\n\t\tGraphics object consisting of 2 graphics primitives]\n\n\tThe total number of Graphics objects composing the array is returned\n\tby the function ``len``::\n\n\t\tsage: len(G)\n\t\t4\n\n\tThe square-bracket operator can be used to replace elements in the array::\n\n\t\tsage: G[0] = g4\n\t\tsage: G\n\t\tGraphics Array of size 2 x 2\n\n\t.. PLOT::\n\n\t\tg1 = plot(sin(x**2), (x, 0, 6), axes_labels=['$x$', '$y$'], \\\n\t\t\t\t  axes=False, frame=True, gridlines='minor')\n\t\ty = var('y')\n\t\tg2 = streamline_plot((sin(x), cos(y)), (x,-3,3), (y,-3,3), \\\n\t\t\t\t\t\t\t aspect_ratio=1)\n\t\tg3 = graphs.DodecahedralGraph().plot()\n\t\tg4 = polar_plot(sin(5*x)**2, (x, 0, 2*pi), color='green', fontsize=8) \\\n\t\t\t + circle((0,0), 0.5, rgbcolor='red', fill=True, alpha=0.1, \\\n\t\t\t\t\t  legend_label='pink')\n\t\tg4.set_legend_options(loc='upper right')\n\t\tG = graphics_array([[g1, g2], [g3, g4]])\n\t\tG[0] = g4\n\t\tsphinx_plot(G)\n\n\t", "category": "graphics", "imports": ["import os", "from sage.misc.fast_methods import WithEqualityById", "from sage.structure.sage_object import SageObject", "from sage.misc.temporary_file import tmp_filename", "from .graphics import Graphics, ALLOWED_EXTENSIONS, _parse_figsize", "\t\t\tsage: from sage.plot.multigraphics import MultiGraphics", "\t\t\tsage: from sage.repl.rich_output import get_display_manager", "\t\t\tsage: import matplotlib.pyplot as plt", "\t\t\tsage: from matplotlib.figure import Figure", "\t\tfrom matplotlib.figure import Figure", "\t\tfrom matplotlib import rcParams", "\t\t\t\tfrom sage.misc.sage_ostools import have_program", "\t\t\t\tfrom matplotlib.backends.backend_pgf import FigureCanvasPgf", "\t\t\t\tfrom matplotlib.backends.backend_agg import FigureCanvasAgg", "\t\tfrom sage.repl.rich_output import get_display_manager", "\t\t\tsage: from sage.plot.multigraphics import MultiGraphics", "\t\t\tsage: from matplotlib.figure import Figure", "\t\tfrom matplotlib import rcParams", "\t\t\tsage: from sage.plot.multigraphics import GraphicsArray", "\t\t\tsage: from matplotlib.figure import Figure", "\t\t\tsage: from sage.plot.multigraphics import GraphicsArray", "\t\t\tfrom matplotlib.backends.backend_agg import FigureCanvasAgg"]}], [{"term": "def", "name": "ir", "data": "def ir(x, i = int, r = round):\n\treturn i(r(x))\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "irr", "data": "def irr(rect, ir = ir):\n\tl, t, r, b = rect\n\treturn (ir(l), ir(t), ir(r), ir(b))\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "class", "name": "GState", "data": "class GState(object):\n\n\tpencolor = black\n\tfillcolor = black\n\ttextcolor = black\n\tbackcolor = white\n\tpensize = 1\n\tfont = application_font\n\t\n\twin_pen = gdip.Pen(pencolor._win_argb, 1)\n\twin_fill_brush = gdip.SolidBrush(fillcolor._win_argb)\n\twin_text_brush = gdip.SolidBrush(textcolor._win_argb)\n\twin_bg_brush = gdip.SolidBrush(backcolor._win_argb)\n\t\n\tdef __init__(self, clone = None):\n\t\tif clone:\n\t\t\tself.__dict__.update(clone.__dict__)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "class", "name": "Canvas", "data": "class Canvas(GCanvas):\n\n\t_current_point = None\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "f__init__", "data": "\tdef __init__(self, win_graphics, for_printing = False):\n\t\tself._win_graphics = win_graphics\n\t\tself._win_path = gdip.GraphicsPath()\n\t\tself._state = GState()\n\t\tself._stack = []\n\t\tif for_printing:\n\t\t\tunit = gdip.UnitPoint\n\t\t\twin_graphics.SetPageUnit(unit)\n\t\t#else:\n\t\t#\tunit = gdip.UnitPixel\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "f_from_win_dc", "data": "\tdef _from_win_dc(cls, dc):\n\t\treturn cls._from_win_hdc(dc.GetSafeHdc())\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "f_from_win_hdc", "data": "\tdef _from_win_hdc(cls, hdc, **kwds):\n\t\twin_graphics = gdip.Graphics.from_hdc(hdc)\n\t\treturn cls(win_graphics, **kwds)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "f_from_win_image", "data": "\tdef _from_win_image(cls, win_image):\n\t\twin_graphics = gdip.Graphics.from_image(win_image)\n\t\t#print \"Canvas._from_win_image: win_graphics =\", win_graphics ###\n\t\t#print \"... clip bounds =\", win_graphics.GetClipBounds() ###\n\t\treturn cls(win_graphics)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fget_pencolor", "data": "\tdef get_pencolor(self):\n\t\treturn self._state.pencolor\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fset_pencolor", "data": "\tdef set_pencolor(self, c):\n\t\tstate = self._state\n\t\tstate.pencolor = c\n\t\tstate.win_pen = gdip.Pen(c._win_argb, state.pensize)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fget_fillcolor", "data": "\tdef get_fillcolor(self):\n\t\treturn self._state.fillcolor\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fset_fillcolor", "data": "\tdef set_fillcolor(self, c):\n\t\tstate = self._state\n\t\tstate.fillcolor = c\n\t\tstate.win_fill_brush = gdip.SolidBrush(c._win_argb)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fget_textcolor", "data": "\tdef get_textcolor(self):\n\t\treturn self._state.textcolor\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fset_textcolor", "data": "\tdef set_textcolor(self, c):\n\t\tstate = self._state\n\t\tstate.textcolor = c\n\t\tstate.win_text_brush = gdip.SolidBrush(c._win_argb)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fget_backcolor", "data": "\tdef get_backcolor(self):\n\t\treturn self._state.backcolor\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fset_backcolor", "data": "\tdef set_backcolor(self, c):\n\t\tstate = self._state\n\t\tstate.backcolor = c\n\t\tstate.win_bg_brush = gdip.SolidBrush(c._win_argb)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fget_pensize", "data": "\tdef get_pensize(self):\n\t\treturn self._state.pensize\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fset_pensize", "data": "\tdef set_pensize(self, x):\n\t\tstate = self._state\n\t\tstate.pensize = x\n\t\tstate.win_pen = gdip.Pen(state.pencolor._win_argb, x)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fget_current_point", "data": "\tdef get_current_point(self):\n\t\treturn self._current_point\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fget_font", "data": "\tdef get_font(self):\n\t\treturn self._state.font\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fset_font", "data": "\tdef set_font(self, f):\n\t\tself._state.font = f\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fnewpath", "data": "\tdef newpath(self):\n\t\tself._win_path.Reset()\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fmoveto", "data": "\tdef moveto(self, x, y):\n\t\tp = (x, y)\n\t\tself._current_point = p\n\t\tself._win_path.StartFigure()\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "flineto", "data": "\tdef lineto(self, x, y):\n\t\tx0, y0 = self._current_point\n\t\tself._win_path.AddLine_4f(x0, y0, x, y)\n\t\tself._current_point = (x, y)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fcurveto", "data": "\tdef curveto(self, p1, p2, p3):\n\t\tp0 = self._current_point\n\t\tself._win_path.AddBezier_4p(p0, p1, p2, p3)\n\t\tself._current_point = p3\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "farc", "data": "\tdef arc(self, c, r, a0, a1):\n\t\tg = self._win_path\n\t\tg.AddArc_p3f(c, r, a0, a1)\n\t\tself._current_point = g.GetLastPoint()\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fclosepath", "data": "\tdef closepath(self):\n\t\tself._win_path.CloseFigure()\n\t\tself._current_point = None\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "ffill", "data": "\tdef fill(self):\n\t\tself._win_graphics.FillPath(self._state.win_fill_brush, self._win_path)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fstroke", "data": "\tdef stroke(self):\n\t\tself._win_graphics.DrawPath(self._state.win_pen, self._win_path)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "ferase", "data": "\tdef erase(self):\n\t\tg = self._win_graphics\n\t\tg.SetSourceCopyMode()\n\t\tg.FillPath(self._state.win_bg_brush, self._win_path)\n\t\tg.SetSourceOverMode()\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fshow_text", "data": "\tdef show_text(self, text):\n\t\tfont = self._state.font\n\t\tgf = font._win_gdip_font\n\t\tx, y = self._current_point\n\t\tbrush = self._state.win_text_brush\n\t\tg = self._win_graphics\n\t\tw = g.DrawAndMeasureStringWidth_2f(text, gf, x, y, brush)\n\t\tself._current_point = x + w, y\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fclip", "data": "\tdef clip(self):\n\t\tself._win_graphics.SetClip_PI(self._win_path)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "frectclip", "data": "\tdef rectclip(self, rect):\n\t\tself._win_graphics.SetClip_rI(rect)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fgsave", "data": "\tdef gsave(self):\n\t\told_state = self._state\n\t\told_state.win_state = self._win_graphics.Save()\n\t\tself._stack.append(old_state)\n\t\tself._state = GState(old_state)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fgrestore", "data": "\tdef grestore(self):\n\t\told_state = self._stack.pop()\n\t\tself._win_graphics.Restore(old_state.win_state)\n\t\tself._state = old_state\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "frect", "data": "\tdef rect(self, rect):\n\t\tself._win_path.AddRectangle_r(rect)\n\t\tself._current_point = None\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "ffill_rect", "data": "\tdef fill_rect(self, rect):\n\t\tself._win_graphics.FillRectangle_r(self._state.win_fill_brush, rect)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fstroke_rect", "data": "\tdef stroke_rect(self, rect):\n\t\tself._win_graphics.DrawRectangle_r(self._state.win_pen, rect)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "ferase_rect", "data": "\tdef erase_rect(self, rect):\n\t\tself._win_graphics.FillRectangle_r(self._state.win_bg_brush, rect)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "foval", "data": "\tdef oval(self, rect):\n\t\tself._win_path.AddEllipse_r(rect)\n\t\tself._current_point = None\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "ffill_oval", "data": "\tdef fill_oval(self, rect):\n\t\tself._win_graphics.FillEllipse_r(self._state.win_fill_brush, rect)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fstroke_oval", "data": "\tdef stroke_oval(self, rect):\n\t\tself._win_graphics.DrawEllipse_r(self._state.win_pen, rect)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "ferase_oval", "data": "\tdef erase_oval(self, rect):\n\t\tself._win_graphics.FillEllipse_r(self._state.win_bg_brush, rect)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fstroke_arc", "data": "\tdef stroke_arc(self, c, r, a0, a1):\n\t\tself._win_graphics.DrawArc_3pf(self._state.win_pen, c, r, a0, a1)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fwedge", "data": "\tdef wedge(self, c, r, a0, a1):\n\t\tself._win_path.AddPie_p3f(c, r, a0, a1)\n\t\tself._current_point = None\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fstroke_wedge", "data": "\tdef stroke_wedge(self, c, r, a0, a1):\n\t\tself._win_graphics.DrawPie_p3f(self._state.win_pen, c, r, a0, a1)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "ffill_wedge", "data": "\tdef fill_wedge(self, c, r, a0, a1):\n\t\tself._win_graphics.FillPie_p3f(self._state.win_fill_brush, c, r, a0, a1)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "ferase_wedge", "data": "\tdef erase_wedge(self, c, r, a0, a1):\n\t\tself._win_graphics.FillPie_p3f(self._state.win_bg_brush, c, r, a0, a1)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "flines", "data": "\tdef lines(self, points):\n\t\tself._win_path.AddLines_pv(points)\n\t\tself._current_point = points[-1]\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "flinesto", "data": "\tdef linesto(self, points):\n\t\tself.lines([self._current_point] + points)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fstroke_lines", "data": "\tdef stroke_lines(self, points):\n\t\tself._win_graphics.DrawLines_pv(self._state.win_pen, points)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fpoly", "data": "\tdef poly(self, points):\n\t\tself._win_path.AddPolygon_pv(points)\n\t\tself._current_point = None\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fstroke_poly", "data": "\tdef stroke_poly(self, points):\n\t\tself._win_graphics.DrawPolygon_pv(self._state.win_pen, points)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "ffill_poly", "data": "\tdef fill_poly(self, points):\n\t\tself._win_graphics.FillPolygon_pv(self._state.win_fill_brush, points)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "ferase_poly", "data": "\tdef erase_poly(self, points):\n\t\tself._win_graphics.FillPolygon_pv(self._state.win_bg_brush, points)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fcurves", "data": "\tdef curves(self, points):\n\t\tself._win_path.AddBeziers_pv(points)\n\t\tself._current_point = points[-1]\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fcurvesto", "data": "\tdef curvesto(self, points):\n\t\tself.curves([self._current_point] + points)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fstroke_curves", "data": "\tdef stroke_curves(self, points):\n\t\tself._win_graphics.DrawBeziers_pv(self._state.win_pen, points)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "ftranslate", "data": "\tdef translate(self, dx, dy):\n\t\tself._win_graphics.Translate_2f(dx, dy)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}, {"term": "def", "name": "fscale", "data": "\tdef scale(self, sx, sy):\n\t\tself._win_graphics.Scale_2f(sx, sy)\n", "description": null, "category": "graphics", "imports": ["from math import sin, cos, pi", "import win32con as wc, win32ui as ui, win32gui as gui", "from win32con import PS_SOLID, BS_SOLID, RGN_AND", "#from win32ui import CreatePen, CreateBrush", "#from win32gui import CloseFigure, PathToRegion, AngleArc", "from GUI import export", "import GUI.GDIPlus as gdip", "from GUI.StdColors import black, white", "from GUI.StdFonts import application_font", "from GUI.WinUtils import win_null_brush", "from GUI.GCanvases import Canvas as GCanvas"]}], [{"term": "def", "name": "start_pyglet", "data": "def start_pyglet() -> None:\n\tpyglet.app.run()\n", "description": null, "category": "graphics", "imports": ["import pyglet", "from pyglet.window import Window", "from graphics.data.graphics_data import GraphicsData "]}, {"term": "def", "name": "set_pyglet_resource_paths", "data": "def set_pyglet_resource_paths(path: list[str]) -> None:\n\tpyglet.resource.path = path\n\tpyglet.resource.reindex()\n", "description": null, "category": "graphics", "imports": ["import pyglet", "from pyglet.window import Window", "from graphics.data.graphics_data import GraphicsData "]}, {"term": "def", "name": "get_world_origin_screen_space", "data": "def get_world_origin_screen_space(window: Window) -> tuple[int, int]:\n\torigin_x_s = window.width // 2\n\torigin_y_s = window.height // 2\n\n\treturn origin_x_s, origin_y_s\n", "description": null, "category": "graphics", "imports": ["import pyglet", "from pyglet.window import Window", "from graphics.data.graphics_data import GraphicsData "]}, {"term": "def", "name": "to_screen_space", "data": "def to_screen_space(world_coords: tuple[int, int], window: Window, graphics_data: GraphicsData) -> tuple[int, int]:\n\n\tworld_origin_x_s, world_origin_y_s = get_world_origin_screen_space(window)\n\n\tx_change = (world_coords[0] - world_coords[1]) * (graphics_data.tile_image_top_pixel_width // 2)\n\ty_change = (world_coords[0] + world_coords[1]) * (graphics_data.tile_image_top_pixel_height // 2)\n\n\treturn world_origin_x_s + x_change, world_origin_y_s + y_change\n", "description": null, "category": "graphics", "imports": ["import pyglet", "from pyglet.window import Window", "from graphics.data.graphics_data import GraphicsData "]}, {"term": "def", "name": "to_world_space", "data": "def to_world_space(screen_coords: tuple[int, int], window: Window, graphics_data: GraphicsData) -> tuple[int, int]:\n\n\tworld_origin_x_s, world_origin_y_s = get_world_origin_screen_space(window)\n\t\n\t# get the area\n\tto_origin_x_s = screen_coords[0] - world_origin_x_s\n\tto_origin_y_s = screen_coords[1] - world_origin_y_s\n\n\tto_origin_x_w = to_origin_x_s // graphics_data.tile_image_top_pixel_width \n\tto_origin_y_w = to_origin_y_s // graphics_data.tile_image_top_pixel_height \n\n\tisometric_x_w = to_origin_x_w + to_origin_y_w \n\t# isometric_y_w = abs(to_origin_x_w - to_origin_y_w) \n\tisometric_y_w = to_origin_y_w - to_origin_x_w \n\n\tfinal_x_w = isometric_x_w\n\tfinal_y_w = isometric_y_w\n\n\t# get the line\n\tinner_x_pixel = to_origin_x_s % graphics_data.tile_image_top_pixel_width \n\tinner_y_pixel = to_origin_y_s % graphics_data.tile_image_top_pixel_height\n\n\t\"\"\"\n\td=(x\u2212x1)(y2\u2212y1)\u2212(y\u2212y1)(x2\u2212x1) \n\tIf d<0 then the point lies on one side of the line, \n\tand if d>0 then it lies on the other side. \n\tIf d=0 then the point lies exactly line.\n\t\"\"\"\t\n\n\t# points\n\tmiddle_x = graphics_data.tile_image_top_pixel_width // 2\n\tleft_x = 0\n\tright_x = graphics_data.tile_image_top_pixel_width \n\n\tmiddle_y = graphics_data.tile_image_top_pixel_height // 2\n\tbottom_y = 0\n\ttop_y = graphics_data.tile_image_top_pixel_height \n\n\t# bottom left (mid left to bottom middle)\n\tb_left_d = (inner_x_pixel-left_x)*(bottom_y-middle_y) - (inner_y_pixel-middle_y)*(middle_x-left_x)\n\tif b_left_d > 0:\n\t\tfinal_x_w -= 1\n\n\t# upper left\n\tu_left_d = (inner_x_pixel-left_x)*(top_y-middle_y) - (inner_y_pixel-middle_y)*(middle_x-left_x)\n\tif u_left_d < 0:\n\t\tfinal_y_w += 1\n\n\t# upper right \n\tu_right_d = (inner_x_pixel-right_x)*(top_y-middle_y) - (inner_y_pixel-middle_y)*(middle_x-right_x)\n\tif u_right_d > 0:\n\t\tfinal_x_w += 1\n\n\t# bottom right \n\tb_right_d = (inner_x_pixel-right_x)*(bottom_y-middle_y) - (inner_y_pixel-middle_y)*(middle_x-right_x)\n\tif b_right_d < 0:\n\t\tfinal_y_w -= 1\n\n\treturn final_x_w, final_y_w \n", "description": "\n\td=(x\u2212x1)(y2\u2212y1)\u2212(y\u2212y1)(x2\u2212x1) \n\tIf d<0 then the point lies on one side of the line, \n\tand if d>0 then it lies on the other side. \n\tIf d=0 then the point lies exactly line.\n\t", "category": "graphics", "imports": ["import pyglet", "from pyglet.window import Window", "from graphics.data.graphics_data import GraphicsData "]}, {"term": "def", "name": "anchor_image_top_left", "data": "def anchor_image_top_left(image: any) -> None:\n\timage.anchor_y = image.height\n", "description": null, "category": "graphics", "imports": ["import pyglet", "from pyglet.window import Window", "from graphics.data.graphics_data import GraphicsData "]}, {"term": "def", "name": "anchor_tile", "data": "def anchor_tile(image: any, graphics_data: GraphicsData) -> None:\n\timage.anchor_y = image.height - graphics_data.tile_image_top_pixel_height\n\n", "description": null, "category": "graphics", "imports": ["import pyglet", "from pyglet.window import Window", "from graphics.data.graphics_data import GraphicsData "]}, {"term": "def", "name": "create_modded_tile_image", "data": "def create_modded_tile_image(image_path: str, graphics_data: GraphicsData) -> any:\n\timage = pyglet.resource.image(image_path)\n\n\t# grab all bounds more cleanly -> cuts off excess for clean anchoring operations, etc.\n\tx_lower, x_upper = graphics_data.tile_image_region_x_start, graphics_data.tile_image_region_x_end\n\ty_lower, y_upper = graphics_data.tile_image_region_y_start, graphics_data.tile_image_region_y_end\n\n\tsub_image = image.get_region(x_lower, y_lower, x_upper, y_upper)\n\tanchor_tile(sub_image, graphics_data)\n\treturn sub_image\n", "description": null, "category": "graphics", "imports": ["import pyglet", "from pyglet.window import Window", "from graphics.data.graphics_data import GraphicsData "]}, {"term": "def", "name": "create_modded_wall_image", "data": "def create_modded_wall_image(image_path: str, graphics_data: GraphicsData) -> any:\n\timage = pyglet.resource.image(image_path)\n\n\t# grab all bounds more cleanly -> cuts off excess for clean anchoring operations, etc.\n\tx_lower, x_upper = graphics_data.tile_image_region_x_start, graphics_data.tile_image_region_x_end\n\ty_lower, y_upper = graphics_data.tile_image_region_y_start, graphics_data.tile_image_region_y_end\n\n\tsub_image = image.get_region(x_lower, y_lower, x_upper, y_upper)\n", "description": null, "category": "graphics", "imports": ["import pyglet", "from pyglet.window import Window", "from graphics.data.graphics_data import GraphicsData "]}], [], [{"term": "def", "name": "main", "data": "def main():\n\tover = GLabel('Game over!')\n\tover.font = 'Times New Roman-30-bold'\n\tover.color = 'Salmon'\n\twin = GLabel('You Win!')\n\twin.font = 'Times New Roman-30-bold'\n\twin.color = 'tan'\n\tgraphics = BreakoutGraphics()\n\tlives = NUM_LIVES\n\t# Add animation loop here!\n\twhile True:\n\t\tpause(FRAME_RATE)\n\t\tgraphics.ball.move(graphics._dx, graphics._dy)\n\t\t# Record the number of blocks.\n\t\tif graphics.is_hit_brick():\n\t\t\tgraphics.brick_count -= 1\n\t\t\t# When all blocks are removed, the game is over\n\t\t\tif graphics.brick_count <= 0:\n\t\t\t\tgraphics.window.add(win, x=(graphics.window.width - over.width)/2, y=(graphics.window.height - over.height)/2)\n\t\t\t\tbreak\n\n\t\t# When the ball hits the window, let the ball bounce.\n\t\tif graphics.ball.x <= 0 or graphics.ball.x >= graphics.window.width - graphics.ball.width:\n\t\t\tgraphics._dx = -graphics._dx\n\t\tif graphics.ball.y <= 0:\n\t\t\tgraphics._dy = -graphics._dy\n\t\t# If the ball exceeds the bottom of the window, lives - 1.\n\t\tif graphics.ball.y >= graphics.window.height - graphics.ball.height:\n\t\t\tlives -= 1\n\t\t\tgraphics.reset_ball_start_point()\n\t\t\t# If lives = 0, game over.\n\t\t\tif lives == 0:\n\t\t\t\tgraphics.window.add(over, (graphics.window.width - over.width)/2, y=(graphics.window.height - over.height)/2)\n\t\t\t\tbreak\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.graphics.gobjects import GLabel"]}], [{"term": "def", "name": "assemble", "data": "def assemble():\n\tenergy_parts = (tools.transform.split_sheet(\n\t\tpygame.image.load(os.path.join(\"resources\", \"images\", \"blocks\", \"energy_parts.png\"))\n\t))\n\n\tgraphics.add(AnimationGraphic(energy_parts[0][0:5]), \"energy_sphere_decreasing_animation\")\n\tgraphics.add(AnimationGraphic([energy_parts[0][0]]), \"energy_sphere_static_animation\")\n\tgraphics.add(Graphic(energy_parts[0][0]), \"energy_sphere\")\n\n\tgraphics.add(RotationSwitchGraphic(energy_parts[1][0], energy_parts[2][0]), \"energy_receiver_time\")\n\tgraphics.add(RotationSwitchGraphic(energy_parts[3][0], energy_parts[4][0]), \"energy_receiver_toggle\")\n\n\tgraphics.add(RotationSwitchGraphic(energy_parts[1][1], energy_parts[2][1]), \"energy_wire_through\")\n\tgraphics.add(RotationSwitchGraphic(energy_parts[1][2], energy_parts[2][2]), \"energy_wire_turn\")\n\tgraphics.add(RotationSwitchGraphic(energy_parts[1][3], energy_parts[2][3]), \"energy_wire_t_junction\")\n\tgraphics.add(RotationSwitchGraphic(energy_parts[1][4], energy_parts[2][4]), \"energy_wire_cross_junction\")\n\n\t# Darken them up a bit. This will pull in some other stuff, but it's fine and actually beneficial\n\tdarker = pygame.Surface((42, 42))\n\tdarker.fill(pygame.Color(0, 0, 0))\n\tdarker.set_alpha(100)\n\tdarker.convert_alpha()\n\tdarker_wires = [[energy_parts[i][j].copy() for j in range(0, 5)] for i in range(0, 3)]\n\tfor row in darker_wires:\n\t\tfor wire in row:\n\t\t\twire.blit(darker, (0, 0))\n\n\t# Add graphics for the darker wires\n\tgraphics.add(RotationSwitchGraphic(darker_wires[1][1], darker_wires[2][1]), \"energy_wire_through_dark\")\n\tgraphics.add(RotationSwitchGraphic(darker_wires[1][2], darker_wires[2][2]), \"energy_wire_turn_dark\")\n\tgraphics.add(RotationSwitchGraphic(darker_wires[1][3], darker_wires[2][3]), \"energy_wire_t_junction_dark\")\n\tgraphics.add(RotationSwitchGraphic(darker_wires[1][4], darker_wires[2][4]), \"energy_wire_cross_junction_dark\")\n\n\tgraphics.add(RotationReflectionSectionalSwitchGraphic(energy_parts[2][5], energy_parts[1][5], [\n\t\tcp_section(energy_parts[2][5], (14, 34, 10, 8)),\n\t\tcp_section(energy_parts[2][5], (8, 32, 30, 6)),\n\t\tcp_section(energy_parts[2][5], (8, 26, 30, 6)),\n\t\tcp_section(energy_parts[2][5], (8, 20, 30, 6)),\n\t\tcp_section(energy_parts[2][5], (8, 14, 30, 6)),\n\t\tcp_section(energy_parts[2][5], (8, 8, 30, 6)),\n\t\tcp_section(energy_parts[2][5], (8, 0, 30, 8))\n\t]), \"energy_delay\")\n\n\ttransistor_graphic = RotationReflectionSectionalSwitchGraphic(energy_parts[1][7], energy_parts[2][7], [\n\t\tcp_section(energy_parts[2][7], (0, 14, 16, 14)),\n\t\tcp_section(energy_parts[2][7], (16, 14, 10, 16)),\n\t\tcp_section(energy_parts[2][7], (26, 14, 16, 14)),\n\t\tcp_section(energy_parts[4][7], (16, 24, 14, 18)),\n\t\tcp_section(energy_parts[4][7], (16, 14, 10, 12))\n\t])\n\tgraphics.add(transistor_graphic, \"energy_transistor\")\n\n\tgraphics.add(RotationSwitchGraphic(energy_parts[1][6], energy_parts[2][6]), \"energy_force_field\")\n\n\tgraphics.add(RotationGraphic(energy_parts[0][5]), \"force_field\")\n\n\tgraphics.add(SectionalSwitchGraphic(energy_parts[1][8], energy_parts[2][8], [\n\t\tcp_section(energy_parts[2][8], (0, 8, 42, 34)),\n\t\tcp_section(energy_parts[2][8], (0, 0, 42, 8))\n\t]), \"energy_recharge\")\n\n\tgraphics.add(AnimationGraphic(energy_parts[0][8:14]), \"energy_ball\")\n", "description": null, "category": "graphics", "imports": ["import os.path", "import pygame", "from graphics import graphics", "import tools", "from graphics.graphic_class.animation_graphic import AnimationGraphic", "from graphics.graphic_class.graphic import Graphic", "from graphics.graphic_class.reflection_graphic import ReflectionGraphic", "from graphics.graphic_class.rotation_graphic import RotationGraphic", "from graphics.graphic_class.rotation_reflection_sectional_switch_graphic import RotationReflectionSectionalSwitchGraphic", "from graphics.graphic_class.rotation_switch_graphic import RotationSwitchGraphic", "from graphics.graphic_class.sectional_switch_graphic import SectionalSwitchGraphic", "from tools.transform import get_clear_surface, cp_section"]}], [{"term": "class", "name": "MyWindow", "data": "class MyWindow(QMainWindow):\n\tdef __init__(self):\n\t\tsuper(MyWindow, self).__init__()\n\t\tloadUi(sys._MEIPASS + os.sep + \"scripts\" + os.sep + \"MainWindow_layout.ui\", self)  # for deployment\n\t\tself.statusBar()\n\t\tself.setWindowTitle('QuArray')\n\t\tself.setWindowOpacity(0.96)\n\t\tself.ndpi_exporter.clicked.connect(lambda: self.ndpi_export())\n\t\tself.trainingbutton.clicked.connect(lambda: self.dabanalysis())\n\t\tself.testingbutton.clicked.connect(lambda: self.thresh_action())\n\t\tself.overbtn.clicked.connect(lambda: self.overlay())\n\t\tself.actionNDPI_SVS_Export.triggered.connect(lambda: self.ndpi_export())\n\t\tself.actionRun_Dab_Analysis.triggered.connect(lambda: self.dabanalysis())\n\t\tself.actionSet_Thresholds.triggered.connect(lambda: self.thresh_action())\n\t\tself.actionOverlay_Figure.triggered.connect(lambda: self.overlay())\n\t\tself.saveimages = False\n\t\tself.checkBox.stateChanged.connect(self.clickbox)\n\t\tscene = QtWidgets.QGraphicsScene()\n\t\tself.pixmap = QtWidgets.QGraphicsPixmapItem()\n\t\tscene.addItem(self.pixmap)\n\t\tself.graphicsView.setScene(scene)\n\t\tself.show()\n\n\tdef ndpi_export(self):  # select file(s) button 2\n\t\tself.NDPI = Cut_Application_thread.MyWindow()\n\t\tself.NDPI.show()\n\n\tdef dabanalysis(self):  # select file(s) button 1\n\t\tself.statusupdate(\"Select path containing PNG files\")\n\t\tself.path = QFileDialog.getExistingDirectory(parent=self, caption='Open file',\n\t\t\t\t\t\t\t\t\t\t\t\t\t directory=\"/Users/callum/Desktop\")\n\t\tif self.path:\n\t\t\tself.analysis = DABanalysis.DabAnalysis(path=self.path, save=self.saveimages)\n\t\t\tself.analysis.maxcuts.connect(self.progress.setMaximum)\n\t\t\tself.analysis.countChanged.connect(self.onCountChanged)\n\t\t\tself.analysis.info.connect(self.statusupdate)\n\t\t\tself.analysis.figures.connect(self.showimage)\n\t\t\tself.analysis.activate.connect(self.activate_input)\n\t\t\tif hasattr(self, \"newthreshold\"):\n\t\t\t\tprint(\"Using new DAB threshold - \" + str(self.newthreshold))\n\t\t\t\tself.analysis.threshold = self.newthreshold / 100\n\t\t\t\tself.analysis.start()\n\t\t\telse:\n\t\t\t\tself.analysis.start()\n\n\tdef activate_input(self, onoff):\n\t\tself.trainingbutton.setEnabled(onoff)\n\t\tself.testingbutton.setEnabled(onoff)\n\t\tself.overbtn.setEnabled(onoff)\n\t\tself.checkBox.setEnabled(onoff)\n\n\tdef statusupdate(self, message):\n\t\tself.statusbar.showMessage(message)\n\n\tdef clickbox(self, state):\n\t\tif state == Qt.Checked:\n\t\t\tself.saveimages = True\n\t\telse:\n\t\t\tself.saveimages = False\n\n\t@pyqtSlot(int)\n\tdef onCountChanged(self, value):\n\t\tself.progress.setValue(value)\n\n\tdef showimage(self):\n\t\timg = qimage2ndarray.array2qimage(self.analysis.current_image, normalize=True)\n\t\timg = QtGui.QPixmap(img)\n\t\tself.pixmap.setPixmap(img)\n\t\tself.graphicsView.fitInView(self.graphicsView.sceneRect(), Qt.KeepAspectRatio)\n\n\tdef thresh_action(self):  # select file(s) button 2\n\t\tself.SW = ThresholdSelectorWindow()\n\t\tself.SW.show()\n\t\tself.SW.signal.connect(self.updatethresholds)\n\n\tdef updatethresholds(self, value):\n\t\tself.newthreshold = value\n\t\tself.statusupdate(\"threshold value updated - \" + str(value))\n\t\tself.testingbutton.setStyleSheet(\"background-color: rgb(0,90,0)\")\n\n\tdef overlay(self):\n\t\tself.statusupdate(\"Select path - This is slow so only a few files if large\")\n\t\tpath = QFileDialog.getExistingDirectory(parent=self, caption='Open file',\n\t\t\t\t\t\t\t\t\t\t\t\tdirectory=\"/Users/callum/Desktop\")\n\t\tif path:\n\t\t\tself.overlayfig = Overlay.Overlay(path=path)\n\t\t\tself.overlayfig.maxcuts.connect(self.progress.setMaximum)\n\t\t\tself.overlayfig.countChanged.connect(self.onCountChanged)\n\t\t\tself.overlayfig.info.connect(self.statusupdate)\n\t\t\tself.overlayfig.figures.connect(self.showimageoverlay)\n\t\t\tif hasattr(self, \"newthreshold\"):\n\t\t\t\tprint(\"Using new DAB threshold - \" + str(self.newthreshold))\n\t\t\t\tself.overlayfig.threshold = self.newthreshold / 100\n\t\t\t\tself.overlayfig.start()\n\t\t\telse:\n\t\t\t\tself.overlayfig.start()\n\n\tdef showimageoverlay(self):\n\t\timg = qimage2ndarray.array2qimage(self.overlayfig.current_image, normalize=True)\n\t\timg = QtGui.QPixmap(img)\n\t\tself.pixmap.setPixmap(img)\n\t\tself.graphicsView.fitInView(self.graphicsView.sceneRect(), Qt.KeepAspectRatio)\n\n", "description": null, "category": "graphics", "imports": ["import qdarkgraystyle", "from scripts import DABanalysis, Overlay, Cut_Application_thread", "import sys", "import os", "from PyQt5.QtCore import pyqtSlot, Qt, pyqtSignal", "from PyQt5.QtWidgets import QFileDialog", "from PyQt5 import QtWidgets, QtGui", "from PyQt5.QtWidgets import QApplication, QMainWindow", "from PyQt5.uic import loadUi", "import qimage2ndarray", "import random", "import numpy as np", "from skimage.color import rgb2hsv", "from PIL import Image"]}, {"term": "class", "name": "ThresholdSelectorWindow", "data": "class ThresholdSelectorWindow(QtWidgets.QWidget):\n\tsignal = pyqtSignal(int)\n\n\tdef __init__(self):\n\t\tsuper(ThresholdSelectorWindow, self).__init__()\n\t\tloadUi(sys._MEIPASS + os.sep + \"scripts\" + os.sep + \"Threshold_selector_Layout.ui\", self)\n\t\tself.slider.setSingleStep(1)\n\t\tself.slider.valueChanged[int].connect(self.sliderchange)\n\t\tself.setWindowTitle('Set DAB Thresholds')\n\t\tself.setWindowOpacity(0.96)\n\t\t# scene 1\n\t\tscene = QtWidgets.QGraphicsScene()\n\t\tself.pixmap = QtWidgets.QGraphicsPixmapItem()\n\t\tscene.addItem(self.pixmap)\n\t\tself.graphicsView.setScene(scene)\n\t\t# scene 2\n\t\tscene_2 = QtWidgets.QGraphicsScene()\n\t\tself.pixmap_2 = QtWidgets.QGraphicsPixmapItem()\n\t\tscene_2.addItem(self.pixmap_2)\n\t\tself.graphicsView_2.setScene(scene_2)\n\t\t# scene 3 - graphicsView_zoom1\n\t\tscene_3 = QtWidgets.QGraphicsScene()\n\t\tself.pixmap_3 = QtWidgets.QGraphicsPixmapItem()\n\t\tscene_3.addItem(self.pixmap_3)\n\t\tself.graphicsView_zoom1.setScene(scene_3)\n\t\t# scene 4 - graphicsView_zoom2\n\t\tscene_4 = QtWidgets.QGraphicsScene()\n\t\tself.pixmap_4 = QtWidgets.QGraphicsPixmapItem()\n\t\tscene_4.addItem(self.pixmap_4)\n\t\tself.graphicsView_zoom2.setScene(scene_4)\n\t\tself.trainingbutton.clicked.connect(lambda: self.getpath())\n\t\tself.imagebutton.clicked.connect(lambda: self.sampleimage())\n\t\tself.togglebtn.clicked.connect(lambda: self.toggle())\n\t\tself.applybtn.clicked.connect(lambda: self.apply())\n\n\t\tif not hasattr(self, \"path\"):\n\t\t\tself.imagebutton.setEnabled(False)\n\t\t\tself.togglebtn.setEnabled(False)\n\t\t\tself.applybtn.setEnabled(False)\n\t\t\tself.slider.setVisible(False)\n\t\t\tself.slbl.setEnabled(False)\n\t\t\tself.dablbl.setEnabled(False)\n\t\t\tself.lbl2.setEnabled(False)\n\t\tself.show()\n\n\tdef getpath(self):  # select file(s) button 1\n\t\tself.path = QFileDialog.getExistingDirectory(parent=self, caption='Open file path',\n\t\t\t\t\t\t\t\t\t\t\t\t\t directory=\"/Users/callum/Desktop\")\n\t\tif self.path:\n\t\t\tself.imagebutton.setEnabled(True)\n\t\t\tself.togglebtn.setEnabled(True)\n\t\t\tself.applybtn.setEnabled(True)\n\t\t\tself.slider.setVisible(True)\n\t\t\tself.slbl.setEnabled(True)\n\t\t\tself.dablbl.setEnabled(True)\n\t\t\tself.lbl2.setEnabled(True)\n\t\t\tself.lbl.setText(self.path)\n\t\t\tself.sampleimage()  # get a sample image\n\n\tdef settext(self, text):\n\t\tself.lbl2.setText(text)\n\t\tself.lbl2.repaint()\n\t\treturn\n\n\t@pyqtSlot()\n\tdef sampleimage(self):\n\t\tif hasattr(self, \"path\"):\n\t\t\tfiles = [f for f in os.listdir(self.path) if f.endswith(\".png\") and not f.endswith(\"Overlay.png\")]\n\t\t\tself.randpath = files[random.randint(0, len(files) - 1)]\n\t\t\tself.settext(self.randpath)\n\t\t\tself.img = np.array(Image.open(self.path + os.sep + self.randpath))[:, :, :3]\n\t\t\tcenter = int(self.img.shape[0] / 2)\n\t\t\tself.zoomimg = self.img[center - 256:center + 256, center - 256:center + 256, :]\n\t\t\tzoomimg = qimage2ndarray.array2qimage(self.zoomimg, normalize=True)\n\t\t\tzoomimg = QtGui.QPixmap(zoomimg)\n\t\t\tself.pixmap_4.setPixmap(zoomimg)\n\t\t\tself.graphicsView_zoom2.fitInView(self.graphicsView_zoom2.sceneRect(), Qt.KeepAspectRatio)\n\t\t\tself.pixmap_3.setPixmap(zoomimg)\n\t\t\tself.graphicsView_zoom1.fitInView(self.graphicsView_zoom1.sceneRect(), Qt.KeepAspectRatio)\n\t\t\tself.img = self.img[::4, ::4]  # todo scale this better\n\t\t\tshowim = qimage2ndarray.array2qimage(self.img, normalize=True)\n\t\t\tshowim = QtGui.QPixmap(showim)\n\t\t\tself.pixmap_2.setPixmap(showim)\n\t\t\tself.graphicsView_2.fitInView(self.graphicsView_2.sceneRect(), Qt.KeepAspectRatio)\n\t\t\t# prep for analysis\n\t\t\timg_hsv = rgb2hsv(self.img)\n\t\t\tself.img_hue = img_hsv[:, :, 0]\n\t\t\tself.image_sat = img_hsv[:, :, 1]\n\t\t\timg_hsv_zoom = rgb2hsv(self.zoomimg)\n\t\t\tself.img_hue_sml = img_hsv_zoom[:, :, 0]\n\t\t\tself.image_sat_sml = img_hsv_zoom[:, :, 1]\n\t\t\tself.slider.setMaximum((self.image_sat.max()) * 100)\n\t\t\tself.slider.setMinimum((self.image_sat.min()) * 100)\n\t\t\tself.togimg = qimage2ndarray.array2qimage(self.img, normalize=True)\n\t\t\tself.togimg = QtGui.QPixmap(self.togimg)\n\t\t\tself.pixmap.setPixmap(self.togimg)\n\t\t\tself.graphicsView.fitInView(self.graphicsView.sceneRect(), Qt.KeepAspectRatio)\n\t\t\treturn\n\n\tdef resizeEvent(self, event):\n\t\tself.graphicsView.fitInView(self.graphicsView.sceneRect(), Qt.KeepAspectRatio)\n\t\tself.graphicsView_2.fitInView(self.graphicsView_2.sceneRect(), Qt.KeepAspectRatio)\n\t\tself.graphicsView_zoom1.fitInView(self.graphicsView_zoom1.sceneRect(), Qt.KeepAspectRatio)\n\t\tself.graphicsView_zoom2.fitInView(self.graphicsView_zoom2.sceneRect(), Qt.KeepAspectRatio)\n\t\tself.show()\n\n\tdef sliderchange(self, value):\n\t\tif hasattr(self, \"img\"):\n\t\t\tself.slbl.setText(str(value))\n\t\t\t#  todo sort the poor code here\n\t\t\t# large image\n\t\t\thue = np.logical_and(self.img_hue > 0.02, self.img_hue < 0.10)  # BROWN PIXELS BETWEEN 0.02 and 0.10\n\t\t\timg = np.logical_and(hue, self.image_sat > value / 100)\n\t\t\timg = qimage2ndarray.array2qimage(img, normalize=True)\n\t\t\timg = QtGui.QPixmap(img)\n\t\t\tself.pixmap.setPixmap(img)\n\t\t\tself.graphicsView.fitInView(self.graphicsView.sceneRect(), Qt.KeepAspectRatio)\n\t\t\t# small image\n\t\t\thue = np.logical_and(self.img_hue_sml > 0.02, self.img_hue_sml < 0.10)  # BROWN PIXELS BETWEEN 0.02 and 0.10\n\t\t\timg = np.logical_and(hue, self.image_sat_sml > value / 100)\n\t\t\timg = qimage2ndarray.array2qimage(img, normalize=True)\n\t\t\timg = QtGui.QPixmap(img)\n\t\t\tself.pixmap_3.setPixmap(img)\n\t\t\tself.graphicsView_zoom1.fitInView(self.graphicsView_zoom1.sceneRect(), Qt.KeepAspectRatio)\n\n\tdef toggle(self):\n\t\tif hasattr(self, \"togimg\"):\n\t\t\tself.pixmap.setPixmap(self.togimg)\n\t\t\tself.graphicsView.fitInView(self.graphicsView.sceneRect(), Qt.KeepAspectRatio)\n\n\tpyqtSlot()\n\n\tdef apply(self):\n\t\tself.signal.emit(int(self.slider.value()))\n\n", "description": null, "category": "graphics", "imports": ["import qdarkgraystyle", "from scripts import DABanalysis, Overlay, Cut_Application_thread", "import sys", "import os", "from PyQt5.QtCore import pyqtSlot, Qt, pyqtSignal", "from PyQt5.QtWidgets import QFileDialog", "from PyQt5 import QtWidgets, QtGui", "from PyQt5.QtWidgets import QApplication, QMainWindow", "from PyQt5.uic import loadUi", "import qimage2ndarray", "import random", "import numpy as np", "from skimage.color import rgb2hsv", "from PIL import Image"]}], [], [], [{"term": "class", "name": "Graphics_scene", "data": "class Graphics_scene(QtGui.QGraphicsScene):\n\tdef __init__(self, main_window):\n\t\tsuper(Graphics_scene, self).__init__(main_window)\n\t\tself.selector = Selector(main_window.selection_tree_widget)\n\n\tdef draw_digital_map(self, digital_map):\n\t\tself.draw_roads(digital_map.roads)\n\t\tself.draw_lane_markings(digital_map.lane_markings)\n\t\tself.draw_kerb_lines(digital_map.kerb_lines)\n\t\tself.draw_arrow_markings(digital_map.arrow_markings)\n\t\tself.draw_bus_stops(digital_map.bus_stops)\n\t\tself.draw_traffic_signals(digital_map.traffic_signals)\n\n\tdef draw_roads(self, roads):\n\t\tfor road_name in roads:\n\t\t\tfor road_section in roads[road_name]:\n\t\t\t\tgraphics_item = self.draw_polyline(road_section)\n\t\t\t\tgraphics_item.setVisible(False)\n\t\t\t\troad_section.visual_item = graphics_item\n\t\t\t\tself.selector.add_road(graphics_item)\n\t\t\t\tfor point in road_section.polyline:\n\t\t\t\t\tgraphics_item = self.draw_point(point, road_section)\n\t\t\t\t\tgraphics_item.setVisible(False)\n\t\t\t\t\tself.selector.add_dot(graphics_item)\n\n\tdef draw_lane_markings(self, lane_markings):\n\t\tfor marking_type in lane_markings:\n\t\t\tfor lane_marking in lane_markings[marking_type]:\n\t\t\t\tself.draw_lane_marking(lane_marking)\n\n\tdef draw_lane_marking(self, lane_marking):\n\t\tgraphics_item = self.draw_polyline(lane_marking)\n\t\tlane_marking.visual_item = graphics_item\n\t\tself.selector.add_lane_marking(graphics_item)\n\t\tfor point in lane_marking.polyline:\n\t\t\tgraphics_item = self.draw_point(point, lane_marking)\n\t\t\tgraphics_item.setVisible(False)\n\t\t\tself.selector.add_dot(graphics_item)\n\n\tdef draw_kerb_lines(self, kerb_lines):\n\t\tfor kerb_line in kerb_lines:\n\t\t\tgraphics_item = self.draw_polyline(kerb_line, QtCore.Qt.green)\n\t\t\tkerb_line.visual_item = graphics_item\n\t\t\tself.selector.add_kerb_line(graphics_item)\n\t\t\tfor point in kerb_line.polyline:\n\t\t\t\tgraphics_item = self.draw_point(point, kerb_line, QtCore.Qt.green)\n\t\t\t\tgraphics_item.setVisible(False)\n\t\t\t\tself.selector.add_dot(graphics_item)\n\n\tdef draw_arrow_markings(self, arrow_markings):\n\t\tfor arrow_marking in arrow_markings:\n\t\t\tif 'A' == arrow_marking.arrow_type:\n\t\t\t\tpath = right_arrow_icon()\n\t\t\telif 'B' == arrow_marking.arrow_type:\n\t\t\t\tpath = straight_and_left_arrow_icon()\n\t\t\telif 'C' == arrow_marking.arrow_type:\n\t\t\t\tpath = straight_and_right_arrow_icon()\n\t\t\telif 'D' == arrow_marking.arrow_type:\n\t\t\t\tpath = straight_arrow_icon()\n\t\t\telif 'E' == arrow_marking.arrow_type:\n\t\t\t\tpath = left_arrow_icon()\n\t\t\telif 'F' == arrow_marking.arrow_type:\n\t\t\t\tpath = left_and_right_arrow_icon()\n\t\t\telif 'G' == arrow_marking.arrow_type:\n\t\t\t\tpath = conv_left_arrow_icon()\n\t\t\telif 'H' == arrow_marking.arrow_type:\n\t\t\t\tpath = conv_right_arrow_icon()\n\t\t\telif 'I' == arrow_marking.arrow_type:\n\t\t\t\tpath = straight_and_left_and_right_arrow_icon()\n\t\t\telse:\n\t\t\t\tpath = None\n\t\t\tgraphics_item = QtGui.QGraphicsPathItem(path)\n\t\t\tgraphics_item.setBrush(QtCore.Qt.black)\n\t\t\tgraphics_item.setPos(arrow_marking.position.x, arrow_marking.position.y)\n\t\t\tgraphics_item.setRotation(-arrow_marking.bearing)\n\t\t\tgraphics_item.setVisible(False)\n\t\t\tself.addItem(graphics_item)\n\t\t\tgraphics_item.road_item = arrow_marking\n\t\t\tarrow_marking.visual_item = graphics_item\n\t\t\tgraphics_item.is_selectable = True\n\t\t\tself.selector.add_arrow_marking(graphics_item)\n\n\tdef draw_bus_stops(self, bus_stops):\n\t\tfor bus_stop in bus_stops:\n\t\t\tpath = bus_stop_icon()\n\t\t\tgraphics_item = QtGui.QGraphicsPathItem(path)\n\t\t\tgraphics_item.setBrush(QtCore.Qt.black)\n\t\t\tgraphics_item.setPos(bus_stop.position.x, bus_stop.position.y)\n\t\t\tgraphics_item.setVisible(False)\n\t\t\tself.addItem(graphics_item)\n\t\t\tgraphics_item.road_item = bus_stop\n\t\t\tbus_stop.visual_item = graphics_item\n\t\t\tgraphics_item.is_selectable = True\n\t\t\tself.selector.add_bus_stop(graphics_item)\n\n\tdef draw_traffic_signals(self, traffic_signals):\n\t\tfor signal in traffic_signals:\n\t\t\tpath = traffic_signal_icon()\n\t\t\tgraphics_item = QtGui.QGraphicsPathItem(path)\n\t\t\tgraphics_item.setBrush(QtCore.Qt.black)\n\t\t\tgraphics_item.setPos(signal.position.x, signal.position.y)\n\t\t\tgraphics_item.setRotation(-signal.bearing)\n\t\t\tgraphics_item.setVisible(False)\n\t\t\tself.addItem(graphics_item)\n\t\t\tgraphics_item.road_item = signal\n\t\t\tsignal.visual_item = graphics_item\n\t\t\tgraphics_item.is_selectable = True\n\t\t\tself.selector.add_traffic_signal(graphics_item)\n\n\tdef draw_road_network(self, road_network):\n\t\tself.draw_lane_edges(road_network.lane_edges)\n\n\tdef draw_lane_edges(self, lane_edges):\n\t\tfor marking_type in lane_edges:\n\t\t\tfor lane_edge in lane_edges[marking_type]:\n\t\t\t\tself.draw_lane_edge(lane_edge)\n\n\tdef draw_lane_edge(self, lane_edge):\n\t\tgraphics_item = self.draw_polyline(lane_edge)\n\t\tgraphics_item.setZValue(1)\n\t\tgraphics_item.setPen(QtCore.Qt.blue)\n\t\tlane_edge.visual_item = graphics_item\n\t\tself.selector.add_lane_edge(graphics_item)\n\n\tdef draw_polyline(self, road_item, pen_color=QtCore.Qt.black):\n\t\tpolyline = road_item.polyline\n\t\tpoint = polyline[0]\n\t\tpath = QtGui.QPainterPath(QtCore.QPointF(point.x, point.y))\n\t\tfor point in polyline[1:]:\n\t\t\tpath.lineTo(point.x, point.y)\n\t\tgraphics_item = QtGui.QGraphicsPathItem(path)\n\t\tgraphics_item.setPen(pen_color)\n\t\tself.addItem(graphics_item)\n\t\tgraphics_item.road_item = road_item\n\t\tgraphics_item.is_selectable = True\n\t\treturn graphics_item\n\n\tdef draw_point(self, point, road_item, color=QtCore.Qt.black):\n\t\tw = 0.3\n\t\th = 0.3\n\t\tgraphics_item = QtGui.QGraphicsEllipseItem(-w/2.0, -h/2.0, w, h)\n\t\tgraphics_item.setPos(point.x, point.y)\n\t\tgraphics_item.setPen(color)\n\t\tgraphics_item.setBrush(color)\n\t\tself.addItem(graphics_item)\n\t\tgraphics_item.road_item = road_item\n\t\tgraphics_item.is_selectable = True\n\t\treturn graphics_item\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtGui, QtCore"]}, {"term": "def", "name": "arrow_stem_icon", "data": "def arrow_stem_icon():\n\tpath = QtGui.QPainterPath()\n\tpath.addRect(-0.15, 0, 0.30, 2.40)\n\treturn path\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtGui, QtCore"]}, {"term": "def", "name": "arrow_head_icon", "data": "def arrow_head_icon():\n\tpath = QtGui.QPainterPath(QtCore.QPointF(-0.15, 0))\n\tpath.lineTo(0.15, 0)\n\tpath.lineTo(0.15, 0.60)\n\tpath.lineTo(0.45, 0.60)\n\tpath.lineTo(0, 1.20)\n\tpath.lineTo(-0.45, 0.60)\n\tpath.lineTo(-0.15, 0.60)\n\tpath.closeSubpath()\n\treturn path\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtGui, QtCore"]}, {"term": "def", "name": "rotated_arrow_head_icon", "data": "def rotated_arrow_head_icon(angle):\n\tmatrix = QtGui.QTransform()\n\tmatrix.rotate(angle)\n\tpath = arrow_head_icon()\n\tpolygon = path.toFillPolygon(matrix)\n\tpath = QtGui.QPainterPath()\n\tpath.addPolygon(polygon)\n\treturn path\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtGui, QtCore"]}, {"term": "def", "name": "right_arrow_icon", "data": "def right_arrow_icon():\n\tpath1 = arrow_stem_icon()\n\tpath2 = rotated_arrow_head_icon(-90)\n\tpath2.translate(-0.15, 2.25)\n\treturn path1.united(path2)\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtGui, QtCore"]}, {"term": "def", "name": "straight_and_left_arrow_icon", "data": "def straight_and_left_arrow_icon():\n\tpath1 = straight_arrow_icon()\n\tpath2 = rotated_arrow_head_icon(90)\n\tpath2.translate(0.15, 1.50)\n\treturn path1.united(path2)\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtGui, QtCore"]}, {"term": "def", "name": "straight_and_right_arrow_icon", "data": "def straight_and_right_arrow_icon():\n\tpath1 = straight_arrow_icon()\n\tpath2 = rotated_arrow_head_icon(-90)\n\tpath2.translate(-0.15, 1.50)\n\treturn path1.united(path2)\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtGui, QtCore"]}, {"term": "def", "name": "straight_arrow_icon", "data": "def straight_arrow_icon():\n\tpath1 = arrow_stem_icon()\n\tpath2 = arrow_head_icon()\n\tpath2.translate(0, 1.80)\n\treturn path1.united(path2)\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtGui, QtCore"]}, {"term": "def", "name": "left_arrow_icon", "data": "def left_arrow_icon():\n\tpath1 = arrow_stem_icon()\n\tpath2 = rotated_arrow_head_icon(90)\n\tpath2.translate(0.15, 2.25)\n\treturn path1.united(path2)\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtGui, QtCore"]}, {"term": "def", "name": "left_and_right_arrow_icon", "data": "def left_and_right_arrow_icon():\n\tpath1 = left_arrow_icon()\n\tpath2 = right_arrow_icon()\n\treturn path1.united(path2)\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtGui, QtCore"]}, {"term": "def", "name": "conv_right_arrow_icon", "data": "def conv_right_arrow_icon():\n\t# At junction of Rochor Canal Road and Queen Street.\n\tpath = QtGui.QPainterPath(QtCore.QPointF(0, 0))\n\trect = QtCore.QRectF(-0.45, 0, 0.90, 2.10)\n\tpath.arcTo(rect, -90, 180)\n\tpath.lineTo(0, 2.40)\n\tpath.lineTo(-0.60, 1.95)\n\tpath.lineTo(0, 1.50)\n\tpath.lineTo(0, 1.80)\n\trect = QtCore.QRectF(-0.30, 0.30, 0.60, 1.50)\n\tpath.arcTo(rect, 90, -180)\n\tpath.closeSubpath()\n\treturn path\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtGui, QtCore"]}, {"term": "def", "name": "conv_left_arrow_icon", "data": "def conv_left_arrow_icon():\n\t# At junction of Rochor Canal Road and Queen Street.\n\tpath = QtGui.QPainterPath(QtCore.QPointF(0, 0))\n\trect = QtCore.QRectF(-0.45, 0, 0.90, 2.10)\n\tpath.arcTo(rect, -90, -180)\n\tpath.lineTo(0, 2.40)\n\tpath.lineTo(0.60, 1.95)\n\tpath.lineTo(0, 1.50)\n\tpath.lineTo(0, 1.80)\n\trect = QtCore.QRectF(-0.30, 0.30, 0.60, 1.50)\n\tpath.arcTo(rect, 90, 180)\n\tpath.closeSubpath()\n\treturn path\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtGui, QtCore"]}, {"term": "def", "name": "straight_and_left_and_right_arrow_icon", "data": "def straight_and_left_and_right_arrow_icon():\n\t# Found at junction of Short Street, Albert Street, and McNally Street (???).\n\tpath1 = straight_and_left_arrow_icon()\n\tpath2 = straight_and_right_arrow_icon()\n\treturn path1.united(path2)\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtGui, QtCore"]}, {"term": "def", "name": "bus_stop_icon", "data": "def bus_stop_icon():\n\tpath = QtGui.QPainterPath(QtCore.QPointF(-0.15, 0))\n\tpath.lineTo(0.15, 0)\n\tpath.lineTo(0.15, 2.40)\n\tpath.lineTo(1.35, 2.40)\n\tpath.lineTo(1.35, 3.30)\n\tpath.lineTo(-0.15, 3.30)\n\tpath.closeSubpath()\n\treturn path\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtGui, QtCore"]}, {"term": "def", "name": "traffic_signal_icon", "data": "def traffic_signal_icon():\n\t# The signal icon looks like an ice-cream cone, with the semi-circle representing the\n\t# light bulb facing the drivers or pedestrians.\n\tpath1 = QtGui.QPainterPath()\n\tpath1.lineTo(-0.50, 2.00)\n\tpath1.lineTo(0.50, 2.00)\n\tpath1.closeSubpath()\n\tpath2 = QtGui.QPainterPath(QtCore.QPointF(-0.50, 2.00))\n\tpath2.arcTo(-0.50, 1.50, 1.00, 1.00, 0, -180)\n\tpath2.lineTo(0, 0)\n\tpath2.closeSubpath()\n\treturn path1.united(path2)\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtGui, QtCore"]}, {"term": "class", "name": "classSelector:", "data": "class Selector:\n\tdef __init__(self, tree_widget):\n\t\ttree_widget.header().setResizeMode(QtGui.QHeaderView.ResizeToContents)\n\n\t\tself.road_group = Selector_group(\"Roads\", tree_widget, False)\n\t\tself.lane_marking_group = Selector_group(\"Lane markings\", tree_widget)\n\t\tself.kerb_line_group = Selector_group(\"Kerb lines\", tree_widget)\n\t\tself.arrow_marking_group = Selector_group(\"Arrow markings\", tree_widget, False)\n\t\tself.bus_stop_group = Selector_group(\"Bus stops\", tree_widget, False)\n\t\tself.traffic_signal_group = Selector_group(\"Traffic signals\", tree_widget, False)\n\n\t\tself.dots = list()\n\n\t\tself.lane_edge_group = Selector_group(\"Lane_edges\", tree_widget)\n\n\tdef add_road(self, graphics_item):\n\t\troad = graphics_item.road_item\n\t\tself.road_group.add_to_sub_group(graphics_item, road.road_name)\n\n\tdef add_lane_marking(self, graphics_item):\n\t\tlane_marking = graphics_item.road_item\n\t\tself.lane_marking_group.add_to_sub_group(graphics_item, lane_marking.marking_type)\n\n\tdef add_kerb_line(self, graphics_item):\n\t\tself.kerb_line_group.add(graphics_item)\n\n\tdef add_arrow_marking(self, graphics_item):\n\t\tself.arrow_marking_group.add(graphics_item)\n\n\tdef add_bus_stop(self, graphics_item):\n\t\tself.bus_stop_group.add(graphics_item)\n\n\tdef add_traffic_signal(self, graphics_item):\n\t\ttraffic_signal = graphics_item.road_item\n\t\tself.traffic_signal_group.add_to_sub_group(graphics_item, traffic_signal.signal_type)\n\n\tdef add_lane_edge(self, graphics_item):\n\t\tlane_edge = graphics_item.road_item\n\t\tself.lane_edge_group.add_to_sub_group(graphics_item, lane_edge.marking_type)\n\n\tdef add_dot(self, graphics_item):\n\t\tself.dots.append(graphics_item)\n\n\tdef show_dots(self):\n\t\tfor graphics_item in self.dots:\n\t\t\tif graphics_item.road_item.visual_item.isVisible():\n\t\t\t\tgraphics_item.setVisible(True)\n\n\tdef hide_dots(self):\n\t\tfor graphics_item in self.dots:\n\t\t\tgraphics_item.setVisible(False)\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtGui, QtCore"]}, {"term": "class", "name": "Selector_group", "data": "class Selector_group(QtCore.QObject):\n\tVISIBILITY_BUTTON_COLUMN = 1\n\tSELECTABILITY_BUTTON_COLUMN = 2\n\n\tdef __init__(self, group_name, parent, is_initially_visible=True):\n\t\tsuper(Selector_group, self).__init__()\n\n\t\tself.tree_widget_item = QtGui.QTreeWidgetItem([group_name, \"visible\", \"selectable\"])\n\t\tif isinstance(parent, QtGui.QTreeWidget):\n\t\t\tparent.addTopLevelItem(self.tree_widget_item)\n\t\telse:\n\t\t\tparent.addChild(self.tree_widget_item)\n\t\tself.make_check_boxes(is_initially_visible)\n\n\t\tself.sub_groups = dict()\n\t\tself.graphics_items = list()\n\n\tdef add(self, graphics_item):\n\t\tself.graphics_items.append(graphics_item)\n\n\tdef add_to_sub_group(self, graphics_item, sub_group_name):\n\t\tif sub_group_name not in self.sub_groups:\n\t\t\tcheck_box = self.visibility_check_box()\n\t\t\tis_checked = True if check_box.checkState() == QtCore.Qt.Checked else False\n\t\t\tself.sub_groups[sub_group_name] = Selector_group(sub_group_name, self.tree_widget_item,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t is_checked)\n\t\tsub_group = self.sub_groups[sub_group_name]\n\t\tsub_group.add(graphics_item)\n\n\tdef make_check_boxes(self, is_initially_visible):\n\t\tself.make_check_box(\"visible\", is_initially_visible,\n\t\t\t\t\t\t\tSelector_group.VISIBILITY_BUTTON_COLUMN, self.toggle_visibility)\n\t\tself.make_check_box(\"selectable\", True,\n\t\t\t\t\t\t\tSelector_group.SELECTABILITY_BUTTON_COLUMN, self.toggle_selectability)\n\n\tdef make_check_box(self, label, is_initially_checked, column, slot):\n\t\tcheck_box = QtGui.QCheckBox(label)\n\t\tcheck_box.setAutoFillBackground(True)\n\t\tif is_initially_checked:\n\t\t\tcheck_box.setCheckState(QtCore.Qt.Checked)\n\t\telse:\n\t\t\tcheck_box.setCheckState(QtCore.Qt.Unchecked)\n\t\ttree_widget = self.tree_widget_item.treeWidget()\n\t\ttree_widget.setItemWidget(self.tree_widget_item, column, check_box)\n\t\tcheck_box.group = self\n\t\ttree_widget.connect(check_box, QtCore.SIGNAL(\"stateChanged(int)\"), slot)\n\n\tdef visibility_check_box(self):\n\t\ttree_widget = self.tree_widget_item.treeWidget()\n\t\treturn tree_widget.itemWidget(self.tree_widget_item,\n\t\t\t\t\t\t\t\t\t  Selector_group.VISIBILITY_BUTTON_COLUMN)\n\n\tdef selectability_check_box(self):\n\t\ttree_widget = self.tree_widget_item.treeWidget()\n\t\treturn tree_widget.itemWidget(self.tree_widget_item,\n\t\t\t\t\t\t\t\t\t  Selector_group.SELECTABILITY_BUTTON_COLUMN)\n\n\tdef toggle_visibility(self, status):\n\t\tbutton = self.sender()\n\t\tgroup = button.group\n\t\tself.toggle_group_visibility(group, status)\n\t\tfor sub_group in group.sub_groups.values():\n\t\t\tcheck_box = sub_group.visibility_check_box()\n\t\t\tcheck_box.setCheckState(status)\n\n\tdef toggle_group_visibility(self, group, status):\n\t\tfor graphics_item in group.graphics_items:\n\t\t\tif QtCore.Qt.Checked == status:\n\t\t\t\tgraphics_item.show()\n\t\t\telse:\n\t\t\t\tgraphics_item.hide()\n\n\tdef toggle_selectability(self, status):\n\t\tbutton = self.sender()\n\t\tgroup = button.group\n\t\tself.toggle_group_selectability(group, status)\n\t\tfor sub_group in group.sub_groups.values():\n\t\t\tcheck_box = sub_group.selectability_check_box()\n\t\t\tcheck_box.setCheckState(status)\n\n\tdef toggle_group_selectability(self, group, status):\n\t\tfor graphics_item in group.graphics_items:\n\t\t\tif QtCore.Qt.Checked == status:\n\t\t\t\tgraphics_item.is_selectable = True\n\t\t\telse:\n\t\t\t\tgraphics_item.is_selectable = False\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtGui, QtCore"]}], [{"term": "class", "name": "TGraphicsObject", "data": "class TGraphicsObject( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateGraphicsObject( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.GraphicsObject_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.GraphicsObject_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TFont", "data": "class TFont( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateFont( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Font_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Font_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TPen", "data": "class TPen( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreatePen( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Pen_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Pen_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBrush", "data": "class TBrush( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBrush( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Brush_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Brush_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TCanvas", "data": "class TCanvas( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateCanvas( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Canvas_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Canvas_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TGraphic", "data": "class TGraphic( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateGraphic( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Graphic_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Graphic_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TPicture", "data": "class TPicture( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreatePicture( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Picture_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Picture_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafileCanvas", "data": "class TMetafileCanvas( TCanvas ):\r\n\tdef Create( Self, AMetafile, ReferenceDevice ):\r\n\t\treturn _Graphics.CreateMetafileCanvas( Self, AMetafile, ReferenceDevice )\r\n\r\n\tdef CreateWithComment( Self, AMetafile, ReferenceDevice, CreatedBy, Description ):\r\n\t\treturn _Graphics.CreateWithCommentMetafileCanvas( Self, AMetafile, ReferenceDevice, CreatedBy, Description )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.MetafileCanvas_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.MetafileCanvas_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TSharedImage", "data": "class TSharedImage(TObject):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateSharedImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.SharedImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.SharedImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafileImage", "data": "class TMetafileImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateMetafileImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.MetafileImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.MetafileImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafile", "data": "class TMetafile( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateMetafile( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Metafile_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Metafile_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBitmapImage", "data": "class TBitmapImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBitmapImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.BitmapImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.BitmapImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBitmap", "data": "class TBitmap( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBitmap( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Bitmap_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Bitmap_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TIconImage", "data": "class TIconImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateIconImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.IconImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.IconImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TIcon", "data": "class TIcon( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateIcon( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Icon_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Icon_SetAttr( Self, Key, Value )\r\n\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}], [{"term": "class", "name": "TGraphicsObject", "data": "class TGraphicsObject( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateGraphicsObject( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.GraphicsObject_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.GraphicsObject_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TFont", "data": "class TFont( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateFont( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Font_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Font_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TPen", "data": "class TPen( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreatePen( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Pen_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Pen_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBrush", "data": "class TBrush( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBrush( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Brush_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Brush_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TCanvas", "data": "class TCanvas( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateCanvas( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Canvas_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Canvas_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TGraphic", "data": "class TGraphic( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateGraphic( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Graphic_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Graphic_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TPicture", "data": "class TPicture( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreatePicture( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Picture_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Picture_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafileCanvas", "data": "class TMetafileCanvas( TCanvas ):\r\n\tdef Create( Self, AMetafile, ReferenceDevice ):\r\n\t\treturn _Graphics.CreateMetafileCanvas( Self, AMetafile, ReferenceDevice )\r\n\r\n\tdef CreateWithComment( Self, AMetafile, ReferenceDevice, CreatedBy, Description ):\r\n\t\treturn _Graphics.CreateWithCommentMetafileCanvas( Self, AMetafile, ReferenceDevice, CreatedBy, Description )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.MetafileCanvas_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.MetafileCanvas_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TSharedImage", "data": "class TSharedImage(TObject):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateSharedImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.SharedImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.SharedImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafileImage", "data": "class TMetafileImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateMetafileImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.MetafileImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.MetafileImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafile", "data": "class TMetafile( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateMetafile( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Metafile_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Metafile_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBitmapImage", "data": "class TBitmapImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBitmapImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.BitmapImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.BitmapImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBitmap", "data": "class TBitmap( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBitmap( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Bitmap_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Bitmap_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TIconImage", "data": "class TIconImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateIconImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.IconImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.IconImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TIcon", "data": "class TIcon( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateIcon( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Icon_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Icon_SetAttr( Self, Key, Value )\r\n\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\n\t# Add the animation loop here!\n\tlives = NUM_LIVES\n\twhile True:\n\t\tpause(FRAME_RATE)\n\t\tgraphics.ball.move(graphics.get_dx(), graphics.get_dy())\n\t\tgraphics.check_collision()\n\t\t# count = number of bricks == brick_rows * brick_cols, when ball touch brick once, count -= 1\n\t\tif graphics.count == 0:\n\t\t\tgraphics.win()\n\t\t\tbreak\n\t\t# check if ball touch the left, right wall of window\n\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\t\tgraphics.set_dx()\n\t\t# check if ball touch the upper wall of window\n\t\tif graphics.ball.y <= 0:\n\t\t\tgraphics.set_dy()\n\t\t# check if ball fall to bottom of window\n\t\telif graphics.ball.y + graphics.ball.height >= graphics.window.height:\n\t\t\tgraphics.back_to_start()\n\t\t\tlives -= 1\n\t\t\tif lives == 0:\n\t\t\t\tgraphics.lose()\n\t\t\t\tbreak\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "def", "name": "find_graphics_cards", "data": "def find_graphics_cards():\n\tfile = open('graphicscards.csv', 'w')\n\twriter = csv.writer(file)\n\twriter.writerow(['Graphics Card', 'Price', 'Shipping', 'More Info'])\n\twriter.writerow([])\n\n\t# Checks if any graphics cards have been found\n\tis_available = False\n\n\tfor page in range(1, 100+1):\n\t\tif page == 1:\n\t\t\thtml_text = requests.get('https://www.newegg.com/Desktop-Graphics-Cards/SubCategory/ID-48').text\n\t\telse:\n\t\t\thtml_text = requests.get(f'https://www.newegg.com/Desktop-Graphics-Cards/SubCategory/ID-48/Page-{page}').text\n\n\t\tsoup = BeautifulSoup(html_text, 'lxml')\n\n\t\tgraphics_cards = soup.find_all('div', class_='item-container')\n\n\t\tfor graphics_card in graphics_cards:\n\t\t\tprice = graphics_card.find('li', class_='price-current').text.split()\n\t\t\tif price:\n\t\t\t\tprice = price[0]\n\t\t\telse:\n\t\t\t\tcontinue\n\t\t\tnum_price = float(price.replace('$', '').replace(',', ''))\n\n\t\t\tshipping = graphics_card.find('li', class_='price-ship').text.split()\n\t\t\tif 'Free' in shipping or 'Special' in shipping:\n\t\t\t\tnum_shipping = 0\n\t\t\t\tshipping = shipping[0]\n\t\t\telif 'Est.' in shipping:\n\t\t\t\tnum_shipping = float(shipping[len(shipping)-1].replace('$', ''))\n\t\t\t\tshipping = shipping[len(shipping)-1]\n\t\t\telse:\n\t\t\t\tnum_shipping = float(shipping[0].replace('$', ''))\n\t\t\t\tshipping = shipping[0]\n\n\t\t\ttotal_cost = num_price + num_shipping\n\t\t\tif total_cost <= budget:\n\t\t\t\tgraphics_card_name = graphics_card.find('a', class_='item-title').text\n\t\t\t\tmore_info = graphics_card.a['href']\n\n\t\t\t\tif multiple:\n\t\t\t\t\tfor preferred_graphics_card in preferred_graphics_cards:\n\t\t\t\t\t\tpreferred_graphics_card = preferred_graphics_card.strip()\n\t\t\t\t\t\tif preferred_graphics_card.upper() in graphics_card_name.upper():\n\t\t\t\t\t\t\tis_available = True\n\t\t\t\t\t\t\tprint(f\"Graphics Card: {graphics_card_name}\")\n\t\t\t\t\t\t\tprint(f\"Price: {price}\")\n\t\t\t\t\t\t\tprint(f\"Shipping: {shipping}\")\n\t\t\t\t\t\t\tprint(f\"More info: {more_info}\")\n\n\t\t\t\t\t\t\tprint()\n\t\t\t\t\t\t\twriter.writerow([graphics_card_name, price, shipping, more_info])\n\t\t\t\telse:\n\t\t\t\t\tif preferred_graphics_cards.strip() == '':\n\t\t\t\t\t\tis_available = True\n\t\t\t\t\t\tprint(f\"Graphics Card: {graphics_card_name}\")\n\t\t\t\t\t\tprint(f\"Price: {price}\")\n\t\t\t\t\t\tprint(f\"Shipping: {shipping}\")\n\t\t\t\t\t\tprint(f\"More info: {more_info}\")\n\n\t\t\t\t\t\tprint()\n\t\t\t\t\t\twriter.writerow([graphics_card_name, price, shipping, more_info])\n\t\t\t\t\telse:\n\t\t\t\t\t\tif preferred_graphics_cards.upper() in graphics_card_name.upper():\n\t\t\t\t\t\t\tis_available = True\n\t\t\t\t\t\t\tprint(f\"Graphics Card: {graphics_card_name}\")\n\t\t\t\t\t\t\tprint(f\"Price: {price}\")\n\t\t\t\t\t\t\tprint(f\"Shipping: {shipping}\")\n\t\t\t\t\t\t\tprint(f\"More info: {more_info}\")\n\n\t\t\t\t\t\t\tprint()\n\t\t\t\t\t\t\twriter.writerow([graphics_card_name, price, shipping, more_info])\n\n\tif not is_available:\n\t\tprint(\"There are no graphics cards available.\")\n\t\twriter.writerow([\"None available.\"])\n\n\tfile.close()\n\n", "description": null, "category": "graphics", "imports": ["from bs4 import BeautifulSoup", "import requests", "import time", "import csv"]}], [{"term": "class", "name": "classSkymapEngine:", "data": "class SkymapEngine:\n\n\tdef __init__(self, graphics, font_metrics, language=EN, ra=0.0, dec=0.0, fieldradius=-1.0, lm_stars=13.8, caption=''):\n\t\t\"\"\"\n\t\tWidth is width of the map including the legend in mm.\n\t\t\"\"\"\n\t\tself.graphics = graphics\n\t\tself.font_metrics = font_metrics\n\n\t\tself.caption = ''\n\t\tself.language = language\n\t\tself.drawingwidth = self.graphics.gi_width\n\t\tself.min_radius   = 1.0 # of deepsky symbols (mm)\n\t\tself.star_border_linewidth = 0.06\n\n\t\tself.lm_stars\t = lm_stars\n\t\tself.deepsky_label_limit = 15 # deepsky lm for labels\n\n\t\tself.set_caption(caption)\n\t\tself.set_field(ra,dec,fieldradius)\n\t\tpass\n\n\tdef set_field(self, ra, dec,fieldradius):\n\t\t\"\"\"\n\t\tProvide the RA, DEC, and radius of the map in radians. This method\n\t\tsets a new drawingscale and legend_fontscale\n\t\t\"\"\"\n\t\tself.fieldcentre\t\t = (ra,dec)\n\t\tself.fieldradius\t\t = fieldradius\n\t\tself.drawingscale\t\t= self.drawingwidth/2.0*0.98/sin(fieldradius)\n\t\tself.legend_fontscale\t= self.drawingwidth/100.0\n\n\t\tself.set_caption(self.caption)\n\t\tpass\n\n\n\tdef set_language(language):\n\t\t\"\"\"\n\t\tSet the language of the legend.\n\t\t\"\"\"\n\t\tself.language = language\n\t\tpass\n\n\n\tdef set_caption(self, caption):\n\t\tself.caption = caption\n\t\tif caption == '':\n\t\t\tself.graphics.set_dimensions(self.drawingwidth, self.drawingwidth)\n\t\telse:\n\t\t\tself.graphics.set_dimensions(self.drawingwidth,self.drawingwidth + self.legend_fontscale*self.graphics.gi_fontsize*2.0)\n\t\t\tpass\n\n\t\tpass\n\n\n\tdef magnitude_to_radius(self, magnitude):\n\t\t#radius = 0.13*1.35**(int(self.lm_stars)-magnitude)\n\t\tradius = 0.15*1.33**(int(self.lm_stars)-magnitude)\n\t\treturn radius\n\n\n\n\tdef draw_magnitude_scale(self,\n\t\t\t\t\t\t\t xcentre_stars,\n\t\t\t\t\t\t\t ybottom,\n\t\t\t\t\t\t\t stars_in_scale=11):\n\t\t\"\"\"\n\t\tDraws a vertical magnitude scale with at most \\\"stars_in_scale\\\" stars down\n\t\tto magnitude -1\n\t\t\"\"\"\n\t\tmags_in_scale = int(self.lm_stars) - arange(stars_in_scale)\n\t\tlegendx = xcentre_stars\n\t\tlegendy = arange(stars_in_scale)*self.graphics.gi_fontsize + ybottom\n\n\t\tlegendr = self.magnitude_to_radius(mags_in_scale)\n\t\tself.graphics.set_linewidth(self.star_border_linewidth)\n\n\t\tfor i in range(len(legendy)):\n\t\t\tif mags_in_scale[i] >= -1:\n\t\t\t\tself.star(legendx, legendy[i], legendr[i])\n\t\t\t\tself.graphics.text_right(legendx+self.graphics.gi_fontsize, legendy[i]-self.graphics.gi_fontsize/3.0, str(mags_in_scale[i]),begin=True, end=True)\n\t\t\t\tpass\n\t\t\tpass\n\n\t\tpass\n\n\n\n\tdef draw_caption(self):\n\t\tif self.caption != '':\n\t\t\tfh = self.graphics.gi_fontsize\n\t\t\tself.graphics.set_font(self.graphics.gi_font, 2.0*fh)\n\t\t\tself.graphics.text_centred(0,self.drawingwidth/2.0+fh, self.caption, begin=True, end=True)\n\t\t\tself.graphics.set_font(self.graphics.gi_font, fh)\n\t\t\tpass\n\t\tpass\n\n\n\tdef draw_field_border(self):\n\t\t\"\"\"\n\t\tDraw a circle representing bthe edge of the field of view.\n\t\t\"\"\"\n\t\tself.graphics.set_linewidth(0.15)\n\t\tself.graphics.circle(0,0,sin(self.fieldradius)*self.drawingscale)\n\t\tpass\n\n\n\tdef draw_mapscale(self,x, y, maxlength):\n\t\t\"\"\"\n\t\tx,y are the coordinates of the leftmost point of the horizontal line.\n\t\tThis is excluding the vertical end bars. maxlength is the maximum\n\t\tlength of the ruler line excluding the endbars.\n\t\t\"\"\"\n\t\t# Determine a suitable scale ruler in the topleft corner\n\t\tallowed_ruler = array([1,5,10,30,60,120,300.0]) # arcminutes\n\t\tallowed_labels = ['1\\251', '5\\251', '10\\251', '30\\251', '1\\312', '2\\312', '5\\312']\n\n\t\tmaxruler = maxlength\n\t\truler_mm = allowed_ruler*pi/180/60.0*self.drawingscale\n\t\truler_label = ''\n\t\truler_length= 0.0\n\t\tfor i in range(len(allowed_ruler)):\n\t\t\tif ruler_mm[-(i+1)] <= maxruler:\n\t\t\t\truler_label = allowed_labels[-(i+1)]\n\t\t\t\truler_length= ruler_mm[-(i+1)]\n\t\t\t\tbreak\n\t\t\t\tpass\n\t\t\tpass\n\n\t\t# Draw ruler\n\t\tlength = ruler_length\n\t\tleft   = x\n\t\tyline  = y\n\n\t\tlw = self.graphics.gi_linewidth\n\n\t\tself.graphics.line(x, y, x+length, y)\n\t\tself.graphics.line(x-lw/2.0, y - 0.01*self.drawingwidth,\n\t\t\t\t\t\t   x-lw/2.0, y + 0.01*self.drawingwidth)\n\t\tself.graphics.line(x+length+lw/2.0,\n\t\t\t\t\t\t   y -0.01*self.drawingwidth,\n\t\t\t\t\t\t   x+length+lw/2.0,\n\t\t\t\t\t\t   y+0.01*self.drawingwidth)\n\t\tself.graphics.text_centred(x+length/2.0,\n\t\t\t\t\t\t\t\t   y-self.graphics.gi_fontsize*2/3.0,\n\t\t\t\t\t\t\t\t   ruler_label,\n\t\t\t\t\t\t\t\t   begin=True, end=True)\n\t\tpass\n\n\n\n\tdef draw_coordinates(self, x, y, ra, dec):\n\t\t\"\"\"\n\t\tx,y are coordinates of the lower left corner of the textbox\n\t\t\"\"\"\n\t\trah = int(ra*12/pi)\n\t\tram = int((ra*12/pi -rah)*60)\n\t\tras = int(((ra*12/pi -rah)*60 - ram)*60+0.5)\n\t\tif ras == 60:\n\t\t\tram +=1\n\t\t\tras = 0\n\t\t\tpass\n\t\tif ram == 60:\n\t\t\trah += 1\n\t\t\tram = 0\n\t\t\tpass\n\t\tif rah == 24:\n\t\t\trah = 0\n\t\t\tpass\n\n\t\tdecsign = '+'\n\t\tif dec < 0.0:\n\t\t\tdecsign = '-'\n\t\t\tpass\n\t\tdecd= int(abs(dec)*180/pi)\n\t\tdecm = int((abs(dec)*180/pi-decd)*60)\n\t\tdecs = int( ((abs(dec)*180/pi-decd)*60 -decm)*60+0.5)\n\n\t\tif decs == 60:\n\t\t\tdecm += 1\n\t\t\tdecs = 0\n\t\t\tpass\n\t\tif decm == 60:\n\t\t\tdecd+=1\n\t\t\tdecm = 0\n\t\t\tpass\n\n\t\tself.graphics.text_right(x, y, str(rah).rjust(2),begin=True, end=False)\n\t\tself.graphics.text_superscript(self.language['h'])\n\t\tself.graphics.text(str(ram))\n\t\tself.graphics.text_superscript(self.language['m'])\n\t\tself.graphics.text(str(ras))\n\t\tself.graphics.text_superscript(self.language['s'])\n\t\tdectext = ' '+decsign+str(decd)+'\\312'+str(decm)+'\\251'+str(decs)+'\\042'\n\t\tself.graphics.text(dectext,begin=False, end=True)\n\t\tpass\n\n\n\n\tdef draw_legend(self):\n\t\t# Set the fontsize for the entire legend\n\t\tself.graphics.set_font(self.graphics.gi_font,\n\t\t\t\t\t\t\t   fontsize=2.6*self.legend_fontscale)\n\n\t\tself.draw_caption()\n\n\t\t# Draw vertical magnitude scale\n\t\tself.draw_magnitude_scale(xcentre_stars= -0.4775*self.drawingwidth,\n\t\t\t\t\t\t\t\t  ybottom=-0.485*self.drawingwidth)\n\n\t\t# Draw border of field-of-view\n\t\tself.draw_field_border()\n\n\t\t# Draw scale of map\n\t\tself.draw_mapscale(x=-0.49*self.drawingwidth,\n\t\t\t\t\t\t   y=0.48*self.drawingwidth,\n\t\t\t\t\t\t   maxlength=self.drawingwidth/3.0)\n\n\n\t\t# Draw orientation indication\n\t\tx = -0.46*self.drawingwidth\n\t\ty =  0.32*self.drawingwidth\n\t\tdl = 0.03*self.drawingwidth\n\n\t\tfh = self.graphics.gi_fontsize\n\t\tself.graphics.line(x-dl,y, x+dl,y)\n\t\tself.graphics.line(x,y-dl, x,y+dl)\n\t\tself.graphics.text_centred(x, y+dl+fh/2.0, 'N',begin=True, end=True)\n\t\tself.graphics.text_right(x+dl+fh/6.0, y-fh/3.0, 'W',begin=True, end=True)\n\n\t\t# Draw coordinates of fieldcentre\n\t\tself.draw_coordinates(x=-0.49*self.drawingwidth,\n\t\t\t\t\t\t\t  y=0.49*self.drawingwidth -\n\t\t\t\t\t\t\t  3*fh,\n\t\t\t\t\t\t\t  ra=self.fieldcentre[0],\n\t\t\t\t\t\t\t  dec=self.fieldcentre[1])\n\n\n\t\t# Draw list of symbols\n\t\tlegendx  = 0.48*self.drawingwidth\n\t\tlegendy  = 0.49*self.drawingwidth\n\t\tlegendinc= fh\n\n\t\tr = fh/3.0\n\t\ttext_offset = -2.5*r\n\n\n\t\ttoplabels=[('OCL', len(self.language['OCL'])),\n\t\t\t\t   ('AST', len(self.language['AST'])),\n\t\t\t\t   ('G', len(self.language['G'])),\n\t\t\t\t   ('GCL', len(self.language['GCL']))]\n\t\tbottomlabels=[('SNR', len(self.language['SNR'])),\n\t\t\t\t\t  ('N',len(self.language['N'])),\n\t\t\t\t\t  ('PN', len(self.language['PN'])),\n\t\t\t\t\t  ('PG',len(self.language['PG']))]\n\t\tdef labsort(x,y):\n\t\t\tr = 0\n\t\t\tif x[1] < y[1]:\n\t\t\t\tr = -1\n\t\t\tif x[1] > y[1]:\n\t\t\t\tr = 1\n\t\t\treturn r\n\n\t\ttoplabels.sort(labsort)\n\t\ttoplabels.reverse()\n\t\ttl = []\n\t\tfor lab in toplabels:\n\t\t\ttl.append(lab[0])\n\t\t\tpass\n\n\t\tbottomlabels.sort(labsort)\n\t\tbottomlabels.reverse()\n\t\tbl = []\n\t\tfor lab in bottomlabels:\n\t\t\tbl.append(lab[0])\n\t\t\tpass\n\n\t\tself.open_cluster(legendx, legendy-(tl.index('OCL')+1)*legendinc,r)\n\t\tself.graphics.text_left(legendx+text_offset, legendy-(tl.index('OCL')+1)*legendinc-fh/3.0, self.language['OCL'], begin=True, end=True)\n\n\t\tself.asterism(legendx, legendy-(tl.index('AST')+1)*legendinc,r)\n\t\tself.graphics.text_left(legendx+text_offset, legendy-(tl.index('AST')+1)*legendinc-fh/3.0, self.language['AST'],begin=True, end=True)\n\n\t\tself.galaxy(legendx, legendy-(tl.index('G')+1)*legendinc,r)\n\t\tself.graphics.text_left(legendx+text_offset, legendy-(tl.index('G')+1)*legendinc- fh/3.0, self.language['G'], begin=True, end=True)\n\n\t\tself.globular_cluster(legendx, legendy-(tl.index('GCL')+1)*legendinc,r)\n\t\tself.graphics.text_left(legendx+text_offset, legendy-(tl.index('GCL')+1)*legendinc-fh/3.0, self.language['GCL'], begin=True, end=True)\n\n\n\t\tlegendy = 0.485*self.drawingwidth\n\n\t\tself.supernova_remnant(legendx, -legendy+bl.index('SNR')*legendinc,r)\n\t\tself.graphics.text_left(legendx+text_offset, -legendy+bl.index('SNR')*legendinc - fh/3.0, self.language['SNR'],begin=True, end=True)\n\n\t\tself.planetary_nebula(legendx, -legendy+bl.index('PN')*legendinc,r)\n\t\tself.graphics.text_left(legendx+text_offset, -legendy+bl.index('PN')*legendinc -  fh/3.0, self.language['PN'],begin=True, end=True)\n\n\t\tself.diffuse_nebula(legendx, -legendy +bl.index('N')*legendinc,r)\n\t\tself.graphics.text_left(legendx+text_offset, -legendy+bl.index('N')*legendinc-fh/3.0, self.language['N'], begin=True, end=True)\n\n\t\tself.unknown_object(legendx, -legendy+bl.index('PG')*legendinc,r)\n\t\tself.graphics.text_left(legendx+text_offset, -legendy+bl.index('PG')*legendinc-fh/3.0, self.language['PG'], begin=True, end=True)\n\n\t\tpass # end of draw_legend\n\n\n\n\n\tdef draw_deepsky_objects(self, deepsky_catalog):\n\t\t# Draw deep sky\n\t\tprint 'Drawing deepsky...'\n\t\tdeepsky_list = deepsky_catalog.select_deepsky(self.fieldcentre,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  self.fieldradius).deepsky_list\n\t\tif len(deepsky_list) == 1:\n\t\t\tprint '1 deepsky object in map.'\n\t\telse:\n\t\t\tprint str(len(deepsky_list))+' deepsky objects in map.'\n\t\t\tpass\n\n\t\tdeepsky_list.sort(deepsky.cmp_mag)\n\t\tdeepsky_list_mm = []\n\t\tfor object in deepsky_list:\n\t\t\tl, m  =  radec_to_lm((object.ra, object.dec), self.fieldcentre)\n\t\t\tx,y   = -l*self.drawingscale, m*self.drawingscale\n\t\t\trlong  = object.rlong*self.drawingscale\n\t\t\tif object.type == deepsky.GALCL:\n\t\t\t\trlong = self.min_radius\n\t\t\t\tpass\n\t\t\tif rlong < self.min_radius:\n\t\t\t\trlong = self.min_radius\n\t\t\tdeepsky_list_mm.append((x,y,rlong))\n\t\t\tpass\n\n\t\tlabel_potential = LabelPotential(sin(self.fieldradius)*self.drawingscale ,deepsky_list_mm)\n\n\t\tprint 'Drawing objects...'\n\t\tfor i in range(len(deepsky_list)):\n\t\t\tobject = deepsky_list[i]\n\n\t\t\tx,y,rlong  = deepsky_list_mm[i]\n\t\t\trlong  = object.rlong*self.drawingscale\n\t\t\trshort = object.rshort*self.drawingscale\n\t\t\tposangle=object.position_angle+direction_ddec(\\\n\t\t\t\t(object.ra, object.dec), self.fieldcentre)+0.5*pi\n\n\t\t\tif rlong <= self.min_radius:\n\t\t\t\trshort *= self.min_radius/rlong\n\t\t\t\trlong = self.min_radius\n\t\t\t\tpass\n\n\t\t\tif object.type == deepsky.GALCL:\n\t\t\t\trlong /= 3.0\n\t\t\t\tpass\n\n\t\t\tlabel=''\n\t\t\tif object.messier > 0:\n\t\t\t\tlabel = 'M '+str(object.messier)\n\t\t\telif object.cat == 'NGC':\n\t\t\t\tobject.all_names.sort()\n\t\t\t\tlabel = string.join(object.all_names,'-')\n\t\t\t\tif object.mag > self.deepsky_label_limit:\n\t\t\t\t\tlabel = ''\n\t\t\t\t\tpass\n\t\t\telse :\n\t\t\t\tlabel = object.cat+' '+string.join(object.all_names, '-')\n\t\t\t\tif object.mag > self.deepsky_label_limit:\n\t\t\t\t\tlabel = ''\n\t\t\t\t\tpass\n\t\t\t\tpass\n\n\t\t\tlabel_length = self.font_metrics.string_width(self.graphics.gi_font, self.graphics.gi_fontsize, label)\n\t\t\tlabelpos = -1\n\n\t\t\tlabelpos_list =[]\n\t\t\tif object.type == deepsky.G:\n\t\t\t\tlabelpos_list = self.galaxy_labelpos(x,y,rlong,rshort,posangle,label_length)\n\t\t\telif object.type == deepsky.N:\n\t\t\t\tlabelpos_list = self.diffuse_nebula_labelpos(x,y,2.0*rlong,2.0*rshort,posangle,label_length)\n\t\t\telif object.type in [deepsky.PN,deepsky.OC,deepsky.GC,deepsky.SNR]:\n\t\t\t\tlabelpos_list = self.circular_object_labelpos(x,y, rlong, label_length)\n\t\t\telif object.type == deepsky.STARS:\n\t\t\t\tlabelpos_list = self.asterism_labelpos(x,y,rlong,label_length)\n\t\t\telse:\n\t\t\t\tlabelpos_list = self.unknown_object_labelpos(x,y,rlong,label_length)\n\t\t\t\tpass\n\n\t\t\tpot = 1e+30\n\t\t\tfor labelpos_index in range(len(labelpos_list)):\n\t\t\t\t[[x1,y1],[x2,y2],[x3,y3]] = labelpos_list[labelpos_index]\n\t\t\t\tpot1 = label_potential.compute_potential(x2,y2)\n\t\t\t\t#label_potential.compute_potential(x1,y1),\n\t\t\t\t#label_potential.compute_potential(x3,y3)])\n\t\t\t\tif pot1 < pot:\n\t\t\t\t\tpot = pot1\n\t\t\t\t\tlabelpos = labelpos_index\n\t\t\t\t\tpass\n\t\t\t\tpass\n\n\t\t\t[xx,yy] = labelpos_list[labelpos][1]\n\t\t\tlabel_potential.add_position(xx,yy,label_length)\n\n\t\t\tif object.type == deepsky.G:\n\t\t\t\tself.galaxy(x,y,rlong,rshort,posangle,label,labelpos)\n\t\t\telif object.type == deepsky.N:\n\t\t\t\tself.diffuse_nebula(x,y,2.0*rlong,2.0*rshort,posangle,label,labelpos)\n\t\t\telif object.type == deepsky.PN:\n\t\t\t\tself.planetary_nebula(x,y, rlong, label,labelpos)\n\t\t\telif object.type == deepsky.OC:\n\t\t\t\tself.open_cluster(x,y,rlong,label,labelpos)\n\t\t\telif object.type == deepsky.GC:\n\t\t\t\tself.globular_cluster(x,y,rlong, label,labelpos)\n\t\t\telif object.type == deepsky.STARS:\n\t\t\t\tself.asterism(x,y,rlong,label,labelpos)\n\t\t\telif object.type == deepsky.SNR:\n\t\t\t\tself.supernova_remnant(x,y,rlong,label,labelpos)\n\t\t\telse:\n\t\t\t\tself.unknown_object(x,y,rlong,label,labelpos)\n\t\t\t\tpass\n\n\t\t\tpass # object in deeplist\n\t\tpass\n\n\n\tdef draw_extra_objects(self,extra_positions):\n\t\t# Draw extra objects\n\t\tprint 'Drawing extra objects...'\n\t\tfor object in extra_positions:\n\t\t\trax,decx,label,labelpos = object\n\t\t\tif angular_distance((rax,decx),self.fieldcentre) < self.fieldradius:\n\t\t\t\tl,m =  radec_to_lm((rax,decx), self.fieldcentre)\n\t\t\t\tx,y = -l*self.drawingscale,m*self.drawingscale\n\t\t\t\tself.unknown_object(x,y,self.min_radius,label,labelpos)\n\t\t\t\tpass\n\t\t\tpass # for...\n\t\tpass\n\n\n\n\tdef draw_stars(self, star_catalog):\n\t\t# Select and draw stars\n\t\tprint 'Drawing stars...'\n\t\tselection = star_catalog.select_stars(self.fieldcentre,\n\t\t\t\t\t\t\t\t\t\t\t  self.fieldradius,\n\t\t\t\t\t\t\t\t\t\t\t  self.lm_stars)\n\t\tprint str(selection.shape[0])+' stars in map.'\n\t\tprint 'Faintest star: '+str(int(max(selection[:,2])*100.0+0.5)/100.0)\n\n\t\tl, m = radec_to_lm((selection[:,0], selection[:,1]), self.fieldcentre)\n\t\tx, y = -l, m\n\n\t\tmag\t   = selection[:,2]\n\t\tindices   = argsort(mag)\n\t\tmagsorted = mag[indices]\n\t\txsorted   = x[indices]*self.drawingscale\n\t\tysorted   = y[indices]*self.drawingscale\n\n\t\trsorted = self.magnitude_to_radius(magsorted)\n\t\tself.graphics.set_linewidth(self.star_border_linewidth)\n\t\tself.graphics.set_pen_gray(1.0)\n\t\tself.graphics.set_fill_gray(0.0)\n\t\tfor i in range(len(xsorted)):\n\t\t\tif magsorted[i] <= 13.8:\n\t\t\t\tself.star(xsorted[i], ysorted[i], rsorted[i])\n\t\t\t\tpass\n\t\t\tpass\n\t\tself.graphics.set_pen_gray(0.0)\n\t\tpass\n\n\n\tdef make_map(self, star_catalog=None, deepsky_catalog=None,\n\t\t\t\t extra_positions=[]):\n\t\tself.graphics.new()\n\t\tself.graphics.set_pen_gray(0.0)\n\t\tself.graphics.set_fill_gray(0.0)\n\t\tself.graphics.set_font(fontsize=2.6)\n\t\tself.graphics.set_linewidth(0.15)\n\n\t\tif deepsky_catalog != None:\n\t\t\tself.draw_deepsky_objects(deepsky_catalog)\n\t\t\tpass\n\t\tif extra_positions != []:\n\t\t\tself.draw_extra_objects(extra_positions)\n\t\t\tpass\n\t\tif star_catalog != None:\n\t\t\tself.draw_stars(star_catalog)\n\t\t\tpass\n\t\tprint 'Drawing legend'\n\t\tself.draw_legend()\n\t\tself.graphics.finish()\n\t\tpass\n\n\n\n\tdef star(self, x, y, radius):\n\t\t\"\"\"\n\t\tFilled circle with boundary. Set fill colour and boundary\n\t\tcolour in advance using set_pen_gray and set_fill_gray\n\t\t\"\"\"\n\t\txx = int(x*100.0+0.5)/100.0\n\t\tyy = int(y*100.0+0.5)/100.0\n\t\tr = int((radius+self.graphics.gi_linewidth/2.0)*100.0+0.5)/100.0\n\t\tself.graphics.circle(xx,yy,r,'PF')\n\t\tpass\n\n\n\n\tdef open_cluster(self, x, y, radius=-1.0, label='', labelpos=''):\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/40.0\n\t\t\tpass\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_linewidth(0.3)\n\t\tself.graphics.set_dashed_line(0.6,0.4)\n\t\tself.graphics.circle(x,y,r)\n\n\t\tself.draw_circular_object_label(x,y,r,label,labelpos)\n\n\t\tself.graphics.restore()\n\t\tpass\n\n\n\n\tdef asterism(self,x,y,radius=-1, label='', labelpos=-1):\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/40.0\n\t\t\tpass\n\t\tw2=2**0.5\n\t\td = r/2.0*w2\n\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_linewidth(0.3)\n\t\tself.graphics.set_dashed_line(0.6,0.4)\n\t\tdiff = self.graphics.gi_linewidth/2.0/w2\n\n\t\tself.graphics.line(x-diff, y+d+diff, x+d+diff,y-diff)\n\t\tself.graphics.line(x+d, y, x,y-d)\n\t\tself.graphics.line(x+diff, y-d-diff, x-d-diff,y+diff)\n\t\tself.graphics.line(x-d, y, x,y+d)\n\n\t\tfh =  self.graphics.gi_fontsize\n\t\tif label != '':\n\t\t\tif labelpos == 0 or labelpos == -1:\n\t\t\t\tself.graphics.text_centred(x, y-d-2*fh/3.0, label,begin=True, end=True)\n\t\t\telif labelpos == 1:\n\t\t\t\tself.graphics.text_centred(x, y+d+fh/3.0, label,begin=True, end=True)\n\t\t\telif labelpos == 2:\n\t\t\t\tself.graphics.text_left(x-d-fh/6.0, y-fh/3.0, label,begin=True, end=True)\n\t\t\telif labelpos == 3:\n\t\t\t\tself.graphics.text_right(x+d+fh/6.0, y-fh/3.0, label, begin=True, end=True)\n\t\t\tpass\n\t\tself.graphics.restore()\n\t\tpass\n\n\n\tdef asterism_labelpos(self,x,y,radius=-1,label_length=0.0):\n\t\t\"\"\"\n\t\tx,y,radius, label_length in mm\n\t\treturns [[start, centre, end],()]\n\t\t\"\"\"\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/40.0\n\t\t\tpass\n\t\tw2=2**0.5\n\t\td = r/2.0*w2\n\t\tfh =  self.graphics.gi_fontsize\n\t\tlabel_pos_list = []\n\t\tyy = y-d-2*fh/3.0\n\t\tlabel_pos_list.append([[x-label_length/2.0,yy],[x,yy],[x+label_length,yy]])\n\t\tyy = y+d+2*fh/3.0\n\t\tlabel_pos_list.append([[x-label_length/2.0,yy],[x,yy],[x+label_length,yy]])\n\t\txx = x-d-fh/6.0\n\t\tyy = y\n\t\tlabel_pos_list.append([[xx-label_length,yy],[xx-label_length/2.0,yy],[xx,yy]])\n\t\txx = x+d+fh/6.0\n\t\tyy = y\n\t\tlabel_pos_list.append([[xx,yy],[xx+label_length/2.0,yy],[xx+label_length,yy]])\n\t\treturn label_pos_list\n\n\n\n\n\n\n\n\tdef galaxy(self, x, y, rlong=-1, rshort=-1, posangle=0.0, label='', labelpos=-1):\n\t\t\"\"\"\n\t\tIf rlong != -1 and rshort == -1 =>   rshort <- rlong\n\t\tif rlong < 0.0 => standard galaxy\n\t\tlabelpos can be 0,1,2,3\n\t\t\"\"\"\n\t\trl = rlong\n\t\trs = rshort\n\t\tif rlong <= 0.0:\n\t\t\trl = self.drawingwidth/40.0\n\t\t\trs = rl/2.0\n\t\t\tpass\n\t\tif rlong > 0.0 and rshort < 0.0:\n\t\t\trl = rlong\n\t\t\trs = rlong/2.0\n\t\t\tpass\n\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_linewidth(0.2)\n\t\tp = posangle\n\t\tif posangle >= 0.5*pi:\n\t\t\tp += pi\n\t\t\tpass\n\t\tif posangle < -0.5*pi:\n\t\t\tp -= pi\n\t\t\tpass\n\n\t\tfh = self.graphics.gi_fontsize\n\t\tself.graphics.ellipse(x,y,rl, rs, p)\n\t\tif label != '':\n\t\t\tself.graphics.save()\n\t\t\tself.graphics.translate(x,y)\n\t\t\tself.graphics.rotate(p)\n\t\t\tif labelpos == 0 or labelpos == -1:\n\t\t\t\tself.graphics.text_centred(0, -rshort-0.5*fh, label,begin=True, end=True)\n\t\t\telif labelpos == 1:\n\t\t\t\tself.graphics.text_centred(0, +rshort+0.5*fh, label,begin=True, end=True)\n\t\t\telif labelpos == 2:\n\t\t\t\tself.graphics.text_right(rlong+fh/6.0, -fh/3.0, label,begin=True, end=True)\n\t\t\telif labelpos == 3:\n\t\t\t\tself.graphics.text_left(-rlong-fh/6.0, -fh/3.0, label,begin=True, end=True)\n\t\t\t\tpass\n\t\t\tself.graphics.restore()\n\t\t\tpass\n\t\tself.graphics.restore()\n\t\tpass\n\n\n\n\tdef galaxy_labelpos(self,x,y,rlong=-1,rshort=-1,posangle=0.0,label_length=0.0):\n\n\t\trl = rlong\n\t\trs = rshort\n\t\tif rlong <= 0.0:\n\t\t\trl = self.drawingwidth/40.0\n\t\t\trs = rl/2.0\n\t\t\tpass\n\t\tif rlong > 0.0 and rshort < 0.0:\n\t\t\trl = rlong\n\t\t\trs = rlong/2.0\n\t\t\tpass\n\n\t\tp = posangle\n\t\tif posangle >= 0.5*pi:\n\t\t\tp += pi\n\t\t\tpass\n\t\tif posangle < -0.5*pi:\n\t\t\tp -= pi\n\t\t\tpass\n\n\t\tfh = self.graphics.gi_fontsize\n\t\tlabel_pos_list = []\n\n\t\tsp = sin(p)\n\t\tcp = cos(p)\n\n\t\thl = label_length/2.0\n\n\t\td = -rshort-0.5*fh\n\t\txc = x + d*sp\n\t\tyc = y - d*cp\n\t\txs = xc -hl*cp\n\t\tys = yc -hl*sp\n\t\txe = xc +hl*cp\n\t\tye = yc +hl*sp\n\t\tlabel_pos_list.append([[xs,ys],[xc,yc],[xe,ye]])\n\n\t\txc = x - d*sp\n\t\tyc = y + d*cp\n\t\txs = xc -hl*cp\n\t\tys = yc -hl*sp\n\t\txe = xc +hl*cp\n\t\tye = yc +hl*sp\n\t\tlabel_pos_list.append([[xs,ys],[xc,yc],[xe,ye]])\n\n\t\td  = rlong+fh/6.0\n\t\txs = x + d*cp\n\t\tys = y + d*sp\n\t\txc = xs + hl*cp\n\t\tyc = ys + hl*sp\n\t\txe = xc + hl*cp\n\t\tye = yc + hl*sp\n\t\tlabel_pos_list.append([[xs,ys],[xc,yc],[xe,ye]])\n\n\t\txe = x - d*cp\n\t\tye = y - d*sp\n\t\txc = xe - hl*cp\n\t\tyc = ye - hl*sp\n\t\txs = xc - hl*cp\n\t\tys = yc - hl*sp\n\t\tlabel_pos_list.append([[xs,ys],[xc,yc],[xe,ye]])\n\n\n\n\t\treturn label_pos_list\n\n\n\n\tdef draw_circular_object_label(self,x,y,r,label='',labelpos=-1):\n\t\tfh = self.graphics.gi_fontsize\n\t\tif label != '':\n\t\t\targ = 1.0-2*fh/(3.0*r)\n\t\t\tif arg < 1.0 and arg > -1.0:\n\t\t\t\ta = arccos(arg)\n\t\t\telse:\n\t\t\t\ta = 0.5*pi\n\t\t\t\tpass\n\t\t\tif labelpos == 0 or labelpos == -1:\n\t\t\t\tself.graphics.text_right(x+sin(a)*r+fh/6.0, y-r, label,begin=True, end=True)\n\t\t\telif labelpos == 1:\n\t\t\t\tself.graphics.text_left(x-sin(a)*r-fh/6.0, y-r, label,begin=True, end=True)\n\t\t\telif labelpos == 2:\n\t\t\t\tself.graphics.text_right(x+sin(a)*r+fh/6.0, y+r-2*fh/3.0, label,begin=True, end=True)\n\t\t\telif labelpos == 3:\n\t\t\t\tself.graphics.text_left(x-sin(a)*r-fh/6.0, y+r-2*fh/3.0, label,begin=True, end=True)\n\t\t\t\tpass\n\t\t\tpass\n\t\tpass\n\n\n\tdef circular_object_labelpos(self,x,y,radius=-1.0,label_length=0.0):\n\t\tfh = self.graphics.gi_fontsize\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/40.0\n\t\t\tpass\n\t\targ = 1.0-2*fh/(3.0*r)\n\t\tif arg < 1.0 and arg > -1.0:\n\t\t\ta = arccos(arg)\n\t\telse:\n\t\t\ta = 0.5*pi\n\t\t\tpass\n\n\n\t\tlabel_pos_list = []\n\t\txs = x+sin(a)*r+fh/6.0\n\t\tys = y-r+fh/3.0\n\t\tlabel_pos_list.append([[xs,ys],[xs+label_length/2.0,ys],[xs+label_length,ys]])\n\t\txs = x-sin(a)*r-fh/6.0 - label_length\n\t\tlabel_pos_list.append([[xs,ys],[xs+label_length/2.0,ys],[xs+label_length,ys]])\n\n\t\txs = x+sin(a)*r+fh/6.0\n\t\tys = y+r-fh/3.0\n\t\tlabel_pos_list.append([[xs,ys],[xs+label_length/2.0,ys],[xs+label_length,ys]])\n\n\t\txs = x+sin(a)*r+fh/6.0\n\t\tys = y+r-fh/3.0\n\t\tlabel_pos_list.append([[xs,ys],[xs+label_length/2.0,ys],[xs+label_length,ys]])\n\t\treturn label_pos_list\n\n\n\n\tdef globular_cluster(self, x,y,radius=-1.0, label='', labelpos=''):\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/40.0\n\t\t\tpass\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_linewidth(0.2)\n\t\tself.graphics.circle(x,y,r)\n\t\tself.graphics.line(x-r, y, x+r, y)\n\t\tself.graphics.line(x, y-r, x, y+r)\n\n\t\tself.draw_circular_object_label(x,y,r,label,labelpos)\n\n\t\tself.graphics.restore()\n\t\tpass\n\n\n\n\tdef diffuse_nebula(self, x, y, width=-1.0, height=-1.0, posangle=0.0, label='',labelpos=''):\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_linewidth(0.2)\n\t\td = 0.5*width\n\t\tif width < 0.0:\n\t\t\td = self.drawingwidth/40.0\n\t\t\tpass\n\t\td1 = d+self.graphics.gi_linewidth/2.0\n\t\tself.graphics.line(x-d1, y+d, x+d1, y+d)\n\t\tself.graphics.line(x+d, y+d, x+d, y-d)\n\t\tself.graphics.line(x+d1, y-d, x-d1, y-d)\n\t\tself.graphics.line(x-d, y-d, x-d, y+d)\n\t\tfh = self.graphics.gi_fontsize\n\t\tif label != '':\n\t\t\tif labelpos == 0 or labelpos == -1:\n\t\t\t\tself.graphics.text_centred(x, y-d-fh/2.0, label,\n\t\t\t\t\t\t\t\t\t\t   begin=True, end=True)\n\t\t\telif labelpos == 1:\n\t\t\t\tself.graphics.text_centred(x, y+d+fh/2.0, label,\n\t\t\t\t\t\t\t\t\t\t   begin=True, end=True)\n\t\t\telif labelpos == 2:\n\t\t\t\tself.graphics.text_left(x-d-fh/6.0, y-fh/3.0, label,\n\t\t\t\t\t\t\t\t\t\tbegin=True, end=True)\n\t\t\telif labelpos == 3:\n\t\t\t\tself.graphics.text_right(x+d+fh/6.0, y-fh/3.0, label,\n\t\t\t\t\t\t\t\t\t\t begin=True, end=True)\n\t\t\tpass\n\t\tself.graphics.restore()\n\t\tpass\n\n\n\n\tdef diffuse_nebula_labelpos(self,x,y,width=-1.0,height=-1.0, posangle=0.0,label_length=0.0):\n\n\t\td = 0.5*width\n\t\tif width < 0.0:\n\t\t\td = self.drawingwidth/40.0\n\t\t\tpass\n\t\tfh = self.graphics.gi_fontsize\n\n\t\tlabel_pos_list = []\n\t\txs = x - label_length/2.0\n\t\tys = y-d-fh/2.0\n\t\tlabel_pos_list.append([[xs,ys],[xs+label_length/2.0,ys],[xs+label_length,ys]])\n\n\t\tys = y+d+fh/2.0\n\t\tlabel_pos_list.append([[xs,ys],[xs+label_length/2.0,ys],[xs+label_length,ys]])\n\n\t\txs = x - d - fh/6.0 - label_length\n\t\tys = y\n\t\tlabel_pos_list.append([[xs,ys],[xs+label_length/2.0,ys],[xs+label_length,ys]])\n\n\t\txs = x + d + fh/6.0\n\t\tys = y\n\t\tlabel_pos_list.append([[xs,ys],[xs+label_length/2.0,ys],[xs+label_length,ys]])\n\t\treturn label_pos_list\n\n\n\n\n\tdef planetary_nebula(self, x, y, radius=-1.0, label='', labelpos=''):\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/60.0\n\t\t\tpass\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_linewidth(0.2)\n\t\tself.graphics.circle(x,y,0.75*r)\n\t\tself.graphics.line(x-0.75*r, y, x-1.5*r, y)\n\t\tself.graphics.line(x+0.75*r, y, x+1.5*r, y)\n\t\tself.graphics.line(x, y+0.75*r, x, y+1.5*r)\n\t\tself.graphics.line(x, y-0.75*r, x, y-1.5*r)\n\n\t\tself.draw_circular_object_label(x,y,r,label,labelpos)\n\n\t\tself.graphics.restore()\n\t\tpass\n\n\n\n\tdef supernova_remnant(self,x,y,radius=-1.0,label='', labelpos=''):\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/40.0\n\t\t\tpass\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_linewidth(0.5)\n\t\tself.graphics.circle(x,y,r-self.graphics.gi_linewidth/2.0)\n\t\t#self.graphics.circle(x,y,r*0.85)\n\t\t#self.graphics.circle(x,y,r*0.7)\n\t\tself.draw_circular_object_label(x,y,r,label,labelpos)\n\n\t\tself.graphics.restore()\n\t\tpass\n\n\tdef unknown_object(self,x,y,radius=-1.0,label='',labelpos=''):\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/40.0\n\t\t\tpass\n\n\t\tr/=2**0.5\n\t\tself.graphics.save()\n\n\t\tself.graphics.set_linewidth(0.2)\n\t\tself.graphics.line(x-r, y+r, x+r, y-r)\n\t\tself.graphics.line(x+r, y+r, x-r, y-r)\n\t\tfh = self.graphics.gi_fontsize\n\t\tif label != '':\n\t\t\tif labelpos == 0:\n\t\t\t\tself.graphics.text_right(x+r+fh/6.0, y-fh/3.0, label,begin=True, end=True)\n\t\t\telif labelpos ==1:\n\t\t\t\tself.graphics.text_left(x-r-fh/6.0, y-fh/3.0, label,begin=True, end=True)\n\t\t\telif labelpos == 2:\n\t\t\t\tself.graphics.text_centred(x, y+ r + fh/2.0, label,begin=True, end=True)\n\t\t\telse:\n\t\t\t\tself.graphics.text_centred(x, y - r - fh/2.0, label,begin=True, end=True)\n\t\t\t\tpass\n\t\t\tpass\n\t\tself.graphics.restore()\n\t\tpass\n\n\n\n\tdef unknown_object_labelpos(self,x,y,radius=-1,label_length=0.0):\n\t\tr = radius\n\t\tif radius <= 0.0:\n\t\t\tr = self.drawingwidth/40.0\n\t\t\tpass\n\t\tfh = self.graphics.gi_fontsize\n\t\tr/=2**0.5\n\t\tlabel_pos_list = []\n\t\txs = x + r +fh/6.0\n\t\tys = y\n\t\tlabel_pos_list.append([[xs,ys],[xs+label_length/2.0,ys],[xs+label_length,ys]])\n\n\t\txs = x - r -fh/6.0 - label_length\n\t\tys = y\n\t\tlabel_pos_list.append([[xs,ys],[xs+label_length/2.0,ys],[xs+label_length,ys]])\n\n\t\txs = x -label_length/2.0\n\t\tys = y + r +fh/2.0\n\t\tlabel_pos_list.append([[xs,ys],[xs+label_length/2.0,ys],[xs+label_length,ys]])\n\n\t\txs = x -label_length/2.0\n\t\tys = y - r -fh/2.0\n\t\tlabel_pos_list.append([[xs,ys],[xs+label_length/2.0,ys],[xs+label_length,ys]])\n\t\treturn label_pos_list\n\n\n\tpass # class SkymapEngine\n\n\n", "description": "\n\t\tWidth is width of the map including the legend in mm.\n\t\t", "category": "graphics", "imports": ["from numpy import *", "import string", "from fchart.label_potential import *", "from fchart.astrocalc import *", "import fchart.deepsky_object as deepsky", "\timport eps", "\timport pdf", "\timport star_catalog as sc", "\tfrom  fonts import FontMetrics"]}], [{"term": "class", "name": "Flask", "data": "class Flask(pygame.sprite.Sprite):\n\tdef __init__(self, x, y, screen):\n\t\tsuper().__init__()\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.activated = False\n\t\tself.screen = screen\n\t\tself.sprites = []\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_01.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_02.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_03.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_04.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_05.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_06.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_07.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_09.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_10.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_11.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_12.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_13.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_14.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_15.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_16.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_17.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_18.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_19.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_20.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_21.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_22.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_23.png'))\n\t\tself.sprites.append(pygame.image.load('Graphics/flask/frame_24.png'))\n\t\tself.current_sprite = 0\n\t\tself.image = self.sprites[self.current_sprite]\n\t\tself.rect = self.image.get_rect(bottomleft=(self.x, self.y))\n\n\tdef update(self, speed, x_shift):\n\t\tself.activated = True\n\n\t\tif self.activated:\n\t\t\tself.current_sprite += speed\n\t\t\tif int(self.current_sprite) >= len(self.sprites):\n\t\t\t\tself.current_sprite = 0\n\t\t\t\tself.activated = False\n\n\t\tself.image = self.sprites[int(self.current_sprite)]\n\t\tself.rect.x += x_shift\n\n\n\n\n\n\n\n\n", "description": null, "category": "graphics", "imports": ["import pygame"]}], [{"term": "def", "name": "snowman", "data": "  def snowman(cx,cy,r):\n\tp1 = graphics.Point(cx,cy)\n\tsnowman1 = graphics.Circle(p1,r)\n\tsnowman1.setFill(\"white\")\n\tsnowman1.draw(winterWin)\n\n\tp2 = graphics.Point(cx,(115/150)*cy)\n\tsnowman2 = graphics.Circle(p2,(25/35)*r)\n\tsnowman2.setFill(\"white\")\n\tsnowman2.draw(winterWin)\n\n\tp3 = graphics.Point(cx, (85/150)*cy)\n\tsnowman3 = graphics.Circle(p3,(15/35)*r)\n\tsnowman3.setFill(\"white\")\n\tsnowman3.draw(winterWin)\n", "description": null, "category": "graphics", "imports": ["import graphics", "import tkinter"]}, {"term": "def", "name": "tree", "data": "  def tree():\n\tdef stump(cx,cy,cx2,cy2):\n\t  p1 = graphics.Point(cx,cy)\n\t  p2 = graphics.Point(cx2,cy2)\n\t  treeBase = graphics.Rectangle(p1,p2)\n\t  treeBase.setFill(\"tan\")\n\t  treeBase.draw(winterWin)\n\n\tdef top(p1x,p1y,p2x,p23y,p3x):\n\t  p1 = graphics.Point(p1x,p1y)\n\t  p2 = graphics.Point(p2x,p23y)\n\t  p3 = graphics.Point(p3x,p23y)\n\t  tree1 = graphics.Polygon(p1,p2,p3,p1)\n\t  tree1.setFill(\"green\")\n\t  tree1.setOutline(\"green\")\n\t  tree1.draw(winterWin)\n\n\t  p1.move(0,-30/75*p1y)\n\t  p2.move(5/23*p2x,-30/135*p23y)\n\t  p3.move(-5/103*p3x,-30/135*p23y)\n\t  tree2 = graphics.Polygon(p1,p2,p3,p1)\n\t  tree2.setFill(\"green\")\n\t  tree2.setOutline(\"green\")\n\t  tree2.draw(winterWin)\n\n\t  p1.move(0, -30/75*p1y)\n\t  p2.move(5/23*p2x, -30/135*p23y)\n\t  p3.move(-5/103*p3x, -30/135*p23y)\n\t  tree3 = graphics.Polygon(p1, p2, p3, p1)\n\t  tree3.setFill(\"green\")\n\t  tree3.setOutline(\"green\")\n\t  tree3.draw(winterWin)\n\n\tstump(55, 125, 70, 160)\n\ttop(63, 75, 23, 135, 103)\n", "description": null, "category": "graphics", "imports": ["import graphics", "import tkinter"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tlives = NUM_LIVES\n\tnum_of_brick_original = graphics.get_num_brick()  # Get the original number of brick\n\tnum_of_brick_removed = 0\n\n\t# Add the animation loop here!\n\twhile True:\n\t\tpause(FRAME_RATE)\n\n\t\t# Start game if game_start == True, and lives is not zero\n\t\tif graphics.get_start_signal() and lives != 0:\n\t\t\tgraphics.ball.move(graphics.get_speed_x(), graphics.get_speed_y())\n\n\t\t\t# Collision detection: paddle or brick\n\t\t\tget_obj = graphics.check_collision()\n\t\t\tif get_obj is not None:\n\t\t\t\tif get_obj == graphics.paddle:\n\t\t\t\t\t# Change dy direction when hitting the paddle top\n\t\t\t\t\t# Change dx direction only when hitting the sides of the paddle\n\t\t\t\t\t# No action when hitting other area of the paddle\n\t\t\t\t\tif graphics.when_collide_paddle() == 'top':\n\t\t\t\t\t\tgraphics.change_direction_dy()\n\t\t\t\t\telif graphics.when_collide_paddle() == 'side':\n\t\t\t\t\t\tgraphics.change_direction_dx()\n\t\t\t\telse:\n\t\t\t\t\t# Change dx direction when hitting the side\n\t\t\t\t\t# Otherwise only change dy direction\n\t\t\t\t\tif graphics.when_collide_brick() == 'side':\n\t\t\t\t\t\tgraphics.change_direction_dx()\n\t\t\t\t\tgraphics.change_direction_dy()\n\t\t\t\t\tgraphics.remove_obj()\t\t   # Remove object when hitting bricks\n\t\t\t\t\tnum_of_brick_removed += 1\t   # Count the brick removed\n\n\t\t\t\t\t# End the game when there's no brick is on screen\n\t\t\t\t\tif num_of_brick_removed == num_of_brick_original:\n\t\t\t\t\t\tgraphics.game_end()\n\t\t\t\t\t\tbreak\n\n\t\t\t# Collision detection: floor, wall, ceiling\n\t\t\tif graphics.is_hit_floor():\n\t\t\t\tgraphics.game_restart()\t\t\t # Ball back to starting position\n\t\t\t\tlives -= 1\t\t\t\t\t\t  # Reduce 1 live when ball hit the floor\n\t\t\telif graphics.is_hit_wall():\n\t\t\t\tgraphics.change_direction_dx()\t  # Change dx direction when hitting the either side of the walls\n\t\t\telif graphics.is_hit_ceiling():\n\t\t\t\tgraphics.change_direction_dy()\t  # Change dy direction when hitting the ceiling\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "def", "name": "get_color_by_distance", "data": "def get_color_by_distance(distance):\n\tif distance >= 25:\n\t\treturn 'red'\n\tif distance <= 6:\n\t\treturn 'green'\n\treturn 'orange'\n\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "from colormap import colors", "from time import sleep", "from threading import Thread", "from json import loads", "import serial"]}, {"term": "class", "name": "RunText", "data": "class RunText(SampleBase):\n\tdef __init__(self, *args, **kwargs):\n\t\tsuper(RunText, self).__init__(*args, **kwargs)\n\t\tself.parser.add_argument(\n\t\t\t\"-t\", \"--text\", help=\"The text to scroll on the RGB LED panel\", default=\"Hello world!\")\n\n\tdef run(self):\n\t\toffscreen_canvas = self.matrix.CreateFrameCanvas()\n\t\tfont = graphics.Font()\n\t\tfont_big = graphics.Font()\n\t\tfont_small = graphics.Font()\n\t\tfont.LoadFont(FONTS+\"7x13.bdf\")\n\t\tfont_big.LoadFont(FONTS+\"10x20.bdf\")\n\t\tfont_small.LoadFont(FONTS+\"5x8.bdf\")\n\n\t\tdef left_block(color, text, distance):\n\t\t\tif color in colors.keys():\n\t\t\t\trgb_color = color\n\t\t\telse:\n\t\t\t\trgb_color = 'white'\n\n\t\t\tif distance != -1:\n\t\t\t\tif color == 'black':\n\t\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big,\n\t\t\t\t\t\t\t\t\t  1, 17, colors['brown'], \"\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\")\n\t\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big,\n\t\t\t\t\t\t\t\t\t  1, 35, colors['brown'], \"\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\")\n\n\t\t\t\tif distance < 100:\n\t\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big, 20,\n\t\t\t\t\t\t\t\t\t  15, colors[rgb_color], str(distance)+'Ft')\n\t\t\t\telse:\n\t\t\t\t\tgraphics.DrawText(offscreen_canvas, font, 13,\n\t\t\t\t\t\t\t\t\t  15, colors[rgb_color], 'too far')\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_small,\n\t\t\t\t\t\t\t\t  30, 30, colors[rgb_color], color.upper()[:8])\n\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big, 2,\n\t\t\t\t\t\t\t\t  18, colors[rgb_color], \"\\u2691\")\n\n\t\t\tgraphics.DrawText(offscreen_canvas, font,\n\t\t\t\t\t\t\t  1, 30, colors[get_color_by_distance(distance)], text)\n\n\t\tdef right_block(color, text, distance):\n\t\t\tif color in colors.keys():\n\t\t\t\trgb_color = color\n\t\t\telse:\n\t\t\t\trgb_color = 'white'\n\n\t\t\tif distance != -1:\n\t\t\t\tif color == 'black':\n\t\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big,\n\t\t\t\t\t\t\t\t\t  65, 17, colors['brown'], \"\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\")\n\t\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big,\n\t\t\t\t\t\t\t\t\t  65, 35, colors['brown'], \"\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\")\n\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big, 115,\n\t\t\t\t\t\t\t\t  18, colors[rgb_color], \"\\u2691\")\n\t\t\t\tif distance < 100:\n\t\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big, 70,\n\t\t\t\t\t\t\t\t\t  15, colors[rgb_color], str(distance)+'Ft')\n\t\t\t\telse:\n\t\t\t\t\tgraphics.DrawText(offscreen_canvas, font, 65,\n\t\t\t\t\t\t\t\t\t  15, colors[rgb_color], 'too far')\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_small,\n\t\t\t\t\t\t\t\t  66, 30, colors[rgb_color], color.upper()[:8])\n\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big, 115,\n\t\t\t\t\t\t\t\t  18, colors[rgb_color], \"\\u2691\")\n\n\t\t\tgraphics.DrawText(offscreen_canvas, font,\n\t\t\t\t\t\t\t  100, 30, colors[get_color_by_distance(distance)], text)\n\n\t\tspeed = 0.25\n\n\t\twhile True:\n\t\t\tif display_values:\n\t\t\t\toffscreen_canvas = self.matrix.SwapOnVSync(offscreen_canvas)\n\t\t\t\toffscreen_canvas.Clear()\n\t\t\t\tleft_block(piles[0]['color'], ' <<<', piles[0]['distance'])\n\t\t\t\tright_block(piles[1]['color'], '>>> ', piles[1]['distance'])\n\t\t\t\tsleep(speed)\n\n\t\t\t\toffscreen_canvas = self.matrix.SwapOnVSync(offscreen_canvas)\n\t\t\t\toffscreen_canvas.Clear()\n\t\t\t\tleft_block(piles[0]['color'], '< <<', piles[0]['distance'])\n\t\t\t\tright_block(piles[1]['color'], '>> >', piles[1]['distance'])\n\t\t\t\tsleep(speed)\n\n\t\t\t\toffscreen_canvas = self.matrix.SwapOnVSync(offscreen_canvas)\n\t\t\t\toffscreen_canvas.Clear()\n\t\t\t\tleft_block(piles[0]['color'], '<< <', piles[0]['distance'])\n\t\t\t\tright_block(piles[1]['color'], '> >>', piles[1]['distance'])\n\t\t\t\tsleep(speed)\n\n\t\t\t\toffscreen_canvas = self.matrix.SwapOnVSync(offscreen_canvas)\n\t\t\t\toffscreen_canvas.Clear()\n\t\t\t\tleft_block(piles[0]['color'], '<<< ', piles[0]['distance'])\n\t\t\t\tright_block(piles[1]['color'], ' >>>', piles[1]['distance'])\n\t\t\t\tsleep(speed)\n\t\t\telse:\n\t\t\t\toffscreen_canvas = self.matrix.SwapOnVSync(offscreen_canvas)\n\t\t\t\toffscreen_canvas.Clear()\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_small,\n\t\t\t\t\t\t\t\t  1, 30, colors['white'], ' <<')\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_small,\n\t\t\t\t\t\t\t\t  110, 30, colors['white'], '>> ')\n\t\t\t\tsleep(speed)\n\t\t\t\toffscreen_canvas = self.matrix.SwapOnVSync(offscreen_canvas)\n\t\t\t\toffscreen_canvas.Clear()\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_small,\n\t\t\t\t\t\t\t\t  1, 30, colors['white'], '< <')\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_small,\n\t\t\t\t\t\t\t\t  110, 30, colors['white'], '> >')\n\t\t\t\tsleep(speed)\n\t\t\t\toffscreen_canvas = self.matrix.SwapOnVSync(offscreen_canvas)\n\t\t\t\toffscreen_canvas.Clear()\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_small,\n\t\t\t\t\t\t\t\t  1, 30, colors['white'], '<< ')\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_small,\n\t\t\t\t\t\t\t\t  110, 30, colors['white'], ' >>')\n\t\t\t\tsleep(speed)\n\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "from colormap import colors", "from time import sleep", "from threading import Thread", "from json import loads", "import serial"]}, {"term": "def", "name": "timer", "data": "def timer():\n\tglobal display_values, timer_counter\n\twhile True:\n\t\tif timer_counter >= timer_limit:\n\t\t\tdisplay_values = False\n\t\telse:\n\t\t\ttimer_counter = timer_counter + 1\n\t\t\tdisplay_values = True\n\n\t\tsleep(1)\n\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "from colormap import colors", "from time import sleep", "from threading import Thread", "from json import loads", "import serial"]}, {"term": "def", "name": "uart", "data": "def uart():\n\tglobal piles, timer_counter\n\twhile True:\n\t\ttry:\n\t\t\tp = rgb_port.readline().decode()\n\t\t\tprint(p)\n\t\t\tpiles = loads(p)\n\t\t\ttimer_counter = 0\n\t\texcept:\n\t\t\tprint(\"... error in string\")\n\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "from colormap import colors", "from time import sleep", "from threading import Thread", "from json import loads", "import serial"]}], [{"term": "class", "name": "Display", "data": "class Display(object):\n\t\n\tWHITE = graphicsUtils.formatColor(1.0, 1.0, 1.0)\n\tRED = graphicsUtils.formatColor(1.0, 0.0, 0.0)\n\tGREEN = graphicsUtils.formatColor(0.16, 0.49, 0.31)\n\tBLUE = graphicsUtils.formatColor(0.0, 0.0, 1.0)\n\tBLACK = graphicsUtils.formatColor(0.0, 0.0, 0.0)\n\tGREY = graphicsUtils.formatColor(0.5, .5, 0.5)\n\t\n\tVISIBLE_CUTTOFF = 0.001\n\t\n\t\n\tpartDict = {}\n\tbeliefParts = []\n\tbeliefValue = []\n\tbeliefColor = []\n\tobservations = []\n\t\n\tgraphicsLock = threading.Lock()\n\t\n\tCOLORS = [\n\t\t'purple',\n\t\t'green',\n\t\t'teal',\n\t\t'red',\n\t\t'orange',\n\t\t'yellow'\n\t]\n\tCOLOR_HUES = {\n\t\t'purple' : 0.8,\n\t\t'green' : 0.3,\n\t\t'teal' : 0.49,\n\t\t'red' : 0.0,\n\t\t'orange' : 0.125,\n\t\t'yellow' : 0.21\n\t}\n\t\n\t@staticmethod\n\tdef initGraphics(layout):\n\t\tgraphicsUtils.begin_graphics(\n\t\t\twidth=layout.getWidth(), \n\t\t\theight=layout.getHeight(), \n\t\t\tcolor = Display.WHITE,\n\t\t\ttitle = Const.TITLE\n\t\t);\n\t\t\n\t@staticmethod\n\tdef endGraphics():\n\t\tgraphicsUtils.end_graphics()\n\n\t@staticmethod\n\tdef raiseEndGraphics():\n\t\tgraphicsUtils.raiseEndGraphics()\n\t\n\t@staticmethod\n\tdef drawCar(car):\n\t\tif car in Display.partDict:\n\t\t\tDisplay._remove(car)\n\t\tcolor = Display.GREY\n\t\tif car.isJunior():\n\t\t\tcolor = Display.BLACK\n\t\tparts = graphicsUtils.rectangle(\n\t\t\tcar.pos, Car.LENGTH, \n\t\t\tCar.WIDTH, \n\t\t\tcolor, \n\t\t\tcar.dir\n\t\t)\n\t\tDisplay.partDict[car] = parts\n\t\t\n\t@staticmethod\n\tdef drawObservation(obs):\n\t\tparts = Display.drawCircle(obs.pos, Observation.RADIUS)\n\t\tDisplay.partDict[obs] = parts\n\t\n\t@staticmethod\n\tdef drawSquare(pos, size, color):\n\t\treturn graphicsUtils.square(pos, size, color)\n\t\n\t@staticmethod\n\tdef drawFinish(block):\n\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.GREEN, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\n\t@staticmethod\n\tdef drawBlocks(blocks):\n\t\tfor block in blocks:\n\t\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.BLUE, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\t\n\t@staticmethod\n\tdef drawCircle(pos, radius):\n\t\treturn graphicsUtils.circle(pos, radius, Display.RED, Display.RED)\n\t\n\t@staticmethod\n\tdef drawBelief(model):\n\t\tDisplay.beliefVisible = []\n\t\tfor r in range(model.getBeliefRows()):\n\t\t\tbeliefValueRow = []\n\t\t\tbeliefPartRow = []\n\t\t\tbeliefColorRow = []\n\t\t\tfor c in range(model.getBeliefCols()):\n\t\t\t\tsquare = Display.drawBeliefSquare(r, c, 'purple', 0.0, model)\n\t\t\t\tbeliefPartRow.append(square)\n\t\t\t\tbeliefValueRow.append(0.0)\n\t\t\t\tbeliefColorRow.append(None)\n\t\t\tDisplay.beliefParts.append(beliefPartRow)\n\t\t\tDisplay.beliefValue.append(beliefValueRow)\n\t\t\tDisplay.beliefColor.append(beliefColorRow)\n\t\t\t\t\n\t@staticmethod\n\tdef drawBeliefSquare(row, col, color, value, model):\n\t\ttileSize = Const.BELIEF_TILE_SIZE\n\t\tx = col * tileSize + tileSize / 2.0\n\t\ty = row * tileSize + tileSize / 2.0\n\t\tif not model.inBounds(x, y): return None\n\t\tcolor = Display._getBeliefSquareColor(color, value)\n\t\treturn Display.drawSquare(Vec2d(x, y), tileSize, color)\n\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef getKeys():\n\t\t#print 'attempt get keys'\n\t\tDisplay._acquireLock()\n\t\t#print 'get keys'\n\t\tkeys = graphicsUtils.keys_waiting() + graphicsUtils.keys_pressed()\n\t\tDisplay._releaseLock()\n\t\treturn keys\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef graphicsSleep(timeToSleep):\n\t\tgraphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''for _ in range(int(timeToSleep / 0.005)):\n\t\t\t#print 'attempt sleep'\n\t\t\tDisplay._acquireLock()\n\t\t\t#print 'sleep'\n\t\t\tgraphicsUtils.sleep(0.001)\n\t\t\tDisplay._releaseLock()\n\t\t\ttime.sleep(0.004)'''\n\t\t\n\t\t#graphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''startWait = time.time()\n\t\tDisplay._acquireLock()\n\t\ttimeToSleep -= time.time() - startWait\n\t\tgraphicsUtils.refresh()\n\t\tif timeToSleep > 0:\n\t\t\tgraphicsUtils.sleep(timeToSleep)\n\t\tDisplay._releaseLock()'''\n\t\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef updateBelief(color, belief):\n\t\tDisplay._acquireLock()\n\t\ttotal = belief.getSum()\n\t\tif abs(total - 1.0) > 0.001:\n\t\t\traise Exception('belief does not sum to 1 ('+str(total)+'). Use the normalize method.')\n\t\tfor r in range(belief.getNumRows()):\n\t\t\tfor c in range(belief.getNumCols()):\n\t\t\t\tvalue = belief.getProb(r, c)\n\t\t\t\tDisplay._updateBeliefSquare(r, c, value, color)\n\t\tDisplay._releaseLock()\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef move(obj, delta):\n\t\t#print 'attempt move'\n\t\tDisplay._acquireLock()\n\t\t#print 'move'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.move_by(parts, delta.x, delta.y)\n\t\t#print 'end move'\n\t\tDisplay._releaseLock()\n\t\t\n\t# make thread safe\n\t@staticmethod\n\tdef rotate(obj, angle):\n\t\tif angle == 0: return\n\t\t#print 'attempt rotate'\n\t\tDisplay._acquireLock()\n\t\t#print 'rotate'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.rotate_by(parts, angle)\n\t\tDisplay._releaseLock()\n\t\t\t\t\n\t@staticmethod\n\tdef _getBeliefSquareColor(color, value):\n\t\tvalue = min(1.0, value * 15)\n\t\tsaturation = value\n\t\thue = Display.COLOR_HUES[color]\n\t\tr, g, b = colorsys.hsv_to_rgb(hue, saturation, 1.0)\n\t\tcolor = graphicsUtils.formatColor(r, g, b)\n\t\treturn color\t\t\n\t\n\t@staticmethod\n\tdef _isVisible(value):\n\t\treturn value >= Display.VISIBLE_CUTTOFF\n\t\n\t@staticmethod\n\tdef _updateBeliefSquare(r, c, value, colorName):\n\t\tpart = Display.beliefParts[r][c]\n\t\tif part == None: return\n\t\toldValue = Display.beliefValue[r][c]\n\t\toldColor = Display.beliefColor[r][c]\n\t\twasVisible = Display._isVisible(oldValue)\n\t\tisVisible = Display._isVisible(value) \n\t\tif not isVisible: value = 0.0\n\t\tif oldColor != colorName and oldValue >= value: return\n\t\tif not isVisible and not wasVisible: return\n\t\tcolor = Display._getBeliefSquareColor(colorName, value)\n\t\tgraphicsUtils.changeColor(part, color)\n\t\tDisplay.beliefValue[r][c] = value\n\t\tDisplay.beliefColor[r][c] = colorName\n\t\t\n\t@staticmethod\n\tdef _acquireLock():\n\t\treturn\n\t\t#print 'acquire'\n\t\treturn Display.graphicsLock.acquire()\n\t\n\t@staticmethod\n\tdef _releaseLock():\n\t\treturn\n\t\t#print 'release'\n\t\treturn Display.graphicsLock.release()\n\t \n\t####################################\n\t# Depreicated\n\t####################################\n\t\t\n\t@staticmethod\n\tdef _remove(obj):\n\t\tparts = Display.partDict[obj]\n\t\tgraphicsUtils.remove_from_screen(parts);\n\t\t\n\t@staticmethod\n\tdef redrawObservations(observations):\n\t\traise Exception('depreicated')\n\t\tfor obs in Display.observations:\n\t\t\tDisplay._remove(obs)\n\t\tfor obs in observations:\n\t\t\tDisplay.drawObservation(obs)\n\t\tDisplay.observations = observations\n", "description": null, "category": "graphics", "imports": ["import graphicsUtils", "from engine.model.car.car import Car", "from engine.const import Const", "from engine.model.observation import Observation", "from engine.vector import Vec2d", "import colorsys", "import threading"]}], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis widget is an easy starting point for generating multi-panel figures.\n\tExample::\n\t\n\t\tw = pg.GraphicsLayoutWidget()\n\t\tp1 = w.addPlot(row=0, col=0)\n\t\tp2 = w.addPlot(row=0, col=1)\n\t\tv = w.addViewBox(row=1, col=0, colspan=2)\n\t\n\tParameters\n\t----------\n\tparent : QWidget or None\n\t\tThe parent widget (see QWidget.__init__)\n\tshow : bool\n\t\tIf True, then immediately show the widget after it is created.\n\t\tIf the widget has no parent, then it will be shown inside a new window.\n\tsize : (width, height) tuple\n\t\tOptionally resize the widget. Note: if this widget is placed inside a\n\t\tlayout, then this argument has no effect.\n\ttitle : str or None\n\t\tIf specified, then set the window title for this widget.\n\tkargs : \n\t\tAll extra arguments are passed to \n\t\t:func:`GraphicsLayout.__init__() `\n\t\t\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, show=False, size=None, title=None, **kargs):\n\t\tmkQApp()\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n\t\t\n\t\tif size is not None:\n\t\t\tself.resize(*size)\n\t\t\t\n\t\tif title is not None:\n\t\t\tself.setWindowTitle(title)\n\t\t\t\n\t\tif show is True:\n\t\t\tself.show()\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis widget is an easy starting point for generating multi-panel figures.\n\tExample::\n\t\n\t\tw = pg.GraphicsLayoutWidget()\n\t\tp1 = w.addPlot(row=0, col=0)\n\t\tp2 = w.addPlot(row=0, col=1)\n\t\tv = w.addViewBox(row=1, col=0, colspan=2)\n\t\n\tParameters\n\t----------\n\tparent : QWidget or None\n\t\tThe parent widget (see QWidget.__init__)\n\tshow : bool\n\t\tIf True, then immediately show the widget after it is created.\n\t\tIf the widget has no parent, then it will be shown inside a new window.\n\tsize : (width, height) tuple\n\t\tOptionally resize the widget. Note: if this widget is placed inside a\n\t\tlayout, then this argument has no effect.\n\ttitle : str or None\n\t\tIf specified, then set the window title for this widget.\n\tkargs : \n\t\tAll extra arguments are passed to \n\t\t:func:`GraphicsLayout.__init__() `\n\t\t\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui, mkQApp", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [{"term": "def", "name": "tileland_graphics_loader", "data": "def tileland_graphics_loader(path):\n\ttileland_graphics_file_name = os.listdir(path)\n\tfor i in range(0, len(tileland_graphics_file_name)):\n\t\ttileland_graphics_name = str(path) + tileland_graphics_file_name[i]\n\t\tprint(tileland_graphics_name)\n\t\tC.tileland_graphics_path[i] = pygame.image.load(tileland_graphics_name).convert_alpha()\n", "description": null, "category": "graphics", "imports": ["import os", "import pygame", "import moyu_engine.config.constants as C", "import moyu_engine.config.graphics as G"]}], [{"term": "def", "name": "tileland_graphics_loader", "data": "def tileland_graphics_loader(path):\n\ttileland_graphics_file_name = os.listdir(path)\n\tfor i in range(0, len(tileland_graphics_file_name)):\n\t\ttileland_graphics_name = str(path) + tileland_graphics_file_name[i]\n\t\tprint(tileland_graphics_name)\n\t\tC.tileland_graphics_path[i] = pygame.image.load(tileland_graphics_name).convert_alpha()\n", "description": null, "category": "graphics", "imports": ["import os", "import pygame", "import moyu_engine.config.constants as C", "import moyu_engine.config.graphics as G"]}], [{"term": "def", "name": "tileland_graphics_loader", "data": "def tileland_graphics_loader(path):\n\ttileland_graphics_file_name = os.listdir(path)\n\tfor i in range(0, len(tileland_graphics_file_name)):\n\t\ttileland_graphics_name = str(path) + tileland_graphics_file_name[i]\n\t\tprint(tileland_graphics_name)\n\t\tC.tileland_graphics_path[i] = pygame.image.load(tileland_graphics_name).convert_alpha()\n", "description": null, "category": "graphics", "imports": ["import os", "import pygame", "import moyu_engine.config.constants as C", "import moyu_engine.config.graphics as G"]}], [{"term": "def", "name": "tileland_graphics_loader", "data": "def tileland_graphics_loader(path):\n\ttileland_graphics_file_name = os.listdir(path)\n\tfor i in range(0, len(tileland_graphics_file_name)):\n\t\ttileland_graphics_name = str(path) + tileland_graphics_file_name[i]\n\t\tprint(tileland_graphics_name)\n\t\tC.tileland_graphics_path[i] = pygame.image.load(tileland_graphics_name).convert_alpha()\n", "description": null, "category": "graphics", "imports": ["import os", "import pygame", "import moyu_engine.config.constants as C", "import moyu_engine.config.graphics as G"]}], [{"term": "def", "name": "tileland_graphics_loader", "data": "def tileland_graphics_loader(path):\n\ttileland_graphics_file_name = os.listdir(path)\n\tfor i in range(0, len(tileland_graphics_file_name)):\n\t\ttileland_graphics_name = str(path) + tileland_graphics_file_name[i]\n\t\tprint(tileland_graphics_name)\n\t\tC.tileland_graphics_path[i] = pygame.image.load(tileland_graphics_name).convert_alpha()\n", "description": null, "category": "graphics", "imports": ["import os", "import pygame", "import moyu_engine.config.constants as C", "import moyu_engine.config.graphics as G"]}], [{"term": "def", "name": "tileland_graphics_loader", "data": "def tileland_graphics_loader(path):\n\ttileland_graphics_file_name = os.listdir(path)\n\tfor i in range(0, len(tileland_graphics_file_name)):\n\t\ttileland_graphics_name = str(path) + tileland_graphics_file_name[i]\n\t\tprint(tileland_graphics_name)\n\t\tC.tileland_graphics_path[i] = pygame.image.load(tileland_graphics_name).convert_alpha()\n", "description": null, "category": "graphics", "imports": ["import os", "import pygame", "import moyu_engine.config.constants as C", "import moyu_engine.config.graphics as G"]}], [{"term": "def", "name": "tileland_graphics_loader", "data": "def tileland_graphics_loader(path):\n\ttileland_graphics_file_name = os.listdir(path)\n\tfor i in range(0, len(tileland_graphics_file_name)):\n\t\ttileland_graphics_name = str(path) + tileland_graphics_file_name[i]\n\t\tprint(tileland_graphics_name)\n\t\tC.tileland_graphics_path[i] = pygame.image.load(tileland_graphics_name).convert_alpha()\n", "description": null, "category": "graphics", "imports": ["import os", "import pygame", "import moyu_engine.config.constants as C", "import moyu_engine.config.graphics as G"]}], [{"term": "def", "name": "setConfigOption", "data": "def setConfigOption(opt, value):\n\tif opt not in CONFIG_OPTIONS:\n\t\traise KeyError('Unknown configuration option \"%s\"' % opt)\n\tif opt == 'imageAxisOrder' and value not in ('row-major', 'col-major'):\n\t\traise ValueError('imageAxisOrder must be either \"row-major\" or \"col-major\"')\n\tif opt == 'segmentedLineMode' and value not in ('auto', 'on', 'off'):\n\t\traise ValueError('segmentedLineMode must be \"auto\", \"on\" or \"off\"')\n\tCONFIG_OPTIONS[opt] = value\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "import os", "import sys", "import numpy  # # pyqtgraph requires numpy", "from .colors import palette", "from .Qt import QtCore, QtGui, QtWidgets", "from .Qt import exec_ as exec", "from .Qt import mkQApp", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "import atexit", "from .colormap import *", "from .functions import *", "from .graphicsItems.ArrowItem import *", "from .graphicsItems.AxisItem import *", "from .graphicsItems.BarGraphItem import *", "from .graphicsItems.ButtonItem import *", "from .graphicsItems.ColorBarItem import *", "from .graphicsItems.CurvePoint import *", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.ErrorBarItem import *", "from .graphicsItems.FillBetweenItem import *", "from .graphicsItems.GradientEditorItem import *", "from .graphicsItems.GradientLegend import *", "from .graphicsItems.GraphicsItem import *", "from .graphicsItems.GraphicsLayout import *", "from .graphicsItems.GraphicsObject import *", "from .graphicsItems.GraphicsWidget import *", "from .graphicsItems.GraphicsWidgetAnchor import *", "from .graphicsItems.GraphItem import *", "from .graphicsItems.GridItem import *", "from .graphicsItems.HistogramLUTItem import *", "from .graphicsItems.ImageItem import *", "from .graphicsItems.InfiniteLine import *", "from .graphicsItems.IsocurveItem import *", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.LabelItem import *", "from .graphicsItems.LegendItem import *", "from .graphicsItems.LinearRegionItem import *", "from .graphicsItems.MultiPlotItem import *", "from .graphicsItems.PColorMeshItem import *", "from .graphicsItems.PlotCurveItem import *", "from .graphicsItems.PlotDataItem import *", "from .graphicsItems.PlotItem import *", "from .graphicsItems.ROI import *", "from .graphicsItems.ScaleBar import *", "from .graphicsItems.ScatterPlotItem import *", "from .graphicsItems.TargetItem import *", "from .graphicsItems.TextItem import *", "from .graphicsItems.UIGraphicsItem import *", "from .graphicsItems.ViewBox import *", "from .graphicsItems.VTickGroup import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .graphicsWindows import *", "from .imageview import *", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "from .Point import Point", "from .ptime import time", "from .Qt import isQObjectAlive", "from .SignalProxy import *", "from .SRTTransform import SRTTransform", "from .SRTTransform3D import SRTTransform3D", "from .ThreadsafeTimer import *", "from .Transform3D import Transform3D", "from .util.cupy_helper import getCupy", "from .Vector import Vector", "from .WidgetGroup import *", "from .widgets.BusyCursor import *", "from .widgets.CheckTable import *", "from .widgets.ColorButton import *", "from .widgets.ColorMapWidget import *", "from .widgets.ComboBox import *", "from .widgets.DataFilterWidget import *", "from .widgets.DataTreeWidget import *", "from .widgets.DiffTreeWidget import *", "from .widgets.FeedbackButton import *", "from .widgets.FileDialog import *", "from .widgets.GradientWidget import *", "from .widgets.GraphicsLayoutWidget import *", "from .widgets.GraphicsView import *", "from .widgets.GroupBox import GroupBox", "from .widgets.HistogramLUTWidget import *", "from .widgets.JoystickButton import *", "from .widgets.LayoutWidget import *", "from .widgets.MultiPlotWidget import *", "from .widgets.PathButton import *", "from .widgets.PlotWidget import *", "from .widgets.ProgressDialog import *", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .widgets.ScatterPlotWidget import *", "from .widgets.SpinBox import *", "from .widgets.TableWidget import *", "from .widgets.TreeWidget import *", "from .widgets.ValueLabel import *", "from .widgets.VerticalLabel import *", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "setConfigOptions", "data": "def setConfigOptions(**opts):\n\t\"\"\"Set global configuration options. \n\t\n\tEach keyword argument sets one global option. \n\t\"\"\"\n\tfor k,v in opts.items():\n\t\tsetConfigOption(k, v)\n", "description": "Set global configuration options. \n\t\n\tEach keyword argument sets one global option. \n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "import os", "import sys", "import numpy  # # pyqtgraph requires numpy", "from .colors import palette", "from .Qt import QtCore, QtGui, QtWidgets", "from .Qt import exec_ as exec", "from .Qt import mkQApp", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "import atexit", "from .colormap import *", "from .functions import *", "from .graphicsItems.ArrowItem import *", "from .graphicsItems.AxisItem import *", "from .graphicsItems.BarGraphItem import *", "from .graphicsItems.ButtonItem import *", "from .graphicsItems.ColorBarItem import *", "from .graphicsItems.CurvePoint import *", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.ErrorBarItem import *", "from .graphicsItems.FillBetweenItem import *", "from .graphicsItems.GradientEditorItem import *", "from .graphicsItems.GradientLegend import *", "from .graphicsItems.GraphicsItem import *", "from .graphicsItems.GraphicsLayout import *", "from .graphicsItems.GraphicsObject import *", "from .graphicsItems.GraphicsWidget import *", "from .graphicsItems.GraphicsWidgetAnchor import *", "from .graphicsItems.GraphItem import *", "from .graphicsItems.GridItem import *", "from .graphicsItems.HistogramLUTItem import *", "from .graphicsItems.ImageItem import *", "from .graphicsItems.InfiniteLine import *", "from .graphicsItems.IsocurveItem import *", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.LabelItem import *", "from .graphicsItems.LegendItem import *", "from .graphicsItems.LinearRegionItem import *", "from .graphicsItems.MultiPlotItem import *", "from .graphicsItems.PColorMeshItem import *", "from .graphicsItems.PlotCurveItem import *", "from .graphicsItems.PlotDataItem import *", "from .graphicsItems.PlotItem import *", "from .graphicsItems.ROI import *", "from .graphicsItems.ScaleBar import *", "from .graphicsItems.ScatterPlotItem import *", "from .graphicsItems.TargetItem import *", "from .graphicsItems.TextItem import *", "from .graphicsItems.UIGraphicsItem import *", "from .graphicsItems.ViewBox import *", "from .graphicsItems.VTickGroup import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .graphicsWindows import *", "from .imageview import *", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "from .Point import Point", "from .ptime import time", "from .Qt import isQObjectAlive", "from .SignalProxy import *", "from .SRTTransform import SRTTransform", "from .SRTTransform3D import SRTTransform3D", "from .ThreadsafeTimer import *", "from .Transform3D import Transform3D", "from .util.cupy_helper import getCupy", "from .Vector import Vector", "from .WidgetGroup import *", "from .widgets.BusyCursor import *", "from .widgets.CheckTable import *", "from .widgets.ColorButton import *", "from .widgets.ColorMapWidget import *", "from .widgets.ComboBox import *", "from .widgets.DataFilterWidget import *", "from .widgets.DataTreeWidget import *", "from .widgets.DiffTreeWidget import *", "from .widgets.FeedbackButton import *", "from .widgets.FileDialog import *", "from .widgets.GradientWidget import *", "from .widgets.GraphicsLayoutWidget import *", "from .widgets.GraphicsView import *", "from .widgets.GroupBox import GroupBox", "from .widgets.HistogramLUTWidget import *", "from .widgets.JoystickButton import *", "from .widgets.LayoutWidget import *", "from .widgets.MultiPlotWidget import *", "from .widgets.PathButton import *", "from .widgets.PlotWidget import *", "from .widgets.ProgressDialog import *", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .widgets.ScatterPlotWidget import *", "from .widgets.SpinBox import *", "from .widgets.TableWidget import *", "from .widgets.TreeWidget import *", "from .widgets.ValueLabel import *", "from .widgets.VerticalLabel import *", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "getConfigOption", "data": "def getConfigOption(opt):\n\t\"\"\"Return the value of a single global configuration option.\n\t\"\"\"\n\treturn CONFIG_OPTIONS[opt]\n\n", "description": "Return the value of a single global configuration option.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "import os", "import sys", "import numpy  # # pyqtgraph requires numpy", "from .colors import palette", "from .Qt import QtCore, QtGui, QtWidgets", "from .Qt import exec_ as exec", "from .Qt import mkQApp", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "import atexit", "from .colormap import *", "from .functions import *", "from .graphicsItems.ArrowItem import *", "from .graphicsItems.AxisItem import *", "from .graphicsItems.BarGraphItem import *", "from .graphicsItems.ButtonItem import *", "from .graphicsItems.ColorBarItem import *", "from .graphicsItems.CurvePoint import *", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.ErrorBarItem import *", "from .graphicsItems.FillBetweenItem import *", "from .graphicsItems.GradientEditorItem import *", "from .graphicsItems.GradientLegend import *", "from .graphicsItems.GraphicsItem import *", "from .graphicsItems.GraphicsLayout import *", "from .graphicsItems.GraphicsObject import *", "from .graphicsItems.GraphicsWidget import *", "from .graphicsItems.GraphicsWidgetAnchor import *", "from .graphicsItems.GraphItem import *", "from .graphicsItems.GridItem import *", "from .graphicsItems.HistogramLUTItem import *", "from .graphicsItems.ImageItem import *", "from .graphicsItems.InfiniteLine import *", "from .graphicsItems.IsocurveItem import *", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.LabelItem import *", "from .graphicsItems.LegendItem import *", "from .graphicsItems.LinearRegionItem import *", "from .graphicsItems.MultiPlotItem import *", "from .graphicsItems.PColorMeshItem import *", "from .graphicsItems.PlotCurveItem import *", "from .graphicsItems.PlotDataItem import *", "from .graphicsItems.PlotItem import *", "from .graphicsItems.ROI import *", "from .graphicsItems.ScaleBar import *", "from .graphicsItems.ScatterPlotItem import *", "from .graphicsItems.TargetItem import *", "from .graphicsItems.TextItem import *", "from .graphicsItems.UIGraphicsItem import *", "from .graphicsItems.ViewBox import *", "from .graphicsItems.VTickGroup import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .graphicsWindows import *", "from .imageview import *", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "from .Point import Point", "from .ptime import time", "from .Qt import isQObjectAlive", "from .SignalProxy import *", "from .SRTTransform import SRTTransform", "from .SRTTransform3D import SRTTransform3D", "from .ThreadsafeTimer import *", "from .Transform3D import Transform3D", "from .util.cupy_helper import getCupy", "from .Vector import Vector", "from .WidgetGroup import *", "from .widgets.BusyCursor import *", "from .widgets.CheckTable import *", "from .widgets.ColorButton import *", "from .widgets.ColorMapWidget import *", "from .widgets.ComboBox import *", "from .widgets.DataFilterWidget import *", "from .widgets.DataTreeWidget import *", "from .widgets.DiffTreeWidget import *", "from .widgets.FeedbackButton import *", "from .widgets.FileDialog import *", "from .widgets.GradientWidget import *", "from .widgets.GraphicsLayoutWidget import *", "from .widgets.GraphicsView import *", "from .widgets.GroupBox import GroupBox", "from .widgets.HistogramLUTWidget import *", "from .widgets.JoystickButton import *", "from .widgets.LayoutWidget import *", "from .widgets.MultiPlotWidget import *", "from .widgets.PathButton import *", "from .widgets.PlotWidget import *", "from .widgets.ProgressDialog import *", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .widgets.ScatterPlotWidget import *", "from .widgets.SpinBox import *", "from .widgets.TableWidget import *", "from .widgets.TreeWidget import *", "from .widgets.ValueLabel import *", "from .widgets.VerticalLabel import *", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "systemInfo", "data": "def systemInfo():\n\tprint(\"sys.platform: %s\" % sys.platform)\n\tprint(\"sys.version: %s\" % sys.version)\n\tfrom .Qt import VERSION_INFO\n\tprint(\"qt bindings: %s\" % VERSION_INFO)\n\t\n\tglobal __version__\n\trev = None\n\tif __version__ is None:  ## this code was probably checked out from bzr; look up the last-revision file\n\t\tlastRevFile = os.path.join(os.path.dirname(__file__), '..', '.bzr', 'branch', 'last-revision')\n\t\tif os.path.exists(lastRevFile):\n\t\t\twith open(lastRevFile, 'r') as fd:\n\t\t\t\trev = fd.read().strip()\n\t\n\tprint(\"pyqtgraph: %s; %s\" % (__version__, rev))\n\tprint(\"config:\")\n\timport pprint\n\tpprint.pprint(CONFIG_OPTIONS)\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "import os", "import sys", "import numpy  # # pyqtgraph requires numpy", "from .colors import palette", "from .Qt import QtCore, QtGui, QtWidgets", "from .Qt import exec_ as exec", "from .Qt import mkQApp", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "import atexit", "from .colormap import *", "from .functions import *", "from .graphicsItems.ArrowItem import *", "from .graphicsItems.AxisItem import *", "from .graphicsItems.BarGraphItem import *", "from .graphicsItems.ButtonItem import *", "from .graphicsItems.ColorBarItem import *", "from .graphicsItems.CurvePoint import *", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.ErrorBarItem import *", "from .graphicsItems.FillBetweenItem import *", "from .graphicsItems.GradientEditorItem import *", "from .graphicsItems.GradientLegend import *", "from .graphicsItems.GraphicsItem import *", "from .graphicsItems.GraphicsLayout import *", "from .graphicsItems.GraphicsObject import *", "from .graphicsItems.GraphicsWidget import *", "from .graphicsItems.GraphicsWidgetAnchor import *", "from .graphicsItems.GraphItem import *", "from .graphicsItems.GridItem import *", "from .graphicsItems.HistogramLUTItem import *", "from .graphicsItems.ImageItem import *", "from .graphicsItems.InfiniteLine import *", "from .graphicsItems.IsocurveItem import *", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.LabelItem import *", "from .graphicsItems.LegendItem import *", "from .graphicsItems.LinearRegionItem import *", "from .graphicsItems.MultiPlotItem import *", "from .graphicsItems.PColorMeshItem import *", "from .graphicsItems.PlotCurveItem import *", "from .graphicsItems.PlotDataItem import *", "from .graphicsItems.PlotItem import *", "from .graphicsItems.ROI import *", "from .graphicsItems.ScaleBar import *", "from .graphicsItems.ScatterPlotItem import *", "from .graphicsItems.TargetItem import *", "from .graphicsItems.TextItem import *", "from .graphicsItems.UIGraphicsItem import *", "from .graphicsItems.ViewBox import *", "from .graphicsItems.VTickGroup import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .graphicsWindows import *", "from .imageview import *", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "from .Point import Point", "from .ptime import time", "from .Qt import isQObjectAlive", "from .SignalProxy import *", "from .SRTTransform import SRTTransform", "from .SRTTransform3D import SRTTransform3D", "from .ThreadsafeTimer import *", "from .Transform3D import Transform3D", "from .util.cupy_helper import getCupy", "from .Vector import Vector", "from .WidgetGroup import *", "from .widgets.BusyCursor import *", "from .widgets.CheckTable import *", "from .widgets.ColorButton import *", "from .widgets.ColorMapWidget import *", "from .widgets.ComboBox import *", "from .widgets.DataFilterWidget import *", "from .widgets.DataTreeWidget import *", "from .widgets.DiffTreeWidget import *", "from .widgets.FeedbackButton import *", "from .widgets.FileDialog import *", "from .widgets.GradientWidget import *", "from .widgets.GraphicsLayoutWidget import *", "from .widgets.GraphicsView import *", "from .widgets.GroupBox import GroupBox", "from .widgets.HistogramLUTWidget import *", "from .widgets.JoystickButton import *", "from .widgets.LayoutWidget import *", "from .widgets.MultiPlotWidget import *", "from .widgets.PathButton import *", "from .widgets.PlotWidget import *", "from .widgets.ProgressDialog import *", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .widgets.ScatterPlotWidget import *", "from .widgets.SpinBox import *", "from .widgets.TableWidget import *", "from .widgets.TreeWidget import *", "from .widgets.ValueLabel import *", "from .widgets.VerticalLabel import *", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "renamePyc", "data": "def renamePyc(startDir):\n\t### Used to rename orphaned .pyc files\n\t### When a python file changes its location in the repository, usually the .pyc file\n\t### is left behind, possibly causing mysterious and difficult to track bugs. \n\n\t### Note that this is no longer necessary for python 3.2; from PEP 3147:\n\t### \"If the py source file is missing, the pyc file inside __pycache__ will be ignored. \n\t### This eliminates the problem of accidental stale pyc file imports.\"\n\t\n\tprinted = False\n\tstartDir = os.path.abspath(startDir)\n\tfor path, dirs, files in os.walk(startDir):\n\t\tif '__pycache__' in path:\n\t\t\tcontinue\n\t\tfor f in files:\n\t\t\tfileName = os.path.join(path, f)\n\t\t\tbase, ext = os.path.splitext(fileName)\n\t\t\tpy = base + \".py\"\n\t\t\tif ext == '.pyc' and not os.path.isfile(py):\n\t\t\t\tif not printed:\n\t\t\t\t\tprint(\"NOTE: Renaming orphaned .pyc files:\")\n\t\t\t\t\tprinted = True\n\t\t\t\tn = 1\n\t\t\t\twhile True:\n\t\t\t\t\tname2 = fileName + \".renamed%d\" % n\n\t\t\t\t\tif not os.path.exists(name2):\n\t\t\t\t\t\tbreak\n\t\t\t\t\tn += 1\n\t\t\t\tprint(\"  \" + fileName + \"  ==>\")\n\t\t\t\tprint(\"  \" + name2)\n\t\t\t\tos.rename(fileName, name2)\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "import os", "import sys", "import numpy  # # pyqtgraph requires numpy", "from .colors import palette", "from .Qt import QtCore, QtGui, QtWidgets", "from .Qt import exec_ as exec", "from .Qt import mkQApp", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "import atexit", "from .colormap import *", "from .functions import *", "from .graphicsItems.ArrowItem import *", "from .graphicsItems.AxisItem import *", "from .graphicsItems.BarGraphItem import *", "from .graphicsItems.ButtonItem import *", "from .graphicsItems.ColorBarItem import *", "from .graphicsItems.CurvePoint import *", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.ErrorBarItem import *", "from .graphicsItems.FillBetweenItem import *", "from .graphicsItems.GradientEditorItem import *", "from .graphicsItems.GradientLegend import *", "from .graphicsItems.GraphicsItem import *", "from .graphicsItems.GraphicsLayout import *", "from .graphicsItems.GraphicsObject import *", "from .graphicsItems.GraphicsWidget import *", "from .graphicsItems.GraphicsWidgetAnchor import *", "from .graphicsItems.GraphItem import *", "from .graphicsItems.GridItem import *", "from .graphicsItems.HistogramLUTItem import *", "from .graphicsItems.ImageItem import *", "from .graphicsItems.InfiniteLine import *", "from .graphicsItems.IsocurveItem import *", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.LabelItem import *", "from .graphicsItems.LegendItem import *", "from .graphicsItems.LinearRegionItem import *", "from .graphicsItems.MultiPlotItem import *", "from .graphicsItems.PColorMeshItem import *", "from .graphicsItems.PlotCurveItem import *", "from .graphicsItems.PlotDataItem import *", "from .graphicsItems.PlotItem import *", "from .graphicsItems.ROI import *", "from .graphicsItems.ScaleBar import *", "from .graphicsItems.ScatterPlotItem import *", "from .graphicsItems.TargetItem import *", "from .graphicsItems.TextItem import *", "from .graphicsItems.UIGraphicsItem import *", "from .graphicsItems.ViewBox import *", "from .graphicsItems.VTickGroup import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .graphicsWindows import *", "from .imageview import *", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "from .Point import Point", "from .ptime import time", "from .Qt import isQObjectAlive", "from .SignalProxy import *", "from .SRTTransform import SRTTransform", "from .SRTTransform3D import SRTTransform3D", "from .ThreadsafeTimer import *", "from .Transform3D import Transform3D", "from .util.cupy_helper import getCupy", "from .Vector import Vector", "from .WidgetGroup import *", "from .widgets.BusyCursor import *", "from .widgets.CheckTable import *", "from .widgets.ColorButton import *", "from .widgets.ColorMapWidget import *", "from .widgets.ComboBox import *", "from .widgets.DataFilterWidget import *", "from .widgets.DataTreeWidget import *", "from .widgets.DiffTreeWidget import *", "from .widgets.FeedbackButton import *", "from .widgets.FileDialog import *", "from .widgets.GradientWidget import *", "from .widgets.GraphicsLayoutWidget import *", "from .widgets.GraphicsView import *", "from .widgets.GroupBox import GroupBox", "from .widgets.HistogramLUTWidget import *", "from .widgets.JoystickButton import *", "from .widgets.LayoutWidget import *", "from .widgets.MultiPlotWidget import *", "from .widgets.PathButton import *", "from .widgets.PlotWidget import *", "from .widgets.ProgressDialog import *", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .widgets.ScatterPlotWidget import *", "from .widgets.SpinBox import *", "from .widgets.TableWidget import *", "from .widgets.TreeWidget import *", "from .widgets.ValueLabel import *", "from .widgets.VerticalLabel import *", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "fimportModules", "data": "#def importModules(path, globals, locals, excludes=()):\n\t#\"\"\"Import all modules residing within *path*, return a dict of name: module pairs.\n\t\n\t#Note that *path* MUST be relative to the module doing the import.\t\n\t#\"\"\"\n\t#d = os.path.join(os.path.split(globals['__file__'])[0], path)\n\t#files = set()\n\t#for f in frozenSupport.listdir(d):\n\t\t#if frozenSupport.isdir(os.path.join(d, f)) and f not in ['__pycache__', 'tests']:\n\t\t\t#files.add(f)\n\t\t#elif f[-3:] == '.py' and f != '__init__.py':\n\t\t\t#files.add(f[:-3])\n\t\t#elif f[-4:] == '.pyc' and f != '__init__.pyc':\n\t\t\t#files.add(f[:-4])\n\t\t\n\t#mods = {}\n\t#path = path.replace(os.sep, '.')\n\t#for modName in files:\n\t\t#if modName in excludes:\n\t\t\t#continue\n\t\t#try:\n\t\t\t#if len(path) > 0:\n\t\t\t\t#modName = path + '.' + modName\n\t\t\t#print( \"from .%s import * \" % modName)\n\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\n\t\t\t#mods[modName] = mod\n\t\t#except:\n\t\t\t#import traceback\n\t\t\t#traceback.print_stack()\n\t\t\t#sys.excepthook(*sys.exc_info())\n\t\t\t#print(\"[Error importing module: %s]\" % modName)\n\t\t\t\n\t#return mods\n", "description": "Import all modules residing within *path*, return a dict of name: module pairs.\n\t\n\t#Note that *path* MUST be relative to the module doing the import.\t\n\t#", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "import os", "import sys", "import numpy  # # pyqtgraph requires numpy", "from .colors import palette", "from .Qt import QtCore, QtGui, QtWidgets", "from .Qt import exec_ as exec", "from .Qt import mkQApp", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "import atexit", "from .colormap import *", "from .functions import *", "from .graphicsItems.ArrowItem import *", "from .graphicsItems.AxisItem import *", "from .graphicsItems.BarGraphItem import *", "from .graphicsItems.ButtonItem import *", "from .graphicsItems.ColorBarItem import *", "from .graphicsItems.CurvePoint import *", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.ErrorBarItem import *", "from .graphicsItems.FillBetweenItem import *", "from .graphicsItems.GradientEditorItem import *", "from .graphicsItems.GradientLegend import *", "from .graphicsItems.GraphicsItem import *", "from .graphicsItems.GraphicsLayout import *", "from .graphicsItems.GraphicsObject import *", "from .graphicsItems.GraphicsWidget import *", "from .graphicsItems.GraphicsWidgetAnchor import *", "from .graphicsItems.GraphItem import *", "from .graphicsItems.GridItem import *", "from .graphicsItems.HistogramLUTItem import *", "from .graphicsItems.ImageItem import *", "from .graphicsItems.InfiniteLine import *", "from .graphicsItems.IsocurveItem import *", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.LabelItem import *", "from .graphicsItems.LegendItem import *", "from .graphicsItems.LinearRegionItem import *", "from .graphicsItems.MultiPlotItem import *", "from .graphicsItems.PColorMeshItem import *", "from .graphicsItems.PlotCurveItem import *", "from .graphicsItems.PlotDataItem import *", "from .graphicsItems.PlotItem import *", "from .graphicsItems.ROI import *", "from .graphicsItems.ScaleBar import *", "from .graphicsItems.ScatterPlotItem import *", "from .graphicsItems.TargetItem import *", "from .graphicsItems.TextItem import *", "from .graphicsItems.UIGraphicsItem import *", "from .graphicsItems.ViewBox import *", "from .graphicsItems.VTickGroup import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .graphicsWindows import *", "from .imageview import *", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "from .Point import Point", "from .ptime import time", "from .Qt import isQObjectAlive", "from .SignalProxy import *", "from .SRTTransform import SRTTransform", "from .SRTTransform3D import SRTTransform3D", "from .ThreadsafeTimer import *", "from .Transform3D import Transform3D", "from .util.cupy_helper import getCupy", "from .Vector import Vector", "from .WidgetGroup import *", "from .widgets.BusyCursor import *", "from .widgets.CheckTable import *", "from .widgets.ColorButton import *", "from .widgets.ColorMapWidget import *", "from .widgets.ComboBox import *", "from .widgets.DataFilterWidget import *", "from .widgets.DataTreeWidget import *", "from .widgets.DiffTreeWidget import *", "from .widgets.FeedbackButton import *", "from .widgets.FileDialog import *", "from .widgets.GradientWidget import *", "from .widgets.GraphicsLayoutWidget import *", "from .widgets.GraphicsView import *", "from .widgets.GroupBox import GroupBox", "from .widgets.HistogramLUTWidget import *", "from .widgets.JoystickButton import *", "from .widgets.LayoutWidget import *", "from .widgets.MultiPlotWidget import *", "from .widgets.PathButton import *", "from .widgets.PlotWidget import *", "from .widgets.ProgressDialog import *", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .widgets.ScatterPlotWidget import *", "from .widgets.SpinBox import *", "from .widgets.TableWidget import *", "from .widgets.TreeWidget import *", "from .widgets.ValueLabel import *", "from .widgets.VerticalLabel import *", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "fimportAll", "data": "#def importAll(path, globals, locals, excludes=()):\n\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\n\t#mods = importModules(path, globals, locals, excludes)\n\t#for mod in mods.values():\n\t\t#if hasattr(mod, '__all__'):\n\t\t\t#names = mod.__all__\n\t\t#else:\n\t\t\t#names = [n for n in dir(mod) if n[0] != '_']\n\t\t#for k in names:\n\t\t\t#if hasattr(mod, k):\n\t\t\t\t#globals[k] = getattr(mod, k)\n", "description": "Given a list of modules, import all names from each module into the global namespace.", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "import os", "import sys", "import numpy  # # pyqtgraph requires numpy", "from .colors import palette", "from .Qt import QtCore, QtGui, QtWidgets", "from .Qt import exec_ as exec", "from .Qt import mkQApp", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "import atexit", "from .colormap import *", "from .functions import *", "from .graphicsItems.ArrowItem import *", "from .graphicsItems.AxisItem import *", "from .graphicsItems.BarGraphItem import *", "from .graphicsItems.ButtonItem import *", "from .graphicsItems.ColorBarItem import *", "from .graphicsItems.CurvePoint import *", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.ErrorBarItem import *", "from .graphicsItems.FillBetweenItem import *", "from .graphicsItems.GradientEditorItem import *", "from .graphicsItems.GradientLegend import *", "from .graphicsItems.GraphicsItem import *", "from .graphicsItems.GraphicsLayout import *", "from .graphicsItems.GraphicsObject import *", "from .graphicsItems.GraphicsWidget import *", "from .graphicsItems.GraphicsWidgetAnchor import *", "from .graphicsItems.GraphItem import *", "from .graphicsItems.GridItem import *", "from .graphicsItems.HistogramLUTItem import *", "from .graphicsItems.ImageItem import *", "from .graphicsItems.InfiniteLine import *", "from .graphicsItems.IsocurveItem import *", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.LabelItem import *", "from .graphicsItems.LegendItem import *", "from .graphicsItems.LinearRegionItem import *", "from .graphicsItems.MultiPlotItem import *", "from .graphicsItems.PColorMeshItem import *", "from .graphicsItems.PlotCurveItem import *", "from .graphicsItems.PlotDataItem import *", "from .graphicsItems.PlotItem import *", "from .graphicsItems.ROI import *", "from .graphicsItems.ScaleBar import *", "from .graphicsItems.ScatterPlotItem import *", "from .graphicsItems.TargetItem import *", "from .graphicsItems.TextItem import *", "from .graphicsItems.UIGraphicsItem import *", "from .graphicsItems.ViewBox import *", "from .graphicsItems.VTickGroup import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .graphicsWindows import *", "from .imageview import *", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "from .Point import Point", "from .ptime import time", "from .Qt import isQObjectAlive", "from .SignalProxy import *", "from .SRTTransform import SRTTransform", "from .SRTTransform3D import SRTTransform3D", "from .ThreadsafeTimer import *", "from .Transform3D import Transform3D", "from .util.cupy_helper import getCupy", "from .Vector import Vector", "from .WidgetGroup import *", "from .widgets.BusyCursor import *", "from .widgets.CheckTable import *", "from .widgets.ColorButton import *", "from .widgets.ColorMapWidget import *", "from .widgets.ComboBox import *", "from .widgets.DataFilterWidget import *", "from .widgets.DataTreeWidget import *", "from .widgets.DiffTreeWidget import *", "from .widgets.FeedbackButton import *", "from .widgets.FileDialog import *", "from .widgets.GradientWidget import *", "from .widgets.GraphicsLayoutWidget import *", "from .widgets.GraphicsView import *", "from .widgets.GroupBox import GroupBox", "from .widgets.HistogramLUTWidget import *", "from .widgets.JoystickButton import *", "from .widgets.LayoutWidget import *", "from .widgets.MultiPlotWidget import *", "from .widgets.PathButton import *", "from .widgets.PlotWidget import *", "from .widgets.ProgressDialog import *", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .widgets.ScatterPlotWidget import *", "from .widgets.SpinBox import *", "from .widgets.TableWidget import *", "from .widgets.TreeWidget import *", "from .widgets.ValueLabel import *", "from .widgets.VerticalLabel import *", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "cleanup", "data": "def cleanup():\n\tglobal _cleanupCalled\n\tif _cleanupCalled:\n\t\treturn\n\t\n\tif not getConfigOption('exitCleanup'):\n\t\treturn\n\t\n\tViewBox.quit()  ## tell ViewBox that it doesn't need to deregister views anymore.\n\t\n\t## Workaround for Qt exit crash:\n\t## ALL QGraphicsItems must have a scene before they are deleted.\n\t## This is potentially very expensive, but preferred over crashing.\n\t## Note: this appears to be fixed in PySide as of 2012.12, but it should be left in for a while longer..\n\tapp = QtWidgets.QApplication.instance()\n\tif app is None or not isinstance(app, QtWidgets.QApplication):\n\t\t# app was never constructed is already deleted or is an\n\t\t# QCoreApplication/QGuiApplication and not a full QApplication\n\t\treturn\n\timport gc\n\ts = QtWidgets.QGraphicsScene()\n\tfor o in gc.get_objects():\n\t\ttry:\n\t\t\tif isinstance(o, QtWidgets.QGraphicsItem) and isQObjectAlive(o) and o.scene() is None:\n\t\t\t\tif getConfigOption('crashWarning'):\n\t\t\t\t\tsys.stderr.write('Error: graphics item without scene. '\n\t\t\t\t\t\t'Make sure ViewBox.close() and GraphicsView.close() '\n\t\t\t\t\t\t'are properly called before app shutdown (%s)\\n' % (o,))\n\t\t\t\t\n\t\t\t\ts.addItem(o)\n\t\texcept (RuntimeError, ReferenceError):  ## occurs if a python wrapper no longer has its underlying C++ object\n\t\t\tcontinue\n\t_cleanupCalled = True\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "import os", "import sys", "import numpy  # # pyqtgraph requires numpy", "from .colors import palette", "from .Qt import QtCore, QtGui, QtWidgets", "from .Qt import exec_ as exec", "from .Qt import mkQApp", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "import atexit", "from .colormap import *", "from .functions import *", "from .graphicsItems.ArrowItem import *", "from .graphicsItems.AxisItem import *", "from .graphicsItems.BarGraphItem import *", "from .graphicsItems.ButtonItem import *", "from .graphicsItems.ColorBarItem import *", "from .graphicsItems.CurvePoint import *", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.ErrorBarItem import *", "from .graphicsItems.FillBetweenItem import *", "from .graphicsItems.GradientEditorItem import *", "from .graphicsItems.GradientLegend import *", "from .graphicsItems.GraphicsItem import *", "from .graphicsItems.GraphicsLayout import *", "from .graphicsItems.GraphicsObject import *", "from .graphicsItems.GraphicsWidget import *", "from .graphicsItems.GraphicsWidgetAnchor import *", "from .graphicsItems.GraphItem import *", "from .graphicsItems.GridItem import *", "from .graphicsItems.HistogramLUTItem import *", "from .graphicsItems.ImageItem import *", "from .graphicsItems.InfiniteLine import *", "from .graphicsItems.IsocurveItem import *", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.LabelItem import *", "from .graphicsItems.LegendItem import *", "from .graphicsItems.LinearRegionItem import *", "from .graphicsItems.MultiPlotItem import *", "from .graphicsItems.PColorMeshItem import *", "from .graphicsItems.PlotCurveItem import *", "from .graphicsItems.PlotDataItem import *", "from .graphicsItems.PlotItem import *", "from .graphicsItems.ROI import *", "from .graphicsItems.ScaleBar import *", "from .graphicsItems.ScatterPlotItem import *", "from .graphicsItems.TargetItem import *", "from .graphicsItems.TextItem import *", "from .graphicsItems.UIGraphicsItem import *", "from .graphicsItems.ViewBox import *", "from .graphicsItems.VTickGroup import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .graphicsWindows import *", "from .imageview import *", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "from .Point import Point", "from .ptime import time", "from .Qt import isQObjectAlive", "from .SignalProxy import *", "from .SRTTransform import SRTTransform", "from .SRTTransform3D import SRTTransform3D", "from .ThreadsafeTimer import *", "from .Transform3D import Transform3D", "from .util.cupy_helper import getCupy", "from .Vector import Vector", "from .WidgetGroup import *", "from .widgets.BusyCursor import *", "from .widgets.CheckTable import *", "from .widgets.ColorButton import *", "from .widgets.ColorMapWidget import *", "from .widgets.ComboBox import *", "from .widgets.DataFilterWidget import *", "from .widgets.DataTreeWidget import *", "from .widgets.DiffTreeWidget import *", "from .widgets.FeedbackButton import *", "from .widgets.FileDialog import *", "from .widgets.GradientWidget import *", "from .widgets.GraphicsLayoutWidget import *", "from .widgets.GraphicsView import *", "from .widgets.GroupBox import GroupBox", "from .widgets.HistogramLUTWidget import *", "from .widgets.JoystickButton import *", "from .widgets.LayoutWidget import *", "from .widgets.MultiPlotWidget import *", "from .widgets.PathButton import *", "from .widgets.PlotWidget import *", "from .widgets.ProgressDialog import *", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .widgets.ScatterPlotWidget import *", "from .widgets.SpinBox import *", "from .widgets.TableWidget import *", "from .widgets.TreeWidget import *", "from .widgets.ValueLabel import *", "from .widgets.VerticalLabel import *", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "_connectCleanup", "data": "def _connectCleanup():\n\tglobal _cleanupConnected\n\tif _cleanupConnected:\n\t\treturn\n\tQtWidgets.QApplication.instance().aboutToQuit.connect(cleanup)\n\t_cleanupConnected = True\n\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "import os", "import sys", "import numpy  # # pyqtgraph requires numpy", "from .colors import palette", "from .Qt import QtCore, QtGui, QtWidgets", "from .Qt import exec_ as exec", "from .Qt import mkQApp", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "import atexit", "from .colormap import *", "from .functions import *", "from .graphicsItems.ArrowItem import *", "from .graphicsItems.AxisItem import *", "from .graphicsItems.BarGraphItem import *", "from .graphicsItems.ButtonItem import *", "from .graphicsItems.ColorBarItem import *", "from .graphicsItems.CurvePoint import *", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.ErrorBarItem import *", "from .graphicsItems.FillBetweenItem import *", "from .graphicsItems.GradientEditorItem import *", "from .graphicsItems.GradientLegend import *", "from .graphicsItems.GraphicsItem import *", "from .graphicsItems.GraphicsLayout import *", "from .graphicsItems.GraphicsObject import *", "from .graphicsItems.GraphicsWidget import *", "from .graphicsItems.GraphicsWidgetAnchor import *", "from .graphicsItems.GraphItem import *", "from .graphicsItems.GridItem import *", "from .graphicsItems.HistogramLUTItem import *", "from .graphicsItems.ImageItem import *", "from .graphicsItems.InfiniteLine import *", "from .graphicsItems.IsocurveItem import *", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.LabelItem import *", "from .graphicsItems.LegendItem import *", "from .graphicsItems.LinearRegionItem import *", "from .graphicsItems.MultiPlotItem import *", "from .graphicsItems.PColorMeshItem import *", "from .graphicsItems.PlotCurveItem import *", "from .graphicsItems.PlotDataItem import *", "from .graphicsItems.PlotItem import *", "from .graphicsItems.ROI import *", "from .graphicsItems.ScaleBar import *", "from .graphicsItems.ScatterPlotItem import *", "from .graphicsItems.TargetItem import *", "from .graphicsItems.TextItem import *", "from .graphicsItems.UIGraphicsItem import *", "from .graphicsItems.ViewBox import *", "from .graphicsItems.VTickGroup import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .graphicsWindows import *", "from .imageview import *", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "from .Point import Point", "from .ptime import time", "from .Qt import isQObjectAlive", "from .SignalProxy import *", "from .SRTTransform import SRTTransform", "from .SRTTransform3D import SRTTransform3D", "from .ThreadsafeTimer import *", "from .Transform3D import Transform3D", "from .util.cupy_helper import getCupy", "from .Vector import Vector", "from .WidgetGroup import *", "from .widgets.BusyCursor import *", "from .widgets.CheckTable import *", "from .widgets.ColorButton import *", "from .widgets.ColorMapWidget import *", "from .widgets.ComboBox import *", "from .widgets.DataFilterWidget import *", "from .widgets.DataTreeWidget import *", "from .widgets.DiffTreeWidget import *", "from .widgets.FeedbackButton import *", "from .widgets.FileDialog import *", "from .widgets.GradientWidget import *", "from .widgets.GraphicsLayoutWidget import *", "from .widgets.GraphicsView import *", "from .widgets.GroupBox import GroupBox", "from .widgets.HistogramLUTWidget import *", "from .widgets.JoystickButton import *", "from .widgets.LayoutWidget import *", "from .widgets.MultiPlotWidget import *", "from .widgets.PathButton import *", "from .widgets.PlotWidget import *", "from .widgets.ProgressDialog import *", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .widgets.ScatterPlotWidget import *", "from .widgets.SpinBox import *", "from .widgets.TableWidget import *", "from .widgets.TreeWidget import *", "from .widgets.ValueLabel import *", "from .widgets.VerticalLabel import *", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "exit", "data": "def exit():\n\t\"\"\"\n\tCauses python to exit without garbage-collecting any objects, and thus avoids\n\tcalling object destructor methods. This is a sledgehammer workaround for \n\ta variety of bugs in PyQt and Pyside that cause crashes on exit.\n\t\n\tThis function does the following in an attempt to 'safely' terminate\n\tthe process:\n\t\n\t  * Invoke atexit callbacks\n\t  * Close all open file handles\n\t  * os._exit()\n\t\n\tNote: there is some potential for causing damage with this function if you\n\tare using objects that _require_ their destructors to be called (for example,\n\tto properly terminate log files, disconnect from devices, etc). Situations\n\tlike this are probably quite rare, but use at your own risk.\n\t\"\"\"\n\t\n\t## first disable our own cleanup function; won't be needing it.\n\tsetConfigOptions(exitCleanup=False)\n\t\n\t## invoke atexit callbacks\n\tatexit._run_exitfuncs()\n\t\n\t## close file handles\n\tif sys.platform == 'darwin':\n\t\tfor fd in range(3, 4096):\n\t\t\tif fd in [7]:  # trying to close 7 produces an illegal instruction on the Mac.\n\t\t\t\tcontinue\n\t\t\ttry:\n\t\t\t\tos.close(fd)\n\t\t\texcept OSError:\n\t\t\t\tpass\n\telse:\n\t\tos.closerange(3, 4096) ## just guessing on the maximum descriptor count..\n\n\tos._exit(0)\n\t\n", "description": "\n\tCauses python to exit without garbage-collecting any objects, and thus avoids\n\tcalling object destructor methods. This is a sledgehammer workaround for \n\ta variety of bugs in PyQt and Pyside that cause crashes on exit.\n\t\n\tThis function does the following in an attempt to 'safely' terminate\n\tthe process:\n\t\n\t  * Invoke atexit callbacks\n\t  * Close all open file handles\n\t  * os._exit()\n\t\n\tNote: there is some potential for causing damage with this function if you\n\tare using objects that _require_ their destructors to be called (for example,\n\tto properly terminate log files, disconnect from devices, etc). Situations\n\tlike this are probably quite rare, but use at your own risk.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "import os", "import sys", "import numpy  # # pyqtgraph requires numpy", "from .colors import palette", "from .Qt import QtCore, QtGui, QtWidgets", "from .Qt import exec_ as exec", "from .Qt import mkQApp", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "import atexit", "from .colormap import *", "from .functions import *", "from .graphicsItems.ArrowItem import *", "from .graphicsItems.AxisItem import *", "from .graphicsItems.BarGraphItem import *", "from .graphicsItems.ButtonItem import *", "from .graphicsItems.ColorBarItem import *", "from .graphicsItems.CurvePoint import *", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.ErrorBarItem import *", "from .graphicsItems.FillBetweenItem import *", "from .graphicsItems.GradientEditorItem import *", "from .graphicsItems.GradientLegend import *", "from .graphicsItems.GraphicsItem import *", "from .graphicsItems.GraphicsLayout import *", "from .graphicsItems.GraphicsObject import *", "from .graphicsItems.GraphicsWidget import *", "from .graphicsItems.GraphicsWidgetAnchor import *", "from .graphicsItems.GraphItem import *", "from .graphicsItems.GridItem import *", "from .graphicsItems.HistogramLUTItem import *", "from .graphicsItems.ImageItem import *", "from .graphicsItems.InfiniteLine import *", "from .graphicsItems.IsocurveItem import *", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.LabelItem import *", "from .graphicsItems.LegendItem import *", "from .graphicsItems.LinearRegionItem import *", "from .graphicsItems.MultiPlotItem import *", "from .graphicsItems.PColorMeshItem import *", "from .graphicsItems.PlotCurveItem import *", "from .graphicsItems.PlotDataItem import *", "from .graphicsItems.PlotItem import *", "from .graphicsItems.ROI import *", "from .graphicsItems.ScaleBar import *", "from .graphicsItems.ScatterPlotItem import *", "from .graphicsItems.TargetItem import *", "from .graphicsItems.TextItem import *", "from .graphicsItems.UIGraphicsItem import *", "from .graphicsItems.ViewBox import *", "from .graphicsItems.VTickGroup import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .graphicsWindows import *", "from .imageview import *", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "from .Point import Point", "from .ptime import time", "from .Qt import isQObjectAlive", "from .SignalProxy import *", "from .SRTTransform import SRTTransform", "from .SRTTransform3D import SRTTransform3D", "from .ThreadsafeTimer import *", "from .Transform3D import Transform3D", "from .util.cupy_helper import getCupy", "from .Vector import Vector", "from .WidgetGroup import *", "from .widgets.BusyCursor import *", "from .widgets.CheckTable import *", "from .widgets.ColorButton import *", "from .widgets.ColorMapWidget import *", "from .widgets.ComboBox import *", "from .widgets.DataFilterWidget import *", "from .widgets.DataTreeWidget import *", "from .widgets.DiffTreeWidget import *", "from .widgets.FeedbackButton import *", "from .widgets.FileDialog import *", "from .widgets.GradientWidget import *", "from .widgets.GraphicsLayoutWidget import *", "from .widgets.GraphicsView import *", "from .widgets.GroupBox import GroupBox", "from .widgets.HistogramLUTWidget import *", "from .widgets.JoystickButton import *", "from .widgets.LayoutWidget import *", "from .widgets.MultiPlotWidget import *", "from .widgets.PathButton import *", "from .widgets.PlotWidget import *", "from .widgets.ProgressDialog import *", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .widgets.ScatterPlotWidget import *", "from .widgets.SpinBox import *", "from .widgets.TableWidget import *", "from .widgets.TreeWidget import *", "from .widgets.ValueLabel import *", "from .widgets.VerticalLabel import *", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "plot", "data": "def plot(*args, **kargs):\n\t\"\"\"\n\tCreate and return a :class:`PlotWidget ` \n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to plot data. (see :func:`PlotItem.plot() `)\n\t\"\"\"\n\tmkQApp()\n\tpwArgList = ['title', 'labels', 'name', 'left', 'right', 'top', 'bottom', 'background']\n\tpwArgs = {}\n\tdataArgs = {}\n\tfor k in kargs:\n\t\tif k in pwArgList:\n\t\t\tpwArgs[k] = kargs[k]\n\t\telse:\n\t\t\tdataArgs[k] = kargs[k]\n\twindowTitle = pwArgs.pop(\"title\", \"PlotWidget\")\n\tw = PlotWidget(**pwArgs)\n\tw.setWindowTitle(windowTitle)\n\tif len(args) > 0 or len(dataArgs) > 0:\n\t\tw.plot(*args, **dataArgs)\n\tplots.append(w)\n\tw.show()\n\treturn w\n", "description": "\n\tCreate and return a :class:`PlotWidget ` \n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to plot data. (see :func:`PlotItem.plot() `)\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "import os", "import sys", "import numpy  # # pyqtgraph requires numpy", "from .colors import palette", "from .Qt import QtCore, QtGui, QtWidgets", "from .Qt import exec_ as exec", "from .Qt import mkQApp", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "import atexit", "from .colormap import *", "from .functions import *", "from .graphicsItems.ArrowItem import *", "from .graphicsItems.AxisItem import *", "from .graphicsItems.BarGraphItem import *", "from .graphicsItems.ButtonItem import *", "from .graphicsItems.ColorBarItem import *", "from .graphicsItems.CurvePoint import *", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.ErrorBarItem import *", "from .graphicsItems.FillBetweenItem import *", "from .graphicsItems.GradientEditorItem import *", "from .graphicsItems.GradientLegend import *", "from .graphicsItems.GraphicsItem import *", "from .graphicsItems.GraphicsLayout import *", "from .graphicsItems.GraphicsObject import *", "from .graphicsItems.GraphicsWidget import *", "from .graphicsItems.GraphicsWidgetAnchor import *", "from .graphicsItems.GraphItem import *", "from .graphicsItems.GridItem import *", "from .graphicsItems.HistogramLUTItem import *", "from .graphicsItems.ImageItem import *", "from .graphicsItems.InfiniteLine import *", "from .graphicsItems.IsocurveItem import *", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.LabelItem import *", "from .graphicsItems.LegendItem import *", "from .graphicsItems.LinearRegionItem import *", "from .graphicsItems.MultiPlotItem import *", "from .graphicsItems.PColorMeshItem import *", "from .graphicsItems.PlotCurveItem import *", "from .graphicsItems.PlotDataItem import *", "from .graphicsItems.PlotItem import *", "from .graphicsItems.ROI import *", "from .graphicsItems.ScaleBar import *", "from .graphicsItems.ScatterPlotItem import *", "from .graphicsItems.TargetItem import *", "from .graphicsItems.TextItem import *", "from .graphicsItems.UIGraphicsItem import *", "from .graphicsItems.ViewBox import *", "from .graphicsItems.VTickGroup import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .graphicsWindows import *", "from .imageview import *", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "from .Point import Point", "from .ptime import time", "from .Qt import isQObjectAlive", "from .SignalProxy import *", "from .SRTTransform import SRTTransform", "from .SRTTransform3D import SRTTransform3D", "from .ThreadsafeTimer import *", "from .Transform3D import Transform3D", "from .util.cupy_helper import getCupy", "from .Vector import Vector", "from .WidgetGroup import *", "from .widgets.BusyCursor import *", "from .widgets.CheckTable import *", "from .widgets.ColorButton import *", "from .widgets.ColorMapWidget import *", "from .widgets.ComboBox import *", "from .widgets.DataFilterWidget import *", "from .widgets.DataTreeWidget import *", "from .widgets.DiffTreeWidget import *", "from .widgets.FeedbackButton import *", "from .widgets.FileDialog import *", "from .widgets.GradientWidget import *", "from .widgets.GraphicsLayoutWidget import *", "from .widgets.GraphicsView import *", "from .widgets.GroupBox import GroupBox", "from .widgets.HistogramLUTWidget import *", "from .widgets.JoystickButton import *", "from .widgets.LayoutWidget import *", "from .widgets.MultiPlotWidget import *", "from .widgets.PathButton import *", "from .widgets.PlotWidget import *", "from .widgets.ProgressDialog import *", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .widgets.ScatterPlotWidget import *", "from .widgets.SpinBox import *", "from .widgets.TableWidget import *", "from .widgets.TreeWidget import *", "from .widgets.ValueLabel import *", "from .widgets.VerticalLabel import *", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "image", "data": "def image(*args, **kargs):\n\t\"\"\"\n\tCreate and return an :class:`ImageView ` \n\tWill show 2D or 3D image data.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to show data. (see :func:`ImageView.setImage() `)\n\t\"\"\"\n\tmkQApp()\n\tw = ImageView()\n\twindowTitle = kargs.pop(\"title\", \"ImageView\")\n\tw.setWindowTitle(windowTitle)\n\tw.setImage(*args, **kargs)\n\timages.append(w)\n\tw.show()\n", "description": "\n\tCreate and return an :class:`ImageView ` \n\tWill show 2D or 3D image data.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to show data. (see :func:`ImageView.setImage() `)\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "import os", "import sys", "import numpy  # # pyqtgraph requires numpy", "from .colors import palette", "from .Qt import QtCore, QtGui, QtWidgets", "from .Qt import exec_ as exec", "from .Qt import mkQApp", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "import atexit", "from .colormap import *", "from .functions import *", "from .graphicsItems.ArrowItem import *", "from .graphicsItems.AxisItem import *", "from .graphicsItems.BarGraphItem import *", "from .graphicsItems.ButtonItem import *", "from .graphicsItems.ColorBarItem import *", "from .graphicsItems.CurvePoint import *", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.ErrorBarItem import *", "from .graphicsItems.FillBetweenItem import *", "from .graphicsItems.GradientEditorItem import *", "from .graphicsItems.GradientLegend import *", "from .graphicsItems.GraphicsItem import *", "from .graphicsItems.GraphicsLayout import *", "from .graphicsItems.GraphicsObject import *", "from .graphicsItems.GraphicsWidget import *", "from .graphicsItems.GraphicsWidgetAnchor import *", "from .graphicsItems.GraphItem import *", "from .graphicsItems.GridItem import *", "from .graphicsItems.HistogramLUTItem import *", "from .graphicsItems.ImageItem import *", "from .graphicsItems.InfiniteLine import *", "from .graphicsItems.IsocurveItem import *", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.LabelItem import *", "from .graphicsItems.LegendItem import *", "from .graphicsItems.LinearRegionItem import *", "from .graphicsItems.MultiPlotItem import *", "from .graphicsItems.PColorMeshItem import *", "from .graphicsItems.PlotCurveItem import *", "from .graphicsItems.PlotDataItem import *", "from .graphicsItems.PlotItem import *", "from .graphicsItems.ROI import *", "from .graphicsItems.ScaleBar import *", "from .graphicsItems.ScatterPlotItem import *", "from .graphicsItems.TargetItem import *", "from .graphicsItems.TextItem import *", "from .graphicsItems.UIGraphicsItem import *", "from .graphicsItems.ViewBox import *", "from .graphicsItems.VTickGroup import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .graphicsWindows import *", "from .imageview import *", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "from .Point import Point", "from .ptime import time", "from .Qt import isQObjectAlive", "from .SignalProxy import *", "from .SRTTransform import SRTTransform", "from .SRTTransform3D import SRTTransform3D", "from .ThreadsafeTimer import *", "from .Transform3D import Transform3D", "from .util.cupy_helper import getCupy", "from .Vector import Vector", "from .WidgetGroup import *", "from .widgets.BusyCursor import *", "from .widgets.CheckTable import *", "from .widgets.ColorButton import *", "from .widgets.ColorMapWidget import *", "from .widgets.ComboBox import *", "from .widgets.DataFilterWidget import *", "from .widgets.DataTreeWidget import *", "from .widgets.DiffTreeWidget import *", "from .widgets.FeedbackButton import *", "from .widgets.FileDialog import *", "from .widgets.GradientWidget import *", "from .widgets.GraphicsLayoutWidget import *", "from .widgets.GraphicsView import *", "from .widgets.GroupBox import GroupBox", "from .widgets.HistogramLUTWidget import *", "from .widgets.JoystickButton import *", "from .widgets.LayoutWidget import *", "from .widgets.MultiPlotWidget import *", "from .widgets.PathButton import *", "from .widgets.PlotWidget import *", "from .widgets.ProgressDialog import *", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .widgets.ScatterPlotWidget import *", "from .widgets.SpinBox import *", "from .widgets.TableWidget import *", "from .widgets.TreeWidget import *", "from .widgets.ValueLabel import *", "from .widgets.VerticalLabel import *", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "dbg", "data": "def dbg(*args, **kwds):\n\t\"\"\"\n\tCreate a console window and begin watching for exceptions.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t\"\"\"\n\tmkQApp()\n\tfrom . import console\n\tc = console.ConsoleWidget(*args, **kwds)\n\tc.catchAllExceptions()\n\tc.show()\n\tglobal consoles\n\ttry:\n\t\tconsoles.append(c)\n\texcept NameError:\n\t\tconsoles = [c]\n\treturn c\n\n", "description": "\n\tCreate a console window and begin watching for exceptions.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "import os", "import sys", "import numpy  # # pyqtgraph requires numpy", "from .colors import palette", "from .Qt import QtCore, QtGui, QtWidgets", "from .Qt import exec_ as exec", "from .Qt import mkQApp", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "import atexit", "from .colormap import *", "from .functions import *", "from .graphicsItems.ArrowItem import *", "from .graphicsItems.AxisItem import *", "from .graphicsItems.BarGraphItem import *", "from .graphicsItems.ButtonItem import *", "from .graphicsItems.ColorBarItem import *", "from .graphicsItems.CurvePoint import *", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.ErrorBarItem import *", "from .graphicsItems.FillBetweenItem import *", "from .graphicsItems.GradientEditorItem import *", "from .graphicsItems.GradientLegend import *", "from .graphicsItems.GraphicsItem import *", "from .graphicsItems.GraphicsLayout import *", "from .graphicsItems.GraphicsObject import *", "from .graphicsItems.GraphicsWidget import *", "from .graphicsItems.GraphicsWidgetAnchor import *", "from .graphicsItems.GraphItem import *", "from .graphicsItems.GridItem import *", "from .graphicsItems.HistogramLUTItem import *", "from .graphicsItems.ImageItem import *", "from .graphicsItems.InfiniteLine import *", "from .graphicsItems.IsocurveItem import *", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.LabelItem import *", "from .graphicsItems.LegendItem import *", "from .graphicsItems.LinearRegionItem import *", "from .graphicsItems.MultiPlotItem import *", "from .graphicsItems.PColorMeshItem import *", "from .graphicsItems.PlotCurveItem import *", "from .graphicsItems.PlotDataItem import *", "from .graphicsItems.PlotItem import *", "from .graphicsItems.ROI import *", "from .graphicsItems.ScaleBar import *", "from .graphicsItems.ScatterPlotItem import *", "from .graphicsItems.TargetItem import *", "from .graphicsItems.TextItem import *", "from .graphicsItems.UIGraphicsItem import *", "from .graphicsItems.ViewBox import *", "from .graphicsItems.VTickGroup import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .graphicsWindows import *", "from .imageview import *", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "from .Point import Point", "from .ptime import time", "from .Qt import isQObjectAlive", "from .SignalProxy import *", "from .SRTTransform import SRTTransform", "from .SRTTransform3D import SRTTransform3D", "from .ThreadsafeTimer import *", "from .Transform3D import Transform3D", "from .util.cupy_helper import getCupy", "from .Vector import Vector", "from .WidgetGroup import *", "from .widgets.BusyCursor import *", "from .widgets.CheckTable import *", "from .widgets.ColorButton import *", "from .widgets.ColorMapWidget import *", "from .widgets.ComboBox import *", "from .widgets.DataFilterWidget import *", "from .widgets.DataTreeWidget import *", "from .widgets.DiffTreeWidget import *", "from .widgets.FeedbackButton import *", "from .widgets.FileDialog import *", "from .widgets.GradientWidget import *", "from .widgets.GraphicsLayoutWidget import *", "from .widgets.GraphicsView import *", "from .widgets.GroupBox import GroupBox", "from .widgets.HistogramLUTWidget import *", "from .widgets.JoystickButton import *", "from .widgets.LayoutWidget import *", "from .widgets.MultiPlotWidget import *", "from .widgets.PathButton import *", "from .widgets.PlotWidget import *", "from .widgets.ProgressDialog import *", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .widgets.ScatterPlotWidget import *", "from .widgets.SpinBox import *", "from .widgets.TableWidget import *", "from .widgets.TreeWidget import *", "from .widgets.ValueLabel import *", "from .widgets.VerticalLabel import *", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "stack", "data": "def stack(*args, **kwds):\n\t\"\"\"\n\tCreate a console window and show the current stack trace.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t\"\"\"\n\tmkQApp()\n\tfrom . import console\n\tc = console.ConsoleWidget(*args, **kwds)\n\tc.setStack()\n\tc.show()\n\tglobal consoles\n\ttry:\n\t\tconsoles.append(c)\n\texcept NameError:\n\t\tconsoles = [c]\n\treturn c\n\n", "description": "\n\tCreate a console window and show the current stack trace.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "import os", "import sys", "import numpy  # # pyqtgraph requires numpy", "from .colors import palette", "from .Qt import QtCore, QtGui, QtWidgets", "from .Qt import exec_ as exec", "from .Qt import mkQApp", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "import atexit", "from .colormap import *", "from .functions import *", "from .graphicsItems.ArrowItem import *", "from .graphicsItems.AxisItem import *", "from .graphicsItems.BarGraphItem import *", "from .graphicsItems.ButtonItem import *", "from .graphicsItems.ColorBarItem import *", "from .graphicsItems.CurvePoint import *", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.ErrorBarItem import *", "from .graphicsItems.FillBetweenItem import *", "from .graphicsItems.GradientEditorItem import *", "from .graphicsItems.GradientLegend import *", "from .graphicsItems.GraphicsItem import *", "from .graphicsItems.GraphicsLayout import *", "from .graphicsItems.GraphicsObject import *", "from .graphicsItems.GraphicsWidget import *", "from .graphicsItems.GraphicsWidgetAnchor import *", "from .graphicsItems.GraphItem import *", "from .graphicsItems.GridItem import *", "from .graphicsItems.HistogramLUTItem import *", "from .graphicsItems.ImageItem import *", "from .graphicsItems.InfiniteLine import *", "from .graphicsItems.IsocurveItem import *", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.LabelItem import *", "from .graphicsItems.LegendItem import *", "from .graphicsItems.LinearRegionItem import *", "from .graphicsItems.MultiPlotItem import *", "from .graphicsItems.PColorMeshItem import *", "from .graphicsItems.PlotCurveItem import *", "from .graphicsItems.PlotDataItem import *", "from .graphicsItems.PlotItem import *", "from .graphicsItems.ROI import *", "from .graphicsItems.ScaleBar import *", "from .graphicsItems.ScatterPlotItem import *", "from .graphicsItems.TargetItem import *", "from .graphicsItems.TextItem import *", "from .graphicsItems.UIGraphicsItem import *", "from .graphicsItems.ViewBox import *", "from .graphicsItems.VTickGroup import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .graphicsWindows import *", "from .imageview import *", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "from .Point import Point", "from .ptime import time", "from .Qt import isQObjectAlive", "from .SignalProxy import *", "from .SRTTransform import SRTTransform", "from .SRTTransform3D import SRTTransform3D", "from .ThreadsafeTimer import *", "from .Transform3D import Transform3D", "from .util.cupy_helper import getCupy", "from .Vector import Vector", "from .WidgetGroup import *", "from .widgets.BusyCursor import *", "from .widgets.CheckTable import *", "from .widgets.ColorButton import *", "from .widgets.ColorMapWidget import *", "from .widgets.ComboBox import *", "from .widgets.DataFilterWidget import *", "from .widgets.DataTreeWidget import *", "from .widgets.DiffTreeWidget import *", "from .widgets.FeedbackButton import *", "from .widgets.FileDialog import *", "from .widgets.GradientWidget import *", "from .widgets.GraphicsLayoutWidget import *", "from .widgets.GraphicsView import *", "from .widgets.GroupBox import GroupBox", "from .widgets.HistogramLUTWidget import *", "from .widgets.JoystickButton import *", "from .widgets.LayoutWidget import *", "from .widgets.MultiPlotWidget import *", "from .widgets.PathButton import *", "from .widgets.PlotWidget import *", "from .widgets.ProgressDialog import *", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .widgets.ScatterPlotWidget import *", "from .widgets.SpinBox import *", "from .widgets.TableWidget import *", "from .widgets.TreeWidget import *", "from .widgets.ValueLabel import *", "from .widgets.VerticalLabel import *", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "setPalette", "data": "def setPalette(app, style):\n\tif isinstance(style, str):\n\t\tstyle = style.lower()\n\t\tif style == 'qdarkstylelight':\n\t\t\tp = palette.getQDarkStyleLightQPalette()\n\t\telif style in ['qdarkstyle','qdarkstyledark']:\n\t\t\tp = palette.getQDarkStyleDarkQPalette()\n\t\telse:\n\t\t\traise ValueError(f'no palette by the name {style} exists')\n\telif isinstance(style, QtGui.QPalette):\n\t\tp = style\n\telse:\n\t\traise TypeError('style either be a string or QPalette')\n\tapp.paletteChanged.emit(p)\n\tapp.setPalette(p)\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "import os", "import sys", "import numpy  # # pyqtgraph requires numpy", "from .colors import palette", "from .Qt import QtCore, QtGui, QtWidgets", "from .Qt import exec_ as exec", "from .Qt import mkQApp", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "import atexit", "from .colormap import *", "from .functions import *", "from .graphicsItems.ArrowItem import *", "from .graphicsItems.AxisItem import *", "from .graphicsItems.BarGraphItem import *", "from .graphicsItems.ButtonItem import *", "from .graphicsItems.ColorBarItem import *", "from .graphicsItems.CurvePoint import *", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.ErrorBarItem import *", "from .graphicsItems.FillBetweenItem import *", "from .graphicsItems.GradientEditorItem import *", "from .graphicsItems.GradientLegend import *", "from .graphicsItems.GraphicsItem import *", "from .graphicsItems.GraphicsLayout import *", "from .graphicsItems.GraphicsObject import *", "from .graphicsItems.GraphicsWidget import *", "from .graphicsItems.GraphicsWidgetAnchor import *", "from .graphicsItems.GraphItem import *", "from .graphicsItems.GridItem import *", "from .graphicsItems.HistogramLUTItem import *", "from .graphicsItems.ImageItem import *", "from .graphicsItems.InfiniteLine import *", "from .graphicsItems.IsocurveItem import *", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.LabelItem import *", "from .graphicsItems.LegendItem import *", "from .graphicsItems.LinearRegionItem import *", "from .graphicsItems.MultiPlotItem import *", "from .graphicsItems.PColorMeshItem import *", "from .graphicsItems.PlotCurveItem import *", "from .graphicsItems.PlotDataItem import *", "from .graphicsItems.PlotItem import *", "from .graphicsItems.ROI import *", "from .graphicsItems.ScaleBar import *", "from .graphicsItems.ScatterPlotItem import *", "from .graphicsItems.TargetItem import *", "from .graphicsItems.TextItem import *", "from .graphicsItems.UIGraphicsItem import *", "from .graphicsItems.ViewBox import *", "from .graphicsItems.VTickGroup import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .graphicsWindows import *", "from .imageview import *", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "from .Point import Point", "from .ptime import time", "from .Qt import isQObjectAlive", "from .SignalProxy import *", "from .SRTTransform import SRTTransform", "from .SRTTransform3D import SRTTransform3D", "from .ThreadsafeTimer import *", "from .Transform3D import Transform3D", "from .util.cupy_helper import getCupy", "from .Vector import Vector", "from .WidgetGroup import *", "from .widgets.BusyCursor import *", "from .widgets.CheckTable import *", "from .widgets.ColorButton import *", "from .widgets.ColorMapWidget import *", "from .widgets.ComboBox import *", "from .widgets.DataFilterWidget import *", "from .widgets.DataTreeWidget import *", "from .widgets.DiffTreeWidget import *", "from .widgets.FeedbackButton import *", "from .widgets.FileDialog import *", "from .widgets.GradientWidget import *", "from .widgets.GraphicsLayoutWidget import *", "from .widgets.GraphicsView import *", "from .widgets.GroupBox import GroupBox", "from .widgets.HistogramLUTWidget import *", "from .widgets.JoystickButton import *", "from .widgets.LayoutWidget import *", "from .widgets.MultiPlotWidget import *", "from .widgets.PathButton import *", "from .widgets.PlotWidget import *", "from .widgets.ProgressDialog import *", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .widgets.ScatterPlotWidget import *", "from .widgets.SpinBox import *", "from .widgets.TableWidget import *", "from .widgets.TreeWidget import *", "from .widgets.ValueLabel import *", "from .widgets.VerticalLabel import *", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}], [{"term": "class", "name": "classAnimationPlayer:\r", "data": "class AnimationPlayer:\r\n\tdef __init__(self):\r\n\t\tself.frames = {\r\n\t\t\t# magic\r\n\t\t\t'flame': import_folder('./graphics/particles/flame/frames'),\r\n\t\t\t'aura': import_folder('./graphics/particles/aura'),\r\n\t\t\t'heal': import_folder('./graphics/particles/heal/frames'),\r\n\r\n\t\t\t# attacks\r\n\t\t\t'claw': import_folder('./graphics/particles/claw'),\r\n\t\t\t'slash': import_folder('./graphics/particles/slash'),\r\n\t\t\t'sparkle': import_folder('./graphics/particles/sparkle'),\r\n\t\t\t'leaf_attack': import_folder('./graphics/particles/leaf_attack'),\r\n\t\t\t'thunder': import_folder('./graphics/particles/thunder'),\r\n\r\n\t\t\t# monster deaths\r\n\t\t\t'squid': import_folder('./graphics/particles/smoke_orange'),\r\n\t\t\t'raccoon': import_folder('./graphics/particles/raccoon'),\r\n\t\t\t'spirit': import_folder('./graphics/particles/nova'),\r\n\t\t\t'bamboo': import_folder('./graphics/particles/bamboo'),\r\n\r\n\t\t\t# leafs\r\n\t\t\t'leaf': (\r\n\t\t\t\timport_folder('./graphics/particles/leaf1'),\r\n\t\t\t\timport_folder('./graphics/particles/leaf2'),\r\n\t\t\t\timport_folder('./graphics/particles/leaf3'),\r\n\t\t\t\timport_folder('./graphics/particles/leaf4'),\r\n\t\t\t\timport_folder('./graphics/particles/leaf5'),\r\n\t\t\t\timport_folder('./graphics/particles/leaf6'),\r\n\t\t\t\tself.reflect_images(import_folder(\r\n\t\t\t\t\t'./graphics/particles/leaf1')),\r\n\t\t\t\tself.reflect_images(import_folder(\r\n\t\t\t\t\t'./graphics/particles/leaf2')),\r\n\t\t\t\tself.reflect_images(import_folder(\r\n\t\t\t\t\t'./graphics/particles/leaf3')),\r\n\t\t\t\tself.reflect_images(import_folder(\r\n\t\t\t\t\t'./graphics/particles/leaf4')),\r\n\t\t\t\tself.reflect_images(import_folder(\r\n\t\t\t\t\t'./graphics/particles/leaf5')),\r\n\t\t\t\tself.reflect_images(import_folder(\r\n\t\t\t\t\t'./graphics/particles/leaf6'))\r\n\t\t\t)\r\n\t\t}\r\n\r\n\tdef reflect_images(self, frames):\r\n\t\tnew_frames = []\r\n\r\n\t\tfor frame in frames:\r\n\t\t\tflipped_frame = pygame.transform.flip(frame, True, False)\r\n\t\t\tnew_frames.append(flipped_frame)\r\n\t\treturn new_frames\r\n\r\n\tdef create_grass_particles(self, pos, groups):\r\n\t\tanimation_frames = choice(self.frames['leaf'])\r\n\t\tParticleEffect(pos, animation_frames, groups)\r\n\r\n\tdef create_particles(self, animation_type, pos, groups):\r\n\t\tanimation_frames = self.frames[animation_type]\r\n\t\tParticleEffect(pos, animation_frames, groups)\r\n\r\n", "description": null, "category": "graphics", "imports": ["import pygame\r", "from support import import_folder\r", "from random import choice\r", "\t\t\t'flame': import_folder('./graphics/particles/flame/frames'),\r", "\t\t\t'aura': import_folder('./graphics/particles/aura'),\r", "\t\t\t'heal': import_folder('./graphics/particles/heal/frames'),\r", "\t\t\t'claw': import_folder('./graphics/particles/claw'),\r", "\t\t\t'slash': import_folder('./graphics/particles/slash'),\r", "\t\t\t'sparkle': import_folder('./graphics/particles/sparkle'),\r", "\t\t\t'leaf_attack': import_folder('./graphics/particles/leaf_attack'),\r", "\t\t\t'thunder': import_folder('./graphics/particles/thunder'),\r", "\t\t\t'squid': import_folder('./graphics/particles/smoke_orange'),\r", "\t\t\t'raccoon': import_folder('./graphics/particles/raccoon'),\r", "\t\t\t'spirit': import_folder('./graphics/particles/nova'),\r", "\t\t\t'bamboo': import_folder('./graphics/particles/bamboo'),\r", "\t\t\t\timport_folder('./graphics/particles/leaf1'),\r", "\t\t\t\timport_folder('./graphics/particles/leaf2'),\r", "\t\t\t\timport_folder('./graphics/particles/leaf3'),\r", "\t\t\t\timport_folder('./graphics/particles/leaf4'),\r", "\t\t\t\timport_folder('./graphics/particles/leaf5'),\r", "\t\t\t\timport_folder('./graphics/particles/leaf6'),\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\r\n\tdef __init__(self, pos, animation_frames, groups):\r\n\t\tsuper().__init__(groups)\r\n\t\tself.sprite_type = 'magic'\r\n\t\tself.frame_index = 0\r\n\t\tself.animation_speed = 0.15\r\n\t\tself.frames = animation_frames\r\n\t\tself.image = self.frames[self.frame_index]\r\n\t\tself.rect = self.image.get_rect(center=pos)\r\n\r\n\tdef animate(self):\r\n\t\tself.frame_index += self.animation_speed\r\n\t\tif self.frame_index >= len(self.frames):\r\n\t\t\tself.kill()\r\n\t\telse:\r\n\t\t\tself.image = self.frames[int(self.frame_index)]\r\n\r\n\tdef update(self):\r\n\t\tself.animate()\r\n", "description": null, "category": "graphics", "imports": ["import pygame\r", "from support import import_folder\r", "from random import choice\r", "\t\t\t'flame': import_folder('./graphics/particles/flame/frames'),\r", "\t\t\t'aura': import_folder('./graphics/particles/aura'),\r", "\t\t\t'heal': import_folder('./graphics/particles/heal/frames'),\r", "\t\t\t'claw': import_folder('./graphics/particles/claw'),\r", "\t\t\t'slash': import_folder('./graphics/particles/slash'),\r", "\t\t\t'sparkle': import_folder('./graphics/particles/sparkle'),\r", "\t\t\t'leaf_attack': import_folder('./graphics/particles/leaf_attack'),\r", "\t\t\t'thunder': import_folder('./graphics/particles/thunder'),\r", "\t\t\t'squid': import_folder('./graphics/particles/smoke_orange'),\r", "\t\t\t'raccoon': import_folder('./graphics/particles/raccoon'),\r", "\t\t\t'spirit': import_folder('./graphics/particles/nova'),\r", "\t\t\t'bamboo': import_folder('./graphics/particles/bamboo'),\r", "\t\t\t\timport_folder('./graphics/particles/leaf1'),\r", "\t\t\t\timport_folder('./graphics/particles/leaf2'),\r", "\t\t\t\timport_folder('./graphics/particles/leaf3'),\r", "\t\t\t\timport_folder('./graphics/particles/leaf4'),\r", "\t\t\t\timport_folder('./graphics/particles/leaf5'),\r", "\t\t\t\timport_folder('./graphics/particles/leaf6'),\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r", "\t\t\t\tself.reflect_images(import_folder(\r"]}], [{"term": "def", "name": "writePPSSPPConfig", "data": "def writePPSSPPConfig(system):\n\tiniConfig = configparser.ConfigParser(interpolation=None)\n\t# To prevent ConfigParser from converting to lower case\n\tiniConfig.optionxform = str\n\tif os.path.exists(ppssppConfig):\n\t\ttry:\n\t\t\twith io.open(ppssppConfig, 'r', encoding='utf_8_sig') as fp:\n\t\t\t\tiniConfig.readfp(fp)\n\t\texcept:\n\t\t\tpass\n\n\tcreatePPSSPPConfig(iniConfig, system)\n\t# Save the ini file\n\tif not os.path.exists(os.path.dirname(ppssppConfig)):\n\t\tos.makedirs(os.path.dirname(ppssppConfig))\n\twith open(ppssppConfig, 'w') as configfile:\n\t\tiniConfig.write(configfile)\n", "description": null, "category": "graphics", "imports": ["import sys", "import os", "import io", "import retrolxFiles", "import settings", "from Emulator import Emulator", "import configparser"]}, {"term": "def", "name": "createPPSSPPConfig", "data": "def createPPSSPPConfig(iniConfig, system):\n\n\t## [GRAPHICS]\n\tif not iniConfig.has_section(\"Graphics\"):\n\t\tiniConfig.add_section(\"Graphics\")\n\n\t# Graphics Backend : TODO VULKAN support (Not used for now)\n\tiniConfig.set(\"Graphics\", \"FailedGraphicsBackends\", \"0 (OPENGL)\")\n\tif system.isOptSet('gfxbackend'):\n\t\tiniConfig.set(\"Graphics\", \"GraphicsBackend\", system.config[\"gfxbackend\"])\n\telse:\n\t\tiniConfig.set(\"Graphics\", \"GraphicsBackend\", \"0 (OPENGL)\")\n\n\t# Display FPS\n\tif system.isOptSet('showFPS') and system.getOptBoolean('showFPS') == True:\n\t\tiniConfig.set(\"Graphics\", \"ShowFPSCounter\", \"3\") # 1 for Speed%, 2 for FPS, 3 for both\n\telse:\n\t\tiniConfig.set(\"Graphics\", \"ShowFPSCounter\", \"0\")\n\n\t# Frameskip\n\tiniConfig.set(\"Graphics\", \"FrameSkipType\", \"0\") # Use number and not pourcent\n\tiniConfig.set(\"Graphics\", \"AutoFrameSkip\", \"False\")\n\tif system.isOptSet(\"frameskip\"):\n\t\tif system.config[\"frameskip\"] == \"automatic\":\n\t\t\tiniConfig.set(\"Graphics\", \"AutoFrameSkip\", \"True\")\n\t\t\tiniConfig.set(\"Graphics\", \"FrameSkip\",\t \"1\")\n\t\telse:\n\t\t\tiniConfig.set(\"Graphics\", \"FrameSkip\", str(system.config[\"frameskip\"]))\n\telse:\n\t\tiniConfig.set(\"Graphics\", \"FrameSkip\",\t \"0\")\n\n\t# Internal Resolution\n\tif system.isOptSet('internal_resolution'):\n\t\tiniConfig.set(\"Graphics\", \"InternalResolution\", str(system.config[\"internal_resolution\"]))\n\telse:\n\t\tiniConfig.set(\"Graphics\", \"InternalResolution\", \"1\")\n\n\t# Texture Scaling Level\n\tif system.isOptSet('texture_scaling_level'):\n\t\tiniConfig.set(\"Graphics\", \"TexScalingLevel\", system.config[\"texture_scaling_level\"])\n\telse:\n\t\tiniConfig.set(\"Graphics\", \"TexScalingLevel\", \"1\")\n\t# Texture Scaling Type\n\tif system.isOptSet('texture_scaling_type'):\n\t\tiniConfig.set(\"Graphics\", \"TexScalingType\", system.config[\"texture_scaling_type\"])\n\telse:\n\t\tiniConfig.set(\"Graphics\", \"TexScalingType\", \"0\")\n\t# Texture Deposterize\n\tif system.isOptSet('texture_deposterize'):\n\t\tiniConfig.set(\"Graphics\", \"TexDeposterize\", system.config[\"texture_deposterize\"])\n\telse:\n\t\tiniConfig.set(\"Graphics\", \"TexDeposterize\", \"True\")\n\n\t# Anisotropic Filtering\n\tif system.isOptSet('anisotropic_filtering'):\n\t\tiniConfig.set(\"Graphics\", \"AnisotropyLevel\", system.config[\"anisotropic_filtering\"])\n\telse:\n\t\tiniConfig.set(\"Graphics\", \"AnisotropyLevel\", \"3\")\n\n", "description": null, "category": "graphics", "imports": ["import sys", "import os", "import io", "import retrolxFiles", "import settings", "from Emulator import Emulator", "import configparser"]}], [], [{"term": "class", "name": "GameManager", "data": "class GameManager(ListenerContext):\n\t\n\t# graphics\n\twindow: GameWindow \n\tgraphics_data: GraphicsData\n\timage_loader: ImageLoader\n\tdraw_data_container: GameDrawDataContainer\t\n\tui_drawer: UIDrawer\n\tscreen_state_machine: ScreenStateMachine\n\n\t# loading\n\tfirst_frame_event_listener: EventListener\n\n\tdef __init__(self) -> None:\n\t\t# on first frame, do this\n\t\t# self.first_frame_event_listener = EventListener(self.full_load, self)\n\t\tevent_bus.add_listener(EventType.ON_DRAW_FRAME, self.full_load)\n\n\tdef start(self) -> None:\n\t\t# IO initial load: graphics data, ui_images, imgui startup, sound\n\t\t# create the graphics data\n\t\tself.graphics_data = GraphicsData()\n\t\tself.graphics_data.load()\n\n\t\t# load ui images\n\t\tself.image_loader = ImageLoader(self.graphics_data)\n\t\tself.image_loader.set_resource_paths(self.graphics_data.asset_base_paths)\n\t\tself.image_loader.load_ui_images()\n\n\t\t# object creation\n\t\tself.window = GameWindow(self.graphics_data)\n\t\tself.screen_state_machine = ScreenStateMachine(self.graphics_data)\n\t\tself.ui_drawer = UIDrawer(self.window, self.screen_state_machine, self.graphics_data)\n\t\tself.draw_data_container = GameDrawDataContainer(self.graphics_data)\n\t\tself.window.register_ui_drawer(self.ui_drawer)\n\n\t\t# start the graphics and sound for loading screen\n\t\tchange_screen_event: OnChangeScreenStateEvent = OnChangeScreenStateEvent(ScreenState.LOADING)\n\t\tevent_bus.emit(EventType.ON_SCREEN_STATE_CHANGE, change_screen_event)\n\t\t\n\t\tgraphics_helpers.start_pyglet()\n\t\t\n\tdef full_load(self, on_draw_frame: OnDrawEvent) -> None:\n\n\t\tprint(self)\n\n\t\t# remove this, since we only do this on the first frame\n\t\tevent_bus.remove_listener(EventType.ON_DRAW_FRAME, self.full_load)\n\n\t\t# show the loading screen\n\n\t\t# load images, etc.\n\n\t\t# main images\n\t\tchange_screen_event: OnChangeScreenStateEvent = OnChangeScreenStateEvent(ScreenState.MAIN_MENU)\n\t\tevent_bus.emit(EventType.ON_SCREEN_STATE_CHANGE, change_screen_event)\n\n\n", "description": null, "category": "graphics", "imports": ["from __future__ import annotations", "from typing import List", "import time", "from core.event_bus import EventListener, ListenerContext, event_bus", "from core.event_types import EventType, OnChangeScreenStateEvent, no_data_event_instance, OnDrawEvent", "from ui.screens.screen_state import ScreenStateMachine", "from ui.screens.screen_state_enum import ScreenState", "from graphics.data.graphics_data import GraphicsData", "from graphics.game_draw_data_container import GameDrawDataContainer", "from graphics.game_window import GameWindow", "from graphics.image_loader import ImageLoader", "from graphics.ui_drawer import UIDrawer", "from ui.ui_immediate_functions import font_manager", "import graphics.graphics_helper_functions as graphics_helpers"]}], [{"term": "def", "name": "get_all", "data": "def get_all():\n\targs = request.args.to_dict()\n\tpage = args.get(\"page\")\n\tpage_size = args.get(\"pageSize\")\n\ttry:\n\t\tr = requests.get(graphics_card_api_routes.BASE + graphics_card_api_routes.API +\n\t\t\t\t\t\t graphics_card_api_routes.GET_ALL\n\t\t\t\t\t\t + \"?page={}&pageSize={}\".format(page, page_size))\n\t\tresp = jsonify(r.json())\n\t\tresp.status_code = r.status_code\n\t\treturn resp\n\texcept requests.exceptions.RequestException as err:\n\t\tprint(err)\n\t\tresp = jsonify(str(err))\n\t\tresp.status_code = 404\n\t\treturn resp\n\n", "description": null, "category": "graphics", "imports": ["import requests", "from flask import request, jsonify", "from utils import token_utils, role", "from utils.routes.product_microservice import graphics_card_api_routes"]}, {"term": "def", "name": "get_number_of_records", "data": "def get_number_of_records():\n\ttry:\n\t\tr = requests.get(graphics_card_api_routes.BASE + graphics_card_api_routes.API +\n\t\t\t\t\t\t graphics_card_api_routes.GET_NUMBER_OF_RECORDS)\n\t\tresp = jsonify(r.json())\n\t\tresp.status_code = r.status_code\n\t\treturn resp\n\texcept requests.exceptions.RequestException as err:\n\t\tprint(err)\n\t\tresp = jsonify(str(err))\n\t\tresp.status_code = 404\n\t\treturn resp\n\n", "description": null, "category": "graphics", "imports": ["import requests", "from flask import request, jsonify", "from utils import token_utils, role", "from utils.routes.product_microservice import graphics_card_api_routes"]}, {"term": "def", "name": "get_by_id", "data": "def get_by_id(id):\n\ttry:\n\t\tr = requests.get(graphics_card_api_routes.BASE + graphics_card_api_routes.API +\n\t\t\t\t\t\t graphics_card_api_routes.GET_BY_ID + \"/{}\".format(id))\n\t\tresp = jsonify(r.json())\n\t\tresp.status_code = r.status_code\n\t\treturn resp\n\texcept requests.exceptions.RequestException as err:\n\t\tprint(err)\n\t\tresp = jsonify(str(err))\n\t\tresp.status_code = 404\n\t\treturn resp\n\n", "description": null, "category": "graphics", "imports": ["import requests", "from flask import request, jsonify", "from utils import token_utils, role", "from utils.routes.product_microservice import graphics_card_api_routes"]}, {"term": "def", "name": "search_by_name", "data": "def search_by_name():\n\targs = request.args.to_dict()\n\tpage = args.get(\"page\")\n\tpage_size = args.get(\"pageSize\")\n\tname = args.get(\"name\")\n\ttry:\n\t\tr = requests.get(graphics_card_api_routes.BASE + graphics_card_api_routes.API +\n\t\t\t\t\t\t graphics_card_api_routes.SEARCH_BY_NAME\n\t\t\t\t\t\t + \"?page={}&pageSize={}&name={}\".format(page, page_size, name))\n\t\tresp = jsonify(r.json())\n\t\tresp.status_code = r.status_code\n\t\treturn resp\n\texcept requests.exceptions.RequestException as err:\n\t\tprint(err)\n\t\tresp = jsonify(str(err))\n\t\tresp.status_code = 404\n\t\treturn resp\n\n", "description": null, "category": "graphics", "imports": ["import requests", "from flask import request, jsonify", "from utils import token_utils, role", "from utils.routes.product_microservice import graphics_card_api_routes"]}, {"term": "def", "name": "get_number_of_records_search", "data": "def get_number_of_records_search():\n\targs = request.args.to_dict()\n\tname = args.get(\"name\")\n\ttry:\n\t\tr = requests.get(graphics_card_api_routes.BASE + graphics_card_api_routes.API +\n\t\t\t\t\t\t graphics_card_api_routes.GET_NUMBER_OF_RECORDS_SEARCH + \"?name={}\".format(name))\n\t\tresp = jsonify(r.json())\n\t\tresp.status_code = r.status_code\n\t\treturn resp\n\texcept requests.exceptions.RequestException as err:\n\t\tprint(err)\n\t\tresp = jsonify(str(err))\n\t\tresp.status_code = 404\n\t\treturn resp\n\n", "description": null, "category": "graphics", "imports": ["import requests", "from flask import request, jsonify", "from utils import token_utils, role", "from utils.routes.product_microservice import graphics_card_api_routes"]}, {"term": "def", "name": "filter", "data": "def filter():\n\targs = request.args.to_dict()\n\tpage = args.get(\"page\")\n\tpage_size = args.get(\"pageSize\")\n\tdata = request.json\n\ttry:\n\t\tr = requests.post(graphics_card_api_routes.BASE + graphics_card_api_routes.API +\n\t\t\t\t\t\t  graphics_card_api_routes.FILTER +\n\t\t\t\t\t\t  \"?page={}&pageSize={}\".format(page, page_size), json=data)\n\t\tresp = jsonify(r.json())\n\t\tresp.status_code = r.status_code\n\t\treturn resp\n\texcept requests.exceptions.RequestException as err:\n\t\tprint(err)\n\t\tresp = jsonify(str(err))\n\t\tresp.status_code = 404\n\t\treturn resp\n\n", "description": null, "category": "graphics", "imports": ["import requests", "from flask import request, jsonify", "from utils import token_utils, role", "from utils.routes.product_microservice import graphics_card_api_routes"]}, {"term": "def", "name": "get_number_of_records_filter", "data": "def get_number_of_records_filter():\n\tdata = request.json\n\ttry:\n\t\tr = requests.post(graphics_card_api_routes.BASE + graphics_card_api_routes.API +\n\t\t\t\t\t\t  graphics_card_api_routes.GET_NUMBER_OF_RECORDS_FILTER, json=data)\n\t\tresp = jsonify(r.json())\n\t\tresp.status_code = r.status_code\n\t\treturn resp\n\texcept requests.exceptions.RequestException as err:\n\t\tprint(err)\n\t\tresp = jsonify(str(err))\n\t\tresp.status_code = 404\n\t\treturn resp\n\n", "description": null, "category": "graphics", "imports": ["import requests", "from flask import request, jsonify", "from utils import token_utils, role", "from utils.routes.product_microservice import graphics_card_api_routes"]}, {"term": "def", "name": "get_manufacturers", "data": "def get_manufacturers():\n\ttry:\n\t\tr = requests.get(graphics_card_api_routes.BASE + graphics_card_api_routes.API +\n\t\t\t\t\t\t graphics_card_api_routes.GET_MANUFACTURERS)\n\t\tresp = jsonify(r.json())\n\t\tresp.status_code = r.status_code\n\t\treturn resp\n\texcept requests.exceptions.RequestException as err:\n\t\tprint(err)\n\t\tresp = jsonify(str(err))\n\t\tresp.status_code = 404\n\t\treturn resp\n\n", "description": null, "category": "graphics", "imports": ["import requests", "from flask import request, jsonify", "from utils import token_utils, role", "from utils.routes.product_microservice import graphics_card_api_routes"]}, {"term": "def", "name": "get_chip_manufacturers", "data": "def get_chip_manufacturers():\n\ttry:\n\t\tr = requests.get(graphics_card_api_routes.BASE + graphics_card_api_routes.API +\n\t\t\t\t\t\t graphics_card_api_routes.GET_CHIP_MANUFACTURERS)\n\t\tresp = jsonify(r.json())\n\t\tresp.status_code = r.status_code\n\t\treturn resp\n\texcept requests.exceptions.RequestException as err:\n\t\tprint(err)\n\t\tresp = jsonify(str(err))\n\t\tresp.status_code = 404\n\t\treturn resp\n\n", "description": null, "category": "graphics", "imports": ["import requests", "from flask import request, jsonify", "from utils import token_utils, role", "from utils.routes.product_microservice import graphics_card_api_routes"]}, {"term": "def", "name": "get_memory_sizes", "data": "def get_memory_sizes():\n\ttry:\n\t\tr = requests.get(graphics_card_api_routes.BASE + graphics_card_api_routes.API +\n\t\t\t\t\t\t graphics_card_api_routes.GET_MEMORY_SIZES)\n\t\tresp = jsonify(r.json())\n\t\tresp.status_code = r.status_code\n\t\treturn resp\n\texcept requests.exceptions.RequestException as err:\n\t\tprint(err)\n\t\tresp = jsonify(str(err))\n\t\tresp.status_code = 404\n\t\treturn resp\n\n", "description": null, "category": "graphics", "imports": ["import requests", "from flask import request, jsonify", "from utils import token_utils, role", "from utils.routes.product_microservice import graphics_card_api_routes"]}, {"term": "def", "name": "get_memory_types", "data": "def get_memory_types():\n\ttry:\n\t\tr = requests.get(graphics_card_api_routes.BASE + graphics_card_api_routes.API +\n\t\t\t\t\t\t graphics_card_api_routes.GET_MEMORY_TYPES)\n\t\tresp = jsonify(r.json())\n\t\tresp.status_code = r.status_code\n\t\treturn resp\n\texcept requests.exceptions.RequestException as err:\n\t\tprint(err)\n\t\tresp = jsonify(str(err))\n\t\tresp.status_code = 404\n\t\treturn resp\n\n", "description": null, "category": "graphics", "imports": ["import requests", "from flask import request, jsonify", "from utils import token_utils, role", "from utils.routes.product_microservice import graphics_card_api_routes"]}, {"term": "def", "name": "get_model_names", "data": "def get_model_names():\n\ttry:\n\t\tr = requests.get(graphics_card_api_routes.BASE + graphics_card_api_routes.API +\n\t\t\t\t\t\t graphics_card_api_routes.GET_MODEL_NAMES)\n\t\tresp = jsonify(r.json())\n\t\tresp.status_code = r.status_code\n\t\treturn resp\n\texcept requests.exceptions.RequestException as err:\n\t\tprint(err)\n\t\tresp = jsonify(str(err))\n\t\tresp.status_code = 404\n\t\treturn resp\n\n", "description": null, "category": "graphics", "imports": ["import requests", "from flask import request, jsonify", "from utils import token_utils, role", "from utils.routes.product_microservice import graphics_card_api_routes"]}, {"term": "def", "name": "create", "data": "def create():\n\tdata = request.json\n\theaders = request.headers\n\ttry:\n\t\tr = requests.post(graphics_card_api_routes.BASE + graphics_card_api_routes.API +\n\t\t\t\t\t\t  graphics_card_api_routes.CREATE, json=data, headers=headers)\n\t\tresp = jsonify(r.json())\n\t\tresp.status_code = r.status_code\n\t\treturn resp\n\texcept requests.exceptions.RequestException as err:\n\t\tprint(err)\n\t\tresp = jsonify(str(err))\n\t\tresp.status_code = 404\n\t\treturn resp\n\n", "description": null, "category": "graphics", "imports": ["import requests", "from flask import request, jsonify", "from utils import token_utils, role", "from utils.routes.product_microservice import graphics_card_api_routes"]}, {"term": "def", "name": "update", "data": "def update():\n\tdata = request.json\n\theaders = request.headers\n\ttry:\n\t\tr = requests.put(graphics_card_api_routes.BASE + graphics_card_api_routes.API +\n\t\t\t\t\t\t graphics_card_api_routes.UPDATE, json=data, headers=headers)\n\t\tresp = jsonify(r.json())\n\t\tresp.status_code = r.status_code\n\t\treturn resp\n\texcept requests.exceptions.RequestException as err:\n\t\tprint(err)\n\t\tresp = jsonify(str(err))\n\t\tresp.status_code = 404\n\t\treturn resp\n\n", "description": null, "category": "graphics", "imports": ["import requests", "from flask import request, jsonify", "from utils import token_utils, role", "from utils.routes.product_microservice import graphics_card_api_routes"]}, {"term": "def", "name": "delete", "data": "def delete(id):\n\theaders = request.headers\n\ttry:\n\t\tr = requests.delete(graphics_card_api_routes.BASE + graphics_card_api_routes.API +\n\t\t\t\t\t\t\tgraphics_card_api_routes.DELETE + \"/{}\".format(id), headers=headers)\n\t\tresp = jsonify(r.json())\n\t\tresp.status_code = r.status_code\n\t\treturn resp\n\texcept requests.exceptions.RequestException as err:\n\t\tprint(err)\n\t\tresp = jsonify(str(err))\n\t\tresp.status_code = 404\n\t\treturn resp\n", "description": null, "category": "graphics", "imports": ["import requests", "from flask import request, jsonify", "from utils import token_utils, role", "from utils.routes.product_microservice import graphics_card_api_routes"]}], [{"term": "class", "name": "classGraphics:", "data": "class Graphics:\n\t\"\"\"A class which contains all of the graphics we will display in the game.\"\"\"\n\tdef __init__(self):\n\t\t\"\"\"Set up the Graphics class.\"\"\"\n\t\tself.load_graphics()\n\tdef load_graphics(self):\n\t\t\"\"\"Create, load and scale each of the graphics.  Most of these graphics are snake body parts which exist \n\t\tin 4 orientations, one for each direction.  To make the game easier, we load the images for all for \n\t\tdirections into a single array for each kind of body part.  The order that we load them tells us \n\t\ttheir direction.  The order is UP, DOWN, LEFT, RIGHT.  It's easy to remember as if it was the Konami code.\n\t\tThat way, we can find the head-up graphic just by saying: \n\t\tgraphics.head[DIRECTION_UP]\"\"\"\n\t\tself.head : pygame.surface = [\n\t\t\tpygame.transform.scale(pygame.image.load(Paths.GRAPHICS_HEAD_UP_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE)),\n\t\t\tpygame.transform.scale(pygame.image.load(Paths.GRAPHICS_HEAD_DOWN_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE)),\n\t\t\tpygame.transform.scale(pygame.image.load(Paths.GRAPHICS_HEAD_LEFT_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE)),\n\t\t\tpygame.transform.scale(pygame.image.load(Paths.GRAPHICS_HEAD_RIGHT_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE))\n\t\t]\n\t\tself.body : pygame.surface = [\n\t\t\tpygame.transform.scale(pygame.image.load(Paths.GRAPHICS_BODY_UP_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE)),\n\t\t\tpygame.transform.scale(pygame.image.load(Paths.GRAPHICS_BODY_DOWN_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE)),\n\t\t\tpygame.transform.scale(pygame.image.load(Paths.GRAPHICS_BODY_LEFT_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE)),\n\t\t\tpygame.transform.scale(pygame.image.load(Paths.GRAPHICS_BODY_RIGHT_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE))\n\t\t]\n\t\tself.tail : pygame.surface = [\n\t\t\tpygame.transform.scale(pygame.image.load(Paths.GRAPHICS_TAIL_UP_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE)),\n\t\t\tpygame.transform.scale(pygame.image.load(Paths.GRAPHICS_TAIL_DOWN_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE)),\n\t\t\tpygame.transform.scale(pygame.image.load(Paths.GRAPHICS_TAIL_LEFT_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE)),\n\t\t\tpygame.transform.scale(pygame.image.load(Paths.GRAPHICS_TAIL_RIGHT_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE))\n\t\t]\n\t\tself.tongue : pygame.surface = [\n\t\t\tpygame.transform.scale(pygame.image.load(Paths.GRAPHICS_TONGUE_UP_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE)),\n\t\t\tpygame.transform.scale(pygame.image.load(Paths.GRAPHICS_TONGUE_DOWN_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE)),\n\t\t\tpygame.transform.scale(pygame.image.load(Paths.GRAPHICS_TONGUE_LEFT_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE)),\n\t\t\tpygame.transform.scale(pygame.image.load(Paths.GRAPHICS_TONGUE_RIGHT_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE))\n\t\t]\n\t\tself.steak = pygame.transform.scale(pygame.image.load(Paths.GRAPHICS_STEAK_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE))\n\t\tself.wall = pygame.transform.scale(pygame.image.load(Paths.GRAPHICS_WALL_PATH), (Settings.BLOCK_SIZE * Settings.SCALE, Settings.BLOCK_SIZE * Settings.SCALE))\n", "description": "A class which contains all of the graphics we will display in the game.", "category": "graphics", "imports": ["import pygame", "from settings import Settings", "from settings import Paths"]}], [{"term": "class", "name": "TGraphicsObject", "data": "class TGraphicsObject( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateGraphicsObject( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.GraphicsObject_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.GraphicsObject_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TFont", "data": "class TFont( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateFont( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Font_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Font_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TPen", "data": "class TPen( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreatePen( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Pen_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Pen_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBrush", "data": "class TBrush( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBrush( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Brush_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Brush_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TCanvas", "data": "class TCanvas( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateCanvas( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Canvas_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Canvas_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TGraphic", "data": "class TGraphic( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateGraphic( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Graphic_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Graphic_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TPicture", "data": "class TPicture( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreatePicture( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Picture_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Picture_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafileCanvas", "data": "class TMetafileCanvas( TCanvas ):\r\n\tdef Create( Self, AMetafile, ReferenceDevice ):\r\n\t\treturn _Graphics.CreateMetafileCanvas( Self, AMetafile, ReferenceDevice )\r\n\r\n\tdef CreateWithComment( Self, AMetafile, ReferenceDevice, CreatedBy, Description ):\r\n\t\treturn _Graphics.CreateWithCommentMetafileCanvas( Self, AMetafile, ReferenceDevice, CreatedBy, Description )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.MetafileCanvas_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.MetafileCanvas_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TSharedImage", "data": "class TSharedImage(TObject):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateSharedImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.SharedImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.SharedImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafileImage", "data": "class TMetafileImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateMetafileImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.MetafileImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.MetafileImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafile", "data": "class TMetafile( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateMetafile( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Metafile_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Metafile_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBitmapImage", "data": "class TBitmapImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBitmapImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.BitmapImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.BitmapImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBitmap", "data": "class TBitmap( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBitmap( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Bitmap_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Bitmap_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TIconImage", "data": "class TIconImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateIconImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.IconImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.IconImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TIcon", "data": "class TIcon( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateIcon( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Icon_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Icon_SetAttr( Self, Key, Value )\r\n\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}], [], [{"term": "def", "name": "func1", "data": "def func1():\n\tpenup(frank,graphics)\n\tgoto(frank,graphics,-300, 200)\n\tpendown(frank,graphics)\n\tfor _ in range(4):\n\t\tright(frank, 45,graphics)\n\t\tforward(frank, 40,graphics)\n\t\tleft(frank, 45,graphics)\n\t\tforward(frank, 30,graphics)\n\t\tleft(frank, 45,graphics)\n\t\tforward(frank, 40,graphics)\n\t\tright(frank, 45,graphics)\n\t\tforward(frank, 30,graphics)\n", "description": null, "category": "graphics", "imports": ["import queue", "import threading", "#from modulo2 import forward,right, left, figuree, process_queue, generate_screen,generate_Tortugas", "from modulo2 import *"]}, {"term": "def", "name": "func2", "data": "def func2():\n\tpenup(maturin,graphics)\n\tgoto(maturin,graphics,-300, 180)\n\tpendown(maturin,graphics)\n\tfor _ in range(4):\n\t\tleft(maturin, 45,graphics)\n\t\tforward(maturin, 40,graphics)\n\t\tright(maturin, 45,graphics)\n\t\tforward(maturin, 30,graphics)\n\t\tright(maturin, 45,graphics)\n\t\tforward(maturin, 40,graphics)\n\t\tleft(maturin, 45,graphics)\n", "description": null, "category": "graphics", "imports": ["import queue", "import threading", "#from modulo2 import forward,right, left, figuree, process_queue, generate_screen,generate_Tortugas", "from modulo2 import *"]}, {"term": "def", "name": "func3", "data": "def func3():\n\tpenup(maturin,graphics)\n\tgoto(maturin,graphics,-300, 180)\n\tpendown(maturin,graphics)\n\tfor _ in range(4):\n\t\tfigure(maturin, graphics,4, 20)\n\t\tforward(maturin, 40,graphics)\n\t\tcircle(maturin, graphics,4)\n\n", "description": null, "category": "graphics", "imports": ["import queue", "import threading", "#from modulo2 import forward,right, left, figuree, process_queue, generate_screen,generate_Tortugas", "from modulo2 import *"]}], [{"term": "def", "name": "setUp", "data": "  def setUp(self):\n\tself.app = QAPP.QT_APP\n\tself.designView = DesignView(None)\n\n\t# create a test design hierarchy\n\tself.design = Design()\n\tself.design.package.center = Point.fromXY(0, 0)\n\tself.design.package.width = 5000\n\tself.design.package.height = 5000\n\n\tdie = Die()\n\tdie.center = Point.fromXY(0, 0)\n\tdie.width = 3000\n\tdie.height = 3000\n\tself.design.package.dies.append(die)\n\n\tself.designView.setDesign(self.design)\n", "description": null, "category": "graphics", "imports": ["import unittest", "from pyrite.malachite.Design import DesignObject, Design, Package, Die", "from pyrite.DesignView import DesignView, DesignObjectGraphicsItem,\\", "from pyrite.malachite.Geom import Point", "import QAPP"]}, {"term": "def", "name": "testHasPackageItem", "data": "  def testHasPackageItem(self):\n\titems = self.designView.scene().items()\n\tpkgitem = [item for item in items if isinstance(item, PackageGraphicsItem)]\n\tself.assertEqual(len(pkgitem), 1,\n\t\t\"No package graphics item in the QScene for Design View\")\n", "description": null, "category": "graphics", "imports": ["import unittest", "from pyrite.malachite.Design import DesignObject, Design, Package, Die", "from pyrite.DesignView import DesignView, DesignObjectGraphicsItem,\\", "from pyrite.malachite.Geom import Point", "import QAPP"]}, {"term": "def", "name": "testHasDieItem", "data": "  def testHasDieItem(self):\n\titems = self.designView.scene().items()\n\tpkgitem = [item for item in items if isinstance(item, DieGraphicsItem)]\n\tself.assertEqual(len(pkgitem), 1,\n\t\t\"No die graphics item in the QScene for Design View\")\n\n", "description": null, "category": "graphics", "imports": ["import unittest", "from pyrite.malachite.Design import DesignObject, Design, Package, Die", "from pyrite.DesignView import DesignView, DesignObjectGraphicsItem,\\", "from pyrite.malachite.Geom import Point", "import QAPP"]}, {"term": "def", "name": "setUp", "data": "  def setUp(self):\n\tself.do1 = DesignObject(\"TEST\")\n", "description": null, "category": "graphics", "imports": ["import unittest", "from pyrite.malachite.Design import DesignObject, Design, Package, Die", "from pyrite.DesignView import DesignView, DesignObjectGraphicsItem,\\", "from pyrite.malachite.Geom import Point", "import QAPP"]}, {"term": "def", "name": "testReturnsValidItems", "data": "  def testReturnsValidItems(self):\n\tgItem1 = DesignObjectGraphicsItem.graphicsItemForDesignObject(self.do1)\n\tself.assertIsNotNone(gItem1)\n", "description": null, "category": "graphics", "imports": ["import unittest", "from pyrite.malachite.Design import DesignObject, Design, Package, Die", "from pyrite.DesignView import DesignView, DesignObjectGraphicsItem,\\", "from pyrite.malachite.Geom import Point", "import QAPP"]}, {"term": "def", "name": "testSingularity", "data": "  def testSingularity(self):\n\tgItem1 = DesignObjectGraphicsItem.graphicsItemForDesignObject(self.do1)\n\tgItem2 = DesignObjectGraphicsItem.graphicsItemForDesignObject(self.do1)\n\tself.assertEqual(gItem1, gItem2)\n\n", "description": null, "category": "graphics", "imports": ["import unittest", "from pyrite.malachite.Design import DesignObject, Design, Package, Die", "from pyrite.DesignView import DesignView, DesignObjectGraphicsItem,\\", "from pyrite.malachite.Geom import Point", "import QAPP"]}, {"term": "def", "name": "testPackage", "data": "  def testPackage(self):\n\tdo = Package()\n\tgitem = DesignObjectGraphicsItem.graphicsItemForDesignObject(do)\n\tself.assertIsInstance(gitem, PackageGraphicsItem)\n", "description": null, "category": "graphics", "imports": ["import unittest", "from pyrite.malachite.Design import DesignObject, Design, Package, Die", "from pyrite.DesignView import DesignView, DesignObjectGraphicsItem,\\", "from pyrite.malachite.Geom import Point", "import QAPP"]}, {"term": "def", "name": "testDie", "data": "  def testDie(self):\n\tdo = Die()\n\tgitem = DesignObjectGraphicsItem.graphicsItemForDesignObject(do)\n\tself.assertIsInstance(gitem, DieGraphicsItem)\n\n", "description": null, "category": "graphics", "imports": ["import unittest", "from pyrite.malachite.Design import DesignObject, Design, Package, Die", "from pyrite.DesignView import DesignView, DesignObjectGraphicsItem,\\", "from pyrite.malachite.Geom import Point", "import QAPP"]}], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis widget is an easy starting point for generating multi-panel figures.\n\tExample::\n\t\n\t\tw = pg.GraphicsLayoutWidget()\n\t\tp1 = w.addPlot(row=0, col=0)\n\t\tp2 = w.addPlot(row=0, col=1)\n\t\tv = w.addViewBox(row=1, col=0, colspan=2)\n\t\n\tParameters\n\t----------\n\tparent : QWidget or None\n\t\tThe parent widget (see QWidget.__init__)\n\tshow : bool\n\t\tIf True, then immediately show the widget after it is created.\n\t\tIf the widget has no parent, then it will be shown inside a new window.\n\tsize : (width, height) tuple\n\t\tOptionally resize the widget. Note: if this widget is placed inside a\n\t\tlayout, then this argument has no effect.\n\ttitle : str or None\n\t\tIf specified, then set the window title for this widget.\n\tkargs : \n\t\tAll extra arguments are passed to \n\t\t:func:`GraphicsLayout.__init__() `\n\t\t\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, show=False, size=None, title=None, **kargs):\n\t\tmkQApp()\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n\t\t\n\t\tif size is not None:\n\t\t\tself.resize(*size)\n\t\t\t\n\t\tif title is not None:\n\t\t\tself.setWindowTitle(title)\n\t\t\t\n\t\tif show is True:\n\t\t\tself.show()\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis widget is an easy starting point for generating multi-panel figures.\n\tExample::\n\t\n\t\tw = pg.GraphicsLayoutWidget()\n\t\tp1 = w.addPlot(row=0, col=0)\n\t\tp2 = w.addPlot(row=0, col=1)\n\t\tv = w.addViewBox(row=1, col=0, colspan=2)\n\t\n\tParameters\n\t----------\n\tparent : QWidget or None\n\t\tThe parent widget (see QWidget.__init__)\n\tshow : bool\n\t\tIf True, then immediately show the widget after it is created.\n\t\tIf the widget has no parent, then it will be shown inside a new window.\n\tsize : (width, height) tuple\n\t\tOptionally resize the widget. Note: if this widget is placed inside a\n\t\tlayout, then this argument has no effect.\n\ttitle : str or None\n\t\tIf specified, then set the window title for this widget.\n\tkargs : \n\t\tAll extra arguments are passed to \n\t\t:func:`GraphicsLayout.__init__() `\n\t\t\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui, mkQApp", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [], [{"term": "def", "name": "display", "data": "def display():\n\t\"Redirect to logged-in user's graphics, or public graphics.\"\n\tif flask.g.current_user:\n\t\treturn flask.redirect(\n\t\t\tflask.url_for(\".user\", username=flask.g.current_user[\"username\"])\n\t\t)\n\telse:\n\t\treturn flask.redirect(flask.url_for(\".public\"))\n\n", "description": null, "category": "graphics", "imports": ["import flask", "import datagraphics.graphic", "import datagraphics.user", "from datagraphics import constants", "from datagraphics import utils"]}, {"term": "def", "name": "public", "data": "def public():\n\t\"Display list of public graphics.\"\n\tgraphics = get_graphics_public(full=True)\n\treturn flask.render_template(\"graphics/public.html\", graphics=graphics)\n\n", "description": null, "category": "graphics", "imports": ["import flask", "import datagraphics.graphic", "import datagraphics.user", "from datagraphics import constants", "from datagraphics import utils"]}, {"term": "def", "name": "user", "data": "def user(username):\n\t\"Display list of user's graphics.\"\n\tuser = datagraphics.user.get_user(username=username)\n\tif user is None:\n\t\tutils.flash_error(\"No such user.\")\n\t\treturn flask.redirect(flask.url_for(\"home\"))\n\tif not datagraphics.user.am_admin_or_self(user):\n\t\tutils.flash_error(\"View access to user is not allowed.\")\n\t\treturn flask.redirect(flask.url_for(\"home\"))\n\tgraphics = get_graphics_owner(username, full=True)\n\treturn flask.render_template(\n\t\t\"graphics/user.html\", user=user, graphics=graphics, show_public=True\n\t)\n\n", "description": null, "category": "graphics", "imports": ["import flask", "import datagraphics.graphic", "import datagraphics.user", "from datagraphics import constants", "from datagraphics import utils"]}, {"term": "def", "name": "editor", "data": "def editor(username):\n\t\"Display list of the graphics for which the user is editor.\"\n\tuser = datagraphics.user.get_user(username=username)\n\tif user is None:\n\t\tutils.flash_error(\"No such user.\")\n\t\treturn flask.redirect(flask.url_for(\"home\"))\n\tif not datagraphics.user.am_admin_or_self(user):\n\t\tutils.flash_error(\"View access to editor graphics is not allowed.\")\n\t\treturn flask.redirect(flask.url_for(\"home\"))\n\tgraphics = get_graphics_editor(username, full=True)\n\treturn flask.render_template(\n\t\t\"graphics/editor.html\", user=user, graphics=graphics, show_public=True\n\t)\n\n", "description": null, "category": "graphics", "imports": ["import flask", "import datagraphics.graphic", "import datagraphics.user", "from datagraphics import constants", "from datagraphics import utils"]}, {"term": "def", "name": "all", "data": "def all():\n\t\"Display list of graphics.\"\n\tif not flask.g.am_admin:\n\t\tutils.flash_error(\"Not logged in as admin.\")\n\t\treturn flask.redirect(flask.url_for(\"home\"))\n\tgraphics = get_graphics_all(full=True)\n\treturn flask.render_template(\"graphics/all.html\", graphics=graphics)\n\n", "description": null, "category": "graphics", "imports": ["import flask", "import datagraphics.graphic", "import datagraphics.user", "from datagraphics import constants", "from datagraphics import utils"]}, {"term": "def", "name": "get_graphics_owner", "data": "def get_graphics_owner(username, full=False):\n\t\"\"\"Get the graphics owned by the given user.\n\tIf full is True, as docs.\n\tIf full is False, as list of tuples (iuid, title, modified).\n\t\"\"\"\n\tview = flask.g.db.view(\n\t\t\"graphics\",\n\t\t\"owner_modified\",\n\t\tstartkey=(username, \"ZZZZZZ\"),\n\t\tendkey=(username, \"\"),\n\t\tinclude_docs=full,\n\t\treduce=False,\n\t\tdescending=True,\n\t)\n\tif full:\n\t\tresult = []\n\t\tfor row in view:\n\t\t\tgraphic = row.doc\n\t\t\tfetch_dataset(graphic)\n\t\t\tflask.g.cache[graphic[\"_id\"]] = graphic\n\t\t\tresult.append(graphic)\n\t\treturn result\n\telse:\n\t\treturn [(row.id, row.value, row.key[1]) for row in view]\n\n", "description": "Get the graphics owned by the given user.\n\tIf full is True, as docs.\n\tIf full is False, as list of tuples (iuid, title, modified).\n\t", "category": "graphics", "imports": ["import flask", "import datagraphics.graphic", "import datagraphics.user", "from datagraphics import constants", "from datagraphics import utils"]}, {"term": "def", "name": "count_graphics_owner", "data": "def count_graphics_owner(username):\n\t\"Return the number of graphics owned by the given user.\"\n\tview = flask.g.db.view(\n\t\t\"graphics\",\n\t\t\"owner_modified\",\n\t\tstartkey=(username, \"\"),\n\t\tendkey=(username, \"ZZZZZZ\"),\n\t\treduce=True,\n\t)\n\trows = list(view)\n\tif rows:\n\t\treturn rows[0].value\n\telse:\n\t\treturn 0\n\n", "description": null, "category": "graphics", "imports": ["import flask", "import datagraphics.graphic", "import datagraphics.user", "from datagraphics import constants", "from datagraphics import utils"]}, {"term": "def", "name": "get_graphics_editor", "data": "def get_graphics_editor(username, full=False):\n\t\"\"\"Get the graphics for which the given user is editor.\n\tIf full is True, as docs.\n\tIf full is False, as list of tuples (iuid, title, modified).\n\t\"\"\"\n\tview = flask.g.db.view(\n\t\t\"graphics\",\n\t\t\"editor_modified\",\n\t\tstartkey=(username, \"ZZZZZZ\"),\n\t\tendkey=(username, \"\"),\n\t\tinclude_docs=full,\n\t\treduce=False,\n\t\tdescending=True,\n\t)\n\tif full:\n\t\tresult = []\n\t\tfor row in view:\n\t\t\tgraphic = row.doc\n\t\t\tfetch_dataset(graphic)\n\t\t\tflask.g.cache[graphic[\"_id\"]] = graphic\n\t\t\tresult.append(graphic)\n\t\treturn result\n\telse:\n\t\treturn [(row.id, row.value, row.key[1]) for row in view]\n\n", "description": "Get the graphics for which the given user is editor.\n\tIf full is True, as docs.\n\tIf full is False, as list of tuples (iuid, title, modified).\n\t", "category": "graphics", "imports": ["import flask", "import datagraphics.graphic", "import datagraphics.user", "from datagraphics import constants", "from datagraphics import utils"]}, {"term": "def", "name": "count_graphics_editor", "data": "def count_graphics_editor(username):\n\t\"Return the number of graphics for which the given user is editor.\"\n\tview = flask.g.db.view(\n\t\t\"graphics\",\n\t\t\"editor_modified\",\n\t\tstartkey=(username, \"\"),\n\t\tendkey=(username, \"ZZZZZZ\"),\n\t\treduce=True,\n\t)\n\trows = list(view)\n\tif rows:\n\t\treturn rows[0].value\n\telse:\n\t\treturn 0\n\n", "description": null, "category": "graphics", "imports": ["import flask", "import datagraphics.graphic", "import datagraphics.user", "from datagraphics import constants", "from datagraphics import utils"]}, {"term": "def", "name": "get_graphics_public", "data": "def get_graphics_public(full=False, limit=None):\n\t\"\"\"Get the public graphics.\n\tIf full is True, as docs.\n\tIf full is False, as list of tuples (iuid, title, modified).\n\t\"\"\"\n\tview = flask.g.db.view(\n\t\t\"graphics\",\n\t\t\"public_modified\",\n\t\tstartkey=\"ZZZZZZ\",\n\t\tendkey=\"\",\n\t\tlimit=limit,\n\t\tinclude_docs=full,\n\t\treduce=False,\n\t\tdescending=True,\n\t)\n\tif full:\n\t\tresult = []\n\t\tfor row in view:\n\t\t\tgraphic = row.doc\n\t\t\tfetch_dataset(graphic)\n\t\t\tflask.g.cache[graphic[\"_id\"]] = graphic\n\t\t\tresult.append(graphic)\n\t\treturn result\n\telse:\n\t\treturn [(row.id, row.value, row.key) for row in view]\n\n", "description": "Get the public graphics.\n\tIf full is True, as docs.\n\tIf full is False, as list of tuples (iuid, title, modified).\n\t", "category": "graphics", "imports": ["import flask", "import datagraphics.graphic", "import datagraphics.user", "from datagraphics import constants", "from datagraphics import utils"]}, {"term": "def", "name": "count_graphics_public", "data": "def count_graphics_public():\n\t\"Return the number of public graphics.\"\n\tview = flask.g.db.view(\"graphics\", \"public_modified\", reduce=True)\n\trows = list(view)\n\tif rows:\n\t\treturn rows[0].value\n\telse:\n\t\treturn 0\n\n", "description": null, "category": "graphics", "imports": ["import flask", "import datagraphics.graphic", "import datagraphics.user", "from datagraphics import constants", "from datagraphics import utils"]}, {"term": "def", "name": "get_graphics_all", "data": "def get_graphics_all(full=False):\n\t\"\"\"Get all graphics.\n\tIf full is True, as docs.\n\tIf full is False, as list of tuples (iuid, title, owner, modified).\n\t\"\"\"\n\tview = flask.g.db.view(\n\t\t\"graphics\",\n\t\t\"owner_modified\",\n\t\tstartkey=(\"ZZZZZZ\", \"ZZZZZZ\"),\n\t\tendkey=(\"\", \"\"),\n\t\tinclude_docs=full,\n\t\treduce=False,\n\t\tdescending=True,\n\t)\n\tif full:\n\t\tresult = []\n\t\tfor row in view:\n\t\t\tgraphic = row.doc\n\t\t\tfetch_dataset(graphic)\n\t\t\tflask.g.cache[graphic[\"_id\"]] = graphic\n\t\t\tresult.append(graphic)\n\t\treturn result\n\telse:\n\t\treturn [(row.id, row.value, row.key[0], row.key[1]) for row in view]\n\n", "description": "Get all graphics.\n\tIf full is True, as docs.\n\tIf full is False, as list of tuples (iuid, title, owner, modified).\n\t", "category": "graphics", "imports": ["import flask", "import datagraphics.graphic", "import datagraphics.user", "from datagraphics import constants", "from datagraphics import utils"]}, {"term": "def", "name": "count_graphics_all", "data": "def count_graphics_all():\n\t\"Return the total number of graphics.\"\n\tview = flask.g.db.view(\"graphics\", \"owner_modified\", reduce=True)\n\trows = list(view)\n\tif rows:\n\t\treturn rows[0].value\n\telse:\n\t\treturn 0\n\n", "description": null, "category": "graphics", "imports": ["import flask", "import datagraphics.graphic", "import datagraphics.user", "from datagraphics import constants", "from datagraphics import utils"]}, {"term": "def", "name": "fetch_dataset", "data": "def fetch_dataset(graphic):\n\t\"Set the dataset in the graphic to the instance, if possible.\"\n\tdataset = datagraphics.graphic.get_dataset(graphic)\n\tif dataset is not None:\n\t\tif not datagraphics.dataset.allow_view(dataset):\n\t\t\tdataset = None\n\tgraphic[\"dataset\"] = dataset\n", "description": null, "category": "graphics", "imports": ["import flask", "import datagraphics.graphic", "import datagraphics.user", "from datagraphics import constants", "from datagraphics import utils"]}], [{"term": "def", "name": "darken", "data": "def darken(color, factor=0.7):\n\t\"\"\"Return darkened color as a ReportLab RGB color.\n\n\tTake a passed color and returns a Reportlab color that is darker by the\n\tfactor indicated in the parameter.\n\t\"\"\"\n\tnewcol = color_to_reportlab(color)\n\tfor a in [\"red\", \"green\", \"blue\"]:\n\t\tsetattr(newcol, a, factor * getattr(newcol, a))\n\treturn newcol\n\n", "description": "Return darkened color as a ReportLab RGB color.\n\n\tTake a passed color and returns a Reportlab color that is darker by the\n\tfactor indicated in the parameter.\n\t", "category": "graphics", "imports": ["import os", "import tempfile", "from io import BytesIO", "\tfrom reportlab.lib import colors", "\tfrom reportlab.pdfgen import canvas", "\tfrom Bio import MissingPythonDependencyError", "\tfrom PIL import Image", "\tfrom Bio import MissingPythonDependencyError", "from urllib.request import urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\t\timport_imagemap=False,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "def", "name": "color_to_reportlab", "data": "def color_to_reportlab(color):\n\t\"\"\"Return the passed color in Reportlab Color format.\n\n\tWe allow colors to be specified as hex values, tuples, or Reportlab Color\n\tobjects, and with or without an alpha channel. This function acts as a\n\tRosetta stone for conversion of those formats to a Reportlab Color\n\tobject, with alpha value.\n\n\tAny other color specification is returned directly\n\t\"\"\"\n\t# Reportlab Color objects are in the format we want already\n\tif isinstance(color, colors.Color):\n\t\treturn color\n\telif isinstance(color, str):  # String implies hex color\n\t\tif color.startswith(\"0x\"):  # Standardise to octothorpe\n\t\t\tcolor.replace(\"0x\", \"#\")\n\t\tif len(color) == 7:\n\t\t\treturn colors.HexColor(color)\n\t\telse:\n\t\t\ttry:\n\t\t\t\treturn colors.HexColor(color, hasAlpha=True)\n\t\t\texcept TypeError:  # Catch pre-2.7 Reportlab\n\t\t\t\traise RuntimeError(\n\t\t\t\t\t\"Your reportlab seems to be too old, try 2.7 onwards\"\n\t\t\t\t) from None\n\telif isinstance(color, tuple):  # Tuple implies RGB(alpha) tuple\n\t\treturn colors.Color(*color)\n\treturn color\n\n", "description": "Return the passed color in Reportlab Color format.\n\n\tWe allow colors to be specified as hex values, tuples, or Reportlab Color\n\tobjects, and with or without an alpha channel. This function acts as a\n\tRosetta stone for conversion of those formats to a Reportlab Color\n\tobject, with alpha value.\n\n\tAny other color specification is returned directly\n\t", "category": "graphics", "imports": ["import os", "import tempfile", "from io import BytesIO", "\tfrom reportlab.lib import colors", "\tfrom reportlab.pdfgen import canvas", "\tfrom Bio import MissingPythonDependencyError", "\tfrom PIL import Image", "\tfrom Bio import MissingPythonDependencyError", "from urllib.request import urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\t\timport_imagemap=False,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "def", "name": "get_temp_imagefilename", "data": "def get_temp_imagefilename(url):\n\t\"\"\"Return filename of temporary file containing downloaded image.\n\n\tCreate a new temporary file to hold the image file at the passed URL\n\tand return the filename.\n\t\"\"\"\n\timg = urlopen(url).read()\n\tim = Image.open(BytesIO(img))\n\t# im.transpose(Image.FLIP_TOP_BOTTOM)\n\tf = tempfile.NamedTemporaryFile(delete=False, suffix=\".png\")\n\tfname = f.name\n\tf.close()\n\tim.save(fname, \"PNG\")\n\treturn fname\n\n", "description": "Return filename of temporary file containing downloaded image.\n\n\tCreate a new temporary file to hold the image file at the passed URL\n\tand return the filename.\n\t", "category": "graphics", "imports": ["import os", "import tempfile", "from io import BytesIO", "\tfrom reportlab.lib import colors", "\tfrom reportlab.pdfgen import canvas", "\tfrom Bio import MissingPythonDependencyError", "\tfrom PIL import Image", "\tfrom Bio import MissingPythonDependencyError", "from urllib.request import urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\t\timport_imagemap=False,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "class", "name": "classKGMLCanvas:", "data": "class KGMLCanvas:\n\t\"\"\"Reportlab Canvas-based representation of a KGML pathway map.\"\"\"\n\n\tdef __init__(\n\t\tself,\n\t\tpathway,\n\t\timport_imagemap=False,\n\t\tlabel_compounds=True,\n\t\tlabel_orthologs=True,\n\t\tlabel_reaction_entries=True,\n\t\tlabel_maps=True,\n\t\tshow_maps=False,\n\t\tfontname=\"Helvetica\",\n\t\tfontsize=6,\n\t\tdraw_relations=True,\n\t\tshow_orthologs=True,\n\t\tshow_compounds=True,\n\t\tshow_genes=True,\n\t\tshow_reaction_entries=True,\n\t\tmargins=(0.02, 0.02),\n\t):\n\t\t\"\"\"Initialize.\"\"\"\n\t\tself.pathway = pathway\n\t\tself.show_maps = show_maps\n\t\tself.show_orthologs = show_orthologs\n\t\tself.show_compounds = show_compounds\n\t\tself.show_genes = show_genes\n\t\tself.show_reaction_entries = show_reaction_entries\n\t\tself.label_compounds = label_compounds\n\t\tself.label_orthologs = label_orthologs\n\t\tself.label_reaction_entries = label_reaction_entries\n\t\tself.label_maps = label_maps\n\t\tself.fontname = fontname\n\t\tself.fontsize = fontsize\n\t\tself.draw_relations = draw_relations\n\t\tself.non_reactant_transparency = 0.3\n\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL\n\t\t# percentage of canvas that will be margin in on either side in the\n\t\t# X and Y directions\n\t\tself.margins = margins\n\n\tdef draw(self, filename):\n\t\t\"\"\"Add the map elements to the drawing.\"\"\"\n\t\t# Instantiate the drawing, first\n\t\t# size x_max, y_max for now - we can add margins, later\n\t\tif self.import_imagemap:\n\t\t\t# We're drawing directly on the image, so we set the canvas to the\n\t\t\t# same size as the image\n\t\t\tif os.path.isfile(self.pathway.image):\n\t\t\t\timfilename = self.pathway.image\n\t\t\telse:\n\t\t\t\timfilename = get_temp_imagefilename(self.pathway.image)\n\t\t\tim = Image.open(imfilename)\n\t\t\tcwidth, cheight = im.size\n\t\telse:\n\t\t\t# No image, so we set the canvas size to accommodate visible\n\t\t\t# elements\n\t\t\tcwidth, cheight = (self.pathway.bounds[1][0], self.pathway.bounds[1][1])\n\t\t# Instantiate canvas\n\t\tself.drawing = canvas.Canvas(\n\t\t\tfilename,\n\t\t\tbottomup=0,\n\t\t\tpagesize=(\n\t\t\t\tcwidth * (1 + 2 * self.margins[0]),\n\t\t\t\tcheight * (1 + 2 * self.margins[1]),\n\t\t\t),\n\t\t)\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\t\t# Transform the canvas to add the margins\n\t\tself.drawing.translate(\n\t\t\tself.margins[0] * self.pathway.bounds[1][0],\n\t\t\tself.margins[1] * self.pathway.bounds[1][1],\n\t\t)\n\t\t# Add the map image, if required\n\t\tif self.import_imagemap:\n\t\t\tself.drawing.saveState()\n\t\t\tself.drawing.scale(1, -1)\n\t\t\tself.drawing.translate(0, -cheight)\n\t\t\tself.drawing.drawImage(imfilename, 0, 0)\n\t\t\tself.drawing.restoreState()\n\t\t# Add the reactions, compounds and maps\n\t\t# Maps go on first, to be overlaid by more information.\n\t\t# By default, they're slightly transparent.\n\t\tif self.show_maps:\n\t\t\tself.__add_maps()\n\t\tif self.show_reaction_entries:\n\t\t\tself.__add_reaction_entries()\n\t\tif self.show_orthologs:\n\t\t\tself.__add_orthologs()\n\t\tif self.show_compounds:\n\t\t\tself.__add_compounds()\n\t\tif self.show_genes:\n\t\t\tself.__add_genes()\n\t\t# TODO: complete draw_relations code\n\t\t# if self.draw_relations:\n\t\t#\tself.__add_relations()\n\t\t# Write the pathway map to PDF\n\t\tself.drawing.save()\n\n\tdef __add_maps(self):\n\t\t\"\"\"Add maps to the drawing of the map (PRIVATE).\n\n\t\tWe do this first, as they're regional labels to be overlaid by\n\t\tinformation.  Also, we want to set the color to something subtle.\n\n\t\tWe're using Hex colors because that's what KGML uses, and\n\t\tReportlab doesn't mind.\n\t\t\"\"\"\n\t\tfor m in self.pathway.maps:\n\t\t\tfor g in m.graphics:\n\t\t\t\tself.drawing.setStrokeColor(\"#888888\")\n\t\t\t\tself.drawing.setFillColor(\"#DDDDDD\")\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_maps:\n\t\t\t\t\tself.drawing.setFillColor(\"#888888\")\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_graphics(self, graphics):\n\t\t\"\"\"Add the passed graphics object to the map (PRIVATE).\n\n\t\tAdd text, add after the graphics object, for sane Z-ordering.\n\t\t\"\"\"\n\t\tif graphics.type == \"line\":\n\t\t\tp = self.drawing.beginPath()\n\t\t\tx, y = graphics.coords[0]\n\t\t\t# There are optional settings for lines that aren't necessarily\n\t\t\t# part of the KGML DTD\n\t\t\tif graphics.width is not None:\n\t\t\t\tself.drawing.setLineWidth(graphics.width)\n\t\t\telse:\n\t\t\t\tself.drawing.setLineWidth(1)\n\t\t\tp.moveTo(x, y)\n\t\t\tfor (x, y) in graphics.coords:\n\t\t\t\tp.lineTo(x, y)\n\t\t\tself.drawing.drawPath(p)\n\t\t\tself.drawing.setLineWidth(1)  # Return to default\n\t\t# KGML defines the (x, y) coordinates as the centre of the circle/\n\t\t# rectangle/roundrectangle, but Reportlab uses the co-ordinates of the\n\t\t# lower-left corner for rectangle/elif.\n\t\tif graphics.type == \"circle\":\n\t\t\tself.drawing.circle(\n\t\t\t\tgraphics.x, graphics.y, graphics.width * 0.5, stroke=1, fill=1\n\t\t\t)\n\t\telif graphics.type == \"roundrectangle\":\n\t\t\tself.drawing.roundRect(\n\t\t\t\tgraphics.x - graphics.width * 0.5,\n\t\t\t\tgraphics.y - graphics.height * 0.5,\n\t\t\t\tgraphics.width,\n\t\t\t\tgraphics.height,\n\t\t\t\tmin(graphics.width, graphics.height) * 0.1,\n\t\t\t\tstroke=1,\n\t\t\t\tfill=1,\n\t\t\t)\n\t\telif graphics.type == \"rectangle\":\n\t\t\tself.drawing.rect(\n\t\t\t\tgraphics.x - graphics.width * 0.5,\n\t\t\t\tgraphics.y - graphics.height * 0.5,\n\t\t\t\tgraphics.width,\n\t\t\t\tgraphics.height,\n\t\t\t\tstroke=1,\n\t\t\t\tfill=1,\n\t\t\t)\n\n\tdef __add_labels(self, graphics):\n\t\t\"\"\"Add labels for the passed graphics objects to the map (PRIVATE).\n\n\t\tWe don't check that the labels fit inside objects such as circles/\n\t\trectangles/roundrectangles.\n\t\t\"\"\"\n\t\tif graphics.type == \"line\":\n\t\t\t# We use the midpoint of the line - sort of - we take the median\n\t\t\t# line segment (list-wise, not in terms of length), and use the\n\t\t\t# midpoint of that line.  We could have other options here,\n\t\t\t# maybe even parameterising it to a proportion of the total line\n\t\t\t# length.\n\t\t\tmid_idx = len(graphics.coords) * 0.5\n\t\t\tif not int(mid_idx) == mid_idx:\n\t\t\t\tidx1, idx2 = int(mid_idx - 0.5), int(mid_idx + 0.5)\n\t\t\telse:\n\t\t\t\tidx1, idx2 = int(mid_idx - 1), int(mid_idx)\n\t\t\tx1, y1 = graphics.coords[idx1]\n\t\t\tx2, y2 = graphics.coords[idx2]\n\t\t\tx, y = 0.5 * (x1 + x2), 0.5 * (y1 + y2)\n\t\telif graphics.type == \"circle\":\n\t\t\tx, y = graphics.x, graphics.y\n\t\telif graphics.type in (\"rectangle\", \"roundrectangle\"):\n\t\t\tx, y = graphics.x, graphics.y\n\t\t# How big so we want the text, and how many characters?\n\t\tif graphics._parent.type == \"map\":\n\t\t\ttext = graphics.name\n\t\t\tself.drawing.setFont(self.fontname, self.fontsize + 2)\n\t\telif len(graphics.name) < 15:\n\t\t\ttext = graphics.name\n\t\telse:\n\t\t\ttext = graphics.name[:12] + \"...\"\n\t\tself.drawing.drawCentredString(x, y, text)\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\n\tdef __add_orthologs(self):\n\t\t\"\"\"Add 'ortholog' Entry elements to the drawing of the map (PRIVATE).\n\n\t\tIn KGML, these are typically line objects, so we render them\n\t\tbefore the compound circles to cover the unsightly ends/junctions.\n\t\t\"\"\"\n\t\tfor ortholog in self.pathway.orthologs:\n\t\t\tfor g in ortholog.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_orthologs:\n\t\t\t\t\t# We want the label color to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_reaction_entries(self):\n\t\t\"\"\"Add Entry elements for Reactions to the map drawing (PRIVATE).\n\n\t\tIn KGML, these are typically line objects, so we render them\n\t\tbefore the compound circles to cover the unsightly ends/junctions\n\t\t\"\"\"\n\t\tfor reaction in self.pathway.reaction_entries:\n\t\t\tfor g in reaction.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_reaction_entries:\n\t\t\t\t\t# We want the label color to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_compounds(self):\n\t\t\"\"\"Add compound elements to the drawing of the map (PRIVATE).\"\"\"\n\t\tfor compound in self.pathway.compounds:\n\t\t\tfor g in compound.graphics:\n\t\t\t\t# Modify transparency of compounds that don't participate\n\t\t\t\t# in reactions\n\t\t\t\tfillcolor = color_to_reportlab(g.bgcolor)\n\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\tfillcolor.alpha *= self.non_reactant_transparency\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(fillcolor)\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\t\tt = 0.3\n\t\t\t\t\telse:\n\t\t\t\t\t\tt = 1\n\t\t\t\t\tself.drawing.setFillColor(colors.Color(0.2, 0.2, 0.2, t))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_genes(self):\n\t\t\"\"\"Add gene elements to the drawing of the map (PRIVATE).\"\"\"\n\t\tfor gene in self.pathway.genes:\n\t\t\tfor g in gene.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_relations(self):\n\t\t\"\"\"Add relations to the map (PRIVATE).\n\n\t\tThis is tricky. There is no defined graphic in KGML for a\n\t\trelation, and the corresponding entries are typically defined\n\t\tas objects 'to be connected somehow'.  KEGG uses KegSketch, which\n\t\tis not public, and most third-party software draws straight line\n\t\tarrows, with heads to indicate the appropriate direction\n\t\t(at both ends for reversible reactions), using solid lines for\n\t\tECrel relation types, and dashed lines for maplink relation types.\n\n\t\tThe relation has:\n\t\t- entry1: 'from' node\n\t\t- entry2: 'to' node\n\t\t- subtype: what the relation refers to\n\n\t\tTypically we have entry1 = map/ortholog; entry2 = map/ortholog,\n\t\tsubtype = compound.\n\t\t\"\"\"\n\t\t# Dashed lines for maplinks, solid for everything else\n\t\tfor relation in list(self.pathway.relations):\n\t\t\tif relation.type == \"maplink\":\n\t\t\t\tself.drawing.setDash(6, 3)\n\t\t\telse:\n\t\t\t\tself.drawing.setDash()\n\t\t\tfor s in relation.subtypes:\n\t\t\t\tsubtype = self.pathway.entries[s[1]]\n\t\t\t\t# Our aim is to draw an arrow from the entry1 object to the\n\t\t\t\t# entry2 object, via the subtype object.\n\t\t\t\t# 1) Entry 1 to subtype\n\t\t\t\tself.__draw_arrow(relation.entry1, subtype)\n\t\t\t\t# 2) subtype to Entry 2\n\t\t\t\tself.__draw_arrow(subtype, relation.entry2)\n\n\tdef __draw_arrow(self, g_from, g_to):\n\t\t\"\"\"Draw an arrow between given Entry objects (PRIVATE).\n\n\t\tDraws an arrow from the g_from Entry object to the g_to\n\t\tEntry object; both must have Graphics objects.\n\t\t\"\"\"\n\t\t# Centre and bound co-ordinates for the from and two objects\n\t\tbounds_from, bounds_to = g_from.bounds, g_to.bounds\n\t\tcentre_from = (\n\t\t\t0.5 * (bounds_from[0][0] + bounds_from[1][0]),\n\t\t\t0.5 * (bounds_from[0][1] + bounds_from[1][1]),\n\t\t)\n\t\tcentre_to = (\n\t\t\t0.5 * (bounds_to[0][0] + bounds_to[1][0]),\n\t\t\t0.5 * (bounds_to[0][1] + bounds_to[1][1]),\n\t\t)\n\t\tp = self.drawing.beginPath()\n\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t# If the 'from' and 'to' graphics are vertically-aligned, draw a line\n\t\t# from the 'from' to the 'to' entity\n\t\tif bounds_to[0][0] < centre_from[0] < bounds_to[1][0]:\n\t\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t\tif centre_to[1] > centre_from[1]:  # to above from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\t\telse:  # to below from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\telif bounds_from[0][0] < centre_to[0] < bounds_from[1][0]:\n\t\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t\tif centre_to[1] > centre_from[1]:  # to above from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\t\telse:  # to below from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\tself.drawing.drawPath(p)  # Draw arrow shaft\n\t\t# print(g_from)\n\t\t# print(bounds_from)\n\t\t# print(g_to)\n\t\t# print(bounds_to)\n", "description": "Reportlab Canvas-based representation of a KGML pathway map.", "category": "graphics", "imports": ["import os", "import tempfile", "from io import BytesIO", "\tfrom reportlab.lib import colors", "\tfrom reportlab.pdfgen import canvas", "\tfrom Bio import MissingPythonDependencyError", "\tfrom PIL import Image", "\tfrom Bio import MissingPythonDependencyError", "from urllib.request import urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\t\timport_imagemap=False,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}], [], [{"term": "def", "name": "writePPSSPPConfig", "data": "def writePPSSPPConfig(system):\n\tiniConfig = configparser.ConfigParser(interpolation=None)\n\t# To prevent ConfigParser from converting to lower case\n\tiniConfig.optionxform = str\n\tif os.path.exists(ppssppConfig):\n\t\ttry:\n\t\t\twith io.open(ppssppConfig, 'r', encoding='utf_8_sig') as fp:\n\t\t\t\tiniConfig.readfp(fp)\n\t\texcept:\n\t\t\tpass\n\n\tcreatePPSSPPConfig(iniConfig, system)\n\t# Save the ini file\n\tif not os.path.exists(os.path.dirname(ppssppConfig)):\n\t\tos.makedirs(os.path.dirname(ppssppConfig))\n\twith open(ppssppConfig, 'w') as configfile:\n\t\tiniConfig.write(configfile)\n", "description": null, "category": "graphics", "imports": ["import sys", "import os", "import io", "import batoceraFiles", "import settings", "from Emulator import Emulator", "import configparser"]}, {"term": "def", "name": "createPPSSPPConfig", "data": "def createPPSSPPConfig(iniConfig, system):\n\n\t## [GRAPHICS]\n\tif not iniConfig.has_section(\"Graphics\"):\n\t\tiniConfig.add_section(\"Graphics\")\n\n\t# Graphics Backend\n\tif system.isOptSet('gfxbackend'):\n\t\tiniConfig.set(\"Graphics\", \"GraphicsBackend\", system.config[\"gfxbackend\"])\n\telse:\n\t\tiniConfig.set(\"Graphics\", \"GraphicsBackend\", \"0 (OPENGL)\")\n\n\t# Display FPS\n\tif system.isOptSet('showFPS') and system.getOptBoolean('showFPS') == True:\n\t\tiniConfig.set(\"Graphics\", \"ShowFPSCounter\", \"3\") # 1 for Speed%, 2 for FPS, 3 for both\n\telse:\n\t\tiniConfig.set(\"Graphics\", \"ShowFPSCounter\", \"0\")\n\n\t# Frameskip\n\tiniConfig.set(\"Graphics\", \"FrameSkipType\", \"0\") # Use number and not percent\n\tif system.isOptSet(\"frameskip\") and not system.config[\"frameskip\"] == \"automatic\":\n\t\tiniConfig.set(\"Graphics\", \"FrameSkip\", str(system.config[\"frameskip\"]))\n\telif system.isOptSet('rendering_mode') and system.getOptBoolean('rendering_mode') == False:\n\t\tiniConfig.set(\"Graphics\", \"FrameSkip\", \"0\")\n\telse:\n\t\tiniConfig.set(\"Graphics\", \"FrameSkip\", \"2\")\n\n\t# Buffered rendering\n\tif system.isOptSet('rendering_mode') and system.getOptBoolean('rendering_mode') == False:\n\t\tiniConfig.set(\"Graphics\", \"RenderingMode\", \"0\")\n\t\t# Have to force autoframeskip off here otherwise PPSSPP sets rendering mode back to 1.\n\t\tiniConfig.set(\"Graphics\", \"AutoFrameSkip\", \"False\")\n\telse:\n\t\tiniConfig.set(\"Graphics\", \"RenderingMode\", \"1\")\n\t\t# Both internal resolution and auto frameskip are dependent on buffered rendering being on, only check these if the user is actually using buffered rendering.\n\t\t# Internal Resolution\n\t\tif system.isOptSet('internal_resolution'):\n\t\t\tiniConfig.set(\"Graphics\", \"InternalResolution\", str(system.config[\"internal_resolution\"]))\n\t\telse:\n\t\t\tiniConfig.set(\"Graphics\", \"InternalResolution\", \"1\")\n\t\t# Auto frameskip\n\t\tif system.isOptSet(\"autoframeskip\") and system.getOptBoolean(\"autoframeskip\") == False:\n\t\t\tiniConfig.set(\"Graphics\", \"AutoFrameSkip\", \"False\")\n\t\telse:\n\t\t\tiniConfig.set(\"Graphics\", \"AutoFrameSkip\", \"True\")\n\n\t# VSync Interval\n\tif system.isOptSet('vsyncinterval') and system.getOptBoolean('vsyncinterval') == False:\n\t\tiniConfig.set(\"Graphics\", \"VSyncInterval\", \"False\")\n\telse:\n\t\tiniConfig.set(\"Graphics\", \"VSyncInterval\", \"True\")\n\n\t# Texture Scaling Level\n\tif system.isOptSet('texture_scaling_level'):\n\t\tiniConfig.set(\"Graphics\", \"TexScalingLevel\", system.config[\"texture_scaling_level\"])\n\telse:\n\t\tiniConfig.set(\"Graphics\", \"TexScalingLevel\", \"1\")\n\t# Texture Scaling Type\n\tif system.isOptSet('texture_scaling_type'):\n\t\tiniConfig.set(\"Graphics\", \"TexScalingType\", system.config[\"texture_scaling_type\"])\n\telse:\n\t\tiniConfig.set(\"Graphics\", \"TexScalingType\", \"0\")\n\t# Texture Deposterize\n\tif system.isOptSet('texture_deposterize'):\n\t\tiniConfig.set(\"Graphics\", \"TexDeposterize\", system.config[\"texture_deposterize\"])\n\telse:\n\t\tiniConfig.set(\"Graphics\", \"TexDeposterize\", \"True\")\n\n\t# Anisotropic Filtering\n\tif system.isOptSet('anisotropic_filtering'):\n\t\tiniConfig.set(\"Graphics\", \"AnisotropyLevel\", system.config[\"anisotropic_filtering\"])\n\telse:\n\t\tiniConfig.set(\"Graphics\", \"AnisotropyLevel\", \"3\")\n\n", "description": null, "category": "graphics", "imports": ["import sys", "import os", "import io", "import batoceraFiles", "import settings", "from Emulator import Emulator", "import configparser"]}], [{"term": "class", "name": "Display", "data": "class Display(object):\n\t\n\tWHITE = graphicsUtils.formatColor(1.0, 1.0, 1.0)\n\tRED = graphicsUtils.formatColor(1.0, 0.0, 0.0)\n\tGREEN = graphicsUtils.formatColor(0.16, 0.49, 0.31)\n\tBLUE = graphicsUtils.formatColor(0.0, 0.0, 1.0)\n\tBLACK = graphicsUtils.formatColor(0.0, 0.0, 0.0)\n\tGREY = graphicsUtils.formatColor(0.5, .5, 0.5)\n\t\n\tVISIBLE_CUTTOFF = 0.001\n\t\n\t\n\tpartDict = {}\n\tbeliefParts = []\n\tbeliefValue = []\n\tbeliefColor = []\n\tobservations = []\n\t\n\tgraphicsLock = threading.Lock()\n\t\n\tCOLORS = [\n\t\t'purple',\n\t\t'green',\n\t\t'teal',\n\t\t'red',\n\t\t'orange',\n\t\t'yellow'\n\t]\n\tCOLOR_HUES = {\n\t\t'purple' : 0.8,\n\t\t'green' : 0.3,\n\t\t'teal' : 0.49,\n\t\t'red' : 0.0,\n\t\t'orange' : 0.125,\n\t\t'yellow' : 0.21\n\t}\n\t\n\t@staticmethod\n\tdef initGraphics(layout):\n\t\tgraphicsUtils.begin_graphics(\n\t\t\twidth=layout.getWidth(), \n\t\t\theight=layout.getHeight(), \n\t\t\tcolor = Display.WHITE,\n\t\t\ttitle = Const.TITLE\n\t\t);\n\t\t\n\t@staticmethod\n\tdef endGraphics():\n\t\tgraphicsUtils.end_graphics()\n\n\t@staticmethod\n\tdef raiseEndGraphics():\n\t\tgraphicsUtils.raiseEndGraphics()\n\t\n\t@staticmethod\n\tdef drawCar(car):\n\t\tif car in Display.partDict:\n\t\t\tDisplay._remove(car)\n\t\tcolor = Display.GREY\n\t\tif car.isJunior():\n\t\t\tcolor = Display.BLACK\n\t\tparts = graphicsUtils.rectangle(\n\t\t\tcar.pos, Car.LENGTH, \n\t\t\tCar.WIDTH, \n\t\t\tcolor, \n\t\t\tcar.dir\n\t\t)\n\t\tDisplay.partDict[car] = parts\n\t\t\n\t@staticmethod\n\tdef drawObservation(obs):\n\t\tparts = Display.drawCircle(obs.pos, Observation.RADIUS)\n\t\tDisplay.partDict[obs] = parts\n\t\n\t@staticmethod\n\tdef drawSquare(pos, size, color):\n\t\treturn graphicsUtils.square(pos, size, color)\n\t\n\t@staticmethod\n\tdef drawFinish(block):\n\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.GREEN, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\n\t@staticmethod\n\tdef drawBlocks(blocks):\n\t\tfor block in blocks:\n\t\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.BLUE, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\t\n\t@staticmethod\n\tdef drawCircle(pos, radius):\n\t\treturn graphicsUtils.circle(pos, radius, Display.RED, Display.RED)\n\t\n\t@staticmethod\n\tdef drawBelief(model):\n\t\tDisplay.beliefVisible = []\n\t\tfor r in range(model.getBeliefRows()):\n\t\t\tbeliefValueRow = []\n\t\t\tbeliefPartRow = []\n\t\t\tbeliefColorRow = []\n\t\t\tfor c in range(model.getBeliefCols()):\n\t\t\t\tsquare = Display.drawBeliefSquare(r, c, 'purple', 0.0, model)\n\t\t\t\tbeliefPartRow.append(square)\n\t\t\t\tbeliefValueRow.append(0.0)\n\t\t\t\tbeliefColorRow.append(None)\n\t\t\tDisplay.beliefParts.append(beliefPartRow)\n\t\t\tDisplay.beliefValue.append(beliefValueRow)\n\t\t\tDisplay.beliefColor.append(beliefColorRow)\n\t\t\t\t\n\t@staticmethod\n\tdef drawBeliefSquare(row, col, color, value, model):\n\t\ttileSize = Const.BELIEF_TILE_SIZE\n\t\tx = col * tileSize + tileSize / 2.0\n\t\ty = row * tileSize + tileSize / 2.0\n\t\tif not model.inBounds(x, y): return None\n\t\tcolor = Display._getBeliefSquareColor(color, value)\n\t\treturn Display.drawSquare(Vec2d(x, y), tileSize, color)\n\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef getKeys():\n\t\t#print 'attempt get keys'\n\t\tDisplay._acquireLock()\n\t\t#print 'get keys'\n\t\tkeys = graphicsUtils.keys_waiting() + graphicsUtils.keys_pressed()\n\t\tDisplay._releaseLock()\n\t\treturn keys\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef graphicsSleep(timeToSleep):\n\t\tgraphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''for _ in range(int(timeToSleep / 0.005)):\n\t\t\t#print 'attempt sleep'\n\t\t\tDisplay._acquireLock()\n\t\t\t#print 'sleep'\n\t\t\tgraphicsUtils.sleep(0.001)\n\t\t\tDisplay._releaseLock()\n\t\t\ttime.sleep(0.004)'''\n\t\t\n\t\t#graphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''startWait = time.time()\n\t\tDisplay._acquireLock()\n\t\ttimeToSleep -= time.time() - startWait\n\t\tgraphicsUtils.refresh()\n\t\tif timeToSleep > 0:\n\t\t\tgraphicsUtils.sleep(timeToSleep)\n\t\tDisplay._releaseLock()'''\n\t\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef updateBelief(color, belief):\n\t\tDisplay._acquireLock()\n\t\ttotal = belief.getSum()\n\t\tif abs(total - 1.0) > 0.001:\n\t\t\traise Exception('belief does not sum to 1 ('+str(total)+'). Use the normalize method.')\n\t\tfor r in range(belief.getNumRows()):\n\t\t\tfor c in range(belief.getNumCols()):\n\t\t\t\tvalue = belief.getProb(r, c)\n\t\t\t\tDisplay._updateBeliefSquare(r, c, value, color)\n\t\tDisplay._releaseLock()\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef move(obj, delta):\n\t\t#print 'attempt move'\n\t\tDisplay._acquireLock()\n\t\t#print 'move'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.move_by(parts, delta.x, delta.y)\n\t\t#print 'end move'\n\t\tDisplay._releaseLock()\n\t\t\n\t# make thread safe\n\t@staticmethod\n\tdef rotate(obj, angle):\n\t\tif angle == 0: return\n\t\t#print 'attempt rotate'\n\t\tDisplay._acquireLock()\n\t\t#print 'rotate'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.rotate_by(parts, angle)\n\t\tDisplay._releaseLock()\n\t\t\t\t\n\t@staticmethod\n\tdef _getBeliefSquareColor(color, value):\n\t\tvalue = min(1.0, value * 15)\n\t\tsaturation = value\n\t\thue = Display.COLOR_HUES[color]\n\t\tr, g, b = colorsys.hsv_to_rgb(hue, saturation, 1.0)\n\t\tcolor = graphicsUtils.formatColor(r, g, b)\n\t\treturn color\t\t\n\t\n\t@staticmethod\n\tdef _isVisible(value):\n\t\treturn value >= Display.VISIBLE_CUTTOFF\n\t\n\t@staticmethod\n\tdef _updateBeliefSquare(r, c, value, colorName):\n\t\tpart = Display.beliefParts[r][c]\n\t\tif part == None: return\n\t\toldValue = Display.beliefValue[r][c]\n\t\toldColor = Display.beliefColor[r][c]\n\t\twasVisible = Display._isVisible(oldValue)\n\t\tisVisible = Display._isVisible(value) \n\t\tif not isVisible: value = 0.0\n\t\tif oldColor != colorName and oldValue >= value: return\n\t\tif not isVisible and not wasVisible: return\n\t\tcolor = Display._getBeliefSquareColor(colorName, value)\n\t\tgraphicsUtils.changeColor(part, color)\n\t\tDisplay.beliefValue[r][c] = value\n\t\tDisplay.beliefColor[r][c] = colorName\n\t\t\n\t@staticmethod\n\tdef _acquireLock():\n\t\treturn\n\t\t#print 'acquire'\n\t\treturn Display.graphicsLock.acquire()\n\t\n\t@staticmethod\n\tdef _releaseLock():\n\t\treturn\n\t\t#print 'release'\n\t\treturn Display.graphicsLock.release()\n\t \n\t####################################\n\t# Depreicated\n\t####################################\n\t\t\n\t@staticmethod\n\tdef _remove(obj):\n\t\tparts = Display.partDict[obj]\n\t\tgraphicsUtils.remove_from_screen(parts);\n\t\t\n\t@staticmethod\n\tdef redrawObservations(observations):\n\t\traise Exception('depreicated')\n\t\tfor obs in Display.observations:\n\t\t\tDisplay._remove(obs)\n\t\tfor obs in observations:\n\t\t\tDisplay.drawObservation(obs)\n\t\tDisplay.observations = observations\n", "description": null, "category": "graphics", "imports": ["from . import graphicsUtils", "from engine.model.car.car import Car", "from engine.const import Const", "from engine.model.observation import Observation", "from engine.vector import Vec2d", "import colorsys", "import threading"]}], [{"term": "class", "name": "SettingsParams", "data": "class SettingsParams(AppRef):\n\n\tdef __init__(self):\n\t\tsuper(SettingsParams, self).__init__()\n\t\tself.SETTINGS = g_settingsCore.options\n\n\tdef __settingsDiffPreprocessing(self, diff):\n\t\tif constants.GRAPHICS.SMOOTHING in diff:\n\t\t\trppSetting = graphics.GRAPHICS_SETTINGS.RENDER_PIPELINE\n\t\t\trenderOptions = graphics.getGraphicsSetting(rppSetting)\n\t\t\tisAdvancedRender = renderOptions.value == _DEFERRED_RENDER_IDX\n\t\t\tif rppSetting in diff:\n\t\t\t\tisAdvancedRender = diff[rppSetting] == _DEFERRED_RENDER_IDX\n\t\t\tif isAdvancedRender:\n\t\t\t\tdiff[constants.GRAPHICS.CUSTOM_AA] = diff[constants.GRAPHICS.SMOOTHING]\n\t\t\telse:\n\t\t\t\tdiff[constants.GRAPHICS.MULTISAMPLING] = diff[constants.GRAPHICS.SMOOTHING]\n\t\treturn diff\n\n\tdef getGameSettings(self):\n\t\treturn self.SETTINGS.pack(constants.GAME.ALL())\n\n\tdef getSoundSettings(self):\n\t\treturn self.SETTINGS.pack(constants.SOUND.ALL())\n\n\tdef getGraphicsSettings(self):\n\t\treturn self.SETTINGS.pack(constants.GRAPHICS.ALL())\n\n\tdef getMarkersSettings(self):\n\t\treturn self.SETTINGS.pack(constants.MARKERS.ALL())\n\n\tdef getAimSettings(self):\n\t\treturn self.SETTINGS.pack(constants.AIM.ALL())\n\n\tdef getControlsSettings(self):\n\t\treturn self.SETTINGS.pack(constants.CONTROLS.ALL())\n\n\tdef getMonitorSettings(self):\n\t\treturn self.SETTINGS.pack((constants.GRAPHICS.MONITOR,\n\t\t constants.GRAPHICS.FULLSCREEN,\n\t\t constants.GRAPHICS.WINDOW_SIZE,\n\t\t constants.GRAPHICS.RESOLUTION))\n\n\tdef preview(self, settingName, value):\n\t\tsetting = self.SETTINGS.getSetting(settingName)\n\t\tif setting is not None:\n\t\t\tsetting.preview(value)\n\t\treturn\n\n\tdef revert(self):\n\t\tself.SETTINGS.revert()\n\t\tg_settingsCore.clearStorages()\n\n\tdef apply(self, diff):\n\t\tdiff = self.__settingsDiffPreprocessing(diff)\n\t\tapplyMethod = self.getApplyMethod(diff)\n\t\tself.SETTINGS.apply(diff)\n\t\tg_settingsCore.applyStorages()\n\t\tif len(set(graphics.GRAPHICS_SETTINGS.ALL()) & set(diff.keys())):\n\t\t\tBigWorld.commitPendingGraphicsSettings()\n\t\treturn applyMethod == options.APPLY_METHOD.RESTART\n\n\tdef getApplyMethod(self, diff):\n\t\tnewMonitorIndex = diff.get(constants.GRAPHICS.MONITOR)\n\t\tif not g_monitorSettings.isFullscreen:\n\t\t\tisFullscreen = diff.get(constants.GRAPHICS.FULLSCREEN)\n\t\t\tisMonitorChanged = g_monitorSettings.isMonitorChanged or newMonitorIndex is not None and g_monitorSettings.currentMonitor != newMonitorIndex\n\t\t\treturn isFullscreen and isMonitorChanged and options.APPLY_METHOD.RESTART\n\t\telse:\n", "description": null, "category": "graphics", "imports": ["import BigWorld", "from account_helpers.SettingsCore import g_settingsCore", "from gui.Scaleform.daapi.view.lobby.settings import constants", "from gui.shared.utils import graphics", "from gui.shared.utils.graphics import g_monitorSettings", "from gui.Scaleform.daapi import AppRef", "from gui.Scaleform.daapi.view.lobby.settings import options"]}], [{"term": "class", "name": "classeditor_data:\r", "data": "class editor_data:\r\n\tzero = 0\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import graph\r", "import pygame\r", "import cPickle\r"]}, {"term": "def", "name": "init_editor", "data": "def init_editor():\r\n\teditor = editor_data()\r\n\treturn editor\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import graph\r", "import pygame\r", "import cPickle\r"]}, {"term": "def", "name": "load_tileset", "data": "def load_tileset(filename, graphics):\r\n\tfactor_x = int(graphics.resolution_x/640)\r\n\tfactor_y = int(graphics.resolution_y/400)\r\n\ttile_w = 16*factor_x\r\n\ttile_h = 16*factor_y\r\n\timg = pygame.image.load(filename)\r\n\tbuff = pygame.Surface((256*factor_x, 256*factor_y), pygame.HWSURFACE, 32)\r\n\timg.convert(32, pygame.HWSURFACE)\r\n\ti = 0\r\n\twhile i < 256*factor_x:\r\n\t\tbuff.blit(img, (i, 0), (i/factor_x, 0, 1, 256))\r\n\t\ti += 1\r\n\ti = 0\r\n\twhile i < 256*factor_y:\r\n\t\tgraphics.tileset.blit(buff, (0, i), (0, i/factor_y, 256*factor_x, 1))\r\n\t\ti += 1\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import graph\r", "import pygame\r", "import cPickle\r"]}, {"term": "def", "name": "load_spriteset", "data": "def load_spriteset(filename, graphics):\r\n\tfactor_x = int(graphics.resolution_x/640)\r\n\tfactor_y = int(graphics.resolution_y/400)\r\n\ttile_w = 16*factor_x\r\n\ttile_h = 16*factor_y\r\n\timg = pygame.image.load(filename)\r\n\tbuff = pygame.Surface((256*factor_x, 256*factor_y), pygame.HWSURFACE, 32)\r\n\timg.convert(32, pygame.HWSURFACE)\r\n\ti = 0\r\n\twhile i < 256*factor_x:\r\n\t\tbuff.blit(img, (i, 0), (i/factor_x, 0, 1, 256))\r\n\t\ti += 1\r\n\ti = 0\r\n\twhile i < 256*factor_y:\r\n\t\tgraphics.spriteset.blit(buff, (0, i), (0, i/factor_y, 256*factor_x, 1))\r\n\t\ti += 1\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import graph\r", "import pygame\r", "import cPickle\r"]}, {"term": "def", "name": "draw_screen", "data": "def draw_screen(editor, level, graphics):\r\n\tfactor_x = int(graphics.resolution_x/640)\r\n\tfactor_y = int(graphics.resolution_y/400)\r\n\ttile_w = 16*factor_x\r\n\ttile_h = 16*factor_y\r\n\tgraphics.screen.fill((32, 0, 64))\r\n\tx = 0\r\n\ttile_x = int(graphics.scroll_x/16)\r\n\twhile x < 24:\r\n\t\ty = 0\r\n\t\ttile_y = int(graphics.scroll_y/16)\r\n\t\twhile y < 24:\r\n\t\t\tif tile_x < graphics.tilemap_width \\\r\n\t\t\t  and tile_y < graphics.tilemap_height \\\r\n\t\t\t  and tile_x >= 0 \\\r\n\t\t\t  and tile_y >= 0:\r\n\t\t\t\ttile = graphics.tilemap[tile_y * graphics.tilemap_width + tile_x]\r\n\t\t\t\tgraphics.screen.blit(graphics.tileset, (x*tile_w, y*tile_h), ((tile%16)*tile_w, (tile/16)*tile_h, tile_w, tile_h))\r\n\t\t\telse:\r\n\t\t\t\ttile = 1\r\n\t\t\t\tgraphics.screen.blit(graphics.tileset, (x*tile_w, y*tile_h), ((tile%16)*tile_w, (tile/16)*tile_h, tile_w, tile_h))\r\n\t\t\ty += 1\r\n\t\t\ttile_y += 1\r\n\t\tx += 1\r\n\t\ttile_x += 1\r\n\t\t\r\n\tif editor.mode == 1:\r\n\t\tx = 0\r\n\t\ttile_x = int(graphics.scroll_x/16)\r\n\t\twhile x < 24:\r\n\t\t\ty = 0\r\n\t\t\ttile_y = int(graphics.scroll_y/16)\r\n\t\t\twhile y < 24:\r\n\t\t\t\tif tile_x < graphics.tilemap_width \\\r\n\t\t\t\t  and tile_y < graphics.tilemap_height \\\r\n\t\t\t\t  and tile_x >= 0 \\\r\n\t\t\t\t  and tile_y >= 0:\r\n\t\t\t\t\ttile = level.object_[tile_y * graphics.tilemap_width + tile_x]\r\n\t\t\t\t\tif tile != 0:\r\n\t\t\t\t\t\tgraphics.screen.blit(graphics.spriteset, (x*tile_w, y*tile_h), ((tile%16)*tile_w, (tile/16)*tile_h, tile_w, tile_h))\r\n\t\t\t\ty += 1\r\n\t\t\t\ttile_y += 1\r\n\t\t\tx += 1\r\n\t\t\ttile_x += 1\r\n\t\t\t\r\n\tif editor.mode == 2:\r\n\t\tx = 0\r\n\t\ttile_x = int(graphics.scroll_x/16)\r\n\t\twhile x < 24:\r\n\t\t\ty = 0\r\n\t\t\ttile_y = int(graphics.scroll_y/16)\r\n\t\t\twhile y < 24:\r\n\t\t\t\tif tile_x < graphics.tilemap_width \\\r\n\t\t\t\t  and tile_y < graphics.tilemap_height \\\r\n\t\t\t\t  and tile_x >= 0 \\\r\n\t\t\t\t  and tile_y >= 0:\r\n\t\t\t\t\ttile = level.direction[tile_y * graphics.tilemap_width + tile_x]\r\n\t\t\t\t\tif tile != 0:\r\n\t\t\t\t\t\tgraphics.screen.blit(graphics.spriteset, (x*tile_w, y*tile_h), ((tile%16)*tile_w, (tile/16)*tile_h, tile_w, tile_h))\r\n\t\t\t\ty += 1\r\n\t\t\t\ttile_y += 1\r\n\t\t\tx += 1\r\n\t\t\ttile_x += 1\r\n\t\r\n\tgraphics.screen.fill((32, 0, 64), (384*factor_x, 256*factor_x, tile_w, tile_h))\r\n\t\r\n\tif editor.mode == 0:\r\n\t\tgraphics.screen.blit(graphics.tileset, (384*factor_x, 0), (0, 0, 256*factor_x, 256*factor_y))\r\n\t\ttile = editor.tile\r\n\t\tgraphics.screen.blit(graphics.tileset, (384*factor_x, 256*factor_y), ((tile%16)*tile_w, (tile/16)*tile_h, tile_w, tile_h))\r\n\t\t\r\n\tif editor.mode != 0:\r\n\t\tgraphics.screen.blit(graphics.spriteset, (384*factor_x, 0), (0, 0, 256*factor_x, 256*factor_y))\r\n\t\ttile = editor.object_\r\n\t\tgraphics.screen.blit(graphics.spriteset, (384*factor_x, 256*factor_y), ((tile%16)*tile_w, (tile/16)*tile_h, tile_w, tile_h))\r\n\t\r\n\ti=0\r\n\twhile i < graphics.sprites:\r\n\t\tgraphics.screen.blit(graphics.spriteset, ((graphics.sprite_x[i] - int(graphics.scroll_x/16)*16*graphics.sprite_s[i])*factor_x, (graphics.sprite_y[i] - int(graphics.scroll_y/16)*16*graphics.sprite_s[i])*factor_y), ((graphics.sprite_c[i]%16)*tile_w, (graphics.sprite_c[i]/16)*tile_h, tile_w, tile_h))\r\n\t\ti += 1\r\n\tgraphics.sprites = 0\r\n\t\r\n\tpygame.display.flip()\r\n\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import graph\r", "import pygame\r", "import cPickle\r"]}, {"term": "def", "name": "edit", "data": "def edit(level, graphics):\r\n\tfactor_x = int(graphics.resolution_x/640)\r\n\tfactor_y = int(graphics.resolution_y/400)\r\n\ttile_w = 16*factor_x\r\n\ttile_h = 16*factor_y\r\n\teditor = init_editor()\r\n\t#graphics.tilemap_width = 1024\r\n\t#graphics.tilemap_height = 1024\r\n\t#graphics.tilemap = [0 for i in range(graphics.tilemap_width*graphics.tilemap_height)]\r\n\tf = data.load(\"tileset.png\")\r\n\tload_tileset(f, graphics)\r\n\tf = data.load(\"editor.png\")\r\n\tload_spriteset(f, graphics)\r\n\t\r\n\ti=0\r\n\tmenu_quit = 0\r\n\tticks = pygame.time.get_ticks()\r\n\tt = 0\r\n\teditor.tile = 1\r\n\teditor.mode = 0\r\n\teditor.object_ = 0\r\n\twhile menu_quit == 0:\r\n\t\tpygame.event.pump()\r\n\t\tkeys = pygame.key.get_pressed()\r\n\t\tif(keys[pygame.K_ESCAPE] == 1):\r\n\t\t\tmenu_quit = 1\r\n\t\tif(keys[pygame.K_LEFT] == 1):\r\n\t\t\tgraphics.scroll_x -= 0.25*t\r\n\t\tif(keys[pygame.K_RIGHT] == 1):\r\n\t\t\tgraphics.scroll_x += 0.25*t\r\n\t\tif(keys[pygame.K_UP] == 1):\r\n\t\t\tgraphics.scroll_y -= 0.25*t\r\n\t\tif(keys[pygame.K_DOWN] == 1):\r\n\t\t\tgraphics.scroll_y += 0.25*t\r\n\t\tif(keys[pygame.K_TAB] == 1 and tab == 0):\r\n\t\t\teditor.mode = (editor.mode + 1)%3\r\n\t\t\tif editor.mode == 2:\r\n\t\t\t\tf = data.load(\"arrows.png\")\r\n\t\t\t\tload_spriteset(f, graphics)\r\n\t\t\tif editor.mode == 0:\r\n\t\t\t\tf = data.load(\"editor.png\")\r\n\t\t\t\tload_spriteset(f, graphics)\r\n\t\t\t\t\r\n\t\ttab = keys[pygame.K_TAB]\r\n\t\t\r\n\t\tt = pygame.mouse.get_pos()\r\n\t\tmouse = (float(t[0])/float(factor_x), float(t[1])/float(factor_y))\r\n\t\tgraph.draw_sprite_static(0, int(mouse[0]/16)*16, int(mouse[1]/16)*16, graphics)\r\n\t\tgraph.draw_sprite_static(1, mouse[0], mouse[1], graphics)\r\n\t\t\r\n\t\tif keys[pygame.K_s]:\r\n\t\t\tlevel.start_x = int(mouse[0]/16)*16 + int(graphics.scroll_x/16)*16\r\n\t\t\tlevel.start_y = int(mouse[1]/16)*16 + int(graphics.scroll_y/16)*16\r\n\t\t\r\n\t\tif editor.mode == 0:\r\n\t\t\tmouseb = pygame.mouse.get_pressed()\r\n\t\t\tif mouseb[2]:\r\n\t\t\t\tif mouse[0] >= 384 and mouse[0] < 640 and mouse[1] >= 0 and mouse[1] < 256:\r\n\t\t\t\t\teditor.tile = (int(mouse[0])-384)/16 + int(mouse[1]/16)*16\r\n\t\t\t\tif mouse[0] >= 0 and mouse[0] < 384:\r\n\t\t\t\t\ttile = int(int(mouse[0]/16) + int(graphics.scroll_x/16) + (int(mouse[1]/16) + int(graphics.scroll_y/16))*graphics.tilemap_width)\r\n\t\t\t\t\tif tile >= 0 and tile < graphics.tilemap_width*graphics.tilemap_height:\r\n\t\t\t\t\t\teditor.tile = graphics.tilemap[tile]\r\n\t\t\t\t\t\t\r\n\t\t\tif mouseb[0]:\r\n\t\t\t\tif mouse[0] >= 0 and mouse[0] < 384:\r\n\t\t\t\t\ttile = int(int(mouse[0]/16) + int(graphics.scroll_x/16) + (int(mouse[1]/16) + int(graphics.scroll_y/16))*graphics.tilemap_width)\r\n\t\t\t\t\tif tile >= 0 and tile < graphics.tilemap_width*graphics.tilemap_height:\r\n\t\t\t\t\t\tgraphics.tilemap[tile] = editor.tile\r\n\t\t\r\n\t\tif editor.mode == 1:\r\n\t\t\tmouseb = pygame.mouse.get_pressed()\r\n\t\t\tif mouseb[2]:\r\n\t\t\t\tif mouse[0] >= 384 and mouse[0] < 640 and mouse[1] >= 0 and mouse[1] < 256:\r\n\t\t\t\t\teditor.object_ = (int(mouse[0])-384)/16 + int(mouse[1]/16)*16\r\n\t\t\t\tif mouse[0] >= 0 and mouse[0] < 384:\r\n\t\t\t\t\ttile = int(int(mouse[0]/16) + int(graphics.scroll_x/16) + (int(mouse[1]/16) + int(graphics.scroll_y/16))*graphics.tilemap_width)\r\n\t\t\t\t\tif tile >= 0 and tile < graphics.tilemap_width*graphics.tilemap_height:\r\n\t\t\t\t\t\teditor.object_ = level.object_[tile]\r\n\t\t\t\t\t\t\r\n\t\t\tif mouseb[0]:\r\n\t\t\t\tif mouse[0] >= 0 and mouse[0] < 384:\r\n\t\t\t\t\ttile = int(int(mouse[0]/16) + int(graphics.scroll_x/16) + (int(mouse[1]/16) + int(graphics.scroll_y/16))*graphics.tilemap_width)\r\n\t\t\t\t\tif tile >= 0 and tile < graphics.tilemap_width*graphics.tilemap_height:\r\n\t\t\t\t\t\tlevel.object_[tile] = editor.object_\r\n\r\n\t\tif editor.mode == 2:\r\n\t\t\tmouseb = pygame.mouse.get_pressed()\r\n\t\t\tif mouseb[2]:\r\n\t\t\t\tif mouse[0] >= 384 and mouse[0] < 640 and mouse[1] >= 0 and mouse[1] < 256:\r\n\t\t\t\t\teditor.object_ = (int(mouse[0])-384)/16 + int(mouse[1]/16)*16\r\n\t\t\t\tif mouse[0] >= 0 and mouse[0] < 384:\r\n\t\t\t\t\ttile = int(int(mouse[0]/16) + int(graphics.scroll_x/16) + (int(mouse[1]/16) + int(graphics.scroll_y/16))*graphics.tilemap_width)\r\n\t\t\t\t\tif tile >= 0 and tile < graphics.tilemap_width*graphics.tilemap_height:\r\n\t\t\t\t\t\teditor.object_ = level.direction[tile]\r\n\t\t\t\t\t\t\r\n\t\t\tif mouseb[0]:\r\n\t\t\t\tif mouse[0] >= 0 and mouse[0] < 384:\r\n\t\t\t\t\ttile = int(int(mouse[0]/16) + int(graphics.scroll_x/16) + (int(mouse[1]/16) + int(graphics.scroll_y/16))*graphics.tilemap_width)\r\n\t\t\t\t\tif tile >= 0 and tile < graphics.tilemap_width*graphics.tilemap_height:\r\n\t\t\t\t\t\tlevel.direction[tile] = editor.object_\r\n\t\t\t\t\t\t\r\n\t\tdraw_screen(editor, level, graphics)\r\n\t\tpygame.time.wait(1)\r\n\t\tt = pygame.time.get_ticks() - ticks\r\n\t\tticks = pygame.time.get_ticks()\r\n\t\ti += 1\r\n\tgraphics.screen.fill((32, 0, 64))\r\n\tpygame.display.flip()\r\n\tf = data.load('level.map', 'wb')\r\n\tcPickle.dump(level, f)\r\n\tf = data.load(\"tileset.png\")\r\n\tgraph.load_tileset(f, graphics)\r\n\tf.close()\r\n", "description": null, "category": "graphics", "imports": ["import data\r", "import graph\r", "import pygame\r", "import cPickle\r"]}], [{"term": "class", "name": "GraphicsStatics", "data": "class GraphicsStatics(object):\n\t\n\t# Globals\n\tg_palette = []\n\tg_hatch = ['/', '\\\\', '|', '-', '+', 'x', 'o', 'O', '.', '*']\n\tg_linestyle = ['-', '--', '-.', ':']\n\n\tg_fig_size_base = 10\n\tg_styles_initialized = False\n\n\t@staticmethod\n\tdef initialize_matplotlib_styles():\n\n\t\tif not GraphicsStatics.g_styles_initialized:\n\t\t\tsns.set()\n\t\t\tsns.set_style('whitegrid', {'axes.facecolor': '.9'})\n\t\t\tplt.style.use('fivethirtyeight')\n\t\t\tsns.set_context('talk')\n\n\t\t\t# Assign the default palette\n\t\t\tGraphicsStatics.g_palette = sns.color_palette('Set2', 8)\n\n\t\t\tsns.set_palette(\n\t\t\t\tGraphicsStatics.g_palette)\n\n\t\t\tpyl.rcParams['figure.figsize'] = GraphicsStatics.get_landscape_fig_size()\n\t\t\tplt.rcParams['figure.figsize'] = GraphicsStatics.get_landscape_fig_size()\n\t\t\tplt.rcParams['axes.labelsize'] = 2*GraphicsStatics.g_fig_size_base\n\t\t\tplt.rcParams['axes.titlesize'] = 2*GraphicsStatics.g_fig_size_base\n\n\t\t\tGraphicsStatics.g_styles_initialized = True\n\n\t@staticmethod\n\tdef set_fig_size_base(value):\n\t\tGraphicsStatics.g_fig_size_base = value\n\t\tGraphicsStatics.g_styles_initialized = False\n\t\tGraphicsStatics.initialize_matplotlib_styles()\n\n\t@staticmethod\n\tdef get_landscape_fig_size():\n\t\treturn (2*GraphicsStatics.g_fig_size_base, GraphicsStatics.g_fig_size_base)\n\n\t@staticmethod\n\tdef get_square_fig_size():\n\t\treturn (2*GraphicsStatics.g_fig_size_base, 2*GraphicsStatics.g_fig_size_base)\n\n\t@staticmethod\n\tdef get_portrait_fig_size():\n\t\treturn (GraphicsStatics.g_fig_size_base, 2*GraphicsStatics.g_fig_size_base)\n\n\t@staticmethod\n\tdef get_color(index):\n\t\treturn GraphicsStatics.g_palette[index % len(GraphicsStatics.g_palette)]\n\n\t@staticmethod\n\tdef get_hatch(index):\n\t\treturn GraphicsStatics.g_hatch[index % len(GraphicsStatics.g_hatch)]\n\n\t@staticmethod\n\tdef get_linestyle(index):\n\t\treturn GraphicsStatics.g_linestyle[index % len(GraphicsStatics.g_linestyle)]\n\n\t@staticmethod\n\tdef style_plot(title, subtitle, tl_name, fig, ax, experiment_manager=None, top=0.91, tight_layout=False):\n\n\t\tfig.subplots_adjust(top=top)\n\n\t\tif title is not None:\n\t\t\tfig.suptitle(\n\t\t\t\tt=title, \n\t\t\t\tfontsize=26, \n\t\t\t\tfontweight='bold',\n\t\t\t\tverticalalignment='top',\n\t\t\t\thorizontalalignment='center',\n\t\t\t\tfontstyle='italic',\n\t\t\t\tx=(fig.subplotpars.right + fig.subplotpars.left)/2)\n\n\t\tif subtitle is not None:\n\t\t\tax.set_title(\n\t\t\t\tlabel=subtitle, \n\t\t\t\tfontdict={ \n\t\t\t\t\t'fontsize': 18,\n\t\t\t\t\t'horizontalalignment': 'center'\n\t\t\t\t})\n\n\t\tif experiment_manager:\n\t\t\texperiment_id = experiment_manager.get_experiment_id()\n\n\t\t\tif experiment_manager is not None:\n\t\t\t\tfig.text(\n\t\t\t\t\tx=0.98, \n\t\t\t\t\ty=1, \n\t\t\t\t\ts=experiment_id, \n\t\t\t\t\tha='right', \n\t\t\t\t\tva='top',\n\t\t\t\t\tfontsize=16,\n\t\t\t\t\tfontstyle='italic',\n\t\t\t\t\tbbox={ \n\t\t\t\t\t\t'facecolor': GraphicsStatics.get_color(6), \n\t\t\t\t\t\t'alpha': 0.5, \n\t\t\t\t\t\t'pad': 7\n\t\t\t\t\t})\t\n\t\t\n\t\tif tl_name is not None:\n\t\t\tfig.text(\n\t\t\t\tx=0.02, \n\t\t\t\ty=1, \n\t\t\t\ts=tl_name, \n\t\t\t\tha='left', \n\t\t\t\tva='top',\n\t\t\t\tfontsize=16,\n\t\t\t\tfontstyle='italic',\n\t\t\t\tbbox={ \n\t\t\t\t\t'facecolor': GraphicsStatics.get_color(5), \n\t\t\t\t\t'alpha': 0.5, \n\t\t\t\t\t'pad': 7\n\t\t\t\t})\n\n\t\tif tight_layout:\n\t\t\tplt.tight_layout()\n\t\t\t\n\t\tif experiment_manager is not None:\n\t\t\texperiment_manager.log_chart_to_neptune(\n\t\t\t\tfigure=fig, \n\t\t\t\tname=tl_name.replace('\\n', ' - '))\n\n", "description": null, "category": "graphics", "imports": ["import matplotlib as mat", "from matplotlib import pyplot as plt", "import pylab as pyl", "import seaborn as sns"]}], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, **kargs):\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [{"term": "def", "name": "write", "data": "def write(font, message, pos):\n\tmy_font = fonts[font]\n\tmessage = str.lower(message)\n\tif len(message) > 0:\n\t\tfor i in range(len(message)):\n\t\t\tif message[i] != ' ':\n\t\t\t\tletter_image = my_font[message[i]]\n\t\t\t\tpos_y = pos[1] - my_font[size_y] / 2\n\t\t\t\tpos_x = (i - (len(message) / 2)) * (my_font[size_x] + 5) + pos[0]\n\n\t\t\t\trenderer.screen.blit(letter_image, (pos_x, pos_y))\n\n", "description": null, "category": "graphics", "imports": ["import pygame as py", "import renderer as renderer"]}, {"term": "def", "name": "write_from_left", "data": "def write_from_left(font, message, pos):\n\tmy_font = fonts[font]\n\tmessage = str.lower(message)\n\tif len(message) > 0:\n\t\tfor i in range(len(message)):\n\t\t\tif message[i] != ' ':\n\t\t\t\tletter_image = my_font[message[i]]\n\t\t\t\tpos_y = pos[1] - my_font[size_y] / 2\n\t\t\t\tpos_x = i * (my_font[size_x] + 20) + pos[0]\n\n\t\t\t\trenderer.screen.blit(letter_image, (pos_x, pos_y))\n", "description": null, "category": "graphics", "imports": ["import pygame as py", "import renderer as renderer"]}], [{"term": "def", "name": "darken", "data": "def darken(color, factor=0.7):\n\t\"\"\"Return darkened color as a ReportLab RGB color.\n\n\tTake a passed color and returns a Reportlab color that is darker by the\n\tfactor indicated in the parameter.\n\t\"\"\"\n\tnewcol = color_to_reportlab(color)\n\tfor a in [\"red\", \"green\", \"blue\"]:\n\t\tsetattr(newcol, a, factor * getattr(newcol, a))\n\treturn newcol\n\n", "description": "Return darkened color as a ReportLab RGB color.\n\n\tTake a passed color and returns a Reportlab color that is darker by the\n\tfactor indicated in the parameter.\n\t", "category": "graphics", "imports": ["import os", "import tempfile", "from io import BytesIO", "\tfrom reportlab.lib import colors", "\tfrom reportlab.pdfgen import canvas", "\tfrom Bio import MissingPythonDependencyError", "\tfrom PIL import Image", "\tfrom Bio import MissingPythonDependencyError", "from urllib.request import urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\t\timport_imagemap=False,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "def", "name": "color_to_reportlab", "data": "def color_to_reportlab(color):\n\t\"\"\"Return the passed color in Reportlab Color format.\n\n\tWe allow colors to be specified as hex values, tuples, or Reportlab Color\n\tobjects, and with or without an alpha channel. This function acts as a\n\tRosetta stone for conversion of those formats to a Reportlab Color\n\tobject, with alpha value.\n\n\tAny other color specification is returned directly\n\t\"\"\"\n\t# Reportlab Color objects are in the format we want already\n\tif isinstance(color, colors.Color):\n\t\treturn color\n\telif isinstance(color, str):  # String implies hex color\n\t\tif color.startswith(\"0x\"):  # Standardise to octothorpe\n\t\t\tcolor.replace(\"0x\", \"#\")\n\t\tif len(color) == 7:\n\t\t\treturn colors.HexColor(color)\n\t\telse:\n\t\t\ttry:\n\t\t\t\treturn colors.HexColor(color, hasAlpha=True)\n\t\t\texcept TypeError:  # Catch pre-2.7 Reportlab\n\t\t\t\traise RuntimeError(\n\t\t\t\t\t\"Your reportlab seems to be too old, try 2.7 onwards\"\n\t\t\t\t) from None\n\telif isinstance(color, tuple):  # Tuple implies RGB(alpha) tuple\n\t\treturn colors.Color(*color)\n\treturn color\n\n", "description": "Return the passed color in Reportlab Color format.\n\n\tWe allow colors to be specified as hex values, tuples, or Reportlab Color\n\tobjects, and with or without an alpha channel. This function acts as a\n\tRosetta stone for conversion of those formats to a Reportlab Color\n\tobject, with alpha value.\n\n\tAny other color specification is returned directly\n\t", "category": "graphics", "imports": ["import os", "import tempfile", "from io import BytesIO", "\tfrom reportlab.lib import colors", "\tfrom reportlab.pdfgen import canvas", "\tfrom Bio import MissingPythonDependencyError", "\tfrom PIL import Image", "\tfrom Bio import MissingPythonDependencyError", "from urllib.request import urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\t\timport_imagemap=False,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "def", "name": "get_temp_imagefilename", "data": "def get_temp_imagefilename(url):\n\t\"\"\"Return filename of temporary file containing downloaded image.\n\n\tCreate a new temporary file to hold the image file at the passed URL\n\tand return the filename.\n\t\"\"\"\n\timg = urlopen(url).read()\n\tim = Image.open(BytesIO(img))\n\t# im.transpose(Image.FLIP_TOP_BOTTOM)\n\tf = tempfile.NamedTemporaryFile(delete=False, suffix=\".png\")\n\tfname = f.name\n\tf.close()\n\tim.save(fname, \"PNG\")\n\treturn fname\n\n", "description": "Return filename of temporary file containing downloaded image.\n\n\tCreate a new temporary file to hold the image file at the passed URL\n\tand return the filename.\n\t", "category": "graphics", "imports": ["import os", "import tempfile", "from io import BytesIO", "\tfrom reportlab.lib import colors", "\tfrom reportlab.pdfgen import canvas", "\tfrom Bio import MissingPythonDependencyError", "\tfrom PIL import Image", "\tfrom Bio import MissingPythonDependencyError", "from urllib.request import urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\t\timport_imagemap=False,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "class", "name": "classKGMLCanvas:", "data": "class KGMLCanvas:\n\t\"\"\"Reportlab Canvas-based representation of a KGML pathway map.\"\"\"\n\n\tdef __init__(\n\t\tself,\n\t\tpathway,\n\t\timport_imagemap=False,\n\t\tlabel_compounds=True,\n\t\tlabel_orthologs=True,\n\t\tlabel_reaction_entries=True,\n\t\tlabel_maps=True,\n\t\tshow_maps=False,\n\t\tfontname=\"Helvetica\",\n\t\tfontsize=6,\n\t\tdraw_relations=True,\n\t\tshow_orthologs=True,\n\t\tshow_compounds=True,\n\t\tshow_genes=True,\n\t\tshow_reaction_entries=True,\n\t\tmargins=(0.02, 0.02),\n\t):\n\t\t\"\"\"Initialize the class.\"\"\"\n\t\tself.pathway = pathway\n\t\tself.show_maps = show_maps\n\t\tself.show_orthologs = show_orthologs\n\t\tself.show_compounds = show_compounds\n\t\tself.show_genes = show_genes\n\t\tself.show_reaction_entries = show_reaction_entries\n\t\tself.label_compounds = label_compounds\n\t\tself.label_orthologs = label_orthologs\n\t\tself.label_reaction_entries = label_reaction_entries\n\t\tself.label_maps = label_maps\n\t\tself.fontname = fontname\n\t\tself.fontsize = fontsize\n\t\tself.draw_relations = draw_relations\n\t\tself.non_reactant_transparency = 0.3\n\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL\n\t\t# percentage of canvas that will be margin in on either side in the\n\t\t# X and Y directions\n\t\tself.margins = margins\n\n\tdef draw(self, filename):\n\t\t\"\"\"Add the map elements to the drawing.\"\"\"\n\t\t# Instantiate the drawing, first\n\t\t# size x_max, y_max for now - we can add margins, later\n\t\tif self.import_imagemap:\n\t\t\t# We're drawing directly on the image, so we set the canvas to the\n\t\t\t# same size as the image\n\t\t\tif os.path.isfile(self.pathway.image):\n\t\t\t\timfilename = self.pathway.image\n\t\t\telse:\n\t\t\t\timfilename = get_temp_imagefilename(self.pathway.image)\n\t\t\tim = Image.open(imfilename)\n\t\t\tcwidth, cheight = im.size\n\t\telse:\n\t\t\t# No image, so we set the canvas size to accommodate visible\n\t\t\t# elements\n\t\t\tcwidth, cheight = (self.pathway.bounds[1][0], self.pathway.bounds[1][1])\n\t\t# Instantiate canvas\n\t\tself.drawing = canvas.Canvas(\n\t\t\tfilename,\n\t\t\tbottomup=0,\n\t\t\tpagesize=(\n\t\t\t\tcwidth * (1 + 2 * self.margins[0]),\n\t\t\t\tcheight * (1 + 2 * self.margins[1]),\n\t\t\t),\n\t\t)\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\t\t# Transform the canvas to add the margins\n\t\tself.drawing.translate(\n\t\t\tself.margins[0] * self.pathway.bounds[1][0],\n\t\t\tself.margins[1] * self.pathway.bounds[1][1],\n\t\t)\n\t\t# Add the map image, if required\n\t\tif self.import_imagemap:\n\t\t\tself.drawing.saveState()\n\t\t\tself.drawing.scale(1, -1)\n\t\t\tself.drawing.translate(0, -cheight)\n\t\t\tself.drawing.drawImage(imfilename, 0, 0)\n\t\t\tself.drawing.restoreState()\n\t\t# Add the reactions, compounds and maps\n\t\t# Maps go on first, to be overlaid by more information.\n\t\t# By default, they're slightly transparent.\n\t\tif self.show_maps:\n\t\t\tself.__add_maps()\n\t\tif self.show_reaction_entries:\n\t\t\tself.__add_reaction_entries()\n\t\tif self.show_orthologs:\n\t\t\tself.__add_orthologs()\n\t\tif self.show_compounds:\n\t\t\tself.__add_compounds()\n\t\tif self.show_genes:\n\t\t\tself.__add_genes()\n\t\t# TODO: complete draw_relations code\n\t\t# if self.draw_relations:\n\t\t#\tself.__add_relations()\n\t\t# Write the pathway map to PDF\n\t\tself.drawing.save()\n\n\tdef __add_maps(self):\n\t\t\"\"\"Add maps to the drawing of the map (PRIVATE).\n\n\t\tWe do this first, as they're regional labels to be overlaid by\n\t\tinformation.  Also, we want to set the color to something subtle.\n\n\t\tWe're using Hex colors because that's what KGML uses, and\n\t\tReportlab doesn't mind.\n\t\t\"\"\"\n\t\tfor m in self.pathway.maps:\n\t\t\tfor g in m.graphics:\n\t\t\t\tself.drawing.setStrokeColor(\"#888888\")\n\t\t\t\tself.drawing.setFillColor(\"#DDDDDD\")\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_maps:\n\t\t\t\t\tself.drawing.setFillColor(\"#888888\")\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_graphics(self, graphics):\n\t\t\"\"\"Add the passed graphics object to the map (PRIVATE).\n\n\t\tAdd text, add after the graphics object, for sane Z-ordering.\n\t\t\"\"\"\n\t\tif graphics.type == \"line\":\n\t\t\tp = self.drawing.beginPath()\n\t\t\tx, y = graphics.coords[0]\n\t\t\t# There are optional settings for lines that aren't necessarily\n\t\t\t# part of the KGML DTD\n\t\t\tif graphics.width is not None:\n\t\t\t\tself.drawing.setLineWidth(graphics.width)\n\t\t\telse:\n\t\t\t\tself.drawing.setLineWidth(1)\n\t\t\tp.moveTo(x, y)\n\t\t\tfor (x, y) in graphics.coords:\n\t\t\t\tp.lineTo(x, y)\n\t\t\tself.drawing.drawPath(p)\n\t\t\tself.drawing.setLineWidth(1)  # Return to default\n\t\t# KGML defines the (x, y) coordinates as the centre of the circle/\n\t\t# rectangle/roundrectangle, but Reportlab uses the coordinates of the\n\t\t# lower-left corner for rectangle/elif.\n\t\tif graphics.type == \"circle\":\n\t\t\tself.drawing.circle(\n\t\t\t\tgraphics.x, graphics.y, graphics.width * 0.5, stroke=1, fill=1\n\t\t\t)\n\t\telif graphics.type == \"roundrectangle\":\n\t\t\tself.drawing.roundRect(\n\t\t\t\tgraphics.x - graphics.width * 0.5,\n\t\t\t\tgraphics.y - graphics.height * 0.5,\n\t\t\t\tgraphics.width,\n\t\t\t\tgraphics.height,\n\t\t\t\tmin(graphics.width, graphics.height) * 0.1,\n\t\t\t\tstroke=1,\n\t\t\t\tfill=1,\n\t\t\t)\n\t\telif graphics.type == \"rectangle\":\n\t\t\tself.drawing.rect(\n\t\t\t\tgraphics.x - graphics.width * 0.5,\n\t\t\t\tgraphics.y - graphics.height * 0.5,\n\t\t\t\tgraphics.width,\n\t\t\t\tgraphics.height,\n\t\t\t\tstroke=1,\n\t\t\t\tfill=1,\n\t\t\t)\n\n\tdef __add_labels(self, graphics):\n\t\t\"\"\"Add labels for the passed graphics objects to the map (PRIVATE).\n\n\t\tWe don't check that the labels fit inside objects such as circles/\n\t\trectangles/roundrectangles.\n\t\t\"\"\"\n\t\tif graphics.type == \"line\":\n\t\t\t# We use the midpoint of the line - sort of - we take the median\n\t\t\t# line segment (list-wise, not in terms of length), and use the\n\t\t\t# midpoint of that line.  We could have other options here,\n\t\t\t# maybe even parameterising it to a proportion of the total line\n\t\t\t# length.\n\t\t\tmid_idx = len(graphics.coords) * 0.5\n\t\t\tif not int(mid_idx) == mid_idx:\n\t\t\t\tidx1, idx2 = int(mid_idx - 0.5), int(mid_idx + 0.5)\n\t\t\telse:\n\t\t\t\tidx1, idx2 = int(mid_idx - 1), int(mid_idx)\n\t\t\tx1, y1 = graphics.coords[idx1]\n\t\t\tx2, y2 = graphics.coords[idx2]\n\t\t\tx, y = 0.5 * (x1 + x2), 0.5 * (y1 + y2)\n\t\telif graphics.type == \"circle\":\n\t\t\tx, y = graphics.x, graphics.y\n\t\telif graphics.type in (\"rectangle\", \"roundrectangle\"):\n\t\t\tx, y = graphics.x, graphics.y\n\t\t# How big so we want the text, and how many characters?\n\t\tif graphics._parent.type == \"map\":\n\t\t\ttext = graphics.name\n\t\t\tself.drawing.setFont(self.fontname, self.fontsize + 2)\n\t\telif len(graphics.name) < 15:\n\t\t\ttext = graphics.name\n\t\telse:\n\t\t\ttext = graphics.name[:12] + \"...\"\n\t\tself.drawing.drawCentredString(x, y, text)\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\n\tdef __add_orthologs(self):\n\t\t\"\"\"Add 'ortholog' Entry elements to the drawing of the map (PRIVATE).\n\n\t\tIn KGML, these are typically line objects, so we render them\n\t\tbefore the compound circles to cover the unsightly ends/junctions.\n\t\t\"\"\"\n\t\tfor ortholog in self.pathway.orthologs:\n\t\t\tfor g in ortholog.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_orthologs:\n\t\t\t\t\t# We want the label color to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_reaction_entries(self):\n\t\t\"\"\"Add Entry elements for Reactions to the map drawing (PRIVATE).\n\n\t\tIn KGML, these are typically line objects, so we render them\n\t\tbefore the compound circles to cover the unsightly ends/junctions\n\t\t\"\"\"\n\t\tfor reaction in self.pathway.reaction_entries:\n\t\t\tfor g in reaction.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_reaction_entries:\n\t\t\t\t\t# We want the label color to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_compounds(self):\n\t\t\"\"\"Add compound elements to the drawing of the map (PRIVATE).\"\"\"\n\t\tfor compound in self.pathway.compounds:\n\t\t\tfor g in compound.graphics:\n\t\t\t\t# Modify transparency of compounds that don't participate\n\t\t\t\t# in reactions\n\t\t\t\tfillcolor = color_to_reportlab(g.bgcolor)\n\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\tfillcolor.alpha *= self.non_reactant_transparency\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(fillcolor)\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\t\tt = 0.3\n\t\t\t\t\telse:\n\t\t\t\t\t\tt = 1\n\t\t\t\t\tself.drawing.setFillColor(colors.Color(0.2, 0.2, 0.2, t))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_genes(self):\n\t\t\"\"\"Add gene elements to the drawing of the map (PRIVATE).\"\"\"\n\t\tfor gene in self.pathway.genes:\n\t\t\tfor g in gene.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_relations(self):\n\t\t\"\"\"Add relations to the map (PRIVATE).\n\n\t\tThis is tricky. There is no defined graphic in KGML for a\n\t\trelation, and the corresponding entries are typically defined\n\t\tas objects 'to be connected somehow'.  KEGG uses KegSketch, which\n\t\tis not public, and most third-party software draws straight line\n\t\tarrows, with heads to indicate the appropriate direction\n\t\t(at both ends for reversible reactions), using solid lines for\n\t\tECrel relation types, and dashed lines for maplink relation types.\n\n\t\tThe relation has:\n\t\t- entry1: 'from' node\n\t\t- entry2: 'to' node\n\t\t- subtype: what the relation refers to\n\n\t\tTypically we have entry1 = map/ortholog; entry2 = map/ortholog,\n\t\tsubtype = compound.\n\t\t\"\"\"\n\t\t# Dashed lines for maplinks, solid for everything else\n\t\tfor relation in list(self.pathway.relations):\n\t\t\tif relation.type == \"maplink\":\n\t\t\t\tself.drawing.setDash(6, 3)\n\t\t\telse:\n\t\t\t\tself.drawing.setDash()\n\t\t\tfor s in relation.subtypes:\n\t\t\t\tsubtype = self.pathway.entries[s[1]]\n\t\t\t\t# Our aim is to draw an arrow from the entry1 object to the\n\t\t\t\t# entry2 object, via the subtype object.\n\t\t\t\t# 1) Entry 1 to subtype\n\t\t\t\tself.__draw_arrow(relation.entry1, subtype)\n\t\t\t\t# 2) subtype to Entry 2\n\t\t\t\tself.__draw_arrow(subtype, relation.entry2)\n\n\tdef __draw_arrow(self, g_from, g_to):\n\t\t\"\"\"Draw an arrow between given Entry objects (PRIVATE).\n\n\t\tDraws an arrow from the g_from Entry object to the g_to\n\t\tEntry object; both must have Graphics objects.\n\t\t\"\"\"\n\t\t# Centre and bound coordinates for the from and two objects\n\t\tbounds_from, bounds_to = g_from.bounds, g_to.bounds\n\t\tcentre_from = (\n\t\t\t0.5 * (bounds_from[0][0] + bounds_from[1][0]),\n\t\t\t0.5 * (bounds_from[0][1] + bounds_from[1][1]),\n\t\t)\n\t\tcentre_to = (\n\t\t\t0.5 * (bounds_to[0][0] + bounds_to[1][0]),\n\t\t\t0.5 * (bounds_to[0][1] + bounds_to[1][1]),\n\t\t)\n\t\tp = self.drawing.beginPath()\n\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t# If the 'from' and 'to' graphics are vertically-aligned, draw a line\n\t\t# from the 'from' to the 'to' entity\n\t\tif bounds_to[0][0] < centre_from[0] < bounds_to[1][0]:\n\t\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t\tif centre_to[1] > centre_from[1]:  # to above from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\t\telse:  # to below from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\telif bounds_from[0][0] < centre_to[0] < bounds_from[1][0]:\n\t\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t\tif centre_to[1] > centre_from[1]:  # to above from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\t\telse:  # to below from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\tself.drawing.drawPath(p)  # Draw arrow shaft\n\t\t# print(g_from)\n\t\t# print(bounds_from)\n\t\t# print(g_to)\n\t\t# print(bounds_to)\n", "description": "Reportlab Canvas-based representation of a KGML pathway map.", "category": "graphics", "imports": ["import os", "import tempfile", "from io import BytesIO", "\tfrom reportlab.lib import colors", "\tfrom reportlab.pdfgen import canvas", "\tfrom Bio import MissingPythonDependencyError", "\tfrom PIL import Image", "\tfrom Bio import MissingPythonDependencyError", "from urllib.request import urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\t\timport_imagemap=False,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}], [], [{"term": "def", "name": "f_fromUtf8", "data": "\tdef _fromUtf8(s):\n\t\treturn s\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtCore, QtGui"]}, {"term": "def", "name": "f_translate", "data": "\tdef _translate(context, text, disambig):\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtCore, QtGui"]}, {"term": "def", "name": "f_translate", "data": "\tdef _translate(context, text, disambig):\n\t\treturn QtGui.QApplication.translate(context, text, disambig)\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtCore, QtGui"]}, {"term": "class", "name": "Ui_Form", "data": "class Ui_Form(object):\n\tdef setupUi(self, Form):\n\t\tForm.setObjectName(_fromUtf8(\"Form\"))\n\t\tForm.resize(1440, 900)\n\t\tself.graphicsView_MT = QtGui.QGraphicsView(Form)\n\t\tself.graphicsView_MT.setGeometry(QtCore.QRect(210, 40, 500, 360))\n\t\tself.graphicsView_MT.setObjectName(_fromUtf8(\"graphicsView_MT\"))\n\t\tself.graphicsView_OEE = QtGui.QGraphicsView(Form)\n\t\tself.graphicsView_OEE.setGeometry(QtCore.QRect(740, 40, 500, 360))\n\t\tself.graphicsView_OEE.setObjectName(_fromUtf8(\"graphicsView_OEE\"))\n\t\tself.graphicsView_Loss = QtGui.QGraphicsView(Form)\n\t\tself.graphicsView_Loss.setGeometry(QtCore.QRect(210, 450, 500, 360))\n\t\tself.graphicsView_Loss.setObjectName(_fromUtf8(\"graphicsView_Loss\"))\n\t\tself.graphicsView_Pie = QtGui.QGraphicsView(Form)\n\t\tself.graphicsView_Pie.setGeometry(QtCore.QRect(740, 450, 500, 360))\n\t\tself.graphicsView_Pie.setObjectName(_fromUtf8(\"graphicsView_Pie\"))\n\n\t\tself.retranslateUi(Form)\n\t\tQtCore.QMetaObject.connectSlotsByName(Form)\n\n\tdef retranslateUi(self, Form):\n\t\tForm.setWindowTitle(_translate(\"Form\", \"Form\", None))\n\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtCore, QtGui"]}], [{"term": "def", "name": "graphics_pipe", "data": "def graphics_pipe():\n\tfrom panda3d.core import GraphicsPipeSelection\n\n\tpipe = GraphicsPipeSelection.get_global_ptr().make_default_pipe()\n\n\tif pipe is None or not pipe.is_valid():\n\t\tpytest.skip(\"GraphicsPipe is invalid\")\n\n\tyield pipe\n\n", "description": null, "category": "graphics", "imports": ["import pytest", "\tfrom panda3d.core import GraphicsPipeSelection", "\tfrom panda3d.core import GraphicsEngine", "\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties", "\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties"]}, {"term": "def", "name": "graphics_engine", "data": "def graphics_engine():\n\tfrom panda3d.core import GraphicsEngine\n\n\tengine = GraphicsEngine.get_global_ptr()\n\tyield engine\n\n\t# This causes GraphicsEngine to also terminate the render threads.\n\tengine.remove_all_windows()\n\n", "description": null, "category": "graphics", "imports": ["import pytest", "\tfrom panda3d.core import GraphicsPipeSelection", "\tfrom panda3d.core import GraphicsEngine", "\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties", "\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties"]}, {"term": "def", "name": "window", "data": "def window(graphics_pipe, graphics_engine):\n\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties\n\n\tfbprops = FrameBufferProperties.get_default()\n\twinprops = WindowProperties.get_default()\n\n\twin = graphics_engine.make_output(\n\t\tgraphics_pipe,\n\t\t'window',\n\t\t0,\n\t\tfbprops,\n\t\twinprops,\n\t\tGraphicsPipe.BF_require_window\n\t)\n\tgraphics_engine.open_windows()\n\n\tif win is None:\n\t\tpytest.skip(\"GraphicsPipe cannot make windows\")\n\n\tyield win\n\n\tif win is not None:\n\t\tgraphics_engine.remove_window(win)\n\n", "description": null, "category": "graphics", "imports": ["import pytest", "\tfrom panda3d.core import GraphicsPipeSelection", "\tfrom panda3d.core import GraphicsEngine", "\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties", "\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties"]}, {"term": "def", "name": "gsg", "data": "def gsg(graphics_pipe, graphics_engine):\n\t\"Returns a windowless GSG that can be used for offscreen rendering.\"\n\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties\n\n\tfbprops = FrameBufferProperties()\n\tfbprops.force_hardware = True\n\n\tbuffer = graphics_engine.make_output(\n\t\tgraphics_pipe,\n\t\t'buffer',\n\t\t0,\n\t\tfbprops,\n\t\tWindowProperties.size(32, 32),\n\t\tGraphicsPipe.BF_refuse_window\n\t)\n\tgraphics_engine.open_windows()\n\n\tif buffer is None:\n\t\tpytest.skip(\"GraphicsPipe cannot make offscreen buffers\")\n\n\tyield buffer.gsg\n\n\tif buffer is not None:\n\t\tgraphics_engine.remove_window(buffer)\n", "description": null, "category": "graphics", "imports": ["import pytest", "\tfrom panda3d.core import GraphicsPipeSelection", "\tfrom panda3d.core import GraphicsEngine", "\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties", "\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties"]}], [{"term": "def", "name": "main", "data": "def main():\n\t\"\"\"\n\tThis program plays a Python game 'zone'\n\tA ball will be bouncing around the GWindow\n\tPlayers must defend the zone indicated by black\n\tline at the middle of the GWindow by clicking on\n\tthe bouncing ball\n\t\"\"\"\n\tgraphics = ZoneGraphics()\n\twhile True:\n\t\t# Update\n\t\tgraphics.ball.move(graphics.vx, graphics.vy)\n\n\t\t# Check\n\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width > graphics.w.width:\n\t\t\tgraphics.vx *= -1\n\t\tif graphics.ball.y <= 0 or graphics.ball.y + graphics.ball.height > graphics.w.height:\n\t\t\tgraphics.vy *= -1\n\t\t# Pause\n\t\tpause(FRAME_RATE)\n\n", "description": "\n\tThis program plays a Python game 'zone'\n\tA ball will be bouncing around the GWindow\n\tPlayers must defend the zone indicated by black\n\tline at the middle of the GWindow by clicking on\n\tthe bouncing ball\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from zonegraphics import ZoneGraphics"]}], [{"term": "class", "name": "Line", "data": "class Line(GraphicPrimitive_xydata):\n\t\"\"\"\n\tPrimitive class that initializes the line graphics type.\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.line import Line\n\t\tsage: Line([1,2,7], [1,5,-1], {})\n\t\tLine defined by 3 points\n\t\"\"\"\n\tdef __init__(self, xdata, ydata, options):\n\t\t\"\"\"\n\t\tInitialize a line graphics primitive.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: from sage.plot.line import Line\n\t\t\tsage: Line([-1,2], [17,4], {'thickness':2})\n\t\t\tLine defined by 2 points\n\t\t\"\"\"\n\t\tvalid_options = self._allowed_options().keys()\n\t\tfor opt in options.iterkeys():\n\t\t\tif opt not in valid_options:\n\t\t\t\traise RuntimeError(\"Error in line(): option '%s' not valid.\"%opt)\n\t\tself.xdata = xdata\n\t\tself.ydata = ydata\n\t\tGraphicPrimitive_xydata.__init__(self, options)\n\n\tdef _allowed_options(self):\n\t\t\"\"\"\n\t\tDisplayed the list of allowed line options.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: from sage.plot.line import Line\n\t\t\tsage: list(sorted(Line([-1,2], [17,4], {})._allowed_options().iteritems()))\n\t\t\t[('alpha', 'How transparent the line is.'),\n\t\t\t ('hue', 'The color given as a hue.'),\n\t\t\t ('legend_color', 'The color of the legend text.'),\n\t\t\t ('legend_label', 'The label for this item in the legend.'),\n\t\t\t ('linestyle',\n\t\t\t  \"The style of the line, which is one of '--' (dashed), '-.' (dash dot), '-' (solid), 'steps', ':' (dotted).\"),\n\t\t\t ('marker', 'the marker symbol (see documentation for line2d for details)'),\n\t\t\t ('markeredgecolor', 'the color of the marker edge'),\n\t\t\t ('markeredgewidth', 'the size of the marker edge in points'),\n\t\t\t ('markerfacecolor', 'the color of the marker face'),\n\t\t\t ('markersize', 'the size of the marker in points'),\n\t\t\t ('rgbcolor', 'The color as an RGB tuple.'),\n\t\t\t ('thickness', 'How thick the line is.'),\n\t\t\t ('zorder', 'The layer level in which to draw')]\n\t\t\"\"\"\n\t\treturn {'alpha':'How transparent the line is.',\n\t\t\t\t'legend_color':'The color of the legend text.',\n\t\t\t\t'legend_label':'The label for this item in the legend.',\n\t\t\t\t'thickness':'How thick the line is.',\n\t\t\t\t'rgbcolor':'The color as an RGB tuple.',\n\t\t\t\t'hue':'The color given as a hue.',\n\t\t\t\t'linestyle':\"The style of the line, which is one of '--' (dashed), '-.' (dash dot), '-' (solid), 'steps', ':' (dotted).\",\n\t\t\t\t'marker':\"the marker symbol (see documentation for line2d for details)\",\n\t\t\t\t'markersize':'the size of the marker in points',\n\t\t\t\t'markeredgecolor':'the color of the marker edge',\n\t\t\t\t'markeredgewidth':'the size of the marker edge in points',\n\t\t\t\t'markerfacecolor':'the color of the marker face',\n\t\t\t\t'zorder':'The layer level in which to draw'\n\t\t\t\t}\n\n\tdef _plot3d_options(self, options=None):\n\t\t\"\"\"\n\t\tTranslate 2D plot options into 3D plot options.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: L = line([(1,1), (1,2), (2,2), (2,1)], alpha=.5, thickness=10, zorder=2)\n\t\t\tsage: l=L[0]; l\n\t\t\tLine defined by 4 points\n\t\t\tsage: m=l.plot3d(z=2)\n\t\t\tsage: m.texture.opacity\n\t\t\t0.5\n\t\t\tsage: m.thickness\n\t\t\t10\n\t\t\tsage: L = line([(1,1), (1,2), (2,2), (2,1)], linestyle=\":\")\n\t\t\tsage: L.plot3d()\n\t\t\tTraceback (most recent call last):\n\t\t\tNotImplementedError: Invalid 3d line style: ':'\n\t\t\"\"\"\n\t\tif options is None:\n\t\t\toptions = dict(self.options())\n\t\toptions_3d = {}\n\t\tif 'thickness' in options:\n\t\t\toptions_3d['thickness'] = options['thickness']\n\t\t\tdel options['thickness']\n\t\tif 'zorder' in options:\n\t\t\tdel options['zorder']\n\t\tif 'linestyle' in options:\n\t\t\tif options['linestyle'] not in ('-', 'solid'):\n\t\t\t\traise NotImplementedError(\"Invalid 3d line style: '%s'\"%\n\t\t\t\t\t\t\t\t\t\t  (options['linestyle']))\n\t\t\tdel options['linestyle']\n\t\toptions_3d.update(GraphicPrimitive_xydata._plot3d_options(self, options))\n\t\treturn options_3d\n\n\tdef plot3d(self, z=0, **kwds):\n\t\t\"\"\"\n\t\tPlots a 2D line in 3D, with default height zero.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: E = EllipticCurve('37a').plot(thickness=5).plot3d()\n\t\t\tsage: F = EllipticCurve('37a').plot(thickness=5).plot3d(z=2)\n\t\t\tsage: E + F  # long time (5s on sage.math, 2012)\n\t\t\tGraphics3d Object\n\t\t\"\"\"\n\t\tfrom sage.plot.plot3d.shapes2 import line3d\n\t\toptions = self._plot3d_options()\n\t\toptions.update(kwds)\n\t\treturn line3d([(x, y, z) for x, y in zip(self.xdata, self.ydata)], **options)\n\n\tdef _repr_(self):\n\t\t\"\"\"\n\t\tString representation of a line primitive.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: from sage.plot.line import Line\n\t\t\tsage: Line([-1,2,3,3], [17,4,0,2], {})._repr_()\n\t\t\t'Line defined by 4 points'\n\t\t\"\"\"\n\t\treturn \"Line defined by %s points\"%len(self)\n\n\tdef __getitem__(self, i):\n\t\t\"\"\"\n\t\tExtract the i-th element of the line (which is stored as a list of points).\n\n\t\tINPUT:\n\n\t\t- ``i`` -- an integer between 0 and the number of points minus 1\n\n\t\tOUTPUT:\n\n\t\tA 2-tuple of floats.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: L = line([(1,2), (3,-4), (2, 5), (1,2)])\n\t\t\tsage: line_primitive = L[0]; line_primitive\n\t\t\tLine defined by 4 points\n\t\t\tsage: line_primitive[0]\n\t\t\t(1.0, 2.0)\n\t\t\tsage: line_primitive[2]\n\t\t\t(2.0, 5.0)\n\t\t\tsage: list(line_primitive)\n\t\t\t[(1.0, 2.0), (3.0, -4.0), (2.0, 5.0), (1.0, 2.0)]\n\t\t\"\"\"\n\t\treturn self.xdata[i], self.ydata[i]\n\n\tdef __setitem__(self, i, point):\n\t\t\"\"\"\n\t\tSet the i-th element of this line (really a sequence of lines\n\t\tthrough given points).\n\n\t\tINPUT:\n\n\t\t- ``i`` -- an integer between 0 and the number of points on the\n\t\t  line minus 1\n\n\t\t- ``point`` -- a 2-tuple of floats\n\n\t\tEXAMPLES:\n\n\t\tWe create a line graphics object $L$ and get ahold of the\n\t\tcorresponding line graphics primitive::\n\n\t\t\tsage: L = line([(1,2), (3,-4), (2, 5), (1,2)])\n\t\t\tsage: line_primitive = L[0]; line_primitive\n\t\t\tLine defined by 4 points\n\n\t\tWe then set the 0th point to `(0,0)` instead of `(1,2)`::\n\n\t\t\tsage: line_primitive[0] = (0,0)\n\t\t\tsage: line_primitive[0]\n\t\t\t(0.0, 0.0)\n\n\t\tPlotting we visibly see the change -- now the line starts at `(0,0)`::\n\n\t\t\tsage: L\n\t\t\tGraphics object consisting of 1 graphics primitive\n\t\t\"\"\"\n\t\tself.xdata[i] = float(point[0])\n\t\tself.ydata[i] = float(point[1])\n\n\tdef __len__(self):\n\t\tr\"\"\"\n\t\tReturn the number of points on this line (where a line is really a sequence\n\t\tof line segments through a given list of points).\n\n\t\tEXAMPLES:\n\n\t\tWe create a line, then grab the line primitive as ``L[0]`` and compute\n\t\tits length::\n\n\t\t\tsage: L = line([(1,2), (3,-4), (2, 5), (1,2)])\n\t\t\tsage: len(L[0])\n\t\t\t4\n\t\t\"\"\"\n\t\treturn len(self.xdata)\n\n\tdef _render_on_subplot(self, subplot):\n\t\t\"\"\"\n\t\tRender this line on a matplotlib subplot.\n\n\t\tINPUT:\n\n\t\t- ``subplot`` -- a matplotlib subplot\n\n\t\tEXAMPLES:\n\n\t\tThis implicitly calls this function::\n\n\t\t\tsage: line([(1,2), (3,-4), (2, 5), (1,2)])\n\t\t\tGraphics object consisting of 1 graphics primitive\n\t\t\"\"\"\n\t\timport matplotlib.lines as lines\n\t\toptions = dict(self.options())\n\t\tfor o in ('alpha', 'legend_color', 'legend_label', 'linestyle',\n\t\t\t\t  'rgbcolor', 'thickness'):\n\t\t\tif o in options:\n\t\t\t\tdel options[o]\n\t\tp = lines.Line2D(self.xdata, self.ydata, **options)\n\t\toptions = self.options()\n\t\ta = float(options['alpha'])\n\t\tp.set_alpha(a)\n\t\tp.set_linewidth(float(options['thickness']))\n\t\tp.set_color(to_mpl_color(options['rgbcolor']))\n\t\tp.set_label(options['legend_label'])\n\t\t# we don't pass linestyle in directly since the drawstyles aren't\n\t\t# pulled off automatically.  This (I think) is a bug in matplotlib 1.0.1\n\t\tif 'linestyle' in options:\n\t\t\tfrom sage.plot.misc import get_matplotlib_linestyle\n\t\t\tp.set_linestyle(get_matplotlib_linestyle(options['linestyle'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t return_type='short'))\n\t\tsubplot.add_line(p)\n", "description": "\n\tPrimitive class that initializes the line graphics type.\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.line import Line\n\t\tsage: Line([1,2,7], [1,5,-1], {})\n\t\tLine defined by 3 points\n\t", "category": "graphics", "imports": ["from sage.plot.primitive import GraphicPrimitive_xydata", "from sage.misc.decorators import options, rename_keyword", "from sage.plot.colors import to_mpl_color", "\t\tsage: from sage.plot.line import Line", "\t\t\tsage: from sage.plot.line import Line", "\t\t\tsage: from sage.plot.line import Line", "\t\tfrom sage.plot.plot3d.shapes2 import line3d", "\t\t\tsage: from sage.plot.line import Line", "\t\timport matplotlib.lines as lines", "\t\t\tfrom sage.plot.misc import get_matplotlib_linestyle", "\t\tfrom sage.plot.plot3d.shapes2 import line3d", "\t\tsage: import numpy; line(numpy.array([]))", "\tfrom sage.plot.all import Graphics", "\tfrom sage.plot.plot import xydata_from_point_list", "\tfrom sage.rings.all import CC, CDF"]}, {"term": "def", "name": "line", "data": "def line(points, **kwds):\n\t\"\"\"\n\tReturns either a 2-dimensional or 3-dimensional line depending\n\ton value of points.\n\n\tINPUT:\n\n\t-  ``points`` - either a single point (as a tuple), a list of\n\t   points, a single complex number, or a list of complex numbers.\n\n\tFor information regarding additional arguments, see either line2d?\n\tor line3d?.\n\n\tEXAMPLES::\n\n\t\tsage: line([(0,0), (1,1)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: line([(0,0,1), (1,1,1)])\n\t\tGraphics3d Object\n\t\"\"\"\n\ttry:\n\t\treturn line2d(points, **kwds)\n\texcept ValueError:\n\t\tfrom sage.plot.plot3d.shapes2 import line3d\n\t\treturn line3d(points, **kwds)\n\n", "description": "\n\tReturns either a 2-dimensional or 3-dimensional line depending\n\ton value of points.\n\n\tINPUT:\n\n\t-  ``points`` - either a single point (as a tuple), a list of\n\t   points, a single complex number, or a list of complex numbers.\n\n\tFor information regarding additional arguments, see either line2d?\n\tor line3d?.\n\n\tEXAMPLES::\n\n\t\tsage: line([(0,0), (1,1)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: line([(0,0,1), (1,1,1)])\n\t\tGraphics3d Object\n\t", "category": "graphics", "imports": ["from sage.plot.primitive import GraphicPrimitive_xydata", "from sage.misc.decorators import options, rename_keyword", "from sage.plot.colors import to_mpl_color", "\t\tsage: from sage.plot.line import Line", "\t\t\tsage: from sage.plot.line import Line", "\t\t\tsage: from sage.plot.line import Line", "\t\tfrom sage.plot.plot3d.shapes2 import line3d", "\t\t\tsage: from sage.plot.line import Line", "\t\timport matplotlib.lines as lines", "\t\t\tfrom sage.plot.misc import get_matplotlib_linestyle", "\t\tfrom sage.plot.plot3d.shapes2 import line3d", "\t\tsage: import numpy; line(numpy.array([]))", "\tfrom sage.plot.all import Graphics", "\tfrom sage.plot.plot import xydata_from_point_list", "\tfrom sage.rings.all import CC, CDF"]}, {"term": "def", "name": "line2d", "data": "def line2d(points, **options):\n\tr\"\"\"\n\tCreate the line through the given list of points.\n\n\tINPUT:\n\n\t-  ``points`` - either a single point (as a tuple), a list of\n\t   points, a single complex number, or a list of complex numbers.\n\n\tType ``line2d.options`` for a dictionary of the default options for\n\tlines.  You can change this to change the defaults for all future\n\tlines.  Use ``line2d.reset()`` to reset to the default options.\n\n\tINPUT:\n\n\t- ``alpha`` -- How transparent the line is\n\n\t- ``thickness`` -- How thick the line is\n\n\t- ``rgbcolor`` -- The color as an RGB tuple\n\n\t- ``hue`` -- The color given as a hue\n\n\t- ``legend_color`` -- The color of the text in the legend\n\n\t- ``legend_label`` -- the label for this item in the legend\n\n\n\tAny MATPLOTLIB line option may also be passed in.  E.g.,\n\n\t- ``linestyle`` - (default: \"-\") The style of the line, which is one of\n\t   - ``\"-\"`` or ``\"solid\"``\n\t   - ``\"--\"`` or ``\"dashed\"``\n\t   - ``\"-.\"`` or ``\"dash dot\"``\n\t   - ``\":\"`` or ``\"dotted\"``\n\t   - ``\"None\"`` or ``\" \"`` or ``\"\"`` (nothing)\n\n\t   The linestyle can also be prefixed with a drawing style (e.g., ``\"steps--\"``)\n\n\t   - ``\"default\"`` (connect the points with straight lines)\n\t   - ``\"steps\"`` or ``\"steps-pre\"`` (step function; horizontal\n\t\t line is to the left of point)\n\t   - ``\"steps-mid\"`` (step function; points are in the middle of\n\t\t horizontal lines)\n\t   - ``\"steps-post\"`` (step function; horizontal line is to the\n\t\t right of point)\n\n\t- ``marker``  - The style of the markers, which is one of\n\t   - ``\"None\"`` or ``\" \"`` or ``\"\"`` (nothing) -- default\n\t   - ``\",\"`` (pixel), ``\".\"`` (point)\n\t   - ``\"_\"`` (horizontal line), ``\"|\"`` (vertical line)\n\t   - ``\"o\"`` (circle), ``\"p\"`` (pentagon), ``\"s\"`` (square), ``\"x\"`` (x), ``\"+\"`` (plus), ``\"*\"`` (star)\n\t   - ``\"D\"`` (diamond), ``\"d\"`` (thin diamond)\n\t   - ``\"H\"`` (hexagon), ``\"h\"`` (alternative hexagon)\n\t   - ``\"<\"`` (triangle left), ``\">\"`` (triangle right), ``\"^\"`` (triangle up), ``\"v\"`` (triangle down)\n\t   - ``\"1\"`` (tri down), ``\"2\"`` (tri up), ``\"3\"`` (tri left), ``\"4\"`` (tri right)\n\t   - ``0`` (tick left), ``1`` (tick right), ``2`` (tick up), ``3`` (tick down)\n\t   - ``4`` (caret left), ``5`` (caret right), ``6`` (caret up), ``7`` (caret down)\n\t   - ``\"$...$\"`` (math TeX string)\n\n\t- ``markersize`` -- the size of the marker in points\n\n\t- ``markeredgecolor`` -- the color of the marker edge\n\n\t- ``markerfacecolor`` -- the color of the marker face\n\n\t- ``markeredgewidth`` -- the size of the marker edge in points\n\n\tEXAMPLES:\n\n\tA line with no points or one point::\n\n\t\tsage: line([])\t  #returns an empty plot\n\t\tGraphics object consisting of 0 graphics primitives\n\t\tsage: import numpy; line(numpy.array([]))\n\t\tGraphics object consisting of 0 graphics primitives\n\t\tsage: line([(1,1)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA line with numpy arrays::\n\n\t\tsage: line(numpy.array([[1,2], [3,4]]))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA line with a legend::\n\n\t\tsage: line([(0,0),(1,1)], legend_label='line')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tLines with different colors in the legend text::\n\n\t\tsage: p1 = line([(0,0),(1,1)], legend_label='line')\n\t\tsage: p2 = line([(1,1),(2,4)], legend_label='squared', legend_color='red')\n\t\tsage: p1 + p2\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tExtra options will get passed on to show(), as long as they are valid::\n\n\t\tsage: line([(0,1), (3,4)], figsize=[10, 2])\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: line([(0,1), (3,4)]).show(figsize=[10, 2]) # These are equivalent\n\n\tWe can also use a logarithmic scale if the data will support it::\n\n\t\tsage: line([(1,2),(2,4),(3,4),(4,8),(4.5,32)],scale='loglog',base=2)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tMany more examples below!\n\n\tA blue conchoid of Nicomedes::\n\n\t\tsage: L = [[1+5*cos(pi/2+pi*i/100), tan(pi/2+pi*i/100)*(1+5*cos(pi/2+pi*i/100))] for i in range(1,100)]\n\t\tsage: line(L, rgbcolor=(1/4,1/8,3/4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA line with 2 complex points::\n\n\t\tsage: i = CC.0\n\t\tsage: line([1+i, 2+3*i])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA blue hypotrochoid (3 leaves)::\n\n\t\tsage: n = 4; h = 3; b = 2\n\t\tsage: L = [[n*cos(pi*i/100)+h*cos((n/b)*pi*i/100),n*sin(pi*i/100)-h*sin((n/b)*pi*i/100)] for i in range(200)]\n\t\tsage: line(L, rgbcolor=(1/4,1/4,3/4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA blue hypotrochoid (4 leaves)::\n\n\t\tsage: n = 6; h = 5; b = 2\n\t\tsage: L = [[n*cos(pi*i/100)+h*cos((n/b)*pi*i/100),n*sin(pi*i/100)-h*sin((n/b)*pi*i/100)] for i in range(200)]\n\t\tsage: line(L, rgbcolor=(1/4,1/4,3/4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA red limacon of Pascal::\n\n\t\tsage: L = [[sin(pi*i/100)+sin(pi*i/50),-(1+cos(pi*i/100)+cos(pi*i/50))] for i in range(-100,101)]\n\t\tsage: line(L, rgbcolor=(1,1/4,1/2))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA light green trisectrix of Maclaurin::\n\n\t\tsage: L = [[2*(1-4*cos(-pi/2+pi*i/100)^2),10*tan(-pi/2+pi*i/100)*(1-4*cos(-pi/2+pi*i/100)^2)] for i in range(1,100)]\n\t\tsage: line(L, rgbcolor=(1/4,1,1/8))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA green lemniscate of Bernoulli::\n\n\t\tsage: cosines = [cos(-pi/2+pi*i/100) for i in range(201)]\n\t\tsage: v = [(1/c, tan(-pi/2+pi*i/100)) for i,c in enumerate(cosines) if c != 0]\n\t\tsage: L = [(a/(a^2+b^2), b/(a^2+b^2)) for a,b in v]\n\t\tsage: line(L, rgbcolor=(1/4,3/4,1/8))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA red plot of the Jacobi elliptic function `\\text{sn}(x,2)`, `-3 < x < 3`::\n\n\t\tsage: L = [(i/100.0, real_part(jacobi('sn', i/100.0, 2.0))) for i in\n\t\t....:\t  range(-300, 300, 30)]\n\t\tsage: line(L, rgbcolor=(3/4, 1/4, 1/8))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA red plot of `J`-Bessel function `J_2(x)`, `0 < x < 10`::\n\n\t\tsage: L = [(i/10.0, bessel_J(2,i/10.0)) for i in range(100)]\n\t\tsage: line(L, rgbcolor=(3/4,1/4,5/8))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\n\tA purple plot of the Riemann zeta function `\\zeta(1/2 + it)`, `0 < t < 30`::\n\n\t\tsage: i = CDF.gen()\n\t\tsage: v = [zeta(0.5 + n/10 * i) for n in range(300)]\n\t\tsage: L = [(z.real(), z.imag()) for z in v]\n\t\tsage: line(L, rgbcolor=(3/4,1/2,5/8))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA purple plot of the Hasse-Weil `L`-function `L(E, 1 + it)`, `-1 < t < 10`::\n\n\t\tsage: E = EllipticCurve('37a')\n\t\tsage: vals = E.lseries().values_along_line(1-I, 1+10*I, 100) # critical line\n\t\tsage: L = [(z[1].real(), z[1].imag()) for z in vals]\n\t\tsage: line(L, rgbcolor=(3/4,1/2,5/8))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA red, blue, and green \"cool cat\"::\n\n\t\tsage: G = plot(-cos(x), -2, 2, thickness=5, rgbcolor=(0.5,1,0.5))\n\t\tsage: P = polygon([[1,2], [5,6], [5,0]], rgbcolor=(1,0,0))\n\t\tsage: Q = polygon([(-x,y) for x,y in P[0]], rgbcolor=(0,0,1))\n\t\tsage: G + P + Q   # show the plot\n\t\tGraphics object consisting of 3 graphics primitives\n\n\tTESTS:\n\n\tCheck that :trac:`13690` is fixed. The legend label should have circles\n\tas markers.::\n\n\t\tsage: line(enumerate(range(2)), marker='o', legend_label='circle')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\"\"\"\n\tfrom sage.plot.all import Graphics\n\tfrom sage.plot.plot import xydata_from_point_list\n\tfrom sage.rings.all import CC, CDF\n\tif points in CC or points in CDF:\n\t\tpass\n\telse:\n\t\ttry:\n\t\t\tif not points:\n\t\t\t\treturn Graphics()\n\t\texcept ValueError: # numpy raises a ValueError if not empty\n\t\t\tpass\n\txdata, ydata = xydata_from_point_list(points)\n\tg = Graphics()\n\tg._set_extra_kwds(Graphics._extract_kwds_for_show(options))\n\tg.add_primitive(Line(xdata, ydata, options))\n\tif options['legend_label']:\n\t\tg.legend(True)\n\t\tg._legend_colors = [options['legend_color']]\n\treturn g\n", "description": "\n\tCreate the line through the given list of points.\n\n\tINPUT:\n\n\t-  ``points`` - either a single point (as a tuple), a list of\n\t   points, a single complex number, or a list of complex numbers.\n\n\tType ``line2d.options`` for a dictionary of the default options for\n\tlines.  You can change this to change the defaults for all future\n\tlines.  Use ``line2d.reset()`` to reset to the default options.\n\n\tINPUT:\n\n\t- ``alpha`` -- How transparent the line is\n\n\t- ``thickness`` -- How thick the line is\n\n\t- ``rgbcolor`` -- The color as an RGB tuple\n\n\t- ``hue`` -- The color given as a hue\n\n\t- ``legend_color`` -- The color of the text in the legend\n\n\t- ``legend_label`` -- the label for this item in the legend\n\n\n\tAny MATPLOTLIB line option may also be passed in.  E.g.,\n\n\t- ``linestyle`` - (default: \"-\") The style of the line, which is one of\n\t   - ``\"-\"`` or ``\"solid\"``\n\t   - ``\"--\"`` or ``\"dashed\"``\n\t   - ``\"-.\"`` or ``\"dash dot\"``\n\t   - ``\":\"`` or ``\"dotted\"``\n\t   - ``\"None\"`` or ``\" \"`` or ``\"\"`` (nothing)\n\n\t   The linestyle can also be prefixed with a drawing style (e.g., ``\"steps--\"``)\n\n\t   - ``\"default\"`` (connect the points with straight lines)\n\t   - ``\"steps\"`` or ``\"steps-pre\"`` (step function; horizontal\n\t\t line is to the left of point)\n\t   - ``\"steps-mid\"`` (step function; points are in the middle of\n\t\t horizontal lines)\n\t   - ``\"steps-post\"`` (step function; horizontal line is to the\n\t\t right of point)\n\n\t- ``marker``  - The style of the markers, which is one of\n\t   - ``\"None\"`` or ``\" \"`` or ``\"\"`` (nothing) -- default\n\t   - ``\",\"`` (pixel), ``\".\"`` (point)\n\t   - ``\"_\"`` (horizontal line), ``\"|\"`` (vertical line)\n\t   - ``\"o\"`` (circle), ``\"p\"`` (pentagon), ``\"s\"`` (square), ``\"x\"`` (x), ``\"+\"`` (plus), ``\"*\"`` (star)\n\t   - ``\"D\"`` (diamond), ``\"d\"`` (thin diamond)\n\t   - ``\"H\"`` (hexagon), ``\"h\"`` (alternative hexagon)\n\t   - ``\"<\"`` (triangle left), ``\">\"`` (triangle right), ``\"^\"`` (triangle up), ``\"v\"`` (triangle down)\n\t   - ``\"1\"`` (tri down), ``\"2\"`` (tri up), ``\"3\"`` (tri left), ``\"4\"`` (tri right)\n\t   - ``0`` (tick left), ``1`` (tick right), ``2`` (tick up), ``3`` (tick down)\n\t   - ``4`` (caret left), ``5`` (caret right), ``6`` (caret up), ``7`` (caret down)\n\t   - ``\"$...$\"`` (math TeX string)\n\n\t- ``markersize`` -- the size of the marker in points\n\n\t- ``markeredgecolor`` -- the color of the marker edge\n\n\t- ``markerfacecolor`` -- the color of the marker face\n\n\t- ``markeredgewidth`` -- the size of the marker edge in points\n\n\tEXAMPLES:\n\n\tA line with no points or one point::\n\n\t\tsage: line([])\t  #returns an empty plot\n\t\tGraphics object consisting of 0 graphics primitives\n\t\tsage: import numpy; line(numpy.array([]))\n\t\tGraphics object consisting of 0 graphics primitives\n\t\tsage: line([(1,1)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA line with numpy arrays::\n\n\t\tsage: line(numpy.array([[1,2], [3,4]]))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA line with a legend::\n\n\t\tsage: line([(0,0),(1,1)], legend_label='line')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tLines with different colors in the legend text::\n\n\t\tsage: p1 = line([(0,0),(1,1)], legend_label='line')\n\t\tsage: p2 = line([(1,1),(2,4)], legend_label='squared', legend_color='red')\n\t\tsage: p1 + p2\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tExtra options will get passed on to show(), as long as they are valid::\n\n\t\tsage: line([(0,1), (3,4)], figsize=[10, 2])\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: line([(0,1), (3,4)]).show(figsize=[10, 2]) # These are equivalent\n\n\tWe can also use a logarithmic scale if the data will support it::\n\n\t\tsage: line([(1,2),(2,4),(3,4),(4,8),(4.5,32)],scale='loglog',base=2)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tMany more examples below!\n\n\tA blue conchoid of Nicomedes::\n\n\t\tsage: L = [[1+5*cos(pi/2+pi*i/100), tan(pi/2+pi*i/100)*(1+5*cos(pi/2+pi*i/100))] for i in range(1,100)]\n\t\tsage: line(L, rgbcolor=(1/4,1/8,3/4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA line with 2 complex points::\n\n\t\tsage: i = CC.0\n\t\tsage: line([1+i, 2+3*i])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA blue hypotrochoid (3 leaves)::\n\n\t\tsage: n = 4; h = 3; b = 2\n\t\tsage: L = [[n*cos(pi*i/100)+h*cos((n/b)*pi*i/100),n*sin(pi*i/100)-h*sin((n/b)*pi*i/100)] for i in range(200)]\n\t\tsage: line(L, rgbcolor=(1/4,1/4,3/4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA blue hypotrochoid (4 leaves)::\n\n\t\tsage: n = 6; h = 5; b = 2\n\t\tsage: L = [[n*cos(pi*i/100)+h*cos((n/b)*pi*i/100),n*sin(pi*i/100)-h*sin((n/b)*pi*i/100)] for i in range(200)]\n\t\tsage: line(L, rgbcolor=(1/4,1/4,3/4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA red limacon of Pascal::\n\n\t\tsage: L = [[sin(pi*i/100)+sin(pi*i/50),-(1+cos(pi*i/100)+cos(pi*i/50))] for i in range(-100,101)]\n\t\tsage: line(L, rgbcolor=(1,1/4,1/2))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA light green trisectrix of Maclaurin::\n\n\t\tsage: L = [[2*(1-4*cos(-pi/2+pi*i/100)^2),10*tan(-pi/2+pi*i/100)*(1-4*cos(-pi/2+pi*i/100)^2)] for i in range(1,100)]\n\t\tsage: line(L, rgbcolor=(1/4,1,1/8))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA green lemniscate of Bernoulli::\n\n\t\tsage: cosines = [cos(-pi/2+pi*i/100) for i in range(201)]\n\t\tsage: v = [(1/c, tan(-pi/2+pi*i/100)) for i,c in enumerate(cosines) if c != 0]\n\t\tsage: L = [(a/(a^2+b^2), b/(a^2+b^2)) for a,b in v]\n\t\tsage: line(L, rgbcolor=(1/4,3/4,1/8))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA red plot of the Jacobi elliptic function `\\text{sn}(x,2)`, `-3 < x < 3`::\n\n\t\tsage: L = [(i/100.0, real_part(jacobi('sn', i/100.0, 2.0))) for i in\n\t\t....:\t  range(-300, 300, 30)]\n\t\tsage: line(L, rgbcolor=(3/4, 1/4, 1/8))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA red plot of `J`-Bessel function `J_2(x)`, `0 < x < 10`::\n\n\t\tsage: L = [(i/10.0, bessel_J(2,i/10.0)) for i in range(100)]\n\t\tsage: line(L, rgbcolor=(3/4,1/4,5/8))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\n\tA purple plot of the Riemann zeta function `\\zeta(1/2 + it)`, `0 < t < 30`::\n\n\t\tsage: i = CDF.gen()\n\t\tsage: v = [zeta(0.5 + n/10 * i) for n in range(300)]\n\t\tsage: L = [(z.real(), z.imag()) for z in v]\n\t\tsage: line(L, rgbcolor=(3/4,1/2,5/8))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA purple plot of the Hasse-Weil `L`-function `L(E, 1 + it)`, `-1 < t < 10`::\n\n\t\tsage: E = EllipticCurve('37a')\n\t\tsage: vals = E.lseries().values_along_line(1-I, 1+10*I, 100) # critical line\n\t\tsage: L = [(z[1].real(), z[1].imag()) for z in vals]\n\t\tsage: line(L, rgbcolor=(3/4,1/2,5/8))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA red, blue, and green \"cool cat\"::\n\n\t\tsage: G = plot(-cos(x), -2, 2, thickness=5, rgbcolor=(0.5,1,0.5))\n\t\tsage: P = polygon([[1,2], [5,6], [5,0]], rgbcolor=(1,0,0))\n\t\tsage: Q = polygon([(-x,y) for x,y in P[0]], rgbcolor=(0,0,1))\n\t\tsage: G + P + Q   # show the plot\n\t\tGraphics object consisting of 3 graphics primitives\n\n\tTESTS:\n\n\tCheck that :trac:`13690` is fixed. The legend label should have circles\n\tas markers.::\n\n\t\tsage: line(enumerate(range(2)), marker='o', legend_label='circle')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t", "category": "graphics", "imports": ["from sage.plot.primitive import GraphicPrimitive_xydata", "from sage.misc.decorators import options, rename_keyword", "from sage.plot.colors import to_mpl_color", "\t\tsage: from sage.plot.line import Line", "\t\t\tsage: from sage.plot.line import Line", "\t\t\tsage: from sage.plot.line import Line", "\t\tfrom sage.plot.plot3d.shapes2 import line3d", "\t\t\tsage: from sage.plot.line import Line", "\t\timport matplotlib.lines as lines", "\t\t\tfrom sage.plot.misc import get_matplotlib_linestyle", "\t\tfrom sage.plot.plot3d.shapes2 import line3d", "\t\tsage: import numpy; line(numpy.array([]))", "\tfrom sage.plot.all import Graphics", "\tfrom sage.plot.plot import xydata_from_point_list", "\tfrom sage.rings.all import CC, CDF"]}], [{"term": "def", "name": "pattern", "data": "def pattern(n):\r\n\tk = n - 1\r\n\tfor i in range(0,n):\r\n\t\t\r\n", "description": null, "category": "graphics", "imports": []}], [{"term": "class", "name": "classL12:", "data": "class L12:\n\tdef __init__(self):\n\t\tself.ok = True\n\t\tself.state = 0 \n\t\tself.background = setup.GRAPHICS['black']\n\t\tself.b1 = setup.GRAPHICS['12.1']\n\t\tself.b2 = setup.GRAPHICS['12.2']\n\t\tself.b3 = setup.GRAPHICS['12.3']\n\t\tself.b4 = setup.GRAPHICS['12.4']\n\t\tself.b5 = setup.GRAPHICS['12.5']\n\t\tself.b6 = setup.GRAPHICS['12.6']\n\t\tself.b7 = setup.GRAPHICS['12.7']\n\t\tself.b8 = setup.GRAPHICS['12.8']\n\t\tself.b9 = setup.GRAPHICS['12.9']\n\t\tself.b10 = setup.GRAPHICS['12.10']\n\t\tself.b11 = setup.GRAPHICS['12.11']\n\t\tself.b12 = setup.GRAPHICS['12.12']\n\t\tself.b13 = setup.GRAPHICS['12.13']\n\t\tself.b14 = setup.GRAPHICS['12.14']\n\t\tself.b15 = setup.GRAPHICS['12.15']\n\t\tself.b16 = setup.GRAPHICS['12.16']\n\t\tself.b17 = setup.GRAPHICS['12.17']\n\t\tself.b18 = setup.GRAPHICS['12.18']\n\t\tself.b19 = setup.GRAPHICS['12.19']\n\t\tself.b20 = setup.GRAPHICS['12.20']\n\t\tself.b21 = setup.GRAPHICS['12.21']\n\t\tself.b22 = setup.GRAPHICS['12.22']\n\t\tself.b23 = setup.GRAPHICS['12.23']\n\t\tself.b24 = setup.GRAPHICS['12.24']\n\t\tself.b25 = setup.GRAPHICS['12.25']\n\t\tself.b26 = setup.GRAPHICS['12.26']\n\t\tself.b27 = setup.GRAPHICS['12.27']\n\t\tself.b28 = setup.GRAPHICS['12.28']\n\t\tself.b29 = setup.GRAPHICS['12.29']\n\t\tself.b30 = setup.GRAPHICS['12.30']\n\t\tself.b31 = setup.GRAPHICS['12.31']\n\t\tself.b32 = setup.GRAPHICS['12.32']\n\t\tself.b33 = setup.GRAPHICS['12.33']\n\t\tself.b34 = setup.GRAPHICS['12.34']\n\n\t\tself.a1 = setup.GRAPHICS['13.1']\n\t\tself.a2 = setup.GRAPHICS['13.2']\n\t\tself.a3 = setup.GRAPHICS['13.3']\n\t\tself.a4 = setup.GRAPHICS['13.4']\n\t\tself.a5 = setup.GRAPHICS['13.5']\n\t\tself.a6 = setup.GRAPHICS['13.6']\n\t\tself.a7 = setup.GRAPHICS['13.7']\n\t\tself.a8 = setup.GRAPHICS['13.8']\n\t\tself.a9 = setup.GRAPHICS['13.9']\n\t\tself.a10 = setup.GRAPHICS['13.10']\n\t\tself.a11 = setup.GRAPHICS['13.11']\n\t\tself.a12 = setup.GRAPHICS['13.12']\n\n\t\tself.c1 = setup.GRAPHICS['14.1']\n\t\tself.c2 = setup.GRAPHICS['14.2']\n\t\tself.c3 = setup.GRAPHICS['14.3']\n\t\tself.c4 = setup.GRAPHICS['14.4']\n\t\tself.c5 = setup.GRAPHICS['14.5']\n\t\tself.c6 = setup.GRAPHICS['14.6']\n\t\tself.c7 = setup.GRAPHICS['14.7']\n\t\tself.c8 = setup.GRAPHICS['14.8']\n\n\t\tself.timer = 0\n\t\tself.ok = True\n\t\tself.choice = 0\n\tdef update(self, surface, keys, dir):\n\t #   print(self.state)\n\t\tif self.state == 0:\n\t\t\tsurface.blit(self.background, surface.get_rect())\n\t\tif 'down' in dir and self.ok:\n\t\t\tprint(dir['x'], dir['y'])\n\n\t\t\tif 220 > dir['x'] > 160 and 600 > dir['y'] > 530 and self.state >= 27:\n\t\t\t\tself.choice = 1\n\t\t\t\tself.timer = pygame.time.get_ticks()\n\t\t\tif 360 > dir['x'] > 300 and 600 > dir['y'] > 530 and self.state >= 27:\n\t\t\t\tself.choice = 2\n\t\t\t\tself.timer = pygame.time.get_ticks()\n\t\t\tif not(40 < dir['x'] < 260 and 480 > dir['y'] > 330) and self.state == 3:\n\t\t\t\treturn\n\t\t\tif not(480 > dir['x'] > 240 and 500 > dir['y'] > 220) and self.state == 8:\n\t\t\t\treturn\n\t\t\tif self.choice != 0:\n\t\t\t\tprint(self.choice)\n\t\t\tself.state += 1\n\t\tif self.state == 1:\n\t\t\tsurface.blit(self.b1, surface.get_rect())\n\t\telif self.state == 2:\n\t\t\tsurface.blit(self.b2, surface.get_rect())\n\t\telif self.state == 3:\n\t\t\tsurface.blit(self.b3, surface.get_rect())\n\t\telif self.state == 4:\n\t\t\tsurface.blit(self.b32, surface.get_rect())\n\t\telif self.state == 5:\n\t\t\tsurface.blit(self.b33, surface.get_rect())\n\t\telif self.state == 6:\n\t\t\tself.timer = pygame.time.get_ticks()\n\t\t\tsurface.blit(self.b34, surface.get_rect())\n\t\telif pygame.time.get_ticks() - self.timer < 2000 and self.timer and self.state == 7:\n\t\t\tself.ok = False\n\t\t\tsurface.blit(self.b4, surface.get_rect())\n\t\telif 2000 < pygame.time.get_ticks() - self.timer < 4000 and self.timer and self.state == 4:\n\t\t\tsurface.blit(self.b5, surface.get_rect())\n\t\telif 4000 < pygame.time.get_ticks() - self.timer < 6000 and self.timer and self.state == 4:\n\t\t\tsurface.blit(self.b6, surface.get_rect())\n\t\telif self.state == 7:\n\t\t\tsurface.blit(self.b7, surface.get_rect())\n\t\t\tself.ok = True\n\t\telif self.state == 8:\n\t\t\tself.timer = pygame.time.get_ticks()\n\t\t\tsurface.blit(self.b8, surface.get_rect())\n\t\telif pygame.time.get_ticks() - self.timer < 2000 and self.state == 9:\n\t\t\tself.ok = False\n\t\t\tsurface.blit(self.b9, surface.get_rect())\n\t\telif 2000 < pygame.time.get_ticks() - self.timer < 4000 and self.state == 9:\n\t\t\tsurface.blit(self.b10, surface.get_rect())\n\t\telif 4000 < pygame.time.get_ticks() - self.timer < 6000 and self.state == 9:\n\t\t\tsurface.blit(self.b11, surface.get_rect())\n\t\telif 6000 < pygame.time.get_ticks() - self.timer < 8000 and self.state == 9:\n\t\t\tsurface.blit(self.b12, surface.get_rect())\n\t\telif self.state == 9:\n\t\t\tsurface.blit(self.b13, surface.get_rect())\n\t\t\tself.ok = True\n\t\telif self.state == 10:\n\t\t\tsurface.blit(self.b14, surface.get_rect())\n\t\telif self.state == 11:\n\t\t\tsurface.blit(self.b15, surface.get_rect())\n\t\telif self.state == 12:\n\t\t\tsurface.blit(self.b16, surface.get_rect())\n\t\telif self.state == 13:\n\t\t\tsurface.blit(self.b17, surface.get_rect())\n\t\telif self.state == 14:\n\t\t\tsurface.blit(self.b18, surface.get_rect())\n\t\telif self.state == 15:\n\t\t\tsurface.blit(self.b19, surface.get_rect())\n\t\telif self.state == 16:\n\t\t\tsurface.blit(self.b20, surface.get_rect())\n\t\telif self.state == 17:\n\t\t\tsurface.blit(self.b21, surface.get_rect())\n\t\telif self.state == 18:\n\t\t\tsurface.blit(self.b22, surface.get_rect())\n\t\telif self.state == 19:\n\t\t\tsurface.blit(self.b23, surface.get_rect())\n\t\telif self.state == 20:\n\t\t\tsurface.blit(self.b24, surface.get_rect())\n\t\telif self.state == 21:\n\t\t\tsurface.blit(self.b25, surface.get_rect())\n\t\telif self.state == 22:\n\t\t\tsurface.blit(self.b26, surface.get_rect())\n\t\telif self.state == 23:\n\t\t\tsurface.blit(self.b27, surface.get_rect())\n\t\telif self.state == 24:\n\t\t\tsurface.blit(self.b28, surface.get_rect())\n\t\telif self.state == 25:\n\t\t\tsurface.blit(self.b29, surface.get_rect())\n\t\telif self.state == 26:\n\t\t\tsurface.blit(self.b30, surface.get_rect())\n\t\telif self.state == 27:\n\t\t\tsurface.blit(self.b31, surface.get_rect())\n\t\t# \u597d\n\t\tif self.state >= 27 and self.choice == 2:\n\t\t\tif pygame.time.get_ticks() - self.timer < 2000:\n\t\t\t\tsurface.blit(self.a1, surface.get_rect())\n\t\t\telif 2000 < pygame.time.get_ticks() - self.timer < 4000:\n\t\t\t\tsurface.blit(self.a2, surface.get_rect())\n\t\t\telif 4000 < pygame.time.get_ticks() - self.timer < 6000:\n\t\t\t\tsurface.blit(self.a3, surface.get_rect())\n\t\t\telif 6000 < pygame.time.get_ticks() - self.timer < 8000:\n\t\t\t\tsurface.blit(self.a4, surface.get_rect())\n\t\t\telif 8000 < pygame.time.get_ticks() - self.timer < 10000:\n\t\t\t\tsurface.blit(self.a5, surface.get_rect())\n\t\t\telif 10000 < pygame.time.get_ticks() - self.timer < 12000:\n\t\t\t\tsurface.blit(self.a6, surface.get_rect())\n\t\t\telif 12000 < pygame.time.get_ticks() - self.timer < 14000:\n\t\t\t\tsurface.blit(self.a7, surface.get_rect())\n\t\t\telif 14000 < pygame.time.get_ticks() - self.timer < 16000:\n\t\t\t\tsurface.blit(self.a8, surface.get_rect())\n\t\t\telif 16000 < pygame.time.get_ticks() - self.timer < 18000:\n\t\t\t\tsurface.blit(self.a9, surface.get_rect())\n\t\t\telif 18000 < pygame.time.get_ticks() - self.timer < 20000:\n\t\t\t\tsurface.blit(self.a10, surface.get_rect())\n\t\t\telif 20000 < pygame.time.get_ticks() - self.timer < 22000:\n\t\t\t\tsurface.blit(self.a11, surface.get_rect())\n\t\t\telif 22000 < pygame.time.get_ticks() - self.timer < 24000:\n\t\t\t\tsurface.blit(self.a12, surface.get_rect())\n\t\t# \u574f\n\t\tif self.state >= 27 and self.choice == 1:\n\t\t\tif pygame.time.get_ticks() - self.timer < 2000:\n\t\t\t\tsurface.blit(self.c1, surface.get_rect())\n\t\t\telif 2000 < pygame.time.get_ticks() - self.timer < 4000:\n\t\t\t\tsurface.blit(self.c2, surface.get_rect())\n\t\t\telif 4000 < pygame.time.get_ticks() - self.timer < 6000:\n\t\t\t\tsurface.blit(self.c3, surface.get_rect())\n\t\t\telif 6000 < pygame.time.get_ticks() - self.timer < 8000:\n\t\t\t\tsurface.blit(self.c4, surface.get_rect())\n\t\t\telif 8000 < pygame.time.get_ticks() - self.timer < 10000:\n\t\t\t\tsurface.blit(self.c5, surface.get_rect())\n\t\t\telif 10000 < pygame.time.get_ticks() - self.timer < 12000:\n\t\t\t\tsurface.blit(self.c6, surface.get_rect())\n\t\t\telif 12000 < pygame.time.get_ticks() - self.timer < 14000:\n\t\t\t\tsurface.blit(self.c7, surface.get_rect())\n\t\t\telif 14000 < pygame.time.get_ticks() - self.timer < 16000:\n\t\t\t\tsurface.blit(self.c8, surface.get_rect())\n\t\t\t\n\t\t\t\n", "description": null, "category": "graphics", "imports": ["from .import setup", "import pygame, time"]}], [], [{"term": "class", "name": "IconExporter", "data": "class IconExporter(object):\r\n\tdef __init__(self, omc_session, icon_dir_name):\r\n\t\t\"\"\"\r\n\t\tCreates a new instance of IconExporter and passes in an OMCSession\r\n\t\t\"\"\"\r\n\r\n\t\tself.logger = logging.getLogger('py_modelica_exporter.IconExporter')\r\n\t\tself.logger.setLevel(logging.NOTSET)\r\n\r\n\t\tself.logger.info('Initializing IconExporter()')\r\n\r\n\t\t# start om session\r\n\t\tself.omc = omc_session\r\n\r\n\t\tself.icon_dir_name = icon_dir_name\r\n\r\n\t# get graphics objects from annotation Icon\r\n\tdef get_graphics_for_class(self, modelica_class):\r\n\r\n\t\t# TODO: does not work if a port (same class) is being used multiple times...\r\n\t\t# if modelicaClass in graphics_cache:\r\n\t\t#\t return graphics_cache[modelicaClass]\r\n\r\n\t\tresult = dict()\r\n\t\tresult['graphics'] = []\r\n\r\n\t\t# answer2 = ask_omc('getIconAnnotation', modelicaClass, parsed=False)\r\n\t\ticon_annotation = self.omc.getIconAnnotation(modelica_class)\r\n\r\n\t\tresult['coordinateSystem'] = {}\r\n\t\tresult['coordinateSystem']['extent'] = [[-100, -100], [100, 100]]\r\n\r\n\t\tr = regex_coordSys.search(icon_annotation)\r\n\r\n\t\tif r:\r\n\t\t\tg = r.groups()\r\n\t\t\tresult['coordinateSystem']['extent'] = [[float(g[0]), float(g[1])], [float(g[2]), float(g[3])]]\r\n\t\t\tresult['coordinateSystem']['preserveAspectRatio'] = bool(g[4])\r\n\t\t\tresult['coordinateSystem']['initialScale'] = float(g[5])\r\n\t\t\tresult['coordinateSystem']['grid'] = [float(g[6]), float(g[7])]\r\n\r\n\t\t\twithout_coord_sys = icon_annotation[icon_annotation.find(',{'):]\r\n\t\telse:\r\n\t\t\t# logger.warning('Coordinate system was skipped')\r\n\t\t\t# logger.warning(answer2)\r\n\t\t\twithout_coord_sys = icon_annotation\r\n\r\n\t\tfor icon_line in without_coord_sys.split('),'):\r\n\r\n\t\t\t# default values\r\n\t\t\tgraphics_obj = {}\r\n\r\n\t\t\tr = regex_line.search(icon_line)\r\n\t\t\tif r:\r\n\t\t\t\tgraphics_obj['type'] = 'Line'\r\n\t\t\t\tg = r.groups()\r\n\t\t\t\tgraphics_obj['visible'] = g[0]\r\n\t\t\t\tgraphics_obj['origin'] = [float(g[1]), float(g[2])]\r\n\t\t\t\tgraphics_obj['rotation'] = float(g[3])\r\n\r\n\t\t\t\tpoints = []\r\n\t\t\t\tgg = re.findall(regex_points, g[4])\r\n\t\t\t\tfor i in range(0, len(gg)):\r\n\t\t\t\t\tpoints.append([float(gg[i][0]), float(gg[i][1])])\r\n\t\t\t\tgraphics_obj['points'] = points\r\n\r\n\t\t\t\tgraphics_obj['color'] = [int(g[5]), int(g[6]), int(g[7])]\r\n\t\t\t\tgraphics_obj['pattern'] = g[8]\r\n\t\t\t\tgraphics_obj['thickness'] = float(g[9])\r\n\t\t\t\tgraphics_obj['arrow'] = [g[10], g[11]]\r\n\t\t\t\tgraphics_obj['arrowSize'] = float(g[12])\r\n\t\t\t\tgraphics_obj['smooth'] = g[13]\r\n\r\n\t\t\tr = regex_rectangle.search(icon_line)\r\n\t\t\tif r:\r\n\t\t\t\tgraphics_obj['type'] = 'Rectangle'\r\n\t\t\t\tg = r.groups()\r\n\t\t\t\tgraphics_obj['visible'] = g[0]\r\n\t\t\t\tgraphics_obj['origin'] = [float(g[1]), float(g[2])]\r\n\t\t\t\tgraphics_obj['rotation'] = float(g[3])\r\n\t\t\t\tgraphics_obj['lineColor'] = [int(g[4]), int(g[5]), int(g[6])]\r\n\t\t\t\tgraphics_obj['fillColor'] = [int(g[7]), int(g[8]), int(g[9])]\r\n\t\t\t\tgraphics_obj['linePattern'] = g[10]\r\n\t\t\t\tgraphics_obj['fillPattern'] = g[11]\r\n\t\t\t\tgraphics_obj['lineThickness'] = float(g[12])\r\n\t\t\t\tgraphics_obj['borderPattern'] = g[13]\r\n\t\t\t\tgraphics_obj['extent'] = [[float(g[14]), float(g[15])], [float(g[16]), float(g[17])]]\r\n\t\t\t\tgraphics_obj['radius'] = float(g[18])\r\n\r\n\t\t\tr = regex_polygon.search(icon_line)\r\n\t\t\tif r:\r\n\t\t\t\tgraphics_obj['icon_line'] = icon_line\r\n\t\t\t\tgraphics_obj['type'] = 'Polygon'\r\n\t\t\t\tg = r.groups()\r\n\t\t\t\tgraphics_obj['visible'] = g[0]\r\n\t\t\t\tgraphics_obj['origin'] = [float(g[1]), float(g[2])]\r\n\t\t\t\tgraphics_obj['rotation'] = float(g[3])\r\n\t\t\t\tgraphics_obj['lineColor'] = [int(g[4]), int(g[5]), int(g[6])]\r\n\t\t\t\tgraphics_obj['fillColor'] = [int(g[7]), int(g[8]), int(g[9])]\r\n\t\t\t\tgraphics_obj['linePattern'] = g[10]\r\n\t\t\t\tgraphics_obj['fillPattern'] = g[11]\r\n\t\t\t\tgraphics_obj['lineThickness'] = float(g[12])\r\n\r\n\t\t\t\tpoints = []\r\n\t\t\t\tgg = re.findall(regex_points, g[13])\r\n\t\t\t\tfor i in range(0, len(gg)):\r\n\t\t\t\t\tpoints.append([float(gg[i][0]), float(gg[i][1])])\r\n\t\t\t\tgraphics_obj['points'] = points\r\n\r\n\t\t\t\tmin_x = 100\r\n\t\t\t\tmin_y = 100\r\n\t\t\t\tmax_x = -100\r\n\t\t\t\tmax_y = -100\r\n\r\n\t\t\t\tfor point in graphics_obj['points']:\r\n\t\t\t\t\tif min_x > point[0]:\r\n\t\t\t\t\t\tmin_x = point[0]\r\n\t\t\t\t\tif max_x < point[0]:\r\n\t\t\t\t\t\tmax_x = point[0]\r\n\t\t\t\t\tif min_y > point[1]:\r\n\t\t\t\t\t\tmin_y = point[1]\r\n\t\t\t\t\tif max_y < point[1]:\r\n\t\t\t\t\t\tmax_y = point[1]\r\n\r\n\t\t\t\tgraphics_obj['extent'] = [[min_x, min_y], [max_x, max_y]]\r\n\r\n\t\t\t\tgraphics_obj['smooth'] = g[14]\r\n\r\n\t\t\tr = regex_text.search(icon_line)\r\n\t\t\tif r:\r\n\t\t\t\tgraphics_obj['type'] = 'Text'\r\n\t\t\t\tg = r.groups()\r\n\t\t\t\tgraphics_obj['visible'] = g[0]\r\n\t\t\t\tgraphics_obj['origin'] = [float(g[1]), float(g[2])]\r\n\t\t\t\tgraphics_obj['rotation'] = float(g[3])\r\n\t\t\t\tgraphics_obj['lineColor'] = [int(g[4]), int(g[5]), int(g[6])]\r\n\t\t\t\tgraphics_obj['fillColor'] = [int(g[7]), int(g[8]), int(g[9])]\r\n\t\t\t\tgraphics_obj['linePattern'] = g[10]\r\n\t\t\t\tgraphics_obj['fillPattern'] = g[11]\r\n\t\t\t\tgraphics_obj['lineThickness'] = float(g[12])\r\n\t\t\t\tgraphics_obj['extent'] = [[float(g[13]), float(g[14])], [float(g[15]), float(g[16])]]\r\n\t\t\t\tgraphics_obj['textString'] = g[17].strip('\"')\r\n\t\t\t\tgraphics_obj['fontSize'] = float(g[18])\r\n\t\t\t\tgraphics_obj['fontName'] = g[19]\r\n\t\t\t\tif graphics_obj['fontName']:\r\n\t\t\t\t\tgraphics_obj['fontName'] = graphics_obj['fontName'].strip('\"')\r\n\r\n\t\t\t\tgraphics_obj['textStyle'] = []\r\n\t\t\t\tif g[20]:\r\n\t\t\t\t\t# text Style can have different number of styles\r\n\t\t\t\t\tgraphics_obj['textStyle'] = regex_type_value.findall(g[20])\r\n\r\n\t\t\t\tgraphics_obj['horizontalAlignment'] = g[21]\r\n\r\n\t\t\tr = regex_ellipse.search(icon_line)\r\n\t\t\tif r:\r\n\t\t\t\tg = r.groups()\r\n\t\t\t\tgraphics_obj['type'] = 'Ellipse'\r\n\t\t\t\tgraphics_obj['visible'] = g[0]\r\n\t\t\t\tgraphics_obj['origin'] = [float(g[1]), float(g[2])]\r\n\t\t\t\tgraphics_obj['rotation'] = float(g[3])\r\n\t\t\t\tgraphics_obj['lineColor'] = [int(g[4]), int(g[5]), int(g[6])]\r\n\t\t\t\tgraphics_obj['fillColor'] = [int(g[7]), int(g[8]), int(g[9])]\r\n\t\t\t\tgraphics_obj['linePattern'] = g[10]\r\n\t\t\t\tgraphics_obj['fillPattern'] = g[11]\r\n\t\t\t\tgraphics_obj['lineThickness'] = float(g[12])\r\n\t\t\t\tgraphics_obj['extent'] = [[float(g[13]), float(g[14])], [float(g[15]), float(g[16])]]\r\n\t\t\t\tgraphics_obj['startAngle'] = float(g[17])\r\n\t\t\t\tgraphics_obj['endAngle'] = float(g[18])\r\n\r\n\t\t\tif not 'type' in graphics_obj:\r\n\t\t\t\tgraphics_obj['type'] = 'Unknown'\r\n\t\t\t\t# logger.error('Unknown graphicsObj: {0}'.format(icon_line))\r\n\r\n\t\t\tresult['graphics'].append(graphics_obj)\r\n\r\n\t\tgraphics_cache[modelica_class] = result\r\n\r\n\t\treturn result\r\n\r\n\tdef get_graphics_with_ports_for_class(self, modelica_class):\r\n\t\tgraphics = self.get_graphics_for_class(modelica_class)\r\n\t\tgraphics['className'] = modelica_class\r\n\t\tgraphics['ports'] = []\r\n\t\t# answer_full = ask_omc('getComponents', modelicaClass, parsed=False)\r\n\t\tanswer_full = self.omc.getComponents(modelica_class, parsed=False)\r\n\r\n\t\tcomp_id = 0\r\n\t\tfor answer in answer_full[2:].split('},{'):\r\n\t\t\t#print answer\r\n\t\t\tcomp_id += 1\r\n\t\t\tclass_name = answer[0:answer.find(',')]\r\n\t\t\tcomponent_name = answer[answer.find(',') + 1:][0:answer[answer.find(',') + 1:].find(',')]\r\n\r\n\t\t\t# if ask_omc('isConnector', class_name):\r\n\t\t\tif self.omc.isConnector(class_name):\r\n\t\t\t\ttry:\r\n\t\t\t\t\tcomp_annotation = self.omc.getNthComponentAnnotation(modelica_class, comp_id)\r\n\t\t\t\t\t# comp_annotation = ask_omc(\r\n\t\t\t\t\t#\t 'getNthComponentAnnotation', modelicaClass + ', ' + str(comp_id))['SET2']['Set1']\r\n\t\t\t\texcept KeyError as ex:\r\n\t\t\t\t\tself.logger.error(\r\n\t\t\t\t\t\t'KeyError: {0} componentName: {1} {2}'.format(modelica_class, component_name, ex.message))\r\n\t\t\t\t\tcontinue\r\n\r\n\t\t\t\t# base class graphics for ports\r\n\t\t\t\tg_base = []\r\n\t\t\t\tbase_classes = []\r\n\t\t\t\tself.get_base_classes(class_name, base_classes)\r\n\r\n\t\t\t\tfor base_class in base_classes:\r\n\t\t\t\t\tgraphics_base = self.get_graphics_for_class(base_class)\r\n\t\t\t\t\tg_base.append(graphics_base)\r\n\r\n\t\t\t\tg = self.get_graphics_for_class(class_name)\r\n\r\n\t\t\t\tg_this = g['graphics']\r\n\r\n\t\t\t\tg['graphics'] = []\r\n\t\t\t\tfor g_b in g_base:\r\n\t\t\t\t\tfor g_i in g_b['graphics']:\r\n\t\t\t\t\t\tg['graphics'].append(g_i)\r\n\t\t\t\tfor g_b in g_this:\r\n\t\t\t\t\tg['graphics'].append(g_b)\r\n\r\n\t\t\t\tg['id'] = component_name\r\n\t\t\t\tg['className'] = class_name\r\n\r\n\t\t\t\tdesc = self.omc.getComponentComment(modelica_class + ', ' + component_name)\r\n\t\t\t\t# desc = ask_omc('getComponentComment', modelicaClass + ', ' + component_name)\r\n\r\n\t\t\t\tif type(desc) is dict:\r\n\t\t\t\t\tg['desc'] = ''\r\n\t\t\t\telse:\r\n\t\t\t\t\tg['desc'] = desc.strip().strip('\"')\r\n\r\n\t\t\t\tg['classDesc'] = self.omc.getClassComment(class_name).strip().strip('\"')\r\n\t\t\t\t# g['classDesc'] = ask_omc('getClassComment', class_name).strip().strip('\"')\r\n\r\n\t\t\t\tmin_x = g['coordinateSystem']['extent'][0][0]\r\n\t\t\t\tmin_y = g['coordinateSystem']['extent'][0][1]\r\n\t\t\t\tmax_x = g['coordinateSystem']['extent'][1][0]\r\n\t\t\t\tmax_y = g['coordinateSystem']['extent'][1][1]\r\n\r\n\t\t\t\tfor gs in g['graphics']:\r\n\t\t\t\t\t# use default values if it is not there\r\n\t\t\t\t\tif not 'extent' in gs:\r\n\t\t\t\t\t\tgs['extent'] = [[-100, -100], [100, 100]]\r\n\r\n\t\t\t\t\tif not 'origin' in gs:\r\n\t\t\t\t\t\tgs['origin'] = [0, 0]\r\n\r\n\t\t\t\t\tif min_x > gs['extent'][0][0] + gs['origin'][0]:\r\n\t\t\t\t\t\tmin_x = gs['extent'][0][0] + gs['origin'][0]\r\n\t\t\t\t\tif min_x > gs['extent'][1][0] + gs['origin'][0]:\r\n\t\t\t\t\t\tmin_x = gs['extent'][1][0] + gs['origin'][0]\r\n\t\t\t\t\tif min_y > gs['extent'][0][1] + gs['origin'][1]:\r\n\t\t\t\t\t\tmin_y = gs['extent'][0][1] + gs['origin'][1]\r\n\t\t\t\t\tif min_y > gs['extent'][1][1] + gs['origin'][1]:\r\n\t\t\t\t\t\tmin_y = gs['extent'][1][1] + gs['origin'][1]\r\n\t\t\t\t\tif max_x < gs['extent'][1][0] + gs['origin'][0]:\r\n\t\t\t\t\t\tmax_x = gs['extent'][1][0] + gs['origin'][0]\r\n\t\t\t\t\tif max_x < gs['extent'][0][0] + gs['origin'][0]:\r\n\t\t\t\t\t\tmax_x = gs['extent'][0][0] + gs['origin'][0]\r\n\t\t\t\t\tif max_y < gs['extent'][1][1] + gs['origin'][1]:\r\n\t\t\t\t\t\tmax_y = gs['extent'][1][1] + gs['origin'][1]\r\n\t\t\t\t\tif max_y < gs['extent'][0][1] + gs['origin'][1]:\r\n\t\t\t\t\t\tmax_y = gs['extent'][0][1] + gs['origin'][1]\r\n\r\n\t\t\t\tg['coordinateSystem']['extent'] = [[min_x, min_y], [max_x, max_y]]\r\n\r\n\t\t\t\t#print comp_annotation\r\n\t\t\t\tindex_delta = 7\r\n\t\t\t\tif comp_annotation[10] == \"-\":\r\n\t\t\t\t\t# fallback to diagram annotations\r\n\t\t\t\t\tindex_delta = 0\r\n\r\n\t\t\t\torigin_x = comp_annotation[1 + index_delta]\r\n\t\t\t\torigin_y = comp_annotation[2 + index_delta]\r\n\t\t\t\tx0 = comp_annotation[3 + index_delta]\r\n\t\t\t\ty0 = comp_annotation[4 + index_delta]\r\n\t\t\t\tx1 = comp_annotation[5 + index_delta]\r\n\t\t\t\ty1 = comp_annotation[6 + index_delta]\r\n\r\n\t\t\t\trotation = comp_annotation[7 + index_delta]\r\n\r\n\t\t\t\tg['transformation'] = {}\r\n\t\t\t\tg['transformation']['origin'] = [origin_x, origin_y]\r\n\t\t\t\tg['transformation']['extent'] = [[x0, y0], [x1, y1]]\r\n\t\t\t\tg['transformation']['rotation'] = rotation\r\n\r\n\t\t\t\tgraphics['ports'].append(g)\r\n\r\n\t\treturn graphics\r\n\r\n\tdef get_gradient_colors(self, start_color, stop_color, mid_points):\r\n\t\tresult = []\r\n\r\n\t\tstart_red = int(start_color[0])\r\n\t\tstart_green = int(start_color[1])\r\n\t\tstart_blue = int(start_color[2])\r\n\r\n\t\tstop_red = int(stop_color[0])\r\n\t\tstop_green = int(stop_color[1])\r\n\t\tstop_blue = int(stop_color[2])\r\n\r\n\t\tr_delta = (stop_red - start_red) / (mid_points + 1)\r\n\t\tg_delta = (stop_green - start_green) / (mid_points + 1)\r\n\t\tb_delta = (stop_blue - start_blue) / (mid_points + 1)\r\n\r\n\t\tresult.append((start_red, start_green, start_blue))\r\n\r\n\t\tfor i in range(1, mid_points + 1):\r\n\t\t\tresult.append((start_red + i * r_delta, start_green + i * g_delta, start_blue + i * b_delta))\r\n\r\n\t\tresult.append((stop_red, stop_green, stop_blue))\r\n\r\n\t\treturn result\r\n\r\n\tdef get_coordinates(self, xy, graphics, min_x, max_y, transformation, coordinate_system):\r\n\r\n\t\tx = xy[0] + graphics['origin'][0]\r\n\t\ty = xy[1] + graphics['origin'][1]\r\n\r\n\t\t# rotation for the icon\r\n\t\ts = math.sin(graphics['rotation'] / 180 * 3.1415)\r\n\t\tc = math.cos(graphics['rotation'] / 180 * 3.1415)\r\n\r\n\t\tx -= graphics['origin'][0]\r\n\t\ty -= graphics['origin'][1]\r\n\r\n\t\txnew = x * c - y * s\r\n\t\tynew = x * s + y * c\r\n\r\n\t\tx = xnew + graphics['origin'][0]\r\n\t\ty = ynew + graphics['origin'][1]\r\n\r\n\t\tif transformation and coordinate_system:\r\n\t\t\ttry:\r\n\t\t\t\tt_width = abs(max(transformation['extent'][1][0], transformation['extent'][0][0]) - min(\r\n\t\t\t\t\ttransformation['extent'][1][0], transformation['extent'][0][0]))\r\n\t\t\t\tt_height = abs(max(transformation['extent'][1][1], transformation['extent'][0][1]) - min(\r\n\t\t\t\t\ttransformation['extent'][1][1], transformation['extent'][0][1]))\r\n\t\t\t\to_width = abs(max(coordinate_system['extent'][1][0], coordinate_system['extent'][0][0]) - min(\r\n\t\t\t\t\tcoordinate_system['extent'][1][1], coordinate_system['extent'][0][1]))\r\n\t\t\t\to_height = abs(max(coordinate_system['extent'][1][1], coordinate_system['extent'][0][1]) - min(\r\n\t\t\t\t\tcoordinate_system['extent'][1][1], coordinate_system['extent'][0][1]))\r\n\r\n\t\t\t\tif 'extent' in transformation and transformation['extent'][1][0] < transformation['extent'][0][0]:\r\n\t\t\t\t\t# horizontal flip\r\n\t\t\t\t\tx = (-xy[0] + graphics['origin'][0]) / o_width * t_width + transformation['origin'][0] + \\\r\n\t\t\t\t\t\ttransformation['extent'][1][0] + t_width / 2\r\n\t\t\t\telse:\r\n\t\t\t\t\tx = (xy[0] + graphics['origin'][0]) / o_width * t_width + transformation['origin'][0] + \\\r\n\t\t\t\t\t\ttransformation['extent'][0][0] + t_width / 2\r\n\r\n\t\t\t\tif 'extent' in transformation and transformation['extent'][1][1] < transformation['extent'][0][1]:\r\n\t\t\t\t\t# vertical flip\r\n\t\t\t\t\ty = (-xy[1] + graphics['origin'][1]) / o_height * t_height + transformation['origin'][1] + min(\r\n\t\t\t\t\t\ttransformation['extent'][1][1], transformation['extent'][0][1]) + t_height / 2\r\n\t\t\t\telse:\r\n\t\t\t\t\ty = (xy[1] + graphics['origin'][1]) / o_height * t_height + transformation['origin'][1] + min(\r\n\t\t\t\t\t\ttransformation['extent'][0][1], transformation['extent'][0][1]) + t_height / 2\r\n\r\n\t\t\t\ts = math.sin(transformation['rotation'] / 180 * 3.1415)\r\n\t\t\t\tc = math.cos(transformation['rotation'] / 180 * 3.1415)\r\n\r\n\t\t\t\tx -= transformation['origin'][0]\r\n\t\t\t\ty -= transformation['origin'][1]\r\n\r\n\t\t\t\txnew = x * c - y * s\r\n\t\t\t\tynew = x * s + y * c\r\n\r\n\t\t\t\tx = xnew + transformation['origin'][0]\r\n\t\t\t\ty = ynew + transformation['origin'][1]\r\n\r\n\t\t\texcept KeyError as ex:\r\n\t\t\t\tself.logger.error('Component position transformation failed: {0}', ex.message)\r\n\t\t\t\tself.logger.error(graphics)\r\n\r\n\t\tx -= min_x\r\n\t\ty = max_y - y\r\n\r\n\t\treturn x, y\r\n\r\n\t# get svg object from modelica graphics object\r\n\tdef get_svg_from_graphics(self, dwg, graphics, min_x, max_y, transformation=None, coordinate_system=None):\r\n\t\tshape = None\r\n\t\tdefinitions = svgwrite.container.Defs()\r\n\t\torigin = None\r\n\r\n\t\tif not 'origin' in graphics:\r\n\t\t\tgraphics['origin'] = (0, 0)\r\n\r\n\t\torigin = graphics['origin']\r\n\r\n\t\tif graphics['type'] == 'Rectangle' or graphics['type'] == 'Ellipse' or graphics['type'] == 'Text':\r\n\t\t\t(x0, y0) = self.get_coordinates(graphics['extent'][0], graphics, min_x, max_y, transformation,\r\n\t\t\t\t\t\t\t\t\t\t\tcoordinate_system)\r\n\t\t\t(x1, y1) = self.get_coordinates(graphics['extent'][1], graphics, min_x, max_y, transformation,\r\n\t\t\t\t\t\t\t\t\t\t\tcoordinate_system)\r\n\r\n\t\t\tif graphics['type'] == 'Rectangle':\r\n\t\t\t\tshape = dwg.rect((min(x0, x1), min(y0, y1)), (abs(x1 - x0), abs(y1 - y0)), graphics['radius'],\r\n\t\t\t\t\t\t\t\t graphics['radius'])\r\n\r\n\t\tif graphics['type'] == 'Rectangle' or graphics['type'] == 'Ellipse' or graphics['type'] == 'Polygon':\r\n\t\t\tif not 'fillPattern' in graphics:\r\n\t\t\t\tgraphics['fillPattern'] = 'FillPattern.None'\r\n\r\n\t\telif graphics['type'] == 'Line':\r\n\t\t\tif 'points' in graphics:\r\n\t\t\t\tif graphics['smooth'] == 'Smooth.Bezier' and len(graphics['points']) > 2:\r\n\t\t\t\t\t# TODO: Optimize this part!!!\r\n\t\t\t\t\tshape = svgwrite.path.Path()\r\n\t\t\t\t\tx_0, y_0 = self.get_coordinates([graphics['points'][0][0], graphics['points'][0][1]], graphics,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tmin_x, max_y, transformation, coordinate_system)\r\n\t\t\t\t\tshape.push('M', x_0, y_0, 'C')\r\n\r\n\t\t\t\t\tfor i in range(1, len(graphics['points']) - 1):\r\n\t\t\t\t\t\tx_0, y_0 = self.get_coordinates([graphics['points'][i - 1][0], graphics['points'][i - 1][1]],\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tgraphics, min_x, max_y, transformation, coordinate_system)\r\n\t\t\t\t\t\tx_1, y_1 = self.get_coordinates([graphics['points'][i][0], graphics['points'][i][1]], graphics,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmin_x, max_y, transformation, coordinate_system)\r\n\t\t\t\t\t\tx_2, y_2 = self.get_coordinates([graphics['points'][i + 1][0], graphics['points'][i + 1][1]],\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tgraphics, min_x, max_y, transformation, coordinate_system)\r\n\t\t\t\t\t\tx_01 = (x_1 + x_0) / 2\r\n\t\t\t\t\t\ty_01 = (y_1 + y_0) / 2\r\n\t\t\t\t\t\tx_12 = (x_2 + x_1) / 2\r\n\t\t\t\t\t\ty_12 = (y_2 + y_1) / 2\r\n\t\t\t\t\t\tshape.push(x_01, y_01, x_1, y_1, x_12, y_12)\r\n\t\t\t\t\tx_n, y_n = self.get_coordinates([graphics['points'][len(graphics['points']) - 1][0],\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t graphics['points'][len(graphics['points']) - 1][1]], graphics,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tmin_x, max_y, transformation, coordinate_system)\r\n\t\t\t\t\tshape.push(x_12, y_12, x_n, y_n, x_n, y_n)\r\n\t\t\t\telse:\r\n\t\t\t\t\tshape = dwg.polyline(\r\n\t\t\t\t\t\t[self.get_coordinates([x, y], graphics, min_x, max_y, transformation, coordinate_system) for\r\n\t\t\t\t\t\t (x, y) in graphics['points']])\r\n\t\t\t\tshape.fill('none', opacity=0)\r\n\r\n\t\t\t\t# markers\r\n\t\t\t\tif graphics['arrow'][0] != 'Arrow.None':\r\n\t\t\t\t\turl_id_start = graphics['arrow'][0] + '_start' + str(uuid.uuid4())\r\n\t\t\t\t\tmarker = svgwrite.container.Marker(insert=(10, 5), size=(4, 3), orient='auto', id=url_id_start,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t   viewBox=\"0 0 10 10\")\r\n\t\t\t\t\tp = svgwrite.path.Path(d=\"M 10 0 L 0 5 L 10 10 z\")\r\n\t\t\t\t\tp.fill(\"rgb(\" + ','.join([str(v) for v in graphics['color']]) + \")\")\r\n\t\t\t\t\tmarker.add(p)\r\n\t\t\t\t\tdefinitions.add(marker)\r\n\t\t\t\t\tshape['marker-start'] = marker.get_funciri()\r\n\r\n\t\t\t\tif graphics['arrow'][1] != 'Arrow.None':\r\n\t\t\t\t\turl_id_end = graphics['arrow'][1] + '_end' + str(uuid.uuid4())\r\n\t\t\t\t\tmarker = svgwrite.container.Marker(insert=(0, 5), size=(4, 3), orient='auto', id=url_id_end,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t   viewBox=\"0 0 10 10\")\r\n\t\t\t\t\tp = svgwrite.path.Path(d=\"M 0 0 L 10 5 L 0 10 z\")\r\n\t\t\t\t\tp.fill(\"rgb(\" + ','.join([str(v) for v in graphics['color']]) + \")\")\r\n\t\t\t\t\tmarker.add(p)\r\n\t\t\t\t\tdefinitions.add(marker)\r\n\t\t\t\t\tshape['marker-end'] = marker.get_funciri()\r\n\r\n\t\t\telse:\r\n\t\t\t\tself.logger.error('Not handled: {0}'.format(graphics))\r\n\t\t\t\treturn None\r\n\r\n\t\telif graphics['type'] == 'Polygon':\r\n\t\t\tif 'points' in graphics:\r\n\t\t\t\tif graphics['smooth'] == 'Smooth.Bezier' and len(graphics['points']) > 2:\r\n\t\t\t\t\t# TODO: Optimize this part!!!\r\n\t\t\t\t\tshape = svgwrite.path.Path()\r\n\t\t\t\t\tx_0, y_0 = self.get_coordinates([graphics['points'][0][0], graphics['points'][0][1]], graphics,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tmin_x, max_y, transformation, coordinate_system)\r\n\t\t\t\t\tshape.push('M', x_0, y_0, 'C')\r\n\r\n\t\t\t\t\tfor i in range(1, len(graphics['points']) - 1):\r\n\t\t\t\t\t\tx_0, y_0 = self.get_coordinates([graphics['points'][i - 1][0], graphics['points'][i - 1][1]],\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tgraphics, min_x, max_y, transformation, coordinate_system)\r\n\t\t\t\t\t\tx_1, y_1 = self.get_coordinates([graphics['points'][i][0], graphics['points'][i][1]], graphics,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmin_x, max_y, transformation, coordinate_system)\r\n\t\t\t\t\t\tx_2, y_2 = self.get_coordinates([graphics['points'][i + 1][0], graphics['points'][i + 1][1]],\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tgraphics, min_x, max_y, transformation, coordinate_system)\r\n\t\t\t\t\t\tx_01 = (x_1 + x_0) / 2\r\n\t\t\t\t\t\ty_01 = (y_1 + y_0) / 2\r\n\t\t\t\t\t\tx_12 = (x_2 + x_1) / 2\r\n\t\t\t\t\t\ty_12 = (y_2 + y_1) / 2\r\n\t\t\t\t\t\tshape.push(x_01, y_01, x_1, y_1, x_12, y_12)\r\n\t\t\t\t\tx_n, y_n = self.get_coordinates([graphics['points'][len(graphics['points']) - 1][0],\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t graphics['points'][len(graphics['points']) - 1][1]], graphics,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tmin_x, max_y, transformation, coordinate_system)\r\n\t\t\t\t\tshape.push(x_12, y_12, x_n, y_n, x_n, y_n)\r\n\t\t\t\telse:\r\n\t\t\t\t\tshape = dwg.polygon(\r\n\t\t\t\t\t\t[self.get_coordinates([x, y], graphics, min_x, max_y, transformation, coordinate_system) for\r\n\t\t\t\t\t\t (x, y) in graphics['points']])\r\n\t\t\t\tshape.fill('none', opacity=0)\r\n\t\t\telse:\r\n\t\t\t\tself.logger.error('Not handled: {0}'.format(graphics))\r\n\t\t\t\treturn None\r\n\r\n\t\telif graphics['type'] == 'Ellipse':\r\n\t\t\tshape = dwg.ellipse(((x0 + x1) / 2, (y0 + y1) / 2), (abs((x1 - x0) / 2), abs((y1 - y0) / 2)))\r\n\r\n\t\telif graphics['type'] == 'Text':\r\n\r\n\t\t\textra = {}\r\n\t\t\tx = (x0 + x1) / 2\r\n\t\t\ty = (y0 + y1) / 2\r\n\r\n\t\t\textra['font_family'] = graphics['fontName'] or \"Verdana\"\r\n\r\n\t\t\tif graphics['fontSize'] == 0:\r\n\t\t\t\textra['font_size'] = \"18\"\r\n\t\t\telse:\r\n\t\t\t\textra['font_size'] = graphics['fontSize']\r\n\r\n\t\t\tfor style in graphics['textStyle']:\r\n\t\t\t\tif style == \"TextStyle.Bold\":\r\n\t\t\t\t\textra['font-weight'] = 'bold'\r\n\t\t\t\telif style == \"TextStyle.Italic\":\r\n\t\t\t\t\textra['font-style'] = 'italic'\r\n\t\t\t\telif style == \"TextStyle.UnderLine\":\r\n\t\t\t\t\textra['text-decoration'] = 'underline'\r\n\r\n\t\t\textra['alignment_baseline'] = \"middle\"\r\n\r\n\t\t\tif graphics['horizontalAlignment'] == \"TextAlignment.Left\":\r\n\t\t\t\textra['text_anchor'] = \"start\"\r\n\t\t\t\tif x0 < x1:\r\n\t\t\t\t\tx = x0\r\n\t\t\t\telse:\r\n\t\t\t\t\tx = x1\r\n\t\t\t\tif y0 < y1:\r\n\t\t\t\t\ty = y0\r\n\t\t\t\telse:\r\n\t\t\t\t\ty = y1\r\n\t\t\telif graphics['horizontalAlignment'] == \"TextAlignment.Center\":\r\n\t\t\t\textra['text_anchor'] = \"middle\"\r\n\t\t\telif graphics['horizontalAlignment'] == \"TextAlignment.Right\":\r\n\t\t\t\textra['text_anchor'] = \"end\"\r\n\t\t\t\tif x0 < x1:\r\n\t\t\t\t\tx = x1\r\n\t\t\t\telse:\r\n\t\t\t\t\tx = x0\r\n\t\t\t\tif y0 < y1:\r\n\t\t\t\t\ty = y1\r\n\t\t\t\telse:\r\n\t\t\t\t\ty = y0\r\n\r\n\t\t\tshape = dwg.text(graphics['textString'].replace('%', ''), None, [x], [y], **extra)\r\n\r\n\t\t\tif graphics['textString'].find('%') != -1:\r\n\t\t\t\textra = {'class': \"bbox\", 'display': \"none\"}\r\n\t\t\t\txmin = x0\r\n\t\t\t\tymin = y0\r\n\t\t\t\txmax = x1\r\n\t\t\t\tymax = y1\r\n\r\n\t\t\t\tif x0 > x1:\r\n\t\t\t\t\txmin = x1\r\n\t\t\t\t\txmax = x0\r\n\t\t\t\tif y0 > y1:\r\n\t\t\t\t\tymin = y1\r\n\t\t\t\t\tymax = y0\r\n\r\n\t\t\t\tshape.add(svgwrite.text.TSpan((\"{0} {1} {2} {3}\".format(xmin, ymin, xmax, ymax)), **extra))\r\n\t\t\t\textra = {'class': \"data-bind\", 'display': \"none\"}\r\n\t\t\t\tshape.add(svgwrite.text.TSpan(graphics['textString'], **extra))\r\n\t\telse:\r\n\t\t\tself.logger.error('Not handled: {0}'.format(graphics))\r\n\t\t\treturn None\r\n\r\n\t\tdot_size = 4\r\n\t\tdash_size = 16\r\n\t\tspace_size = 8\r\n\r\n\t\tif 'linePattern' in graphics:\r\n\t\t\tdot_size *= graphics['lineThickness']\r\n\t\t\tdash_size *= graphics['lineThickness']\r\n\t\t\tspace_size *= graphics['lineThickness']\r\n\r\n\t\t\tif graphics['linePattern'] == 'LinePattern.None' or graphics['type'] == 'Text':\r\n\t\t\t\tpass\r\n\t\t\telif graphics['linePattern'] == 'LinePattern.Solid':\r\n\t\t\t\tshape.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\",\r\n\t\t\t\t\t\t\t width='{0}mm'.format(graphics['lineThickness']))\r\n\t\t\telif graphics['linePattern'] == 'LinePattern.Dash':\r\n\t\t\t\tshape.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\",\r\n\t\t\t\t\t\t\t width='{0}mm'.format(graphics['lineThickness']))\r\n\t\t\t\tshape.dasharray([dash_size, space_size])\r\n\t\t\telif graphics['linePattern'] == 'LinePattern.Dot':\r\n\t\t\t\tshape.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\",\r\n\t\t\t\t\t\t\t width='{0}mm'.format(graphics['lineThickness']))\r\n\t\t\t\tshape.dasharray([dot_size, space_size])\r\n\t\t\telif graphics['linePattern'] == 'LinePattern.DashDot':\r\n\t\t\t\tshape.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\",\r\n\t\t\t\t\t\t\t width='{0}mm'.format(graphics['lineThickness']))\r\n\t\t\t\tshape.dasharray([dash_size, space_size, dot_size, space_size])\r\n\t\t\telif graphics['linePattern'] == 'LinePattern.DashDotDot':\r\n\t\t\t\tshape.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\",\r\n\t\t\t\t\t\t\t width='{0}mm'.format(graphics['lineThickness']))\r\n\t\t\t\tshape.dasharray([dash_size, space_size, dot_size, space_size, dot_size, space_size])\r\n\r\n\t\t\tif graphics['type'] == 'Rectangle':\r\n\t\t\t\tif graphics['borderPattern'] == 'BorderPattern.None':\r\n\t\t\t\t\tpass\r\n\t\t\t\telif graphics['borderPattern'] == 'BorderPattern.Raised':\r\n\t\t\t\t\turl_id = graphics['borderPattern'] + '_' + str(uuid.uuid4())\r\n\t\t\t\t\tshape['filter'] = 'url(#' + url_id + ')'\r\n\r\n\t\t\t\t\tsvg_filter = svgwrite.filters.Filter(id=url_id, filterUnits=\"objectBoundingBox\", x=\"-0.1\", y=\"-0.1\",\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t width=\"1.2\", height=\"1.2\")\r\n\t\t\t\t\tsvg_filter.feGaussianBlur(\"SourceAlpha\", stdDeviation=\"5\", result=\"alpha_blur\")\r\n\t\t\t\t\tfeSL = svg_filter.feSpecularLighting(\"alpha_blur\", surfaceScale=\"5\", specularConstant=\"1\",\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t specularExponent=\"20\", lighting_color=\"#FFFFFF\",\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t result=\"spec_light\")\r\n\t\t\t\t\tfeSL.fePointLight((-5000, -10000, 10000))\r\n\t\t\t\t\tsvg_filter.feComposite(\"spec_light\", in2=\"SourceAlpha\", operator=\"in\", result=\"spec_light\")\r\n\t\t\t\t\tsvg_filter.feComposite(\"SourceGraphic\", in2=\"spec_light\", operator=\"out\", result=\"spec_light_fill\")\r\n\r\n\t\t\t\t\tdefinitions.add(svg_filter)\r\n\t\t\t\telif graphics['borderPattern'] == 'BorderPattern.Sunken':\r\n\t\t\t\t\tself.logger.warning('Not supported: {0}'.format(graphics['borderPattern']))\r\n\t\t\t\telif graphics['borderPattern'] == 'BorderPattern.Engraved':\r\n\t\t\t\t\tself.logger.warning('Not supported: {0}'.format(graphics['borderPattern']))\r\n\r\n\t\tif 'color' in graphics:\r\n\t\t\ttry:\r\n\t\t\t\tshape.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['color']]) + \")\",\r\n\t\t\t\t\t\t\t width='{0}mm'.format(graphics['thickness']))\r\n\t\t\texcept TypeError as ex:\r\n\t\t\t\tself.logger.error('{0} {1}'.format(graphics['color'], ex.message))\r\n\r\n\t\tif 'pattern' in graphics:\r\n\t\t\tdot_size *= graphics['thickness']\r\n\t\t\tdash_size *= graphics['thickness']\r\n\t\t\tspace_size *= graphics['thickness']\r\n\r\n\t\t\tif graphics['pattern'] == 'LinePattern.None' or graphics['type'] == 'Text':\r\n\t\t\t\tpass\r\n\t\t\telif graphics['pattern'] == 'LinePattern.Solid':\r\n\t\t\t\tshape.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['color']]) + \")\",\r\n\t\t\t\t\t\t\t width='{0}mm'.format(graphics['thickness']))\r\n\t\t\telif graphics['pattern'] == 'LinePattern.Dash':\r\n\t\t\t\tshape.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['color']]) + \")\",\r\n\t\t\t\t\t\t\t width='{0}mm'.format(graphics['thickness']))\r\n\t\t\t\tshape.dasharray([dash_size, space_size])\r\n\t\t\telif graphics['pattern'] == 'LinePattern.Dot':\r\n\t\t\t\tshape.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['color']]) + \")\",\r\n\t\t\t\t\t\t\t width='{0}mm'.format(graphics['thickness']))\r\n\t\t\t\tshape.dasharray([dot_size, space_size])\r\n\t\t\telif graphics['pattern'] == 'LinePattern.DashDot':\r\n\t\t\t\tshape.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['color']]) + \")\",\r\n\t\t\t\t\t\t\t width='{0}mm'.format(graphics['thickness']))\r\n\t\t\t\tshape.dasharray([dash_size, space_size, dot_size, space_size])\r\n\t\t\telif graphics['pattern'] == 'LinePattern.DashDotDot':\r\n\t\t\t\tshape.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['color']]) + \")\",\r\n\t\t\t\t\t\t\t width='{0}mm'.format(graphics['thickness']))\r\n\t\t\t\tshape.dasharray([dash_size, space_size, dot_size, space_size, dot_size, space_size])\r\n\r\n\t\tif 'fillPattern' in graphics:\r\n\t\t\tif graphics['fillPattern'] == 'FillPattern.None':\r\n\t\t\t\tif graphics['type'] == 'Text':\r\n\t\t\t\t\tshape.fill(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\")\r\n\t\t\t\telse:\r\n\t\t\t\t\tshape.fill('none', opacity=0)\r\n\t\t\telif graphics['fillPattern'] == 'FillPattern.Solid':\r\n\t\t\t\tshape.fill(\"rgb(\" + ','.join([str(v) for v in graphics['fillColor']]) + \")\")\r\n\t\t\telif graphics['fillPattern'] == 'FillPattern.Horizontal':\r\n\t\t\t\turl_id = str(uuid.uuid4())\r\n\t\t\t\tshape.fill('url(#' + url_id + ')')\r\n\r\n\t\t\t\tpattern = svgwrite.pattern.Pattern(id=url_id, insert=(0, 0), size=(5, 5), patternUnits='userSpaceOnUse')\r\n\r\n\t\t\t\trect = svgwrite.shapes.Rect(insert=(0, 0), size=(5, 5))\r\n\t\t\t\trect.fill(\"rgb(\" + ','.join([str(v) for v in graphics['fillColor']]) + \")\")\r\n\t\t\t\tpattern.add(rect)\r\n\r\n\t\t\t\tsvg_path = svgwrite.path.Path(d=\"M0,0 L5,0\")\r\n\t\t\t\tsvg_path.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\", width=2)\r\n\t\t\t\tpattern.add(svg_path)\r\n\r\n\t\t\t\tdefinitions.add(pattern)\r\n\r\n\t\t\telif graphics['fillPattern'] == 'FillPattern.Vertical':\r\n\t\t\t\turl_id = str(uuid.uuid4())\r\n\t\t\t\tshape.fill('url(#' + url_id + ')')\r\n\r\n\t\t\t\tpattern = svgwrite.pattern.Pattern(id=url_id, insert=(0, 0), size=(5, 5), patternUnits='userSpaceOnUse')\r\n\r\n\t\t\t\trect = svgwrite.shapes.Rect(insert=(0, 0), size=(5, 5))\r\n\t\t\t\trect.fill(\"rgb(\" + ','.join([str(v) for v in graphics['fillColor']]) + \")\")\r\n\t\t\t\tpattern.add(rect)\r\n\r\n\t\t\t\tsvg_path = svgwrite.path.Path(d=\"M0,0 L0,5\")\r\n\t\t\t\tsvg_path.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\", width=2)\r\n\t\t\t\tpattern.add(svg_path)\r\n\r\n\t\t\t\tdefinitions.add(pattern)\r\n\r\n\t\t\telif graphics['fillPattern'] == 'FillPattern.Cross':\r\n\t\t\t\turl_id = str(uuid.uuid4())\r\n\t\t\t\tshape.fill('url(#' + url_id + ')')\r\n\r\n\t\t\t\tpattern = svgwrite.pattern.Pattern(id=url_id, insert=(0, 0), size=(5, 5), patternUnits='userSpaceOnUse')\r\n\r\n\t\t\t\trect = svgwrite.shapes.Rect(insert=(0, 0), size=(5, 5))\r\n\t\t\t\trect.fill(\"rgb(\" + ','.join([str(v) for v in graphics['fillColor']]) + \")\")\r\n\t\t\t\tpattern.add(rect)\r\n\r\n\t\t\t\tsvg_path = svgwrite.path.Path(d=\"M0,0 L5,0\")\r\n\t\t\t\tsvg_path.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\", width=2)\r\n\t\t\t\tpattern.add(svg_path)\r\n\r\n\t\t\t\tsvg_path = svgwrite.path.Path(d=\"M0,0 L0,5\")\r\n\t\t\t\tsvg_path.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\", width=2)\r\n\t\t\t\tpattern.add(svg_path)\r\n\r\n\t\t\t\tdefinitions.add(pattern)\r\n\r\n\t\t\telif graphics['fillPattern'] == 'FillPattern.Forward':\r\n\t\t\t\turl_id = str(uuid.uuid4())\r\n\t\t\t\tshape.fill('url(#' + url_id + ')')\r\n\r\n\t\t\t\tpattern = svgwrite.pattern.Pattern(id=url_id, insert=(0, 0), size=(7, 7), patternUnits='userSpaceOnUse')\r\n\r\n\t\t\t\trect = svgwrite.shapes.Rect(insert=(0, 0), size=(7, 7))\r\n\t\t\t\trect.fill(\"rgb(\" + ','.join([str(v) for v in graphics['fillColor']]) + \")\")\r\n\t\t\t\tpattern.add(rect)\r\n\r\n\t\t\t\tsvg_path = svgwrite.path.Path(d=\"M0,0 l7,7\")\r\n\t\t\t\tsvg_path.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\", width=1)\r\n\t\t\t\tpattern.add(svg_path)\r\n\r\n\t\t\t\tsvg_path = svgwrite.path.Path(d=\"M6,-1 l3,3\")\r\n\t\t\t\tsvg_path.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\", width=1)\r\n\t\t\t\tpattern.add(svg_path)\r\n\r\n\t\t\t\tsvg_path = svgwrite.path.Path(d=\"M-1,6 l3,3\")\r\n\t\t\t\tsvg_path.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\", width=1)\r\n\t\t\t\tpattern.add(svg_path)\r\n\r\n\t\t\t\tdefinitions.add(pattern)\r\n\r\n\t\t\telif graphics['fillPattern'] == 'FillPattern.Backward':\r\n\t\t\t\turl_id = str(uuid.uuid4())\r\n\t\t\t\tshape.fill('url(#' + url_id + ')')\r\n\r\n\t\t\t\tpattern = svgwrite.pattern.Pattern(id=url_id, insert=(0, 0), size=(7, 7), patternUnits='userSpaceOnUse')\r\n\r\n\t\t\t\trect = svgwrite.shapes.Rect(insert=(0, 0), size=(7, 7))\r\n\t\t\t\trect.fill(\"rgb(\" + ','.join([str(v) for v in graphics['fillColor']]) + \")\")\r\n\t\t\t\tpattern.add(rect)\r\n\r\n\t\t\t\tsvg_path = svgwrite.path.Path(d=\"M7,0 l-7,7\")\r\n\t\t\t\tsvg_path.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\", width=1)\r\n\t\t\t\tpattern.add(svg_path)\r\n\r\n\t\t\t\tsvg_path = svgwrite.path.Path(d=\"M1,-1 l-7,7\")\r\n\t\t\t\tsvg_path.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\", width=1)\r\n\t\t\t\tpattern.add(svg_path)\r\n\r\n\t\t\t\tsvg_path = svgwrite.path.Path(d=\"M8,6 l-7,7\")\r\n\t\t\t\tsvg_path.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\", width=1)\r\n\t\t\t\tpattern.add(svg_path)\r\n\r\n\t\t\t\tdefinitions.add(pattern)\r\n\r\n\t\t\telif graphics['fillPattern'] == 'FillPattern.CrossDiag':\r\n\r\n\t\t\t\turl_id = str(uuid.uuid4())\r\n\t\t\t\tshape.fill('url(#' + url_id + ')')\r\n\r\n\t\t\t\tpattern = svgwrite.pattern.Pattern(id=url_id, insert=(0, 0), size=(8, 8), patternUnits='userSpaceOnUse')\r\n\r\n\t\t\t\trect = svgwrite.shapes.Rect(insert=(0, 0), size=(8, 8))\r\n\t\t\t\trect.fill(\"rgb(\" + ','.join([str(v) for v in graphics['fillColor']]) + \")\")\r\n\t\t\t\tpattern.add(rect)\r\n\r\n\t\t\t\tsvg_path = svgwrite.path.Path(d=\"M0,0 l8,8\")\r\n\t\t\t\tsvg_path.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\", width=1)\r\n\t\t\t\tpattern.add(svg_path)\r\n\r\n\t\t\t\tsvg_path = svgwrite.path.Path(d=\"M8,0 l-8,8\")\r\n\t\t\t\tsvg_path.stroke(\"rgb(\" + ','.join([str(v) for v in graphics['lineColor']]) + \")\", width=1)\r\n\t\t\t\tpattern.add(svg_path)\r\n\r\n\t\t\t\tdefinitions.add(pattern)\r\n\r\n\t\t\telif graphics['fillPattern'] == 'FillPattern.HorizontalCylinder':\r\n\r\n\t\t\t\turl_id = str(uuid.uuid4())\r\n\t\t\t\tshape.fill('url(#' + url_id + ')')\r\n\r\n\t\t\t\tline_color = graphics['lineColor']\r\n\t\t\t\tfill_color = graphics['fillColor']\r\n\r\n\t\t\t\tif not line_color:\r\n\t\t\t\t\tline_color = 'black'\r\n\t\t\t\tif not fill_color:\r\n\t\t\t\t\tfill_color = 'white'\r\n\r\n\t\t\t\tgradient = svgwrite.gradients.LinearGradient(id=url_id, x1=\"0%\", y1=\"0%\", x2=\"0%\", y2=\"100%\")\r\n\r\n\t\t\t\tcolors = self.get_gradient_colors(line_color, fill_color, 0)\r\n\r\n\t\t\t\tstop_values = [\r\n\t\t\t\t\t(0, 0),\r\n\t\t\t\t\t(0.3, 1),\r\n\t\t\t\t\t(0.7, 1),\r\n\t\t\t\t\t(1, 0)\r\n\t\t\t\t]\r\n\r\n\t\t\t\tfor (stop_value, idx) in stop_values:\r\n\t\t\t\t\tgradient.add_stop_color(offset=stop_value,\r\n\t\t\t\t\t\t\t\t\t\t\tcolor='rgb({0}, {1}, {2})'.format(colors[idx][0], colors[idx][1],\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  colors[idx][2]), opacity=1)\r\n\r\n\t\t\t\tdefinitions.add(gradient)\r\n\r\n\t\t\telif graphics['fillPattern'] == 'FillPattern.VerticalCylinder':\r\n\t\t\t\turl_id = str(uuid.uuid4())\r\n\t\t\t\tshape.fill('url(#' + url_id + ')')\r\n\r\n\t\t\t\tline_color = graphics['lineColor']\r\n\t\t\t\tfill_color = graphics['fillColor']\r\n\r\n\t\t\t\tif not line_color:\r\n\t\t\t\t\tline_color = 'black'\r\n\t\t\t\tif not fill_color:\r\n\t\t\t\t\tfill_color = 'white'\r\n\r\n\t\t\t\tgradient = svgwrite.gradients.LinearGradient(id=url_id, x1=\"0%\", y1=\"0%\", x2=\"100%\", y2=\"0%\")\r\n\r\n\t\t\t\tcolors = self.get_gradient_colors(line_color, fill_color, 0)\r\n\r\n\t\t\t\tstop_values = [\r\n\t\t\t\t\t(0, 0),\r\n\t\t\t\t\t(0.3, 1),\r\n\t\t\t\t\t(0.7, 1),\r\n\t\t\t\t\t(1, 0)\r\n\t\t\t\t]\r\n\r\n\t\t\t\tfor (stop_value, idx) in stop_values:\r\n\t\t\t\t\tgradient.add_stop_color(offset=stop_value,\r\n\t\t\t\t\t\t\t\t\t\t\tcolor='rgb({0}, {1}, {2})'.format(colors[idx][0], colors[idx][1],\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  colors[idx][2]), opacity=1)\r\n\r\n\t\t\t\tdefinitions.add(gradient)\r\n\t\t\telif graphics['fillPattern'] == 'FillPattern.Sphere':\r\n\t\t\t\tif graphics['type'] == 'Ellipse':\r\n\t\t\t\t\turl_id = str(uuid.uuid4())\r\n\r\n\t\t\t\t\tshape.fill('url(#' + url_id + ')')\r\n\r\n\t\t\t\t\tline_color = graphics['lineColor']\r\n\t\t\t\t\tfill_color = graphics['fillColor']\r\n\r\n\t\t\t\t\tif not line_color:\r\n\t\t\t\t\t\tline_color = 'black'\r\n\t\t\t\t\tif not fill_color:\r\n\t\t\t\t\t\tfill_color = 'white'\r\n\r\n\t\t\t\t\tgradient = svgwrite.gradients.RadialGradient(id=url_id, cx=\"50%\", cy=\"50%\", r=\"55%\", fx=\"50%\",\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t fy=\"50%\")\r\n\t\t\t\t\tcolors = self.get_gradient_colors(line_color, fill_color, 9)\r\n\r\n\t\t\t\t\tstop_values = [\r\n\t\t\t\t\t\t(0, 10),\r\n\t\t\t\t\t\t(0.45, 8),\r\n\t\t\t\t\t\t(0.7, 6),\r\n\t\t\t\t\t\t(1, 0)\r\n\t\t\t\t\t]\r\n\r\n\t\t\t\t\tfor (stop_value, idx) in stop_values:\r\n\t\t\t\t\t\tgradient.add_stop_color(offset=stop_value,\r\n\t\t\t\t\t\t\t\t\t\t\t\tcolor='rgb({0}, {1}, {2})'.format(colors[idx][0], colors[idx][1],\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  colors[idx][2]), opacity=1)\r\n\r\n\t\t\t\t\tdefinitions.add(gradient)\r\n\t\t\t\telif graphics['type'] == 'Rectangle':\r\n\t\t\t\t\turl_id = str(uuid.uuid4())\r\n\r\n\t\t\t\t\tshape.fill('url(#' + url_id + ')')\r\n\r\n\t\t\t\t\tline_color = graphics['lineColor']\r\n\t\t\t\t\tfill_color = graphics['fillColor']\r\n\r\n\t\t\t\t\tif not line_color:\r\n\t\t\t\t\t\tline_color = 'black'\r\n\t\t\t\t\tif not fill_color:\r\n\t\t\t\t\t\tfill_color = 'white'\r\n\r\n\t\t\t\t\tgradient = svgwrite.gradients.RadialGradient(id=url_id, cx=\"50%\", cy=\"50%\", r=\"0.9\", fx=\"50%\",\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t fy=\"50%\")\r\n\r\n\t\t\t\t\tcolors = self.get_gradient_colors(line_color, fill_color, 0)\r\n\r\n\t\t\t\t\tstop_values = [\r\n\t\t\t\t\t\t(0, 1),\r\n\t\t\t\t\t\t(1, 0)\r\n\t\t\t\t\t]\r\n\r\n\t\t\t\t\tfor (stop_value, idx) in stop_values:\r\n\t\t\t\t\t\tgradient.add_stop_color(offset=stop_value,\r\n\t\t\t\t\t\t\t\t\t\t\t\tcolor='rgb({0}, {1}, {2})'.format(colors[idx][0], colors[idx][1],\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  colors[idx][2]), opacity=1)\r\n\r\n\t\t\t\t\tdefinitions.add(gradient)\r\n\t\telse:\r\n\t\t\tshape.fill('none', opacity=0)\r\n\r\n\t\treturn shape, definitions\r\n\r\n\t# generate svgs from graphics objects\r\n\tdef generate_svg(self, filename, icon_graphics):\r\n\r\n\t\twidth = 100\r\n\t\theight = 100\r\n\r\n\t\tmin_x = 0\r\n\t\tmin_y = 0\r\n\t\tmax_x = 100\r\n\t\tmax_y = 100\r\n\r\n\t\tfor icon_graphic in icon_graphics:\r\n\t\t\tfor graphics in icon_graphic['graphics']:\r\n\t\t\t\tif not 'origin' in graphics:\r\n\t\t\t\t\tgraphics['origin'] = (0, 0)\r\n\r\n\t\t\t\tif not 'extent' in graphics:\r\n\t\t\t\t\tgraphics['extent'] = [[-100, -100], [100, 100]]\r\n\r\n\t\t\t\tif 'extent' in graphics:\r\n\t\t\t\t\tif min_x > graphics['extent'][0][0] + graphics['origin'][0]:\r\n\t\t\t\t\t\tmin_x = graphics['extent'][0][0] + graphics['origin'][0]\r\n\t\t\t\t\tif min_x > graphics['extent'][1][0] + graphics['origin'][0]:\r\n\t\t\t\t\t\tmin_x = graphics['extent'][1][0] + graphics['origin'][0]\r\n\t\t\t\t\tif min_y > graphics['extent'][0][1] + graphics['origin'][1]:\r\n\t\t\t\t\t\tmin_y = graphics['extent'][0][1] + graphics['origin'][1]\r\n\t\t\t\t\tif min_y > graphics['extent'][1][1] + graphics['origin'][1]:\r\n\t\t\t\t\t\tmin_y = graphics['extent'][1][1] + graphics['origin'][1]\r\n\t\t\t\t\tif max_x < graphics['extent'][1][0] + graphics['origin'][0]:\r\n\t\t\t\t\t\tmax_x = graphics['extent'][1][0] + graphics['origin'][0]\r\n\t\t\t\t\tif max_x < graphics['extent'][0][0] + graphics['origin'][0]:\r\n\t\t\t\t\t\tmax_x = graphics['extent'][0][0] + graphics['origin'][0]\r\n\t\t\t\t\tif max_y < graphics['extent'][1][1] + graphics['origin'][1]:\r\n\t\t\t\t\t\tmax_y = graphics['extent'][1][1] + graphics['origin'][1]\r\n\t\t\t\t\tif max_y < graphics['extent'][0][1] + graphics['origin'][1]:\r\n\t\t\t\t\t\tmax_y = graphics['extent'][0][1] + graphics['origin'][1]\r\n\r\n\t\t\t\tif 'points' in graphics:\r\n\t\t\t\t\tfor point in graphics['points']:\r\n\t\t\t\t\t\tif min_x > point[0] + graphics['origin'][0]:\r\n\t\t\t\t\t\t\tmin_x = point[0] + graphics['origin'][0]\r\n\t\t\t\t\t\tif min_y > point[1] + graphics['origin'][1]:\r\n\t\t\t\t\t\t\tmin_y = point[1] + graphics['origin'][1]\r\n\t\t\t\t\t\tif max_x < point[0] + graphics['origin'][0]:\r\n\t\t\t\t\t\t\tmax_x = point[0] + graphics['origin'][0]\r\n\t\t\t\t\t\tif max_y < point[1] + graphics['origin'][1]:\r\n\t\t\t\t\t\t\tmax_y = point[1] + graphics['origin'][1]\r\n\r\n\t\t\t\tfor port in icon_graphic['ports']:\r\n\t\t\t\t\tif min_x > port['transformation']['extent'][0][0] + port['transformation']['origin'][0]:\r\n\t\t\t\t\t\tmin_x = port['transformation']['extent'][0][0] + port['transformation']['origin'][0]\r\n\t\t\t\t\tif min_x > port['transformation']['extent'][1][0] + port['transformation']['origin'][0]:\r\n\t\t\t\t\t\tmin_x = port['transformation']['extent'][1][0] + port['transformation']['origin'][0]\r\n\t\t\t\t\tif min_y > port['transformation']['extent'][0][1] + port['transformation']['origin'][1]:\r\n\t\t\t\t\t\tmin_y = port['transformation']['extent'][0][1] + port['transformation']['origin'][1]\r\n\t\t\t\t\tif min_y > port['transformation']['extent'][1][1] + port['transformation']['origin'][1]:\r\n\t\t\t\t\t\tmin_y = port['transformation']['extent'][1][1] + port['transformation']['origin'][1]\r\n\t\t\t\t\tif max_x < port['transformation']['extent'][1][0] + port['transformation']['origin'][0]:\r\n\t\t\t\t\t\tmax_x = port['transformation']['extent'][1][0] + port['transformation']['origin'][0]\r\n\t\t\t\t\tif max_x < port['transformation']['extent'][0][0] + port['transformation']['origin'][0]:\r\n\t\t\t\t\t\tmax_x = port['transformation']['extent'][0][0] + port['transformation']['origin'][0]\r\n\t\t\t\t\tif max_y < port['transformation']['extent'][1][1] + port['transformation']['origin'][1]:\r\n\t\t\t\t\t\tmax_y = port['transformation']['extent'][1][1] + port['transformation']['origin'][1]\r\n\t\t\t\t\tif max_y < port['transformation']['extent'][0][1] + port['transformation']['origin'][1]:\r\n\t\t\t\t\t\tmax_y = port['transformation']['extent'][0][1] + port['transformation']['origin'][1]\r\n\r\n\t\t# ports can have borders\r\n\t\tmin_x -= 5\r\n\t\tmax_x += 5\r\n\t\tmin_y -= 5\r\n\t\tmax_y += 5\r\n\r\n\t\twidth = max_x - min_x\r\n\t\theight = max_y - min_y\r\n\r\n\t\tdwg = svgwrite.Drawing(filename, size=(width, height), viewBox=\"0 0 \" + str(width) + \" \" + str(height))\r\n\t\tdwg.add(svgwrite.base.Desc(icon_graphics[-1]['className']))\r\n\r\n\t\tfor icon_graphic in icon_graphics:\r\n\t\t\tfor graphics in icon_graphic['graphics']:\r\n\t\t\t\tshape_definitions = self.get_svg_from_graphics(dwg, graphics, min_x, max_y)\r\n\t\t\t\tif shape_definitions:\r\n\t\t\t\t\tshape, definitions = shape_definitions\r\n\t\t\t\t\tif isinstance(shape, svgwrite.text.Text) and shape.text == 'name':\r\n\t\t\t\t\t\tshape.text = filename.split('.')[-2]\r\n\t\t\t\t\tdwg.add(shape)\r\n\t\t\t\t\tdwg.add(definitions)\r\n\r\n\t\tfor icon_graphic in icon_graphics:\r\n\t\t\tfor port in icon_graphic['ports']:\r\n\t\t\t\tgroup = dwg.g(id=port['id'])\r\n\t\t\t\tfor graphics in port['graphics']:\r\n\t\t\t\t\tsvg_shape = self.get_svg_from_graphics(dwg, graphics, min_x, max_y, port['transformation'],\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   port['coordinateSystem'])\r\n\t\t\t\t\tif svg_shape:\r\n\t\t\t\t\t\tgroup.add(svg_shape[0])\r\n\t\t\t\t\t\tgroup.add(svg_shape[1])\r\n\r\n\t\t\t\tport_info = dwg.g(id='info', display='none')\r\n\t\t\t\tport_info.add(svgwrite.text.Text(port['id'], id='name'))\r\n\t\t\t\tport_info.add(svgwrite.text.Text(port['className'], id='type'))\r\n\t\t\t\tport_info.add(svgwrite.text.Text(port['classDesc'], id='classDesc'))\r\n\t\t\t\tport_info.add(svgwrite.text.Text(port['desc'], id='desc'))\r\n\r\n\t\t\t\tgroup.add(port_info)\r\n\r\n\t\t\t\tdwg.add(group)\r\n\r\n\t\tdwg.save()\r\n\r\n\t\treturn dwg\r\n\r\n\tdef export_icon(self, modelica_class, dir_name=None):\r\n\r\n\t\tif dir_name is None:\r\n\t\t\tdir_name = self.icon_dir_name\r\n\r\n\t\ttry:\r\n\t\t\t# get all icons\r\n\t\t\ticon_graphics = []\r\n\t\t\tbase_classes = []\r\n\t\t\tself.get_base_classes(modelica_class, base_classes)\r\n\r\n\t\t\tfor base_class in base_classes:\r\n\t\t\t\tgraphics = self.get_graphics_with_ports_for_class(base_class)\r\n\t\t\t\ticon_graphics.append(graphics)\r\n\t\t\tgraphics = self.get_graphics_with_ports_for_class(modelica_class)\r\n\t\t\ticon_graphics.append(graphics)\r\n\r\n\t\t\t# with open(os.path.join(output_dir, self.class_to_filename(modelica_class) + '.json'), 'w') as f_p:\r\n\t\t\t#\t json.dump(iconGraphics, f_p)\r\n\r\n\t\t\t# export svgs\r\n\t\t\tsvg_file_path = os.path.join(dir_name, self.class_to_filename(modelica_class) + \".svg\")\r\n\t\t\tdwg = self.generate_svg(svg_file_path, icon_graphics)\r\n\r\n\t\t\treturn svg_file_path\r\n\t\texcept:\r\n\t\t\treturn None\r\n\r\n\tdef get_base_classes(self, modelica_class, base_classes):\r\n\r\n\t\tinheritance_cnt = self.omc.getInheritanceCount(modelica_class)\r\n\t\t# inheritance_cnt = ask_omc('getInheritanceCount', modelica_class)\r\n\r\n\t\tfor i in range(1, inheritance_cnt + 1):\r\n\t\t\tbase_class = self.omc.getNthInheritedClass(modelica_class, str(i))\r\n\t\t\t# base_class = ask_omc('getNthInheritedClass', modelica_class + ', ' + str(i))\r\n\t\t\tif base_class not in base_classes:\r\n\t\t\t\tbase_classes.append(base_class)\r\n\t\t\t\tself.get_base_classes(base_class, base_classes)\r\n\r\n\tdef class_to_filename(self, cl):\r\n\t\t\"\"\"\r\n\t  The file-system dislikes directory separators, and scripts dislike tokens that expand to other names.\r\n\t  This function uses the same replacement rules as the OpenModelica documentation-generating script.\r\n\t  \"\"\"\r\n\t\treturn cl.replace(\"/\", \"Division\").replace(\"*\", \"Multiplication\")\r\n\r\n", "description": "\r\n\t\tCreates a new instance of IconExporter and passes in an OMCSession\r\n\t\t", "category": "graphics", "imports": ["import os\r", "import re\r", "import math\r", "import uuid\r", "import json\r", "import logging\r", "import sys\r", "from optparse import OptionParser\r", "import svgwrite\r", "import OMPython\r"]}], [{"term": "def", "name": "trazadora", "data": "def trazadora():\n\tpenup(traza, graphics)\n\tgoto(traza, graphics, -140,140)\n\tfor i in range(17):\n\t\twrite(traza, graphics, str(i))\n\t\tright(traza, 90,graphics)\n\t\tforward(traza, 10, graphics)\n\t\tpendown(traza, graphics)\n\t\tforward(traza, 150, graphics)\n\t\tpenup(traza, graphics)\n\t\tbackward(traza, graphics,160)\n\t\tleft(traza, 90, graphics)\n\t\tforward(traza,20, graphics)\n", "description": null, "category": "graphics", "imports": ["from random import *", "import queue", "import threading", "from turtle import pendown, penup", "from modulo2 import * "]}, {"term": "def", "name": "competidor", "data": "def competidor(tortuga, graphics,posx, posy):\n\tpenup(tortuga, graphics)\n\tgoto(tortuga, graphics, posx,posy)\n\tpendown(tortuga, graphics)\n\tfor i in range(100):\n\t\tforward(tortuga, randint(1,5), graphics)\n", "description": null, "category": "graphics", "imports": ["from random import *", "import queue", "import threading", "from turtle import pendown, penup", "from modulo2 import * "]}], [], [{"term": "def", "name": "get_modules", "data": "def get_modules():\n\treturn [x.get('module', None) for x in Factory.classes.itervalues()]\n", "description": null, "category": "graphics", "imports": ["import cause of the Factory and Core.", "import kivy", "from kivy.factory import Factory", "hiddenimports = _kivy_modules + get_modules()", "hiddenimports = list(set(hiddenimports))"]}], [{"term": "class", "name": "CoordinatesError", "data": "class CoordinatesError(BoxConstructError):\n\tpass\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "coords", "data": "def coords(value):\n\tif value.has_form(\"List\", 2):\n\t\tx, y = value.leaves[0].round_to_float(), value.leaves[1].round_to_float()\n\t\tif x is None or y is None:\n\t\t\traise CoordinatesError\n\t\treturn (x, y)\n\traise CoordinatesError\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Coords", "data": "class Coords(object):\n\tdef __init__(self, graphics, expr=None, pos=None, d=None):\n\t\tself.graphics = graphics\n\t\tself.p = pos\n\t\tself.d = d\n\t\tif expr is not None:\n\t\t\tif expr.has_form(\"Offset\", 1, 2):\n\t\t\t\tself.d = coords(expr.leaves[0])\n\t\t\t\tif len(expr.leaves) > 1:\n\t\t\t\t\tself.p = coords(expr.leaves[1])\n\t\t\t\telse:\n\t\t\t\t\tself.p = None\n\t\t\telse:\n\t\t\t\tself.p = coords(expr)\n\n\tdef pos(self):\n\t\tp = self.graphics.translate(self.p)\n\t\tp = (cut(p[0]), cut(p[1]))\n\t\tif self.d is not None:\n\t\t\td = self.graphics.translate_absolute(self.d)\n\t\t\treturn (p[0] + d[0], p[1] + d[1])\n\t\treturn p\n\n\tdef add(self, x, y):\n\t\tp = (self.p[0] + x, self.p[1] + y)\n\t\treturn Coords(self.graphics, pos=p, d=self.d)\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "cut", "data": "def cut(value):\n\t\"Cut values in graphics primitives (not displayed otherwise in SVG)\"\n\tborder = 10 ** 8\n\tif value < -border:\n\t\tvalue = -border\n\telif value > border:\n\t\tvalue = border\n\treturn value\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "create_css", "data": "def create_css(\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "_to_float", "data": "def _to_float(x):\n\tx = x.round_to_float()\n\tif x is None:\n\t\traise BoxConstructError\n\treturn x\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "_data_and_options", "data": "def _data_and_options(leaves, defined_options):\n\tdata = []\n\toptions = defined_options.copy()\n\tfor leaf in leaves:\n\t\tif leaf.get_head_name() == \"System`Rule\":\n\t\t\tif len(leaf.leaves) != 2:\n\t\t\t\traise BoxConstructError\n\t\t\tname, value = leaf.leaves\n\t\t\tname_head = name.get_head_name()\n\t\t\tif name_head == \"System`Symbol\":\n\t\t\t\tpy_name = name.get_name()\n\t\t\telif name_head == \"System`String\":\n\t\t\t\tpy_name = \"System`\" + name.get_string_value()\n\t\t\telse:  # unsupported name type\n\t\t\t\traise BoxConstructError\n\t\t\toptions[py_name] = value\n\t\telse:\n\t\t\tdata.append(leaf)\n\treturn data, options\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "_extract_graphics", "data": "def _extract_graphics(graphics, format, evaluation):\n\tgraphics_box = Expression(SymbolMakeBoxes, graphics).evaluate(evaluation)\n\t# builtin = GraphicsBox(expression=False)\n\telements, calc_dimensions = graphics_box._prepare_elements(\n\t\tgraphics_box.leaves, {\"evaluation\": evaluation}, neg_y=True\n\t)\n\txmin, xmax, ymin, ymax, _, _, _, _ = calc_dimensions()\n\n\t# xmin, xmax have always been moved to 0 here. the untransformed\n\t# and unscaled bounds are found in elements.xmin, elements.ymin,\n\t# elements.extent_width, elements.extent_height.\n\n\t# now compute the position of origin (0, 0) in the transformed\n\t# coordinate space.\n\n\tex = elements.extent_width\n\tey = elements.extent_height\n\n\tsx = (xmax - xmin) / ex\n\tsy = (ymax - ymin) / ey\n\n\tox = -elements.xmin * sx + xmin\n\toy = -elements.ymin * sy + ymin\n\n\t# generate code for svg or asy.\n\n\tif format in (\"asy\", \"svg\"):\n\t\tformat_fn = lookup_method(elements, format)\n\t\tcode = format_fn(elements)\n\telse:\n\t\traise NotImplementedError\n\n\treturn xmin, xmax, ymin, ymax, ox, oy, ex, ey, code\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Show", "data": "class Show(Builtin):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "fapply", "data": "\tdef apply(self, graphics, evaluation, options):\n\t\t\"\"\"Show[graphics_, OptionsPattern[%(name)s]]\"\"\"\n\n\t\tfor option in options:\n\t\t\tif option not in (\"System`ImageSize\",):\n\t\t\t\toptions[option] = Expression(SymbolN, options[option]).evaluate(\n\t\t\t\t\tevaluation\n\t\t\t\t)\n\n\t\t# The below could probably be done with graphics.filter..\n\t\tnew_leaves = []\n\t\toptions_set = set(options.keys())\n\t\tfor leaf in graphics.leaves:\n\t\t\tleaf_name = leaf.get_head_name()\n\t\t\tif leaf_name == \"System`Rule\" and str(leaf.leaves[0]) in options_set:\n\t\t\t\tcontinue\n\t\t\tnew_leaves.append(leaf)\n\n\t\tnew_leaves += options_to_rules(options)\n\t\tgraphics = graphics.restructure(graphics.head, new_leaves, evaluation)\n\n\t\treturn graphics\n\n", "description": "Show[graphics_, OptionsPattern[%(name)s]]", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Graphics", "data": "class Graphics(Builtin):\n\tr\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "fapply_makeboxes", "data": "\tdef apply_makeboxes(self, content, evaluation, options):\n\t\t\"\"\"MakeBoxes[%(name)s[content_, OptionsPattern[%(name)s]],\n\t\tStandardForm|TraditionalForm|OutputForm]\"\"\"\n\n\t\tdef convert(content):\n\t\t\thead = content.get_head_name()\n\n\t\t\tif head == \"System`List\":\n\t\t\t\treturn Expression(\n\t\t\t\t\tSymbolList, *[convert(item) for item in content.leaves]\n\t\t\t\t)\n\t\t\telif head == \"System`Style\":\n\t\t\t\treturn Expression(\n\t\t\t\t\t\"StyleBox\", *[convert(item) for item in content.leaves]\n\t\t\t\t)\n\n\t\t\tif head in element_heads:\n\t\t\t\tif head == \"System`Text\":\n\t\t\t\t\thead = \"System`Inset\"\n\t\t\t\tatoms = content.get_atoms(include_heads=False)\n\t\t\t\tif any(\n\t\t\t\t\tnot isinstance(atom, (Integer, Real))\n\t\t\t\t\tand not atom.get_name() in GRAPHICS_SYMBOLS\n\t\t\t\t\tfor atom in atoms\n\t\t\t\t):\n\t\t\t\t\tif head == \"System`Inset\":\n\t\t\t\t\t\tinset = content.leaves[0]\n\t\t\t\t\t\tif inset.get_head_name() == \"System`Graphics\":\n\t\t\t\t\t\t\topts = {}\n\t\t\t\t\t\t\t# opts = dict(opt._leaves[0].name:opt_leaves[1]   for opt in  inset._leaves[1:])\n\t\t\t\t\t\t\tinset = self.apply_makeboxes(\n\t\t\t\t\t\t\t\tinset._leaves[0], evaluation, opts\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\tn_leaves = [inset] + [\n\t\t\t\t\t\t\tExpression(SymbolN, leaf).evaluate(evaluation)\n\t\t\t\t\t\t\tfor leaf in content.leaves[1:]\n\t\t\t\t\t\t]\n\t\t\t\t\telse:\n\t\t\t\t\t\tn_leaves = (\n\t\t\t\t\t\t\tExpression(SymbolN, leaf).evaluate(evaluation)\n\t\t\t\t\t\t\tfor leaf in content.leaves\n\t\t\t\t\t\t)\n\t\t\t\telse:\n\t\t\t\t\tn_leaves = content.leaves\n\t\t\t\treturn Expression(head + self.box_suffix, *n_leaves)\n\t\t\treturn content\n\n\t\tfor option in options:\n\t\t\tif option not in (\"System`ImageSize\",):\n\t\t\t\toptions[option] = Expression(SymbolN, options[option]).evaluate(\n\t\t\t\t\tevaluation\n\t\t\t\t)\n\n\t\tfrom mathics.builtin.box.graphics import GraphicsBox\n\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox\n\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D\n\n\t\tif type(self) is Graphics:\n\t\t\treturn GraphicsBox(\n\t\t\t\tconvert(content), evaluation=evaluation, *options_to_rules(options)\n\t\t\t)\n\t\telif type(self) is Graphics3D:\n\t\t\treturn Graphics3DBox(\n\t\t\t\tconvert(content), evaluation=evaluation, *options_to_rules(options)\n\t\t\t)\n\n", "description": "MakeBoxes[%(name)s[content_, OptionsPattern[%(name)s]],\n\t\tStandardForm|TraditionalForm|OutputForm]", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "_Size", "data": "class _Size(_GraphicsElement):\n\tdef init(self, graphics, item=None, value=None):\n\t\tsuper(_Size, self).init(graphics, item)\n\t\tif item is not None:\n\t\t\tself.value = item.leaves[0].round_to_float()\n\t\telif value is not None:\n\t\t\tself.value = value\n\t\telse:\n\t\t\traise BoxConstructError\n\t\tif self.value < 0:\n\t\t\traise BoxConstructError\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "_Thickness", "data": "class _Thickness(_Size):\n\tpass\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "AbsoluteThickness", "data": "class AbsoluteThickness(_Thickness):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "fget_thickness", "data": "\tdef get_thickness(self):\n\t\treturn self.graphics.translate_absolute((self.value, 0))[0]\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Thickness", "data": "class Thickness(_Thickness):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "fget_thickness", "data": "\tdef get_thickness(self):\n\t\treturn self.graphics.translate_relative(self.value)\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Thin", "data": "class Thin(Builtin):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Thick", "data": "class Thick(Builtin):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "PointSize", "data": "class PointSize(_Size):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "fget_absolute_size", "data": "\tdef get_absolute_size(self):\n\t\tif self.graphics.view_width is None:\n\t\t\tself.graphics.view_width = 400\n\t\tif self.value is None:\n\t\t\tself.value = DEFAULT_POINT_FACTOR\n\t\treturn self.graphics.view_width * self.value\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "FontColor", "data": "class FontColor(Builtin):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Offset", "data": "class Offset(Builtin):\n\tpass\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Rectangle", "data": "class Rectangle(Builtin):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Disk", "data": "class Disk(Builtin):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Circle", "data": "class Circle(Builtin):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Inset", "data": "class Inset(Builtin):\n\tpass\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Text", "data": "class Text(Inset):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "_Polyline", "data": "class _Polyline(_GraphicsElement):\n\tdef do_init(self, graphics, points):\n\t\tif not points.has_form(\"List\", None):\n\t\t\traise BoxConstructError\n\t\tif (\n\t\t\tpoints.leaves\n\t\t\tand points.leaves[0].has_form(\"List\", None)\n\t\t\tand all(leaf.has_form(\"List\", None) for leaf in points.leaves[0].leaves)\n\t\t):\n\t\t\tleaves = points.leaves\n\t\t\tself.multi_parts = True\n\t\telse:\n\t\t\tleaves = [Expression(SymbolList, *points.leaves)]\n\t\t\tself.multi_parts = False\n\t\tlines = []\n\t\tfor leaf in leaves:\n\t\t\tif leaf.has_form(\"List\", None):\n\t\t\t\tlines.append(leaf.leaves)\n\t\t\telse:\n\t\t\t\traise BoxConstructError\n\t\tself.lines = [\n\t\t\t[graphics.coords(graphics, point) for point in line] for line in lines\n\t\t]\n\n\tdef extent(self):\n\t\tl = self.style.get_line_width(face_element=False)\n\t\tresult = []\n\t\tfor line in self.lines:\n\t\t\tfor c in line:\n\t\t\t\tx, y = c.pos()\n\t\t\t\tresult.extend(\n\t\t\t\t\t[(x - l, y - l), (x - l, y + l), (x + l, y - l), (x + l, y + l)]\n\t\t\t\t)\n\t\treturn result\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Point", "data": "class Point(Builtin):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Line", "data": "class Line(Builtin):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "_svg_bezier", "data": "def _svg_bezier(*segments):\n\t# see https://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands\n\t# see https://docs.webplatform.org/wiki/svg/tutorials/smarter_svg_shapes\n\n\twhile segments and not segments[0][1]:\n\t\tsegments = segments[1:]\n\n\tif not segments:\n\t\treturn\n\n\tforms = \"LQC\"  # SVG commands for line, quadratic bezier, cubic bezier\n\n\tdef path(max_degree, p):\n\t\tmax_degree = min(max_degree, len(forms))\n\t\twhile p:\n\t\t\tn = min(max_degree, len(p))  # 1, 2, or 3\n\t\t\tif n < 1:\n\t\t\t\traise BoxConstructError\n\t\t\tyield forms[n - 1] + \" \".join(\"%f,%f\" % xy for xy in p[:n])\n\t\t\tp = p[n:]\n\n\tk, p = segments[0]\n\tyield \"M%f,%f\" % p[0]\n\n\tfor s in path(k, p[1:]):\n\t\tyield s\n\n\tfor k, p in segments[1:]:\n\t\tfor s in path(k, p):\n\t\t\tyield s\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "FilledCurve", "data": "class FilledCurve(Builtin):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Polygon", "data": "class Polygon(Builtin):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "RegularPolygon", "data": "class RegularPolygon(Builtin):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Arrow", "data": "class Arrow(Builtin):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Arrowheads", "data": "class Arrowheads(_GraphicsElement):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "finit", "data": "\tdef init(self, graphics, item=None):\n\t\tsuper(Arrowheads, self).init(graphics, item)\n\t\tif len(item.leaves) != 1:\n\t\t\traise BoxConstructError\n\t\tself.spec = item.leaves[0]\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "f_arrow_size", "data": "\tdef _arrow_size(self, s, extent):\n\t\tif isinstance(s, Symbol):\n\t\t\tsize = self.symbolic_sizes.get(s.get_name(), 0)\n\t\t\treturn self.graphics.translate_absolute((size, 0))[0]\n\t\telse:\n\t\t\treturn _to_float(s) * extent\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "fheads", "data": "\tdef heads(self, extent, default_arrow, custom_arrow):\n\t\t# see https://reference.wolfram.com/language/ref/Arrowheads.html\n\n\t\tif self.spec.get_head_name() == \"System`List\":\n\t\t\tleaves = self.spec.leaves\n\t\t\tif all(x.get_head_name() == \"System`List\" for x in leaves):\n\t\t\t\tfor head in leaves:\n\t\t\t\t\tspec = head.leaves\n\t\t\t\t\tif len(spec) not in (2, 3):\n\t\t\t\t\t\traise BoxConstructError\n\t\t\t\t\tsize_spec = spec[0]\n\t\t\t\t\tif (\n\t\t\t\t\t\tisinstance(size_spec, Symbol)\n\t\t\t\t\t\tand size_spec.get_name() == \"System`Automatic\"\n\t\t\t\t\t):\n\t\t\t\t\t\ts = self.default_size * extent\n\t\t\t\t\telif size_spec.is_numeric():\n\t\t\t\t\t\ts = self._arrow_size(size_spec, extent)\n\t\t\t\t\telse:\n\t\t\t\t\t\traise BoxConstructError\n\n\t\t\t\t\tif len(spec) == 3 and custom_arrow:\n\t\t\t\t\t\tgraphics = spec[2]\n\t\t\t\t\t\tif graphics.get_head_name() != \"System`Graphics\":\n\t\t\t\t\t\t\traise BoxConstructError\n\t\t\t\t\t\tarrow = custom_arrow(graphics)\n\t\t\t\t\telse:\n\t\t\t\t\t\tarrow = default_arrow\n\n\t\t\t\t\tif not isinstance(spec[1], (Real, Rational, Integer)):\n\t\t\t\t\t\traise BoxConstructError\n\n\t\t\t\t\tyield s, _to_float(spec[1]), arrow\n\t\t\telse:\n\t\t\t\tn = max(1.0, len(leaves) - 1.0)\n\t\t\t\tfor i, head in enumerate(leaves):\n\t\t\t\t\tyield self._arrow_size(head, extent), i / n, default_arrow\n\t\telse:\n\t\t\tyield self._arrow_size(self.spec, extent), 1, default_arrow\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "_norm", "data": "def _norm(p, q):\n\tpx, py = p\n\tqx, qy = q\n\n\tdx = qx - px\n\tdy = qy - py\n\n\tlength = sqrt(dx * dx + dy * dy)\n\treturn dx, dy, length\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "class_Line:", "data": "class _Line:\n\tdef make_draw_svg(self, style):\n\t\tdef draw(points):\n\t\t\tyield '' % style\n\n\t\treturn draw\n\n\tdef make_draw_asy(self, pen):\n\t\tdef draw(points):\n\t\t\tyield \"draw(\"\n\t\t\tyield \"--\".join([\"(%.5g,%5g)\" % xy for xy in points])\n\t\t\tyield \", % s);\" % pen\n\n\t\treturn draw\n\n\tdef arrows(self, points, heads):  # heads has to be sorted by pos\n\t\tdef segments(points):\n\t\t\tfor i in range(len(points) - 1):\n\t\t\t\tpx, py = points[i]\n\t\t\t\tdx, dy, dl = _norm((px, py), points[i + 1])\n\t\t\t\tyield dl, px, py, dx, dy\n\n\t\tseg = list(segments(points))\n\n\t\tif not seg:\n\t\t\treturn\n\n\t\ti = 0\n\t\tt0 = 0.0\n\t\tn = len(seg)\n\t\tdl, px, py, dx, dy = seg[i]\n\t\ttotal = sum(segment[0] for segment in seg)\n\n\t\tfor s, t, draw in ((s, pos * total - t0, draw) for s, pos, draw in heads):\n\t\t\tif s == 0.0:  # ignore zero-sized arrows\n\t\t\t\tcontinue\n\n\t\t\tif i < n:  # not yet past last segment?\n\t\t\t\twhile t > dl:  # position past current segment?\n\t\t\t\t\tt -= dl\n\t\t\t\t\tt0 += dl\n\t\t\t\t\ti += 1\n\t\t\t\t\tif i == n:\n\t\t\t\t\t\tpx += dx  # move to last segment's end\n\t\t\t\t\t\tpy += dy\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tdl, px, py, dx, dy = seg[i]\n\n\t\t\tfor shape in draw(px, py, dx / dl, dy / dl, t, s):\n\t\t\t\tyield shape\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "_bezier_derivative", "data": "def _bezier_derivative(p):\n\t# see http://pomax.github.io/bezierinfo/, Section 12 Derivatives\n\tn = len(p[0]) - 1\n\treturn [[n * (x1 - x0) for x1, x0 in zip(w, w[1:])] for w in p]\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "_bezier_evaluate", "data": "def _bezier_evaluate(p, t):\n\t# see http://pomax.github.io/bezierinfo/, Section 4 Controlling Bezier Curvatures\n\tn = len(p[0]) - 1\n\tif n == 3:\n\t\tt2 = t * t\n\t\tt3 = t2 * t\n\t\tmt = 1 - t\n\t\tmt2 = mt * mt\n\t\tmt3 = mt2 * mt\n\t\treturn [\n\t\t\tw[0] * mt3 + 3 * w[1] * mt2 * t + 3 * w[2] * mt * t2 + w[3] * t3 for w in p\n\t\t]\n\telif n == 2:\n\t\tt2 = t * t\n\t\tmt = 1 - t\n\t\tmt2 = mt * mt\n\t\treturn [w[0] * mt2 + w[1] * 2 * mt * t + w[2] * t2 for w in p]\n\telif n == 1:\n\t\tmt = 1 - t\n\t\treturn [w[0] * mt + w[1] * t for w in p]\n\telse:\n\t\traise ValueError(\"cannot compute bezier curve of order %d\" % n)\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "class_BezierCurve:", "data": "class _BezierCurve:\n\tdef __init__(self, spline_degree=3):\n\t\tself.spline_degree = spline_degree\n\n\tdef make_draw_svg(self, style):\n\t\tdef draw(points):\n\t\t\ts = \" \".join(_svg_bezier((self.spline_degree, points)))\n\t\t\tyield '' % (s, style)\n\n\t\treturn draw\n\n\tdef make_draw_asy(self, pen):\n\t\tdef draw(points):\n\t\t\tfor path in asy_bezier((self.spline_degree, points)):\n\t\t\t\tyield \"draw(%s, %s);\" % (path, pen)\n\n\t\treturn draw\n\n\tdef arrows(self, points, heads):  # heads has to be sorted by pos\n\t\tif len(points) < 2:\n\t\t\treturn\n\n\t\t# FIXME combined curves\n\n\t\tcp = list(zip(*points))\n\t\tif len(points) >= 3:\n\t\t\tdcp = _bezier_derivative(cp)\n\t\telse:\n\t\t\tdcp = cp\n\n\t\tfor s, t, draw in heads:\n\t\t\tif s == 0.0:  # ignore zero-sized arrows\n\t\t\t\tcontinue\n\n\t\t\tpx, py = _bezier_evaluate(cp, t)\n\n\t\t\ttx, ty = _bezier_evaluate(dcp, t)\n\t\t\ttl = -sqrt(tx * tx + ty * ty)\n\t\t\ttx /= tl\n\t\t\tty /= tl\n\n\t\t\tfor shape in draw(px, py, tx, ty, 0.0, s):\n\t\t\t\tyield shape\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "total_extent", "data": "def total_extent(extents):\n\txmin = xmax = ymin = ymax = None\n\tfor extent in extents:\n\t\tfor x, y in extent:\n\t\t\tif xmin is None or x < xmin:\n\t\t\t\txmin = x\n\t\t\tif xmax is None or x > xmax:\n\t\t\t\txmax = x\n\t\t\tif ymin is None or y < ymin:\n\t\t\t\tymin = y\n\t\t\tif ymax is None or y > ymax:\n\t\t\t\tymax = y\n\treturn xmin, xmax, ymin, ymax\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "EdgeForm", "data": "class EdgeForm(Builtin):\n\t\"\"\"\n\t>> Graphics[{EdgeForm[{Thick, Green}], Disk[]}]\n\t = -Graphics-\n\n\t>> Graphics[{Style[Disk[],EdgeForm[{Thick,Red}]], Circle[{1,1}]}]\n\t = -Graphics-\n\t\"\"\"\n\n\tpass\n\n", "description": "\n\t>> Graphics[{EdgeForm[{Thick, Green}], Disk[]}]\n\t = -Graphics-\n\n\t>> Graphics[{Style[Disk[],EdgeForm[{Thick,Red}]], Circle[{1,1}]}]\n\t = -Graphics-\n\t", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "FaceForm", "data": "class FaceForm(Builtin):\n\tpass\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "_style", "data": "def _style(graphics, item):\n\thead = item.get_head_name()\n\tif head in style_heads:\n\t\tklass = get_class(head)\n\t\tstyle = klass.create_as_style(klass, graphics, item)\n\telif head in (\"System`EdgeForm\", \"System`FaceForm\"):\n\t\tstyle = graphics.get_style_class()(\n\t\t\tgraphics, edge=head == \"System`EdgeForm\", face=head == \"System`FaceForm\"\n\t\t)\n\t\tif len(item.leaves) > 1:\n\t\t\traise BoxConstructError\n\t\tif item.leaves:\n\t\t\tif item.leaves[0].has_form(\"List\", None):\n\t\t\t\tfor dir in item.leaves[0].leaves:\n\t\t\t\t\tstyle.append(dir, allow_forms=False)\n\t\t\telse:\n\t\t\t\tstyle.append(item.leaves[0], allow_forms=False)\n\telse:\n\t\traise BoxConstructError\n\treturn style\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Style", "data": "class Style(object):\n\tdef __init__(self, graphics, edge=False, face=False):\n\t\tself.styles = []\n\t\tself.options = {}\n\t\tself.graphics = graphics\n\t\tself.edge = edge\n\t\tself.face = face\n\t\tself.klass = graphics.get_style_class()\n\n\tdef append(self, item, allow_forms=True):\n\t\tself.styles.append(_style(self.graphics, item))\n\n\tdef set_option(self, name, value):\n\t\tself.options[name] = value\n\n\tdef extend(self, style, pre=True):\n\t\tif pre:\n\t\t\tself.styles = style.styles + self.styles\n\t\telse:\n\t\t\tself.styles.extend(style.styles)\n\n\tdef clone(self):\n\t\tresult = self.klass(self.graphics, edge=self.edge, face=self.face)\n\t\tresult.styles = self.styles[:]\n\t\tresult.options = self.options.copy()\n\t\treturn result\n\n\tdef get_default_face_color(self):\n\t\treturn RGBColor(components=(0, 0, 0, 1))\n\n\tdef get_default_edge_color(self):\n\t\treturn RGBColor(components=(0, 0, 0, 1))\n\n\tdef get_style(\n\t\tself, style_class, face_element=None, default_to_faces=True, consider_forms=True\n\t):\n\t\tif face_element is not None:\n\t\t\tdefault_to_faces = consider_forms = face_element\n\t\tedge_style = face_style = None\n\t\tif style_class == _Color:\n\t\t\tif default_to_faces:\n\t\t\t\tface_style = self.get_default_face_color()\n\t\t\telse:\n\t\t\t\tedge_style = self.get_default_edge_color()\n\t\telif style_class == _Thickness:\n\t\t\tif not default_to_faces:\n\t\t\t\tedge_style = AbsoluteThickness(self.graphics, value=0.5)\n\t\tfor item in self.styles:\n\t\t\tif isinstance(item, style_class):\n\t\t\t\tif default_to_faces:\n\t\t\t\t\tface_style = item\n\t\t\t\telse:\n\t\t\t\t\tedge_style = item\n\t\t\telif isinstance(item, Style):\n\t\t\t\tif consider_forms:\n\t\t\t\t\tif item.edge:\n\t\t\t\t\t\tedge_style, _ = item.get_style(\n\t\t\t\t\t\t\tstyle_class, default_to_faces=False, consider_forms=False\n\t\t\t\t\t\t)\n\t\t\t\t\telif item.face:\n\t\t\t\t\t\t_, face_style = item.get_style(\n\t\t\t\t\t\t\tstyle_class, default_to_faces=True, consider_forms=False\n\t\t\t\t\t\t)\n\n\t\treturn edge_style, face_style\n\n\tdef get_option(self, name):\n\t\treturn self.options.get(name, None)\n\n\tdef get_line_width(self, face_element=True):\n\t\tif self.graphics.pixel_width is None:\n\t\t\treturn 0\n\t\tedge_style, _ = self.get_style(\n\t\t\t_Thickness, default_to_faces=face_element, consider_forms=face_element\n\t\t)\n\t\tif edge_style is None:\n\t\t\treturn 0\n\t\treturn edge_style.get_thickness()\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "def", "name": "_flatten", "data": "def _flatten(leaves):\n\tfor leaf in leaves:\n\t\tif leaf.get_head_name() == \"System`List\":\n\t\t\tflattened = leaf.flatten(Symbol(\"List\"))\n\t\t\tif flattened.get_head_name() == \"System`List\":\n\t\t\t\tfor x in flattened.leaves:\n\t\t\t\t\tyield x\n\t\t\telse:\n\t\t\t\tyield flattened\n\t\telse:\n\t\t\tyield leaf\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "_GraphicsElements", "data": "class _GraphicsElements(object):\n\tdef __init__(self, content, evaluation):\n\t\tself.evaluation = evaluation\n\t\tself.elements = []\n\n\t\tbuiltins = evaluation.definitions.builtin\n\n\t\tdef get_options(name):\n\t\t\tbuiltin = builtins.get(name)\n\t\t\tif builtin is None:\n\t\t\t\treturn None\n\t\t\treturn builtin.options\n\n\t\tdef stylebox_style(style, specs):\n\t\t\tnew_style = style.clone()\n\t\t\tfor spec in _flatten(specs):\n\t\t\t\thead_name = spec.get_head_name()\n\t\t\t\tif head_name in style_and_form_heads:\n\t\t\t\t\tnew_style.append(spec)\n\t\t\t\telif head_name == \"System`Rule\" and len(spec.leaves) == 2:\n\t\t\t\t\toption, expr = spec.leaves\n\t\t\t\t\tif not isinstance(option, Symbol):\n\t\t\t\t\t\traise BoxConstructError\n\n\t\t\t\t\tname = option.get_name()\n\t\t\t\t\tcreate = style_options.get(name, None)\n\t\t\t\t\tif create is None:\n\t\t\t\t\t\traise BoxConstructError\n\n\t\t\t\t\tnew_style.set_option(name, create(style.graphics, expr))\n\t\t\t\telse:\n\t\t\t\t\traise BoxConstructError\n\t\t\treturn new_style\n\n\t\tdef convert(content, style):\n\t\t\tif content.has_form(\"List\", None):\n\t\t\t\titems = content.leaves\n\t\t\telse:\n\t\t\t\titems = [content]\n\t\t\tstyle = style.clone()\n\t\t\tfor item in items:\n\t\t\t\tif item.get_name() == \"System`Null\":\n\t\t\t\t\tcontinue\n\t\t\t\thead = item.get_head_name()\n\t\t\t\tif head in style_and_form_heads:\n\t\t\t\t\tstyle.append(item)\n\t\t\t\telif head == \"System`StyleBox\":\n\t\t\t\t\tif len(item.leaves) < 1:\n\t\t\t\t\t\traise BoxConstructError\n\t\t\t\t\tfor element in convert(\n\t\t\t\t\t\titem.leaves[0], stylebox_style(style, item.leaves[1:])\n\t\t\t\t\t):\n\t\t\t\t\t\tyield element\n\t\t\t\telif head[-3:] == \"Box\":  # and head[:-3] in element_heads:\n\t\t\t\t\telement_class = get_class(head)\n\t\t\t\t\tif element_class is not None:\n\t\t\t\t\t\toptions = get_options(head[:-3])\n\t\t\t\t\t\tif options:\n\t\t\t\t\t\t\tdata, options = _data_and_options(item.leaves, options)\n\t\t\t\t\t\t\tnew_item = Expression(head, *data)\n\t\t\t\t\t\t\telement = get_class(head)(self, style, new_item, options)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\telement = get_class(head)(self, style, item)\n\t\t\t\t\t\tyield element\n\t\t\t\t\telse:\n\t\t\t\t\t\traise BoxConstructError\n\t\t\t\telif head == \"System`List\":\n\t\t\t\t\tfor element in convert(item, style):\n\t\t\t\t\t\tyield element\n\t\t\t\telse:\n\t\t\t\t\traise BoxConstructError\n\n\t\tself.elements = list(convert(content, self.get_style_class()(self)))\n\n\tdef create_style(self, expr):\n\t\tstyle = self.get_style_class()(self)\n\n\t\tdef convert(expr):\n\t\t\tif expr.has_form((\"List\", \"Directive\"), None):\n\t\t\t\tfor item in expr.leaves:\n\t\t\t\t\tconvert(item)\n\t\t\telse:\n\t\t\t\tstyle.append(expr)\n\n\t\tconvert(expr)\n\t\treturn style\n\n\tdef get_style_class(self):\n\t\treturn Style\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "GraphicsElements", "data": "class GraphicsElements(_GraphicsElements):\n\tcoords = Coords\n\n\tdef __init__(self, content, evaluation, neg_y=False):\n\t\tsuper(GraphicsElements, self).__init__(content, evaluation)\n\t\tself.neg_y = neg_y\n\t\tself.xmin = self.ymin = self.pixel_width = None\n\t\tself.pixel_height = self.extent_width = self.extent_height = None\n\t\tself.view_width = None\n\t\tself.content = content\n\n\tdef translate(self, coords):\n\t\tif self.pixel_width is not None:\n\t\t\tw = self.extent_width if self.extent_width > 0 else 1\n\t\t\th = self.extent_height if self.extent_height > 0 else 1\n\t\t\tresult = [\n\t\t\t\t(coords[0] - self.xmin) * self.pixel_width / w,\n\t\t\t\t(coords[1] - self.ymin) * self.pixel_height / h,\n\t\t\t]\n\t\t\tif self.neg_y:\n\t\t\t\tresult[1] = self.pixel_height - result[1]\n\t\t\treturn tuple(result)\n\t\telse:\n\t\t\treturn (coords[0], coords[1])\n\n\tdef translate_absolute(self, d):\n\t\tif self.pixel_width is None:\n\t\t\treturn (0, 0)\n\t\telse:\n\t\t\tl = 96.0 / 72\n\t\t\treturn (d[0] * l, (-1 if self.neg_y else 1) * d[1] * l)\n\n\tdef translate_relative(self, x):\n\t\tif self.pixel_width is None:\n\t\t\treturn 0\n\t\telse:\n\t\t\treturn x * self.pixel_width\n\n\tdef extent(self, completely_visible_only=False):\n\t\tif completely_visible_only:\n\t\t\text = total_extent(\n\t\t\t\t[\n\t\t\t\t\telement.extent()\n\t\t\t\t\tfor element in self.elements\n\t\t\t\t\tif element.is_completely_visible\n\t\t\t\t]\n\t\t\t)\n\t\telse:\n\t\t\text = total_extent([element.extent() for element in self.elements])\n\t\txmin, xmax, ymin, ymax = ext\n\t\tif xmin == xmax:\n\t\t\tif xmin is None:\n\t\t\t\treturn 0, 0, 0, 0\n\t\t\txmin = 0\n\t\t\txmax *= 2\n\t\tif ymin == ymax:\n\t\t\tif ymin is None:\n\t\t\t\treturn 0, 0, 0, 0\n\t\t\tymin = 0\n\t\t\tymax *= 2\n\t\treturn xmin, xmax, ymin, ymax\n\n\tdef set_size(\n\t\tself, xmin, ymin, extent_width, extent_height, pixel_width, pixel_height\n\t):\n\n\t\tself.xmin, self.ymin = xmin, ymin\n\t\tself.extent_width, self.extent_height = extent_width, extent_height\n\t\tself.pixel_width, self.pixel_height = pixel_width, pixel_height\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Directive", "data": "class Directive(Builtin):\n\tattributes = (\"ReadProtected\",)\n\n", "description": null, "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Tiny", "data": "class Tiny(Builtin):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Small", "data": "class Small(Builtin):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Medium", "data": "class Medium(Builtin):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}, {"term": "class", "name": "Large", "data": "class Large(Builtin):\n\t\"\"\"\n", "description": "\n", "category": "graphics", "imports": ["from math import sqrt", "from mathics.version import __version__  # noqa used in loading to check consistency.", "from mathics.builtin.base import (", "from mathics.builtin.drawing.graphics_internals import (", "from mathics.builtin.colors.color_directives import (", "from mathics.builtin.options import options_to_rules", "from mathics.core.expression import (", "from mathics.core.formatter import lookup_method", "from mathics.format.asy_fns import asy_bezier", "\t\tfrom mathics.builtin.box.graphics import GraphicsBox", "\t\tfrom mathics.builtin.box.graphics3d import Graphics3DBox", "\t\tfrom mathics.builtin.drawing.graphics3d import Graphics3D"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\t# game times\n\tlifes = NUM_LIVES\n\t# brick hits\n\thits = 0\n\t# which parts of code should write in the User side?\n\t# Add the animation loop here!\n\twhile lifes > 0 and hits < graphics.brick_count:\n\t\tpause(FRAME_RATE)\n\t\tif graphics.game_start:\n\t\t\t# while the ball in the window\n\t\t\twhile graphics.ball.y < graphics.window.height - graphics.ball.height:\n\t\t\t\tin_x = 0 < graphics.ball.x < (graphics.window.width - graphics.ball.width)\n\t\t\t\tin_y = 0 < graphics.ball.y\n\t\t\t\tif not in_x:\n\t\t\t\t\tgraphics.set_vx()\n\t\t\t\tif not in_y:\n\t\t\t\t\tgraphics.set_vy()\n\t\t\t\tgraphics.ball.move(graphics.get_vx(), graphics.get_vy())\n\t\t\t\tpause(FRAME_RATE)\n\t\t\t\t# check touch\n\t\t\t\tfor i in [graphics.ball.x, graphics.ball.x + graphics.ball.width]:\n\t\t\t\t\tfor j in [graphics.ball.y, graphics.ball.y + graphics.ball.height]:\n\t\t\t\t\t\tif graphics.window.get_object_at(i, j) is not None:\n\t\t\t\t\t\t\tgraphics.set_vy()\n\t\t\t\t\t\t\tif graphics.window.get_object_at(i, j) is not graphics.paddle:\n\t\t\t\t\t\t\t\tgraphics.window.remove(graphics.window.get_object_at(i, j))\n\t\t\t\t\t\t\t\thits += 1\n\t\t\t\t\t\t\t\tprint(\"brick\", hits)\n\n\t\t\t\t\t\t\telif graphics.window.get_object_at(i, j) is graphics.paddle:\n\t\t\t\t\t\t\t\tprint(\"paddle\")\n\t\t\t\t\t\t\tgraphics.ball.move(graphics.get_vx(), graphics.get_vy())\n\t\t\t\t\t\t\tbreak\n\n\t\t\t# lose 1 life\n\t\t\tlifes -= 1\n\t\t\tgraphics.ball.x = graphics.window.width/2 - graphics.ball.width/2\n\t\t\tgraphics.ball.y = graphics.window.height/2 - graphics.ball.height/2\n\n\t\t\tgraphics.game_start = False\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}, {"term": "def", "name": "check_if_touch", "data": "def check_if_touch(graphics):\n\tfor i in [graphics.ball.x, graphics.ball.x + graphics.ball.width]:\n\t\tfor j in [graphics.ball.y, graphics.ball.y + graphics.ball.height]:\n\t\t\tif graphics.window.get_object_at(i, j) is not None:\n\t\t\t\tif graphics.window.get_object_at(i, j) is not graphics.paddle:\n\t\t\t\t\treturn 'brick'\n\n\t\t\t\telse:\n\t\t\t\t\treturn 'paddle'\n\t\t\t\t\tgraphics.set_vy()\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tlives = NUM_LIVES\n\n\tlife = GLabel(f'LIVES: {lives}')\n\tlife.font = 'SansSerif-20'\n\tgraphics.window.add(life, graphics.ball.height, graphics.window.height)\n\tbrick_num = graphics.brick_num\n\n\twhile True:\n\n\t\tif (lives > 0) and (brick_num > 0):\n\n\t\t\t# reset ball to the center of window\n\t\t\twindow_x_center = (graphics.window.width - graphics.ball.width)/2\n\t\t\twindow_y_center = (graphics.window.height - graphics.ball.height)/2\n\n\t\t\t# reset variables in the being of each life\n\t\t\tgraphics.window.add(graphics.ball, window_x_center, window_y_center)\n\t\t\tprint('lives = ', lives)\n\t\t\tgraphics.game_starter = 0\n\t\t\tdx = 0\n\t\t\tdy = 0\n\n\t\t\twhile True:\n\n\t\t\t\tpause(FRAME_RATE)\n\t\t\t\tif brick_num == 0:\n\t\t\t\t\tbreak\n\n\t\t\t\tif graphics.game_starter == 1:  # reset dx, dy when the first click\n\t\t\t\t\tdx = graphics.dx\n\t\t\t\t\tdy = graphics.dy\n\t\t\t\t\tgraphics.game_starter += 1\n\n\t\t\t\tgraphics.ball.move(dx, dy)\n\t\t\t\tprint('dx, dy = ', dx, dy)\n\n\t\t\t\tx = int(graphics.ball.x)\n\t\t\t\ty = int(graphics.ball.y)\n\t\t\t\tx_rr = int(graphics.ball.x + graphics.ball.width)\n\t\t\t\ty_rr = int(graphics.ball.y + graphics.ball.height)\n\n\t\t\t\ttop_border = 0\n\t\t\t\tbottom_border = graphics.window.height - graphics.ball.height/2\n\t\t\t\tright_border = 0\n\t\t\t\tleft_border = graphics.window.width - graphics.ball.width/2\n\n\t\t\t\tx_bounce = False\n\t\t\t\ty_bounce = False\n\n\t\t\t\t#  bouncing\n\t\t\t\tif x <= right_border or x >= left_border:\n\t\t\t\t\tx_bounce = True\n\t\t\t\tif y <= top_border:\n\t\t\t\t\ty_bounce = True\n\t\t\t\telif y >= bottom_border:\n\t\t\t\t\tlives -= 1\n\t\t\t\t\tlife.text = f'LIVES: {lives}'\n\t\t\t\t\tpause(FRAME_RATE*100)\n\t\t\t\t\tbreak\n\n\t\t\t\tnone_count = 0\n\t\t\t\tnot_none_count = 0\n\t\t\t\tcollide_at_x = 0\n\t\t\t\tcollide_at_y = 0\n\n\t\t\t\tfor i in range(x, x_rr+1, graphics.ball.width):\n\t\t\t\t\tfor j in range(y, y_rr+1, graphics.ball.height):\n\n\t\t\t\t\t\tmaybe_obj = graphics.window.get_object_at(i, j)\n\n\t\t\t\t\t\tif maybe_obj is not None:\n\t\t\t\t\t\t\tnot_none_count += 1\n\t\t\t\t\t\t\tcollide_at_x = i\n\t\t\t\t\t\t\tcollide_at_y = j\n\n\t\t\t\tif not_none_count > 0:\n\t\t\t\t\tcollide_obj = graphics.window.get_object_at(collide_at_x, collide_at_y)\n\n\t\t\t\t\tif collide_obj == graphics.paddle:\n\t\t\t\t\t\tif dy > 0:\n\t\t\t\t\t\t\ty_bounce = True\n\t\t\t\t\telif collide_obj is not life:\n\t\t\t\t\t\tgraphics.window.remove(collide_obj)\n\t\t\t\t\t\tbrick_num -= 1\n\t\t\t\t\t\ty_bounce = True\n\n\t\t\t\tif x_bounce is True:\n\t\t\t\t\tdx = -dx\n\t\t\t\tif y_bounce is True:\n\t\t\t\t\tdy = -dy\n\n\t\tif lives == 0:\n\t\t\tlose = GLabel(f'YOU  LOSE!!!!')\n\t\t\tlose.font = 'SansSerif-50'\n\t\t\tlose_w = lose.width\n\t\t\tlose.color = 'red'\n\t\t\tgraphics.window.add(lose, (graphics.window.width - lose_w)/2 , graphics.window.height/2)\n\t\t\tbreak\n\n\t\telif brick_num == 0:\n\t\t\twin = GLabel(f'YOU  WIN')\n\t\t\twin.font = 'SansSerif-50'\n\t\t\twin_w = win.width\n\t\t\twin.color = 'gold'\n\t\t\tgraphics.window.add(win, (graphics.window.width - win_w) / 2, graphics.window.height / 2)\n\t\t\tbreak\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.graphics.gobjects import GLabel"]}], [{"term": "class", "name": "from.baseclassimportvmmGObjectUI", "data": "from .baseclass import vmmGObjectUI\n\n", "description": null, "category": "graphics", "imports": ["from gi.repository import Gtk", "from gi.repository import GObject", "import virtinst", "from . import uiutil", "from .baseclass import vmmGObjectUI"]}, {"term": "class", "name": "vmmGraphicsDetails", "data": "class vmmGraphicsDetails(vmmGObjectUI):\n\t__gsignals__ = {\n\t\t\"changed-password\": (GObject.SignalFlags.RUN_FIRST, None, []),\n\t\t\"changed-port\": (GObject.SignalFlags.RUN_FIRST, None, []),\n\t\t\"changed-tlsport\": (GObject.SignalFlags.RUN_FIRST, None, []),\n\t\t\"changed-type\": (GObject.SignalFlags.RUN_FIRST, None, []),\n\t\t\"changed-address\": (GObject.SignalFlags.RUN_FIRST, None, []),\n\t\t\"changed-keymap\": (GObject.SignalFlags.RUN_FIRST, None, []),\n\t}\n\n\tdef __init__(self, vm, builder, topwin):\n\t\tvmmGObjectUI.__init__(self, \"gfxdetails.ui\",\n\t\t\t\t\t\t\t  None, builder=builder, topwin=topwin)\n\t\tself.vm = vm\n\t\tself.conn = vm.conn\n\n\t\tself.builder.connect_signals({\n\t\t\t\"on_graphics_type_changed\": self._change_graphics_type,\n\t\t\t\"on_graphics_port_auto_toggled\": self._change_port_auto,\n\t\t\t\"on_graphics_tlsport_auto_toggled\": self._change_tlsport_auto,\n\t\t\t\"on_graphics_use_password\": self._change_password_chk,\n\n\t\t\t\"on_graphics_password_changed\": lambda ignore: self.emit(\"changed-password\"),\n\t\t\t\"on_graphics_address_changed\": lambda ignore: self.emit(\"changed-address\"),\n\t\t\t\"on_graphics_tlsport_changed\": lambda ignore: self.emit(\"changed-tlsport\"),\n\t\t\t\"on_graphics_port_changed\": lambda ignore: self.emit(\"changed-port\"),\n\t\t\t\"on_graphics_keymap_changed\": lambda ignore: self.emit(\"changed-keymap\"),\n\t\t})\n\n\t\tself._init_ui()\n\t\tself.top_box = self.widget(\"graphics-box\")\n\n\tdef _cleanup(self):\n\t\tself.vm = None\n\t\tself.conn = None\n\n\t##########################\n\t# Initialization methods #\n\t##########################\n\n\tdef _init_ui(self):\n\t\tgraphics_list = self.widget(\"graphics-type\")\n\t\tgraphics_model = Gtk.ListStore(str, str)\n\t\tgraphics_list.set_model(graphics_model)\n\t\tuiutil.set_combo_text_column(graphics_list, 1)\n\t\tgraphics_model.clear()\n\t\tgraphics_model.append([\"spice\", _(\"Spice server\")])\n\t\tgraphics_model.append([\"vnc\", _(\"VNC server\")])\n\n\t\tself.widget(\"graphics-address\").set_model(Gtk.ListStore(str, str))\n\t\tuiutil.set_combo_text_column(self.widget(\"graphics-address\"), 1)\n\n\t\tmodel = self.widget(\"graphics-address\").get_model()\n\t\tmodel.clear()\n\t\tmodel.append([None, _(\"Hypervisor default\")])\n\t\tmodel.append([\"127.0.0.1\", _(\"Localhost only\")])\n\t\tmodel.append([\"0.0.0.0\", _(\"All interfaces\")])\n\n\t\t# Keymap\n\t\tcombo = self.widget(\"graphics-keymap\")\n\t\tmodel = Gtk.ListStore(str, str)\n\t\tcombo.set_model(model)\n\t\tuiutil.set_combo_text_column(combo, 1)\n\n\t\tmodel.append([\"auto\", \"Auto\"])\n\t\tmodel.append([virtinst.VirtualGraphics.KEYMAP_LOCAL,\n\t\t\t\t\t  \"Copy local keymap\"])\n\t\tfor k in virtinst.VirtualGraphics.valid_keymaps():\n\t\t\tmodel.append([k, k])\n\n\tdef _get_config_graphics_ports(self):\n\t\tport = uiutil.spin_get_helper(self.widget(\"graphics-port\"))\n\t\ttlsport = uiutil.spin_get_helper(self.widget(\"graphics-tlsport\"))\n\t\tgtype = uiutil.get_list_selection(self.widget(\"graphics-type\"), 0)\n\n\t\tif self.widget(\"graphics-port-auto\").get_active():\n\t\t\tport = -1\n\t\tif self.widget(\"graphics-tlsport-auto\").get_active():\n\t\t\ttlsport = -1\n\n\t\tif gtype != \"spice\":\n\t\t\ttlsport = None\n\t\treturn port, tlsport\n\n\n\t##############\n\t# Public API #\n\t##############\n\n\tdef reset_state(self):\n\t\tuiutil.set_grid_row_visible(self.widget(\"graphics-display\"), False)\n\t\tuiutil.set_grid_row_visible(self.widget(\"graphics-xauth\"), False)\n\n\t\tself.widget(\"graphics-type\").set_active(0)\n\t\tself.widget(\"graphics-address\").set_active(0)\n\t\tself.widget(\"graphics-keymap\").set_active(0)\n\n\t\tself._change_ports()\n\t\tself.widget(\"graphics-port-auto\").set_active(True)\n\t\tself.widget(\"graphics-tlsport-auto\").set_active(True)\n\t\tself.widget(\"graphics-password\").set_text(\"\")\n\t\tself.widget(\"graphics-password\").set_sensitive(False)\n\t\tself.widget(\"graphics-password-chk\").set_active(False)\n\n\tdef get_values(self):\n\t\tgtype = uiutil.get_list_selection(self.widget(\"graphics-type\"), 0)\n\t\tport, tlsport = self._get_config_graphics_ports()\n\t\taddr = uiutil.get_list_selection(self.widget(\"graphics-address\"), 0)\n\t\tkeymap = uiutil.get_combo_entry(self.widget(\"graphics-keymap\"))\n\t\tif keymap == \"auto\":\n\t\t\tkeymap = None\n\n\t\tpasswd = self.widget(\"graphics-password\").get_text()\n\t\tif not self.widget(\"graphics-password-chk\").get_active():\n\t\t\tpasswd = None\n\n\t\treturn gtype, port, tlsport, addr, passwd, keymap\n\n\tdef set_dev(self, gfx):\n\t\tself.reset_state()\n\n\t\tdef set_port(basename, val):\n\t\t\tauto = self.widget(basename + \"-auto\")\n\t\t\twidget = self.widget(basename)\n\t\t\tauto.set_inconsistent(False)\n\t\t\tlabel = auto.get_label().split(\" (\")[0]\n\n\t\t\tif val == -1 or gfx.autoport:\n\t\t\t\tauto.set_active(True)\n\t\t\t\tif val and val != -1:\n\t\t\t\t\tlabel += \" (%s %s)\" % (_(\"Port\"), val)\n\t\t\telif val is None:\n\t\t\t\tauto.set_inconsistent(True)\n\t\t\telse:\n\t\t\t\tauto.set_active(False)\n\t\t\t\twidget.set_value(val)\n\n\t\t\tauto.set_label(label)\n\n\t\tgtype = gfx.type\n\t\tis_vnc = (gtype == \"vnc\")\n\t\tis_sdl = (gtype == \"sdl\")\n\t\tis_spice = (gtype == \"spice\")\n\t\ttitle = (_(\"%(graphicstype)s Server\") %\n\t\t\t\t  {\"graphicstype\" : gfx.pretty_type_simple(gtype)})\n\n\t\tif is_vnc or is_spice:\n\t\t\tuse_passwd = gfx.passwd is not None\n\n\t\t\tset_port(\"graphics-port\", gfx.port)\n\t\t\tuiutil.set_combo_entry(\n\t\t\t\tself.widget(\"graphics-address\"), gfx.listen, 0)\n\t\t\tuiutil.set_combo_entry(\n\t\t\t\tself.widget(\"graphics-keymap\"), gfx.keymap or None, 0)\n\n\t\t\tself.widget(\"graphics-password\").set_text(gfx.passwd or \"\")\n\t\t\tself.widget(\"graphics-password-chk\").set_active(use_passwd)\n\t\t\tself.widget(\"graphics-password\").set_sensitive(use_passwd)\n\n\t\tif is_spice:\n\t\t\tset_port(\"graphics-tlsport\", gfx.tlsPort)\n\n\t\tif is_sdl:\n\t\t\ttitle = _(\"Local SDL Window\")\n\n\t\t\tself.widget(\"graphics-display\").set_text(\n\t\t\t\tgfx.display or _(\"Unknown\"))\n\t\t\tself.widget(\"graphics-xauth\").set_text(\n\t\t\t\tgfx.xauth or _(\"Unknown\"))\n\n\t\tuiutil.set_combo_entry(self.widget(\"graphics-type\"), gtype, 0)\n\t\treturn title\n\n\n\t#############\n\t# Listeners #\n\t#############\n\n\tdef _show_rows_from_type(self):\n\t\thide_all = [\"graphics-xauth\", \"graphics-display\", \"graphics-address\",\n\t\t\t\"graphics-password-box\", \"graphics-keymap\", \"graphics-port-box\",\n\t\t\t\"graphics-tlsport-box\"]\n\n\t\tgtype = uiutil.get_list_selection(self.widget(\"graphics-type\"), 0)\n\t\tsdl_rows = [\"graphics-xauth\", \"graphics-display\"]\n\t\tvnc_rows = [\"graphics-password-box\", \"graphics-address\",\n\t\t\t\"graphics-port-box\", \"graphics-keymap\"]\n\t\tspice_rows = vnc_rows[:] + [\"graphics-tlsport-box\"]\n\n\t\trows = []\n\t\tif gtype == \"sdl\":\n\t\t\trows = sdl_rows\n\t\telif gtype == \"vnc\":\n\t\t\trows = vnc_rows\n\t\telif gtype == \"spice\":\n\t\t\trows = spice_rows\n\n\t\tfor row in hide_all:\n\t\t\tuiutil.set_grid_row_visible(self.widget(row), row in rows)\n\n\tdef _change_graphics_type(self, ignore):\n\t\tself._show_rows_from_type()\n\t\tself.emit(\"changed-type\")\n\n\tdef _change_port_auto(self, ignore):\n\t\tself.widget(\"graphics-port-auto\").set_inconsistent(False)\n\t\tself._change_ports()\n\t\tself.emit(\"changed-port\")\n\n\tdef _change_tlsport_auto(self, ignore):\n\t\tself.widget(\"graphics-tlsport-auto\").set_inconsistent(False)\n\t\tself._change_ports()\n\t\tself.emit(\"changed-tlsport\")\n\n\tdef _change_ports(self):\n\t\tis_auto = (self.widget(\"graphics-port-auto\").get_active() or\n\t\t\tself.widget(\"graphics-port-auto\").get_inconsistent())\n\t\tis_tlsauto = (self.widget(\"graphics-tlsport-auto\").get_active() or\n\t\t\tself.widget(\"graphics-tlsport-auto\").get_inconsistent())\n\n\t\tself.widget(\"graphics-port\").set_visible(not is_auto)\n\t\tself.widget(\"graphics-tlsport\").set_visible(not is_tlsauto)\n\n\tdef _change_password_chk(self, ignore=None):\n\t\tif self.widget(\"graphics-password-chk\").get_active():\n\t\t\tself.widget(\"graphics-password\").set_sensitive(True)\n\t\telse:\n\t\t\tself.widget(\"graphics-password\").set_text(\"\")\n\t\t\tself.widget(\"graphics-password\").set_sensitive(False)\n\t\tself.emit(\"changed-password\")\n", "description": null, "category": "graphics", "imports": ["from gi.repository import Gtk", "from gi.repository import GObject", "import virtinst", "from . import uiutil", "from .baseclass import vmmGObjectUI"]}], [{"term": "def", "name": "PrepareFilesets", "data": "def PrepareFilesets():\n\tfor key, folders, condition in FILESET_DEFINITIONS:\n\t\t_AddFolderListAsKey(folders, key, condition=condition)\n\n\tdependencies_file = 'app:/resfiledependencies.yaml'\n\tif blue.paths.exists(dependencies_file):\n\t\tdep = blue.paths.GetFileContentsWithYield(dependencies_file)\n\t\tdep_dict = yaml.load(dep.Read(), Loader=yaml.CSafeLoader)\n\t\tFILE_DEPENDENCIES.update(dep_dict)\n\n", "description": null, "category": "graphics", "imports": ["import blue", "import remotefilecache", "import logging", "import yaml"]}, {"term": "def", "name": "AddFileset", "data": "def AddFileset(key, fileset):\n\tif key in filesets:\n\t\traise IndexError(\"'%s' is already defined\" % key)\n\tfileset_as_list = list(fileset)\n\tfor each in fileset_as_list:\n\t\tdependencies = FILE_DEPENDENCIES.get(each, [])\n\t\tfor dep in dependencies:\n\t\t\tfileset.add(dep)\n\n\tfilesets[key] = list(fileset)\n\n", "description": null, "category": "graphics", "imports": ["import blue", "import remotefilecache", "import logging", "import yaml"]}, {"term": "def", "name": "KeyExists", "data": "def KeyExists(key):\n\treturn key in filesets\n\n", "description": null, "category": "graphics", "imports": ["import blue", "import remotefilecache", "import logging", "import yaml"]}, {"term": "def", "name": "Schedule", "data": "def Schedule(key):\n\ttry:\n\t\tremotefilecache.schedule(key, filesets[key])\n\texcept KeyError:\n\t\tlog.warning('Schedule: unknown key %s' % key)\n\n", "description": null, "category": "graphics", "imports": ["import blue", "import remotefilecache", "import logging", "import yaml"]}, {"term": "def", "name": "ScheduleFront", "data": "def ScheduleFront(key):\n\ttry:\n\t\tremotefilecache.schedule(key, filesets[key])\n\t\tremotefilecache.pull_to_front(key)\n\texcept KeyError:\n\t\tlog.warning('ScheduleFront: unknown key %s' % key)\n\n", "description": null, "category": "graphics", "imports": ["import blue", "import remotefilecache", "import logging", "import yaml"]}, {"term": "def", "name": "PullToFront", "data": "def PullToFront(key):\n\tremotefilecache.pull_to_front(key)\n\n", "description": null, "category": "graphics", "imports": ["import blue", "import remotefilecache", "import logging", "import yaml"]}, {"term": "def", "name": "PushToBack", "data": "def PushToBack(key):\n\tremotefilecache.push_to_back(key)\n\n", "description": null, "category": "graphics", "imports": ["import blue", "import remotefilecache", "import logging", "import yaml"]}, {"term": "def", "name": "_AddFolderListAsKey", "data": "def _AddFolderListAsKey(folderList, key, condition = None):\n\tif condition == None:\n\t\tcondition = lambda x: True\n\tfile_set = set()\n\tfor folder in folderList:\n\t\tremotefilecache.gather_files_conditionally_to_prefetch(folder, condition, file_set, FILE_DEPENDENCIES)\n\n\tfilesets[key] = list(file_set)\n", "description": null, "category": "graphics", "imports": ["import blue", "import remotefilecache", "import logging", "import yaml"]}], [{"term": "def", "name": "PrepareFilesets", "data": "def PrepareFilesets():\n\tfor key, folders, condition in FILESET_DEFINITIONS:\n\t\t_AddFolderListAsKey(folders, key, condition=condition)\n\n\tdependencies_file = 'app:/resfiledependencies.yaml'\n\tif blue.paths.exists(dependencies_file):\n\t\tdep = blue.paths.GetFileContentsWithYield(dependencies_file)\n\t\tdep_dict = yaml.load(dep.Read(), Loader=yaml.CSafeLoader)\n\t\tFILE_DEPENDENCIES.update(dep_dict)\n\n", "description": null, "category": "graphics", "imports": ["import blue", "import remotefilecache", "import logging", "import yaml"]}, {"term": "def", "name": "AddFileset", "data": "def AddFileset(key, fileset):\n\tif key in filesets:\n\t\traise IndexError(\"'%s' is already defined\" % key)\n\tfileset_as_list = list(fileset)\n\tfor each in fileset_as_list:\n\t\tdependencies = FILE_DEPENDENCIES.get(each, [])\n\t\tfor dep in dependencies:\n\t\t\tfileset.add(dep)\n\n\tfilesets[key] = list(fileset)\n\n", "description": null, "category": "graphics", "imports": ["import blue", "import remotefilecache", "import logging", "import yaml"]}, {"term": "def", "name": "KeyExists", "data": "def KeyExists(key):\n\treturn key in filesets\n\n", "description": null, "category": "graphics", "imports": ["import blue", "import remotefilecache", "import logging", "import yaml"]}, {"term": "def", "name": "Schedule", "data": "def Schedule(key):\n\ttry:\n\t\tremotefilecache.schedule(key, filesets[key])\n\texcept KeyError:\n\t\tlog.warning('Schedule: unknown key %s' % key)\n\n", "description": null, "category": "graphics", "imports": ["import blue", "import remotefilecache", "import logging", "import yaml"]}, {"term": "def", "name": "ScheduleFront", "data": "def ScheduleFront(key):\n\ttry:\n\t\tremotefilecache.schedule(key, filesets[key])\n\t\tremotefilecache.pull_to_front(key)\n\texcept KeyError:\n\t\tlog.warning('ScheduleFront: unknown key %s' % key)\n\n", "description": null, "category": "graphics", "imports": ["import blue", "import remotefilecache", "import logging", "import yaml"]}, {"term": "def", "name": "PullToFront", "data": "def PullToFront(key):\n\tremotefilecache.pull_to_front(key)\n\n", "description": null, "category": "graphics", "imports": ["import blue", "import remotefilecache", "import logging", "import yaml"]}, {"term": "def", "name": "PushToBack", "data": "def PushToBack(key):\n\tremotefilecache.push_to_back(key)\n\n", "description": null, "category": "graphics", "imports": ["import blue", "import remotefilecache", "import logging", "import yaml"]}, {"term": "def", "name": "_AddFolderListAsKey", "data": "def _AddFolderListAsKey(folderList, key, condition = None):\n\tif condition == None:\n\t\tcondition = lambda x: True\n\tfile_set = set()\n\tfor folder in folderList:\n\t\tremotefilecache.gather_files_conditionally_to_prefetch(folder, condition, file_set, FILE_DEPENDENCIES)\n\n\tfilesets[key] = list(file_set)\n", "description": null, "category": "graphics", "imports": ["import blue", "import remotefilecache", "import logging", "import yaml"]}], [], [{"term": "def", "name": "setConfigOption", "data": "def setConfigOption(opt, value):\n\tglobal CONFIG_OPTIONS\n\tif opt not in CONFIG_OPTIONS:\n\t\traise KeyError('Unknown configuration option \"%s\"' % opt)\n\tif opt == 'imageAxisOrder' and value not in ('row-major', 'col-major'):\n\t\traise ValueError('imageAxisOrder must be either \"row-major\" or \"col-major\"')\n\tCONFIG_OPTIONS[opt] = value\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "setConfigOptions", "data": "def setConfigOptions(**opts):\n\t\"\"\"Set global configuration options. \n\t\n\tEach keyword argument sets one global option. \n\t\"\"\"\n\tfor k,v in opts.items():\n\t\tsetConfigOption(k, v)\n", "description": "Set global configuration options. \n\t\n\tEach keyword argument sets one global option. \n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "getConfigOption", "data": "def getConfigOption(opt):\n\t\"\"\"Return the value of a single global configuration option.\n\t\"\"\"\n\treturn CONFIG_OPTIONS[opt]\n\n", "description": "Return the value of a single global configuration option.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "systemInfo", "data": "def systemInfo():\n\tprint(\"sys.platform: %s\" % sys.platform)\n\tprint(\"sys.version: %s\" % sys.version)\n\tfrom .Qt import VERSION_INFO\n\tprint(\"qt bindings: %s\" % VERSION_INFO)\n\t\n\tglobal __version__\n\trev = None\n\tif __version__ is None:  ## this code was probably checked out from bzr; look up the last-revision file\n\t\tlastRevFile = os.path.join(os.path.dirname(__file__), '..', '.bzr', 'branch', 'last-revision')\n\t\tif os.path.exists(lastRevFile):\n\t\t\trev = open(lastRevFile, 'r').read().strip()\n\t\n\tprint(\"pyqtgraph: %s; %s\" % (__version__, rev))\n\tprint(\"config:\")\n\timport pprint\n\tpprint.pprint(CONFIG_OPTIONS)\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "renamePyc", "data": "def renamePyc(startDir):\n\t### Used to rename orphaned .pyc files\n\t### When a python file changes its location in the repository, usually the .pyc file\n\t### is left behind, possibly causing mysterious and difficult to track bugs. \n\n\t### Note that this is no longer necessary for python 3.2; from PEP 3147:\n\t### \"If the py source file is missing, the pyc file inside __pycache__ will be ignored. \n\t### This eliminates the problem of accidental stale pyc file imports.\"\n\t\n\tprinted = False\n\tstartDir = os.path.abspath(startDir)\n\tfor path, dirs, files in os.walk(startDir):\n\t\tif '__pycache__' in path:\n\t\t\tcontinue\n\t\tfor f in files:\n\t\t\tfileName = os.path.join(path, f)\n\t\t\tbase, ext = os.path.splitext(fileName)\n\t\t\tpy = base + \".py\"\n\t\t\tif ext == '.pyc' and not os.path.isfile(py):\n\t\t\t\tif not printed:\n\t\t\t\t\tprint(\"NOTE: Renaming orphaned .pyc files:\")\n\t\t\t\t\tprinted = True\n\t\t\t\tn = 1\n\t\t\t\twhile True:\n\t\t\t\t\tname2 = fileName + \".renamed%d\" % n\n\t\t\t\t\tif not os.path.exists(name2):\n\t\t\t\t\t\tbreak\n\t\t\t\t\tn += 1\n\t\t\t\tprint(\"  \" + fileName + \"  ==>\")\n\t\t\t\tprint(\"  \" + name2)\n\t\t\t\tos.rename(fileName, name2)\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "fimportModules", "data": "#def importModules(path, globals, locals, excludes=()):\n\t#\"\"\"Import all modules residing within *path*, return a dict of name: module pairs.\n\t\n\t#Note that *path* MUST be relative to the module doing the import.\t\n\t#\"\"\"\n\t#d = os.path.join(os.path.split(globals['__file__'])[0], path)\n\t#files = set()\n\t#for f in frozenSupport.listdir(d):\n\t\t#if frozenSupport.isdir(os.path.join(d, f)) and f not in ['__pycache__', 'tests']:\n\t\t\t#files.add(f)\n\t\t#elif f[-3:] == '.py' and f != '__init__.py':\n\t\t\t#files.add(f[:-3])\n\t\t#elif f[-4:] == '.pyc' and f != '__init__.pyc':\n\t\t\t#files.add(f[:-4])\n\t\t\n\t#mods = {}\n\t#path = path.replace(os.sep, '.')\n\t#for modName in files:\n\t\t#if modName in excludes:\n\t\t\t#continue\n\t\t#try:\n\t\t\t#if len(path) > 0:\n\t\t\t\t#modName = path + '.' + modName\n\t\t\t#print( \"from .%s import * \" % modName)\n\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\n\t\t\t#mods[modName] = mod\n\t\t#except:\n\t\t\t#import traceback\n\t\t\t#traceback.print_stack()\n\t\t\t#sys.excepthook(*sys.exc_info())\n\t\t\t#print(\"[Error importing module: %s]\" % modName)\n\t\t\t\n\t#return mods\n", "description": "Import all modules residing within *path*, return a dict of name: module pairs.\n\t\n\t#Note that *path* MUST be relative to the module doing the import.\t\n\t#", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "fimportAll", "data": "#def importAll(path, globals, locals, excludes=()):\n\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\n\t#mods = importModules(path, globals, locals, excludes)\n\t#for mod in mods.values():\n\t\t#if hasattr(mod, '__all__'):\n\t\t\t#names = mod.__all__\n\t\t#else:\n\t\t\t#names = [n for n in dir(mod) if n[0] != '_']\n\t\t#for k in names:\n\t\t\t#if hasattr(mod, k):\n\t\t\t\t#globals[k] = getattr(mod, k)\n", "description": "Given a list of modules, import all names from each module into the global namespace.", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "cleanup", "data": "def cleanup():\n\tglobal _cleanupCalled\n\tif _cleanupCalled:\n\t\treturn\n\t\n\tif not getConfigOption('exitCleanup'):\n\t\treturn\n\t\n\tViewBox.quit()  ## tell ViewBox that it doesn't need to deregister views anymore.\n\t\n\t## Workaround for Qt exit crash:\n\t## ALL QGraphicsItems must have a scene before they are deleted.\n\t## This is potentially very expensive, but preferred over crashing.\n\t## Note: this appears to be fixed in PySide as of 2012.12, but it should be left in for a while longer..\n\tapp = QtGui.QApplication.instance()\n\tif app is None or not isinstance(app, QtGui.QApplication):\n\t\t# app was never constructed is already deleted or is an\n\t\t# QCoreApplication/QGuiApplication and not a full QApplication\n\t\treturn\n\timport gc\n\ts = QtGui.QGraphicsScene()\n\tfor o in gc.get_objects():\n\t\ttry:\n\t\t\tif isinstance(o, QtGui.QGraphicsItem) and isQObjectAlive(o) and o.scene() is None:\n\t\t\t\tif getConfigOption('crashWarning'):\n\t\t\t\t\tsys.stderr.write('Error: graphics item without scene. '\n\t\t\t\t\t\t'Make sure ViewBox.close() and GraphicsView.close() '\n\t\t\t\t\t\t'are properly called before app shutdown (%s)\\n' % (o,))\n\t\t\t\t\n\t\t\t\ts.addItem(o)\n\t\texcept RuntimeError:  ## occurs if a python wrapper no longer has its underlying C++ object\n\t\t\tcontinue\n\t_cleanupCalled = True\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "_connectCleanup", "data": "def _connectCleanup():\n\tglobal _cleanupConnected\n\tif _cleanupConnected:\n\t\treturn\n\tQtGui.QApplication.instance().aboutToQuit.connect(cleanup)\n\t_cleanupConnected = True\n\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "exit", "data": "def exit():\n\t\"\"\"\n\tCauses python to exit without garbage-collecting any objects, and thus avoids\n\tcalling object destructor methods. This is a sledgehammer workaround for \n\ta variety of bugs in PyQt and Pyside that cause crashes on exit.\n\t\n\tThis function does the following in an attempt to 'safely' terminate\n\tthe process:\n\t\n\t* Invoke atexit callbacks\n\t* Close all open file handles\n\t* os._exit()\n\t\n\tNote: there is some potential for causing damage with this function if you\n\tare using objects that _require_ their destructors to be called (for example,\n\tto properly terminate log files, disconnect from devices, etc). Situations\n\tlike this are probably quite rare, but use at your own risk.\n\t\"\"\"\n\t\n\t## first disable our own cleanup function; won't be needing it.\n\tsetConfigOptions(exitCleanup=False)\n\t\n\t## invoke atexit callbacks\n\tatexit._run_exitfuncs()\n\t\n\t## close file handles\n\tif sys.platform == 'darwin':\n\t\tfor fd in range(3, 4096):\n\t\t\tif fd not in [7]:  # trying to close 7 produces an illegal instruction on the Mac.\n\t\t\t\tos.close(fd)\n\telse:\n\t\tos.closerange(3, 4096) ## just guessing on the maximum descriptor count..\n\n\tos._exit(0)\n\t\n\n", "description": "\n\tCauses python to exit without garbage-collecting any objects, and thus avoids\n\tcalling object destructor methods. This is a sledgehammer workaround for \n\ta variety of bugs in PyQt and Pyside that cause crashes on exit.\n\t\n\tThis function does the following in an attempt to 'safely' terminate\n\tthe process:\n\t\n\t* Invoke atexit callbacks\n\t* Close all open file handles\n\t* os._exit()\n\t\n\tNote: there is some potential for causing damage with this function if you\n\tare using objects that _require_ their destructors to be called (for example,\n\tto properly terminate log files, disconnect from devices, etc). Situations\n\tlike this are probably quite rare, but use at your own risk.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "plot", "data": "def plot(*args, **kargs):\n\t\"\"\"\n\tCreate and return a :class:`PlotWindow ` \n\t(this is just a window with :class:`PlotWidget ` inside), plot data in it.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to plot data. (see :func:`PlotItem.plot() `)\n\t\"\"\"\n\tmkQApp()\n\t#if 'title' in kargs:\n\t\t#w = PlotWindow(title=kargs['title'])\n\t\t#del kargs['title']\n\t#else:\n\t\t#w = PlotWindow()\n\t#if len(args)+len(kargs) > 0:\n\t\t#w.plot(*args, **kargs)\n\t\t\n\tpwArgList = ['title', 'labels', 'name', 'left', 'right', 'top', 'bottom', 'background']\n\tpwArgs = {}\n\tdataArgs = {}\n\tfor k in kargs:\n\t\tif k in pwArgList:\n\t\t\tpwArgs[k] = kargs[k]\n\t\telse:\n\t\t\tdataArgs[k] = kargs[k]\n\t\t\n\tw = PlotWindow(**pwArgs)\n\tif len(args) > 0 or len(dataArgs) > 0:\n\t\tw.plot(*args, **dataArgs)\n\tplots.append(w)\n\tw.show()\n\treturn w\n", "description": "\n\tCreate and return a :class:`PlotWindow ` \n\t(this is just a window with :class:`PlotWidget ` inside), plot data in it.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to plot data. (see :func:`PlotItem.plot() `)\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "image", "data": "def image(*args, **kargs):\n\t\"\"\"\n\tCreate and return an :class:`ImageWindow ` \n\t(this is just a window with :class:`ImageView ` widget inside), show image data inside.\n\tWill show 2D or 3D image data.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to show data. (see :func:`ImageView.setImage() `)\n\t\"\"\"\n\tmkQApp()\n\tw = ImageWindow(*args, **kargs)\n\timages.append(w)\n\tw.show()\n", "description": "\n\tCreate and return an :class:`ImageWindow ` \n\t(this is just a window with :class:`ImageView ` widget inside), show image data inside.\n\tWill show 2D or 3D image data.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to show data. (see :func:`ImageView.setImage() `)\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "dbg", "data": "def dbg(*args, **kwds):\n\t\"\"\"\n\tCreate a console window and begin watching for exceptions.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t\"\"\"\n\tmkQApp()\n\tfrom . import console\n\tc = console.ConsoleWidget(*args, **kwds)\n\tc.catchAllExceptions()\n\tc.show()\n\tglobal consoles\n\ttry:\n\t\tconsoles.append(c)\n\texcept NameError:\n\t\tconsoles = [c]\n\treturn c\n\t\n", "description": "\n\tCreate a console window and begin watching for exceptions.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "mkQApp", "data": "def mkQApp():\n\tglobal QAPP\n\tinst = QtGui.QApplication.instance()\n\tif inst is None:\n\t\tQAPP = QtGui.QApplication([])\n\telse:\n\t\tQAPP = inst\n\treturn QAPP\n\t\t\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}], [{"term": "class", "name": "_SettingsCore", "data": "class _SettingsCore(object):\n\tonSettingsChanged = Event.Event()\n\n\tdef init(self):\n\t\tfrom account_helpers.settings_core import options, settings_storages, settings_constants\n\t\tfrom gui.shared.utils import graphics\n\t\tGAME = settings_constants.GAME\n\t\tTUTORIAL = settings_constants.TUTORIAL\n\t\tGRAPHICS = settings_constants.GRAPHICS\n\t\tSOUND = settings_constants.SOUND\n\t\tCONTROLS = settings_constants.CONTROLS\n\t\tAIM = settings_constants.AIM\n\t\tMARKERS = settings_constants.MARKERS\n\t\tOTHER = settings_constants.OTHER\n\t\tself.__serverSettings = ServerSettingsManager(self)\n\t\tself.interfaceScale = InterfaceScaleManager(self)\n\t\tVIDEO_SETTINGS_STORAGE = settings_storages.VideoSettingsStorage(self.serverSettings, self)\n\t\tGAME_SETTINGS_STORAGE = settings_storages.GameSettingsStorage(self.serverSettings, self)\n\t\tEXTENDED_GAME_SETTINGS_STORAGE = settings_storages.ExtendedGameSettingsStorage(self.serverSettings, self)\n\t\tTUTORIAL_SETTINGS_STORAGE = settings_storages.TutorialStorage(self.serverSettings, self)\n\t\tGAMEPLAY_SETTINGS_STORAGE = settings_storages.GameplaySettingsStorage(self.serverSettings, self)\n\t\tGRAPHICS_SETTINGS_STORAGE = settings_storages.GraphicsSettingsStorage(self.serverSettings, self)\n\t\tSOUND_SETTINGS_STORAGE = settings_storages.SoundSettingsStorage(self.serverSettings, self)\n\t\tKEYBOARD_SETTINGS_STORAGE = settings_storages.KeyboardSettingsStorage(self.serverSettings, self)\n\t\tCONTROLS_SETTINGS_STORAGE = settings_storages.ControlsSettingsStorage(self.serverSettings, self)\n\t\tAIM_SETTINGS_STORAGE = settings_storages.AimSettingsStorage(self.serverSettings, self)\n\t\tMARKERS_SETTINGS_STORAGE = settings_storages.MarkersSettingsStorage(self.serverSettings, self)\n\t\tMARK_ON_GUN_SETTINGS_STORAGE = settings_storages.MarksOnGunSettingsStorage(self.serverSettings, self)\n\t\tFOV_SETTINGS_STORAGE = settings_storages.FOVSettingsStorage(self.serverSettings, self)\n\t\tMESSENGER_SETTINGS_STORAGE = settings_storages.MessengerSettingsStorage(GAME_SETTINGS_STORAGE)\n\t\tEXTENDED_MESSENGER_SETTINGS_STORAGE = settings_storages.MessengerSettingsStorage(EXTENDED_GAME_SETTINGS_STORAGE)\n\t\tself.__storages = {'game': GAME_SETTINGS_STORAGE,\n\t\t 'extendedGame': EXTENDED_GAME_SETTINGS_STORAGE,\n\t\t 'gameplay': GAMEPLAY_SETTINGS_STORAGE,\n\t\t 'sound': SOUND_SETTINGS_STORAGE,\n\t\t 'keyboard': KEYBOARD_SETTINGS_STORAGE,\n\t\t 'controls': CONTROLS_SETTINGS_STORAGE,\n\t\t 'aim': AIM_SETTINGS_STORAGE,\n\t\t 'markers': MARKERS_SETTINGS_STORAGE,\n\t\t 'graphics': GRAPHICS_SETTINGS_STORAGE,\n\t\t 'video': VIDEO_SETTINGS_STORAGE,\n\t\t 'messenger': MESSENGER_SETTINGS_STORAGE,\n\t\t 'extendedMessenger': EXTENDED_MESSENGER_SETTINGS_STORAGE,\n\t\t 'marksOnGun': MARK_ON_GUN_SETTINGS_STORAGE,\n\t\t 'FOV': FOV_SETTINGS_STORAGE,\n\t\t 'tutorial': TUTORIAL_SETTINGS_STORAGE}\n\t\tself.isDeviseRecreated = False\n\t\tself.isChangesConfirmed = True\n\t\tself.__options = options.SettingsContainer(((GAME.REPLAY_ENABLED, options.ReplaySetting(GAME.REPLAY_ENABLED, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.ENABLE_SERVER_AIM, options.StorageAccountSetting(GAME.ENABLE_SERVER_AIM, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.MINIMAP_ALPHA, options.StorageAccountSetting(GAME.MINIMAP_ALPHA, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.ENABLE_POSTMORTEM, options.PostProcessingSetting(GAME.ENABLE_POSTMORTEM, 'mortem_post_effect', storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.ENABLE_POSTMORTEM_DELAY, options.PostMortemDelaySetting(GAME.ENABLE_POSTMORTEM_DELAY, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.SHOW_VEHICLES_COUNTER, options.StorageAccountSetting(GAME.SHOW_VEHICLES_COUNTER, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.SHOW_BATTLE_EFFICIENCY_RIBBONS, options.ExcludeInReplayAccountSetting(GAME.SHOW_BATTLE_EFFICIENCY_RIBBONS, storage=EXTENDED_GAME_SETTINGS_STORAGE)),\n\t\t (GAME.SHOW_MARKS_ON_GUN, options.ShowMarksOnGunSetting(GAME.SHOW_MARKS_ON_GUN, storage=MARK_ON_GUN_SETTINGS_STORAGE)),\n\t\t (GAME.DYNAMIC_CAMERA, options.DynamicCamera(GAME.DYNAMIC_CAMERA, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.SNIPER_MODE_STABILIZATION, options.SniperModeStabilization(GAME.SNIPER_MODE_STABILIZATION, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.ENABLE_OL_FILTER, options.MessengerSetting(GAME.ENABLE_OL_FILTER, storage=MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.ENABLE_SPAM_FILTER, options.MessengerSetting(GAME.ENABLE_SPAM_FILTER, storage=MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.SHOW_DATE_MESSAGE, options.MessengerDateTimeSetting(1, storage=MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.SHOW_TIME_MESSAGE, options.MessengerDateTimeSetting(2, storage=MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.INVITES_FROM_FRIENDS, options.MessengerSetting(GAME.INVITES_FROM_FRIENDS, storage=MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.RECEIVE_FRIENDSHIP_REQUEST, options.MessengerSetting(GAME.RECEIVE_FRIENDSHIP_REQUEST, storage=MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.RECEIVE_INVITES_IN_BATTLE, options.MessengerSetting(GAME.RECEIVE_INVITES_IN_BATTLE, storage=EXTENDED_MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.STORE_RECEIVER_IN_BATTLE, options.MessengerSetting(GAME.STORE_RECEIVER_IN_BATTLE, storage=MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.DISABLE_BATTLE_CHAT, options.MessengerSetting(GAME.DISABLE_BATTLE_CHAT, storage=MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.CHAT_CONTACTS_LIST_ONLY, options.MessengerSetting(GAME.CHAT_CONTACTS_LIST_ONLY, storage=EXTENDED_MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.PLAYERS_PANELS_SHOW_LEVELS, options.PlayersPanelSetting(GAME.PLAYERS_PANELS_SHOW_LEVELS, 'players_panel', 'showLevels', storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.PLAYERS_PANELS_SHOW_TYPES, options.AccountDumpSetting(GAME.PLAYERS_PANELS_SHOW_TYPES, 'players_panel', 'showTypes')),\n\t\t (GAME.PLAYERS_PANELS_STATE, options.AccountDumpSetting(GAME.PLAYERS_PANELS_STATE, 'players_panel', 'state')),\n\t\t (GAME.SNIPER_MODE_SWINGING_ENABLED, options.SniperModeSwingingSetting()),\n\t\t (GAME.GAMEPLAY_CTF, options.GameplaySetting(GAME.GAMEPLAY_MASK, 'ctf', storage=GAMEPLAY_SETTINGS_STORAGE)),\n\t\t (GAME.GAMEPLAY_DOMINATION, options.GameplaySetting(GAME.GAMEPLAY_MASK, 'domination', storage=GAMEPLAY_SETTINGS_STORAGE)),\n\t\t (GAME.GAMEPLAY_ASSAULT, options.GameplaySetting(GAME.GAMEPLAY_MASK, 'assault', storage=GAMEPLAY_SETTINGS_STORAGE)),\n\t\t (GAME.GAMEPLAY_NATIONS, options.GameplaySetting(GAME.GAMEPLAY_MASK, 'nations', storage=GAMEPLAY_SETTINGS_STORAGE)),\n\t\t (GAME.LENS_EFFECT, options.LensEffectSetting(GAME.LENS_EFFECT, storage=GRAPHICS_SETTINGS_STORAGE)),\n\t\t (GAME.SHOW_VECTOR_ON_MAP, options.MinimapSetting(GAME.SHOW_VECTOR_ON_MAP, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.SHOW_SECTOR_ON_MAP, options.MinimapSetting(GAME.SHOW_SECTOR_ON_MAP, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.SHOW_VEH_MODELS_ON_MAP, options.MinimapVehModelsSetting(GAME.SHOW_VEH_MODELS_ON_MAP, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.MONITOR, options.MonitorSetting(storage=VIDEO_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.WINDOW_SIZE, options.WindowSizeSetting(storage=VIDEO_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.RESOLUTION, options.ResolutionSetting(storage=VIDEO_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.REFRESH_RATE, options.RefreshRateSetting(storage=VIDEO_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.FULLSCREEN, options.FullscreenSetting(storage=VIDEO_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.COLOR_BLIND, options.AccountDumpSetting(GRAPHICS.COLOR_BLIND, GRAPHICS.COLOR_BLIND)),\n\t\t (GRAPHICS.GRAPHICS_QUALITY_HD_SD, options.GraphicsQualityNote()),\n\t\t (GRAPHICS.GAMMA, options.GammaSetting()),\n\t\t (GRAPHICS.TRIPLE_BUFFERED, options.TripleBufferedSetting()),\n\t\t (GRAPHICS.VERTICAL_SYNC, options.VerticalSyncSetting()),\n\t\t (GRAPHICS.MULTISAMPLING, options.MultisamplingSetting()),\n\t\t (GRAPHICS.CUSTOM_AA, options.CustomAASetting()),\n\t\t (GRAPHICS.ASPECT_RATIO, options.AspectRatioSetting()),\n\t\t (GRAPHICS.FPS_PERFOMANCER, options.FPSPerfomancerSetting(GRAPHICS.FPS_PERFOMANCER, storage=GRAPHICS_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.DRR_AUTOSCALER_ENABLED, options.GraphicSetting(GRAPHICS.DRR_AUTOSCALER_ENABLED)),\n\t\t (GRAPHICS.DYNAMIC_RENDERER, options.DynamicRendererSetting()),\n\t\t (GRAPHICS.COLOR_FILTER_INTENSITY, options.ColorFilterIntensitySetting()),\n\t\t (GRAPHICS.COLOR_FILTER_IMAGES, options.ReadOnlySetting(lambda : graphics.getGraphicSettingImages(GRAPHICS.COLOR_GRADING_TECHNIQUE))),\n\t\t (GRAPHICS.FOV, options.FOVSetting(GRAPHICS.FOV, storage=FOV_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.DYNAMIC_FOV_ENABLED, options.DynamicFOVEnabledSetting(storage=FOV_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.PRESETS, options.GraphicsPresetSetting()),\n\t\t (GRAPHICS.RENDER_PIPELINE, options.GraphicSetting(GRAPHICS.RENDER_PIPELINE)),\n\t\t (GRAPHICS.TEXTURE_QUALITY, options.TextureQualitySetting()),\n\t\t (GRAPHICS.DECALS_QUALITY, options.GraphicSetting(GRAPHICS.DECALS_QUALITY)),\n\t\t (GRAPHICS.OBJECT_LOD, options.GraphicSetting(GRAPHICS.OBJECT_LOD)),\n\t\t (GRAPHICS.FAR_PLANE, options.GraphicSetting(GRAPHICS.FAR_PLANE)),\n\t\t (GRAPHICS.TERRAIN_QUALITY, options.TerrainQualitySetting()),\n\t\t (GRAPHICS.SHADOWS_QUALITY, options.GraphicSetting(GRAPHICS.SHADOWS_QUALITY)),\n\t\t (GRAPHICS.LIGHTING_QUALITY, options.GraphicSetting(GRAPHICS.LIGHTING_QUALITY)),\n\t\t (GRAPHICS.SPEEDTREE_QUALITY, options.GraphicSetting(GRAPHICS.SPEEDTREE_QUALITY)),\n\t\t (GRAPHICS.FLORA_QUALITY, options.FloraQualitySetting()),\n\t\t (GRAPHICS.WATER_QUALITY, options.GraphicSetting(GRAPHICS.WATER_QUALITY)),\n\t\t (GRAPHICS.EFFECTS_QUALITY, options.GraphicSetting(GRAPHICS.EFFECTS_QUALITY)),\n\t\t (GRAPHICS.POST_PROCESSING_QUALITY, options.GraphicSetting(GRAPHICS.POST_PROCESSING_QUALITY)),\n\t\t (GRAPHICS.MOTION_BLUR_QUALITY, options.GraphicSetting(GRAPHICS.MOTION_BLUR_QUALITY)),\n\t\t (GRAPHICS.SNIPER_MODE_EFFECTS_QUALITY, options.GraphicSetting(GRAPHICS.SNIPER_MODE_EFFECTS_QUALITY)),\n\t\t (GRAPHICS.VEHICLE_DUST_ENABLED, options.GraphicSetting(GRAPHICS.VEHICLE_DUST_ENABLED)),\n\t\t (GRAPHICS.SNIPER_MODE_GRASS_ENABLED, options.GraphicSetting(GRAPHICS.SNIPER_MODE_GRASS_ENABLED)),\n\t\t (GRAPHICS.VEHICLE_TRACES_ENABLED, options.GraphicSetting(GRAPHICS.VEHICLE_TRACES_ENABLED)),\n\t\t (GRAPHICS.COLOR_GRADING_TECHNIQUE, options.GraphicSetting(GRAPHICS.COLOR_GRADING_TECHNIQUE)),\n\t\t (GRAPHICS.SEMITRANSPARENT_LEAVES_ENABLED, options.GraphicSetting(GRAPHICS.SEMITRANSPARENT_LEAVES_ENABLED)),\n\t\t (GRAPHICS.GRAPHICS_SETTINGS_LIST, options.ReadOnlySetting(lambda : graphics.GRAPHICS_SETTINGS.ALL())),\n\t\t (GRAPHICS.INTERFACE_SCALE, options.InterfaceScaleSetting(GRAPHICS.INTERFACE_SCALE)),\n\t\t (SOUND.MASTER, options.SoundSetting('master')),\n\t\t (SOUND.MUSIC, options.SoundSetting('music')),\n\t\t (SOUND.VOICE, options.SoundSetting('voice')),\n\t\t (SOUND.VEHICLES, options.SoundSetting('vehicles')),\n\t\t (SOUND.EFFECTS, options.SoundSetting('effects')),\n\t\t (SOUND.GUI, options.SoundSetting('gui')),\n\t\t (SOUND.AMBIENT, options.SoundSetting('ambient')),\n\t\t (SOUND.NATIONS_VOICES, options.AccountSetting('nationalVoices')),\n\t\t (SOUND.VOIP_MASTER_FADE, options.SoundSetting('masterFadeVivox')),\n\t\t (SOUND.VOIP_ENABLE, options.VOIPSetting(True)),\n\t\t (SOUND.VOIP_MASTER, options.VOIPMasterSoundSetting()),\n\t\t (SOUND.VOIP_MIC, options.VOIPMicSoundSetting(True)),\n\t\t (SOUND.CAPTURE_DEVICES, options.VOIPCaptureDevicesSetting()),\n\t\t (SOUND.VOIP_SUPPORTED, options.VOIPSupportSetting()),\n\t\t (SOUND.ALT_VOICES, options.AltVoicesSetting(SOUND.ALT_VOICES, storage=SOUND_SETTINGS_STORAGE)),\n\t\t (CONTROLS.MOUSE_ARCADE_SENS, options.MouseSensitivitySetting('arcade')),\n\t\t (CONTROLS.MOUSE_SNIPER_SENS, options.MouseSensitivitySetting('sniper')),\n\t\t (CONTROLS.MOUSE_STRATEGIC_SENS, options.MouseSensitivitySetting('strategic')),\n\t\t (CONTROLS.MOUSE_HORZ_INVERSION, options.MouseInversionSetting(CONTROLS.MOUSE_HORZ_INVERSION, 'horzInvert', storage=CONTROLS_SETTINGS_STORAGE)),\n\t\t (CONTROLS.MOUSE_VERT_INVERSION, options.MouseInversionSetting(CONTROLS.MOUSE_VERT_INVERSION, 'vertInvert', storage=CONTROLS_SETTINGS_STORAGE)),\n\t\t (CONTROLS.BACK_DRAFT_INVERSION, options.BackDraftInversionSetting(storage=CONTROLS_SETTINGS_STORAGE)),\n\t\t (CONTROLS.KEYBOARD, options.KeyboardSettings(storage=KEYBOARD_SETTINGS_STORAGE)),\n\t\t (AIM.ARCADE, options.AimSetting('arcade', storage=AIM_SETTINGS_STORAGE)),\n\t\t (AIM.SNIPER, options.AimSetting('sniper', storage=AIM_SETTINGS_STORAGE)),\n\t\t (MARKERS.ENEMY, options.VehicleMarkerSetting(MARKERS.ENEMY, storage=MARKERS_SETTINGS_STORAGE)),\n\t\t (MARKERS.DEAD, options.VehicleMarkerSetting(MARKERS.DEAD, storage=MARKERS_SETTINGS_STORAGE)),\n\t\t (MARKERS.ALLY, options.VehicleMarkerSetting(MARKERS.ALLY, storage=MARKERS_SETTINGS_STORAGE)),\n\t\t (OTHER.VIBRO_CONNECTED, options.ReadOnlySetting(lambda : VibroManager.g_instance.connect())),\n\t\t (OTHER.VIBRO_GAIN, options.VibroSetting('master')),\n\t\t (OTHER.VIBRO_ENGINE, options.VibroSetting('engine')),\n\t\t (OTHER.VIBRO_ACCELERATION, options.VibroSetting('acceleration')),\n\t\t (OTHER.VIBRO_SHOTS, options.VibroSetting('shots')),\n\t\t (OTHER.VIBRO_HITS, options.VibroSetting('hits')),\n\t\t (OTHER.VIBRO_COLLISIONS, options.VibroSetting('collisions')),\n\t\t (OTHER.VIBRO_DAMAGE, options.VibroSetting('damage')),\n\t\t (OTHER.VIBRO_GUI, options.VibroSetting('gui')),\n\t\t (TUTORIAL.CUSTOMIZATION, options.TutorialSetting(TUTORIAL.CUSTOMIZATION, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.TECHNICAL_MAINTENANCE, options.TutorialSetting(TUTORIAL.TECHNICAL_MAINTENANCE, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.PERSONAL_CASE, options.TutorialSetting(TUTORIAL.PERSONAL_CASE, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.RESEARCH, options.TutorialSetting(TUTORIAL.RESEARCH, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.RESEARCH_TREE, options.TutorialSetting(TUTORIAL.RESEARCH_TREE, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.MEDKIT_INSTALLED, options.TutorialSetting(TUTORIAL.MEDKIT_INSTALLED, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.MEDKIT_USED, options.TutorialSetting(TUTORIAL.MEDKIT_USED, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.REPAIRKIT_INSTALLED, options.TutorialSetting(TUTORIAL.REPAIRKIT_INSTALLED, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.REPAIRKIT_USED, options.TutorialSetting(TUTORIAL.REPAIRKIT_USED, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.FIRE_EXTINGUISHER_INSTALLED, options.TutorialSetting(TUTORIAL.FIRE_EXTINGUISHER_INSTALLED, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.FIRE_EXTINGUISHER_USED, options.TutorialSetting(TUTORIAL.FIRE_EXTINGUISHER_USED, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.WAS_QUESTS_TUTORIAL_STARTED, options.TutorialSetting(TUTORIAL.WAS_QUESTS_TUTORIAL_STARTED, storage=TUTORIAL_SETTINGS_STORAGE))))\n\t\tself.__options.init()\n\t\tAccountSettings.onSettingsChanging += self.__onAccountSettingsChanging\n\t\tself.interfaceScale.init()\n\t\tLOG_DEBUG('SettingsCore is initialized')\n\n\tdef fini(self):\n\t\tself.options.dump()\n\t\tself.__storages = None\n\t\tself.__options = None\n\t\tself.__serverSettings = None\n\t\tself.interfaceScale.fini()\n\t\tAccountSettings.onSettingsChanging -= self.__onAccountSettingsChanging\n\t\tAccountSettings.clearCache()\n\t\tLOG_DEBUG('SettingsCore is destroyed')\n\t\treturn\n\n\t@property\n\tdef options(self):\n\t\treturn self.__options\n\n\t@property\n\tdef storages(self):\n\t\treturn self.__storages\n\n\t@property\n\tdef serverSettings(self):\n\t\treturn self.__serverSettings\n\n\tdef packSettings(self, names):\n\t\treturn self.__options.pack(names)\n\n\tdef getSetting(self, name):\n\t\treturn self.__options.getSetting(name).get()\n\n\tdef getApplyMethod(self, diff):\n\t\treturn self.__options.getApplyMethod(diff)\n\n\tdef applySetting(self, key, value):\n\t\tif self.isSettingChanged(key, value):\n\t\t\tresult = self.__options.getSetting(key).apply(value)\n\t\t\tfrom account_helpers.settings_core import settings_constants\n\t\t\tif key in settings_constants.GRAPHICS.ALL():\n\t\t\t\tLOG_DEBUG('Apply graphic settings: ', {key: value})\n\t\t\t\tself.onSettingsChanged({key: value})\n\t\t\treturn result\n\t\telse:\n\t\t\treturn None\n\n\tdef previewSetting(self, name, value):\n\t\tif self.isSettingChanged(name, value):\n\t\t\tself.__options.getSetting(name).preview(value)\n\n\tdef applySettings(self, diff):\n\t\tself.__options.apply(diff)\n\t\tfrom account_helpers.settings_core import settings_constants\n\t\tgraphicsSettings = {k:v for k, v in diff.iteritems() if k in settings_constants.GRAPHICS.ALL()}\n\t\tif graphicsSettings:\n\t\t\tLOG_DEBUG('Apply graphic settings: ', graphicsSettings)\n\t\t\tself.onSettingsChanged(graphicsSettings)\n\n\tdef revertSettings(self):\n\t\tself.__options.revert()\n\n\tdef isSettingChanged(self, name, value):\n\t\treturn self.getSetting(name) != value\n\n\tdef applyStorages(self, restartApproved):\n\t\tconfirmators = []\n\t\tfor storage in self.__storages.values():\n\t\t\tconfirmators.append(storage.apply(restartApproved))\n\n\t\treturn confirmators\n\n\t@process\n\tdef confirmChanges(self, confirmators):\n\t\tyield lambda callback: callback(None)\n\t\tfor confirmation, revert in confirmators:\n\t\t\tif confirmation is not None:\n\t\t\t\tisConfirmed = yield confirmation()\n\t\t\t\tif not isConfirmed:\n\t\t\t\t\tself.isChangesConfirmed = False\n\t\t\t\t\trevert()\n\n\t\treturn\n\n\tdef clearStorages(self):\n\t\tfor storage in self.__storages.values():\n\t\t\tstorage.clear()\n\n\tdef __onAccountSettingsChanging(self, key, value):\n\t\tLOG_DEBUG('Apply account setting: ', {key: value})\n\t\tself.onSettingsChanged({key: value})\n\n", "description": null, "category": "graphics", "imports": ["import Event", "from InterfaceScaleManager import InterfaceScaleManager", "from Vibroeffects import VibroManager", "from account_helpers.AccountSettings import AccountSettings", "from account_helpers.settings_core.ServerSettingsManager import ServerSettingsManager", "from adisp import process", "from debug_utils import LOG_DEBUG", "\t\tfrom account_helpers.settings_core import options, settings_storages, settings_constants", "\t\tfrom gui.shared.utils import graphics", "\t\t\tfrom account_helpers.settings_core import settings_constants", "\t\tfrom account_helpers.settings_core import settings_constants"]}], [], [{"term": "class", "name": "GraphicsObject", "data": "class GraphicsObject(GraphicsItem, QtGui.QGraphicsObject):\n\t\"\"\"\n\t**Bases:** :class:`GraphicsItem `, :class:`QtGui.QGraphicsObject`\n\n\tExtension of QGraphicsObject with some useful methods (provided by :class:`GraphicsItem `)\n\t\"\"\"\n\t_qtBaseClass = QtGui.QGraphicsObject\n\tdef __init__(self, *args):\n\t\tself.__inform_view_on_changes = True\n\t\tQtGui.QGraphicsObject.__init__(self, *args)\n\t\tself.setFlag(self.GraphicsItemFlag.ItemSendsGeometryChanges)\n\t\tGraphicsItem.__init__(self)\n\t\t\n\tdef itemChange(self, change, value):\n\t\tret = super().itemChange(change, value)\n\t\tif change in [self.GraphicsItemChange.ItemParentHasChanged, self.GraphicsItemChange.ItemSceneHasChanged]:\n\t\t\tself.parentChanged()\n\t\ttry:\n\t\t\tinform_view_on_change = self.__inform_view_on_changes\n\t\texcept AttributeError:\n\t\t\t# It's possible that the attribute was already collected when the itemChange happened\n\t\t\t# (if it was triggered during the gc of the object).\n\t\t\tpass\n\t\telse:\n\t\t\tif inform_view_on_change and change in [self.GraphicsItemChange.ItemPositionHasChanged, self.GraphicsItemChange.ItemTransformHasChanged]:\n\t\t\t\tself.informViewBoundsChanged()\n\t\t\t\n\t\t## workaround for pyqt bug:\n\t\t## http://www.riverbankcomputing.com/pipermail/pyqt/2012-August/031818.html\n\t\tif QT_LIB == 'PyQt5' and change == self.GraphicsItemChange.ItemParentChange and isinstance(ret, QtGui.QGraphicsItem):\n\t\t\tret = sip.cast(ret, QtGui.QGraphicsItem)\n\n\t\treturn ret\n", "description": "\n\t**Bases:** :class:`GraphicsItem `, :class:`QtGui.QGraphicsObject`\n\n\tExtension of QGraphicsObject with some useful methods (provided by :class:`GraphicsItem `)\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui, QT_LIB", "\tfrom ..Qt import sip", "from .GraphicsItem import GraphicsItem"]}], [{"term": "class", "name": "PortGraphics", "data": "class PortGraphics(QGraphicsItem):\n\t\"\"\"\n\tThis class defines the graphics for displaying a port in the APIM View.\n\n\tA port is shaped somewhat like an inverted, elongated pentagon.\n\t\"\"\"\n\t\n\tREQUIRED_PEN_WIDTH = 5.0\n\tOPTIONAL_PEN_WIDTH = 1.0\n\tWIDTH = 50\n\tSIDE_HEIGHT = 1.5 * WIDTH\n\tTAPER_HEIGHT = 0.5 * SIDE_HEIGHT\n\tTOTAL_HEIGHT = SIDE_HEIGHT + TAPER_HEIGHT\n\t# Center the shape about the origin of its coordinate system.\n\tX_POS = -0.5 * WIDTH\n\tY_POS = -0.5 * TOTAL_HEIGHT\n\t\n\tPEN_COLOR = QColor(Qt.black)\n\t\n\tINNER_COLOR = QColor(121, 125, 127)\n\tOUTER_COLOR = QColor(121, 125, 127)\n\t\n\tNAME_FONT = QFont(\"Times\", 15)\n\tTYPE_FONT = QFont(\"Times\", 15)\n\t\n\tdef __init__(self, port: 'Port', parent: QGraphicsItem = None, menuEnabled: bool = True):\n\t\t\"\"\"\n\t\tConstructs a portGraphics object for the given Port object.\n\t\t\n\t\t:param port: The port for which this graphics item represents.\n\t\t:type port: Port\n\t\t:param parent: A QGraphicsItem (probably an actionGraphics object)\n\t\t:type parent: QGraphicsItem\n\t\t:param menuEnabled: If true, a context menu will be shown on right-click.\n\t\t:type menuEnabled: bool\n\t\t\"\"\"\n\t\tQGraphicsItem.__init__(self, parent)\n\t\tself.setAcceptDrops(True)\n\t\tself.setFlag(QGraphicsItem.ItemIsSelectable)\n\t\tself._port = port\n\t\tself._menuEnabled = menuEnabled\n\t\tself.menu = PortMenu()\n\t\t\n\t\t# If port is required and it's an input, make the border thicker\n\t\tif not self._port.isOptional() and self._port in self._port.getAction().getInputPorts():\n\t\t\tself.borderWidth = PortGraphics.REQUIRED_PEN_WIDTH\n\t\telse:\n\t\t\tself.borderWidth = PortGraphics.OPTIONAL_PEN_WIDTH\n\t\t\t\n\t\t# show port name and type\n\t\tif self._menuEnabled:\n\t\t\tfm = QFontMetricsF(PortGraphics.NAME_FONT)\n\t\t\tname = fm.elidedText(self._port.getName(), Qt.ElideRight, PortGraphics.SIDE_HEIGHT)\n\t\t\tself.nameItem = QGraphicsTextItem(name, self)\n\t\t\tself.nameItem.setFont(PortGraphics.NAME_FONT)\n\t\t\tself.nameItem.setRotation(90)\n\t\t\tself.nameItem.setPos(PortGraphics.WIDTH/2 + 5,-PortGraphics.TOTAL_HEIGHT/2)\n\t\t\t\n\t\t\tfm = QFontMetricsF(PortGraphics.TYPE_FONT)\n\t\t\tt = fm.elidedText(self._port.getDataTypeStr(), Qt.ElideRight, PortGraphics.SIDE_HEIGHT)\n\t\t\tself.typeItem = QGraphicsTextItem(t, self)\n\t\t\tself.typeItem.setFont(PortGraphics.TYPE_FONT)\n\t\t\tself.typeItem.setRotation(90)\n\t\t\tself.typeItem.setPos(5, -PortGraphics.TOTAL_HEIGHT / 2)\n\n\tdef getPort(self):\n\t\t\"\"\"\n\t\tReturns the PortGraphics' Port.\n\t\t:return:\n\t\t\"\"\"\n\t\treturn self._port\n\t\n\tdef boundingRect(self) -> QRectF:\n\t\t\"\"\"\n\t\tThis pure virtual function defines the outer bounds of the item as a rectangle.\n\t\t:return: create the bounding of the item\n\t\t:rtype: QRectF\n\t\t\"\"\"\n\t\thalfPenWidth = self.borderWidth / 2\n\t\tx = PortGraphics.X_POS - halfPenWidth\n\t\ty = PortGraphics.Y_POS - halfPenWidth\n\t\t\n\t\tactualWidth = PortGraphics.WIDTH + self.borderWidth\n\t\tactualHeight = PortGraphics.TOTAL_HEIGHT + self.borderWidth\n\t\t\n\t\treturn QRectF(x, y, actualWidth, actualHeight)\n\t\n\tdef shape(self) -> QPainterPath:\n\t\t\"\"\"\n\t\tReturns the shape of the Port as a QPainterPath. Ports are shaped like an inverted, elongated pentagon.\n\n\t\t:return: The shape of the Port as a QPainterPath.\n\t\t:rtype: QPainterPath\n\t\t\"\"\"\n\t\t# Create the polygon (pentagon-like shape)\n\t\tpoly = QPolygon()\n\t\tpoly << QPoint(PortGraphics.X_POS, PortGraphics.Y_POS)\n\t\tpoly << QPoint(PortGraphics.X_POS + PortGraphics.WIDTH, PortGraphics.Y_POS)\n\t\tpoly << QPoint(PortGraphics.X_POS + PortGraphics.WIDTH, PortGraphics.Y_POS + PortGraphics.SIDE_HEIGHT)\n\t\tpoly << QPoint(0, PortGraphics.Y_POS + PortGraphics.TOTAL_HEIGHT)\n\t\tpoly << QPoint(PortGraphics.X_POS, PortGraphics.Y_POS + PortGraphics.SIDE_HEIGHT)\n\t\tpoly << QPoint(PortGraphics.X_POS, PortGraphics.Y_POS)\n\n\t\tpath = QPainterPath()\n\t\tpath.addPolygon(poly)\n\t\treturn path\n\t\n\t\n\tdef paint(self, painter: QPainter, option: QStyleOptionGraphicsItem, widget: QWidget) -> None:\n\t\t\"\"\"\n\t\tPaints a port. This function is used implicitly by the QGraphicsView to render a port.\n\t\t\n\t\t:param painter: The painter to paint with.\n\t\t:type painter: QPainter\n\t\t:param option: provides style options for the item.\n\t\t:type option: QStyleOptionGraphicsItem\n\t\t:param widget: QWidget\n\t\t:type widget: It points to the widget that is being painted on; or make it = None.\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\t\n\t\tpen = QPen(PortGraphics.PEN_COLOR)\n\t\tpen.setWidth(self.borderWidth)\n\t\tpainter.setPen(pen)\n\t\t\n\t\tif type(self._port.getAction()) == ActionWrapper:\n\t\t\tpainter.setBrush(PortGraphics.INNER_COLOR)\n\t\telse:\n\t\t\tpainter.setBrush(PortGraphics.OUTER_COLOR)\n\t\tpainter.drawPath(self.shape())\n\n\tdef contextMenuEvent(self, event: QGraphicsSceneContextMenuEvent) -> None:\n\t\t\"\"\"\n\t\tOpens a context menu (right click menu) for the component.\n\n\t\t:param event: The event that was generated when the user right-clicked on this item.\n\t\t:type event: QGraphicsSceneContextMenuEvent\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\treturn QGraphicsItem.contextMenuEvent(self, event)\n\n\t\t# if not self._menuEnabled:\n\t\t# \treturn QGraphicsItem.contextMenuEvent(self, event)\n\t\t#\n\t\t# self.setSelected(True)\n\t\t# self.menu.exec_(event.screenPos())\n\t\n\tdef mousePressEvent(self, event: QGraphicsSceneMouseEvent):\n\t\t\"\"\"\n\t\tWhen a port is clicked, emit the entitySelected signal from the view.\n\t\t:param event: the mouse click event\n\t\t:type event: QGraphicsSceneMouseEvent\n\t\t:return: None\n\t\t\"\"\"\n\t\tevent.ignore()\n\n\t\ttry:\n\t\t\tself.scene().views()[0].entitySelected.emit(self._port)\n\t\texcept:\n\t\t\tpass\n", "description": "\n\tThis class defines the graphics for displaying a port in the APIM View.\n\n\tA port is shaped somewhat like an inverted, elongated pentagon.\n\t", "category": "graphics", "imports": ["import sys", "import os", "from PySide2.QtCore import QRectF, QPoint", "from PySide2.QtGui import QPainterPath, QPainter, QPolygon, QColor, Qt, QPen, QFont, QFontMetricsF", "from PySide2.QtWidgets import QGraphicsScene, QGraphicsItem, QApplication, QGraphicsView, QStyleOptionGraphicsItem, \\", "from qt_models.portmenu import PortMenu", "import data.apim.port as port", "from data.apim.actionwrapper import ActionWrapper"]}], [{"term": "def", "name": "setConfigOption", "data": "def setConfigOption(opt, value):\r\n\tCONFIG_OPTIONS[opt] = value\r\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use\r", "from .Qt import QtGui\r", "import numpy  ## pyqtgraph requires numpy\r", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)\r", "import os, sys\r", "from . import python2_3\r", "from . import numpy_fix\r", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')\r", "\tfrom .Qt import VERSION_INFO\r", "\timport pprint\r", "\t### This eliminates the problem of accidental stale pyc file imports.\"\r", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea\r", "## these must be imported separately.\r", "#from . import frozenSupport\r", "#def importModules(path, globals, locals, excludes=()):\r", "\t#Note that *path* MUST be relative to the module doing the import.\t\r", "\t\t\t#print( \"from .%s import * \" % modName)\r", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\r", "\t\t\t#import traceback\r", "\t\t\t#print(\"[Error importing module: %s]\" % modName)\r", "#def importAll(path, globals, locals, excludes=()):\r", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\r", "\t#mods = importModules(path, globals, locals, excludes)\r", "# Dynamic imports are disabled. This causes too many problems.\r", "#importAll('graphicsItems', globals(), locals())\r", "#importAll('widgets', globals(), locals(),\r", "from .graphicsItems.VTickGroup import * \r", "from .graphicsItems.GraphicsWidget import * \r", "from .graphicsItems.ScaleBar import * \r", "from .graphicsItems.PlotDataItem import * \r", "from .graphicsItems.GraphItem import * \r", "from .graphicsItems.TextItem import * \r", "from .graphicsItems.GraphicsLayout import * \r", "from .graphicsItems.UIGraphicsItem import * \r", "from .graphicsItems.GraphicsObject import * \r", "from .graphicsItems.PlotItem import * \r", "from .graphicsItems.ROI import * \r", "from .graphicsItems.InfiniteLine import * \r", "from .graphicsItems.HistogramLUTItem import * \r", "from .graphicsItems.GridItem import * \r", "from .graphicsItems.GradientLegend import * \r", "from .graphicsItems.GraphicsItem import * \r", "from .graphicsItems.BarGraphItem import * \r", "from .graphicsItems.ViewBox import * \r", "from .graphicsItems.ArrowItem import * \r", "from .graphicsItems.ImageItem import * \r", "from .graphicsItems.AxisItem import * \r", "from .graphicsItems.LabelItem import * \r", "from .graphicsItems.CurvePoint import * \r", "from .graphicsItems.GraphicsWidgetAnchor import * \r", "from .graphicsItems.PlotCurveItem import * \r", "from .graphicsItems.ButtonItem import * \r", "from .graphicsItems.GradientEditorItem import * \r", "from .graphicsItems.MultiPlotItem import * \r", "from .graphicsItems.ErrorBarItem import * \r", "from .graphicsItems.IsocurveItem import * \r", "from .graphicsItems.LinearRegionItem import * \r", "from .graphicsItems.FillBetweenItem import * \r", "from .graphicsItems.LegendItem import * \r", "from .graphicsItems.ScatterPlotItem import * \r", "from .graphicsItems.ItemGroup import * \r", "from .widgets.MultiPlotWidget import * \r", "from .widgets.ScatterPlotWidget import * \r", "from .widgets.ColorMapWidget import * \r", "from .widgets.FileDialog import * \r", "from .widgets.ValueLabel import * \r", "from .widgets.HistogramLUTWidget import * \r", "from .widgets.CheckTable import * \r", "from .widgets.BusyCursor import * \r", "from .widgets.PlotWidget import * \r", "from .widgets.ComboBox import * \r", "from .widgets.GradientWidget import * \r", "from .widgets.DataFilterWidget import * \r", "from .widgets.SpinBox import * \r", "from .widgets.JoystickButton import * \r", "from .widgets.GraphicsLayoutWidget import * \r", "from .widgets.TreeWidget import * \r", "from .widgets.PathButton import * \r", "from .widgets.VerticalLabel import * \r", "from .widgets.FeedbackButton import * \r", "from .widgets.ColorButton import * \r", "from .widgets.DataTreeWidget import * \r", "from .widgets.GraphicsView import * \r", "from .widgets.LayoutWidget import * \r", "from .widgets.TableWidget import * \r", "from .widgets.ProgressDialog import *\r", "from .imageview import *\r", "from .WidgetGroup import *\r", "from .Point import Point\r", "from .Vector import Vector\r", "from .SRTTransform import SRTTransform\r", "from .Transform3D import Transform3D\r", "from .SRTTransform3D import SRTTransform3D\r", "from .functions import *\r", "from .graphicsWindows import *\r", "from .SignalProxy import *\r", "from .colormap import *\r", "from .ptime import time\r", "from .Qt import isQObjectAlive\r", "import atexit\r", "\timport gc\r", "\tfrom . import console\r"]}, {"term": "def", "name": "setConfigOptions", "data": "def setConfigOptions(**opts):\r\n\tCONFIG_OPTIONS.update(opts)\r\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use\r", "from .Qt import QtGui\r", "import numpy  ## pyqtgraph requires numpy\r", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)\r", "import os, sys\r", "from . import python2_3\r", "from . import numpy_fix\r", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')\r", "\tfrom .Qt import VERSION_INFO\r", "\timport pprint\r", "\t### This eliminates the problem of accidental stale pyc file imports.\"\r", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea\r", "## these must be imported separately.\r", "#from . import frozenSupport\r", "#def importModules(path, globals, locals, excludes=()):\r", "\t#Note that *path* MUST be relative to the module doing the import.\t\r", "\t\t\t#print( \"from .%s import * \" % modName)\r", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\r", "\t\t\t#import traceback\r", "\t\t\t#print(\"[Error importing module: %s]\" % modName)\r", "#def importAll(path, globals, locals, excludes=()):\r", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\r", "\t#mods = importModules(path, globals, locals, excludes)\r", "# Dynamic imports are disabled. This causes too many problems.\r", "#importAll('graphicsItems', globals(), locals())\r", "#importAll('widgets', globals(), locals(),\r", "from .graphicsItems.VTickGroup import * \r", "from .graphicsItems.GraphicsWidget import * \r", "from .graphicsItems.ScaleBar import * \r", "from .graphicsItems.PlotDataItem import * \r", "from .graphicsItems.GraphItem import * \r", "from .graphicsItems.TextItem import * \r", "from .graphicsItems.GraphicsLayout import * \r", "from .graphicsItems.UIGraphicsItem import * \r", "from .graphicsItems.GraphicsObject import * \r", "from .graphicsItems.PlotItem import * \r", "from .graphicsItems.ROI import * \r", "from .graphicsItems.InfiniteLine import * \r", "from .graphicsItems.HistogramLUTItem import * \r", "from .graphicsItems.GridItem import * \r", "from .graphicsItems.GradientLegend import * \r", "from .graphicsItems.GraphicsItem import * \r", "from .graphicsItems.BarGraphItem import * \r", "from .graphicsItems.ViewBox import * \r", "from .graphicsItems.ArrowItem import * \r", "from .graphicsItems.ImageItem import * \r", "from .graphicsItems.AxisItem import * \r", "from .graphicsItems.LabelItem import * \r", "from .graphicsItems.CurvePoint import * \r", "from .graphicsItems.GraphicsWidgetAnchor import * \r", "from .graphicsItems.PlotCurveItem import * \r", "from .graphicsItems.ButtonItem import * \r", "from .graphicsItems.GradientEditorItem import * \r", "from .graphicsItems.MultiPlotItem import * \r", "from .graphicsItems.ErrorBarItem import * \r", "from .graphicsItems.IsocurveItem import * \r", "from .graphicsItems.LinearRegionItem import * \r", "from .graphicsItems.FillBetweenItem import * \r", "from .graphicsItems.LegendItem import * \r", "from .graphicsItems.ScatterPlotItem import * \r", "from .graphicsItems.ItemGroup import * \r", "from .widgets.MultiPlotWidget import * \r", "from .widgets.ScatterPlotWidget import * \r", "from .widgets.ColorMapWidget import * \r", "from .widgets.FileDialog import * \r", "from .widgets.ValueLabel import * \r", "from .widgets.HistogramLUTWidget import * \r", "from .widgets.CheckTable import * \r", "from .widgets.BusyCursor import * \r", "from .widgets.PlotWidget import * \r", "from .widgets.ComboBox import * \r", "from .widgets.GradientWidget import * \r", "from .widgets.DataFilterWidget import * \r", "from .widgets.SpinBox import * \r", "from .widgets.JoystickButton import * \r", "from .widgets.GraphicsLayoutWidget import * \r", "from .widgets.TreeWidget import * \r", "from .widgets.PathButton import * \r", "from .widgets.VerticalLabel import * \r", "from .widgets.FeedbackButton import * \r", "from .widgets.ColorButton import * \r", "from .widgets.DataTreeWidget import * \r", "from .widgets.GraphicsView import * \r", "from .widgets.LayoutWidget import * \r", "from .widgets.TableWidget import * \r", "from .widgets.ProgressDialog import *\r", "from .imageview import *\r", "from .WidgetGroup import *\r", "from .Point import Point\r", "from .Vector import Vector\r", "from .SRTTransform import SRTTransform\r", "from .Transform3D import Transform3D\r", "from .SRTTransform3D import SRTTransform3D\r", "from .functions import *\r", "from .graphicsWindows import *\r", "from .SignalProxy import *\r", "from .colormap import *\r", "from .ptime import time\r", "from .Qt import isQObjectAlive\r", "import atexit\r", "\timport gc\r", "\tfrom . import console\r"]}, {"term": "def", "name": "getConfigOption", "data": "def getConfigOption(opt):\r\n\treturn CONFIG_OPTIONS[opt]\r\n\r\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use\r", "from .Qt import QtGui\r", "import numpy  ## pyqtgraph requires numpy\r", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)\r", "import os, sys\r", "from . import python2_3\r", "from . import numpy_fix\r", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')\r", "\tfrom .Qt import VERSION_INFO\r", "\timport pprint\r", "\t### This eliminates the problem of accidental stale pyc file imports.\"\r", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea\r", "## these must be imported separately.\r", "#from . import frozenSupport\r", "#def importModules(path, globals, locals, excludes=()):\r", "\t#Note that *path* MUST be relative to the module doing the import.\t\r", "\t\t\t#print( \"from .%s import * \" % modName)\r", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\r", "\t\t\t#import traceback\r", "\t\t\t#print(\"[Error importing module: %s]\" % modName)\r", "#def importAll(path, globals, locals, excludes=()):\r", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\r", "\t#mods = importModules(path, globals, locals, excludes)\r", "# Dynamic imports are disabled. This causes too many problems.\r", "#importAll('graphicsItems', globals(), locals())\r", "#importAll('widgets', globals(), locals(),\r", "from .graphicsItems.VTickGroup import * \r", "from .graphicsItems.GraphicsWidget import * \r", "from .graphicsItems.ScaleBar import * \r", "from .graphicsItems.PlotDataItem import * \r", "from .graphicsItems.GraphItem import * \r", "from .graphicsItems.TextItem import * \r", "from .graphicsItems.GraphicsLayout import * \r", "from .graphicsItems.UIGraphicsItem import * \r", "from .graphicsItems.GraphicsObject import * \r", "from .graphicsItems.PlotItem import * \r", "from .graphicsItems.ROI import * \r", "from .graphicsItems.InfiniteLine import * \r", "from .graphicsItems.HistogramLUTItem import * \r", "from .graphicsItems.GridItem import * \r", "from .graphicsItems.GradientLegend import * \r", "from .graphicsItems.GraphicsItem import * \r", "from .graphicsItems.BarGraphItem import * \r", "from .graphicsItems.ViewBox import * \r", "from .graphicsItems.ArrowItem import * \r", "from .graphicsItems.ImageItem import * \r", "from .graphicsItems.AxisItem import * \r", "from .graphicsItems.LabelItem import * \r", "from .graphicsItems.CurvePoint import * \r", "from .graphicsItems.GraphicsWidgetAnchor import * \r", "from .graphicsItems.PlotCurveItem import * \r", "from .graphicsItems.ButtonItem import * \r", "from .graphicsItems.GradientEditorItem import * \r", "from .graphicsItems.MultiPlotItem import * \r", "from .graphicsItems.ErrorBarItem import * \r", "from .graphicsItems.IsocurveItem import * \r", "from .graphicsItems.LinearRegionItem import * \r", "from .graphicsItems.FillBetweenItem import * \r", "from .graphicsItems.LegendItem import * \r", "from .graphicsItems.ScatterPlotItem import * \r", "from .graphicsItems.ItemGroup import * \r", "from .widgets.MultiPlotWidget import * \r", "from .widgets.ScatterPlotWidget import * \r", "from .widgets.ColorMapWidget import * \r", "from .widgets.FileDialog import * \r", "from .widgets.ValueLabel import * \r", "from .widgets.HistogramLUTWidget import * \r", "from .widgets.CheckTable import * \r", "from .widgets.BusyCursor import * \r", "from .widgets.PlotWidget import * \r", "from .widgets.ComboBox import * \r", "from .widgets.GradientWidget import * \r", "from .widgets.DataFilterWidget import * \r", "from .widgets.SpinBox import * \r", "from .widgets.JoystickButton import * \r", "from .widgets.GraphicsLayoutWidget import * \r", "from .widgets.TreeWidget import * \r", "from .widgets.PathButton import * \r", "from .widgets.VerticalLabel import * \r", "from .widgets.FeedbackButton import * \r", "from .widgets.ColorButton import * \r", "from .widgets.DataTreeWidget import * \r", "from .widgets.GraphicsView import * \r", "from .widgets.LayoutWidget import * \r", "from .widgets.TableWidget import * \r", "from .widgets.ProgressDialog import *\r", "from .imageview import *\r", "from .WidgetGroup import *\r", "from .Point import Point\r", "from .Vector import Vector\r", "from .SRTTransform import SRTTransform\r", "from .Transform3D import Transform3D\r", "from .SRTTransform3D import SRTTransform3D\r", "from .functions import *\r", "from .graphicsWindows import *\r", "from .SignalProxy import *\r", "from .colormap import *\r", "from .ptime import time\r", "from .Qt import isQObjectAlive\r", "import atexit\r", "\timport gc\r", "\tfrom . import console\r"]}, {"term": "def", "name": "systemInfo", "data": "def systemInfo():\r\n\tprint(\"sys.platform: %s\" % sys.platform)\r\n\tprint(\"sys.version: %s\" % sys.version)\r\n\tfrom .Qt import VERSION_INFO\r\n\tprint(\"qt bindings: %s\" % VERSION_INFO)\r\n\t\r\n\tglobal __version__\r\n\trev = None\r\n\tif __version__ is None:  ## this code was probably checked out from bzr; look up the last-revision file\r\n\t\tlastRevFile = os.path.join(os.path.dirname(__file__), '..', '.bzr', 'branch', 'last-revision')\r\n\t\tif os.path.exists(lastRevFile):\r\n\t\t\trev = open(lastRevFile, 'r').read().strip()\r\n\t\r\n\tprint(\"pyqtgraph: %s; %s\" % (__version__, rev))\r\n\tprint(\"config:\")\r\n\timport pprint\r\n\tpprint.pprint(CONFIG_OPTIONS)\r\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use\r", "from .Qt import QtGui\r", "import numpy  ## pyqtgraph requires numpy\r", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)\r", "import os, sys\r", "from . import python2_3\r", "from . import numpy_fix\r", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')\r", "\tfrom .Qt import VERSION_INFO\r", "\timport pprint\r", "\t### This eliminates the problem of accidental stale pyc file imports.\"\r", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea\r", "## these must be imported separately.\r", "#from . import frozenSupport\r", "#def importModules(path, globals, locals, excludes=()):\r", "\t#Note that *path* MUST be relative to the module doing the import.\t\r", "\t\t\t#print( \"from .%s import * \" % modName)\r", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\r", "\t\t\t#import traceback\r", "\t\t\t#print(\"[Error importing module: %s]\" % modName)\r", "#def importAll(path, globals, locals, excludes=()):\r", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\r", "\t#mods = importModules(path, globals, locals, excludes)\r", "# Dynamic imports are disabled. This causes too many problems.\r", "#importAll('graphicsItems', globals(), locals())\r", "#importAll('widgets', globals(), locals(),\r", "from .graphicsItems.VTickGroup import * \r", "from .graphicsItems.GraphicsWidget import * \r", "from .graphicsItems.ScaleBar import * \r", "from .graphicsItems.PlotDataItem import * \r", "from .graphicsItems.GraphItem import * \r", "from .graphicsItems.TextItem import * \r", "from .graphicsItems.GraphicsLayout import * \r", "from .graphicsItems.UIGraphicsItem import * \r", "from .graphicsItems.GraphicsObject import * \r", "from .graphicsItems.PlotItem import * \r", "from .graphicsItems.ROI import * \r", "from .graphicsItems.InfiniteLine import * \r", "from .graphicsItems.HistogramLUTItem import * \r", "from .graphicsItems.GridItem import * \r", "from .graphicsItems.GradientLegend import * \r", "from .graphicsItems.GraphicsItem import * \r", "from .graphicsItems.BarGraphItem import * \r", "from .graphicsItems.ViewBox import * \r", "from .graphicsItems.ArrowItem import * \r", "from .graphicsItems.ImageItem import * \r", "from .graphicsItems.AxisItem import * \r", "from .graphicsItems.LabelItem import * \r", "from .graphicsItems.CurvePoint import * \r", "from .graphicsItems.GraphicsWidgetAnchor import * \r", "from .graphicsItems.PlotCurveItem import * \r", "from .graphicsItems.ButtonItem import * \r", "from .graphicsItems.GradientEditorItem import * \r", "from .graphicsItems.MultiPlotItem import * \r", "from .graphicsItems.ErrorBarItem import * \r", "from .graphicsItems.IsocurveItem import * \r", "from .graphicsItems.LinearRegionItem import * \r", "from .graphicsItems.FillBetweenItem import * \r", "from .graphicsItems.LegendItem import * \r", "from .graphicsItems.ScatterPlotItem import * \r", "from .graphicsItems.ItemGroup import * \r", "from .widgets.MultiPlotWidget import * \r", "from .widgets.ScatterPlotWidget import * \r", "from .widgets.ColorMapWidget import * \r", "from .widgets.FileDialog import * \r", "from .widgets.ValueLabel import * \r", "from .widgets.HistogramLUTWidget import * \r", "from .widgets.CheckTable import * \r", "from .widgets.BusyCursor import * \r", "from .widgets.PlotWidget import * \r", "from .widgets.ComboBox import * \r", "from .widgets.GradientWidget import * \r", "from .widgets.DataFilterWidget import * \r", "from .widgets.SpinBox import * \r", "from .widgets.JoystickButton import * \r", "from .widgets.GraphicsLayoutWidget import * \r", "from .widgets.TreeWidget import * \r", "from .widgets.PathButton import * \r", "from .widgets.VerticalLabel import * \r", "from .widgets.FeedbackButton import * \r", "from .widgets.ColorButton import * \r", "from .widgets.DataTreeWidget import * \r", "from .widgets.GraphicsView import * \r", "from .widgets.LayoutWidget import * \r", "from .widgets.TableWidget import * \r", "from .widgets.ProgressDialog import *\r", "from .imageview import *\r", "from .WidgetGroup import *\r", "from .Point import Point\r", "from .Vector import Vector\r", "from .SRTTransform import SRTTransform\r", "from .Transform3D import Transform3D\r", "from .SRTTransform3D import SRTTransform3D\r", "from .functions import *\r", "from .graphicsWindows import *\r", "from .SignalProxy import *\r", "from .colormap import *\r", "from .ptime import time\r", "from .Qt import isQObjectAlive\r", "import atexit\r", "\timport gc\r", "\tfrom . import console\r"]}, {"term": "def", "name": "renamePyc", "data": "def renamePyc(startDir):\r\n\t### Used to rename orphaned .pyc files\r\n\t### When a python file changes its location in the repository, usually the .pyc file\r\n\t### is left behind, possibly causing mysterious and difficult to track bugs. \r\n\r\n\t### Note that this is no longer necessary for python 3.2; from PEP 3147:\r\n\t### \"If the py source file is missing, the pyc file inside __pycache__ will be ignored. \r\n\t### This eliminates the problem of accidental stale pyc file imports.\"\r\n\t\r\n\tprinted = False\r\n\tstartDir = os.path.abspath(startDir)\r\n\tfor path, dirs, files in os.walk(startDir):\r\n\t\tif '__pycache__' in path:\r\n\t\t\tcontinue\r\n\t\tfor f in files:\r\n\t\t\tfileName = os.path.join(path, f)\r\n\t\t\tbase, ext = os.path.splitext(fileName)\r\n\t\t\tpy = base + \".py\"\r\n\t\t\tif ext == '.pyc' and not os.path.isfile(py):\r\n\t\t\t\tif not printed:\r\n\t\t\t\t\tprint(\"NOTE: Renaming orphaned .pyc files:\")\r\n\t\t\t\t\tprinted = True\r\n\t\t\t\tn = 1\r\n\t\t\t\twhile True:\r\n\t\t\t\t\tname2 = fileName + \".renamed%d\" % n\r\n\t\t\t\t\tif not os.path.exists(name2):\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tn += 1\r\n\t\t\t\tprint(\"  \" + fileName + \"  ==>\")\r\n\t\t\t\tprint(\"  \" + name2)\r\n\t\t\t\tos.rename(fileName, name2)\r\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use\r", "from .Qt import QtGui\r", "import numpy  ## pyqtgraph requires numpy\r", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)\r", "import os, sys\r", "from . import python2_3\r", "from . import numpy_fix\r", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')\r", "\tfrom .Qt import VERSION_INFO\r", "\timport pprint\r", "\t### This eliminates the problem of accidental stale pyc file imports.\"\r", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea\r", "## these must be imported separately.\r", "#from . import frozenSupport\r", "#def importModules(path, globals, locals, excludes=()):\r", "\t#Note that *path* MUST be relative to the module doing the import.\t\r", "\t\t\t#print( \"from .%s import * \" % modName)\r", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\r", "\t\t\t#import traceback\r", "\t\t\t#print(\"[Error importing module: %s]\" % modName)\r", "#def importAll(path, globals, locals, excludes=()):\r", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\r", "\t#mods = importModules(path, globals, locals, excludes)\r", "# Dynamic imports are disabled. This causes too many problems.\r", "#importAll('graphicsItems', globals(), locals())\r", "#importAll('widgets', globals(), locals(),\r", "from .graphicsItems.VTickGroup import * \r", "from .graphicsItems.GraphicsWidget import * \r", "from .graphicsItems.ScaleBar import * \r", "from .graphicsItems.PlotDataItem import * \r", "from .graphicsItems.GraphItem import * \r", "from .graphicsItems.TextItem import * \r", "from .graphicsItems.GraphicsLayout import * \r", "from .graphicsItems.UIGraphicsItem import * \r", "from .graphicsItems.GraphicsObject import * \r", "from .graphicsItems.PlotItem import * \r", "from .graphicsItems.ROI import * \r", "from .graphicsItems.InfiniteLine import * \r", "from .graphicsItems.HistogramLUTItem import * \r", "from .graphicsItems.GridItem import * \r", "from .graphicsItems.GradientLegend import * \r", "from .graphicsItems.GraphicsItem import * \r", "from .graphicsItems.BarGraphItem import * \r", "from .graphicsItems.ViewBox import * \r", "from .graphicsItems.ArrowItem import * \r", "from .graphicsItems.ImageItem import * \r", "from .graphicsItems.AxisItem import * \r", "from .graphicsItems.LabelItem import * \r", "from .graphicsItems.CurvePoint import * \r", "from .graphicsItems.GraphicsWidgetAnchor import * \r", "from .graphicsItems.PlotCurveItem import * \r", "from .graphicsItems.ButtonItem import * \r", "from .graphicsItems.GradientEditorItem import * \r", "from .graphicsItems.MultiPlotItem import * \r", "from .graphicsItems.ErrorBarItem import * \r", "from .graphicsItems.IsocurveItem import * \r", "from .graphicsItems.LinearRegionItem import * \r", "from .graphicsItems.FillBetweenItem import * \r", "from .graphicsItems.LegendItem import * \r", "from .graphicsItems.ScatterPlotItem import * \r", "from .graphicsItems.ItemGroup import * \r", "from .widgets.MultiPlotWidget import * \r", "from .widgets.ScatterPlotWidget import * \r", "from .widgets.ColorMapWidget import * \r", "from .widgets.FileDialog import * \r", "from .widgets.ValueLabel import * \r", "from .widgets.HistogramLUTWidget import * \r", "from .widgets.CheckTable import * \r", "from .widgets.BusyCursor import * \r", "from .widgets.PlotWidget import * \r", "from .widgets.ComboBox import * \r", "from .widgets.GradientWidget import * \r", "from .widgets.DataFilterWidget import * \r", "from .widgets.SpinBox import * \r", "from .widgets.JoystickButton import * \r", "from .widgets.GraphicsLayoutWidget import * \r", "from .widgets.TreeWidget import * \r", "from .widgets.PathButton import * \r", "from .widgets.VerticalLabel import * \r", "from .widgets.FeedbackButton import * \r", "from .widgets.ColorButton import * \r", "from .widgets.DataTreeWidget import * \r", "from .widgets.GraphicsView import * \r", "from .widgets.LayoutWidget import * \r", "from .widgets.TableWidget import * \r", "from .widgets.ProgressDialog import *\r", "from .imageview import *\r", "from .WidgetGroup import *\r", "from .Point import Point\r", "from .Vector import Vector\r", "from .SRTTransform import SRTTransform\r", "from .Transform3D import Transform3D\r", "from .SRTTransform3D import SRTTransform3D\r", "from .functions import *\r", "from .graphicsWindows import *\r", "from .SignalProxy import *\r", "from .colormap import *\r", "from .ptime import time\r", "from .Qt import isQObjectAlive\r", "import atexit\r", "\timport gc\r", "\tfrom . import console\r"]}, {"term": "def", "name": "fimportModules", "data": "#def importModules(path, globals, locals, excludes=()):\r\n\t#\"\"\"Import all modules residing within *path*, return a dict of name: module pairs.\r\n\t\r\n\t#Note that *path* MUST be relative to the module doing the import.\t\r\n\t#\"\"\"\r\n\t#d = os.path.join(os.path.split(globals['__file__'])[0], path)\r\n\t#files = set()\r\n\t#for f in frozenSupport.listdir(d):\r\n\t\t#if frozenSupport.isdir(os.path.join(d, f)) and f not in ['__pycache__', 'tests']:\r\n\t\t\t#files.add(f)\r\n\t\t#elif f[-3:] == '.py' and f != '__init__.py':\r\n\t\t\t#files.add(f[:-3])\r\n\t\t#elif f[-4:] == '.pyc' and f != '__init__.pyc':\r\n\t\t\t#files.add(f[:-4])\r\n\t\t\r\n\t#mods = {}\r\n\t#path = path.replace(os.sep, '.')\r\n\t#for modName in files:\r\n\t\t#if modName in excludes:\r\n\t\t\t#continue\r\n\t\t#try:\r\n\t\t\t#if len(path) > 0:\r\n\t\t\t\t#modName = path + '.' + modName\r\n\t\t\t#print( \"from .%s import * \" % modName)\r\n\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\r\n\t\t\t#mods[modName] = mod\r\n\t\t#except:\r\n\t\t\t#import traceback\r\n\t\t\t#traceback.print_stack()\r\n\t\t\t#sys.excepthook(*sys.exc_info())\r\n\t\t\t#print(\"[Error importing module: %s]\" % modName)\r\n\t\t\t\r\n\t#return mods\r\n", "description": "Import all modules residing within *path*, return a dict of name: module pairs.\r\n\t\r\n\t#Note that *path* MUST be relative to the module doing the import.\t\r\n\t#", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use\r", "from .Qt import QtGui\r", "import numpy  ## pyqtgraph requires numpy\r", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)\r", "import os, sys\r", "from . import python2_3\r", "from . import numpy_fix\r", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')\r", "\tfrom .Qt import VERSION_INFO\r", "\timport pprint\r", "\t### This eliminates the problem of accidental stale pyc file imports.\"\r", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea\r", "## these must be imported separately.\r", "#from . import frozenSupport\r", "#def importModules(path, globals, locals, excludes=()):\r", "\t#Note that *path* MUST be relative to the module doing the import.\t\r", "\t\t\t#print( \"from .%s import * \" % modName)\r", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\r", "\t\t\t#import traceback\r", "\t\t\t#print(\"[Error importing module: %s]\" % modName)\r", "#def importAll(path, globals, locals, excludes=()):\r", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\r", "\t#mods = importModules(path, globals, locals, excludes)\r", "# Dynamic imports are disabled. This causes too many problems.\r", "#importAll('graphicsItems', globals(), locals())\r", "#importAll('widgets', globals(), locals(),\r", "from .graphicsItems.VTickGroup import * \r", "from .graphicsItems.GraphicsWidget import * \r", "from .graphicsItems.ScaleBar import * \r", "from .graphicsItems.PlotDataItem import * \r", "from .graphicsItems.GraphItem import * \r", "from .graphicsItems.TextItem import * \r", "from .graphicsItems.GraphicsLayout import * \r", "from .graphicsItems.UIGraphicsItem import * \r", "from .graphicsItems.GraphicsObject import * \r", "from .graphicsItems.PlotItem import * \r", "from .graphicsItems.ROI import * \r", "from .graphicsItems.InfiniteLine import * \r", "from .graphicsItems.HistogramLUTItem import * \r", "from .graphicsItems.GridItem import * \r", "from .graphicsItems.GradientLegend import * \r", "from .graphicsItems.GraphicsItem import * \r", "from .graphicsItems.BarGraphItem import * \r", "from .graphicsItems.ViewBox import * \r", "from .graphicsItems.ArrowItem import * \r", "from .graphicsItems.ImageItem import * \r", "from .graphicsItems.AxisItem import * \r", "from .graphicsItems.LabelItem import * \r", "from .graphicsItems.CurvePoint import * \r", "from .graphicsItems.GraphicsWidgetAnchor import * \r", "from .graphicsItems.PlotCurveItem import * \r", "from .graphicsItems.ButtonItem import * \r", "from .graphicsItems.GradientEditorItem import * \r", "from .graphicsItems.MultiPlotItem import * \r", "from .graphicsItems.ErrorBarItem import * \r", "from .graphicsItems.IsocurveItem import * \r", "from .graphicsItems.LinearRegionItem import * \r", "from .graphicsItems.FillBetweenItem import * \r", "from .graphicsItems.LegendItem import * \r", "from .graphicsItems.ScatterPlotItem import * \r", "from .graphicsItems.ItemGroup import * \r", "from .widgets.MultiPlotWidget import * \r", "from .widgets.ScatterPlotWidget import * \r", "from .widgets.ColorMapWidget import * \r", "from .widgets.FileDialog import * \r", "from .widgets.ValueLabel import * \r", "from .widgets.HistogramLUTWidget import * \r", "from .widgets.CheckTable import * \r", "from .widgets.BusyCursor import * \r", "from .widgets.PlotWidget import * \r", "from .widgets.ComboBox import * \r", "from .widgets.GradientWidget import * \r", "from .widgets.DataFilterWidget import * \r", "from .widgets.SpinBox import * \r", "from .widgets.JoystickButton import * \r", "from .widgets.GraphicsLayoutWidget import * \r", "from .widgets.TreeWidget import * \r", "from .widgets.PathButton import * \r", "from .widgets.VerticalLabel import * \r", "from .widgets.FeedbackButton import * \r", "from .widgets.ColorButton import * \r", "from .widgets.DataTreeWidget import * \r", "from .widgets.GraphicsView import * \r", "from .widgets.LayoutWidget import * \r", "from .widgets.TableWidget import * \r", "from .widgets.ProgressDialog import *\r", "from .imageview import *\r", "from .WidgetGroup import *\r", "from .Point import Point\r", "from .Vector import Vector\r", "from .SRTTransform import SRTTransform\r", "from .Transform3D import Transform3D\r", "from .SRTTransform3D import SRTTransform3D\r", "from .functions import *\r", "from .graphicsWindows import *\r", "from .SignalProxy import *\r", "from .colormap import *\r", "from .ptime import time\r", "from .Qt import isQObjectAlive\r", "import atexit\r", "\timport gc\r", "\tfrom . import console\r"]}, {"term": "def", "name": "fimportAll", "data": "#def importAll(path, globals, locals, excludes=()):\r\n\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\r\n\t#mods = importModules(path, globals, locals, excludes)\r\n\t#for mod in mods.values():\r\n\t\t#if hasattr(mod, '__all__'):\r\n\t\t\t#names = mod.__all__\r\n\t\t#else:\r\n\t\t\t#names = [n for n in dir(mod) if n[0] != '_']\r\n\t\t#for k in names:\r\n\t\t\t#if hasattr(mod, k):\r\n\t\t\t\t#globals[k] = getattr(mod, k)\r\n", "description": "Given a list of modules, import all names from each module into the global namespace.", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use\r", "from .Qt import QtGui\r", "import numpy  ## pyqtgraph requires numpy\r", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)\r", "import os, sys\r", "from . import python2_3\r", "from . import numpy_fix\r", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')\r", "\tfrom .Qt import VERSION_INFO\r", "\timport pprint\r", "\t### This eliminates the problem of accidental stale pyc file imports.\"\r", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea\r", "## these must be imported separately.\r", "#from . import frozenSupport\r", "#def importModules(path, globals, locals, excludes=()):\r", "\t#Note that *path* MUST be relative to the module doing the import.\t\r", "\t\t\t#print( \"from .%s import * \" % modName)\r", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\r", "\t\t\t#import traceback\r", "\t\t\t#print(\"[Error importing module: %s]\" % modName)\r", "#def importAll(path, globals, locals, excludes=()):\r", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\r", "\t#mods = importModules(path, globals, locals, excludes)\r", "# Dynamic imports are disabled. This causes too many problems.\r", "#importAll('graphicsItems', globals(), locals())\r", "#importAll('widgets', globals(), locals(),\r", "from .graphicsItems.VTickGroup import * \r", "from .graphicsItems.GraphicsWidget import * \r", "from .graphicsItems.ScaleBar import * \r", "from .graphicsItems.PlotDataItem import * \r", "from .graphicsItems.GraphItem import * \r", "from .graphicsItems.TextItem import * \r", "from .graphicsItems.GraphicsLayout import * \r", "from .graphicsItems.UIGraphicsItem import * \r", "from .graphicsItems.GraphicsObject import * \r", "from .graphicsItems.PlotItem import * \r", "from .graphicsItems.ROI import * \r", "from .graphicsItems.InfiniteLine import * \r", "from .graphicsItems.HistogramLUTItem import * \r", "from .graphicsItems.GridItem import * \r", "from .graphicsItems.GradientLegend import * \r", "from .graphicsItems.GraphicsItem import * \r", "from .graphicsItems.BarGraphItem import * \r", "from .graphicsItems.ViewBox import * \r", "from .graphicsItems.ArrowItem import * \r", "from .graphicsItems.ImageItem import * \r", "from .graphicsItems.AxisItem import * \r", "from .graphicsItems.LabelItem import * \r", "from .graphicsItems.CurvePoint import * \r", "from .graphicsItems.GraphicsWidgetAnchor import * \r", "from .graphicsItems.PlotCurveItem import * \r", "from .graphicsItems.ButtonItem import * \r", "from .graphicsItems.GradientEditorItem import * \r", "from .graphicsItems.MultiPlotItem import * \r", "from .graphicsItems.ErrorBarItem import * \r", "from .graphicsItems.IsocurveItem import * \r", "from .graphicsItems.LinearRegionItem import * \r", "from .graphicsItems.FillBetweenItem import * \r", "from .graphicsItems.LegendItem import * \r", "from .graphicsItems.ScatterPlotItem import * \r", "from .graphicsItems.ItemGroup import * \r", "from .widgets.MultiPlotWidget import * \r", "from .widgets.ScatterPlotWidget import * \r", "from .widgets.ColorMapWidget import * \r", "from .widgets.FileDialog import * \r", "from .widgets.ValueLabel import * \r", "from .widgets.HistogramLUTWidget import * \r", "from .widgets.CheckTable import * \r", "from .widgets.BusyCursor import * \r", "from .widgets.PlotWidget import * \r", "from .widgets.ComboBox import * \r", "from .widgets.GradientWidget import * \r", "from .widgets.DataFilterWidget import * \r", "from .widgets.SpinBox import * \r", "from .widgets.JoystickButton import * \r", "from .widgets.GraphicsLayoutWidget import * \r", "from .widgets.TreeWidget import * \r", "from .widgets.PathButton import * \r", "from .widgets.VerticalLabel import * \r", "from .widgets.FeedbackButton import * \r", "from .widgets.ColorButton import * \r", "from .widgets.DataTreeWidget import * \r", "from .widgets.GraphicsView import * \r", "from .widgets.LayoutWidget import * \r", "from .widgets.TableWidget import * \r", "from .widgets.ProgressDialog import *\r", "from .imageview import *\r", "from .WidgetGroup import *\r", "from .Point import Point\r", "from .Vector import Vector\r", "from .SRTTransform import SRTTransform\r", "from .Transform3D import Transform3D\r", "from .SRTTransform3D import SRTTransform3D\r", "from .functions import *\r", "from .graphicsWindows import *\r", "from .SignalProxy import *\r", "from .colormap import *\r", "from .ptime import time\r", "from .Qt import isQObjectAlive\r", "import atexit\r", "\timport gc\r", "\tfrom . import console\r"]}, {"term": "def", "name": "cleanup", "data": "def cleanup():\r\n\tglobal _cleanupCalled\r\n\tif _cleanupCalled:\r\n\t\treturn\r\n\t\r\n\tif not getConfigOption('exitCleanup'):\r\n\t\treturn\r\n\t\r\n\tViewBox.quit()  ## tell ViewBox that it doesn't need to deregister views anymore.\r\n\t\r\n\t## Workaround for Qt exit crash:\r\n\t## ALL QGraphicsItems must have a scene before they are deleted.\r\n\t## This is potentially very expensive, but preferred over crashing.\r\n\t## Note: this appears to be fixed in PySide as of 2012.12, but it should be left in for a while longer..\r\n\tif QtGui.QApplication.instance() is None:\r\n\t\treturn\r\n\timport gc\r\n\ts = QtGui.QGraphicsScene()\r\n\tfor o in gc.get_objects():\r\n\t\ttry:\r\n\t\t\tif isinstance(o, QtGui.QGraphicsItem) and isQObjectAlive(o) and o.scene() is None:\r\n\t\t\t\tif getConfigOption('crashWarning'):\r\n\t\t\t\t\tsys.stderr.write('Error: graphics item without scene. '\r\n\t\t\t\t\t\t'Make sure ViewBox.close() and GraphicsView.close() '\r\n\t\t\t\t\t\t'are properly called before app shutdown (%s)\\n' % (o,))\r\n\t\t\t\t\r\n\t\t\t\ts.addItem(o)\r\n\t\texcept RuntimeError:  ## occurs if a python wrapper no longer has its underlying C++ object\r\n\t\t\tcontinue\r\n\t_cleanupCalled = True\r\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use\r", "from .Qt import QtGui\r", "import numpy  ## pyqtgraph requires numpy\r", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)\r", "import os, sys\r", "from . import python2_3\r", "from . import numpy_fix\r", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')\r", "\tfrom .Qt import VERSION_INFO\r", "\timport pprint\r", "\t### This eliminates the problem of accidental stale pyc file imports.\"\r", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea\r", "## these must be imported separately.\r", "#from . import frozenSupport\r", "#def importModules(path, globals, locals, excludes=()):\r", "\t#Note that *path* MUST be relative to the module doing the import.\t\r", "\t\t\t#print( \"from .%s import * \" % modName)\r", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\r", "\t\t\t#import traceback\r", "\t\t\t#print(\"[Error importing module: %s]\" % modName)\r", "#def importAll(path, globals, locals, excludes=()):\r", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\r", "\t#mods = importModules(path, globals, locals, excludes)\r", "# Dynamic imports are disabled. This causes too many problems.\r", "#importAll('graphicsItems', globals(), locals())\r", "#importAll('widgets', globals(), locals(),\r", "from .graphicsItems.VTickGroup import * \r", "from .graphicsItems.GraphicsWidget import * \r", "from .graphicsItems.ScaleBar import * \r", "from .graphicsItems.PlotDataItem import * \r", "from .graphicsItems.GraphItem import * \r", "from .graphicsItems.TextItem import * \r", "from .graphicsItems.GraphicsLayout import * \r", "from .graphicsItems.UIGraphicsItem import * \r", "from .graphicsItems.GraphicsObject import * \r", "from .graphicsItems.PlotItem import * \r", "from .graphicsItems.ROI import * \r", "from .graphicsItems.InfiniteLine import * \r", "from .graphicsItems.HistogramLUTItem import * \r", "from .graphicsItems.GridItem import * \r", "from .graphicsItems.GradientLegend import * \r", "from .graphicsItems.GraphicsItem import * \r", "from .graphicsItems.BarGraphItem import * \r", "from .graphicsItems.ViewBox import * \r", "from .graphicsItems.ArrowItem import * \r", "from .graphicsItems.ImageItem import * \r", "from .graphicsItems.AxisItem import * \r", "from .graphicsItems.LabelItem import * \r", "from .graphicsItems.CurvePoint import * \r", "from .graphicsItems.GraphicsWidgetAnchor import * \r", "from .graphicsItems.PlotCurveItem import * \r", "from .graphicsItems.ButtonItem import * \r", "from .graphicsItems.GradientEditorItem import * \r", "from .graphicsItems.MultiPlotItem import * \r", "from .graphicsItems.ErrorBarItem import * \r", "from .graphicsItems.IsocurveItem import * \r", "from .graphicsItems.LinearRegionItem import * \r", "from .graphicsItems.FillBetweenItem import * \r", "from .graphicsItems.LegendItem import * \r", "from .graphicsItems.ScatterPlotItem import * \r", "from .graphicsItems.ItemGroup import * \r", "from .widgets.MultiPlotWidget import * \r", "from .widgets.ScatterPlotWidget import * \r", "from .widgets.ColorMapWidget import * \r", "from .widgets.FileDialog import * \r", "from .widgets.ValueLabel import * \r", "from .widgets.HistogramLUTWidget import * \r", "from .widgets.CheckTable import * \r", "from .widgets.BusyCursor import * \r", "from .widgets.PlotWidget import * \r", "from .widgets.ComboBox import * \r", "from .widgets.GradientWidget import * \r", "from .widgets.DataFilterWidget import * \r", "from .widgets.SpinBox import * \r", "from .widgets.JoystickButton import * \r", "from .widgets.GraphicsLayoutWidget import * \r", "from .widgets.TreeWidget import * \r", "from .widgets.PathButton import * \r", "from .widgets.VerticalLabel import * \r", "from .widgets.FeedbackButton import * \r", "from .widgets.ColorButton import * \r", "from .widgets.DataTreeWidget import * \r", "from .widgets.GraphicsView import * \r", "from .widgets.LayoutWidget import * \r", "from .widgets.TableWidget import * \r", "from .widgets.ProgressDialog import *\r", "from .imageview import *\r", "from .WidgetGroup import *\r", "from .Point import Point\r", "from .Vector import Vector\r", "from .SRTTransform import SRTTransform\r", "from .Transform3D import Transform3D\r", "from .SRTTransform3D import SRTTransform3D\r", "from .functions import *\r", "from .graphicsWindows import *\r", "from .SignalProxy import *\r", "from .colormap import *\r", "from .ptime import time\r", "from .Qt import isQObjectAlive\r", "import atexit\r", "\timport gc\r", "\tfrom . import console\r"]}, {"term": "def", "name": "_connectCleanup", "data": "def _connectCleanup():\r\n\tglobal _cleanupConnected\r\n\tif _cleanupConnected:\r\n\t\treturn\r\n\tQtGui.QApplication.instance().aboutToQuit.connect(cleanup)\r\n\t_cleanupConnected = True\r\n\r\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use\r", "from .Qt import QtGui\r", "import numpy  ## pyqtgraph requires numpy\r", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)\r", "import os, sys\r", "from . import python2_3\r", "from . import numpy_fix\r", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')\r", "\tfrom .Qt import VERSION_INFO\r", "\timport pprint\r", "\t### This eliminates the problem of accidental stale pyc file imports.\"\r", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea\r", "## these must be imported separately.\r", "#from . import frozenSupport\r", "#def importModules(path, globals, locals, excludes=()):\r", "\t#Note that *path* MUST be relative to the module doing the import.\t\r", "\t\t\t#print( \"from .%s import * \" % modName)\r", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\r", "\t\t\t#import traceback\r", "\t\t\t#print(\"[Error importing module: %s]\" % modName)\r", "#def importAll(path, globals, locals, excludes=()):\r", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\r", "\t#mods = importModules(path, globals, locals, excludes)\r", "# Dynamic imports are disabled. This causes too many problems.\r", "#importAll('graphicsItems', globals(), locals())\r", "#importAll('widgets', globals(), locals(),\r", "from .graphicsItems.VTickGroup import * \r", "from .graphicsItems.GraphicsWidget import * \r", "from .graphicsItems.ScaleBar import * \r", "from .graphicsItems.PlotDataItem import * \r", "from .graphicsItems.GraphItem import * \r", "from .graphicsItems.TextItem import * \r", "from .graphicsItems.GraphicsLayout import * \r", "from .graphicsItems.UIGraphicsItem import * \r", "from .graphicsItems.GraphicsObject import * \r", "from .graphicsItems.PlotItem import * \r", "from .graphicsItems.ROI import * \r", "from .graphicsItems.InfiniteLine import * \r", "from .graphicsItems.HistogramLUTItem import * \r", "from .graphicsItems.GridItem import * \r", "from .graphicsItems.GradientLegend import * \r", "from .graphicsItems.GraphicsItem import * \r", "from .graphicsItems.BarGraphItem import * \r", "from .graphicsItems.ViewBox import * \r", "from .graphicsItems.ArrowItem import * \r", "from .graphicsItems.ImageItem import * \r", "from .graphicsItems.AxisItem import * \r", "from .graphicsItems.LabelItem import * \r", "from .graphicsItems.CurvePoint import * \r", "from .graphicsItems.GraphicsWidgetAnchor import * \r", "from .graphicsItems.PlotCurveItem import * \r", "from .graphicsItems.ButtonItem import * \r", "from .graphicsItems.GradientEditorItem import * \r", "from .graphicsItems.MultiPlotItem import * \r", "from .graphicsItems.ErrorBarItem import * \r", "from .graphicsItems.IsocurveItem import * \r", "from .graphicsItems.LinearRegionItem import * \r", "from .graphicsItems.FillBetweenItem import * \r", "from .graphicsItems.LegendItem import * \r", "from .graphicsItems.ScatterPlotItem import * \r", "from .graphicsItems.ItemGroup import * \r", "from .widgets.MultiPlotWidget import * \r", "from .widgets.ScatterPlotWidget import * \r", "from .widgets.ColorMapWidget import * \r", "from .widgets.FileDialog import * \r", "from .widgets.ValueLabel import * \r", "from .widgets.HistogramLUTWidget import * \r", "from .widgets.CheckTable import * \r", "from .widgets.BusyCursor import * \r", "from .widgets.PlotWidget import * \r", "from .widgets.ComboBox import * \r", "from .widgets.GradientWidget import * \r", "from .widgets.DataFilterWidget import * \r", "from .widgets.SpinBox import * \r", "from .widgets.JoystickButton import * \r", "from .widgets.GraphicsLayoutWidget import * \r", "from .widgets.TreeWidget import * \r", "from .widgets.PathButton import * \r", "from .widgets.VerticalLabel import * \r", "from .widgets.FeedbackButton import * \r", "from .widgets.ColorButton import * \r", "from .widgets.DataTreeWidget import * \r", "from .widgets.GraphicsView import * \r", "from .widgets.LayoutWidget import * \r", "from .widgets.TableWidget import * \r", "from .widgets.ProgressDialog import *\r", "from .imageview import *\r", "from .WidgetGroup import *\r", "from .Point import Point\r", "from .Vector import Vector\r", "from .SRTTransform import SRTTransform\r", "from .Transform3D import Transform3D\r", "from .SRTTransform3D import SRTTransform3D\r", "from .functions import *\r", "from .graphicsWindows import *\r", "from .SignalProxy import *\r", "from .colormap import *\r", "from .ptime import time\r", "from .Qt import isQObjectAlive\r", "import atexit\r", "\timport gc\r", "\tfrom . import console\r"]}, {"term": "def", "name": "exit", "data": "def exit():\r\n\t\"\"\"\r\n\tCauses python to exit without garbage-collecting any objects, and thus avoids\r\n\tcalling object destructor methods. This is a sledgehammer workaround for \r\n\ta variety of bugs in PyQt and Pyside that cause crashes on exit.\r\n\t\r\n\tThis function does the following in an attempt to 'safely' terminate\r\n\tthe process:\r\n\t\r\n\t* Invoke atexit callbacks\r\n\t* Close all open file handles\r\n\t* os._exit()\r\n\t\r\n\tNote: there is some potential for causing damage with this function if you\r\n\tare using objects that _require_ their destructors to be called (for example,\r\n\tto properly terminate log files, disconnect from devices, etc). Situations\r\n\tlike this are probably quite rare, but use at your own risk.\r\n\t\"\"\"\r\n\t\r\n\t## first disable our own cleanup function; won't be needing it.\r\n\tsetConfigOptions(exitCleanup=False)\r\n\t\r\n\t## invoke atexit callbacks\r\n\tatexit._run_exitfuncs()\r\n\t\r\n\t## close file handles\r\n\tif sys.platform == 'darwin':\r\n\t\tfor fd in xrange(3, 4096):\r\n\t\t\tif fd not in [7]:  # trying to close 7 produces an illegal instruction on the Mac.\r\n\t\t\t\tos.close(fd)\r\n\telse:\r\n\t\tos.closerange(3, 4096) ## just guessing on the maximum descriptor count..\r\n\r\n\tos._exit(0)\r\n\t\r\n\r\n", "description": "\r\n\tCauses python to exit without garbage-collecting any objects, and thus avoids\r\n\tcalling object destructor methods. This is a sledgehammer workaround for \r\n\ta variety of bugs in PyQt and Pyside that cause crashes on exit.\r\n\t\r\n\tThis function does the following in an attempt to 'safely' terminate\r\n\tthe process:\r\n\t\r\n\t* Invoke atexit callbacks\r\n\t* Close all open file handles\r\n\t* os._exit()\r\n\t\r\n\tNote: there is some potential for causing damage with this function if you\r\n\tare using objects that _require_ their destructors to be called (for example,\r\n\tto properly terminate log files, disconnect from devices, etc). Situations\r\n\tlike this are probably quite rare, but use at your own risk.\r\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use\r", "from .Qt import QtGui\r", "import numpy  ## pyqtgraph requires numpy\r", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)\r", "import os, sys\r", "from . import python2_3\r", "from . import numpy_fix\r", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')\r", "\tfrom .Qt import VERSION_INFO\r", "\timport pprint\r", "\t### This eliminates the problem of accidental stale pyc file imports.\"\r", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea\r", "## these must be imported separately.\r", "#from . import frozenSupport\r", "#def importModules(path, globals, locals, excludes=()):\r", "\t#Note that *path* MUST be relative to the module doing the import.\t\r", "\t\t\t#print( \"from .%s import * \" % modName)\r", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\r", "\t\t\t#import traceback\r", "\t\t\t#print(\"[Error importing module: %s]\" % modName)\r", "#def importAll(path, globals, locals, excludes=()):\r", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\r", "\t#mods = importModules(path, globals, locals, excludes)\r", "# Dynamic imports are disabled. This causes too many problems.\r", "#importAll('graphicsItems', globals(), locals())\r", "#importAll('widgets', globals(), locals(),\r", "from .graphicsItems.VTickGroup import * \r", "from .graphicsItems.GraphicsWidget import * \r", "from .graphicsItems.ScaleBar import * \r", "from .graphicsItems.PlotDataItem import * \r", "from .graphicsItems.GraphItem import * \r", "from .graphicsItems.TextItem import * \r", "from .graphicsItems.GraphicsLayout import * \r", "from .graphicsItems.UIGraphicsItem import * \r", "from .graphicsItems.GraphicsObject import * \r", "from .graphicsItems.PlotItem import * \r", "from .graphicsItems.ROI import * \r", "from .graphicsItems.InfiniteLine import * \r", "from .graphicsItems.HistogramLUTItem import * \r", "from .graphicsItems.GridItem import * \r", "from .graphicsItems.GradientLegend import * \r", "from .graphicsItems.GraphicsItem import * \r", "from .graphicsItems.BarGraphItem import * \r", "from .graphicsItems.ViewBox import * \r", "from .graphicsItems.ArrowItem import * \r", "from .graphicsItems.ImageItem import * \r", "from .graphicsItems.AxisItem import * \r", "from .graphicsItems.LabelItem import * \r", "from .graphicsItems.CurvePoint import * \r", "from .graphicsItems.GraphicsWidgetAnchor import * \r", "from .graphicsItems.PlotCurveItem import * \r", "from .graphicsItems.ButtonItem import * \r", "from .graphicsItems.GradientEditorItem import * \r", "from .graphicsItems.MultiPlotItem import * \r", "from .graphicsItems.ErrorBarItem import * \r", "from .graphicsItems.IsocurveItem import * \r", "from .graphicsItems.LinearRegionItem import * \r", "from .graphicsItems.FillBetweenItem import * \r", "from .graphicsItems.LegendItem import * \r", "from .graphicsItems.ScatterPlotItem import * \r", "from .graphicsItems.ItemGroup import * \r", "from .widgets.MultiPlotWidget import * \r", "from .widgets.ScatterPlotWidget import * \r", "from .widgets.ColorMapWidget import * \r", "from .widgets.FileDialog import * \r", "from .widgets.ValueLabel import * \r", "from .widgets.HistogramLUTWidget import * \r", "from .widgets.CheckTable import * \r", "from .widgets.BusyCursor import * \r", "from .widgets.PlotWidget import * \r", "from .widgets.ComboBox import * \r", "from .widgets.GradientWidget import * \r", "from .widgets.DataFilterWidget import * \r", "from .widgets.SpinBox import * \r", "from .widgets.JoystickButton import * \r", "from .widgets.GraphicsLayoutWidget import * \r", "from .widgets.TreeWidget import * \r", "from .widgets.PathButton import * \r", "from .widgets.VerticalLabel import * \r", "from .widgets.FeedbackButton import * \r", "from .widgets.ColorButton import * \r", "from .widgets.DataTreeWidget import * \r", "from .widgets.GraphicsView import * \r", "from .widgets.LayoutWidget import * \r", "from .widgets.TableWidget import * \r", "from .widgets.ProgressDialog import *\r", "from .imageview import *\r", "from .WidgetGroup import *\r", "from .Point import Point\r", "from .Vector import Vector\r", "from .SRTTransform import SRTTransform\r", "from .Transform3D import Transform3D\r", "from .SRTTransform3D import SRTTransform3D\r", "from .functions import *\r", "from .graphicsWindows import *\r", "from .SignalProxy import *\r", "from .colormap import *\r", "from .ptime import time\r", "from .Qt import isQObjectAlive\r", "import atexit\r", "\timport gc\r", "\tfrom . import console\r"]}, {"term": "def", "name": "plot", "data": "def plot(*args, **kargs):\r\n\t\"\"\"\r\n\tCreate and return a :class:`PlotWindow ` \r\n\t(this is just a window with :class:`PlotWidget ` inside), plot data in it.\r\n\tAccepts a *title* argument to set the title of the window.\r\n\tAll other arguments are used to plot data. (see :func:`PlotItem.plot() `)\r\n\t\"\"\"\r\n\tmkQApp()\r\n\t#if 'title' in kargs:\r\n\t\t#w = PlotWindow(title=kargs['title'])\r\n\t\t#del kargs['title']\r\n\t#else:\r\n\t\t#w = PlotWindow()\r\n\t#if len(args)+len(kargs) > 0:\r\n\t\t#w.plot(*args, **kargs)\r\n\t\t\r\n\tpwArgList = ['title', 'labels', 'name', 'left', 'right', 'top', 'bottom', 'background']\r\n\tpwArgs = {}\r\n\tdataArgs = {}\r\n\tfor k in kargs:\r\n\t\tif k in pwArgList:\r\n\t\t\tpwArgs[k] = kargs[k]\r\n\t\telse:\r\n\t\t\tdataArgs[k] = kargs[k]\r\n\t\t\r\n\tw = PlotWindow(**pwArgs)\r\n\tif len(args) > 0 or len(dataArgs) > 0:\r\n\t\tw.plot(*args, **dataArgs)\r\n\tplots.append(w)\r\n\tw.show()\r\n\treturn w\r\n", "description": "\r\n\tCreate and return a :class:`PlotWindow ` \r\n\t(this is just a window with :class:`PlotWidget ` inside), plot data in it.\r\n\tAccepts a *title* argument to set the title of the window.\r\n\tAll other arguments are used to plot data. (see :func:`PlotItem.plot() `)\r\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use\r", "from .Qt import QtGui\r", "import numpy  ## pyqtgraph requires numpy\r", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)\r", "import os, sys\r", "from . import python2_3\r", "from . import numpy_fix\r", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')\r", "\tfrom .Qt import VERSION_INFO\r", "\timport pprint\r", "\t### This eliminates the problem of accidental stale pyc file imports.\"\r", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea\r", "## these must be imported separately.\r", "#from . import frozenSupport\r", "#def importModules(path, globals, locals, excludes=()):\r", "\t#Note that *path* MUST be relative to the module doing the import.\t\r", "\t\t\t#print( \"from .%s import * \" % modName)\r", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\r", "\t\t\t#import traceback\r", "\t\t\t#print(\"[Error importing module: %s]\" % modName)\r", "#def importAll(path, globals, locals, excludes=()):\r", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\r", "\t#mods = importModules(path, globals, locals, excludes)\r", "# Dynamic imports are disabled. This causes too many problems.\r", "#importAll('graphicsItems', globals(), locals())\r", "#importAll('widgets', globals(), locals(),\r", "from .graphicsItems.VTickGroup import * \r", "from .graphicsItems.GraphicsWidget import * \r", "from .graphicsItems.ScaleBar import * \r", "from .graphicsItems.PlotDataItem import * \r", "from .graphicsItems.GraphItem import * \r", "from .graphicsItems.TextItem import * \r", "from .graphicsItems.GraphicsLayout import * \r", "from .graphicsItems.UIGraphicsItem import * \r", "from .graphicsItems.GraphicsObject import * \r", "from .graphicsItems.PlotItem import * \r", "from .graphicsItems.ROI import * \r", "from .graphicsItems.InfiniteLine import * \r", "from .graphicsItems.HistogramLUTItem import * \r", "from .graphicsItems.GridItem import * \r", "from .graphicsItems.GradientLegend import * \r", "from .graphicsItems.GraphicsItem import * \r", "from .graphicsItems.BarGraphItem import * \r", "from .graphicsItems.ViewBox import * \r", "from .graphicsItems.ArrowItem import * \r", "from .graphicsItems.ImageItem import * \r", "from .graphicsItems.AxisItem import * \r", "from .graphicsItems.LabelItem import * \r", "from .graphicsItems.CurvePoint import * \r", "from .graphicsItems.GraphicsWidgetAnchor import * \r", "from .graphicsItems.PlotCurveItem import * \r", "from .graphicsItems.ButtonItem import * \r", "from .graphicsItems.GradientEditorItem import * \r", "from .graphicsItems.MultiPlotItem import * \r", "from .graphicsItems.ErrorBarItem import * \r", "from .graphicsItems.IsocurveItem import * \r", "from .graphicsItems.LinearRegionItem import * \r", "from .graphicsItems.FillBetweenItem import * \r", "from .graphicsItems.LegendItem import * \r", "from .graphicsItems.ScatterPlotItem import * \r", "from .graphicsItems.ItemGroup import * \r", "from .widgets.MultiPlotWidget import * \r", "from .widgets.ScatterPlotWidget import * \r", "from .widgets.ColorMapWidget import * \r", "from .widgets.FileDialog import * \r", "from .widgets.ValueLabel import * \r", "from .widgets.HistogramLUTWidget import * \r", "from .widgets.CheckTable import * \r", "from .widgets.BusyCursor import * \r", "from .widgets.PlotWidget import * \r", "from .widgets.ComboBox import * \r", "from .widgets.GradientWidget import * \r", "from .widgets.DataFilterWidget import * \r", "from .widgets.SpinBox import * \r", "from .widgets.JoystickButton import * \r", "from .widgets.GraphicsLayoutWidget import * \r", "from .widgets.TreeWidget import * \r", "from .widgets.PathButton import * \r", "from .widgets.VerticalLabel import * \r", "from .widgets.FeedbackButton import * \r", "from .widgets.ColorButton import * \r", "from .widgets.DataTreeWidget import * \r", "from .widgets.GraphicsView import * \r", "from .widgets.LayoutWidget import * \r", "from .widgets.TableWidget import * \r", "from .widgets.ProgressDialog import *\r", "from .imageview import *\r", "from .WidgetGroup import *\r", "from .Point import Point\r", "from .Vector import Vector\r", "from .SRTTransform import SRTTransform\r", "from .Transform3D import Transform3D\r", "from .SRTTransform3D import SRTTransform3D\r", "from .functions import *\r", "from .graphicsWindows import *\r", "from .SignalProxy import *\r", "from .colormap import *\r", "from .ptime import time\r", "from .Qt import isQObjectAlive\r", "import atexit\r", "\timport gc\r", "\tfrom . import console\r"]}, {"term": "def", "name": "image", "data": "def image(*args, **kargs):\r\n\t\"\"\"\r\n\tCreate and return an :class:`ImageWindow ` \r\n\t(this is just a window with :class:`ImageView ` widget inside), show image data inside.\r\n\tWill show 2D or 3D image data.\r\n\tAccepts a *title* argument to set the title of the window.\r\n\tAll other arguments are used to show data. (see :func:`ImageView.setImage() `)\r\n\t\"\"\"\r\n\tmkQApp()\r\n\tw = ImageWindow(*args, **kargs)\r\n\timages.append(w)\r\n\tw.show()\r\n", "description": "\r\n\tCreate and return an :class:`ImageWindow ` \r\n\t(this is just a window with :class:`ImageView ` widget inside), show image data inside.\r\n\tWill show 2D or 3D image data.\r\n\tAccepts a *title* argument to set the title of the window.\r\n\tAll other arguments are used to show data. (see :func:`ImageView.setImage() `)\r\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use\r", "from .Qt import QtGui\r", "import numpy  ## pyqtgraph requires numpy\r", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)\r", "import os, sys\r", "from . import python2_3\r", "from . import numpy_fix\r", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')\r", "\tfrom .Qt import VERSION_INFO\r", "\timport pprint\r", "\t### This eliminates the problem of accidental stale pyc file imports.\"\r", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea\r", "## these must be imported separately.\r", "#from . import frozenSupport\r", "#def importModules(path, globals, locals, excludes=()):\r", "\t#Note that *path* MUST be relative to the module doing the import.\t\r", "\t\t\t#print( \"from .%s import * \" % modName)\r", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\r", "\t\t\t#import traceback\r", "\t\t\t#print(\"[Error importing module: %s]\" % modName)\r", "#def importAll(path, globals, locals, excludes=()):\r", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\r", "\t#mods = importModules(path, globals, locals, excludes)\r", "# Dynamic imports are disabled. This causes too many problems.\r", "#importAll('graphicsItems', globals(), locals())\r", "#importAll('widgets', globals(), locals(),\r", "from .graphicsItems.VTickGroup import * \r", "from .graphicsItems.GraphicsWidget import * \r", "from .graphicsItems.ScaleBar import * \r", "from .graphicsItems.PlotDataItem import * \r", "from .graphicsItems.GraphItem import * \r", "from .graphicsItems.TextItem import * \r", "from .graphicsItems.GraphicsLayout import * \r", "from .graphicsItems.UIGraphicsItem import * \r", "from .graphicsItems.GraphicsObject import * \r", "from .graphicsItems.PlotItem import * \r", "from .graphicsItems.ROI import * \r", "from .graphicsItems.InfiniteLine import * \r", "from .graphicsItems.HistogramLUTItem import * \r", "from .graphicsItems.GridItem import * \r", "from .graphicsItems.GradientLegend import * \r", "from .graphicsItems.GraphicsItem import * \r", "from .graphicsItems.BarGraphItem import * \r", "from .graphicsItems.ViewBox import * \r", "from .graphicsItems.ArrowItem import * \r", "from .graphicsItems.ImageItem import * \r", "from .graphicsItems.AxisItem import * \r", "from .graphicsItems.LabelItem import * \r", "from .graphicsItems.CurvePoint import * \r", "from .graphicsItems.GraphicsWidgetAnchor import * \r", "from .graphicsItems.PlotCurveItem import * \r", "from .graphicsItems.ButtonItem import * \r", "from .graphicsItems.GradientEditorItem import * \r", "from .graphicsItems.MultiPlotItem import * \r", "from .graphicsItems.ErrorBarItem import * \r", "from .graphicsItems.IsocurveItem import * \r", "from .graphicsItems.LinearRegionItem import * \r", "from .graphicsItems.FillBetweenItem import * \r", "from .graphicsItems.LegendItem import * \r", "from .graphicsItems.ScatterPlotItem import * \r", "from .graphicsItems.ItemGroup import * \r", "from .widgets.MultiPlotWidget import * \r", "from .widgets.ScatterPlotWidget import * \r", "from .widgets.ColorMapWidget import * \r", "from .widgets.FileDialog import * \r", "from .widgets.ValueLabel import * \r", "from .widgets.HistogramLUTWidget import * \r", "from .widgets.CheckTable import * \r", "from .widgets.BusyCursor import * \r", "from .widgets.PlotWidget import * \r", "from .widgets.ComboBox import * \r", "from .widgets.GradientWidget import * \r", "from .widgets.DataFilterWidget import * \r", "from .widgets.SpinBox import * \r", "from .widgets.JoystickButton import * \r", "from .widgets.GraphicsLayoutWidget import * \r", "from .widgets.TreeWidget import * \r", "from .widgets.PathButton import * \r", "from .widgets.VerticalLabel import * \r", "from .widgets.FeedbackButton import * \r", "from .widgets.ColorButton import * \r", "from .widgets.DataTreeWidget import * \r", "from .widgets.GraphicsView import * \r", "from .widgets.LayoutWidget import * \r", "from .widgets.TableWidget import * \r", "from .widgets.ProgressDialog import *\r", "from .imageview import *\r", "from .WidgetGroup import *\r", "from .Point import Point\r", "from .Vector import Vector\r", "from .SRTTransform import SRTTransform\r", "from .Transform3D import Transform3D\r", "from .SRTTransform3D import SRTTransform3D\r", "from .functions import *\r", "from .graphicsWindows import *\r", "from .SignalProxy import *\r", "from .colormap import *\r", "from .ptime import time\r", "from .Qt import isQObjectAlive\r", "import atexit\r", "\timport gc\r", "\tfrom . import console\r"]}, {"term": "def", "name": "dbg", "data": "def dbg(*args, **kwds):\r\n\t\"\"\"\r\n\tCreate a console window and begin watching for exceptions.\r\n\t\r\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\r\n\t\"\"\"\r\n\tmkQApp()\r\n\tfrom . import console\r\n\tc = console.ConsoleWidget(*args, **kwds)\r\n\tc.catchAllExceptions()\r\n\tc.show()\r\n\tglobal consoles\r\n\ttry:\r\n\t\tconsoles.append(c)\r\n\texcept NameError:\r\n\t\tconsoles = [c]\r\n\treturn c\r\n\t\r\n", "description": "\r\n\tCreate a console window and begin watching for exceptions.\r\n\t\r\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\r\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use\r", "from .Qt import QtGui\r", "import numpy  ## pyqtgraph requires numpy\r", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)\r", "import os, sys\r", "from . import python2_3\r", "from . import numpy_fix\r", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')\r", "\tfrom .Qt import VERSION_INFO\r", "\timport pprint\r", "\t### This eliminates the problem of accidental stale pyc file imports.\"\r", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea\r", "## these must be imported separately.\r", "#from . import frozenSupport\r", "#def importModules(path, globals, locals, excludes=()):\r", "\t#Note that *path* MUST be relative to the module doing the import.\t\r", "\t\t\t#print( \"from .%s import * \" % modName)\r", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\r", "\t\t\t#import traceback\r", "\t\t\t#print(\"[Error importing module: %s]\" % modName)\r", "#def importAll(path, globals, locals, excludes=()):\r", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\r", "\t#mods = importModules(path, globals, locals, excludes)\r", "# Dynamic imports are disabled. This causes too many problems.\r", "#importAll('graphicsItems', globals(), locals())\r", "#importAll('widgets', globals(), locals(),\r", "from .graphicsItems.VTickGroup import * \r", "from .graphicsItems.GraphicsWidget import * \r", "from .graphicsItems.ScaleBar import * \r", "from .graphicsItems.PlotDataItem import * \r", "from .graphicsItems.GraphItem import * \r", "from .graphicsItems.TextItem import * \r", "from .graphicsItems.GraphicsLayout import * \r", "from .graphicsItems.UIGraphicsItem import * \r", "from .graphicsItems.GraphicsObject import * \r", "from .graphicsItems.PlotItem import * \r", "from .graphicsItems.ROI import * \r", "from .graphicsItems.InfiniteLine import * \r", "from .graphicsItems.HistogramLUTItem import * \r", "from .graphicsItems.GridItem import * \r", "from .graphicsItems.GradientLegend import * \r", "from .graphicsItems.GraphicsItem import * \r", "from .graphicsItems.BarGraphItem import * \r", "from .graphicsItems.ViewBox import * \r", "from .graphicsItems.ArrowItem import * \r", "from .graphicsItems.ImageItem import * \r", "from .graphicsItems.AxisItem import * \r", "from .graphicsItems.LabelItem import * \r", "from .graphicsItems.CurvePoint import * \r", "from .graphicsItems.GraphicsWidgetAnchor import * \r", "from .graphicsItems.PlotCurveItem import * \r", "from .graphicsItems.ButtonItem import * \r", "from .graphicsItems.GradientEditorItem import * \r", "from .graphicsItems.MultiPlotItem import * \r", "from .graphicsItems.ErrorBarItem import * \r", "from .graphicsItems.IsocurveItem import * \r", "from .graphicsItems.LinearRegionItem import * \r", "from .graphicsItems.FillBetweenItem import * \r", "from .graphicsItems.LegendItem import * \r", "from .graphicsItems.ScatterPlotItem import * \r", "from .graphicsItems.ItemGroup import * \r", "from .widgets.MultiPlotWidget import * \r", "from .widgets.ScatterPlotWidget import * \r", "from .widgets.ColorMapWidget import * \r", "from .widgets.FileDialog import * \r", "from .widgets.ValueLabel import * \r", "from .widgets.HistogramLUTWidget import * \r", "from .widgets.CheckTable import * \r", "from .widgets.BusyCursor import * \r", "from .widgets.PlotWidget import * \r", "from .widgets.ComboBox import * \r", "from .widgets.GradientWidget import * \r", "from .widgets.DataFilterWidget import * \r", "from .widgets.SpinBox import * \r", "from .widgets.JoystickButton import * \r", "from .widgets.GraphicsLayoutWidget import * \r", "from .widgets.TreeWidget import * \r", "from .widgets.PathButton import * \r", "from .widgets.VerticalLabel import * \r", "from .widgets.FeedbackButton import * \r", "from .widgets.ColorButton import * \r", "from .widgets.DataTreeWidget import * \r", "from .widgets.GraphicsView import * \r", "from .widgets.LayoutWidget import * \r", "from .widgets.TableWidget import * \r", "from .widgets.ProgressDialog import *\r", "from .imageview import *\r", "from .WidgetGroup import *\r", "from .Point import Point\r", "from .Vector import Vector\r", "from .SRTTransform import SRTTransform\r", "from .Transform3D import Transform3D\r", "from .SRTTransform3D import SRTTransform3D\r", "from .functions import *\r", "from .graphicsWindows import *\r", "from .SignalProxy import *\r", "from .colormap import *\r", "from .ptime import time\r", "from .Qt import isQObjectAlive\r", "import atexit\r", "\timport gc\r", "\tfrom . import console\r"]}, {"term": "def", "name": "mkQApp", "data": "def mkQApp():\r\n\tglobal QAPP\r\n\tinst = QtGui.QApplication.instance()\r\n\tif inst is None:\r\n\t\tQAPP = QtGui.QApplication([])\r\n\telse:\r\n\t\tQAPP = inst\r\n\treturn QAPP\r\n\t\t\r\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use\r", "from .Qt import QtGui\r", "import numpy  ## pyqtgraph requires numpy\r", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)\r", "import os, sys\r", "from . import python2_3\r", "from . import numpy_fix\r", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')\r", "\tfrom .Qt import VERSION_INFO\r", "\timport pprint\r", "\t### This eliminates the problem of accidental stale pyc file imports.\"\r", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea\r", "## these must be imported separately.\r", "#from . import frozenSupport\r", "#def importModules(path, globals, locals, excludes=()):\r", "\t#Note that *path* MUST be relative to the module doing the import.\t\r", "\t\t\t#print( \"from .%s import * \" % modName)\r", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\r", "\t\t\t#import traceback\r", "\t\t\t#print(\"[Error importing module: %s]\" % modName)\r", "#def importAll(path, globals, locals, excludes=()):\r", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\r", "\t#mods = importModules(path, globals, locals, excludes)\r", "# Dynamic imports are disabled. This causes too many problems.\r", "#importAll('graphicsItems', globals(), locals())\r", "#importAll('widgets', globals(), locals(),\r", "from .graphicsItems.VTickGroup import * \r", "from .graphicsItems.GraphicsWidget import * \r", "from .graphicsItems.ScaleBar import * \r", "from .graphicsItems.PlotDataItem import * \r", "from .graphicsItems.GraphItem import * \r", "from .graphicsItems.TextItem import * \r", "from .graphicsItems.GraphicsLayout import * \r", "from .graphicsItems.UIGraphicsItem import * \r", "from .graphicsItems.GraphicsObject import * \r", "from .graphicsItems.PlotItem import * \r", "from .graphicsItems.ROI import * \r", "from .graphicsItems.InfiniteLine import * \r", "from .graphicsItems.HistogramLUTItem import * \r", "from .graphicsItems.GridItem import * \r", "from .graphicsItems.GradientLegend import * \r", "from .graphicsItems.GraphicsItem import * \r", "from .graphicsItems.BarGraphItem import * \r", "from .graphicsItems.ViewBox import * \r", "from .graphicsItems.ArrowItem import * \r", "from .graphicsItems.ImageItem import * \r", "from .graphicsItems.AxisItem import * \r", "from .graphicsItems.LabelItem import * \r", "from .graphicsItems.CurvePoint import * \r", "from .graphicsItems.GraphicsWidgetAnchor import * \r", "from .graphicsItems.PlotCurveItem import * \r", "from .graphicsItems.ButtonItem import * \r", "from .graphicsItems.GradientEditorItem import * \r", "from .graphicsItems.MultiPlotItem import * \r", "from .graphicsItems.ErrorBarItem import * \r", "from .graphicsItems.IsocurveItem import * \r", "from .graphicsItems.LinearRegionItem import * \r", "from .graphicsItems.FillBetweenItem import * \r", "from .graphicsItems.LegendItem import * \r", "from .graphicsItems.ScatterPlotItem import * \r", "from .graphicsItems.ItemGroup import * \r", "from .widgets.MultiPlotWidget import * \r", "from .widgets.ScatterPlotWidget import * \r", "from .widgets.ColorMapWidget import * \r", "from .widgets.FileDialog import * \r", "from .widgets.ValueLabel import * \r", "from .widgets.HistogramLUTWidget import * \r", "from .widgets.CheckTable import * \r", "from .widgets.BusyCursor import * \r", "from .widgets.PlotWidget import * \r", "from .widgets.ComboBox import * \r", "from .widgets.GradientWidget import * \r", "from .widgets.DataFilterWidget import * \r", "from .widgets.SpinBox import * \r", "from .widgets.JoystickButton import * \r", "from .widgets.GraphicsLayoutWidget import * \r", "from .widgets.TreeWidget import * \r", "from .widgets.PathButton import * \r", "from .widgets.VerticalLabel import * \r", "from .widgets.FeedbackButton import * \r", "from .widgets.ColorButton import * \r", "from .widgets.DataTreeWidget import * \r", "from .widgets.GraphicsView import * \r", "from .widgets.LayoutWidget import * \r", "from .widgets.TableWidget import * \r", "from .widgets.ProgressDialog import *\r", "from .imageview import *\r", "from .WidgetGroup import *\r", "from .Point import Point\r", "from .Vector import Vector\r", "from .SRTTransform import SRTTransform\r", "from .Transform3D import Transform3D\r", "from .SRTTransform3D import SRTTransform3D\r", "from .functions import *\r", "from .graphicsWindows import *\r", "from .SignalProxy import *\r", "from .colormap import *\r", "from .ptime import time\r", "from .Qt import isQObjectAlive\r", "import atexit\r", "\timport gc\r", "\tfrom . import console\r"]}], [{"term": "def", "name": "setConfigOption", "data": "def setConfigOption(opt, value):\n\tglobal CONFIG_OPTIONS\n\tif opt not in CONFIG_OPTIONS:\n\t\traise KeyError('Unknown configuration option \"%s\"' % opt)\n\tif opt == 'imageAxisOrder' and value not in ('row-major', 'col-major'):\n\t\traise ValueError('imageAxisOrder must be either \"row-major\" or \"col-major\"')\n\tCONFIG_OPTIONS[opt] = value\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "setConfigOptions", "data": "def setConfigOptions(**opts):\n\t\"\"\"Set global configuration options. \n\t\n\tEach keyword argument sets one global option. \n\t\"\"\"\n\tfor k,v in opts.items():\n\t\tsetConfigOption(k, v)\n", "description": "Set global configuration options. \n\t\n\tEach keyword argument sets one global option. \n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "getConfigOption", "data": "def getConfigOption(opt):\n\t\"\"\"Return the value of a single global configuration option.\n\t\"\"\"\n\treturn CONFIG_OPTIONS[opt]\n\n", "description": "Return the value of a single global configuration option.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "systemInfo", "data": "def systemInfo():\n\tprint(\"sys.platform: %s\" % sys.platform)\n\tprint(\"sys.version: %s\" % sys.version)\n\tfrom .Qt import VERSION_INFO\n\tprint(\"qt bindings: %s\" % VERSION_INFO)\n\t\n\tglobal __version__\n\trev = None\n\tif __version__ is None:  ## this code was probably checked out from bzr; look up the last-revision file\n\t\tlastRevFile = os.path.join(os.path.dirname(__file__), '..', '.bzr', 'branch', 'last-revision')\n\t\tif os.path.exists(lastRevFile):\n\t\t\trev = open(lastRevFile, 'r').read().strip()\n\t\n\tprint(\"pyqtgraph: %s; %s\" % (__version__, rev))\n\tprint(\"config:\")\n\timport pprint\n\tpprint.pprint(CONFIG_OPTIONS)\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "renamePyc", "data": "def renamePyc(startDir):\n\t### Used to rename orphaned .pyc files\n\t### When a python file changes its location in the repository, usually the .pyc file\n\t### is left behind, possibly causing mysterious and difficult to track bugs. \n\n\t### Note that this is no longer necessary for python 3.2; from PEP 3147:\n\t### \"If the py source file is missing, the pyc file inside __pycache__ will be ignored. \n\t### This eliminates the problem of accidental stale pyc file imports.\"\n\t\n\tprinted = False\n\tstartDir = os.path.abspath(startDir)\n\tfor path, dirs, files in os.walk(startDir):\n\t\tif '__pycache__' in path:\n\t\t\tcontinue\n\t\tfor f in files:\n\t\t\tfileName = os.path.join(path, f)\n\t\t\tbase, ext = os.path.splitext(fileName)\n\t\t\tpy = base + \".py\"\n\t\t\tif ext == '.pyc' and not os.path.isfile(py):\n\t\t\t\tif not printed:\n\t\t\t\t\tprint(\"NOTE: Renaming orphaned .pyc files:\")\n\t\t\t\t\tprinted = True\n\t\t\t\tn = 1\n\t\t\t\twhile True:\n\t\t\t\t\tname2 = fileName + \".renamed%d\" % n\n\t\t\t\t\tif not os.path.exists(name2):\n\t\t\t\t\t\tbreak\n\t\t\t\t\tn += 1\n\t\t\t\tprint(\"  \" + fileName + \"  ==>\")\n\t\t\t\tprint(\"  \" + name2)\n\t\t\t\tos.rename(fileName, name2)\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "fimportModules", "data": "#def importModules(path, globals, locals, excludes=()):\n\t#\"\"\"Import all modules residing within *path*, return a dict of name: module pairs.\n\t\n\t#Note that *path* MUST be relative to the module doing the import.\t\n\t#\"\"\"\n\t#d = os.path.join(os.path.split(globals['__file__'])[0], path)\n\t#files = set()\n\t#for f in frozenSupport.listdir(d):\n\t\t#if frozenSupport.isdir(os.path.join(d, f)) and f not in ['__pycache__', 'tests']:\n\t\t\t#files.add(f)\n\t\t#elif f[-3:] == '.py' and f != '__init__.py':\n\t\t\t#files.add(f[:-3])\n\t\t#elif f[-4:] == '.pyc' and f != '__init__.pyc':\n\t\t\t#files.add(f[:-4])\n\t\t\n\t#mods = {}\n\t#path = path.replace(os.sep, '.')\n\t#for modName in files:\n\t\t#if modName in excludes:\n\t\t\t#continue\n\t\t#try:\n\t\t\t#if len(path) > 0:\n\t\t\t\t#modName = path + '.' + modName\n\t\t\t#print( \"from .%s import * \" % modName)\n\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\n\t\t\t#mods[modName] = mod\n\t\t#except:\n\t\t\t#import traceback\n\t\t\t#traceback.print_stack()\n\t\t\t#sys.excepthook(*sys.exc_info())\n\t\t\t#print(\"[Error importing module: %s]\" % modName)\n\t\t\t\n\t#return mods\n", "description": "Import all modules residing within *path*, return a dict of name: module pairs.\n\t\n\t#Note that *path* MUST be relative to the module doing the import.\t\n\t#", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "fimportAll", "data": "#def importAll(path, globals, locals, excludes=()):\n\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\n\t#mods = importModules(path, globals, locals, excludes)\n\t#for mod in mods.values():\n\t\t#if hasattr(mod, '__all__'):\n\t\t\t#names = mod.__all__\n\t\t#else:\n\t\t\t#names = [n for n in dir(mod) if n[0] != '_']\n\t\t#for k in names:\n\t\t\t#if hasattr(mod, k):\n\t\t\t\t#globals[k] = getattr(mod, k)\n", "description": "Given a list of modules, import all names from each module into the global namespace.", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "cleanup", "data": "def cleanup():\n\tglobal _cleanupCalled\n\tif _cleanupCalled:\n\t\treturn\n\t\n\tif not getConfigOption('exitCleanup'):\n\t\treturn\n\t\n\tViewBox.quit()  ## tell ViewBox that it doesn't need to deregister views anymore.\n\t\n\t## Workaround for Qt exit crash:\n\t## ALL QGraphicsItems must have a scene before they are deleted.\n\t## This is potentially very expensive, but preferred over crashing.\n\t## Note: this appears to be fixed in PySide as of 2012.12, but it should be left in for a while longer..\n\tif QtGui.QApplication.instance() is None:\n\t\treturn\n\timport gc\n\ts = QtGui.QGraphicsScene()\n\tfor o in gc.get_objects():\n\t\ttry:\n\t\t\tif isinstance(o, QtGui.QGraphicsItem) and isQObjectAlive(o) and o.scene() is None:\n\t\t\t\tif getConfigOption('crashWarning'):\n\t\t\t\t\tsys.stderr.write('Error: graphics item without scene. '\n\t\t\t\t\t\t'Make sure ViewBox.close() and GraphicsView.close() '\n\t\t\t\t\t\t'are properly called before app shutdown (%s)\\n' % (o,))\n\t\t\t\t\n\t\t\t\ts.addItem(o)\n\t\texcept RuntimeError:  ## occurs if a python wrapper no longer has its underlying C++ object\n\t\t\tcontinue\n\t_cleanupCalled = True\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "_connectCleanup", "data": "def _connectCleanup():\n\tglobal _cleanupConnected\n\tif _cleanupConnected:\n\t\treturn\n\tQtGui.QApplication.instance().aboutToQuit.connect(cleanup)\n\t_cleanupConnected = True\n\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "exit", "data": "def exit():\n\t\"\"\"\n\tCauses python to exit without garbage-collecting any objects, and thus avoids\n\tcalling object destructor methods. This is a sledgehammer workaround for \n\ta variety of bugs in PyQt and Pyside that cause crashes on exit.\n\t\n\tThis function does the following in an attempt to 'safely' terminate\n\tthe process:\n\t\n\t* Invoke atexit callbacks\n\t* Close all open file handles\n\t* os._exit()\n\t\n\tNote: there is some potential for causing damage with this function if you\n\tare using objects that _require_ their destructors to be called (for example,\n\tto properly terminate log files, disconnect from devices, etc). Situations\n\tlike this are probably quite rare, but use at your own risk.\n\t\"\"\"\n\t\n\t## first disable our own cleanup function; won't be needing it.\n\tsetConfigOptions(exitCleanup=False)\n\t\n\t## invoke atexit callbacks\n\tatexit._run_exitfuncs()\n\t\n\t## close file handles\n\tif sys.platform == 'darwin':\n\t\tfor fd in range(3, 4096):\n\t\t\tif fd not in [7]:  # trying to close 7 produces an illegal instruction on the Mac.\n\t\t\t\tos.close(fd)\n\telse:\n\t\tos.closerange(3, 4096) ## just guessing on the maximum descriptor count..\n\n\tos._exit(0)\n\t\n\n", "description": "\n\tCauses python to exit without garbage-collecting any objects, and thus avoids\n\tcalling object destructor methods. This is a sledgehammer workaround for \n\ta variety of bugs in PyQt and Pyside that cause crashes on exit.\n\t\n\tThis function does the following in an attempt to 'safely' terminate\n\tthe process:\n\t\n\t* Invoke atexit callbacks\n\t* Close all open file handles\n\t* os._exit()\n\t\n\tNote: there is some potential for causing damage with this function if you\n\tare using objects that _require_ their destructors to be called (for example,\n\tto properly terminate log files, disconnect from devices, etc). Situations\n\tlike this are probably quite rare, but use at your own risk.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "plot", "data": "def plot(*args, **kargs):\n\t\"\"\"\n\tCreate and return a :class:`PlotWindow ` \n\t(this is just a window with :class:`PlotWidget ` inside), plot data in it.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to plot data. (see :func:`PlotItem.plot() `)\n\t\"\"\"\n\tmkQApp()\n\t#if 'title' in kargs:\n\t\t#w = PlotWindow(title=kargs['title'])\n\t\t#del kargs['title']\n\t#else:\n\t\t#w = PlotWindow()\n\t#if len(args)+len(kargs) > 0:\n\t\t#w.plot(*args, **kargs)\n\t\t\n\tpwArgList = ['title', 'labels', 'name', 'left', 'right', 'top', 'bottom', 'background']\n\tpwArgs = {}\n\tdataArgs = {}\n\tfor k in kargs:\n\t\tif k in pwArgList:\n\t\t\tpwArgs[k] = kargs[k]\n\t\telse:\n\t\t\tdataArgs[k] = kargs[k]\n\t\t\n\tw = PlotWindow(**pwArgs)\n\tif len(args) > 0 or len(dataArgs) > 0:\n\t\tw.plot(*args, **dataArgs)\n\tplots.append(w)\n\tw.show()\n\treturn w\n", "description": "\n\tCreate and return a :class:`PlotWindow ` \n\t(this is just a window with :class:`PlotWidget ` inside), plot data in it.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to plot data. (see :func:`PlotItem.plot() `)\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "image", "data": "def image(*args, **kargs):\n\t\"\"\"\n\tCreate and return an :class:`ImageWindow ` \n\t(this is just a window with :class:`ImageView ` widget inside), show image data inside.\n\tWill show 2D or 3D image data.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to show data. (see :func:`ImageView.setImage() `)\n\t\"\"\"\n\tmkQApp()\n\tw = ImageWindow(*args, **kargs)\n\timages.append(w)\n\tw.show()\n", "description": "\n\tCreate and return an :class:`ImageWindow ` \n\t(this is just a window with :class:`ImageView ` widget inside), show image data inside.\n\tWill show 2D or 3D image data.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to show data. (see :func:`ImageView.setImage() `)\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "dbg", "data": "def dbg(*args, **kwds):\n\t\"\"\"\n\tCreate a console window and begin watching for exceptions.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t\"\"\"\n\tmkQApp()\n\tfrom . import console\n\tc = console.ConsoleWidget(*args, **kwds)\n\tc.catchAllExceptions()\n\tc.show()\n\tglobal consoles\n\ttry:\n\t\tconsoles.append(c)\n\texcept NameError:\n\t\tconsoles = [c]\n\treturn c\n\t\n", "description": "\n\tCreate a console window and begin watching for exceptions.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "mkQApp", "data": "def mkQApp():\n\tglobal QAPP\n\tinst = QtGui.QApplication.instance()\n\tif inst is None:\n\t\tQAPP = QtGui.QApplication([])\n\telse:\n\t\tQAPP = inst\n\treturn QAPP\n\t\t\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}], [{"term": "def", "name": "setConfigOption", "data": "def setConfigOption(opt, value):\n\tglobal CONFIG_OPTIONS\n\tif opt not in CONFIG_OPTIONS:\n\t\traise KeyError('Unknown configuration option \"%s\"' % opt)\n\tif opt == 'imageAxisOrder' and value not in ('row-major', 'col-major'):\n\t\traise ValueError('imageAxisOrder must be either \"row-major\" or \"col-major\"')\n\tCONFIG_OPTIONS[opt] = value\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "setConfigOptions", "data": "def setConfigOptions(**opts):\n\t\"\"\"Set global configuration options. \n\t\n\tEach keyword argument sets one global option. \n\t\"\"\"\n\tfor k,v in opts.items():\n\t\tsetConfigOption(k, v)\n", "description": "Set global configuration options. \n\t\n\tEach keyword argument sets one global option. \n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "getConfigOption", "data": "def getConfigOption(opt):\n\t\"\"\"Return the value of a single global configuration option.\n\t\"\"\"\n\treturn CONFIG_OPTIONS[opt]\n\n", "description": "Return the value of a single global configuration option.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "systemInfo", "data": "def systemInfo():\n\tprint(\"sys.platform: %s\" % sys.platform)\n\tprint(\"sys.version: %s\" % sys.version)\n\tfrom .Qt import VERSION_INFO\n\tprint(\"qt bindings: %s\" % VERSION_INFO)\n\t\n\tglobal __version__\n\trev = None\n\tif __version__ is None:  ## this code was probably checked out from bzr; look up the last-revision file\n\t\tlastRevFile = os.path.join(os.path.dirname(__file__), '..', '.bzr', 'branch', 'last-revision')\n\t\tif os.path.exists(lastRevFile):\n\t\t\trev = open(lastRevFile, 'r').read().strip()\n\t\n\tprint(\"pyqtgraph: %s; %s\" % (__version__, rev))\n\tprint(\"config:\")\n\timport pprint\n\tpprint.pprint(CONFIG_OPTIONS)\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "renamePyc", "data": "def renamePyc(startDir):\n\t### Used to rename orphaned .pyc files\n\t### When a python file changes its location in the repository, usually the .pyc file\n\t### is left behind, possibly causing mysterious and difficult to track bugs. \n\n\t### Note that this is no longer necessary for python 3.2; from PEP 3147:\n\t### \"If the py source file is missing, the pyc file inside __pycache__ will be ignored. \n\t### This eliminates the problem of accidental stale pyc file imports.\"\n\t\n\tprinted = False\n\tstartDir = os.path.abspath(startDir)\n\tfor path, dirs, files in os.walk(startDir):\n\t\tif '__pycache__' in path:\n\t\t\tcontinue\n\t\tfor f in files:\n\t\t\tfileName = os.path.join(path, f)\n\t\t\tbase, ext = os.path.splitext(fileName)\n\t\t\tpy = base + \".py\"\n\t\t\tif ext == '.pyc' and not os.path.isfile(py):\n\t\t\t\tif not printed:\n\t\t\t\t\tprint(\"NOTE: Renaming orphaned .pyc files:\")\n\t\t\t\t\tprinted = True\n\t\t\t\tn = 1\n\t\t\t\twhile True:\n\t\t\t\t\tname2 = fileName + \".renamed%d\" % n\n\t\t\t\t\tif not os.path.exists(name2):\n\t\t\t\t\t\tbreak\n\t\t\t\t\tn += 1\n\t\t\t\tprint(\"  \" + fileName + \"  ==>\")\n\t\t\t\tprint(\"  \" + name2)\n\t\t\t\tos.rename(fileName, name2)\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "fimportModules", "data": "#def importModules(path, globals, locals, excludes=()):\n\t#\"\"\"Import all modules residing within *path*, return a dict of name: module pairs.\n\t\n\t#Note that *path* MUST be relative to the module doing the import.\t\n\t#\"\"\"\n\t#d = os.path.join(os.path.split(globals['__file__'])[0], path)\n\t#files = set()\n\t#for f in frozenSupport.listdir(d):\n\t\t#if frozenSupport.isdir(os.path.join(d, f)) and f not in ['__pycache__', 'tests']:\n\t\t\t#files.add(f)\n\t\t#elif f[-3:] == '.py' and f != '__init__.py':\n\t\t\t#files.add(f[:-3])\n\t\t#elif f[-4:] == '.pyc' and f != '__init__.pyc':\n\t\t\t#files.add(f[:-4])\n\t\t\n\t#mods = {}\n\t#path = path.replace(os.sep, '.')\n\t#for modName in files:\n\t\t#if modName in excludes:\n\t\t\t#continue\n\t\t#try:\n\t\t\t#if len(path) > 0:\n\t\t\t\t#modName = path + '.' + modName\n\t\t\t#print( \"from .%s import * \" % modName)\n\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\n\t\t\t#mods[modName] = mod\n\t\t#except:\n\t\t\t#import traceback\n\t\t\t#traceback.print_stack()\n\t\t\t#sys.excepthook(*sys.exc_info())\n\t\t\t#print(\"[Error importing module: %s]\" % modName)\n\t\t\t\n\t#return mods\n", "description": "Import all modules residing within *path*, return a dict of name: module pairs.\n\t\n\t#Note that *path* MUST be relative to the module doing the import.\t\n\t#", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "fimportAll", "data": "#def importAll(path, globals, locals, excludes=()):\n\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\n\t#mods = importModules(path, globals, locals, excludes)\n\t#for mod in mods.values():\n\t\t#if hasattr(mod, '__all__'):\n\t\t\t#names = mod.__all__\n\t\t#else:\n\t\t\t#names = [n for n in dir(mod) if n[0] != '_']\n\t\t#for k in names:\n\t\t\t#if hasattr(mod, k):\n\t\t\t\t#globals[k] = getattr(mod, k)\n", "description": "Given a list of modules, import all names from each module into the global namespace.", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "cleanup", "data": "def cleanup():\n\tglobal _cleanupCalled\n\tif _cleanupCalled:\n\t\treturn\n\t\n\tif not getConfigOption('exitCleanup'):\n\t\treturn\n\t\n\tViewBox.quit()  ## tell ViewBox that it doesn't need to deregister views anymore.\n\t\n\t## Workaround for Qt exit crash:\n\t## ALL QGraphicsItems must have a scene before they are deleted.\n\t## This is potentially very expensive, but preferred over crashing.\n\t## Note: this appears to be fixed in PySide as of 2012.12, but it should be left in for a while longer..\n\tif QtGui.QApplication.instance() is None:\n\t\treturn\n\timport gc\n\ts = QtGui.QGraphicsScene()\n\tfor o in gc.get_objects():\n\t\ttry:\n\t\t\tif isinstance(o, QtGui.QGraphicsItem) and isQObjectAlive(o) and o.scene() is None:\n\t\t\t\tif getConfigOption('crashWarning'):\n\t\t\t\t\tsys.stderr.write('Error: graphics item without scene. '\n\t\t\t\t\t\t'Make sure ViewBox.close() and GraphicsView.close() '\n\t\t\t\t\t\t'are properly called before app shutdown (%s)\\n' % (o,))\n\t\t\t\t\n\t\t\t\ts.addItem(o)\n\t\texcept RuntimeError:  ## occurs if a python wrapper no longer has its underlying C++ object\n\t\t\tcontinue\n\t_cleanupCalled = True\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "_connectCleanup", "data": "def _connectCleanup():\n\tglobal _cleanupConnected\n\tif _cleanupConnected:\n\t\treturn\n\tQtGui.QApplication.instance().aboutToQuit.connect(cleanup)\n\t_cleanupConnected = True\n\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "exit", "data": "def exit():\n\t\"\"\"\n\tCauses python to exit without garbage-collecting any objects, and thus avoids\n\tcalling object destructor methods. This is a sledgehammer workaround for \n\ta variety of bugs in PyQt and Pyside that cause crashes on exit.\n\t\n\tThis function does the following in an attempt to 'safely' terminate\n\tthe process:\n\t\n\t* Invoke atexit callbacks\n\t* Close all open file handles\n\t* os._exit()\n\t\n\tNote: there is some potential for causing damage with this function if you\n\tare using objects that _require_ their destructors to be called (for example,\n\tto properly terminate log files, disconnect from devices, etc). Situations\n\tlike this are probably quite rare, but use at your own risk.\n\t\"\"\"\n\t\n\t## first disable our own cleanup function; won't be needing it.\n\tsetConfigOptions(exitCleanup=False)\n\t\n\t## invoke atexit callbacks\n\tatexit._run_exitfuncs()\n\t\n\t## close file handles\n\tif sys.platform == 'darwin':\n\t\tfor fd in range(3, 4096):\n\t\t\tif fd not in [7]:  # trying to close 7 produces an illegal instruction on the Mac.\n\t\t\t\tos.close(fd)\n\telse:\n\t\tos.closerange(3, 4096) ## just guessing on the maximum descriptor count..\n\n\tos._exit(0)\n\t\n\n", "description": "\n\tCauses python to exit without garbage-collecting any objects, and thus avoids\n\tcalling object destructor methods. This is a sledgehammer workaround for \n\ta variety of bugs in PyQt and Pyside that cause crashes on exit.\n\t\n\tThis function does the following in an attempt to 'safely' terminate\n\tthe process:\n\t\n\t* Invoke atexit callbacks\n\t* Close all open file handles\n\t* os._exit()\n\t\n\tNote: there is some potential for causing damage with this function if you\n\tare using objects that _require_ their destructors to be called (for example,\n\tto properly terminate log files, disconnect from devices, etc). Situations\n\tlike this are probably quite rare, but use at your own risk.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "plot", "data": "def plot(*args, **kargs):\n\t\"\"\"\n\tCreate and return a :class:`PlotWindow ` \n\t(this is just a window with :class:`PlotWidget ` inside), plot data in it.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to plot data. (see :func:`PlotItem.plot() `)\n\t\"\"\"\n\tmkQApp()\n\t#if 'title' in kargs:\n\t\t#w = PlotWindow(title=kargs['title'])\n\t\t#del kargs['title']\n\t#else:\n\t\t#w = PlotWindow()\n\t#if len(args)+len(kargs) > 0:\n\t\t#w.plot(*args, **kargs)\n\t\t\n\tpwArgList = ['title', 'labels', 'name', 'left', 'right', 'top', 'bottom', 'background']\n\tpwArgs = {}\n\tdataArgs = {}\n\tfor k in kargs:\n\t\tif k in pwArgList:\n\t\t\tpwArgs[k] = kargs[k]\n\t\telse:\n\t\t\tdataArgs[k] = kargs[k]\n\t\t\n\tw = PlotWindow(**pwArgs)\n\tif len(args) > 0 or len(dataArgs) > 0:\n\t\tw.plot(*args, **dataArgs)\n\tplots.append(w)\n\tw.show()\n\treturn w\n", "description": "\n\tCreate and return a :class:`PlotWindow ` \n\t(this is just a window with :class:`PlotWidget ` inside), plot data in it.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to plot data. (see :func:`PlotItem.plot() `)\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "image", "data": "def image(*args, **kargs):\n\t\"\"\"\n\tCreate and return an :class:`ImageWindow ` \n\t(this is just a window with :class:`ImageView ` widget inside), show image data inside.\n\tWill show 2D or 3D image data.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to show data. (see :func:`ImageView.setImage() `)\n\t\"\"\"\n\tmkQApp()\n\tw = ImageWindow(*args, **kargs)\n\timages.append(w)\n\tw.show()\n", "description": "\n\tCreate and return an :class:`ImageWindow ` \n\t(this is just a window with :class:`ImageView ` widget inside), show image data inside.\n\tWill show 2D or 3D image data.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to show data. (see :func:`ImageView.setImage() `)\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "dbg", "data": "def dbg(*args, **kwds):\n\t\"\"\"\n\tCreate a console window and begin watching for exceptions.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t\"\"\"\n\tmkQApp()\n\tfrom . import console\n\tc = console.ConsoleWidget(*args, **kwds)\n\tc.catchAllExceptions()\n\tc.show()\n\tglobal consoles\n\ttry:\n\t\tconsoles.append(c)\n\texcept NameError:\n\t\tconsoles = [c]\n\treturn c\n\t\n", "description": "\n\tCreate a console window and begin watching for exceptions.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "mkQApp", "data": "def mkQApp():\n\tglobal QAPP\n\tinst = QtGui.QApplication.instance()\n\tif inst is None:\n\t\tQAPP = QtGui.QApplication([])\n\telse:\n\t\tQAPP = inst\n\treturn QAPP\n\t\t\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}], [{"term": "class", "name": "classAnimationPlayer:", "data": "class AnimationPlayer:\n\tdef __init__(self):\n\t\t# particle dictionary\n\t\tself.frames = {\n\t\t\t\t# magic\n\t\t\t\t'flame': import_folder('./graphics/particles/flame/frames'),\n\t\t\t\t'aura': import_folder('./graphics/particles/aura'),\n\t\t\t\t'heal': import_folder('./graphics/particles/heal/frames'),\n\t\t\t\t\n\t\t\t\t# attacks \n\t\t\t\t'claw': import_folder('./graphics/particles/claw'),\n\t\t\t\t'slash': import_folder('./graphics/particles/slash'),\n\t\t\t\t'sparkle': import_folder('./graphics/particles/sparkle'),\n\t\t\t\t'leaf_attack': import_folder('./graphics/particles/leaf_attack'),\n\t\t\t\t'thunder': import_folder('./graphics/particles/thunder'),\n\t\n\t\t\t\t# deaths\n\t\t\t\t'player': import_folder('./graphics/particles/smoke'),\n\t\t\t\t'squid': import_folder('./graphics/particles/smoke_orange'),\n\t\t\t\t'raccoon': import_folder('./graphics/particles/raccoon'),\n\t\t\t\t'spirit': import_folder('./graphics/particles/nova'),\n\t\t\t\t'bamboo': import_folder('./graphics/particles/bamboo'),\n\t\t\t\t\n\t\t\t\t# leafs \n\t\t\t\t'leaf': (\n\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf1'),\n\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf2'),\n\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf3'),\n\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf4'),\n\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf5'),\n\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf6'),\n\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf1')),\n\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf2')),\n\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf3')),\n\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf4')),\n\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf5')),\n\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf6'))\n\t\t\t\t\t)\n\t\t\t\t}\n\tdef reflect_images(self, frames):\n\t\tnew_frames = []\n\t\t\n\t\tfor frame in frames:\n\t\t\t# flip (x true y false)\n\t\t\tflipped_frame = pygame.transform.flip(frame,True,False)\n\t\t\tnew_frames.append(flipped_frame)\n\t\treturn new_frames\n\n\tdef create_grass_particles(self, pos, groups):\n\t\tanimation_frames = choice(self.frames['leaf'])\n\t\tParticleEffect(pos,animation_frames,groups)\n\n\tdef create_particles(self,animation_type, pos, groups):\n\t\tanimation_frames = self.frames[animation_type]\n\t\tParticleEffect(pos,animation_frames,groups)\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import *", "from random import choice", "\t\t\t\t'flame': import_folder('./graphics/particles/flame/frames'),", "\t\t\t\t'aura': import_folder('./graphics/particles/aura'),", "\t\t\t\t'heal': import_folder('./graphics/particles/heal/frames'),", "\t\t\t\t'claw': import_folder('./graphics/particles/claw'),", "\t\t\t\t'slash': import_folder('./graphics/particles/slash'),", "\t\t\t\t'sparkle': import_folder('./graphics/particles/sparkle'),", "\t\t\t\t'leaf_attack': import_folder('./graphics/particles/leaf_attack'),", "\t\t\t\t'thunder': import_folder('./graphics/particles/thunder'),", "\t\t\t\t'player': import_folder('./graphics/particles/smoke'),", "\t\t\t\t'squid': import_folder('./graphics/particles/smoke_orange'),", "\t\t\t\t'raccoon': import_folder('./graphics/particles/raccoon'),", "\t\t\t\t'spirit': import_folder('./graphics/particles/nova'),", "\t\t\t\t'bamboo': import_folder('./graphics/particles/bamboo'),", "\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf1'),", "\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf2'),", "\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf3'),", "\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf4'),", "\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf5'),", "\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf6'),", "\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf1')),", "\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf2')),", "\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf3')),", "\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf4')),", "\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf5')),", "\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf6'))"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\n\tdef __init__(self, pos, animation_frames, groups):\n\t\tsuper().__init__(groups)\n\t\tself.sprite_type = 'magic'\n\t\tself.frame_index = 0\n\t\tself.animation_speed = 0.15\n\t\tself.frames = animation_frames\n\t\tself.image = self.frames[self.frame_index]\n\t\tself.rect = self.image.get_rect(center = pos)\n\n\tdef animate(self):\n\t\tself.frame_index += self.animation_speed\n\n\t\tif self.frame_index >= len(self.frames):\n\t\t\tself.kill()\n\t\telse:\n\t\t\tself.image = self.frames[int(self.frame_index)]\n\n\tdef update(self):\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import *", "from random import choice", "\t\t\t\t'flame': import_folder('./graphics/particles/flame/frames'),", "\t\t\t\t'aura': import_folder('./graphics/particles/aura'),", "\t\t\t\t'heal': import_folder('./graphics/particles/heal/frames'),", "\t\t\t\t'claw': import_folder('./graphics/particles/claw'),", "\t\t\t\t'slash': import_folder('./graphics/particles/slash'),", "\t\t\t\t'sparkle': import_folder('./graphics/particles/sparkle'),", "\t\t\t\t'leaf_attack': import_folder('./graphics/particles/leaf_attack'),", "\t\t\t\t'thunder': import_folder('./graphics/particles/thunder'),", "\t\t\t\t'player': import_folder('./graphics/particles/smoke'),", "\t\t\t\t'squid': import_folder('./graphics/particles/smoke_orange'),", "\t\t\t\t'raccoon': import_folder('./graphics/particles/raccoon'),", "\t\t\t\t'spirit': import_folder('./graphics/particles/nova'),", "\t\t\t\t'bamboo': import_folder('./graphics/particles/bamboo'),", "\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf1'),", "\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf2'),", "\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf3'),", "\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf4'),", "\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf5'),", "\t\t\t\t\timport_folder_asc_alt('./graphics/particles/leaf6'),", "\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf1')),", "\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf2')),", "\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf3')),", "\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf4')),", "\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf5')),", "\t\t\t\t\tself.reflect_images(import_folder_asc_alt('./graphics/particles/leaf6'))"]}], [{"term": "class", "name": "GraphicsTest", "data": "class GraphicsTest(SampleBase):\n\tdef __init__(self, *args, **kwargs):\n\t\tsuper(GraphicsTest, self).__init__(*args, **kwargs)\n\n\tdef run(self):\n\t\tcanvas = self.matrix\n\t\tfont = graphics.Font()\n\t\tfont.LoadFont(\"../../../fonts/7x13.bdf\")\n\n\t\tred = graphics.Color(255, 0, 0)\n\t\tgraphics.DrawLine(canvas, 5, 5, 22, 13, red)\n\n\t\tgreen = graphics.Color(0, 255, 0)\n\t\tgraphics.DrawCircle(canvas, 15, 15, 10, green)\n\n\t\tblue = graphics.Color(0, 0, 255)\n\t\tgraphics.DrawText(canvas, font, 2, 10, blue, \"Text\")\n\n\t\ttime.sleep(10)   # show display for 10 seconds before exit\n\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "import time"]}], [{"term": "class", "name": "GraphicsTest", "data": "class GraphicsTest(SampleBase):\n\tdef __init__(self, *args, **kwargs):\n\t\tsuper(GraphicsTest, self).__init__(*args, **kwargs)\n\n\tdef run(self):\n\t\tcanvas = self.matrix\n\t\tfont = graphics.Font()\n\t\tfont.LoadFont(\"../../../fonts/7x13.bdf\")\n\n\t\tred = graphics.Color(255, 0, 0)\n\t\tgraphics.DrawLine(canvas, 5, 5, 22, 13, red)\n\n\t\tgreen = graphics.Color(0, 255, 0)\n\t\tgraphics.DrawCircle(canvas, 15, 15, 10, green)\n\n\t\tblue = graphics.Color(0, 0, 255)\n\t\tgraphics.DrawText(canvas, font, 2, 10, blue, \"Text\")\n\n\t\ttime.sleep(10)   # show display for 10 seconds before exit\n\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "import time"]}], [{"term": "class", "name": "NvidiaSmiTestCase", "data": "class NvidiaSmiTestCase(unittest.TestCase):\n\n\tdef setUp(self):\n\t\tself.smi = check_nvidia_smi.NvidiaSMI('mem_usage', 'localhost', port=22, username=None, password=None, gpu_uuid=None, xmldata=XML_OUTPUT_NORMAL)\n\n\tdef test_get_device_data(self):\n\t\tself.assertEqual(len(self.smi.get_device_data()['gpus']), 4)\n\n\tdef test_check(self):\n\t\tcheck = nagiosplugin.Check(\n\t\t\tself.smi,\n\t\t\t*self.smi.context('80', '90'),\n\t\t\tself.smi.summary())\n\t\ttry:\n\t\t\tcheck.main()\n\t\texcept SystemExit:\n\t\t\tpass\n\n", "description": null, "category": "graphics", "imports": ["import unittest", "import check_nvidia_smi", "import xmltodict", "import nagiosplugin"]}], [{"term": "class", "name": "Pixmap", "data": "class Pixmap(GPixmap):\n\t#  _ns_bitmap_image_rep  NSBitmapImageRep\n\n\tdef __init__(self, width, height):\n\t\tGPixmap.__init__(self)\n\t\t#ns_size = NSSize(width, height)\n\t\t#ns_image = NSImage.alloc().initWithSize_(ns_size)\n\t\tns_image = NSImage.alloc().init()\n\t\tns_image.setCacheMode_(NSImageCacheNever)\n\t\trow_bytes = 4 * width\n\t\tns_bitmap = NSBitmapImageRep.alloc().\\\n\t\t\tinitWithBitmapDataPlanes_pixelsWide_pixelsHigh_bitsPerSample_samplesPerPixel_hasAlpha_isPlanar_colorSpaceName_bytesPerRow_bitsPerPixel_(\n\t\t\tNone, width, height, 8, 4, True, False, NSCalibratedRGBColorSpace, row_bytes, 32)\n\t\tns_image.addRepresentation_(ns_bitmap)\n\t\tns_bitmap_context = NSGraphicsContext.graphicsContextWithBitmapImageRep_(ns_bitmap)\n\t\tns_graphics_context = FlippedNSGraphicsContext.alloc().initWithBase_(ns_bitmap_context)\n\t\tns_tr = NSAffineTransform.transform()\n\t\tns_tr.translateXBy_yBy_(0.0, height)\n\t\tns_tr.scaleXBy_yBy_(1.0, -1.0)\n\t\t#  Using __class__ to get +saveGraphicsState instead of -saveGraphicsState\n\t\tNSGraphicsContext.__class__.saveGraphicsState()\n\t\ttry:\n\t\t\tNSGraphicsContext.setCurrentContext_(ns_graphics_context)\n\t\t\tns_tr.concat()\n\t\tfinally:\n\t\t\tNSGraphicsContext.__class__.restoreGraphicsState()\n\t\tself._init_with_ns_image(ns_image, flipped = True) #False)\n\t\tself._ns_bitmap_image_rep = ns_bitmap\n\t\tself._ns_graphics_context = ns_graphics_context\n\t\n\tdef with_canvas(self, proc):\n\t\tNSGraphicsContext.__class__.saveGraphicsState()\n\t\tNSGraphicsContext.setCurrentContext_(self._ns_graphics_context)\n\t\ttry:\n\t\t\tcanvas = Canvas()\n\t\t\tproc(canvas)\n\t\tfinally:\n\t\t\tNSGraphicsContext.__class__.restoreGraphicsState()\n", "description": null, "category": "graphics", "imports": ["from Foundation import NSSize", "from AppKit import NSImage, NSCachedImageRep, NSBitmapImageRep, \\", "from GUI import export", "from GUI import Canvas", "from GUI.GPixmaps import Pixmap as GPixmap"]}, {"term": "class", "name": "FlippedNSGraphicsContext", "data": "class FlippedNSGraphicsContext(NSGraphicsContext):\n\n\tdef initWithBase_(self, base):\n\t\tself.base = base\n\t\tself.graphics_port = base.graphicsPort()\n\t\treturn self\n\n\tdef isFlipped(self):\n\t\treturn True\n\t\n\tdef graphicsPort(self):\n\t\treturn self.graphics_port\n\t\n\tdef isDrawingToScreen(self):\n\t\treturn self.base.isDrawingToScreen()\n\n\tdef setCompositingOperation_(self, x):\n\t\tself.base.setCompositingOperation_(x)\n\n\tdef focusStack(self):\n\t\treturn self.base.focusStack()\n\n\tdef saveGraphicsState(self):\n\t\treturn self.base.saveGraphicsState()\n\n\tdef restoreGraphicsState(self):\n\t\treturn self.base.restoreGraphicsState()\n", "description": null, "category": "graphics", "imports": ["from Foundation import NSSize", "from AppKit import NSImage, NSCachedImageRep, NSBitmapImageRep, \\", "from GUI import export", "from GUI import Canvas", "from GUI.GPixmaps import Pixmap as GPixmap"]}], [{"term": "class", "name": "Pixmap", "data": "class Pixmap(GPixmap):\n\t#  _ns_bitmap_image_rep  NSBitmapImageRep\n\n\tdef __init__(self, width, height):\n\t\tGPixmap.__init__(self)\n\t\t#ns_size = NSSize(width, height)\n\t\t#ns_image = NSImage.alloc().initWithSize_(ns_size)\n\t\tns_image = NSImage.alloc().init()\n\t\tns_image.setCacheMode_(NSImageCacheNever)\n\t\trow_bytes = 4 * width\n\t\tns_bitmap = NSBitmapImageRep.alloc().\\\n\t\t\tinitWithBitmapDataPlanes_pixelsWide_pixelsHigh_bitsPerSample_samplesPerPixel_hasAlpha_isPlanar_colorSpaceName_bytesPerRow_bitsPerPixel_(\n\t\t\tNone, width, height, 8, 4, True, False, NSCalibratedRGBColorSpace, row_bytes, 32)\n\t\tns_image.addRepresentation_(ns_bitmap)\n\t\tns_bitmap_context = NSGraphicsContext.graphicsContextWithBitmapImageRep_(ns_bitmap)\n\t\tns_graphics_context = FlippedNSGraphicsContext.alloc().initWithBase_(ns_bitmap_context)\n\t\tns_tr = NSAffineTransform.transform()\n\t\tns_tr.translateXBy_yBy_(0.0, height)\n\t\tns_tr.scaleXBy_yBy_(1.0, -1.0)\n\t\t#  Using __class__ to get +saveGraphicsState instead of -saveGraphicsState\n\t\tNSGraphicsContext.__class__.saveGraphicsState()\n\t\ttry:\n\t\t\tNSGraphicsContext.setCurrentContext_(ns_graphics_context)\n\t\t\tns_tr.concat()\n\t\tfinally:\n\t\t\tNSGraphicsContext.__class__.restoreGraphicsState()\n\t\tself._init_with_ns_image(ns_image, flipped = True) #False)\n\t\tself._ns_bitmap_image_rep = ns_bitmap\n\t\tself._ns_graphics_context = ns_graphics_context\n\t\n\tdef with_canvas(self, proc):\n\t\tNSGraphicsContext.__class__.saveGraphicsState()\n\t\tNSGraphicsContext.setCurrentContext_(self._ns_graphics_context)\n\t\ttry:\n\t\t\tcanvas = Canvas()\n\t\t\tproc(canvas)\n\t\tfinally:\n\t\t\tNSGraphicsContext.__class__.restoreGraphicsState()\n", "description": null, "category": "graphics", "imports": ["from Foundation import NSSize", "from AppKit import NSImage, NSCachedImageRep, NSBitmapImageRep, \\", "from GUI import export", "from GUI import Canvas", "from GUI.GPixmaps import Pixmap as GPixmap"]}, {"term": "class", "name": "FlippedNSGraphicsContext", "data": "class FlippedNSGraphicsContext(NSGraphicsContext):\n\n\tdef initWithBase_(self, base):\n\t\tself.base = base\n\t\tself.graphics_port = base.graphicsPort()\n\t\treturn self\n\n\tdef isFlipped(self):\n\t\treturn True\n\t\n\tdef graphicsPort(self):\n\t\treturn self.graphics_port\n\t\n\tdef isDrawingToScreen(self):\n\t\treturn self.base.isDrawingToScreen()\n\n\tdef setCompositingOperation_(self, x):\n\t\tself.base.setCompositingOperation_(x)\n\n\tdef focusStack(self):\n\t\treturn self.base.focusStack()\n\n\tdef saveGraphicsState(self):\n\t\treturn self.base.saveGraphicsState()\n\n\tdef restoreGraphicsState(self):\n\t\treturn self.base.restoreGraphicsState()\n", "description": null, "category": "graphics", "imports": ["from Foundation import NSSize", "from AppKit import NSImage, NSCachedImageRep, NSBitmapImageRep, \\", "from GUI import export", "from GUI import Canvas", "from GUI.GPixmaps import Pixmap as GPixmap"]}], [{"term": "class", "name": "PlannerBase", "data": "class PlannerBase(object):\n\n\t# This class implements the basic graphical support for the planners. In particular, it plots both the\n\t# occupancy grid (which shows the probability of occupancy) and the search grid (binary and used to\n\t#  plan the path).\n\t\n\tdef __init__(self, title, occupancyGrid):\n\t\tself.title = title\n\t\tself.occupancyGrid = occupancyGrid\n\t\tself.searchGrid = None\n\n\t\tself.robotRadius = rospy.get_param('robot_radius', 0.2)\n\n\t\trospy.loginfo(\"Occupancy grid dimensions = %dx%d\", occupancyGrid.getWidthInCells(), occupancyGrid.getHeightInCells())\n\n\t\tself.setupOccupancyGrid()\n\t\t\n\t\t# Graphics and debug output support\n\t\tself.showGraphics = True\n\t\tself.pauseTimeInSeconds = 0\n\t\tself.iterationsBetweenGraphicsUpdate = 10000\n\t\tself.iterationsSinceLastGraphicsUpdate = 0\n\t\tself.searchGridDrawer = None\n\t\tself.occupancyGridDrawer = None\n\t\tself.windowHeightInPixels = 700\n\t\tself.runInteractively = False\n\n\t# This method is called when first setting stuff up\n\tdef setupOccupancyGrid(self):\n\t\traise NotImplementedError()\n\n\t# This method is called if the occupancy grid changes\n\tdef handleChangeToOccupancyGrid(self):\n\t\traise NotImplementedError()\n\n\t# Pause for key presses?\n\tdef setRunInteractively(self, runInteractively):\n\n\t\t# Record the decision here. We can only configure the drawer if it's already been\n\t\t# created.\n\t\tself.runInteractively = runInteractively\n\t\tif self.searchGridDrawer is not None:\n\t\t\tself.searchGridDrawer.setRunInterctively(runInteractively)\n\t\t\n\t# Show graphics?\n\tdef setShowGraphics(self, showGraphics):\n\t\tself.showGraphics = showGraphics\n\n\t# Getter to get the graphics\n\tdef getPlannerDrawer(self):\n\t\treturn self.searchGridDrawer\n\t\t\n\t# Change the default window height in pixels\n\tdef setWindowHeightInPixels(self, windowHeightInPixels):\n\t\tself.windowHeightInPixels = windowHeightInPixels\n\t\t\n\t# Set the pause time. When a window is updated, how long\n\t# should we pause for? Default is 0s.\n\tdef setDrawingPauseTime(self, pauseTimeInSeconds):\n\t\tself.pauseTimeInSeconds = pauseTimeInSeconds\n\t\t\n\t# Set the number of iterations between drawning the window. The\n\t# default is 50\n\tdef setIterationsBetweenDrawing(self, iterationsBetweenGraphicsUpdate):\n\t\tself.iterationsBetweenGraphicsUpdate = iterationsBetweenGraphicsUpdate\n\n\t# Reset the graphics; clear and close the window and then open a new window\n\tdef resetGraphics(self):\n\t\t\n\t\tif (self.showGraphics == False):\n\t\t\treturn\n\t\t\n\t\t# If we don't have the drawers set up yet, create them\n\t\tif (self.searchGridDrawer is None):\n\t\t\tself.createPlannerDrawer()\n\t\t\tself.searchGridDrawer.setRunInteractively(self.runInteractively)\n\t\t\tself.searchGridDrawer.open()\n\t\t\tself.occupancyGridDrawer.open()\n\t\telse:\n\t\t\tself.searchGridDrawer.reset()\n\t\t\tself.occupancyGridDrawer.reset()\n\t\t\t\n\t\t# Draw the start and end points\n\t\tself.searchGridDrawer.setStartAndGoal(self.start, self.goal)\n\t\t\n\t\t# Now force an initial draw\n\t\tself.drawCurrentState(forceUpdate=True)\n\t\t\n\t# Draw the output and sleep for the pause time.\n\tdef drawCurrentState(self, forceUpdate=False):\n\n\t\t# If graphics is disabled, return\n\t\tif self.showGraphics is False:\n\t\t\treturn\n\n\t\t# This check is needed because this code can be called during initialisation,\n\t\t# when not everything has been set up yet\n\t\tif (self.searchGridDrawer is None) or (self.occupancyGridDrawer is None):\n\t\t\treturn\n\t\t\t\n\t\t# Check if we need to do an update - this happens either if we force an update,\n\t\t# or the override has been set\n\t\tself.iterationsSinceLastGraphicsUpdate = self.iterationsSinceLastGraphicsUpdate + 1\n\n\t\tif forceUpdate is False:\t \n\t\t\tif (self.iterationsSinceLastGraphicsUpdate < self.iterationsBetweenGraphicsUpdate):\n\t\t\t\treturn\n\n\t\t# Reset the draw counter\n\t\tself.iterationsSinceLastGraphicsUpdate = 0\n\n\t\tself.searchGridDrawer.update()\n\t\tself.occupancyGridDrawer.update()\n\t\ttime.sleep(self.pauseTimeInSeconds)\n\n\t# Create the drawers which show the planner's progress\n\tdef createPlannerDrawer(self):\n\t\tself.searchGridDrawer = SearchGridDrawer('Planner SG: ' + self.title, self.searchGrid, self.windowHeightInPixels)\n\t\tself.occupancyGridDrawer = OccupancyGridDrawer('Planner OG :' + self.title, self.occupancyGrid, self.windowHeightInPixels)\n\n\t# Set the pause time\n\tdef setPauseTime(self, pauseTimeInSeconds):\n\t\tself.pauseTimeInSeconds = pauseTimeInSeconds\n", "description": null, "category": "graphics", "imports": ["from occupancy_grid import OccupancyGrid", "from search_grid import SearchGrid", "from grid_drawer import *", "import time", "from collections import deque", "from cell import *", "from planned_path import PlannedPath", "from math import *"]}], [{"term": "def", "name": "get_color_by_distance", "data": "def get_color_by_distance(distance):\n\tif distance >= 25:\n\t\treturn 'red'\n\tif distance <= 6:\n\t\treturn 'green'\n\treturn 'orange'\n\n", "description": null, "category": "graphics", "imports": ["from flask import Flask, request, jsonify, make_response", "from flask_cors import CORS", "from samplebase import SampleBase", "from rgbmatrix import graphics", "from colormap import colors", "from time import sleep", "from threading import Thread"]}, {"term": "class", "name": "RunText", "data": "class RunText(SampleBase):\n\tdef __init__(self, *args, **kwargs):\n\t\tsuper(RunText, self).__init__(*args, **kwargs)\n\t\tself.parser.add_argument(\n\t\t\t\"-t\", \"--text\", help=\"The text to scroll on the RGB LED panel\", default=\"Hello world!\")\n\n\tdef run(self):\n\t\toffscreen_canvas = self.matrix.CreateFrameCanvas()\n\t\tfont = graphics.Font()\n\t\tfont_big = graphics.Font()\n\t\tfont_small = graphics.Font()\n\t\tfont.LoadFont(FONTS+\"7x13.bdf\")\n\t\tfont_big.LoadFont(FONTS+\"10x20.bdf\")\n\t\tfont_small.LoadFont(FONTS+\"5x8.bdf\")\n\n\t\tdef left_block(color, text, distance):\n\t\t\tif color in colors.keys():\n\t\t\t\trgb_color = color\n\t\t\telse:\n\t\t\t\trgb_color = 'white'\n\n\t\t\tif distance != -1:\n\t\t\t\tif color == 'black':\n\t\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big,\n\t\t\t\t\t\t\t\t\t  1, 17, colors['brown'], \"\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\")\n\t\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big,\n\t\t\t\t\t\t\t\t\t  1, 35, colors['brown'], \"\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\")\n\n\t\t\t\tif distance < 100:\n\t\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big, 20,\n\t\t\t\t\t\t\t\t\t  15, colors[rgb_color], str(distance)+'Ft')\n\t\t\t\telse:\n\t\t\t\t\tgraphics.DrawText(offscreen_canvas, font, 13,\n\t\t\t\t\t\t\t\t\t  15, colors[rgb_color], 'too far')\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_small,\n\t\t\t\t\t\t\t\t  30, 30, colors[rgb_color], color.upper()[:8])\n\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big, 2,\n\t\t\t\t\t\t\t\t  18, colors[rgb_color], \"\\u2691\")\n\n\t\t\tgraphics.DrawText(offscreen_canvas, font,\n\t\t\t\t\t\t\t  1, 30, colors[get_color_by_distance(distance)], text)\n\n\t\tdef right_block(color, text, distance):\n\t\t\tif color in colors.keys():\n\t\t\t\trgb_color = color\n\t\t\telse:\n\t\t\t\trgb_color = 'white'\n\n\t\t\tif distance != -1:\n\t\t\t\tif color == 'black':\n\t\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big,\n\t\t\t\t\t\t\t\t\t  65, 17, colors['brown'], \"\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\")\n\t\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big,\n\t\t\t\t\t\t\t\t\t  65, 35, colors['brown'], \"\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\")\n\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big, 115,\n\t\t\t\t\t\t\t\t  18, colors[rgb_color], \"\\u2691\")\n\t\t\t\tif distance < 100:\n\t\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big, 70,\n\t\t\t\t\t\t\t\t\t  15, colors[rgb_color], str(distance)+'Ft')\n\t\t\t\telse:\n\t\t\t\t\tgraphics.DrawText(offscreen_canvas, font, 65,\n\t\t\t\t\t\t\t\t\t  15, colors[rgb_color], 'too far')\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_small,\n\t\t\t\t\t\t\t\t  66, 30, colors[rgb_color], color.upper()[:8])\n\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_big, 115,\n\t\t\t\t\t\t\t\t  18, colors[rgb_color], \"\\u2691\")\n\n\t\t\tgraphics.DrawText(offscreen_canvas, font,\n\t\t\t\t\t\t\t  100, 30, colors[get_color_by_distance(distance)], text)\n\n\t\tspeed = 0.25\n\n\t\twhile True:\n\t\t\tif display_values:\n\t\t\t\toffscreen_canvas = self.matrix.SwapOnVSync(offscreen_canvas)\n\t\t\t\toffscreen_canvas.Clear()\n\t\t\t\tleft_block(piles[0]['color'], ' <<<', piles[0]['distance'])\n\t\t\t\tright_block(piles[1]['color'], '>>> ', piles[1]['distance'])\n\t\t\t\tsleep(speed)\n\n\t\t\t\toffscreen_canvas = self.matrix.SwapOnVSync(offscreen_canvas)\n\t\t\t\toffscreen_canvas.Clear()\n\t\t\t\tleft_block(piles[0]['color'], '< <<', piles[0]['distance'])\n\t\t\t\tright_block(piles[1]['color'], '>> >', piles[1]['distance'])\n\t\t\t\tsleep(speed)\n\n\t\t\t\toffscreen_canvas = self.matrix.SwapOnVSync(offscreen_canvas)\n\t\t\t\toffscreen_canvas.Clear()\n\t\t\t\tleft_block(piles[0]['color'], '<< <', piles[0]['distance'])\n\t\t\t\tright_block(piles[1]['color'], '> >>', piles[1]['distance'])\n\t\t\t\tsleep(speed)\n\n\t\t\t\toffscreen_canvas = self.matrix.SwapOnVSync(offscreen_canvas)\n\t\t\t\toffscreen_canvas.Clear()\n\t\t\t\tleft_block(piles[0]['color'], '<<< ', piles[0]['distance'])\n\t\t\t\tright_block(piles[1]['color'], ' >>>', piles[1]['distance'])\n\t\t\t\tsleep(speed)\n\t\t\telse:\n\t\t\t\toffscreen_canvas = self.matrix.SwapOnVSync(offscreen_canvas)\n\t\t\t\toffscreen_canvas.Clear()\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_small,\n\t\t\t\t\t\t\t\t  1, 30, colors['white'], ' <<')\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_small,\n\t\t\t\t\t\t\t\t  110, 30, colors['white'], '>> ')\n\t\t\t\tsleep(speed)\n\t\t\t\toffscreen_canvas = self.matrix.SwapOnVSync(offscreen_canvas)\n\t\t\t\toffscreen_canvas.Clear()\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_small,\n\t\t\t\t\t\t\t\t  1, 30, colors['white'], '< <')\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_small,\n\t\t\t\t\t\t\t\t  110, 30, colors['white'], '> >')\n\t\t\t\tsleep(speed)\n\t\t\t\toffscreen_canvas = self.matrix.SwapOnVSync(offscreen_canvas)\n\t\t\t\toffscreen_canvas.Clear()\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_small,\n\t\t\t\t\t\t\t\t  1, 30, colors['white'], '<< ')\n\t\t\t\tgraphics.DrawText(offscreen_canvas, font_small,\n\t\t\t\t\t\t\t\t  110, 30, colors['white'], ' >>')\n\t\t\t\tsleep(speed)\n\n", "description": null, "category": "graphics", "imports": ["from flask import Flask, request, jsonify, make_response", "from flask_cors import CORS", "from samplebase import SampleBase", "from rgbmatrix import graphics", "from colormap import colors", "from time import sleep", "from threading import Thread"]}, {"term": "def", "name": "timer", "data": "def timer():\n\tglobal display_values, timer_counter\n\twhile True:\n\t\tif timer_counter >= timer_limit:\n\t\t\tdisplay_values = False\n\t\telse:\n\t\t\ttimer_counter = timer_counter + 1\n\t\t\tdisplay_values = True\n\n\t\tsleep(1)\n\n", "description": null, "category": "graphics", "imports": ["from flask import Flask, request, jsonify, make_response", "from flask_cors import CORS", "from samplebase import SampleBase", "from rgbmatrix import graphics", "from colormap import colors", "from time import sleep", "from threading import Thread"]}, {"term": "def", "name": "index", "data": "def index():\n\treturn \"... rgb server running on port %s\" % PORT\n\n", "description": null, "category": "graphics", "imports": ["from flask import Flask, request, jsonify, make_response", "from flask_cors import CORS", "from samplebase import SampleBase", "from rgbmatrix import graphics", "from colormap import colors", "from time import sleep", "from threading import Thread"]}, {"term": "def", "name": "set_rgb", "data": "def set_rgb():\n\tglobal piles, timer_counter\n\tmessage = False\n\tdata = request.get_json()\n\tif 'piles' in data:\n\t\ttimer_counter = 0\n\t\tpiles = data['piles']\n\t\tmessage = True\n\n\tresponse = make_response(jsonify({\n\t\t\"message\": message,\n\t}), 200)\n\tresponse.headers[\"Content-Type\"] = \"application/json\"\n\treturn response\n\n", "description": null, "category": "graphics", "imports": ["from flask import Flask, request, jsonify, make_response", "from flask_cors import CORS", "from samplebase import SampleBase", "from rgbmatrix import graphics", "from colormap import colors", "from time import sleep", "from threading import Thread"]}, {"term": "def", "name": "server", "data": "def server():\n\tapp.run(debug=False, port=PORT, host='0.0.0.0')\n\n", "description": null, "category": "graphics", "imports": ["from flask import Flask, request, jsonify, make_response", "from flask_cors import CORS", "from samplebase import SampleBase", "from rgbmatrix import graphics", "from colormap import colors", "from time import sleep", "from threading import Thread"]}], [{"term": "def", "name": "main", "data": "def main():\n\tlive = NUM_LIVES\n\tgraphics = BreakoutGraphics()\n\tgraphics.set_ball_position()\n\twhile live > 0:\n\t\t#if graphics.ball.x != (graphics.window_width - graphics.r * 2) / 2 or graphics.ball.y != (graphics.window_height - graphics.r * 2) / 2:\n\t\tvx = graphics.getter__dx()\n\t\tvy = graphics.getter__dy()\n\t\tgraphics.ball.move(vx, vy)\n\t\tgraphics.meet_wall()\n\t\tgraphics.detect_reflect()\n\t\tif graphics.ball.y >= graphics.window_height:\n\t\t\tgraphics.reset_ball()\n\t\t\tlive -= 1\n\t\tpause(FRAME_RATE)\n\tgraphics.back_home()\n\n\n\n\n\t# Add animation loop here!\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics_z import BreakoutGraphics", "from campy.graphics.gobjects import GLabel", "from campy.graphics.gwindow import GWindow"]}], [{"term": "class", "name": "GraphicsResultAllOf", "data": "class GraphicsResultAllOf(object):\n\t\"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n\tRef: https://openapi-generator.tech\n\n\tDo not edit the class manually.\n\t\"\"\"\n\n\t\"\"\"\n\tAttributes:\n\t  openapi_types (dict): The key is attribute name\n\t\t\t\t\t\t\tand the value is attribute type.\n\t  attribute_map (dict): The key is attribute name\n\t\t\t\t\t\t\tand the value is json key in definition.\n\t\"\"\"\n\topenapi_types = {\n\t\t'doc_graphics_info': 'GraphicFieldsList'\n\t}\n\n\tattribute_map = {\n\t\t'doc_graphics_info': 'DocGraphicsInfo'\n\t}\n\n\tdef __init__(self, doc_graphics_info=None, local_vars_configuration=None):  # noqa: E501\n\t\t\"\"\"GraphicsResultAllOf - a model defined in OpenAPI\"\"\"  # noqa: E501\n\t\tif local_vars_configuration is None:\n\t\t\tlocal_vars_configuration = Configuration()\n\t\tself.local_vars_configuration = local_vars_configuration\n\n\t\tself._doc_graphics_info = None\n\t\tself.discriminator = None\n\n\t\tif doc_graphics_info is not None:\n\t\t\tself.doc_graphics_info = doc_graphics_info\n\n\t@property\n\tdef doc_graphics_info(self):\n\t\t\"\"\"Gets the doc_graphics_info of this GraphicsResultAllOf.  # noqa: E501\n\n\n\t\t:return: The doc_graphics_info of this GraphicsResultAllOf.  # noqa: E501\n\t\t:rtype: GraphicFieldsList\n\t\t\"\"\"\n\t\treturn self._doc_graphics_info\n\n\t@doc_graphics_info.setter\n\tdef doc_graphics_info(self, doc_graphics_info):\n\t\t\"\"\"Sets the doc_graphics_info of this GraphicsResultAllOf.\n\n\n\t\t:param doc_graphics_info: The doc_graphics_info of this GraphicsResultAllOf.  # noqa: E501\n\t\t:type doc_graphics_info: GraphicFieldsList\n\t\t\"\"\"\n\n\t\tself._doc_graphics_info = doc_graphics_info\n\n\tdef to_dict(self):\n\t\t\"\"\"Returns the model properties as a dict\"\"\"\n\t\tresult = {}\n\n\t\tfor attr, _ in six.iteritems(self.openapi_types):\n\t\t\tvalue = getattr(self, attr)\n\t\t\tif isinstance(value, list):\n\t\t\t\tresult[attr] = list(map(\n\t\t\t\t\tlambda x: x.to_dict() if hasattr(x, \"to_dict\") else x,\n\t\t\t\t\tvalue\n\t\t\t\t))\n\t\t\telif hasattr(value, \"to_dict\"):\n\t\t\t\tresult[attr] = value.to_dict()\n\t\t\telif isinstance(value, dict):\n\t\t\t\tresult[attr] = dict(map(\n\t\t\t\t\tlambda item: (item[0], item[1].to_dict())\n\t\t\t\t\tif hasattr(item[1], \"to_dict\") else item,\n\t\t\t\t\tvalue.items()\n\t\t\t\t))\n\t\t\telse:\n\t\t\t\tresult[attr] = value\n\n\t\treturn result\n\n\tdef to_str(self):\n\t\t\"\"\"Returns the string representation of the model\"\"\"\n\t\treturn pprint.pformat(self.to_dict())\n\n\tdef __repr__(self):\n\t\t\"\"\"For `print` and `pprint`\"\"\"\n\t\treturn self.to_str()\n\n\tdef __eq__(self, other):\n\t\t\"\"\"Returns true if both objects are equal\"\"\"\n\t\tif not isinstance(other, GraphicsResultAllOf):\n\t\t\treturn False\n\n\t\treturn self.to_dict() == other.to_dict()\n\n\tdef __ne__(self, other):\n\t\t\"\"\"Returns true if both objects are not equal\"\"\"\n\t\tif not isinstance(other, GraphicsResultAllOf):\n\t\t\treturn True\n\n\t\treturn self.to_dict() != other.to_dict()\n", "description": "NOTE: This class is auto generated by OpenAPI Generator.\n\tRef: https://openapi-generator.tech\n\n\tDo not edit the class manually.\n\t", "category": "graphics", "imports": ["import pprint", "import re  # noqa: F401", "import six", "from regula.documentreader.webclient.gen.configuration import Configuration", "from regula.documentreader.webclient.gen.models import *"]}], [], [], [{"term": "def", "name": "gridprinter", "data": "def gridprinter():\r\n\tfrom grid import mover, currentpos, gridA, gridB, gridC\r\n\tgraphics.dungeon()\r\n\tprint(\"\\nCurrent Position:\\n\")\r\n\tif currentpos['grid'] == 'gridA':\r\n\t\tprint(gridA[currentpos['pos']])\r\n\telif currentpos['grid'] == 'gridB':\r\n\t\tprint(gridB[currentpos['pos']])\r\n\telif currentpos['grid'] == 'gridC':\r\n\t\tprint(gridC[currentpos['pos']])\r\n\r\n", "description": null, "category": "graphics", "imports": ["import graphics\r", "import os\r", "from random import choice\r", "from time import sleep\r", "  from messages import tulliusdialogue\r", "\tfrom grid import mover, currentpos, gridA, gridB, gridC\r", "\timport variables\r", "\tfrom variables import armordict,equipped\r", "\timport variables\r", "\tfrom consumeitem import useitem\r", "\timport variables\r", "\t\tfrom grid import mover\r", "\t\tfrom grid import mover\r", "\t\tfrom grid import mover\r", "\t\tfrom grid import mover\r", "\t\tfrom debug import debugmenu\r", "\t\timport startsequence\r", "\t\tfrom armory import equippedarmor\r", "\t  import variables\r"]}, {"term": "def", "name": "stats", "data": "def stats():\r\n\tgraphics.clrscrn()\r\n\tgraphics.stat_ascii()\r\n\timport variables\r\n\tfrom variables import armordict,equipped\r\n\tgraphics.print_centre(f\"HP = {variables.health['hp']}\")\r\n\tgraphics.print_centre(f\"Gold = {variables.money['gold']}\")\r\n\tgraphics.print_centre(f\"Silver = {variables.money['silver']}\")\r\n\tgraphics.print_centre(f\"Enemies defeated = {variables.stats['enemies']}\")\r\n\tgraphics.print_centre(f\"XP = {variables.xp['xp']}\")\r\n\tgraphics.print_centre(f\"Level = {variables.xp['level']}\")\r\n\tgraphics.print_centre(f\"XP need to levelup = {variables.xp['lvlnext']}\")\r\n\tgraphics.print_centre(f\"Max Parry: {armordict['helm'][equipped['helm']][1]+armordict['chestplate'][equipped['chestplate']][1]+armordict['leggings'][equipped['leggings']][1]+armordict['boots'][equipped['boots']][1]+armordict['vambraces'][equipped['vambraces']][1]+armordict['shield'][equipped['shield']][1]}\")\r\n\tgraphics.print_centre(\"Return to menu\")\r\n\tinput()\r\n\tgraphics.clrscrn()\r\n\t\r\n\r\n", "description": null, "category": "graphics", "imports": ["import graphics\r", "import os\r", "from random import choice\r", "from time import sleep\r", "  from messages import tulliusdialogue\r", "\tfrom grid import mover, currentpos, gridA, gridB, gridC\r", "\timport variables\r", "\tfrom variables import armordict,equipped\r", "\timport variables\r", "\tfrom consumeitem import useitem\r", "\timport variables\r", "\t\tfrom grid import mover\r", "\t\tfrom grid import mover\r", "\t\tfrom grid import mover\r", "\t\tfrom grid import mover\r", "\t\tfrom debug import debugmenu\r", "\t\timport startsequence\r", "\t\tfrom armory import equippedarmor\r", "\t  import variables\r"]}, {"term": "def", "name": "inventory", "data": "def inventory():\r\n\tgraphics.clrscrn()\r\n", "description": null, "category": "graphics", "imports": ["import graphics\r", "import os\r", "from random import choice\r", "from time import sleep\r", "  from messages import tulliusdialogue\r", "\tfrom grid import mover, currentpos, gridA, gridB, gridC\r", "\timport variables\r", "\tfrom variables import armordict,equipped\r", "\timport variables\r", "\tfrom consumeitem import useitem\r", "\timport variables\r", "\t\tfrom grid import mover\r", "\t\tfrom grid import mover\r", "\t\tfrom grid import mover\r", "\t\tfrom grid import mover\r", "\t\tfrom debug import debugmenu\r", "\t\timport startsequence\r", "\t\tfrom armory import equippedarmor\r", "\t  import variables\r"]}, {"term": "def", "name": "shop", "data": "def shop():\r\n\timport variables\r\n\twhile True:\r\n\t  graphics.clrscrn()\r\n\t  \r\n", "description": null, "category": "graphics", "imports": ["import graphics\r", "import os\r", "from random import choice\r", "from time import sleep\r", "  from messages import tulliusdialogue\r", "\tfrom grid import mover, currentpos, gridA, gridB, gridC\r", "\timport variables\r", "\tfrom variables import armordict,equipped\r", "\timport variables\r", "\tfrom consumeitem import useitem\r", "\timport variables\r", "\t\tfrom grid import mover\r", "\t\tfrom grid import mover\r", "\t\tfrom grid import mover\r", "\t\tfrom grid import mover\r", "\t\tfrom debug import debugmenu\r", "\t\timport startsequence\r", "\t\tfrom armory import equippedarmor\r", "\t  import variables\r"]}, {"term": "def", "name": "menu", "data": "def menu():\r\n\tgraphics.spacer()\r\n\tgraphics.print_centre(f\"--- [WASD] Move [I] Inventory [V] Stats [M] Menu [Z] Armor [T] Tullius [B] Shop ---\")\r\n\tcho=input(\": \")\r\n\tif cho == \"W\" or cho == \"w\":\r\n\t\tfrom grid import mover\r\n\t\tmover(cho)\r\n\telif cho == \"A\" or cho == \"a\":\r\n\t\tfrom grid import mover\r\n\t\tmover(cho)\r\n\telif cho == \"S\" or cho == \"s\":\r\n\t\tfrom grid import mover\r\n\t\tmover(cho)\r\n\telif cho == \"D\" or cho == \"d\":\r\n\t\tfrom grid import mover\r\n\t\tmover(cho)\r\n\telif cho == \"I\" or cho == \"i\":\r\n\t\tinventory()\r\n\t\tgridprinter()\r\n\telif cho == \"V\" or cho == \"v\":\r\n\t\tstats()\r\n\t\tgridprinter()\r\n\telif cho == 'alohomora':\r\n\t\tfrom debug import debugmenu\r\n\t\tdebugmenu()\r\n\telif cho == \"M\" or cho == \"m\":\r\n\t\timport startsequence\r\n\t\tgraphics.clrscrn()\r\n\t\tstartsequence.pausemenu()\r\n\t\tsleep(1)\r\n\t\tgraphics.clrscrn()\r\n\t\tgridprinter()\r\n\telif cho == 'Z' or cho == 'z':\r\n\t\tfrom armory import equippedarmor\r\n\t\tequippedarmor()\r\n\t\tgridprinter()\r\n\telif cho == 'T' or cho == 't':\r\n\t\ttullius()\r\n\t\tgridprinter()\r\n\telif cho == 'B' or cho == 'b':\r\n\t\tshop()\r\n\t\tgraphics.clrscrn()\r\n\t\tgridprinter()\r\n\telif cho == 'makemetherichestbch':\r\n\t  import variables\r\n\t  variables.money[\"silver\"] += 10000\r\n\t  variables.money[\"gold\"]+=10000\r\n\t  graphics.clrscrn()\r\n\t  gridprinter()\r\n\telse:\r\n\t\tgraphics.clrscrn()\r\n\t\tgridprinter()\r\n", "description": null, "category": "graphics", "imports": ["import graphics\r", "import os\r", "from random import choice\r", "from time import sleep\r", "  from messages import tulliusdialogue\r", "\tfrom grid import mover, currentpos, gridA, gridB, gridC\r", "\timport variables\r", "\tfrom variables import armordict,equipped\r", "\timport variables\r", "\tfrom consumeitem import useitem\r", "\timport variables\r", "\t\tfrom grid import mover\r", "\t\tfrom grid import mover\r", "\t\tfrom grid import mover\r", "\t\tfrom grid import mover\r", "\t\tfrom debug import debugmenu\r", "\t\timport startsequence\r", "\t\tfrom armory import equippedarmor\r", "\t  import variables\r"]}], [{"term": "class", "name": "Display", "data": "class Display(object):\n\t\n\tWHITE = graphicsUtils.formatColor(1.0, 1.0, 1.0)\n\tRED = graphicsUtils.formatColor(1.0, 0.0, 0.0)\n\tGREEN = graphicsUtils.formatColor(0.16, 0.49, 0.31)\n\tBLUE = graphicsUtils.formatColor(0.0, 0.0, 1.0)\n\tBLACK = graphicsUtils.formatColor(0.0, 0.0, 0.0)\n\tGREY = graphicsUtils.formatColor(0.5, .5, 0.5)\n\t\n\tVISIBLE_CUTTOFF = 0.001\n\t\n\t\n\tpartDict = {}\n\tbeliefParts = []\n\tbeliefValue = []\n\tbeliefColor = []\n\tobservations = []\n\t\n\tgraphicsLock = threading.Lock()\n\t\n\tCOLORS = [\n\t\t'purple',\n\t\t'green',\n\t\t'teal',\n\t\t'red',\n\t\t'orange',\n\t\t'yellow'\n\t]\n\tCOLOR_HUES = {\n\t\t'purple' : 0.8,\n\t\t'green' : 0.3,\n\t\t'teal' : 0.49,\n\t\t'red' : 0.0,\n\t\t'orange' : 0.125,\n\t\t'yellow' : 0.21\n\t}\n\t\n\t@staticmethod\n\tdef initGraphics(layout):\n\t\tgraphicsUtils.begin_graphics(\n\t\t\twidth=layout.getWidth(), \n\t\t\theight=layout.getHeight(), \n\t\t\tcolor = Display.WHITE,\n\t\t\ttitle = Const.TITLE\n\t\t);\n\t\t\n\t@staticmethod\n\tdef endGraphics():\n\t\tgraphicsUtils.end_graphics()\n\n\t@staticmethod\n\tdef raiseEndGraphics():\n\t\tgraphicsUtils.raiseEndGraphics()\n\t\n\t@staticmethod\n\tdef drawCar(car):\n\t\tif car in Display.partDict:\n\t\t\tDisplay._remove(car)\n\t\tcolor = Display.GREY\n\t\tif car.isJunior():\n\t\t\tcolor = Display.BLACK\n\t\tparts = graphicsUtils.rectangle(\n\t\t\tcar.pos, Car.LENGTH, \n\t\t\tCar.WIDTH, \n\t\t\tcolor, \n\t\t\tcar.dir\n\t\t)\n\t\tDisplay.partDict[car] = parts\n\t\t\n\t@staticmethod\n\tdef drawObservation(obs):\n\t\tparts = Display.drawCircle(obs.pos, Observation.RADIUS)\n\t\tDisplay.partDict[obs] = parts\n\t\n\t@staticmethod\n\tdef drawSquare(pos, size, color):\n\t\treturn graphicsUtils.square(pos, size, color)\n\t\n\t@staticmethod\n\tdef drawFinish(block):\n\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.GREEN, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\n\t@staticmethod\n\tdef drawBlocks(blocks):\n\t\tfor block in blocks:\n\t\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.BLUE, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\t\n\t@staticmethod\n\tdef drawCircle(pos, radius):\n\t\treturn graphicsUtils.circle(pos, radius, Display.RED, Display.RED)\n\t\n\t@staticmethod\n\tdef drawBelief(model):\n\t\tDisplay.beliefVisible = []\n\t\tfor r in range(model.getBeliefRows()):\n\t\t\tbeliefValueRow = []\n\t\t\tbeliefPartRow = []\n\t\t\tbeliefColorRow = []\n\t\t\tfor c in range(model.getBeliefCols()):\n\t\t\t\tsquare = Display.drawBeliefSquare(r, c, 'purple', 0.0, model)\n\t\t\t\tbeliefPartRow.append(square)\n\t\t\t\tbeliefValueRow.append(0.0)\n\t\t\t\tbeliefColorRow.append(None)\n\t\t\tDisplay.beliefParts.append(beliefPartRow)\n\t\t\tDisplay.beliefValue.append(beliefValueRow)\n\t\t\tDisplay.beliefColor.append(beliefColorRow)\n\t\t\t\t\n\t@staticmethod\n\tdef drawBeliefSquare(row, col, color, value, model):\n\t\ttileSize = Const.BELIEF_TILE_SIZE\n\t\tx = col * tileSize + tileSize / 2.0\n\t\ty = row * tileSize + tileSize / 2.0\n\t\tif not model.inBounds(x, y): return None\n\t\tcolor = Display._getBeliefSquareColor(color, value)\n\t\treturn Display.drawSquare(Vec2d(x, y), tileSize, color)\n\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef getKeys():\n\t\t#print 'attempt get keys'\n\t\tDisplay._acquireLock()\n\t\t#print 'get keys'\n\t\tkeys = graphicsUtils.keys_waiting() + graphicsUtils.keys_pressed()\n\t\tDisplay._releaseLock()\n\t\treturn keys\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef graphicsSleep(timeToSleep):\n\t\tgraphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''for _ in range(int(timeToSleep / 0.005)):\n\t\t\t#print 'attempt sleep'\n\t\t\tDisplay._acquireLock()\n\t\t\t#print 'sleep'\n\t\t\tgraphicsUtils.sleep(0.001)\n\t\t\tDisplay._releaseLock()\n\t\t\ttime.sleep(0.004)'''\n\t\t\n\t\t#graphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''startWait = time.time()\n\t\tDisplay._acquireLock()\n\t\ttimeToSleep -= time.time() - startWait\n\t\tgraphicsUtils.refresh()\n\t\tif timeToSleep > 0:\n\t\t\tgraphicsUtils.sleep(timeToSleep)\n\t\tDisplay._releaseLock()'''\n\t\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef updateBelief(color, belief):\n\t\tDisplay._acquireLock()\n\t\ttotal = belief.getSum()\n\t\tif abs(total - 1.0) > 0.001:\n\t\t\traise Exception('belief does not sum to 1 ('+str(total)+'). Use the normalize method.')\n\t\tfor r in range(belief.getNumRows()):\n\t\t\tfor c in range(belief.getNumCols()):\n\t\t\t\tvalue = belief.getProb(r, c)\n\t\t\t\tDisplay._updateBeliefSquare(r, c, value, color)\n\t\tDisplay._releaseLock()\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef move(obj, delta):\n\t\t#print 'attempt move'\n\t\tDisplay._acquireLock()\n\t\t#print 'move'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.move_by(parts, delta.x, delta.y)\n\t\t#print 'end move'\n\t\tDisplay._releaseLock()\n\t\t\n\t# make thread safe\n\t@staticmethod\n\tdef rotate(obj, angle):\n\t\tif angle == 0: return\n\t\t#print 'attempt rotate'\n\t\tDisplay._acquireLock()\n\t\t#print 'rotate'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.rotate_by(parts, angle)\n\t\tDisplay._releaseLock()\n\t\t\t\t\n\t@staticmethod\n\tdef _getBeliefSquareColor(color, value):\n\t\tvalue = min(1.0, value * 15)\n\t\tsaturation = value\n\t\thue = Display.COLOR_HUES[color]\n\t\tr, g, b = colorsys.hsv_to_rgb(hue, saturation, 1.0)\n\t\tcolor = graphicsUtils.formatColor(r, g, b)\n\t\treturn color\t\t\n\t\n\t@staticmethod\n\tdef _isVisible(value):\n\t\treturn value >= Display.VISIBLE_CUTTOFF\n\t\n\t@staticmethod\n\tdef _updateBeliefSquare(r, c, value, colorName):\n\t\tpart = Display.beliefParts[r][c]\n\t\tif part == None: return\n\t\toldValue = Display.beliefValue[r][c]\n\t\toldColor = Display.beliefColor[r][c]\n\t\twasVisible = Display._isVisible(oldValue)\n\t\tisVisible = Display._isVisible(value) \n\t\tif not isVisible: value = 0.0\n\t\tif oldColor != colorName and oldValue >= value: return\n\t\tif not isVisible and not wasVisible: return\n\t\tcolor = Display._getBeliefSquareColor(colorName, value)\n\t\tgraphicsUtils.changeColor(part, color)\n\t\tDisplay.beliefValue[r][c] = value\n\t\tDisplay.beliefColor[r][c] = colorName\n\t\t\n\t@staticmethod\n\tdef _acquireLock():\n\t\treturn\n\t\t#print 'acquire'\n\t\treturn Display.graphicsLock.acquire()\n\t\n\t@staticmethod\n\tdef _releaseLock():\n\t\treturn\n\t\t#print 'release'\n\t\treturn Display.graphicsLock.release()\n\t \n\t####################################\n\t# Depreicated\n\t####################################\n\t\t\n\t@staticmethod\n\tdef _remove(obj):\n\t\tparts = Display.partDict[obj]\n\t\tgraphicsUtils.remove_from_screen(parts);\n\t\t\n\t@staticmethod\n\tdef redrawObservations(observations):\n\t\traise Exception('depreicated')\n\t\tfor obs in Display.observations:\n\t\t\tDisplay._remove(obs)\n\t\tfor obs in observations:\n\t\t\tDisplay.drawObservation(obs)\n\t\tDisplay.observations = observations\n", "description": null, "category": "graphics", "imports": ["from . import graphicsUtils", "from engine.model.car.car import Car", "from engine.const import Const", "from engine.model.observation import Observation", "from engine.vector import Vec2d", "import colorsys", "import threading"]}], [{"term": "class", "name": "Emoji", "data": "class Emoji(Base):\n\n\t@property\n\tdef default():\n\t\treturn {\n\t\t\t\"doge\": \"https://cdn.jsdelivr.net/npm/vditor@3.8.7/dist/images/emoji/doge.png\",\n\t\t\t\"trollface\": \"https://cdn.jsdelivr.net/npm/vditor@3.8.7/dist/images/emoji/trollface.png\",\n\t\t\t\"huaji\": \"https://cdn.jsdelivr.net/npm/vditor@3.8.7/dist/images/emoji/huaji.gif\",\n\t\t\t\"octocat\": \"https://cdn.jsdelivr.net/npm/vditor@3.8.7/dist/images/emoji/octocat.png\",\n\t\t\t\"wulian\": \"https://cdn.jsdelivr.net/npm/vditor@3.8.7/dist/images/emoji/wulian.png\",\n\t\t\t\"smile\": f'https://{DOMAIN}/emoji/graphics/smile.png',\n\t\t\t\"laughing\": f'https://{DOMAIN}/emoji/graphics/laughing.png',\n\t\t\t\"blush\": f'https://{DOMAIN}/emoji/graphics/blush.png',\n\t\t\t\"smiley\": f'https://{DOMAIN}/emoji/graphics/smiley.png',\n\t\t\t\"relaxed\": f'https://{DOMAIN}/emoji/graphics/relaxed.png',\n\t\t\t\"smirk\": f'https://{DOMAIN}/emoji/graphics/smirk.png',\n\t\t\t\"heart_eyes\": f'https://{DOMAIN}/emoji/graphics/heart_eyes.png',\n\t\t\t\"kissing_heart\": f'https://{DOMAIN}/emoji/graphics/kissing_heart.png',\n\t\t\t\"kissing_closed_eyes\": f'https://{DOMAIN}/emoji/graphics/kissing_closed_eyes.png',\n\t\t\t\"flushed\": f'https://{DOMAIN}/emoji/graphics/flushed.png',\n\t\t\t\"relieved\": f'https://{DOMAIN}/emoji/graphics/relieved.png',\n\t\t\t\"satisfied\": f'https://{DOMAIN}/emoji/graphics/satisfied.png',\n\t\t\t\"grin\": f'https://{DOMAIN}/emoji/graphics/grin.png',\n\t\t\t\"wink\": f'https://{DOMAIN}/emoji/graphics/wink.png',\n\t\t\t\"stuck_out_tongue_winking_eye\": f'https://{DOMAIN}/emoji/graphics/stuck_out_tongue_winking_eye.png',\n\t\t\t\"stuck_out_tongue_closed_eyes\": f'https://{DOMAIN}/emoji/graphics/stuck_out_tongue_closed_eyes.png',\n\t\t\t\"grinning\": f'https://{DOMAIN}/emoji/graphics/grinning.png',\n\t\t\t\"kissing\": f'https://{DOMAIN}/emoji/graphics/kissing.png',\n\t\t\t\"kissing_smiling_eyes\": f'https://{DOMAIN}/emoji/graphics/kissing_smiling_eyes.png',\n\t\t\t\"stuck_out_tongue\": f'https://{DOMAIN}/emoji/graphics/stuck_out_tongue.png',\n\t\t\t\"sleeping\": f'https://{DOMAIN}/emoji/graphics/sleeping.png',\n\t\t\t\"worried\": f'https://{DOMAIN}/emoji/graphics/worried.png',\n\t\t\t\"frowning\": f'https://{DOMAIN}/emoji/graphics/frowning.png',\n\t\t\t\"anguished\": f'https://{DOMAIN}/emoji/graphics/anguished.png',\n\t\t\t\"open_mouth\": f'https://{DOMAIN}/emoji/graphics/open_mouth.png',\n\t\t\t\"grimacing\": f'https://{DOMAIN}/emoji/graphics/grimacing.png',\n\t\t\t\"confused\": f'https://{DOMAIN}/emoji/graphics/confused.png',\n\t\t\t\"hushed\": f'https://{DOMAIN}/emoji/graphics/hushed.png',\n\t\t\t\"expressionless\": f'https://{DOMAIN}/emoji/graphics/expressionless.png',\n\t\t\t\"unamused\": f'https://{DOMAIN}/emoji/graphics/unamused.png',\n\t\t\t\"sweat_smile\": f'https://{DOMAIN}/emoji/graphics/sweat_smile.png',\n\t\t\t\"sweat\": f'https://{DOMAIN}/emoji/graphics/sweat.png',\n\t\t\t\"disappointed_relieved\": f'https://{DOMAIN}/emoji/graphics/disappointed_relieved.png',\n\t\t\t\"weary\": f'https://{DOMAIN}/emoji/graphics/weary.png',\n\t\t\t\"pensive\": f'https://{DOMAIN}/emoji/graphics/pensive.png',\n\t\t\t\"disappointed\": f'https://{DOMAIN}/emoji/graphics/disappointed.png',\n\t\t\t\"confounded\": f'https://{DOMAIN}/emoji/graphics/confounded.png',\n\t\t\t\"fearful\": f'https://{DOMAIN}/emoji/graphics/fearful.png',\n\t\t\t\"cold_sweat\": f'https://{DOMAIN}/emoji/graphics/cold_sweat.png',\n\t\t\t\"persevere\": f'https://{DOMAIN}/emoji/graphics/persevere.png',\n\t\t\t\"cry\": f'https://{DOMAIN}/emoji/graphics/cry.png',\n\t\t\t\"sob\": f'https://{DOMAIN}/emoji/graphics/sob.png',\n\t\t\t\"joy\": f'https://{DOMAIN}/emoji/graphics/joy.png',\n\t\t\t\"astonished\": f'https://{DOMAIN}/emoji/graphics/astonished.png',\n\t\t\t\"scream\": f'https://{DOMAIN}/emoji/graphics/scream.png',\n\t\t\t\"tired_face\": f'https://{DOMAIN}/emoji/graphics/tired_face.png',\n\t\t\t\"angry\": f'https://{DOMAIN}/emoji/graphics/angry.png',\n\t\t\t\"rage\": f'https://{DOMAIN}/emoji/graphics/rage.png',\n\t\t\t\"triumph\": f'https://{DOMAIN}/emoji/graphics/triumph.png',\n\t\t\t\"sleepy\": f'https://{DOMAIN}/emoji/graphics/sleepy.png',\n\t\t\t\"yum\": f'https://{DOMAIN}/emoji/graphics/yum.png',\n\t\t\t\"mask\": f'https://{DOMAIN}/emoji/graphics/mask.png',\n\t\t\t\"sunglasses\": f'https://{DOMAIN}/emoji/graphics/sunglasses.png',\n\t\t\t\"dizzy_face\": f'https://{DOMAIN}/emoji/graphics/dizzy_face.png',\n\t\t\t\"imp\": f'https://{DOMAIN}/emoji/graphics/imp.png',\n\t\t\t\"smiling_imp\": f'https://{DOMAIN}/emoji/graphics/smiling_imp.png',\n\t\t\t\"neutral_face\": f'https://{DOMAIN}/emoji/graphics/neutral_face.png',\n\t\t\t\"no_mouth\": f'https://{DOMAIN}/emoji/graphics/no_mouth.png',\n\t\t\t\"innocent\": f'https://{DOMAIN}/emoji/graphics/innocent.png',\n\t\t\t\"alien\": f'https://{DOMAIN}/emoji/graphics/alien.png',\n\t\t\t\"yellow_heart\": f'https://{DOMAIN}/emoji/graphics/yellow_heart.png',\n\t\t\t\"blue_heart\": f'https://{DOMAIN}/emoji/graphics/blue_heart.png',\n\t\t\t\"purple_heart\": f'https://{DOMAIN}/emoji/graphics/purple_heart.png',\n\t\t\t\"heart\": f'https://{DOMAIN}/emoji/graphics/heart.png',\n\t\t\t\"green_heart\": f'https://{DOMAIN}/emoji/graphics/green_heart.png',\n\t\t\t\"broken_heart\": f'https://{DOMAIN}/emoji/graphics/broken_heart.png',\n\t\t\t\"heartbeat\": f'https://{DOMAIN}/emoji/graphics/heartbeat.png',\n\t\t\t\"heartpulse\": f'https://{DOMAIN}/emoji/graphics/heartpulse.png',\n\t\t\t\"two_hearts\": f'https://{DOMAIN}/emoji/graphics/two_hearts.png',\n\t\t\t\"revolving_hearts\": f'https://{DOMAIN}/emoji/graphics/revolving_hearts.png',\n\t\t\t\"cupid\": f'https://{DOMAIN}/emoji/graphics/cupid.png',\n\t\t\t\"sparkling_heart\": f'https://{DOMAIN}/emoji/graphics/sparkling_heart.png',\n\t\t\t\"sparkles\": f'https://{DOMAIN}/emoji/graphics/sparkles.png',\n\t\t\t\"star\": f'https://{DOMAIN}/emoji/graphics/star.png',\n\t\t\t\"star2\": f'https://{DOMAIN}/emoji/graphics/star2.png',\n\t\t\t\"dizzy\": f'https://{DOMAIN}/emoji/graphics/dizzy.png',\n\t\t\t\"boom\": f'https://{DOMAIN}/emoji/graphics/boom.png',\n\t\t\t\"collision\": f'https://{DOMAIN}/emoji/graphics/collision.png',\n\t\t\t\"anger\": f'https://{DOMAIN}/emoji/graphics/anger.png',\n\t\t\t\"exclamation\": f'https://{DOMAIN}/emoji/graphics/exclamation.png',\n\t\t\t\"question\": f'https://{DOMAIN}/emoji/graphics/question.png',\n\t\t\t\"grey_exclamation\": f'https://{DOMAIN}/emoji/graphics/grey_exclamation.png',\n\t\t\t\"grey_question\": f'https://{DOMAIN}/emoji/graphics/grey_question.png',\n\t\t\t\"zzz\": f'https://{DOMAIN}/emoji/graphics/zzz.png',\n\t\t\t\"dash\": f'https://{DOMAIN}/emoji/graphics/dash.png',\n\t\t\t\"sweat_drops\": f'https://{DOMAIN}/emoji/graphics/sweat_drops.png',\n\t\t\t\"notes\": f'https://{DOMAIN}/emoji/graphics/notes.png',\n\t\t\t\"musical_note\": f'https://{DOMAIN}/emoji/graphics/musical_note.png',\n\t\t\t\"fire\": f'https://{DOMAIN}/emoji/graphics/fire.png',\n\t\t\t\"poop\": f'https://{DOMAIN}/emoji/graphics/poop.png',\n\t\t\t\"+1\": f'https://{DOMAIN}/emoji/graphics/%2B1.png',\n\t\t\t\"thumbsup\": f'https://{DOMAIN}/emoji/graphics/thumbsup.png',\n\t\t\t\"-1\": f'https://{DOMAIN}/emoji/graphics/-1.png',\n\t\t\t\"thumbsdown\": f'https://{DOMAIN}/emoji/graphics/thumbsdown.png',\n\t\t\t\"ok_hand\": f'https://{DOMAIN}/emoji/graphics/ok_hand.png',\n\t\t\t\"punch\": f'https://{DOMAIN}/emoji/graphics/punch.png',\n\t\t\t\"facepunch\": f'https://{DOMAIN}/emoji/graphics/facepunch.png',\n\t\t\t\"fist\": f'https://{DOMAIN}/emoji/graphics/fist.png',\n\t\t\t\"v\": f'https://{DOMAIN}/emoji/graphics/v.png',\n\t\t\t\"wave\": f'https://{DOMAIN}/emoji/graphics/wave.png',\n\t\t\t\"hand\": f'https://{DOMAIN}/emoji/graphics/hand.png',\n\t\t\t\"raised_hand\": f'https://{DOMAIN}/emoji/graphics/raised_hand.png',\n\t\t\t\"open_hands\": f'https://{DOMAIN}/emoji/graphics/open_hands.png',\n\t\t\t\"point_up\": f'https://{DOMAIN}/emoji/graphics/point_up.png',\n\t\t\t\"point_down\": f'https://{DOMAIN}/emoji/graphics/point_down.png',\n\t\t\t\"point_left\": f'https://{DOMAIN}/emoji/graphics/point_left.png',\n\t\t\t\"point_right\": f'https://{DOMAIN}/emoji/graphics/point_right.png',\n\t\t\t\"raised_hands\": f'https://{DOMAIN}/emoji/graphics/raised_hands.png',\n\t\t\t\"pray\": f'https://{DOMAIN}/emoji/graphics/pray.png',\n\t\t\t\"point_up_2\": f'https://{DOMAIN}/emoji/graphics/point_up_2.png',\n\t\t\t\"clap\": f'https://{DOMAIN}/emoji/graphics/clap.png',\n\t\t\t\"muscle\": f'https://{DOMAIN}/emoji/graphics/muscle.png',\n\t\t\t\"couple\": f'https://{DOMAIN}/emoji/graphics/couple.png',\n\t\t\t\"family\": f'https://{DOMAIN}/emoji/graphics/family.png',\n\t\t\t\"two_men_holding_hands\": f'https://{DOMAIN}/emoji/graphics/two_men_holding_hands.png',\n\t\t\t\"two_women_holding_hands\": f'https://{DOMAIN}/emoji/graphics/two_women_holding_hands.png',\n\t\t\t\"dancer\": f'https://{DOMAIN}/emoji/graphics/dancer.png',\n\t\t\t\"dancers\": f'https://{DOMAIN}/emoji/graphics/dancers.png',\n\t\t\t\"ok_woman\": f'https://{DOMAIN}/emoji/graphics/ok_woman.png',\n\t\t\t\"no_good\": f'https://{DOMAIN}/emoji/graphics/no_good.png',\n\t\t\t\"information_desk_person\": f'https://{DOMAIN}/emoji/graphics/information_desk_person.png',\n\t\t\t\"raising_hand\": f'https://{DOMAIN}/emoji/graphics/raising_hand.png',\n\t\t\t\"bride_with_veil\": f'https://{DOMAIN}/emoji/graphics/bride_with_veil.png',\n\t\t\t\"person_with_pouting_face\": f'https://{DOMAIN}/emoji/graphics/person_with_pouting_face.png',\n\t\t\t\"person_frowning\": f'https://{DOMAIN}/emoji/graphics/person_frowning.png',\n\t\t\t\"bow\": f'https://{DOMAIN}/emoji/graphics/bow.png',\n\t\t\t\"couplekiss\": f'https://{DOMAIN}/emoji/graphics/couplekiss.png',\n\t\t\t\"couple_with_heart\": f'https://{DOMAIN}/emoji/graphics/couple_with_heart.png',\n\t\t\t\"massage\": f'https://{DOMAIN}/emoji/graphics/massage.png',\n\t\t\t\"haircut\": f'https://{DOMAIN}/emoji/graphics/haircut.png',\n\t\t\t\"nail_care\": f'https://{DOMAIN}/emoji/graphics/nail_care.png',\n\t\t\t\"boy\": f'https://{DOMAIN}/emoji/graphics/boy.png',\n\t\t\t\"girl\": f'https://{DOMAIN}/emoji/graphics/girl.png',\n\t\t\t\"woman\": f'https://{DOMAIN}/emoji/graphics/woman.png',\n\t\t\t\"man\": f'https://{DOMAIN}/emoji/graphics/man.png',\n\t\t\t\"baby\": f'https://{DOMAIN}/emoji/graphics/baby.png',\n\t\t\t\"older_woman\": f'https://{DOMAIN}/emoji/graphics/older_woman.png',\n\t\t\t\"older_man\": f'https://{DOMAIN}/emoji/graphics/older_man.png',\n\t\t\t\"person_with_blond_hair\": f'https://{DOMAIN}/emoji/graphics/person_with_blond_hair.png',\n\t\t\t\"man_with_gua_pi_mao\": f'https://{DOMAIN}/emoji/graphics/man_with_gua_pi_mao.png',\n\t\t\t\"man_with_turban\": f'https://{DOMAIN}/emoji/graphics/man_with_turban.png',\n\t\t\t\"construction_worker\": f'https://{DOMAIN}/emoji/graphics/construction_worker.png',\n\t\t\t\"cop\": f'https://{DOMAIN}/emoji/graphics/cop.png',\n\t\t\t\"angel\": f'https://{DOMAIN}/emoji/graphics/angel.png',\n\t\t\t\"princess\": f'https://{DOMAIN}/emoji/graphics/princess.png',\n\t\t\t\"smiley_cat\": f'https://{DOMAIN}/emoji/graphics/smiley_cat.png',\n\t\t\t\"smile_cat\": f'https://{DOMAIN}/emoji/graphics/smile_cat.png',\n\t\t\t\"heart_eyes_cat\": f'https://{DOMAIN}/emoji/graphics/heart_eyes_cat.png',\n\t\t\t\"kissing_cat\": f'https://{DOMAIN}/emoji/graphics/kissing_cat.png',\n\t\t\t\"smirk_cat\": f'https://{DOMAIN}/emoji/graphics/smirk_cat.png',\n\t\t\t\"scream_cat\": f'https://{DOMAIN}/emoji/graphics/scream_cat.png',\n\t\t\t\"crying_cat_face\": f'https://{DOMAIN}/emoji/graphics/crying_cat_face.png',\n\t\t\t\"joy_cat\": f'https://{DOMAIN}/emoji/graphics/joy_cat.png',\n\t\t\t\"pouting_cat\": f'https://{DOMAIN}/emoji/graphics/pouting_cat.png',\n\t\t\t\"japanese_ogre\": f'https://{DOMAIN}/emoji/graphics/japanese_ogre.png',\n\t\t\t\"japanese_goblin\": f'https://{DOMAIN}/emoji/graphics/japanese_goblin.png',\n\t\t\t\"see_no_evil\": f'https://{DOMAIN}/emoji/graphics/see_no_evil.png',\n\t\t\t\"hear_no_evil\": f'https://{DOMAIN}/emoji/graphics/hear_no_evil.png',\n\t\t\t\"speak_no_evil\": f'https://{DOMAIN}/emoji/graphics/speak_no_evil.png',\n\t\t\t\"guardsman\": f'https://{DOMAIN}/emoji/graphics/guardsman.png',\n\t\t\t\"skull\": f'https://{DOMAIN}/emoji/graphics/skull.png',\n\t\t\t\"feet\": f'https://{DOMAIN}/emoji/graphics/feet.png',\n\t\t\t\"lips\": f'https://{DOMAIN}/emoji/graphics/lips.png',\n\t\t\t\"kiss\": f'https://{DOMAIN}/emoji/graphics/kiss.png',\n\t\t\t\"droplet\": f'https://{DOMAIN}/emoji/graphics/droplet.png',\n\t\t\t\"ear\": f'https://{DOMAIN}/emoji/graphics/ear.png',\n\t\t\t\"eyes\": f'https://{DOMAIN}/emoji/graphics/eyes.png',\n\t\t\t\"nose\": f'https://{DOMAIN}/emoji/graphics/nose.png',\n\t\t\t\"tongue\": f'https://{DOMAIN}/emoji/graphics/tongue.png',\n\t\t\t\"love_letter\": f'https://{DOMAIN}/emoji/graphics/love_letter.png',\n\t\t\t\"bust_in_silhouette\": f'https://{DOMAIN}/emoji/graphics/bust_in_silhouette.png',\n\t\t\t\"busts_in_silhouette\": f'https://{DOMAIN}/emoji/graphics/busts_in_silhouette.png',\n\t\t\t\"speech_balloon\": f'https://{DOMAIN}/emoji/graphics/speech_balloon.png',\n\t\t\t\"thought_balloon\": f'https://{DOMAIN}/emoji/graphics/thought_balloon.png'\n\t\t}\n\n\tdef get(self):\n\t\t\"\"\"\u83b7\u53d6\u7528\u6237\u81ea\u5b9a\u4e49\u8868\u60c5\"\"\"\n\t\tif self.apiKey == '':\n\t\t\treturn []\n\t\treturn json.loads(self.json('/api/cloud/get', {\n\t\t\t'gameId': 'emojis',\n\t\t\t'apiKey': self.apiKey\n\t\t})['data'])\n\n\tdef set(self, emojis: list):\n\t\t\"\"\"\u67e5\u8be2\u767b\u5f55\u7528\u6237\u5f53\u524d\u6d3b\u8dc3\u5ea6\uff0c\u8bf7\u6c42\u9891\u7387\u8bf7\u63a7\u5236\u5728 30 ~ 60 \u79d2\u4e00\u6b21\"\"\"\n\t\tif self.apiKey == '':\n\t\t\treturn None\n\t\treturn self.json('/api/cloud/sync', {\n\t\t\t'gameId': 'emojis',\n\t\t\t'apiKey': self.apiKey,\n\t\t\t'data': json.dumps(emojis)\n\t\t})\n", "description": "\u83b7\u53d6\u7528\u6237\u81ea\u5b9a\u4e49\u8868\u60c5", "category": "graphics", "imports": ["import json", "from .__fishpi__ import Base, DOMAIN"]}], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, **kargs):\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [], [{"term": "def", "name": "__init__", "data": "  def __init__(self, *args, fontSize=11, preamble=\"\", mode=None, **kwargs):\n\tsuper(Figure, self).__init__(*args, **kwargs)\n\t\n\tif mode is None:\n\t  if \"talk\" in Figure._getBuildDir():\n\t\tself.mode = \"beamer\"\n\t  elif \"thesis\" in Figure._getBuildDir():\n\t\tself.mode = \"thesis\"\n\t  else:\n\t\tself.mode = \"paper\"\n\telse:\n\t  self.mode = mode\n\t\n\tfontFamily = (\"sans-serif\" if self.mode == \"beamer\" else \"serif\")\n\tpreamble = (Figure._TEX_PREAMBLE_COMMON +\n\t\t\t\tFigure._TEX_PREAMBLE_SPECIAL[self.mode] +\n\t\t\t\tpreamble)\n\t\n\tmpl.rcParams.update({\n\t  \"axes.prop_cycle\" : cycler.cycler(color=Figure._LINE_COLORS),\n\t  \"font.family\" : fontFamily,\n\t  \"font.size\" : fontSize,\n\t  \"lines.linewidth\" : 1,\n\t  \"pgf.texsystem\" : \"lualatex\",\n\t  \"pgf.rcfonts\" : False,\n\t  \"pgf.preamble\" : preamble.splitlines(),\n\t  \"text.usetex\" : True,\n\t})\n\t\n\tself._saveDisabled = (platform.node() == \"neon\")\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}, {"term": "def", "name": "create", "data": "  def create(*args, scale=1, **kwargs):\n\tif \"figsize\" in kwargs: kwargs[\"figsize\"] = [scale * x for x in kwargs[\"figsize\"]]\n\treturn plt.figure(*args, FigureClass=Figure, **kwargs)\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}, {"term": "def", "name": "_getBuildDir", "data": "  def _getBuildDir():\n\treturn os.path.realpath(os.environ[\"BUILD_DIR\"])\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}, {"term": "def", "name": "_getGraphicsBasename", "data": "  def _getGraphicsBasename():\n\treturn os.path.splitext(os.path.split(os.path.realpath(sys.argv[0]))[1])[0]\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}, {"term": "def", "name": "_computeHash", "data": "  def _computeHash(path):\n\ttry:\n\t  with open(path, \"rb\") as f: return hashlib.md5(f.read()).digest()\n\texcept:\n\t  return None\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}, {"term": "def", "name": "load", "data": "  def load(datPath=None):\n\tFigure.graphicsCounter += 1\n\tgraphicsNumber = Figure.graphicsCounter\n\t\n\tif path is None:\n\t  buildDir = Figure._getBuildDir()\n\t  graphicsBasename = Figure._getGraphicsBasename()\n\t  basename = os.path.join(buildDir, \"{}_{}\".format(graphicsBasename, graphicsNumber))\n\t  datPath = \"{}.pickle.dat\".format(basename)\n\t\n\tprint(\"Loading {}...\".format(datPath))\n\twith lzma.open(datPath, \"rb\") as f: return pickle.load(f)\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}, {"term": "def", "name": "disableSave", "data": "  def disableSave():\n\tself._saveDisabled = True\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}, {"term": "def", "name": "enableSave", "data": "  def enableSave():\n\tself._saveDisabled = False\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}, {"term": "def", "name": "save", "data": "  def save(self, graphicsNumber=None, appendGraphicsNumber=True,\n\t\t   hideSpines=True, tightLayout=True, crop=True, close=True,\n\t\t   transparent=True):\n\tplt.figure(self.number)\n\t\n\tif graphicsNumber is None:\n\t  Figure.graphicsCounter += 1\n\t  graphicsNumber = Figure.graphicsCounter\n\telse:\n\t  Figure.graphicsCounter = graphicsNumber\n\t\n\tif self._saveDisabled:\n\t  if close: plt.close(self)\n\t  return\n\t\n\tif tightLayout is not False:\n\t  if tightLayout is True: tightLayout = {}\n\t  self.tight_layout(**tightLayout)\n\t\n\tif hideSpines:\n\t  for ax in self.axes:\n\t\tax.spines[\"top\"].set_visible(False)\n\t\tax.spines[\"right\"].set_visible(False)\n\t\n\tif graphicsNumber is None: graphicsNumber = self.number\n\t\n\tbuildDir = Figure._getBuildDir()\n\tgraphicsBasename = Figure._getGraphicsBasename()\n\t\n\tbasename = graphicsBasename\n\tif appendGraphicsNumber: basename += \"_{}\".format(graphicsNumber)\n\tbasename = os.path.join(buildDir, basename)\n\t\n\tif transparent:\n\t  savefigFcn = (\n\t\tlambda path: plt.savefig(path, facecolor=\"none\", transparent=True))\n\telse:\n\t  savefigFcn = (\n\t\tlambda path: plt.savefig(path, facecolor=self.get_facecolor()))\n\t\n\tpgfPath = \"{}.pgf\".format(basename)\n\tprint(\"Saving {}...\".format(os.path.split(pgfPath)[1]))\n\tsavefigFcn(pgfPath)\n\t\n\tpgfXzPath = \"{}.pgf.xz\".format(basename)\n\toldHash = Figure._computeHash(pgfXzPath)\n\twith open(pgfPath, \"rb\") as f: pgf = f.read()\n\twith lzma.open(pgfXzPath, \"wb\") as f: pickle.dump(pgf, f)\n\tos.remove(pgfPath)\n\tnewHash = Figure._computeHash(pgfXzPath)\n\t\n\tpdfPath = \"{}.pdf\".format(basename)\n\t\n\tif (oldHash == newHash) and os.path.isfile(pdfPath):\n\t  print(\"No changes since last run.\")\n\t  pathlib.Path(pdfPath).touch()\n\telse:\n\t  print(\"Compiling to {}...\".format(os.path.split(pdfPath)[1]))\n\t  savefigFcn(pdfPath)\n\t  if crop: subprocess.run([\"pdfcrop\", pdfPath, pdfPath], check=True)\n\t  \n\t  datPath = \"{}.pickle.xz\".format(basename)\n\t  print(\"Saving {}...\".format(os.path.split(datPath)[1]))\n\t  with lzma.open(datPath, \"wb\") as f: pickle.dump(self, f)\n\t\n\tif close: plt.close(self)\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}], [], [], [], [{"term": "class", "name": "CameraGraphics", "data": "class CameraGraphics(ImageGraphics):\n\tdef __init__(self, entity):\n\t\tsuper(CameraGraphics, self).__init__(entity, None)\n\n\t\tself.render_graphics = None\n\n\tdef update(self):\n\t\tentity = self.entity\n\t\tself.set_image(\n\t\t\tentity.screen, entity.world_position,\n\t\t\t*entity.camera_layers,\n\t\t\tscale=entity.scale\n\t\t)\n\n\tdef set_image(self, screen, world_position, *layers, scale=1.0):\n\t\tself.image = self.get_screen_image(\n\t\t\tscreen, world_position,\n\t\t\t*layers, scale=scale\n\t\t)\n\n\tdef get_screen_image(self, screen, world_position, *layers, scale=1.0):\n\t\tif self.render_graphics is None:\n\t\t\traise RuntimeError(\"No 'render_graphics' method has been set for {}\".format(self.__class__.__name__))\n\n\t\tif scale != 1.0:\n\t\t\tscreen = screen.get_scaled(1 / scale)\n\t\tscreen.fill((0, 0, 0, 0))\n\n\t\targs = []\n\n\t\twx, wy = world_position\n\t\twx *= -1\n\t\twy *= -1\n\n\t\tfor l in layers:\n\t\t\targs += l.get_graphics(offset=(wx, wy))\n\n\t\tfor arg in args:\n\t\t\tself.render_graphics(screen, *arg)\n\n\t\tif scale != 1.0:\n\t\t\tscreen = screen.get_scaled(scale)\n\n\t\treturn screen\n\n", "description": null, "category": "graphics", "imports": ["from zsquirrel.entities import Layer", "from zsquirrel.utils.geometry import Rect", "from zsquirrel.resources import Image", "from zsquirrel.graphics import ImageGraphics"]}, {"term": "class", "name": "CameraLayer", "data": "class CameraLayer(Layer):\n\tdef __init__(self, name):\n\t\tsuper(CameraLayer, self).__init__(name)\n\t\tself.screen = None\n\n\t\tself.world_position = 0, 0\n\t\tself.scale = 1\n\t\tself._screen_rect = Rect(self.size, self.position)\n\t\tself.camera_layers = []\n\n\t\tself.make_screen()\n\n\t\tself.graphics = CameraGraphics(self)\n\t\tself.update_methods.append(self.graphics.update)\n\n\t# properties\n\t@property\n\tdef screen_rect(self):\n\t\tr = self._screen_rect\n\t\tr.size = self.world_size\n\t\tr.position = self.world_position\n\n\t\treturn r\n\n\t@property\n\tdef world_size(self):\n\t\tw, h = self.size\n\t\ts = self.scale\n\t\tw /= s\n\t\th /= s\n\n\t\treturn w, h\n\n\t@property\n\tdef focal_point(self):\n\t\treturn self.screen_rect.center\n\n\t# setters\n\tdef make_screen(self):\n\t\tw, h = self.size\n\t\ts = self.scale\n\t\tw /= s\n\t\th /= s\n\n\t\tself.screen = Image.get_surface((w, h))\n\n\tdef set_render_function(self, func):\n\t\tself.graphics.render_graphics = func\n\n\tdef set_camera_layers(self, *layers):\n\t\tself.add_to_list(\"camera_layers\", *layers)\n\n\tdef get_camera_layers(self):\n\t\treturn self.camera_layers\n\n\tdef set_world_position(self, x, y):\n\t\tself.world_position = x, y\n\n\tdef set_size(self, w, h):\n\t\tsuper(CameraLayer, self).set_size(w, h)\n\n\t\tif self.initialized:\n\t\t\tself.make_screen()\n\n\tdef set_scale(self, scale):\n\t\tself.scale = scale\n\t\tself.make_screen()\n\n\t# # graphics rendering\n\t# def get_graphics(self, offset=None):\n\t#\t if not offset:\n\t#\t\t offset = self.position\n\t#\t self.screen.fill((0, 0, 0, 0))\n\t#\n\t#\t wx, wy = self.world_position\n\t#\t wx *= -1\n\t#\t wy *= -1\n\t#\n\t#\t args = super(CameraLayer, self).get_graphics(\n\t#\t\t offset=(wx, wy)\n\t#\t )\n\t#\n\t#\t for arg in args:\n\t#\t\t self.render_graphics(*arg)\n\t#\n\t#\t screen = self.screen\n\t#\t if self.scale != 1:\n\t#\t\t screen = self.screen.get_scaled(self.scale)\n\t#\n\t#\t return [(screen, offset)]\n\t#\n\t# def render_graphics(self, image, *args):\n\t#\t render_graphics(\n\t#\t\t self.screen, image, *args\n\t#\t )\n\n\t# camera methods\n\tdef move_camera(self, dx, dy, v=1):\n\t\tr = self.screen_rect\n\t\tdx *= v\n\t\tdy *= v\n\t\tr.move((dx, dy))\n\n\t\tself.set_world_position(*r.position)\n\n\tdef track_point(self, point, v=1):\n\t\tcx, cy = self.focal_point\n\t\tpx, py = point\n\n\t\tdx = px - cx\n\t\tdy = py - cy\n\n\t\tif abs(dx) < .1:\n\t\t\tdx = 0\n\n\t\tif abs(dy) < .1:\n\t\t\tdy = 0\n\n\t\tself.move_camera(dx, dy, v=v)\n\n\tdef zoom_to_scale(self, scale):\n\t\tcx, cy = self.focal_point\n\t\tself.set_scale(scale)\n\t\tself.track_point((cx, cy))\n\n\tdef get_screen_position(self, x, y):\n\t\twx, wy = self.world_position\n\t\ts = self.scale\n\n\t\tdx = x - wx\n\t\tdy = y - wy\n\t\tdx *= s\n\t\tdy *= s\n\n\t\treturn dx, dy\n\n\tdef get_world_position(self, sx, sy):\n\t\twx, wy = self.world_position\n\t\ts = self.scale\n\n\t\tx = wx + (sx * s)\n\t\ty = wy + (sy * s)\n\n\t\treturn x, y\n", "description": null, "category": "graphics", "imports": ["from zsquirrel.entities import Layer", "from zsquirrel.utils.geometry import Rect", "from zsquirrel.resources import Image", "from zsquirrel.graphics import ImageGraphics"]}], [{"term": "class", "name": "classFuseChunks_GraphicsMode_preMixin:", "data": "class FuseChunks_GraphicsMode_preMixin:\n\t\"\"\"\n\tThe pre- Mixin class for various graphics modes that will be used for the\n\tFuseChunks_Command. This should strictly be a pre-Mixin class. \n\tThe intention is to override some methods of Move_GraphicsMode , \n\tsuch as 'Draw' and use them in the graphics modes of FuseChunks_Command. \n\t\n\tThe Move_GraphicsMode also has two subclasses TranslateChunks_GraphicsMode\n\tand RotateChunks_GraphicsMode. Even in FuseChunks mode (command), we \n\tneed to use these two modes , at the same time we also need to override\n\tthe Draw methods etc so that the 3D workspce shows things like fusable atoms \n\tand bonds. To achieve this, we have made this special Mixin class to define\n\tDraw methods etc. Then, the class FuseChunks_GraphicsMode inherits this \n\tfirst and then the Move_GraphicsMode. (so that, for example \n\tself.Draw in that class  actually uses the method defined in this mixin \n\tclass instead of Move_GraphicsMode.Draw.) \n\t\n\tWe are doing similar thing in classes such as --\n\tTranslate_in_FuseChunks_GraphicsMode where the it uses Draw related methods \n\tfrom this class and special drag related methods form \n\tTranslateChunks_GraphicsMode\n\t\n\t@see: B{TranslateChunks_GraphicsMode} \n\t@see: B{Translate_in_FuseChunks_GraphicsMode} \n\t@see: B{RotateChunks_GraphicsMode}\n\t@see: B{Rotate_in_FuseChunks_GraphicsMode} \n\t@see: Move_GraphicsMode\n\t@see: FuseChunks_Command\n\t\"\"\"\n\trecompute_fusables = True\n\t\t# 'recompute_fusables' is used to optimize redraws by skipping the \n\t\t# recomputing of fusables\n\t\t# (bondable pairs or overlapping atoms). When set to False, Draw() will\n\t\t# not recompute fusables \n\t\t# before repainting the GLPane. When False, 'recompute_fusables' is \n\t\t# reset to True in Draw(), \n\t\t# so it is the responsibility of the caller to Draw() (i.e. win_update()\n\t\t# or gl_update()) to reset it to False before each redraw if desired.\n\t\t#For more info, see comments in Draw().\n\t\n\tsomething_was_picked = False\n\t\t# 'something_was_picked' is a special boolean flag needed by Draw() \n\t\t# to determine when \n\t\t# the state has changed from something selected to nothing selected.  \n\t\t# It is used to \n\t\t# properly update the tolerance label in the Property Manager\n\t\t# when all chunks are unselected.\n\t\n\tdef Enter_GraphicsMode(self):\n\t\tMove_GraphicsMode.Enter_GraphicsMode(self)\n\t\tself.recompute_fusables = True\t\n\t\t\n\t\n\tdef Draw(self):\n\t\t\"\"\"\n\t\tDraw bondable pairs or overlapping atoms.\n\t\t\"\"\"\n\t\tif self.o.is_animating or self.o.button == 'MMB':\n\t\t\t# Don't need to recompute fusables if we are animating between views \n\t\t\t# or zooming, panning or rotating with the MMB.\n\t\t\tself.recompute_fusables = False\n\n\t\t# 'recompute_fusables' is set to False when the bondable pairs or \n\t\t# overlapping atoms don't\n\t\t# need to be recomputed.  Scenerios when 'recompute_fusables' \n\t\t# is set to False:\n\t\t#   1. animating between views. Done above, boolean attr \n\t\t#\t  'self.o.is_animating' is checked.\n\t\t#   2. zooming, panning and rotating with MMB. Done above, \n\t\t#\t  check if self.o.button == 'MMB'\n\t\t#   3. Zooming with mouse wheel, done in fusechunksMode.Wheel().\n\t\t# If 'recompute_fusables' is False here, it is immediately reset to \n\t\t# True below. mark 060405\n\t\tif self.recompute_fusables:\n\t\t\t# This is important and needed in case there is nothing selected.  \n\t\t\t# I mention this because it looks redundant since is the first thing\n\t\t\t# done in find_bondable_pairs(). \n\t\t\tself.command.bondable_pairs = []\n\t\t\tself.command.ways_of_bonding = {}\n\t\t\tself.command.overlapping_atoms = []\n\n\t\t\tif self.o.assy.selmols: \n\t\t\t\t# Recompute fusables. This can be very expensive, especially \n\t\t\t\t# with large parts.\n\t\t\t\tself.command.find_fusables() \n\t\t\t\tif not self.something_was_picked: \n\t\t\t\t\tself.something_was_picked = True\n\t\t\telse:\n\t\t\t\t# Nothing is selected, so there can be no fusables.\n\t\t\t\t# Check if we need to update the slider tolerance label.\n\t\t\t\t# This fixed bug 502-14.  Mark 050407\n\t\t\t\tif self.something_was_picked:\n\t\t\t\t\tself.command.reset_tolerance_label()\n\t\t\t\t\tself.something_was_picked = False # Reset flag\n\t\telse:\n\t\t\tself.recompute_fusables = True\n\n\t\tMove_GraphicsMode.Draw(self)\n\n\t\tif self.command.bondable_pairs:\n\t\t\tself.draw_bondable_pairs()\n\n\t\telif self.command.overlapping_atoms:\n\t\t\tself.draw_overlapping_atoms()\n\t\n\t\t\n\t\n\tdef draw_bondable_pairs(self):\n\t\t\"\"\"\n\t\tDraws bondable pairs of singlets and the bond lines between them. \n\t\tSinglets in the selected chunk(s) are colored green.\n\t\tSinglets in the unselected chunk(s) are colored blue.\n\t\tSinglets with more than one way to bond are colored magenta.\n\t\t\"\"\"\n\t\t# Color of bond lines --\n\t\tbondline_color = get_selCurve_color(0,self.o.backgroundColor) \n\t\tfor s1,s2 in self.command.bondable_pairs:\n\t\t\tcolor = (self.command.ways_of_bonding[s1.key] > 1) and magenta or green\n\t\t\ts1.overdraw_with_special_color(color)\n\t\t\tcolor = (self.command.ways_of_bonding[s2.key] > 1) and magenta or blue\n\t\t\ts2.overdraw_with_special_color(color)\n\t\t\t# Draw bond lines between singlets --\n\t\t\tdrawline(bondline_color, s1.posn(), s2.posn()) \n\t\n\n\tdef draw_overlapping_atoms(self):\n\t\t\"\"\"\n\t\tDraws overlapping atoms. \n\t\tAtoms in the selected chunk(s) are colored green.\n\t\tAtoms in the unselected chunk(s) that will be deleted are colored \n\t\tdarkred.\n\t\t\"\"\"\n\t\tfor a1,a2 in self.command.overlapping_atoms:\n\t\t\t# a1 atoms are the selected chunk atoms\n\t\t\ta1.overdraw_with_special_color(green) # NFR/bug 945. Mark 051029.\n\t\t\t# a2 atoms are the unselected chunk(s) atoms\n\t\t\ta2.overdraw_with_special_color(darkred)\n\t\n\tdef leftDouble(self, event):\n\t\t# This keeps us from leaving Fuse Chunks mode, \n\t\t#as is the case in Move Chunks mode.\n\t\tpass\n\n\tdef Wheel(self, event):\n\t\t\"\"\"\n\t\tMouse wheel event handler.  This overrides modifyMode.Wheel() to \n\t\toptimizeredraws by setting 'recompute_fusables' to False so that Draw()\n\t\twill not recompute fusables while zooming in/out.\n\t\t\"\"\"\n\t\tMove_GraphicsMode.Wheel(self, event)\n\t\tself.recompute_fusables = False\n\n", "description": "\n\tThe pre- Mixin class for various graphics modes that will be used for the\n\tFuseChunks_Command. This should strictly be a pre-Mixin class. \n\tThe intention is to override some methods of Move_GraphicsMode , \n\tsuch as 'Draw' and use them in the graphics modes of FuseChunks_Command. \n\t\n\tThe Move_GraphicsMode also has two subclasses TranslateChunks_GraphicsMode\n\tand RotateChunks_GraphicsMode. Even in FuseChunks mode (command), we \n\tneed to use these two modes , at the same time we also need to override\n\tthe Draw methods etc so that the 3D workspce shows things like fusable atoms \n\tand bonds. To achieve this, we have made this special Mixin class to define\n\tDraw methods etc. Then, the class FuseChunks_GraphicsMode inherits this \n\tfirst and then the Move_GraphicsMode. (so that, for example \n\tself.Draw in that class  actually uses the method defined in this mixin \n\tclass instead of Move_GraphicsMode.Draw.) \n\t\n\tWe are doing similar thing in classes such as --\n\tTranslate_in_FuseChunks_GraphicsMode where the it uses Draw related methods \n\tfrom this class and special drag related methods form \n\tTranslateChunks_GraphicsMode\n\t\n\t@see: B{TranslateChunks_GraphicsMode} \n\t@see: B{Translate_in_FuseChunks_GraphicsMode} \n\t@see: B{RotateChunks_GraphicsMode}\n\t@see: B{Rotate_in_FuseChunks_GraphicsMode} \n\t@see: Move_GraphicsMode\n\t@see: FuseChunks_Command\n\t", "category": "graphics", "imports": ["from graphics.drawing.CS_draw_primitives import drawline", "from graphics.behaviors.shape import get_selCurve_color", "from utilities.constants import green", "from utilities.constants import magenta", "from utilities.constants import blue", "from utilities.constants import darkred", "from commands.Move.Move_GraphicsMode import Move_GraphicsMode", "from commands.Translate.TranslateChunks_GraphicsMode import TranslateChunks_GraphicsMode", "from commands.Rotate.RotateChunks_GraphicsMode import RotateChunks_GraphicsMode", "\t\t\t# This is important and needed in case there is nothing selected.  "]}, {"term": "class", "name": "FuseChunks_GraphicsMode", "data": "class FuseChunks_GraphicsMode(FuseChunks_GraphicsMode_preMixin, \n\t\t\t\t\t\t\t  Move_GraphicsMode):\n\t\"\"\"\n\tThe default Graphics mode for the FuseChunks_Command\n\t@see: FuseChunks_GraphicsMode_preMixin for comments on multiple inheritance\n\t@see: B{FuseChunks_Command} where it is used as a default graphics mode \n\t\t class\n\t@see: B{FuseChunks_Command._createGraphicsMode} \n\t\"\"\"\t\n\tpass\n", "description": "\n\tThe default Graphics mode for the FuseChunks_Command\n\t@see: FuseChunks_GraphicsMode_preMixin for comments on multiple inheritance\n\t@see: B{FuseChunks_Command} where it is used as a default graphics mode \n\t\t class\n\t@see: B{FuseChunks_Command._createGraphicsMode} \n\t", "category": "graphics", "imports": ["from graphics.drawing.CS_draw_primitives import drawline", "from graphics.behaviors.shape import get_selCurve_color", "from utilities.constants import green", "from utilities.constants import magenta", "from utilities.constants import blue", "from utilities.constants import darkred", "from commands.Move.Move_GraphicsMode import Move_GraphicsMode", "from commands.Translate.TranslateChunks_GraphicsMode import TranslateChunks_GraphicsMode", "from commands.Rotate.RotateChunks_GraphicsMode import RotateChunks_GraphicsMode", "\t\t\t# This is important and needed in case there is nothing selected.  "]}, {"term": "class", "name": "Translate_in_FuseChunks_GraphicsMode", "data": "class Translate_in_FuseChunks_GraphicsMode(FuseChunks_GraphicsMode_preMixin,\n\t\t\t\t\t\t\t\t\t\t   TranslateChunks_GraphicsMode):\n\t\"\"\"\n\tWhen the translate groupbox of the FuseChunks Command  property manager is \n\tactive, the graphics mode for the command will be \n\tTranslate_in_FuseChunks_GraphicsMode. \n\t@see: FuseChunks_GraphicsMode_preMixin for comments on multiple inheritance\n\t@see: B{FuseChunks_Command._createGraphicsMode} \n\t\"\"\"\n\tpass\n", "description": "\n\tWhen the translate groupbox of the FuseChunks Command  property manager is \n\tactive, the graphics mode for the command will be \n\tTranslate_in_FuseChunks_GraphicsMode. \n\t@see: FuseChunks_GraphicsMode_preMixin for comments on multiple inheritance\n\t@see: B{FuseChunks_Command._createGraphicsMode} \n\t", "category": "graphics", "imports": ["from graphics.drawing.CS_draw_primitives import drawline", "from graphics.behaviors.shape import get_selCurve_color", "from utilities.constants import green", "from utilities.constants import magenta", "from utilities.constants import blue", "from utilities.constants import darkred", "from commands.Move.Move_GraphicsMode import Move_GraphicsMode", "from commands.Translate.TranslateChunks_GraphicsMode import TranslateChunks_GraphicsMode", "from commands.Rotate.RotateChunks_GraphicsMode import RotateChunks_GraphicsMode", "\t\t\t# This is important and needed in case there is nothing selected.  "]}, {"term": "class", "name": "Rotate_in_FuseChunks_GraphicsMode", "data": "class Rotate_in_FuseChunks_GraphicsMode(FuseChunks_GraphicsMode_preMixin,\n\t\t\t\t\t\t\t\t\t\tRotateChunks_GraphicsMode):\n\t\"\"\"\n\tWhen the translate groupbox of the FuseChunks Command  property manager is \n\tactive, the graphics mode for the command will be \n\tRotate_in_FuseChunks_GraphicsMode. \n\t@see: FuseChunks_GraphicsMode_preMixin for comments on multiple inheritance\n\t@see: B{FuseChunks_Command._createGraphicsMode} \n\t\"\"\"\n\tpass\n", "description": "\n\tWhen the translate groupbox of the FuseChunks Command  property manager is \n\tactive, the graphics mode for the command will be \n\tRotate_in_FuseChunks_GraphicsMode. \n\t@see: FuseChunks_GraphicsMode_preMixin for comments on multiple inheritance\n\t@see: B{FuseChunks_Command._createGraphicsMode} \n\t", "category": "graphics", "imports": ["from graphics.drawing.CS_draw_primitives import drawline", "from graphics.behaviors.shape import get_selCurve_color", "from utilities.constants import green", "from utilities.constants import magenta", "from utilities.constants import blue", "from utilities.constants import darkred", "from commands.Move.Move_GraphicsMode import Move_GraphicsMode", "from commands.Translate.TranslateChunks_GraphicsMode import TranslateChunks_GraphicsMode", "from commands.Rotate.RotateChunks_GraphicsMode import RotateChunks_GraphicsMode", "\t\t\t# This is important and needed in case there is nothing selected.  "]}], [], [], [], [], [{"term": "def", "name": "setConfigOption", "data": "def setConfigOption(opt, value):\n\tCONFIG_OPTIONS[opt] = value\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "setConfigOptions", "data": "def setConfigOptions(**opts):\n\tCONFIG_OPTIONS.update(opts)\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "getConfigOption", "data": "def getConfigOption(opt):\n\treturn CONFIG_OPTIONS[opt]\n\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "systemInfo", "data": "def systemInfo():\n\tprint(\"sys.platform: %s\" % sys.platform)\n\tprint(\"sys.version: %s\" % sys.version)\n\tfrom .Qt import VERSION_INFO\n\tprint(\"qt bindings: %s\" % VERSION_INFO)\n\t\n\tglobal __version__\n\trev = None\n\tif __version__ is None:  ## this code was probably checked out from bzr; look up the last-revision file\n\t\tlastRevFile = os.path.join(os.path.dirname(__file__), '..', '.bzr', 'branch', 'last-revision')\n\t\tif os.path.exists(lastRevFile):\n\t\t\trev = open(lastRevFile, 'r').read().strip()\n\t\n\tprint(\"pyqtgraph: %s; %s\" % (__version__, rev))\n\tprint(\"config:\")\n\timport pprint\n\tpprint.pprint(CONFIG_OPTIONS)\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "renamePyc", "data": "def renamePyc(startDir):\n\t### Used to rename orphaned .pyc files\n\t### When a python file changes its location in the repository, usually the .pyc file\n\t### is left behind, possibly causing mysterious and difficult to track bugs. \n\n\t### Note that this is no longer necessary for python 3.2; from PEP 3147:\n\t### \"If the py source file is missing, the pyc file inside __pycache__ will be ignored. \n\t### This eliminates the problem of accidental stale pyc file imports.\"\n\t\n\tprinted = False\n\tstartDir = os.path.abspath(startDir)\n\tfor path, dirs, files in os.walk(startDir):\n\t\tif '__pycache__' in path:\n\t\t\tcontinue\n\t\tfor f in files:\n\t\t\tfileName = os.path.join(path, f)\n\t\t\tbase, ext = os.path.splitext(fileName)\n\t\t\tpy = base + \".py\"\n\t\t\tif ext == '.pyc' and not os.path.isfile(py):\n\t\t\t\tif not printed:\n\t\t\t\t\tprint(\"NOTE: Renaming orphaned .pyc files:\")\n\t\t\t\t\tprinted = True\n\t\t\t\tn = 1\n\t\t\t\twhile True:\n\t\t\t\t\tname2 = fileName + \".renamed%d\" % n\n\t\t\t\t\tif not os.path.exists(name2):\n\t\t\t\t\t\tbreak\n\t\t\t\t\tn += 1\n\t\t\t\tprint(\"  \" + fileName + \"  ==>\")\n\t\t\t\tprint(\"  \" + name2)\n\t\t\t\tos.rename(fileName, name2)\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "fimportModules", "data": "#def importModules(path, globals, locals, excludes=()):\n\t#\"\"\"Import all modules residing within *path*, return a dict of name: module pairs.\n\t\n\t#Note that *path* MUST be relative to the module doing the import.\t\n\t#\"\"\"\n\t#d = os.path.join(os.path.split(globals['__file__'])[0], path)\n\t#files = set()\n\t#for f in frozenSupport.listdir(d):\n\t\t#if frozenSupport.isdir(os.path.join(d, f)) and f not in ['__pycache__', 'tests']:\n\t\t\t#files.add(f)\n\t\t#elif f[-3:] == '.py' and f != '__init__.py':\n\t\t\t#files.add(f[:-3])\n\t\t#elif f[-4:] == '.pyc' and f != '__init__.pyc':\n\t\t\t#files.add(f[:-4])\n\t\t\n\t#mods = {}\n\t#path = path.replace(os.sep, '.')\n\t#for modName in files:\n\t\t#if modName in excludes:\n\t\t\t#continue\n\t\t#try:\n\t\t\t#if len(path) > 0:\n\t\t\t\t#modName = path + '.' + modName\n\t\t\t#print( \"from .%s import * \" % modName)\n\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\n\t\t\t#mods[modName] = mod\n\t\t#except:\n\t\t\t#import traceback\n\t\t\t#traceback.print_stack()\n\t\t\t#sys.excepthook(*sys.exc_info())\n\t\t\t#print(\"[Error importing module: %s]\" % modName)\n\t\t\t\n\t#return mods\n", "description": "Import all modules residing within *path*, return a dict of name: module pairs.\n\t\n\t#Note that *path* MUST be relative to the module doing the import.\t\n\t#", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "fimportAll", "data": "#def importAll(path, globals, locals, excludes=()):\n\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\n\t#mods = importModules(path, globals, locals, excludes)\n\t#for mod in mods.values():\n\t\t#if hasattr(mod, '__all__'):\n\t\t\t#names = mod.__all__\n\t\t#else:\n\t\t\t#names = [n for n in dir(mod) if n[0] != '_']\n\t\t#for k in names:\n\t\t\t#if hasattr(mod, k):\n\t\t\t\t#globals[k] = getattr(mod, k)\n", "description": "Given a list of modules, import all names from each module into the global namespace.", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "cleanup", "data": "def cleanup():\n\tglobal _cleanupCalled\n\tif _cleanupCalled:\n\t\treturn\n\t\n\tif not getConfigOption('exitCleanup'):\n\t\treturn\n\t\n\tViewBox.quit()  ## tell ViewBox that it doesn't need to deregister views anymore.\n\t\n\t## Workaround for Qt exit crash:\n\t## ALL QGraphicsItems must have a scene before they are deleted.\n\t## This is potentially very expensive, but preferred over crashing.\n\t## Note: this appears to be fixed in PySide as of 2012.12, but it should be left in for a while longer..\n\tif QtGui.QApplication.instance() is None:\n\t\treturn\n\timport gc\n\ts = QtGui.QGraphicsScene()\n\tfor o in gc.get_objects():\n\t\ttry:\n\t\t\tif isinstance(o, QtGui.QGraphicsItem) and isQObjectAlive(o) and o.scene() is None:\n\t\t\t\tif getConfigOption('crashWarning'):\n\t\t\t\t\tsys.stderr.write('Error: graphics item without scene. '\n\t\t\t\t\t\t'Make sure ViewBox.close() and GraphicsView.close() '\n\t\t\t\t\t\t'are properly called before app shutdown (%s)\\n' % (o,))\n\t\t\t\t\n\t\t\t\ts.addItem(o)\n\t\texcept RuntimeError:  ## occurs if a python wrapper no longer has its underlying C++ object\n\t\t\tcontinue\n\t_cleanupCalled = True\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "_connectCleanup", "data": "def _connectCleanup():\n\tglobal _cleanupConnected\n\tif _cleanupConnected:\n\t\treturn\n\tQtGui.QApplication.instance().aboutToQuit.connect(cleanup)\n\t_cleanupConnected = True\n\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "exit", "data": "def exit():\n\t\"\"\"\n\tCauses python to exit without garbage-collecting any objects, and thus avoids\n\tcalling object destructor methods. This is a sledgehammer workaround for \n\ta variety of bugs in PyQt and Pyside that cause crashes on exit.\n\t\n\tThis function does the following in an attempt to 'safely' terminate\n\tthe process:\n\t\n\t* Invoke atexit callbacks\n\t* Close all open file handles\n\t* os._exit()\n\t\n\tNote: there is some potential for causing damage with this function if you\n\tare using objects that _require_ their destructors to be called (for example,\n\tto properly terminate log files, disconnect from devices, etc). Situations\n\tlike this are probably quite rare, but use at your own risk.\n\t\"\"\"\n\t\n\t## first disable our own cleanup function; won't be needing it.\n\tsetConfigOptions(exitCleanup=False)\n\t\n\t## invoke atexit callbacks\n\tatexit._run_exitfuncs()\n\t\n\t## close file handles\n\tif sys.platform == 'darwin':\n\t\tfor fd in xrange(3, 4096):\n\t\t\tif fd not in [7]:  # trying to close 7 produces an illegal instruction on the Mac.\n\t\t\t\tos.close(fd)\n\telse:\n\t\tos.closerange(3, 4096) ## just guessing on the maximum descriptor count..\n\n\tos._exit(0)\n\t\n\n", "description": "\n\tCauses python to exit without garbage-collecting any objects, and thus avoids\n\tcalling object destructor methods. This is a sledgehammer workaround for \n\ta variety of bugs in PyQt and Pyside that cause crashes on exit.\n\t\n\tThis function does the following in an attempt to 'safely' terminate\n\tthe process:\n\t\n\t* Invoke atexit callbacks\n\t* Close all open file handles\n\t* os._exit()\n\t\n\tNote: there is some potential for causing damage with this function if you\n\tare using objects that _require_ their destructors to be called (for example,\n\tto properly terminate log files, disconnect from devices, etc). Situations\n\tlike this are probably quite rare, but use at your own risk.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "plot", "data": "def plot(*args, **kargs):\n\t\"\"\"\n\tCreate and return a :class:`PlotWindow ` \n\t(this is just a window with :class:`PlotWidget ` inside), plot data in it.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to plot data. (see :func:`PlotItem.plot() `)\n\t\"\"\"\n\tmkQApp()\n\t#if 'title' in kargs:\n\t\t#w = PlotWindow(title=kargs['title'])\n\t\t#del kargs['title']\n\t#else:\n\t\t#w = PlotWindow()\n\t#if len(args)+len(kargs) > 0:\n\t\t#w.plot(*args, **kargs)\n\t\t\n\tpwArgList = ['title', 'labels', 'name', 'left', 'right', 'top', 'bottom', 'background']\n\tpwArgs = {}\n\tdataArgs = {}\n\tfor k in kargs:\n\t\tif k in pwArgList:\n\t\t\tpwArgs[k] = kargs[k]\n\t\telse:\n\t\t\tdataArgs[k] = kargs[k]\n\t\t\n\tw = PlotWindow(**pwArgs)\n\tif len(args) > 0 or len(dataArgs) > 0:\n\t\tw.plot(*args, **dataArgs)\n\tplots.append(w)\n\tw.show()\n\treturn w\n", "description": "\n\tCreate and return a :class:`PlotWindow ` \n\t(this is just a window with :class:`PlotWidget ` inside), plot data in it.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to plot data. (see :func:`PlotItem.plot() `)\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "image", "data": "def image(*args, **kargs):\n\t\"\"\"\n\tCreate and return an :class:`ImageWindow ` \n\t(this is just a window with :class:`ImageView ` widget inside), show image data inside.\n\tWill show 2D or 3D image data.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to show data. (see :func:`ImageView.setImage() `)\n\t\"\"\"\n\tmkQApp()\n\tw = ImageWindow(*args, **kargs)\n\timages.append(w)\n\tw.show()\n", "description": "\n\tCreate and return an :class:`ImageWindow ` \n\t(this is just a window with :class:`ImageView ` widget inside), show image data inside.\n\tWill show 2D or 3D image data.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to show data. (see :func:`ImageView.setImage() `)\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "dbg", "data": "def dbg(*args, **kwds):\n\t\"\"\"\n\tCreate a console window and begin watching for exceptions.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t\"\"\"\n\tmkQApp()\n\tfrom . import console\n\tc = console.ConsoleWidget(*args, **kwds)\n\tc.catchAllExceptions()\n\tc.show()\n\tglobal consoles\n\ttry:\n\t\tconsoles.append(c)\n\texcept NameError:\n\t\tconsoles = [c]\n\treturn c\n\t\n", "description": "\n\tCreate a console window and begin watching for exceptions.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}, {"term": "def", "name": "mkQApp", "data": "def mkQApp():\n\tglobal QAPP\n\tinst = QtGui.QApplication.instance()\n\tif inst is None:\n\t\tQAPP = QtGui.QApplication([])\n\telse:\n\t\tQAPP = inst\n\treturn QAPP\n\t\t\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtGui", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "from . import python2_3", "from . import numpy_fix", "\t\tprint('Warning: QApplication was created before pyqtgraph was imported; there may be problems (to avoid bugs, call QApplication.setGraphicsSystem(\"raster\") before the QApplication is created).')", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "import atexit", "\timport gc", "\tfrom . import console"]}], [{"term": "def", "name": "tileland_graphics_loader", "data": "def tileland_graphics_loader(path):\n\ttileland_graphics_file_name = os.listdir(path)\n\tfor i in range(0, len(tileland_graphics_file_name)):\n\t\ttileland_graphics_name = str(path) + tileland_graphics_file_name[i]\n\t\tprint(tileland_graphics_name)\n\t\tC.tileland_graphics_path[i] = pygame.image.load(tileland_graphics_name).convert_alpha()\n", "description": null, "category": "graphics", "imports": ["import os", "import pygame"]}], [{"term": "class", "name": "GraphicsMode_API.py--APIclassforwhateverisusedasaGraphicsMode", "data": "GraphicsMode_API.py -- API class for whatever is used as a GraphicsMode\n", "description": null, "category": "graphics", "imports": []}, {"term": "class", "name": "GraphicsMode_API", "data": "class GraphicsMode_API(object):\n\t\"\"\"\n\tAPI class (incomplete) and abstract superclass for all GraphicsMode objects,\n\tincluding nullGraphicsMode; used for isinstance tests\n\t\"\"\"\n\t# history:\n\t# bruce 071008 added object superclass, 071009 split anyMode -> anyGraphicsMode\n\t# bruce 071028 renamed anyGraphicsMode -> GraphicsMode_API and gave it its own file\n\n\t\n\t# GraphicsMode-specific attribute null values\n\t\n\tcompass_moved_in_from_corner = False\n\t\t# when set, tells GLPane to render compass in a different place [bruce 070406]\n\n\trender_scene = None # optional scene-rendering method [bruce 070406]\n\t\t# When this is None, it tells GLPane to use its default method.\n\t\t# (TODO, maybe: move that default method into basicGraphicsMode's implem\n\t\t#  of this, and put a null implem in this class.)\n\t\t# Note: to use this, override it with a method (or set it to a\n\t\t# callable) which is compatible with GLPane.render_scene()\n\t\t# but which receives a single argument which will be the GLPane.\n\t\n\thover_highlighting_enabled = False\n\t\t# note: hover_highlighting_enabled is a settable instance variable in both\n\t\t# the Command and GraphicsMode APIs; a separate GraphicsMode delegates it\n\t\t# as state to its Command [bruce 071011]\n\n\tcheck_target_depth_fudge_factor = 0.0001\n\t\t# affects GLPane's algorithm for finding objectUnderMouse (selobj)\n\n\tpicking = False # used as instance variable in some mouse methods\n\n\t\n\t# default methods for both nullGraphicsMode and basicGraphicsMode\n\t\n\tdef selobj_highlight_color(self, selobj): #bruce 050612 added this to GraphicsMode API; see depositMode version for docstring\n\t\treturn None\n\n\tdef selobj_still_ok(self, selobj): #bruce 050702 added this to GraphicsMode API; overridden in GraphicsMode, and docstring is there\n\t\treturn True\n\n\tdef draw_overlay(self): #bruce 070405\n\t\treturn\n\n\tdef mouse_event_handler_for_event_position(self, wX, wY): #bruce 070405\n\t\treturn None\n\n\tdef update_cursor(self): #bruce 070410\n\t\treturn\n\n\tdef drawHighlightedObjectUnderMouse(self, glpane, selobj, hicolor): #bruce 071008\n\t\tpass\n\n\tpass # end of class GraphicsMode_API\n", "description": "\n\tAPI class (incomplete) and abstract superclass for all GraphicsMode objects,\n\tincluding nullGraphicsMode; used for isinstance tests\n\t", "category": "graphics", "imports": []}], [{"term": "class", "name": "classGraphicName:", "data": "class GraphicName:\n\tdef __init__(self):\n\t\tself.one_dimension_classes_graphics = OneDimensionGraphic.__subclasses__()\n\t\tself.two_dimension_classes_graphics = TwoDimensionGraphic.__subclasses__()\n\t\tself.classes_non_graphics = list(DataInformation.__subclasses__())\n\n\t\tself.classes_graphics = list(self.one_dimension_classes_graphics.copy())\n\t\tself.classes_graphics.extend(list(self.two_dimension_classes_graphics))\n\n\tdef _get_class_one_dimension_graphics(\n\t\tself, name_graphic: str\n\t) -> Union[object, bool]:\n\t\tfor cls in self.one_dimension_classes_graphics:\n\t\t\tif cls.__name__ == name_graphic:\n\t\t\t\treturn cls()\n\t\treturn False\n\n\tdef _get_class_two_dimension_graphics(\n\t\tself, name_graphic: str\n\t) -> Union[object, bool]:\n\t\tfor cls in self.two_dimension_classes_graphics:\n\t\t\tif cls.__name__ == name_graphic:\n\t\t\t\treturn cls()\n\t\treturn False\n\n\tdef _get_class_non_graphics(self, name_non_graphic: str) -> Union[object, bool]:\n\t\tfor cls in self.classes_non_graphics:\n\t\t\tif cls.__name__ == name_non_graphic:\n\t\t\t\treturn cls()\n\t\treturn False\n\n\tdef create_non_graphic(\n\t\tself,\n\t\tname_non_graphic: str,\n\t\tx_axis: Optional[DataFrame] = None,\n\t) -> dict:\n\t\ttry:\n\t\t\tif obj := self._get_class_non_graphics(name_non_graphic):\n\t\t\t\tmethod = getattr(obj, \"create\")\n\t\t\t\treturn method(x_axis)\n\t\t\telse:\n\t\t\t\treturn {}\n\t\texcept:\n\t\t\treturn {}\n\n\tdef create_graphic(\n\t\tself,\n\t\tname_graphic: str,\n\t\tpath: str,\n\t\tx_axis: Optional[DataFrame] = None,\n\t\ty_axis: Optional[DataFrame] = None,\n\t) -> bool:\n\t\ttry:\n\n\t\t\tif obj := self._get_class_one_dimension_graphics(name_graphic):\n\t\t\t\tmethod = getattr(obj, \"create\")\n\t\t\t\treturn method(x_axis, path)\n\n\t\t\telif obj := self._get_class_two_dimension_graphics(name_graphic):\n\t\t\t\tmethod = getattr(obj, \"create\")\n\t\t\t\tmethod(x_axis, y_axis, path)\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\treturn False\n\t\texcept:\n\t\t\treturn False\n", "description": null, "category": "graphics", "imports": ["from typing import Optional, Union", "from pandas import DataFrame", "from app.graphics.dataInformation import DataInformation", "from app.graphics.oneDimensionGraphic import OneDimensionGraphic", "from app.graphics.twoDimensionGraphic import TwoDimensionGraphic"]}], [{"term": "def", "name": "validate_graphics_name", "data": "def validate_graphics_name(list_graphics: List[str]) -> bool:\n\tfor graphic in list_graphics:\n\t\tif graphic not in Graphics.Graphics_Allow:\n\t\t\treturn False\n\treturn True\n\n", "description": null, "category": "graphics", "imports": ["from typing import List", "from app.config.configGraphics import Graphics, NonGraphics"]}, {"term": "def", "name": "validate_non_graphics_name", "data": "def validate_non_graphics_name(list_non_graphics: List[str]) -> bool:\n\tfor graphic in list_non_graphics:\n\t\tif graphic not in NonGraphics.Non_Graphics_Allow:\n\t\t\treturn False\n\treturn True\n", "description": null, "category": "graphics", "imports": ["from typing import List", "from app.config.configGraphics import Graphics, NonGraphics"]}], [], [{"term": "def", "name": "conv2d_strategy_intel_graphics", "data": "def conv2d_strategy_intel_graphics(attrs, inputs, out_type, target):\n\t\"\"\"conv2d intel graphics strategy\"\"\"\n\tstrategy = _op.OpStrategy()\n\tdata, kernel = inputs\n\tdilation_h, dilation_w = get_const_tuple(attrs.dilation)\n\tgroups = attrs.groups\n\tlayout = attrs.data_layout\n\tkernel_layout = attrs.kernel_layout\n\tif dilation_h < 1 or dilation_w < 1:\n\t\traise ValueError(\"dilation should be positive value\")\n\n\tif groups == 1:\n\t\tif layout == \"NCHW\":\n\t\t\tassert kernel_layout == \"OIHW\"\n\t\t\tstrategy.add_implementation(\n\t\t\t\twrap_compute_conv2d(topi.intel_graphics.conv2d_nchw),\n\t\t\t\twrap_topi_schedule(topi.intel_graphics.schedule_conv2d_nchw),\n\t\t\t\tname=\"conv2d_nchw.intel_graphics\",\n\t\t\t)\n\t\t\t# conv2d_NCHWc won't work without alter op layout pass\n\t\t\t# TODO(@Laurawly): fix this\n\t\t\tstrategy.add_implementation(\n\t\t\t\twrap_compute_conv2d(topi.intel_graphics.conv2d_NCHWc, True, True),\n\t\t\t\twrap_topi_schedule(topi.intel_graphics.schedule_conv2d_NCHWc),\n\t\t\t\tname=\"conv2d_NCHWc.intel_graphics\",\n\t\t\t\tplevel=5,\n\t\t\t)\n\t\telse:\n\t\t\traise RuntimeError(\"Unsupported conv2d layout {} for intel graphics\".format(layout))\n\telif is_depthwise_conv2d(data.shape, layout, kernel.shape, kernel_layout, groups):\n\t\tif layout == \"NCHW\":\n\t\t\tassert kernel_layout == \"OIHW\"\n\t\t\tstrategy.add_implementation(\n\t\t\t\twrap_compute_conv2d(topi.intel_graphics.depthwise_conv2d_nchw),\n\t\t\t\twrap_topi_schedule(topi.intel_graphics.schedule_depthwise_conv2d_nchw),\n\t\t\t\tname=\"depthwise_conv2d_nchw.intel_graphics\",\n\t\t\t)\n\t\telse:\n\t\t\traise RuntimeError(\"Unsupported depthwise_conv2d layout {}\".format(layout))\n\telse:  # group_conv2d\n\t\traise RuntimeError(\"group_conv2d is not supported for intel graphics\")\n\treturn strategy\n\n", "description": "conv2d intel graphics strategy", "category": "graphics", "imports": ["# pylint: disable=invalid-name,unused-argument,wildcard-import,unused-wildcard-import", "from tvm import topi", "from .generic import *", "from .. import op as _op"]}, {"term": "def", "name": "conv2d_NCHWc_strategy_intel_graphics", "data": "def conv2d_NCHWc_strategy_intel_graphics(attrs, inputs, out_type, target):\n\t\"\"\"conv2d_NCHWc intel_graphics strategy\"\"\"\n\tstrategy = _op.OpStrategy()\n\tstrategy.add_implementation(\n\t\twrap_compute_conv2d(topi.intel_graphics.conv2d_NCHWc, True, True),\n\t\twrap_topi_schedule(topi.intel_graphics.schedule_conv2d_NCHWc),\n\t\tname=\"conv2d_NCHWc.intel_graphics\",\n\t)\n\treturn strategy\n", "description": "conv2d_NCHWc intel_graphics strategy", "category": "graphics", "imports": ["# pylint: disable=invalid-name,unused-argument,wildcard-import,unused-wildcard-import", "from tvm import topi", "from .generic import *", "from .. import op as _op"]}], [{"term": "def", "name": "setConfigOption", "data": "def setConfigOption(opt, value):\n\tif opt not in CONFIG_OPTIONS:\n\t\traise KeyError('Unknown configuration option \"%s\"' % opt)\n\tif opt == 'imageAxisOrder' and value not in ('row-major', 'col-major'):\n\t\traise ValueError('imageAxisOrder must be either \"row-major\" or \"col-major\"')\n\tCONFIG_OPTIONS[opt] = value\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "setConfigOptions", "data": "def setConfigOptions(**opts):\n\t\"\"\"Set global configuration options. \n\t\n\tEach keyword argument sets one global option. \n\t\"\"\"\n\tfor k,v in opts.items():\n\t\tsetConfigOption(k, v)\n", "description": "Set global configuration options. \n\t\n\tEach keyword argument sets one global option. \n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "getConfigOption", "data": "def getConfigOption(opt):\n\t\"\"\"Return the value of a single global configuration option.\n\t\"\"\"\n\treturn CONFIG_OPTIONS[opt]\n\n", "description": "Return the value of a single global configuration option.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "systemInfo", "data": "def systemInfo():\n\tprint(\"sys.platform: %s\" % sys.platform)\n\tprint(\"sys.version: %s\" % sys.version)\n\tfrom .Qt import VERSION_INFO\n\tprint(\"qt bindings: %s\" % VERSION_INFO)\n\t\n\tglobal __version__\n\trev = None\n\tif __version__ is None:  ## this code was probably checked out from bzr; look up the last-revision file\n\t\tlastRevFile = os.path.join(os.path.dirname(__file__), '..', '.bzr', 'branch', 'last-revision')\n\t\tif os.path.exists(lastRevFile):\n\t\t\twith open(lastRevFile, 'r') as fd:\n\t\t\t\trev = fd.read().strip()\n\t\n\tprint(\"pyqtgraph: %s; %s\" % (__version__, rev))\n\tprint(\"config:\")\n\timport pprint\n\tpprint.pprint(CONFIG_OPTIONS)\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "renamePyc", "data": "def renamePyc(startDir):\n\t### Used to rename orphaned .pyc files\n\t### When a python file changes its location in the repository, usually the .pyc file\n\t### is left behind, possibly causing mysterious and difficult to track bugs. \n\n\t### Note that this is no longer necessary for python 3.2; from PEP 3147:\n\t### \"If the py source file is missing, the pyc file inside __pycache__ will be ignored. \n\t### This eliminates the problem of accidental stale pyc file imports.\"\n\t\n\tprinted = False\n\tstartDir = os.path.abspath(startDir)\n\tfor path, dirs, files in os.walk(startDir):\n\t\tif '__pycache__' in path:\n\t\t\tcontinue\n\t\tfor f in files:\n\t\t\tfileName = os.path.join(path, f)\n\t\t\tbase, ext = os.path.splitext(fileName)\n\t\t\tpy = base + \".py\"\n\t\t\tif ext == '.pyc' and not os.path.isfile(py):\n\t\t\t\tif not printed:\n\t\t\t\t\tprint(\"NOTE: Renaming orphaned .pyc files:\")\n\t\t\t\t\tprinted = True\n\t\t\t\tn = 1\n\t\t\t\twhile True:\n\t\t\t\t\tname2 = fileName + \".renamed%d\" % n\n\t\t\t\t\tif not os.path.exists(name2):\n\t\t\t\t\t\tbreak\n\t\t\t\t\tn += 1\n\t\t\t\tprint(\"  \" + fileName + \"  ==>\")\n\t\t\t\tprint(\"  \" + name2)\n\t\t\t\tos.rename(fileName, name2)\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "fimportModules", "data": "#def importModules(path, globals, locals, excludes=()):\n\t#\"\"\"Import all modules residing within *path*, return a dict of name: module pairs.\n\t\n\t#Note that *path* MUST be relative to the module doing the import.\t\n\t#\"\"\"\n\t#d = os.path.join(os.path.split(globals['__file__'])[0], path)\n\t#files = set()\n\t#for f in frozenSupport.listdir(d):\n\t\t#if frozenSupport.isdir(os.path.join(d, f)) and f not in ['__pycache__', 'tests']:\n\t\t\t#files.add(f)\n\t\t#elif f[-3:] == '.py' and f != '__init__.py':\n\t\t\t#files.add(f[:-3])\n\t\t#elif f[-4:] == '.pyc' and f != '__init__.pyc':\n\t\t\t#files.add(f[:-4])\n\t\t\n\t#mods = {}\n\t#path = path.replace(os.sep, '.')\n\t#for modName in files:\n\t\t#if modName in excludes:\n\t\t\t#continue\n\t\t#try:\n\t\t\t#if len(path) > 0:\n\t\t\t\t#modName = path + '.' + modName\n\t\t\t#print( \"from .%s import * \" % modName)\n\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\n\t\t\t#mods[modName] = mod\n\t\t#except:\n\t\t\t#import traceback\n\t\t\t#traceback.print_stack()\n\t\t\t#sys.excepthook(*sys.exc_info())\n\t\t\t#print(\"[Error importing module: %s]\" % modName)\n\t\t\t\n\t#return mods\n", "description": "Import all modules residing within *path*, return a dict of name: module pairs.\n\t\n\t#Note that *path* MUST be relative to the module doing the import.\t\n\t#", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "fimportAll", "data": "#def importAll(path, globals, locals, excludes=()):\n\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\n\t#mods = importModules(path, globals, locals, excludes)\n\t#for mod in mods.values():\n\t\t#if hasattr(mod, '__all__'):\n\t\t\t#names = mod.__all__\n\t\t#else:\n\t\t\t#names = [n for n in dir(mod) if n[0] != '_']\n\t\t#for k in names:\n\t\t\t#if hasattr(mod, k):\n\t\t\t\t#globals[k] = getattr(mod, k)\n", "description": "Given a list of modules, import all names from each module into the global namespace.", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "cleanup", "data": "def cleanup():\n\tglobal _cleanupCalled\n\tif _cleanupCalled:\n\t\treturn\n\t\n\tif not getConfigOption('exitCleanup'):\n\t\treturn\n\t\n\tViewBox.quit()  ## tell ViewBox that it doesn't need to deregister views anymore.\n\t\n\t## Workaround for Qt exit crash:\n\t## ALL QGraphicsItems must have a scene before they are deleted.\n\t## This is potentially very expensive, but preferred over crashing.\n\t## Note: this appears to be fixed in PySide as of 2012.12, but it should be left in for a while longer..\n\tapp = QtGui.QApplication.instance()\n\tif app is None or not isinstance(app, QtGui.QApplication):\n\t\t# app was never constructed is already deleted or is an\n\t\t# QCoreApplication/QGuiApplication and not a full QApplication\n\t\treturn\n\timport gc\n\ts = QtGui.QGraphicsScene()\n\tfor o in gc.get_objects():\n\t\ttry:\n\t\t\tif isinstance(o, QtGui.QGraphicsItem) and isQObjectAlive(o) and o.scene() is None:\n\t\t\t\tif getConfigOption('crashWarning'):\n\t\t\t\t\tsys.stderr.write('Error: graphics item without scene. '\n\t\t\t\t\t\t'Make sure ViewBox.close() and GraphicsView.close() '\n\t\t\t\t\t\t'are properly called before app shutdown (%s)\\n' % (o,))\n\t\t\t\t\n\t\t\t\ts.addItem(o)\n\t\texcept (RuntimeError, ReferenceError):  ## occurs if a python wrapper no longer has its underlying C++ object\n\t\t\tcontinue\n\t_cleanupCalled = True\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "_connectCleanup", "data": "def _connectCleanup():\n\tglobal _cleanupConnected\n\tif _cleanupConnected:\n\t\treturn\n\tQtGui.QApplication.instance().aboutToQuit.connect(cleanup)\n\t_cleanupConnected = True\n\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "exit", "data": "def exit():\n\t\"\"\"\n\tCauses python to exit without garbage-collecting any objects, and thus avoids\n\tcalling object destructor methods. This is a sledgehammer workaround for \n\ta variety of bugs in PyQt and Pyside that cause crashes on exit.\n\t\n\tThis function does the following in an attempt to 'safely' terminate\n\tthe process:\n\t\n\t  * Invoke atexit callbacks\n\t  * Close all open file handles\n\t  * os._exit()\n\t\n\tNote: there is some potential for causing damage with this function if you\n\tare using objects that _require_ their destructors to be called (for example,\n\tto properly terminate log files, disconnect from devices, etc). Situations\n\tlike this are probably quite rare, but use at your own risk.\n\t\"\"\"\n\t\n\t## first disable our own cleanup function; won't be needing it.\n\tsetConfigOptions(exitCleanup=False)\n\t\n\t## invoke atexit callbacks\n\tatexit._run_exitfuncs()\n\t\n\t## close file handles\n\tif sys.platform == 'darwin':\n\t\tfor fd in range(3, 4096):\n\t\t\tif fd in [7]:  # trying to close 7 produces an illegal instruction on the Mac.\n\t\t\t\tcontinue\n\t\t\ttry:\n\t\t\t\tos.close(fd)\n\t\t\texcept OSError:\n\t\t\t\tpass\n\telse:\n\t\tos.closerange(3, 4096) ## just guessing on the maximum descriptor count..\n\n\tos._exit(0)\n\t\n", "description": "\n\tCauses python to exit without garbage-collecting any objects, and thus avoids\n\tcalling object destructor methods. This is a sledgehammer workaround for \n\ta variety of bugs in PyQt and Pyside that cause crashes on exit.\n\t\n\tThis function does the following in an attempt to 'safely' terminate\n\tthe process:\n\t\n\t  * Invoke atexit callbacks\n\t  * Close all open file handles\n\t  * os._exit()\n\t\n\tNote: there is some potential for causing damage with this function if you\n\tare using objects that _require_ their destructors to be called (for example,\n\tto properly terminate log files, disconnect from devices, etc). Situations\n\tlike this are probably quite rare, but use at your own risk.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "plot", "data": "def plot(*args, **kargs):\n\t\"\"\"\n\tCreate and return a :class:`PlotWidget ` \n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to plot data. (see :func:`PlotItem.plot() `)\n\t\"\"\"\n\tmkQApp()\n\tpwArgList = ['title', 'labels', 'name', 'left', 'right', 'top', 'bottom', 'background']\n\tpwArgs = {}\n\tdataArgs = {}\n\tfor k in kargs:\n\t\tif k in pwArgList:\n\t\t\tpwArgs[k] = kargs[k]\n\t\telse:\n\t\t\tdataArgs[k] = kargs[k]\n\twindowTitle = pwArgs.pop(\"title\", \"PlotWidget\")\n\tw = PlotWidget(**pwArgs)\n\tw.setWindowTitle(windowTitle)\n\tif len(args) > 0 or len(dataArgs) > 0:\n\t\tw.plot(*args, **dataArgs)\n\tplots.append(w)\n\tw.show()\n\treturn w\n", "description": "\n\tCreate and return a :class:`PlotWidget ` \n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to plot data. (see :func:`PlotItem.plot() `)\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "image", "data": "def image(*args, **kargs):\n\t\"\"\"\n\tCreate and return an :class:`ImageView ` \n\tWill show 2D or 3D image data.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to show data. (see :func:`ImageView.setImage() `)\n\t\"\"\"\n\tmkQApp()\n\tw = ImageView()\n\twindowTitle = kargs.pop(\"title\", \"ImageView\")\n\tw.setWindowTitle(windowTitle)\n\tw.setImage(*args, **kargs)\n\timages.append(w)\n\tw.show()\n", "description": "\n\tCreate and return an :class:`ImageView ` \n\tWill show 2D or 3D image data.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to show data. (see :func:`ImageView.setImage() `)\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "dbg", "data": "def dbg(*args, **kwds):\n\t\"\"\"\n\tCreate a console window and begin watching for exceptions.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t\"\"\"\n\tmkQApp()\n\tfrom . import console\n\tc = console.ConsoleWidget(*args, **kwds)\n\tc.catchAllExceptions()\n\tc.show()\n\tglobal consoles\n\ttry:\n\t\tconsoles.append(c)\n\texcept NameError:\n\t\tconsoles = [c]\n\treturn c\n\n", "description": "\n\tCreate a console window and begin watching for exceptions.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "stack", "data": "def stack(*args, **kwds):\n\t\"\"\"\n\tCreate a console window and show the current stack trace.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t\"\"\"\n\tmkQApp()\n\tfrom . import console\n\tc = console.ConsoleWidget(*args, **kwds)\n\tc.setStack()\n\tc.show()\n\tglobal consoles\n\ttry:\n\t\tconsoles.append(c)\n\texcept NameError:\n\t\tconsoles = [c]\n\treturn c\n", "description": "\n\tCreate a console window and show the current stack trace.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}], [{"term": "class", "name": "BaseDrawer", "data": "class BaseDrawer(object):\n\n\t# Create the graphics window, and figure out the scale\n\tdef __init__(self, title, extent, maximumWindowHeightInPixels):\n\t\t# Make sure that the height of the window is less than the specified maximum\n\t\tself.pixelsPerMetre = float(maximumWindowHeightInPixels) / float(extent[1])\n\t\tself.width = 2 + extent[0] * self.pixelsPerMetre\n\t\tself.height = 2 + extent[1] * self.pixelsPerMetre\n\t\tself.title = title\n\t\tself.start = None\n\t\tself.goal = None\n\t\tself.runInteractively = False\n\t\tself.cellExtent = extent\n\t\t\n\t\t# Work out the cell size\n\t\tcellSize = self.pixelsPerMetre\n\n\t\t# Set up the rectangles which will be drawn\t\t\n\t\tself.rectangles = [[Rectangle(Point(i * cellSize, (extent[1] - j - 1) * cellSize), \\\n\t\t\t\t\t\t\t\t\tPoint((i+1)*cellSize, (extent[1] - j)*cellSize)) \\\n\t\t\t\t\t\t\tfor j in range(extent[1])] for i in range(extent[0])]\n\n\t\t\n\t# Open the window and intialise the graphics\n\tdef open(self):\n\t\tself.window = graphics.GraphWin(self.title, self.width, self.height, autoflush = False)\n\t\tself.initialize()\n\t\tgraphics.update(5)\n\n\t# Close the window\n\tdef close(self):\n\t\tif (self.window is not None):\n\t\t\tself.window.close()\n\t\t\tself.window = None\n\n\t# Reset the graphics to the default state\n\tdef reset(self):\n\t\traise NotImplementedError()\n\n\t# Reset the graphics to the default state\n\tdef update(self):\n\t\traise NotImplementedError()\n\n\t# Convert workspace coordinates to window coordinates. This has to\n\t# take account of the scaling and the fact that graphics packages\n\t# use a left handed coordinate system with the origin in the top\n\t# left hand corner.\n\tdef convertWorkspaceCoordinateToScreenCoordinate(self, workspaceCoordinate):\n\t\tscreenCoordinate = (1 + workspaceCoordinate[0] * self.pixelsPerMetre, \n\t\t\t\t\t\t\t 1 + self.height - workspaceCoordinate[1] * self.pixelsPerMetre)\n\t\treturn screenCoordinate\n \n\tdef initialize(self):\n\t\tfor i in range(self.cellExtent[0]):\n\t\t\tfor j in range(self.cellExtent[1]):\n\t\t\t\tself.rectangles[i][j].draw(self.window)\n\n\t# Set the start and goal. The type stored here depends upon the planning algorithm \n\tdef setStartAndGoal(self, start, goal):\n\t\tself.start = start\n\t\tself.goal = goal\n\n\t# Specify if the drawer runs interactively. This causes it to pause\n\tdef setRunInteractively(self, runInteractively):\n\t\tself.runInteractively = runInteractively\n\n\tdef flushAndUpdateWindow(self):\n\t\t# Flush the results\n\t\tself.window.update()\n\t\tself.window.flush()\n\t\t\t\t\t\t  \n\tdef waitForKeyPress(self):\n\n\t\t# If not running interactively, return\n\t\tif not self.runInteractively:\n\t\t\treturn\n\t\t\n\t\t# This always hangs for me:\n\t\t#self.win.getKey()\n\t\ttry:\n\t\t\tinput(\"Press enter to continue...\")\n\t\texcept SyntaxError:\n\t\t\tpass\n", "description": null, "category": "graphics", "imports": ["import rospy", "from search_grid import SearchGrid", "from cell import *", "from graphics import Rectangle", "from graphics import Point", "import graphics"]}, {"term": "class", "name": "SearchGridDrawer", "data": "class SearchGridDrawer(BaseDrawer):\n\n\tdef __init__(self, title, searchGrid, maximumWindowHeightInPixels):\n\t\tBaseDrawer.__init__(self, title, searchGrid.getExtentInCells(), \n\t\t\t\t\t\t\tmaximumWindowHeightInPixels)\n\t\tself.searchGrid = searchGrid;\n\t\t\t\t\n\tdef reset(self):\n\t\tself.start = None\n\t\tself.goal = None\n\n\t# Go through and draw all objects\t\t\n\tdef update(self):\n\t\t\n\t\t# Draw the current plan\n\t\tself.drawPlanGraphics()\n\t\t\n\t\t# Overlay on top the start and the goal\n\t\tself.drawStartAndGoalGraphics()\n\n\t\t# Flush the graphics\n\t\tself.flushAndUpdateWindow()\n\n\tdef setSearchGrid(self,new_sg):\n\tself.searchGrid=new_sg\n\t\t\t\n\tdef drawPlanGraphics(self):\n\t\t\n\t\t# First iterate over all the cells and mark them up\n\t\tcellExtent = self.searchGrid.getExtentInCells()\n\t\tfor i in range(cellExtent[0]):\n\t\t\tif rospy.is_shutdown():\n\t\t\t\treturn\n\t\t\tfor j in range(cellExtent[1]):\n\t\t\t\tcellLabel = self.searchGrid.getCellFromCoords((i, j)).label\n\t\t\t\tif cellLabel == CellLabel.OBSTRUCTED:\n\t\t\t\t\tcolour = 'purple'\t\t\t\n\t\t\t\telif cellLabel == CellLabel.START:\n\t\t\t\t\tcolour = 'green'\n\t\t\t\telif cellLabel == CellLabel.GOAL:\n\t\t\t\t\tcolour = 'blue'\n\t\t\t\telif cellLabel == CellLabel.UNVISITED:\n\t\t\t\t\tcolour = 'gray'\n\t  \t\t\n\t\t\t\telif cellLabel == CellLabel.DEAD:\n\t\t\t\t\tcolour = 'black'\n\t\t\t\telse:\n\t\t\t\t\tcolour = 'white'\n\t\t\t\tself.rectangles[i][j].setFill(colour);\n\n\t# Draw the path with a custom colour\n\tdef drawPathGraphicsWithCustomColour(self, path, colour):\n\t\tfor p in path.waypoints:\n\t\t\tself.rectangles[p.coords[0]][p.coords[1]].setFill(colour)\n\t\t\t\n\t\tself.drawStartAndGoalGraphics()\n\t\tself.window.update()\n\t\tself.window.flush()\n\n\t# Draw the path\n\tdef drawPathGraphics(self, path):\n\t\tself.drawPathGraphicsWithCustomColour(path, 'yellow')\n \n\tdef drawStartAndGoalGraphics(self):\n\t\t# Now manually mark up the start and goal cells\n\t\tif (self.start is not None):\n\t\t\tcoords = self.start.coords\n\t\t\tself.rectangles[coords[0]][coords[1]].setFill('green')\n\n\t\tif (self.goal is not None):\n\t\t\tcoords = self.goal.coords\n\t\t\tself.rectangles[coords[0]][coords[1]].setFill('blue')\n", "description": null, "category": "graphics", "imports": ["import rospy", "from search_grid import SearchGrid", "from cell import *", "from graphics import Rectangle", "from graphics import Point", "import graphics"]}, {"term": "class", "name": "OccupancyGridDrawer", "data": "class OccupancyGridDrawer(BaseDrawer):\n\n\tdef __init__(self, title, occupancyGrid, maximumWindowHeightInPixels):\n\t\tBaseDrawer.__init__(self, title, occupancyGrid.getExtentInCells(), \n\t\t\t\t\t\t\tmaximumWindowHeightInPixels)\n\t\tself.occupancyGrid = occupancyGrid;\n\n\tdef drawGrid(self):\n\n\t\t# Draw the cells using shading\n\t\tcellExtent = self.occupancyGrid.getExtentInCells()\n\t\tfor i in range(cellExtent[0]):\n\t\t\tif rospy.is_shutdown():\n\t\t\t\treturn\n\t\t\tfor j in range(cellExtent[1]):\n\t\t\t\tcellWeight = 1.0 - self.occupancyGrid.getCell(i, j)\n\t\t\t\thexWeight = '{:02x}'.format(int(cellWeight*255))\n\t\t\t\tcolour = '#' + hexWeight + hexWeight + hexWeight\n\t\t\t\tself.rectangles[i][j].setFill(colour);\n\n\t\t\t\t\n\tdef reset(self):\n\t\t# Nothing to do - rendering is stateless\n\t\tpass\n\n\t# Go through and draw all objects\t\t\n\tdef update(self):\n\t\t\n\t\t# Draw the current plan\n\t\tself.drawGrid()\n\n\t\t# Flush the graphics\n\t\tself.flushAndUpdateWindow()\n", "description": null, "category": "graphics", "imports": ["import rospy", "from search_grid import SearchGrid", "from cell import *", "from graphics import Rectangle", "from graphics import Point", "import graphics"]}], [], [], [{"term": "class", "name": "Pipeline", "data": "class Pipeline(object):\n\tdef __init__(self, name):\n\t\t# this should be sparse, don't store any ship info in Pipelines, pass at render time\n\t\tself.name = name\n\n\t@property\n\tdef vehicle_source_input_path(self):\n\t\t# convenience method to get the ship source input image\n\t\t# I considered having this return the Image, not just the path, but it's not saving much, and is less obvious what it does when used\n\t\treturn os.path.join(\n\t\t\tcurrentdir, \"src\", \"graphics\", \"ships\", self.ship.id + \".png\"\n\t\t)\n\n\tdef process_buy_menu_sprite(self, spritesheet):\n\t\t# this function is passed (uncalled) into the pipeline, and then called at render time\n\t\t# this is so that it has the processed spritesheet available, which is essential for creating buy menu sprites\n\t\t# n.b if buy menu sprite processing has conditions by vehicle type, could pass a dedicated function for each type of processing\n\n\t\t# spriteset templates will add 10px left and right padding to buy menu sprite to prevent cramped appearance in buy menu\n\t\t# note that this means\n\t\t# 1. we can't just use the default <- view of the ship, we provide a separate buy menu sprite\n\t\t# 2. we add a blue bounding box to draw into, with the extra padding\n\t\t# 2. the ship is drawn 10px inset from the left edge of bounding box\n\n\t\tdraw_bounding_box = ImageDraw.Draw(spritesheet.sprites)\n\t\tdraw_bounding_box.rectangle(\n\t\t\t[970, 10, 970 + 148, 10 + 48], fill=0, outline=None, width=0\n\t\t)\n\t\tcrop_box_src = (\n\t\t\t630,\n\t\t\t10,\n\t\t\t630 + self.ship.buy_menu_width,\n\t\t\t10 + 48,\n\t\t)\n\t\tcrop_box_dest = (\n\t\t\t980,\n\t\t\t10,\n\t\t\t980 + self.ship.buy_menu_width,\n\t\t\t10 + 48,\n\t\t)\n\t\tcustom_buy_menu_sprite = spritesheet.sprites.copy().crop(crop_box_src)\n\t\tspritesheet.sprites.paste(custom_buy_menu_sprite, crop_box_dest)\n\t\t# increment x offset for pasting in next vehicle\n\t\treturn spritesheet\n\n\tdef render_common(self, ship, input_image, units):\n\t\t# expects to be passed a PIL Image object\n\t\t# units is a list of objects, with their config data already baked in (don't have to pass anything to units except the spritesheet)\n\t\t# each unit is then called in order, passing in and returning a pixa SpriteSheet\n\t\t# finally the spritesheet is saved\n\t\toutput_path = os.path.join(\n\t\t\tcurrentdir, \"generated\", \"graphics\", ship.id + \".png\"\n\t\t)\n\t\tspritesheet = pixa.make_spritesheet_from_image(input_image, DOS_PALETTE)\n\n\t\tfor unit in units:\n\t\t\tspritesheet = unit.render(spritesheet)\n\t\t# I don't normally leave commented-out code behind, but I'm bored of looking in the PIL docs for how to show the image during compile\n\t\t# spritesheet.sprites.show()\n\t\tspritesheet.save(output_path)\n\n\tdef render(self, ship):\n\t\traise NotImplementedError(\"Implement me in %s\" % repr(self))\n\n", "description": null, "category": "graphics", "imports": ["import os.path", "from PIL import Image, ImageDraw", "import polar_fox", "from polar_fox.graphics_units import (", "import polar_fox.pixa as pixa", "from polar_fox.pixa import Spritesheet, PieceCargoSprites", "from gestalt_graphics import graphics_constants"]}, {"term": "class", "name": "PassThroughPipeline", "data": "class PassThroughPipeline(Pipeline):\n\tdef __init__(self):\n\t\t# this should be sparse, don't store any ship info in Pipelines, pass at render time\n\t\tsuper().__init__(\"pass_through_pipeline\")\n\n\tdef render(self, ship, global_constants):\n\t\tinput_image = Image.open(self.vehicle_source_input_path)\n\t\tunits = []\n\t\tself.render_common(ship, input_image, units)\n\t\tinput_image.close()\n\n", "description": null, "category": "graphics", "imports": ["import os.path", "from PIL import Image, ImageDraw", "import polar_fox", "from polar_fox.graphics_units import (", "import polar_fox.pixa as pixa", "from polar_fox.pixa import Spritesheet, PieceCargoSprites", "from gestalt_graphics import graphics_constants"]}, {"term": "class", "name": "ExtendSpriterowsForCompositedCargosPipeline", "data": "class ExtendSpriterowsForCompositedCargosPipeline(Pipeline):\n\t\"\"\" \"\n\tExtends a cargo carrier spritesheet with variations on cargo colours.\n\tQuite convoluted as it handles multiple classes of cargo (bulk, piece etc)\n\t\"\"\"\n\n\tdef __init__(self):\n\t\t# this should be sparse, don't store any ship info in Pipelines, pass at render time\n\t\t# initing things here is proven to have unexpected results, as the processor will be shared across multiple vehicles\n\t\tsuper().__init__(\"extend_spriterows_for_composited_cargos_pipeline\")\n\n\tdef extend_base_image_to_3_rows_with_waterline_masked_per_load_state(\n\t\tself,\n\t\tbase_image,\n\t\tdeck_recolour_map=None,\n\t\thouse_recolour_map=None,\n\t\thouse_make_safe_recolour_map=None,\n\t):\n\t\t# This composites the ship from:\n\t\t# - the ship base image (this contains the detail for the specific ship such as wheelhouse, holds etc)\n\t\t# - a standard hull image, including a waterline mask for each of 'loading' and 'loaded' states\n\t\t# And returns 3 rows, masked at the waterline for each of 3 load states\n\t\t# !! the naming of _base, _image, result_ etc is bad here, confusing, known issue - Oct 2020\n\t\tcrop_box_hull_1 = (\n\t\t\t0,\n\t\t\t10,\n\t\t\tself.sprites_max_x_extent,\n\t\t\t10 + graphics_constants.spriterow_height,\n\t\t)\n\t\tcrop_box_hull_2 = (\n\t\t\t0,\n\t\t\t10 + graphics_constants.spriterow_height,\n\t\t\tself.sprites_max_x_extent,\n\t\t\t10 + (2 * graphics_constants.spriterow_height),\n\t\t)\n\t\tcrop_box_hull_3 = (\n\t\t\t0,\n\t\t\t10 + (2 * graphics_constants.spriterow_height),\n\t\t\tself.sprites_max_x_extent,\n\t\t\t10 + (3 * graphics_constants.spriterow_height),\n\t\t)\n\n\t\tcrop_box_ship_base = (\n\t\t\t0,\n\t\t\t0,\n\t\t\tself.sprites_max_x_extent,\n\t\t\tgraphics_constants.spriterow_height,\n\t\t)\n\n\t\t# the ship image has false colour pixels for the hull, to aid drawing; remove these by converting to white, also convert any blue to white\n\t\tship_base = base_image.point(\n\t\t\tlambda i: 255 if (i in range(178, 192) or i == 0) else i\n\t\t)\n\t\t# create a mask so that we paste only the ship pixels over the hull (no blue pixels)\n\t\tship_mask = ship_base.copy()\n\t\tship_mask = ship_mask.point(lambda i: 0 if i == 255 else 255).convert(\n\t\t\t\"1\"\n\t\t)  # the inversion here of blue and white looks a bit odd, but potato / potato\n\n\t\thull_base = Image.open(self.hull_input_path)\n\t\t# hull_base uses false colour pixels for establishing correct dimensions; make these blue\n\t\thull_image = (\n\t\t\thull_base.copy()\n\t\t\t.crop(crop_box_hull_1)\n\t\t\t.point(lambda i: 0 if (i in range(215, 227) or i == 244) else i)\n\t\t)\n\n\t\t# directly recolour for deck, house and hull adjustments, which can be defined per ship\n\t\t# *not* for cargo-specific hull recoloring, pass cargo_recolour_maps to GestaltGraphicsSimpleColourRemaps for that case\n\t\t# Order\n\t\t# 1. house recolour map tends to use the dark red range as magic colour because it's nice to draw in\n\t\t#\tbut dark red may also be a destination for deck recolour, so first force the house magic red to use the spare (non-hull) purple range\n\t\t# 2. deck recolour, as it recolours arbitrary ranges, and has a chance of colliding with house and hull destination colours\n\t\t# 3. house (tends to use magic colour)\n\t\t# 4. hull (tends to use magic colour)\n\t\trecolour_maps = [\n\t\t\tgraphics_constants.house_make_magic_red_safe_recolour_map,\n\t\t\tself.ship.gestalt_graphics.deck_recolour_map,\n\t\t\tself.ship.gestalt_graphics.house_recolour_map,\n\t\t\tself.ship.gestalt_graphics.hull_recolour_map,\n\t\t]\n\t\tfor recolour_map in recolour_maps:\n\t\t\tif recolour_map is not None:\n\t\t\t\trecolour_table = ProcessingUnit().make_recolour_table(recolour_map)\n\t\t\t\thull_image = hull_image.point(recolour_table)\n\t\t\"\"\"\n\t\tif self.ship.id == \"tanker_ship_gen_3F\":\n\t\t\thull_image.show()\n\t\t\"\"\"\n\t\t# no hull mask used for first load state (row 1), so only need to create 2 hull mask images\n\t\twaterline_mask_row_2 = (\n\t\t\thull_base.copy()\n\t\t\t.crop(crop_box_hull_2)\n\t\t\t.point(lambda i: 0 if i == 226 else 255)\n\t\t\t.convert(\"1\")\n\t\t)\n\t\twaterline_mask_row_3 = (\n\t\t\thull_base.copy()\n\t\t\t.crop(crop_box_hull_3)\n\t\t\t.point(lambda i: 0 if i == 226 else 255)\n\t\t\t.convert(\"1\")\n\t\t)\n\n\t\thull_image.paste(ship_base, crop_box_ship_base, ship_mask)\n\n\t\t# 3 different load states to composite into result image so 3 different crop boxes to make the rows\n\t\tcrop_box_comp_dest_1 = (\n\t\t\t0,\n\t\t\t0,\n\t\t\tself.sprites_max_x_extent,\n\t\t\tgraphics_constants.spriterow_height,\n\t\t)\n\t\tcrop_box_comp_dest_2 = (\n\t\t\t0,\n\t\t\tgraphics_constants.spriterow_height,\n\t\t\tself.sprites_max_x_extent,\n\t\t\t2 * graphics_constants.spriterow_height,\n\t\t)\n\t\tcrop_box_comp_dest_3 = (\n\t\t\t0,\n\t\t\t2 * graphics_constants.spriterow_height,\n\t\t\tself.sprites_max_x_extent,\n\t\t\t3 * graphics_constants.spriterow_height,\n\t\t)\n\n\t\tresult_image = Image.new(\n\t\t\t\"P\", (self.sprites_max_x_extent, 3 * graphics_constants.spriterow_height)\n\t\t)\n\t\tresult_image.putpalette(DOS_PALETTE)\n\t\t# by design, no mask needed for first load state\n\t\tresult_image.paste(hull_image, crop_box_comp_dest_1)\n\t\tresult_image.paste(hull_image, crop_box_comp_dest_2, waterline_mask_row_2)\n\t\tresult_image.paste(hull_image, crop_box_comp_dest_3, waterline_mask_row_3)\n\n\t\thull_base.close()\n\t\treturn result_image\n\n\tdef add_generic_spriterow(self):\n\t\tcrop_box = (\n\t\t\t0,\n\t\t\t0,\n\t\t\tself.sprites_max_x_extent,\n\t\t\tgraphics_constants.spriterow_height,\n\t\t)\n\t\tvehicle_generic_spriterow_input_image = self.vehicle_base_image.crop(crop_box)\n\t\t# vehicle_generic_spriterow_input_image.show() # comment in to see the image when debugging\n\t\tvehicle_generic_spriterow_input_as_spritesheet = (\n\t\t\tpixa.make_spritesheet_from_image(\n\t\t\t\tvehicle_generic_spriterow_input_image, DOS_PALETTE\n\t\t\t)\n\t\t)\n\t\tself.units.append(\n\t\t\tAppendToSpritesheet(\n\t\t\t\tvehicle_generic_spriterow_input_as_spritesheet, crop_box\n\t\t\t)\n\t\t)\n\t\tself.units.append(\n\t\t\tAddCargoLabel(\n\t\t\t\tlabel=\"EMPTY\",\n\t\t\t\tx_offset=self.sprites_max_x_extent + 5,\n\t\t\t\ty_offset=-1 * graphics_constants.spriterow_height,\n\t\t\t)\n\t\t)\n\n\tdef add_livery_only_spriterows(self):\n\t\t# this might be extensible for containers when needed, using simple conditionals\n\t\t# or because containers include random options it might need reworking,\n\t\t# to be more similar to piece cargo handling, but using recolour not actual sprites\n\t\tvehicle_livery_row_image_as_spritesheet = pixa.make_spritesheet_from_image(\n\t\t\tself.vehicle_base_image, DOS_PALETTE\n\t\t)\n\n\t\tfor label, recolour_map in self.ship.gestalt_graphics.cargo_recolour_maps:\n\t\t\tcrop_box_dest = (\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\tself.sprites_max_x_extent,\n\t\t\t\t3 * graphics_constants.spriterow_height,\n\t\t\t)\n\t\t\tself.units.append(\n\t\t\t\tAppendToSpritesheet(\n\t\t\t\t\tvehicle_livery_row_image_as_spritesheet, crop_box_dest\n\t\t\t\t)\n\t\t\t)\n\t\t\tself.units.append(SimpleRecolour(recolour_map))\n\t\t\tself.units.append(\n\t\t\t\tAddCargoLabel(\n\t\t\t\t\tlabel=label,\n\t\t\t\t\tx_offset=self.sprites_max_x_extent + 5,\n\t\t\t\t\ty_offset=-1 * graphics_constants.spriterow_height,\n\t\t\t\t)\n\t\t\t)\n\n\tdef add_bulk_cargo_spriterows(self):\n\t\tcargo_group_row_height = 2 * graphics_constants.spriterow_height\n\t\tcrop_box_source = (\n\t\t\t0,\n\t\t\tself.base_offset,\n\t\t\tself.sprites_max_x_extent,\n\t\t\tself.base_offset + cargo_group_row_height,\n\t\t)\n\t\tvehicle_bulk_cargo_image = self.vehicle_source_image.copy().crop(\n\t\t\tcrop_box_source\n\t\t)\n\t\tvehicle_bulk_cargo_image = vehicle_bulk_cargo_image.point(\n\t\t\tlambda i: 255 if (i in range(178, 192) or i == 0) else i\n\t\t)\n\t\tvehicle_bulk_cargo_mask = (\n\t\t\tvehicle_bulk_cargo_image.copy()\n\t\t\t.point(lambda i: 255 if i == 255 else 0)\n\t\t\t.convert(\"1\")\n\t\t)\n\n\t\tvehicle_base_image = self.vehicle_base_image.copy().crop(\n\t\t\t(0, 100, self.sprites_max_x_extent, 300)\n\t\t)\n\n\t\tvehicle_bulk_cargo_image.paste(\n\t\t\tvehicle_base_image, None, vehicle_bulk_cargo_mask\n\t\t)\n\n\t\t# if self.ship.id == \"freighter_ship_gen_3E\":\n\t\t# vehicle_bulk_cargo_image.show()\n\n\t\tvehicle_bulk_cargo_input_as_spritesheet = pixa.make_spritesheet_from_image(\n\t\t\tvehicle_bulk_cargo_image, DOS_PALETTE\n\t\t)\n\t\tcrop_box_dest = (0, 0, self.sprites_max_x_extent, cargo_group_row_height)\n\t\tfor label, recolour_map in polar_fox.constants.bulk_cargo_recolour_maps:\n\t\t\tself.units.append(\n\t\t\t\tAppendToSpritesheet(\n\t\t\t\t\tvehicle_bulk_cargo_input_as_spritesheet, crop_box_dest\n\t\t\t\t)\n\t\t\t)\n\t\t\tself.units.append(SimpleRecolour(recolour_map))\n\t\t\tself.units.append(\n\t\t\t\tAddCargoLabel(\n\t\t\t\t\tlabel=label,\n\t\t\t\t\tx_offset=self.sprites_max_x_extent + 5,\n\t\t\t\t\ty_offset=-1 * cargo_group_row_height,\n\t\t\t\t)\n\t\t\t)\n\n\tdef add_piece_cargo_spriterows(self):\n\t\tcargo_group_output_row_height = 2 * graphics_constants.spriterow_height\n\n\t\t# Overview\n\t\t# 2 spriterows for the vehicle loading / loaded states, with pink loc points for cargo\n\t\t# a mask row for the vehicle, with pink mask area, which is converted to black and white mask image\n\t\t# an overlay for the vehicle, created from the vehicle empty state spriterow, and comped with the mask after each cargo has been placed\n\t\t# there is a case not handled, where long cargo sprites will cabbed vehicles in / direction with cab at N end, hard to solve\n\t\tcrop_box_vehicle_cargo_loc_row = (\n\t\t\t0,\n\t\t\tself.base_offset,\n\t\t\tself.sprites_max_x_extent,\n\t\t\tself.base_offset + graphics_constants.spriterow_height,\n\t\t)\n\t\tvehicle_cargo_loc_image = self.vehicle_source_image.copy().crop(\n\t\t\tcrop_box_vehicle_cargo_loc_row\n\t\t)\n\t\t# get the loc points\n\t\tloc_points = [\n\t\t\tpixel for pixel in pixa.pixascan(vehicle_cargo_loc_image) if pixel[2] == 226\n\t\t]\n\t\t# two cargo rows needed, so extend the loc points list\n\t\tloc_points.extend(\n\t\t\t[\n\t\t\t\t(pixel[0], pixel[1] + graphics_constants.spriterow_height, pixel[2])\n\t\t\t\tfor pixel in loc_points\n\t\t\t]\n\t\t)\n\t\t# sort them in y order, this causes sprites to overlap correctly when there are multiple loc points for an angle\n\t\tloc_points = sorted(loc_points, key=lambda x: x[1])\n\n\t\tcrop_box_mask = (\n\t\t\t0,\n\t\t\tself.base_offset + graphics_constants.spriterow_height,\n\t\t\tself.sprites_max_x_extent,\n\t\t\tself.base_offset + (2 * graphics_constants.spriterow_height),\n\t\t)\n\t\tvehicle_base_image = self.vehicle_base_image.copy().crop(\n\t\t\t(0, 100, self.sprites_max_x_extent, 300)\n\t\t)\n\t\tvehicle_mask_base_image = (\n\t\t\tself.vehicle_source_image.copy()\n\t\t\t.crop(crop_box_mask)\n\t\t\t.point(lambda i: 255 if i == 226 else 0)\n\t\t\t.convert(\"1\")\n\t\t)\n\t\tvehicle_mask = Image.new(\n\t\t\t\"1\", (self.sprites_max_x_extent, cargo_group_output_row_height)\n\t\t)\n\t\tcrop_box_mask_1 = (\n\t\t\t0,\n\t\t\t0,\n\t\t\tself.sprites_max_x_extent,\n\t\t\t0 + graphics_constants.spriterow_height,\n\t\t)\n\t\tcrop_box_mask_2 = (\n\t\t\t0,\n\t\t\t0 + graphics_constants.spriterow_height,\n\t\t\tself.sprites_max_x_extent,\n\t\t\t0 + (2 * graphics_constants.spriterow_height),\n\t\t)\n\n\t\tvehicle_mask.paste(vehicle_mask_base_image, crop_box_mask_1)\n\t\tvehicle_mask.paste(vehicle_mask_base_image, crop_box_mask_2)\n\t\t# vehicle_mask.show()\n\n\t\tcrop_box_comp_dest_1 = (\n\t\t\t0,\n\t\t\t0,\n\t\t\tself.sprites_max_x_extent,\n\t\t\t2 * graphics_constants.spriterow_height,\n\t\t)\n\t\tvehicle_cargo_rows_image = Image.new(\n\t\t\t\"P\", (self.sprites_max_x_extent, cargo_group_output_row_height)\n\t\t)\n\t\tvehicle_cargo_rows_image.putpalette(DOS_PALETTE)\n\t\t# paste empty states in for the cargo rows (base image = empty state)\n\t\tvehicle_cargo_rows_image.paste(vehicle_base_image, crop_box_comp_dest_1)\n\t\t# vehicle_cargo_rows_image.show()\n\t\tcrop_box_dest = (0, 0, self.sprites_max_x_extent, cargo_group_output_row_height)\n\n\t\tpiece_cargo_sprites = PieceCargoSprites(\n\t\t\tpolar_fox_constants=polar_fox.constants,\n\t\t\tpolar_fox_graphics_path=os.path.join(\"src\", \"polar_fox\", \"graphics\"),\n\t\t)\n\n\t\tfor cargo_filename in polar_fox.constants.piece_vehicle_type_to_sprites_maps[\n\t\t\tself.ship.gestalt_graphics.piece_type\n\t\t]:\n\n\t\t\tcargo_sprites = piece_cargo_sprites.get_cargo_sprites_all_angles_for_length(\n\t\t\t\tcargo_filename, self.ship.cargo_length\n\t\t\t)\n\n\t\t\tvehicle_comped_image = vehicle_cargo_rows_image.copy()\n\t\t\tfor pixel in loc_points:\n\t\t\t\tangle_num = 0\n\t\t\t\tfor counter, bbox in enumerate(\n\t\t\t\t\tself.global_constants.spritesheet_bounding_boxes\n\t\t\t\t):\n\t\t\t\t\tif pixel[0] >= bbox[0]:\n\t\t\t\t\t\tangle_num = counter\n\t\t\t\t# clamp angle_num to 4, cargo sprites are symmetrical, only 4 angles provided\n\t\t\t\tif angle_num > 3:\n\t\t\t\t\tangle_num = angle_num % 4\n\t\t\t\tcargo_sprite_num = angle_num\n\t\t\t\t# loaded sprites are the second block of 4 in the cargo sprites list\n\t\t\t\tif pixel[1] >= graphics_constants.spriterow_height:\n\t\t\t\t\tcargo_sprite_num = cargo_sprite_num + 4\n\t\t\t\tcargo_width = cargo_sprites[cargo_sprite_num][0].size[0]\n\t\t\t\tcargo_height = cargo_sprites[cargo_sprite_num][0].size[1]\n\t\t\t\t# the +1s for height adjust the crop box to include the loc point\n\t\t\t\t# (needed beause loc points are left-bottom not left-top as per co-ordinate system, makes drawing loc points easier)\n\t\t\t\tcargo_bounding_box = (\n\t\t\t\t\tpixel[0],\n\t\t\t\t\tpixel[1] - cargo_height + 1,\n\t\t\t\t\tpixel[0] + cargo_width,\n\t\t\t\t\tpixel[1] + 1,\n\t\t\t\t)\n\t\t\t\tvehicle_comped_image.paste(\n\t\t\t\t\tcargo_sprites[cargo_sprite_num][0],\n\t\t\t\t\tcargo_bounding_box,\n\t\t\t\t\tcargo_sprites[cargo_sprite_num][1],\n\t\t\t\t)\n\t\t\t\t# if self.ship.id == 'universal_freighter_D' and cargo_filename == 'barrels_silver':\n\t\t\t\t# cargo_sprites[cargo_sprite_num][0].show()\n\t\t\t# vehicle overlay with mask - overlays any areas where cargo shouldn't show\n\t\t\tvehicle_comped_image.paste(\n\t\t\t\tvehicle_base_image, crop_box_comp_dest_1, vehicle_mask\n\t\t\t)\n\t\t\t# if self.ship.id == 'universal_freighter_D':\n\t\t\t# vehicle_comped_image.show()\n\t\t\tvehicle_comped_image_as_spritesheet = pixa.make_spritesheet_from_image(\n\t\t\t\tvehicle_comped_image, DOS_PALETTE\n\t\t\t)\n\t\t\tself.units.append(\n\t\t\t\tAppendToSpritesheet(vehicle_comped_image_as_spritesheet, crop_box_dest)\n\t\t\t)\n\t\t\tself.units.append(\n\t\t\t\tAddCargoLabel(\n\t\t\t\t\tlabel=cargo_filename,\n\t\t\t\t\tx_offset=self.sprites_max_x_extent + 5,\n\t\t\t\t\ty_offset=-1 * cargo_group_output_row_height,\n\t\t\t\t)\n\t\t\t)\n\n\tdef render(self, ship, global_constants):\n\t\tself.hull_input_path = os.path.join(\n\t\t\tcurrentdir, \"src\", \"graphics\", \"hulls\", ship.hull_spritesheet_name + \".png\"\n\t\t)\n\t\tself.units = []\n\t\tself.global_constants = global_constants\n\t\tself.ship = ship\n\t\tself.sprites_max_x_extent = self.global_constants.sprites_max_x_extent\n\n\t\tself.vehicle_source_image = Image.open(self.vehicle_source_input_path)\n\n\t\tcrop_box_source = (\n\t\t\t0,\n\t\t\t10,\n\t\t\tself.sprites_max_x_extent,\n\t\t\t10 + graphics_constants.spriterow_height,\n\t\t)\n\t\t# create a base vehicle image by comping in hull, with empty / loading / loaded hull states\n\t\tself.vehicle_base_image = (\n\t\t\tself.extend_base_image_to_3_rows_with_waterline_masked_per_load_state(\n\t\t\t\tself.vehicle_source_image.copy().crop(crop_box_source)\n\t\t\t)\n\t\t)\n\t\t# the cumulative_input_spriterow_count updates per processed group of spriterows, and is key to making this work\n\t\tcumulative_input_spriterow_count = 0\n\t\tfor vehicle_counter, vehicle_rows in enumerate(ship.get_spriterow_counts()):\n\t\t\tself.cur_vehicle_empty_row_offset = (\n\t\t\t\t10\n\t\t\t\t+ cumulative_input_spriterow_count * graphics_constants.spriterow_height\n\t\t\t)\n\t\t\tfor spriterow_data in vehicle_rows:\n\t\t\t\tspriterow_type = spriterow_data[0]\n\t\t\t\tself.base_offset = 10 + (\n\t\t\t\t\tgraphics_constants.spriterow_height\n\t\t\t\t\t* cumulative_input_spriterow_count\n\t\t\t\t)\n\t\t\t\tif (\n\t\t\t\t\tspriterow_type == \"always_use_same_spriterow\"\n\t\t\t\t\tor spriterow_type == \"empty\"\n\t\t\t\t):\n\t\t\t\t\tinput_spriterow_count = 1\n\t\t\t\t\tself.add_generic_spriterow()\n\t\t\t\telif spriterow_type == \"livery_only\":\n\t\t\t\t\tinput_spriterow_count = 1\n\t\t\t\t\tself.add_livery_only_spriterows()\n\t\t\t\telif spriterow_type == \"bulk_cargo\":\n\t\t\t\t\tinput_spriterow_count = 2\n\t\t\t\t\tself.add_bulk_cargo_spriterows()\n\t\t\t\telif spriterow_type == \"piece_cargo\":\n\t\t\t\t\tinput_spriterow_count = 2\n\t\t\t\t\tself.add_piece_cargo_spriterows()\n\t\t\t\tcumulative_input_spriterow_count += input_spriterow_count\n\n\t\tself.units.append(AddBuyMenuSprite(self.process_buy_menu_sprite))\n\n\t\t# for this pipeline, input_image is just blank white 10px high image, to which the vehicle sprites are then appended\n\t\tinput_image = Image.new(\"P\", (graphics_constants.spritesheet_width, 10), 255)\n\t\tinput_image.putpalette(DOS_PALETTE)\n\t\tself.render_common(ship, input_image, self.units)\n\t\tself.vehicle_source_image.close()\n\n", "description": " \"\n\tExtends a cargo carrier spritesheet with variations on cargo colours.\n\tQuite convoluted as it handles multiple classes of cargo (bulk, piece etc)\n\t", "category": "graphics", "imports": ["import os.path", "from PIL import Image, ImageDraw", "import polar_fox", "from polar_fox.graphics_units import (", "import polar_fox.pixa as pixa", "from polar_fox.pixa import Spritesheet, PieceCargoSprites", "from gestalt_graphics import graphics_constants"]}, {"term": "def", "name": "get_pipeline", "data": "def get_pipeline(pipeline_name):\n\t# return a pipeline by name;\n\t# add pipelines here when creating new ones\n\tfor pipeline in [\n\t\tPassThroughPipeline(),\n\t\tExtendSpriterowsForCompositedCargosPipeline(),\n\t]:\n\t\tif pipeline_name == pipeline.name:\n\t\t\treturn pipeline\n\traise Exception(\"Pipeline not found: \" + pipeline_name)  # should never get to here\n\n", "description": null, "category": "graphics", "imports": ["import os.path", "from PIL import Image, ImageDraw", "import polar_fox", "from polar_fox.graphics_units import (", "import polar_fox.pixa as pixa", "from polar_fox.pixa import Spritesheet, PieceCargoSprites", "from gestalt_graphics import graphics_constants"]}, {"term": "def", "name": "main", "data": "def main():\n\tprint(\"yeah, pipelines.main() does nothing\")\n\n", "description": null, "category": "graphics", "imports": ["import os.path", "from PIL import Image, ImageDraw", "import polar_fox", "from polar_fox.graphics_units import (", "import polar_fox.pixa as pixa", "from polar_fox.pixa import Spritesheet, PieceCargoSprites", "from gestalt_graphics import graphics_constants"]}], [], [], [], [], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\n\twhile True:\n\t\tglobal NUM_LIVES\n\t\tif graphics.switch and NUM_LIVES > 0:\n\t\t\tgraphics.rebound_the_wall()\n\t\t\tgraphics.ball.move(graphics.get_dx(), graphics.get_dy())\n\t\t\tgraphics.rebound_the_paddle()\n\t\t\tgraphics.remove_brick()\n\t\t\tgraphics.win()\n\t\t\tif graphics.ball.y > graphics.window.height:\n\t\t\t\tNUM_LIVES -= 1\n\t\t\t\tgraphics.restart()  # turn off switch and reset the initial speed\n\t\tpause(FRAME_RATE)\n\n\t\tif NUM_LIVES == 0:\n\t\t\tgraphics.the_end()\n\t\t\tbreak\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "def", "name": "main", "data": "def main():\n\tglobal lives, score\n\tgraphics = BreakoutGraphics()\n\n\t# Add the animation loop here!\n\tscores_label = graphics.scores_label\n\tlives_label = graphics.lives_label\n\n\tgraphics.window.add(scores_label, 10, graphics.window.height - 10)\n\tgraphics.window.add(lives_label, graphics.window.width - graphics.lives_label.width/2, graphics.window.height-10)\n\tlives_label.text = \"Life: \" + str(lives)\n\n\tdx = graphics.get_x_speed()\n\tdy = graphics.get_y_speed()\n\n\twhile True:\n\t\tpause(FRAME_RATE)\n\t\tif graphics.get_state():\n\t\t\tgraphics.ball.move(dx, dy)\n\n\t\t\t# Check if the ball hit the bricks or the paddle\n\t\t\tif graphics.check_ball_hit_paddle():\n\t\t\t\tdy = -dy\n\n\t\t\tif graphics.check_ball_hit_bricks():\n\t\t\t\tscore += 1\n\t\t\t\tscores_label.text = \"Score: \" + str(score)\n\t\t\t\t# Set up the condition of winning the game\n\t\t\t\tif score == graphics.bricks_cols * graphics.bricks_rows:\n\t\t\t\t\tgraphics.win_the_game()\n\t\t\t\t\tbreak\n\t\t\t\tdy = -dy\n\n\t\t\t# Check the boundary, and if ball is out of the bottom boundary and lose one life\n\t\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\t\t\tdx = -dx\n\t\t\tif graphics.ball.y <= 0:\n\t\t\t\tdy = -dy\n\t\t\tif graphics.ball.y + graphics.ball.height >= graphics.window.height:\n\t\t\t\tgraphics.window.remove(graphics.ball)\n\t\t\t\tgraphics.reset_ball_position()\n\t\t\t\tgraphics.set_ball_velocity()\n\t\t\t\tlives -= 1\n\t\t\t\tlives_label.text = \"Life: \" + str(lives)\n\t\t\t\tif lives == 0:\n\t\t\t\t\tgraphics.lose_the_game()\n\t\t\t\t\tbreak\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "def", "name": "__init__", "data": "  def __init__(self):\n\tself.frames = {\n\t  # Magic\n\t  'flame': import_folder('../graphics/particles/flame/frames'),\n\t  'aura': import_folder('../graphics/particles/aura'),\n\t  'heal': import_folder('../graphics/particles/heal/frames'),\n\t  \n\t  # Attacks \n\t  'claw': import_folder('../graphics/particles/claw'),\n\t  'slash': import_folder('../graphics/particles/slash'),\n\t  'sparkle': import_folder('../graphics/particles/sparkle'),\n\t  'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\n\t  'thunder': import_folder('../graphics/particles/thunder'),\n\n\t  # Monster deaths\n\t  'squid': import_folder('../graphics/particles/smoke_orange'),\n\t  'raccoon': import_folder('../graphics/particles/raccoon'),\n\t  'spirit': import_folder('../graphics/particles/nova'),\n\t  'bamboo': import_folder('../graphics/particles/bamboo'),\n\t  \n\t  # Leafs \n\t  'leaf': (\n\t\timport_folder('../graphics/particles/leaf1'),\n\t\timport_folder('../graphics/particles/leaf2'),\n\t\timport_folder('../graphics/particles/leaf3'),\n\t\timport_folder('../graphics/particles/leaf4'),\n\t\timport_folder('../graphics/particles/leaf5'),\n\t\timport_folder('../graphics/particles/leaf6'),\n\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\n\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\n\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\n\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\n\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\n\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\n\t\t)\n\t  }\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t  'flame': import_folder('../graphics/particles/flame/frames'),", "\t  'aura': import_folder('../graphics/particles/aura'),", "\t  'heal': import_folder('../graphics/particles/heal/frames'),", "\t  'claw': import_folder('../graphics/particles/claw'),", "\t  'slash': import_folder('../graphics/particles/slash'),", "\t  'sparkle': import_folder('../graphics/particles/sparkle'),", "\t  'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t  'thunder': import_folder('../graphics/particles/thunder'),", "\t  'squid': import_folder('../graphics/particles/smoke_orange'),", "\t  'raccoon': import_folder('../graphics/particles/raccoon'),", "\t  'spirit': import_folder('../graphics/particles/nova'),", "\t  'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\timport_folder('../graphics/particles/leaf1'),", "\t\timport_folder('../graphics/particles/leaf2'),", "\t\timport_folder('../graphics/particles/leaf3'),", "\t\timport_folder('../graphics/particles/leaf4'),", "\t\timport_folder('../graphics/particles/leaf5'),", "\t\timport_folder('../graphics/particles/leaf6'),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}, {"term": "def", "name": "reflect_images", "data": "  def reflect_images(self, frames):\n\tnew_frames = []\n\n\tfor frame in frames:\n\t  flipped_frame = pygame.transform.flip(frame, True, False)\n\t  new_frames.append(flipped_frame)\n\treturn new_frames\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t  'flame': import_folder('../graphics/particles/flame/frames'),", "\t  'aura': import_folder('../graphics/particles/aura'),", "\t  'heal': import_folder('../graphics/particles/heal/frames'),", "\t  'claw': import_folder('../graphics/particles/claw'),", "\t  'slash': import_folder('../graphics/particles/slash'),", "\t  'sparkle': import_folder('../graphics/particles/sparkle'),", "\t  'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t  'thunder': import_folder('../graphics/particles/thunder'),", "\t  'squid': import_folder('../graphics/particles/smoke_orange'),", "\t  'raccoon': import_folder('../graphics/particles/raccoon'),", "\t  'spirit': import_folder('../graphics/particles/nova'),", "\t  'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\timport_folder('../graphics/particles/leaf1'),", "\t\timport_folder('../graphics/particles/leaf2'),", "\t\timport_folder('../graphics/particles/leaf3'),", "\t\timport_folder('../graphics/particles/leaf4'),", "\t\timport_folder('../graphics/particles/leaf5'),", "\t\timport_folder('../graphics/particles/leaf6'),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}, {"term": "def", "name": "create_grass_particles", "data": "  def create_grass_particles(self, pos, groups):\n\tanimation_frames = choice(self.frames['leaf'])\n\tParticleEffect(pos, animation_frames, groups)\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t  'flame': import_folder('../graphics/particles/flame/frames'),", "\t  'aura': import_folder('../graphics/particles/aura'),", "\t  'heal': import_folder('../graphics/particles/heal/frames'),", "\t  'claw': import_folder('../graphics/particles/claw'),", "\t  'slash': import_folder('../graphics/particles/slash'),", "\t  'sparkle': import_folder('../graphics/particles/sparkle'),", "\t  'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t  'thunder': import_folder('../graphics/particles/thunder'),", "\t  'squid': import_folder('../graphics/particles/smoke_orange'),", "\t  'raccoon': import_folder('../graphics/particles/raccoon'),", "\t  'spirit': import_folder('../graphics/particles/nova'),", "\t  'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\timport_folder('../graphics/particles/leaf1'),", "\t\timport_folder('../graphics/particles/leaf2'),", "\t\timport_folder('../graphics/particles/leaf3'),", "\t\timport_folder('../graphics/particles/leaf4'),", "\t\timport_folder('../graphics/particles/leaf5'),", "\t\timport_folder('../graphics/particles/leaf6'),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}, {"term": "def", "name": "create_particles", "data": "  def create_particles(self, animation_type, pos, groups):\n\tanimation_frames = self.frames[animation_type]\n\tParticleEffect(pos, animation_frames, groups)\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t  'flame': import_folder('../graphics/particles/flame/frames'),", "\t  'aura': import_folder('../graphics/particles/aura'),", "\t  'heal': import_folder('../graphics/particles/heal/frames'),", "\t  'claw': import_folder('../graphics/particles/claw'),", "\t  'slash': import_folder('../graphics/particles/slash'),", "\t  'sparkle': import_folder('../graphics/particles/sparkle'),", "\t  'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t  'thunder': import_folder('../graphics/particles/thunder'),", "\t  'squid': import_folder('../graphics/particles/smoke_orange'),", "\t  'raccoon': import_folder('../graphics/particles/raccoon'),", "\t  'spirit': import_folder('../graphics/particles/nova'),", "\t  'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\timport_folder('../graphics/particles/leaf1'),", "\t\timport_folder('../graphics/particles/leaf2'),", "\t\timport_folder('../graphics/particles/leaf3'),", "\t\timport_folder('../graphics/particles/leaf4'),", "\t\timport_folder('../graphics/particles/leaf5'),", "\t\timport_folder('../graphics/particles/leaf6'),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}, {"term": "def", "name": "__init__", "data": "  def __init__(self, pos, animation_frames, groups):\n\tsuper().__init__(groups)\n\tself.sprite_type = 'magic'\n\tself.frame_index = 0\n\tself.animation_speed = 0.15\n\tself.frames = animation_frames\n\tself.image = self.frames[self.frame_index]\n\tself.rect = self.image.get_rect(center = pos)\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t  'flame': import_folder('../graphics/particles/flame/frames'),", "\t  'aura': import_folder('../graphics/particles/aura'),", "\t  'heal': import_folder('../graphics/particles/heal/frames'),", "\t  'claw': import_folder('../graphics/particles/claw'),", "\t  'slash': import_folder('../graphics/particles/slash'),", "\t  'sparkle': import_folder('../graphics/particles/sparkle'),", "\t  'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t  'thunder': import_folder('../graphics/particles/thunder'),", "\t  'squid': import_folder('../graphics/particles/smoke_orange'),", "\t  'raccoon': import_folder('../graphics/particles/raccoon'),", "\t  'spirit': import_folder('../graphics/particles/nova'),", "\t  'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\timport_folder('../graphics/particles/leaf1'),", "\t\timport_folder('../graphics/particles/leaf2'),", "\t\timport_folder('../graphics/particles/leaf3'),", "\t\timport_folder('../graphics/particles/leaf4'),", "\t\timport_folder('../graphics/particles/leaf5'),", "\t\timport_folder('../graphics/particles/leaf6'),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}, {"term": "def", "name": "animate", "data": "  def animate(self):\n\tself.frame_index += self.animation_speed\n\tif self.frame_index >= len(self.frames):\n\t  self.kill()\n\telse:\n\t  self.image = self.frames[int(self.frame_index)]\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t  'flame': import_folder('../graphics/particles/flame/frames'),", "\t  'aura': import_folder('../graphics/particles/aura'),", "\t  'heal': import_folder('../graphics/particles/heal/frames'),", "\t  'claw': import_folder('../graphics/particles/claw'),", "\t  'slash': import_folder('../graphics/particles/slash'),", "\t  'sparkle': import_folder('../graphics/particles/sparkle'),", "\t  'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t  'thunder': import_folder('../graphics/particles/thunder'),", "\t  'squid': import_folder('../graphics/particles/smoke_orange'),", "\t  'raccoon': import_folder('../graphics/particles/raccoon'),", "\t  'spirit': import_folder('../graphics/particles/nova'),", "\t  'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\timport_folder('../graphics/particles/leaf1'),", "\t\timport_folder('../graphics/particles/leaf2'),", "\t\timport_folder('../graphics/particles/leaf3'),", "\t\timport_folder('../graphics/particles/leaf4'),", "\t\timport_folder('../graphics/particles/leaf5'),", "\t\timport_folder('../graphics/particles/leaf6'),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}, {"term": "def", "name": "update", "data": "  def update(self):\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "\t  'flame': import_folder('../graphics/particles/flame/frames'),", "\t  'aura': import_folder('../graphics/particles/aura'),", "\t  'heal': import_folder('../graphics/particles/heal/frames'),", "\t  'claw': import_folder('../graphics/particles/claw'),", "\t  'slash': import_folder('../graphics/particles/slash'),", "\t  'sparkle': import_folder('../graphics/particles/sparkle'),", "\t  'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t  'thunder': import_folder('../graphics/particles/thunder'),", "\t  'squid': import_folder('../graphics/particles/smoke_orange'),", "\t  'raccoon': import_folder('../graphics/particles/raccoon'),", "\t  'spirit': import_folder('../graphics/particles/nova'),", "\t  'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\timport_folder('../graphics/particles/leaf1'),", "\t\timport_folder('../graphics/particles/leaf2'),", "\t\timport_folder('../graphics/particles/leaf3'),", "\t\timport_folder('../graphics/particles/leaf4'),", "\t\timport_folder('../graphics/particles/leaf5'),", "\t\timport_folder('../graphics/particles/leaf6'),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}], [{"term": "class", "name": "GraphicsUpdateType", "data": "class GraphicsUpdateType(Enum):\n\tWINDOW_SIZE_CHANGE = \"window_size_change\"\n", "description": null, "category": "graphics", "imports": ["import toml", "from enum import Enum", "from data.file_paths import graphics_data_path", "from core.event_bus import event_bus ", "from core.event_types import EventType, NoDataEvent ", "from core.extended_enum import ExtendedEnum", "from graphics.data.image_names import UIImageNames"]}, {"term": "class", "name": "classGraphicsData:", "data": "class GraphicsData:\n\n\twindow_x_size: int\n\twindow_y_size: int\n\n\ttile_image_region_x_start: int \n\ttile_image_region_x_end: int \n\ttile_image_region_y_start: int \n\ttile_image_region_y_end: int\n\t\n\ttile_image_top_pixel_width: int \n\ttile_image_top_pixel_height: int  \n\n\tfont_pixel_size: int\n\tfont_paths: dict[str, str] = dict()\n\n\tasset_base_paths: list[str] = list()\n\n\timage_filenames: dict[str, str] = dict()\n\n\thas_loaded: bool = False\n\n\tdef __init__(self) -> None:\n\t\t# event_bus.add_listener(EventType.INITIAL_LOAD, self.load)\n\t\tpass\n\n\tdef load(self) -> None:\n\t\tprint(\"Loading the graphics data\")\n\n\t\twith open(graphics_data_path) as file:\n\t\t\tgraphics_data = toml.load(file) \n\t\t\tself.window_x_size = graphics_data[\"window_x_size\"]\n\t\t\tself.window_y_size = graphics_data[\"window_y_size\"]\n\n\t\t\tself.tile_image_region_x_start = graphics_data[\"tile_image_region_x_start\"]\n\t\t\tself.tile_image_region_x_end = graphics_data[\"tile_image_region_x_end\"]\n\t\t\tself.tile_image_region_y_start = graphics_data[\"tile_image_region_y_start\"]\n\t\t\tself.tile_image_region_y_end = graphics_data[\"tile_image_region_y_end\"]\n\n\t\t\tself.tile_image_top_pixel_width = graphics_data[\"tile_image_top_pixel_width\"]\n\t\t\tself.tile_image_top_pixel_height = graphics_data[\"tile_image_top_pixel_height\"]\n\n\n\t\t\tself.font_pixel_size = graphics_data[\"font_pixel_size\"]\n\t\t\tself.font_paths = graphics_data[\"font_paths\"]\n\n\t\t\t# load the asset paths\n\t\t\tself.asset_base_paths = graphics_data[\"asset_base_paths\"]\n\n\t\t\t# get the path data object\n\t\t\tself.image_filenames = graphics_data[\"image_filenames\"]\n\n\t\tself.has_loaded = True\n\n\t\tprint(toml.dumps(self.image_filenames))\n\n\tdef update(self, update_type: GraphicsUpdateType, new_value: any) -> None:\n\t\t# here we can mess with the graphics settings\n\t\twith open(graphics_data_path, \"a+\") as file:\n\t\t\texisting_data = toml.load(file)\n\t\t\t\n\t\t\texisting_data[update_type.value] = new_value\n\t\t\t\n\t\t\tfile.seek(0)\n\t\t\ttoml.dump(file)\n\t\t\tfile.truncate()\n", "description": null, "category": "graphics", "imports": ["import toml", "from enum import Enum", "from data.file_paths import graphics_data_path", "from core.event_bus import event_bus ", "from core.event_types import EventType, NoDataEvent ", "from core.extended_enum import ExtendedEnum", "from graphics.data.image_names import UIImageNames"]}], [{"term": "class", "name": "RunText", "data": "class RunText(SampleBase):\n\tdef __init__(self, *args, **kwargs):\n\t\tsuper(RunText, self).__init__(*args, **kwargs)\n\t\tself.parser.add_argument(\"-t\", \"--text\", help=\"The text to scroll on the RGB LED panel\", default=\"Hello world!\")\n\n\tdef run(self):\n\t\toffscreen_canvas = self.matrix.CreateFrameCanvas()\n\t\tfont = graphics.Font()\n\t\tfont.LoadFont(\"fonts/7x13.bdf\")\n\t\tfontBig = graphics.Font()\n\t\tfontBig.LoadFont(\"fonts/10x20.bdf\")\n\t\ttextColor1 = graphics.Color(0, 255, 0)\n\t\ttextColor2 = graphics.Color(0, 0, 255)\n\t\ttextColor3 = graphics.Color(255, 0, 0)\n\t\ttextColor4 = graphics.Color(100, 100, 0)\n\t\tpos = offscreen_canvas.width\n\t\tmy_text = self.args.text\n\n\t\twhile True:\n\t\t\toffscreen_canvas.Clear()\n\t\t\tgraphics.DrawText(offscreen_canvas, font, 50, 15, textColor1, \"Hello \")\n\t\t\tgraphics.DrawText(offscreen_canvas, font, 35, 25, textColor2, \"Mortenson\")\n\t\t\tgraphics.DrawText(offscreen_canvas, fontBig, 0, 15, textColor3, \"<<\")\n\t\t\tgraphics.DrawText(offscreen_canvas, fontBig, 0, 29, textColor3, \"<<\")\n\t\t\tgraphics.DrawText(offscreen_canvas, fontBig, 108, 15, textColor4, \">>\")\n\t\t\tgraphics.DrawText(offscreen_canvas, fontBig, 108, 29, textColor4, \">>\")\n\n\n\t\t\ttime.sleep(0.05)\n\t\t\toffscreen_canvas = self.matrix.SwapOnVSync(offscreen_canvas)\n\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "import time"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tnum_lives = NUM_LIVES\n\twhile num_lives != 0:\n\t\tgraphics.getdx()\n\t\tgraphics.getdy()\n\t\tgraphics.move_ball()\n\t\tgraphics.wall_collisions()\n\t\tgraphics.ball_hit_object()\n\t\tif graphics.ball.y + graphics.ball.height >= graphics.window.height:\n\t\t\tgraphics.die()\n\t\t\tnum_lives -= 1\n\t\tpause(FRAME_RATE)\n\tgraphics.gameover()\n\n\n\n\t# Add animation loop here!\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "def", "name": "main", "data": "def main():\n\t\"\"\"\n\t:return:\n\t\"\"\"\n\tgraphics = BreakoutGraphics()\t\t\t\t\t   # Define graphics as an object produced from BreakoutGraphics.\n\tgraphics.lives = NUM_LIVES\t\t\t\t\t\t  # Define lives as the number of attempts.\n\n\twhile graphics.lives > 0:\t\t\t\t\t\t\t\t\t\t\t   # When user still have lives\n\t\tpause(FRAME_RATE)\n\t\tif graphics.start:\t\t\t\t\t\t\t\t\t\t\t\t  # When user clicks mouse and start the game\n\t\t\tgraphics.ball.move(graphics.get_dx(), graphics.get_dy())\t\t# Let ball move with velocity dx and dy.\n\t\t\tif graphics.collide():\t\t\t\t\t\t\t\t\t\t  # When the ball collides something\n\t\t\t\tgraphics.set_dy(-graphics.get_dy())\t\t\t\t\t\t # Let the ball bounces back\n\t\t\tif graphics.prop_on_screen:\t\t\t\t\t\t\t\t\t # When there's a prop on the screen\n\t\t\t\tgraphics.prop.move(0, PROP_Y_SPEED)\t\t\t\t\t\t # Let the prop drop\n\t\t\t\tif graphics.prop.y > graphics.window.height:\t\t\t\t# When the prop exits the screen\n\t\t\t\t\tgraphics.prop_on_screen = False\t\t\t\t\t\t # Turn off the prop switch\n\t\t\t\tif graphics.catch_prop():\t\t\t\t\t\t\t\t   # When paddle catches the prop\n\t\t\t\t\tif graphics.prop is graphics.add_lives:\n\t\t\t\t\t\tgraphics.window.remove(graphics.prop)\n\t\t\t\t\t\tgraphics.lives += 1\t\t\t\t\t\t\t\t # User's lives plus 1\n\t\t\t\t\t\tgraphics.lives_label.text = 'Lives: ' + str(graphics.lives)\t\t # Update lives_label\n\t\t\t\t\telse:\n\t\t\t\t\t\tgraphics.get_superpower()\t\t\t\t\t\t   # Enable the power of other kinds of props\n\t\t\t\t\tgraphics.prop_on_screen = False\t\t\t\t\t\t # Turn off the prop switch\n\n\t\t\t# When the ball collide the left or right side of the window, the ball bounces back.\n\t\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\t\t\tgraphics.set_dx(-graphics.get_dx())\n\n\t\t\t# When the ball collide the upper side of the window, the ball bounces back.\n\t\t\tif graphics.ball.y <= 0:\n\t\t\t\tgraphics.set_dy(-graphics.get_dy())\n\n\t\t\t# When the ball falls out of the lower side of the window, the ball will not bounce back.\n\t\t\tif graphics.ball.y >= graphics.window.height:\n\t\t\t\tgraphics.lives -= 1\t\t   # user lose one life\n\t\t\t\tgraphics.lives_label.text = 'Lives: ' + str(graphics.lives)\n\t\t\t\tgraphics.start = False\t\t# turn off the switch and ball will start running again when mouse clicks.\n\t\t\t\tgraphics.window.add(graphics.ball, x=(graphics.window.width - graphics.ball.width) / 2,\n\t\t\t\t\t\t\t\t\ty=(graphics.window.height - graphics.ball.height) / 2)  # Add a new ball in the original position\n\n\t\t\tif graphics.count == graphics.total_brick:\t\t  # When ball hits and removes all the bricks\n\t\t\t\tgraphics.win()\t\t\t\t\t\t\t\t  # User wins the game\n\n\tgraphics.lose()\t\t\t\t\t\t\t\t\t\t\t # when user consumes all the lives, he loses the game.\n\n", "description": "\n\t:return:\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics_extension import BreakoutGraphics"]}], [{"term": "class", "name": "BiosVfIntegratedGraphicsApertureSizeConsts", "data": "class BiosVfIntegratedGraphicsApertureSizeConsts():\n\tSUPPORTED_BY_DEFAULT_NO = \"no\"\n\tSUPPORTED_BY_DEFAULT_YES = \"yes\"\n\tVP_INTEGRATED_GRAPHICS_APERTURE_SIZE_1024MB = \"1024mb\"\n\tVP_INTEGRATED_GRAPHICS_APERTURE_SIZE_128MB = \"128mb\"\n\tVP_INTEGRATED_GRAPHICS_APERTURE_SIZE_2048MB = \"2048mb\"\n\tVP_INTEGRATED_GRAPHICS_APERTURE_SIZE_256MB = \"256mb\"\n\tVP_INTEGRATED_GRAPHICS_APERTURE_SIZE_4096MB = \"4096mb\"\n\tVP_INTEGRATED_GRAPHICS_APERTURE_SIZE_512MB = \"512mb\"\n\tVP_INTEGRATED_GRAPHICS_APERTURE_SIZE_PLATFORM_DEFAULT = \"platform-default\"\n\tVP_INTEGRATED_GRAPHICS_APERTURE_SIZE_PLATFORM_RECOMMENDED = \"platform-recommended\"\n\n", "description": null, "category": "graphics", "imports": ["import sys, os", "from ...ucsmo import ManagedObject", "from ...ucscoremeta import UcsVersion, MoPropertyMeta, MoMeta", "from ...ucsmeta import VersionMeta"]}, {"term": "class", "name": "BiosVfIntegratedGraphicsApertureSize", "data": "class BiosVfIntegratedGraphicsApertureSize(ManagedObject):\n\t\"\"\"This is BiosVfIntegratedGraphicsApertureSize class.\"\"\"\n\n\tconsts = BiosVfIntegratedGraphicsApertureSizeConsts()\n\tnaming_props = set([])\n\n\tmo_meta = MoMeta(\"BiosVfIntegratedGraphicsApertureSize\", \"biosVfIntegratedGraphicsApertureSize\", \"Integrated-Graphics-Aperture-Size\", VersionMeta.Version311e, \"InputOutput\", 0x3f, [], [\"admin\", \"ls-compute\", \"ls-config\", \"ls-server\", \"ls-server-policy\", \"pn-policy\"], [u'biosSettings', u'biosVProfile'], [], [None])\n\n\tprop_meta = {\n\t\t\"child_action\": MoPropertyMeta(\"child_action\", \"childAction\", \"string\", VersionMeta.Version311e, MoPropertyMeta.INTERNAL, 0x2, None, None, r\"\"\"((deleteAll|ignore|deleteNonPresent),){0,2}(deleteAll|ignore|deleteNonPresent){0,1}\"\"\", [], []), \n\t\t\"dn\": MoPropertyMeta(\"dn\", \"dn\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_ONLY, 0x4, 0, 256, None, [], []), \n\t\t\"prop_acl\": MoPropertyMeta(\"prop_acl\", \"propAcl\", \"ulong\", VersionMeta.Version311e, MoPropertyMeta.READ_ONLY, None, None, None, None, [], []), \n\t\t\"rn\": MoPropertyMeta(\"rn\", \"rn\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_ONLY, 0x8, 0, 256, None, [], []), \n\t\t\"sacl\": MoPropertyMeta(\"sacl\", \"sacl\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_ONLY, None, None, None, r\"\"\"((none|del|mod|addchild|cascade),){0,4}(none|del|mod|addchild|cascade){0,1}\"\"\", [], []), \n\t\t\"status\": MoPropertyMeta(\"status\", \"status\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_WRITE, 0x10, None, None, r\"\"\"((removed|created|modified|deleted),){0,3}(removed|created|modified|deleted){0,1}\"\"\", [], []), \n\t\t\"supported_by_default\": MoPropertyMeta(\"supported_by_default\", \"supportedByDefault\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_ONLY, None, None, None, None, [\"no\", \"yes\"], []), \n\t\t\"vp_integrated_graphics_aperture_size\": MoPropertyMeta(\"vp_integrated_graphics_aperture_size\", \"vpIntegratedGraphicsApertureSize\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_WRITE, 0x20, None, None, None, [\"1024mb\", \"128mb\", \"2048mb\", \"256mb\", \"4096mb\", \"512mb\", \"platform-default\", \"platform-recommended\"], []), \n\t}\n\n\tprop_map = {\n\t\t\"childAction\": \"child_action\", \n\t\t\"dn\": \"dn\", \n\t\t\"propAcl\": \"prop_acl\", \n\t\t\"rn\": \"rn\", \n\t\t\"sacl\": \"sacl\", \n\t\t\"status\": \"status\", \n\t\t\"supportedByDefault\": \"supported_by_default\", \n\t\t\"vpIntegratedGraphicsApertureSize\": \"vp_integrated_graphics_aperture_size\", \n\t}\n\n\tdef __init__(self, parent_mo_or_dn, **kwargs):\n\t\tself._dirty_mask = 0\n\t\tself.child_action = None\n\t\tself.prop_acl = None\n\t\tself.sacl = None\n\t\tself.status = None\n\t\tself.supported_by_default = None\n\t\tself.vp_integrated_graphics_aperture_size = None\n\n\t\tManagedObject.__init__(self, \"BiosVfIntegratedGraphicsApertureSize\", parent_mo_or_dn, **kwargs)\n\n", "description": "This is BiosVfIntegratedGraphicsApertureSize class.", "category": "graphics", "imports": ["import sys, os", "from ...ucsmo import ManagedObject", "from ...ucscoremeta import UcsVersion, MoPropertyMeta, MoMeta", "from ...ucsmeta import VersionMeta"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tscore = graphics.get_score()\n\t# The initial score\n\tlives = 0\n\t# The lives that player loses\n\tbricks_left = graphics.get_brick_number()\n\t# The number of bricks left\n\tfinish_game = False\n\t# This variable tells that whether the player break all the bricks\n\n\t# The visualized lives\n\tspace = 10\n\tx = graphics.window.width\n\ty = graphics.window.height - space - graphics.get_ball_2r()\n\tfor i in range(NUM_LIVES - 1):\n\t\tlives_left = GOval(graphics.get_ball_2r(), graphics.get_ball_2r())\n\t\tlives_left.filled = True\n\t\tlives_left.fill_color = 'black'\n\t\tx -= (lives_left.width + space)\n\t\tgraphics.window.add(lives_left, x, y)\n\n\t# Add animation loop here!\n\twhile True:\n\t\tif not finish_game and lives < NUM_LIVES:\n\t\t\tif graphics.get_start():\n\t\t\t\tgraphics.window.remove(graphics.get_start_instruction())\n\t\t\t\tgraphics.set_start(False)\n\t\t\t\tdx = graphics.get_dx()\n\t\t\t\tdy = graphics.get_dy()\n\t\t\t\twhile True:\n\t\t\t\t\t# Ball move\n\t\t\t\t\tgraphics.ball.move(dx, dy)\n\n\t\t\t\t\t# Check collision\n\t\t\t\t\tgraphics.check_collision()\n\t\t\t\t\tif graphics.obj is graphics.paddle:\n\t\t\t\t\t\tif graphics.ball.y + graphics.ball.height > graphics.paddle.y:\n\t\t\t\t\t\t\tresidual_y = graphics.ball.y + graphics.ball.height - graphics.paddle.y\n\t\t\t\t\t\t\t# The difference between the bottom of the ball and the top of the paddle\n\t\t\t\t\t\t\tgraphics.ball.move(0, -residual_y)\n\t\t\t\t\t\t\t# Moving the ball onto the top of the paddle\n\t\t\t\t\t\tdy *= -1\n\t\t\t\t\telif graphics.obj is not None:\n\t\t\t\t\t\t# Identify the object above the paddle to avoid removing the score board and visualized lives\n\t\t\t\t\t\tif graphics.ball.y + graphics.ball.height < graphics.paddle.y:\n\t\t\t\t\t\t\tdy *= -1\n\t\t\t\t\t\t\tgraphics.window.remove(graphics.obj)\n\t\t\t\t\t\t\tbricks_left -= 1\n\t\t\t\t\t\t\tgraphics.score_count()\n\t\t\t\t\t\t\t# Identify the score level of the removed brick\n\t\t\t\t\t\t\tscore += graphics.get_score_level()\n\t\t\t\t\t\t\tgraphics.score_board.text = 'Score: '+str(score)\n\n\t\t\t\t\t# Check whether there is no bricks\n\t\t\t\t\tif bricks_left == 0:\n\t\t\t\t\t\tfinish_game = True\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\t# Check whether there is a wall\n\t\t\t\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\t\t\t\t\tdx *= -1\n\t\t\t\t\tif graphics.ball.y <= 0:\n\t\t\t\t\t\tdy *= -1\n\n\t\t\t\t\t# Check whether the ball falls out of the window bottom\n\t\t\t\t\tif graphics.ball.y + graphics.ball.height >= graphics.window.height:\n\t\t\t\t\t\tlives += 1\n\t\t\t\t\t\tif lives == 1:\n\t\t\t\t\t\t\tx += graphics.ball.width / 2\n\t\t\t\t\t\t\tlives_ball = graphics.window.get_object_at(x, y)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tx += graphics.get_ball_2r() + space\n\t\t\t\t\t\t\tlives_ball = graphics.window.get_object_at(x, y)\n\t\t\t\t\t\tgraphics.window.remove(lives_ball)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\t# Pause\n\t\t\t\t\tpause(FRAME_RATE)\n\n\t\t\t\tgraphics.window.add(graphics.ball, graphics.get_ball_x(), graphics.get_ball_y())\n\t\t\tpause(FRAME_RATE)\n\n\t\telif finish_game:\n\t\t\tgraphics.finish_game()\n\t\t\tbreak\n\t\telif lives == NUM_LIVES:\n\t\t\tfor i in range(8):\n\t\t\t\tgraphics.fail_game1()\n\t\t\t\tpause(FRAME_RATE * 6)\n\t\t\t\tgraphics.fail_game2()\n\t\t\t\tpause(FRAME_RATE * 6)\n\t\t\tbreak\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from campy.graphics.gobjects import GOval", "from breakoutgraphics_extensions import BreakoutGraphics"]}], [], [], [{"term": "class", "name": "GhostSprite", "data": "class GhostSprite(mazesprite.MazeSprite):\n\t\"\"\"A base class for all ghost sprites.\"\"\"\n\tdef __init__(self, graphics, navigator):\n\t\tself.color = self.get_color()\n\t\tself.is_scared = False\n\t\tmazesprite.MazeSprite.__init__(self, graphics, navigator)\n\n\tdef get_color():\n\t\t\"\"\"Indicates the color of this ghost.\"\"\"\n\t\tpass\n\tdef get_hunting_frames(self, graphics):\n\t\t\"\"\"Returns the images to use when in hunt mode.\"\"\"\n\t\tpass\n\tdef get_startup_position(self):\n\t\t\"\"\"Returns the tile position where this ghost should be when the game starts.\"\"\"\n\t\tpass\n\tdef get_startup_direction(self):\n\t\t\"\"\"Returns the direction the sprite should be facing when the game starts.\"\"\"\n\t\tpass\n\n\tdef load_frames(self, graphics):\n\t\t\"\"\"This sets the frames properties to contain the appropriate image sets.\"\"\"\n\t\tself.hunting_frames = self.get_hunting_frames(graphics)\n\t\tself.scared_frames = self.get_scared_frames(graphics)\n\t\tself.eyesonly_frames = self.get_eyesonly_frames(graphics)\n\t\tself.set_all_frames(self.hunting_frames)\n\n\tdef set_all_frames(self, frames):\n\t\t\"\"\"Sets the framesets for all 4 directions to the specified single set of frames.\n\t\tWe can do this with ghosts because right now they only have a single sprite\n\t\timage.  IF they had different images for up, down, left and right we'd have to\n\t\taddress them individually.\"\"\"\n\t\tself.up_frames = frames\n\t\tself.down_frames = frames\n\t\tself.left_frames = frames\n\t\tself.right_frames = frames\n\t\tself.frames = frames\n\n\t\tself.direction_frames = {\n\t\t\t\"up\": self.up_frames,\n\t\t\t\"down\": self.down_frames,\n\t\t\t\"left\": self.left_frames,\n\t\t\t\"right\": self.right_frames\n\t\t}\n\n\tdef get_scared_frames(self, graphics):\n\t\t\"\"\"Returns the frameset with 'scared' ghost images. \"\"\"\n\t\treturn [graphics.img_ghost_duress]\n\n\tdef get_eyesonly_frames(self, graphics):\n\t\t\"\"\"Returns the frameset with 'eyes only' ghost images.\"\"\"\n\t\treturn [graphics.img_ghost_eyesonly]\n\n\n\t# This overrides the get_speed() method in the mazesprite class, which GobblerSprite inherits.\n\tdef get_speed(self):\n\t\t\"\"\"Returns the number of pixels that the sprite will move at a time.\"\"\"\n\t\treturn gamedata.GameData.GOBBLER_SPEED\n\n\tdef run_away(self):\n\t\t\"\"\"Puts this ghost in 'scared' mode.\"\"\"\n\t\tself.is_scared = True\n\t\t#self.frames = self.scared_frames\n\t\tself.set_all_frames(self.scared_frames)\n\t\t# I need to slow down the ghosts when they're scared\n\t\t# but messing with the speed causes all kinds of\n\t\t# problems with running through walls.\n\t\t#self.speed = self.get_speed() // 2\n\n\tdef hunt(self):\n\t\t\"\"\"Puts this ghost in 'hunt' mode.\"\"\"\n\t\tself.is_scared = False\n\t\tself.set_all_frames(self.hunting_frames)\n\n", "description": "A base class for all ghost sprites.", "category": "graphics", "imports": ["from directions import *", "import gamedata", "import mazesprite"]}, {"term": "class", "name": "YellowGhostSprite", "data": "class YellowGhostSprite(GhostSprite):\n\t\"\"\"Represent's the yellow ghost's graphics, animation and behaviors.\"\"\"\n\tdef __init__(self, graphics, navigator):\n\t\tGhostSprite.__init__(self, graphics, navigator)\n\n\tdef get_color(self):\n\t\treturn \"Yellow\"\n\n\tdef get_hunting_frames(self, graphics):\n\t\treturn [graphics.img_ghost_yellow]\n\n\tdef get_startup_position(self):\n\t\treturn gamedata.GameData.YELLOW_GHOST_STARTUP_POSITION\n\n\tdef get_startup_direction(self):\n\t\treturn gamedata.GameData.YELLOW_GHOST_STARTUP_DIRECTION\n\n", "description": "Represent's the yellow ghost's graphics, animation and behaviors.", "category": "graphics", "imports": ["from directions import *", "import gamedata", "import mazesprite"]}, {"term": "class", "name": "PinkGhostSprite", "data": "class PinkGhostSprite(GhostSprite):\n\t\"\"\"Represent's the pink ghost's graphics, animation and behaviors.\"\"\"\n\tdef __init__(self, graphics, navigator):\n\t\tGhostSprite.__init__(self, graphics, navigator)\n\n\tdef get_color(self):\n\t\treturn \"Pink\"\n\n\tdef get_hunting_frames(self, graphics):\n\t\treturn [graphics.img_ghost_pink]\n\n\tdef get_startup_position(self):\n\t\treturn gamedata.GameData.PINK_GHOST_STARTUP_POSITION\n\n\tdef get_startup_direction(self):\n\t\treturn gamedata.GameData.PINK_GHOST_STARTUP_DIRECTION\n\n", "description": "Represent's the pink ghost's graphics, animation and behaviors.", "category": "graphics", "imports": ["from directions import *", "import gamedata", "import mazesprite"]}, {"term": "class", "name": "CyanGhostSprite", "data": "class CyanGhostSprite(GhostSprite):\n\t\"\"\"Represent's the cyan ghost's graphics, animation and behaviors.\"\"\"\n\tdef __init__(self, graphics, navigator):\n\t\tGhostSprite.__init__(self, graphics, navigator)\n\n\tdef get_color(self):\n\t\treturn \"Cyan\"\n\n\tdef get_hunting_frames(self, graphics):\n\t\treturn [graphics.img_ghost_cyan]\n\n\tdef get_startup_position(self):\n\t\treturn gamedata.GameData.CYAN_GHOST_STARTUP_POSITION\n\n\tdef get_startup_direction(self):\n\t\treturn gamedata.GameData.CYAN_GHOST_STARTUP_DIRECTION\n\n", "description": "Represent's the cyan ghost's graphics, animation and behaviors.", "category": "graphics", "imports": ["from directions import *", "import gamedata", "import mazesprite"]}, {"term": "class", "name": "RedGhostSprite", "data": "class RedGhostSprite(GhostSprite):\n\t\"\"\"Represent's the red ghost's graphics, animation and behaviors.\"\"\"\n\tdef __init__(self, graphics, navigator):\n\t\tGhostSprite.__init__(self, graphics, navigator)\n\n\tdef get_color(self):\n\t\treturn \"Red\"\n\n\tdef get_hunting_frames(self, graphics):\n\t\treturn [graphics.img_ghost_red]\n\n\tdef get_startup_position(self):\n\t\treturn gamedata.GameData.RED_GHOST_STARTUP_POSITION\n\n\tdef get_startup_direction(self):\n\t\treturn gamedata.GameData.RED_GHOST_STARTUP_DIRECTION\n", "description": "Represent's the red ghost's graphics, animation and behaviors.", "category": "graphics", "imports": ["from directions import *", "import gamedata", "import mazesprite"]}], [{"term": "def", "name": "__init__", "data": "  def __init__(self, *args, fontSize=11, preamble=\"\", mode=None, **kwargs):\n\tsuper(Figure, self).__init__(*args, **kwargs)\n\t\n\tif mode is None:\n\t  if \"talk\" in Figure._getBuildDir():\n\t\tself.mode = \"beamer\"\n\t  elif \"thesis\" in Figure._getBuildDir():\n\t\tself.mode = \"thesis\"\n\t  else:\n\t\tself.mode = \"paper\"\n\telse:\n\t  self.mode = mode\n\t\n\tpreamble = (Figure._TEX_PREAMBLE_COMMON +\n\t\t\t\tFigure._TEX_PREAMBLE_SPECIAL[self.mode] +\n\t\t\t\tpreamble)\n\t\n\tmpl.rcParams.update({\n\t  \"axes.prop_cycle\" : cycler.cycler(color=Figure._LINE_COLORS),\n\t  \"font.size\" : fontSize,\n\t  \"lines.linewidth\" : 1,\n\t  \"pgf.texsystem\" : \"lualatex\",\n\t  \"pgf.rcfonts\" : False,\n\t  \"pgf.preamble\" : preamble.splitlines(),\n\t  \"text.usetex\" : True,\n\t})\n\t\n\tself._saveDisabled = (platform.node() == \"neon\")\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}, {"term": "def", "name": "create", "data": "  def create(*args, scale=1, **kwargs):\n\tif \"figsize\" in kwargs: kwargs[\"figsize\"] = [scale * x for x in kwargs[\"figsize\"]]\n\treturn plt.figure(*args, FigureClass=Figure, **kwargs)\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}, {"term": "def", "name": "_getBuildDir", "data": "  def _getBuildDir():\n\treturn os.path.realpath(os.environ[\"BUILD_DIR\"])\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}, {"term": "def", "name": "_getGraphicsBasename", "data": "  def _getGraphicsBasename():\n\treturn os.path.splitext(os.path.split(os.path.realpath(sys.argv[0]))[1])[0]\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}, {"term": "def", "name": "_computeHash", "data": "  def _computeHash(path):\n\ttry:\n\t  with open(path, \"rb\") as f: return hashlib.md5(f.read()).digest()\n\texcept:\n\t  return None\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}, {"term": "def", "name": "load", "data": "  def load(datPath=None):\n\tFigure.graphicsCounter += 1\n\tgraphicsNumber = Figure.graphicsCounter\n\t\n\tif path is None:\n\t  buildDir = Figure._getBuildDir()\n\t  graphics_basename = Figure._getGraphicsBasename()\n\t  basename = os.path.join(buildDir, \"{}_{}\".format(graphics_basename, graphicsNumber))\n\t  datPath = \"{}.pickle.dat\".format(basename)\n\t\n\tprint(\"Loading {}...\".format(datPath))\n\twith lzma.open(datPath, \"rb\") as f: return pickle.load(f)\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}, {"term": "def", "name": "disableSave", "data": "  def disableSave():\n\tself._saveDisabled = True\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}, {"term": "def", "name": "enableSave", "data": "  def enableSave():\n\tself._saveDisabled = False\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}, {"term": "def", "name": "save", "data": "  def save(self, graphicsNumber=None, hideSpines=True, tightLayout=True, crop=True, close=True):\n\tplt.figure(self.number)\n\t\n\tif graphicsNumber is None:\n\t  Figure.graphicsCounter += 1\n\t  graphicsNumber = Figure.graphicsCounter\n\telse:\n\t  Figure.graphicsCounter = graphicsNumber\n\t\n\tif self._saveDisabled:\n\t  if close: plt.close(self)\n\t  return\n\t\n\tif tightLayout is not False:\n\t  if tightLayout is True: tightLayout = {}\n\t  self.tight_layout(**tightLayout)\n\t\n\tif hideSpines:\n\t  for ax in self.axes:\n\t\tax.spines[\"top\"].set_visible(False)\n\t\tax.spines[\"right\"].set_visible(False)\n\t\n\tif graphicsNumber is None: graphicsNumber = self.number\n\t\n\tbuildDir = Figure._getBuildDir()\n\tgraphics_basename = Figure._getGraphicsBasename()\n\tbasename = os.path.join(buildDir, \"{}_{}\".format(graphics_basename, graphicsNumber))\n\t\n\tsavefigFcn = lambda path: plt.savefig(path, facecolor=self.get_facecolor(),\n\t\t\t\t\t\t\t\t\t\t  transparent=True)\n\t\n\tpgfPath = \"{}.pgf\".format(basename)\n\tprint(\"Saving {}...\".format(os.path.split(pgfPath)[1]))\n\tsavefigFcn(pgfPath)\n\t\n\tpgfXzPath = \"{}.pgf.xz\".format(basename)\n\toldHash = Figure._computeHash(pgfXzPath)\n\twith open(pgfPath, \"rb\") as f: pgf = f.read()\n\twith lzma.open(pgfXzPath, \"wb\") as f: pickle.dump(pgf, f)\n\tos.remove(pgfPath)\n\tnewHash = Figure._computeHash(pgfXzPath)\n\t\n\tpdfPath = \"{}.pdf\".format(basename)\n\t\n\tif (oldHash == newHash) and os.path.isfile(pdfPath):\n\t  print(\"No changes since last run.\")\n\t  pathlib.Path(pdfPath).touch()\n\telse:\n\t  print(\"Compiling to {}...\".format(os.path.split(pdfPath)[1]))\n\t  savefigFcn(pdfPath)\n\t  if crop: subprocess.run([\"pdfcrop\", pdfPath, pdfPath], check=True)\n\t  \n\t  datPath = \"{}.pickle.xz\".format(basename)\n\t  print(\"Saving {}...\".format(os.path.split(datPath)[1]))\n\t  with lzma.open(datPath, \"wb\") as f: pickle.dump(self, f)\n\t\n\tif close: plt.close(self)\n", "description": null, "category": "graphics", "imports": ["import hashlib", "import lzma", "import os", "import pathlib", "import pickle", "import platform", "import subprocess", "import sys", "import cycler", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from mpl_toolkits.mplot3d import Axes3D"]}], [{"term": "class", "name": "classAnimacaoJogador:", "data": "class AnimacaoJogador:\n\tdef __init__(self):\n\t\tself.frames = {\n\t\t# MAGICAS\n\t\t'flame': importar_pasta('graphics/particles/flame/frames'),\n\t\t'aura': importar_pasta('graphics/particles/aura'),\n\t\t'heal': importar_pasta('graphics/particles/heal/frames'),\n\n\t\t# ATAQUES\n\t\t'claw': importar_pasta('graphics/particles/claw'),\n\t\t'slash': importar_pasta('graphics/particles/slash'),\n\t\t'sparkle': importar_pasta('graphics/particles/sparkle'),\n\t\t'leaf_attack': importar_pasta('graphics/particles/leaf_attack'),\n\t\t'thunder': importar_pasta('graphics/particles/thunder'),\n\n\t\t# MORTE DOS MONSTROS\n\t\t'squid': importar_pasta('graphics/particles/smoke_orange'),\n\t\t'raccoon': importar_pasta('graphics/particles/raccoon'),\n\t\t'spirit': importar_pasta('graphics/particles/nova'),\n\t\t'bamboo': importar_pasta('graphics/particles/bamboo'),\n\n\t\t# FOLHAS\n\t\t'leaf': (\n\t\t\timportar_pasta('graphics/particles/leaf1'),\n\t\t\timportar_pasta('graphics/particles/leaf2'),\n\t\t\timportar_pasta('graphics/particles/leaf3'),\n\t\t\timportar_pasta('graphics/particles/leaf4'),\n\t\t\timportar_pasta('graphics/particles/leaf5'),\n\t\t\timportar_pasta('graphics/particles/leaf6'),\n\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf1')),\n\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf2')),\n\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf3')),\n\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf4')),\n\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf5')),\n\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf6'))\n\t\t\t)\n\t\t}\n\t\t\n\t\t\n\tdef reflexo_imagem(self,frames):  \n\t\tnovos_frames = []\n\t\tfor frame in frames:\n\t\t\tgiro_frame = pygame.transform.flip(frame,True,False)\n\t\t\tnovos_frames.append(giro_frame)\n\t\treturn novos_frames\t  \n\n\tdef criar_particulas_grama(self, pos, groups):\n\t\tanimacao_frames = choice(self.frames['leaf'])\n\t\tEfeitoParticula(pos,animacao_frames,groups)\n\t\t\n\tdef criar_particulas(self, tipo_animacao, pos,groups):\n\t\tframes_animacao = self.frames[tipo_animacao]\n\t\tEfeitoParticula(pos, frames_animacao, groups)\n\t\t\n", "description": null, "category": "graphics", "imports": ["from mimetypes import init", "import pygame", "from suporte import importar_pasta", "from random import choice", "\t\t'flame': importar_pasta('graphics/particles/flame/frames'),", "\t\t'aura': importar_pasta('graphics/particles/aura'),", "\t\t'heal': importar_pasta('graphics/particles/heal/frames'),", "\t\t'claw': importar_pasta('graphics/particles/claw'),", "\t\t'slash': importar_pasta('graphics/particles/slash'),", "\t\t'sparkle': importar_pasta('graphics/particles/sparkle'),", "\t\t'leaf_attack': importar_pasta('graphics/particles/leaf_attack'),", "\t\t'thunder': importar_pasta('graphics/particles/thunder'),", "\t\t'squid': importar_pasta('graphics/particles/smoke_orange'),", "\t\t'raccoon': importar_pasta('graphics/particles/raccoon'),", "\t\t'spirit': importar_pasta('graphics/particles/nova'),", "\t\t'bamboo': importar_pasta('graphics/particles/bamboo'),", "\t\t\timportar_pasta('graphics/particles/leaf1'),", "\t\t\timportar_pasta('graphics/particles/leaf2'),", "\t\t\timportar_pasta('graphics/particles/leaf3'),", "\t\t\timportar_pasta('graphics/particles/leaf4'),", "\t\t\timportar_pasta('graphics/particles/leaf5'),", "\t\t\timportar_pasta('graphics/particles/leaf6'),", "\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf1')),", "\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf2')),", "\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf3')),", "\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf4')),", "\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf5')),", "\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf6'))"]}, {"term": "class", "name": "EfeitoParticula", "data": "class EfeitoParticula(pygame.sprite.Sprite):\n\tdef __init__(self, pos ,frames_animacao, groups):\n\t\tsuper().__init__(groups)\n\t\tself.tipo_sprite = 'magic'\n\t\tself.indice_frame = 0\n\t\tself.velocidade_animacao = 0.15\n\t\tself.frames = frames_animacao\n\t\tself.image = self.frames[self.indice_frame]\n\t\tself.rect = self.image.get_rect(center = pos)\n\t\n\t\t\n\tdef animar(self):\n\t\tself.indice_frame += self.velocidade_animacao\n\t\tif self.indice_frame >= len(self.frames):\n\t\t\tself.kill()\n\t\telse:\n\t\t\tself.image = self.frames[int(self.indice_frame)]\n\t\t\t\n\tdef update(self):\n\t\tself.animar()\n", "description": null, "category": "graphics", "imports": ["from mimetypes import init", "import pygame", "from suporte import importar_pasta", "from random import choice", "\t\t'flame': importar_pasta('graphics/particles/flame/frames'),", "\t\t'aura': importar_pasta('graphics/particles/aura'),", "\t\t'heal': importar_pasta('graphics/particles/heal/frames'),", "\t\t'claw': importar_pasta('graphics/particles/claw'),", "\t\t'slash': importar_pasta('graphics/particles/slash'),", "\t\t'sparkle': importar_pasta('graphics/particles/sparkle'),", "\t\t'leaf_attack': importar_pasta('graphics/particles/leaf_attack'),", "\t\t'thunder': importar_pasta('graphics/particles/thunder'),", "\t\t'squid': importar_pasta('graphics/particles/smoke_orange'),", "\t\t'raccoon': importar_pasta('graphics/particles/raccoon'),", "\t\t'spirit': importar_pasta('graphics/particles/nova'),", "\t\t'bamboo': importar_pasta('graphics/particles/bamboo'),", "\t\t\timportar_pasta('graphics/particles/leaf1'),", "\t\t\timportar_pasta('graphics/particles/leaf2'),", "\t\t\timportar_pasta('graphics/particles/leaf3'),", "\t\t\timportar_pasta('graphics/particles/leaf4'),", "\t\t\timportar_pasta('graphics/particles/leaf5'),", "\t\t\timportar_pasta('graphics/particles/leaf6'),", "\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf1')),", "\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf2')),", "\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf3')),", "\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf4')),", "\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf5')),", "\t\t\tself.reflexo_imagem(importar_pasta('graphics/particles/leaf6'))"]}], [{"term": "def", "name": "main", "data": "def main():\n\t\"\"\"\n\tThe ball and cannon will move according to the while loop,\n\twhich include the following actions:\n\t1. Detect object in-front-of direction of ball\n\t2. Bounce at paddle\n\t3. Bounce at hitting cannon\n\t4. Remove bricks\n\t5. Count bricks removed\n\t6. Count HP left\n\t7. If going out-of bottom of window edge, -1 lives\n\t8. When bricks or lives reach 0, end while loop\n\t\"\"\"\n\tglobal lives\n\n\tgraphics = BreakoutGraphics()\n\tnum_bricks = graphics.num_bricks\n\n\t# Add the animation loop here!\n\twhile True:\n\t\tpause(FRAME_RATE)\n\n\t\tvx = graphics.get_x_speed()\n\t\tvy = graphics.get_y_speed()\n\n\t\tgraphics.ball.move(vx, vy)\n\n\t\t# Make cannon move up-and-down\n\t\tgraphics.cannon.move(graphics.cannon_dx, graphics.cannon_dy)\n\t\tif graphics.cannon.y <= graphics.window.height/2.5:\n\t\t\tgraphics.cannon_dy *= -1\n\t\telif graphics.cannon.y >= graphics.paddle.y - graphics.cannon.height:\n\t\t\tif graphics.cannon_dy > 0:\n\t\t\t\tgraphics.cannon_dy *= -1\n\n\t\t# Detecting object in-front-of ball direction\n\t\tfor ball_x in range(int(graphics.ball.x), int(graphics.ball.width)+1, int(graphics.ball.width)):\n\t\t\tcheck = 0\n\t\t\tfor ball_y in range(int(graphics.ball.y), int(graphics.ball.height)+1, int(graphics.ball.height)):\n\t\t\t\tobj = graphics.window.get_object_at(ball_x, ball_y)\n\t\t\t\tif obj is not None:\n\t\t\t\t\tif obj is graphics.score_board:\n\t\t\t\t\t\tpass\n\t\t\t\t\telif graphics.check_image(obj):  # Prevent HP bar being removed\n\t\t\t\t\t\tpass\n\t\t\t\t\telif obj is graphics.cannon:  # Cannon bounces the ball\n\t\t\t\t\t\tif vy > 0:\n\t\t\t\t\t\t\tvy *= -1\n\t\t\t\t\t\t\tgraphics.set_y_speed(vy)\n\t\t\t\t\telif obj is not graphics.paddle:  # Remove bricks\n\t\t\t\t\t\tgraphics.window.remove(obj)\n\t\t\t\t\t\tnum_bricks -= 1\n\t\t\t\t\t\tgraphics.num_bricks -= 1\n\t\t\t\t\t\tgraphics.score_board.text = 'Bricks left: ' + str(graphics.num_bricks)\n\t\t\t\t\t\tvy *= -1\n\t\t\t\t\t\tgraphics.set_y_speed(vy)\n\t\t\t\t\telse:  # Paddle bounces ball\n\t\t\t\t\t\tif vy > 0:\n\t\t\t\t\t\t\tvy *= -1\n\t\t\t\t\t\t\tgraphics.set_y_speed(vy)\n\t\t\t\t\tcheck = 1\n\t\t\t\t\tbreak\n\t\t\tif check == 1:\n\t\t\t\tbreak\n\n\t\tupper_left_obj = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y)\n\t\tupper_right_obj = graphics.window.get_object_at(graphics.ball.x + graphics.ball.width, graphics.ball.y)\n\t\tlower_left_obj = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y + graphics.ball.height)\n\t\tlower_right_obj = graphics.window.get_object_at(graphics.ball.x + graphics.ball.width, graphics.ball.y +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tgraphics.ball.height)\n\n\t\tif upper_left_obj is not None:\n\t\t\tif upper_left_obj is graphics.score_board:\n\t\t\t\tpass\n\t\t\telif graphics.check_image(upper_left_obj):\t\t# Prevent HP bar being removed\n\t\t\t\tpass\n\t\t\telif upper_left_obj is graphics.cannon:\t\t # Cannon bounces the ball\n\t\t\t\tif vy > 0:\n\t\t\t\t\tvy *= -1\n\t\t\t\t\tgraphics.set_y_speed(vy)\n\t\t\telif upper_left_obj is not graphics.paddle:\t # Remove bricks\n\t\t\t\tgraphics.window.remove(upper_left_obj)\n\t\t\t\tnum_bricks -= 1\n\t\t\t\tgraphics.num_bricks -= 1\n\t\t\t\tgraphics.score_board.text = 'Bricks left: ' + str(graphics.num_bricks)\n\t\t\t\tvy *= -1\n\t\t\t\tgraphics.set_y_speed(vy)\n\t\t\telse:\t\t\t\t\t\t\t\t\t\t   # Paddle bounces ball\n\t\t\t\tif vy > 0:\n\t\t\t\t\tvy *= -1\n\t\t\t\t\tgraphics.set_y_speed(vy)\n\n\t\telif upper_right_obj is not None:\n\t\t\tif upper_right_obj is graphics.score_board:\n\t\t\t\tpass\n\t\t\telif graphics.check_image(upper_right_obj):\n\t\t\t\tpass\n\t\t\telif upper_right_obj is graphics.cannon:\n\t\t\t\tif vy > 0:\n\t\t\t\t\tvy *= -1\n\t\t\t\t\tgraphics.set_y_speed(vy)\n\t\t\telif upper_right_obj is not graphics.paddle:\n\t\t\t\tgraphics.window.remove(upper_right_obj)\n\t\t\t\tnum_bricks -= 1\n\t\t\t\tgraphics.num_bricks -= 1\n\t\t\t\tgraphics.score_board.text = 'Bricks left: ' + str(graphics.num_bricks)\n\t\t\t\tvy *= -1\n\t\t\t\tgraphics.set_y_speed(vy)\n\t\t\telse:\n\t\t\t\tif vy > 0:\n\t\t\t\t\tvy *= -1\n\t\t\t\t\tgraphics.set_y_speed(vy)\n\n\t\telif lower_left_obj is not None:\n\t\t\tif lower_left_obj is graphics.score_board:\n\t\t\t\tpass\n\t\t\telif graphics.check_image(lower_left_obj):\n\t\t\t\tpass\n\t\t\telif lower_left_obj is graphics.cannon:\n\t\t\t\tif vy > 0:\n\t\t\t\t\tvy *= -1\n\t\t\t\t\tgraphics.set_y_speed(vy)\n\t\t\telif lower_left_obj is not graphics.paddle:\n\t\t\t\tgraphics.window.remove(lower_left_obj)\n\t\t\t\tnum_bricks -= 1\n\t\t\t\tgraphics.num_bricks -= 1\n\t\t\t\tgraphics.score_board.text = 'Bricks left: ' + str(graphics.num_bricks)\n\t\t\t\tvy *= -1\n\t\t\t\tgraphics.set_y_speed(vy)\n\t\t\telse:\n\t\t\t\tif vy > 0:\n\t\t\t\t\tvy *= -1\n\t\t\t\t\tgraphics.set_y_speed(vy)\n\n\t\telif lower_right_obj is not None:\n\t\t\tif lower_right_obj is graphics.score_board:\n\t\t\t\tpass\n\t\t\telif graphics.check_image(lower_right_obj):\n\t\t\t\tpass\n\t\t\telif lower_right_obj is graphics.cannon:\n\t\t\t\tif vy > 0:\n\t\t\t\t\tvy *= -1\n\t\t\t\t\tgraphics.set_y_speed(vy)\n\t\t\telif lower_right_obj is not graphics.paddle:\n\t\t\t\tgraphics.window.remove(lower_right_obj)\n\t\t\t\tnum_bricks -= 1\n\t\t\t\tgraphics.num_bricks -= 1\n\t\t\t\tgraphics.score_board.text = 'Bricks left: ' + str(graphics.num_bricks)\n\t\t\t\tvy *= -1\n\t\t\t\tgraphics.set_y_speed(vy)\n\t\t\telse:\n\t\t\t\tif vy > 0:\n\t\t\t\t\tvy *= -1\n\t\t\t\t\tgraphics.set_y_speed(vy)\n\n\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\t\tvx *= -1\t\t\t\t\t\t\t\t# When ball hits the side walls, bounce back\n\t\t\tgraphics.set_x_speed(vx)\n\n\t\tif graphics.ball.y <= 0:\t\t\t\t\t# When ball hits the celling, bounce back\n\t\t\tvy *= -1\n\t\t\tgraphics.set_y_speed(vy)\n\n\t\tif graphics.ball.y + graphics.ball.height >= graphics.window.height:\n\t\t\tlives -= 1\t\t\t\t\t\t\t  # When ball falls under window bottom\n\t\t\tremove_heart = graphics.window.get_object_at(x=graphics.window.width - graphics.heart_img.width*lives,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t y=graphics.window.height)\n\t\t\tgraphics.window.remove(remove_heart)\t# Removes one HP\n\t\t\tgraphics.re_position_ball()\t\t\t # Reset the ball at initial position to start the next round\n\t\t\tif lives == 0:\n\t\t\t\tbreak\n\n\t\tif num_bricks % 10 == 0 and num_bricks != 100:\n\t\t\tvy *= 1.001\t\t\t\t\t\t\t # Ball goes faster every 10 bricks removed\n\t\t\tgraphics.set_y_speed(vy)\n\n\t\tif num_bricks == 0:\t\t\t\t\t\t # When clearing all bricks\n\t\t\tbreak\n\tgraphics.game_over(lives, num_bricks)\t\t   # Return the different outcomes basing on num of lives and bricks\n\n", "description": "\n\tThe ball and cannon will move according to the while loop,\n\twhich include the following actions:\n\t1. Detect object in-front-of direction of ball\n\t2. Bounce at paddle\n\t3. Bounce at hitting cannon\n\t4. Remove bricks\n\t5. Count bricks removed\n\t6. Count HP left\n\t7. If going out-of bottom of window edge, -1 lives\n\t8. When bricks or lives reach 0, end while loop\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics_ext import BreakoutGraphics"]}], [], [], [{"term": "def", "name": "weightedRandom", "data": "def weightedRandom(max, numDice): \r\n\tnum = 0\r\n\ti = 0\r\n\twhile ( i < numDice): \r\n\t\tnum += random.random() * (max/numDice)\r\n\t\ti +=1\r\n\t\t\r\n\treturn num\r\n\r\n", "description": null, "category": "graphics", "imports": ["from ctypes.wintypes import tagRECT\r", "from math import cos, dist, sin, sqrt\r", "import random\r", "from re import X\r", "from tkinter import Variable\r", "from turtle import distance\r", "import graphics\r"]}, {"term": "class", "name": "SolarSystem", "data": "class SolarSystem(object):\r\n\r\n\tdef __init__(self, name, centrePoint):\r\n\t\tself.name = name\r\n\t\tself.centrePoint = centrePoint\r\n\t\tself.planets = []\r\n\t\tself.moons = []\r\n\t\tself.stars = []\r\n\t\tself.rings = []\r\n\t\tself.asteroidBelts = []\r\n\t\tself.celestialBodyList = []\r\n\t\tself.orbits = {}\r\n\t\tself.tethers = {}\r\n\t\tself.Time = 0\r\n\t\tself.unitTime = 0.05/rate\r\n\r\n\t\r\n\tdef generateSpacialPartitioning(self):\r\n\t\tgridx = range(-5,6)\r\n\t\tgridy = range(-5,6)\r\n\t\trektXSize = win.getWidth()/2\r\n\t\trektYSize = win.getHeight()/2\r\n\r\n\t\tfor x in gridx:\r\n\t\t\tfor y in gridy:\r\n\t\t\t\tp1 = graphics.Point(x*rektXSize,y*rektYSize)\r\n\t\t\t\tp2 = graphics.Point((x+1)*rektXSize,(y+1)*rektYSize)\r\n\t\t\t\tr = graphics.Rectangle(p1,p2)\r\n\t\t\t\tr.draw(win)\r\n\t\t\t\tself.spacialPartitioningCubes[graphics.Point(x,y)] = r\r\n\t\t\t\tself.partitioningDict[graphics.Point(x,y).__repr__()] = []\r\n\t\r\n\tdef add_planet(self, planet):\r\n\t\tself.planets.append(planet)\r\n\t\t\r\n\tdef add_moon(self, moon):\r\n\t\tself.moons.append(moon)\r\n\r\n\tdef add_star(self, star):\r\n\t\tself.stars.append(star)\r\n\r\n\tdef add_ring(self, ring):\r\n\t\tself.rings.append(ring)\r\n\r\n\tdef add_asteroidBelt(self, asteroidBelt):\r\n\t\tself.asteroidBelts.append(asteroidBelt)\r\n\r\n\tdef setStarPoints(self):\r\n\t\tfor star in self.stars:\r\n\t\t\tstar.point = self.centrePoint\r\n\r\n\tdef setPlanetPoints(self):\r\n\t\tfor planet in self.planets:\r\n\t\t\tx = planet.distancefromsun + Sun.size + Sun.point.getX()\r\n\t\t\ty = planet.point.getY() + Sun.point.getY() - self.centrePoint.getY()\r\n\t\t\tplanet.point = graphics.Point(x,y)\r\n\r\n\tdef setMoonPoints(self):\r\n\t\tfor moon in self.moons:\r\n\t\t\tx = moon.parentPlanet.point.getX()\r\n\t\t\ty = moon.parentPlanet.point.getY() + moon.parentPlanet.size + moon.distanceFromParentPlanet + moon.size\r\n\t\t\tmoon.point = graphics.Point(x,y)\r\n\r\n\tdef setRingPoints(self):\r\n\t\tfor ring in self.rings:\r\n\t\t\tring.point = ring.parentPlanet.point\r\n\r\n\tdef setBeltPoints(self):\r\n\t\tfor belt in self.asteroidBelts:\r\n\t\t\tx = Sun.size + belt.distancefromsun\r\n\t\t\ty = 0\r\n\t\t\tbelt.point = graphics.Point(x,y)\r\n\t\t\r\n\tdef generateCelestialBodyLists(self):\r\n\t\tfor body in self.celestialBodyList:\r\n\t\t\tif type(body) == Star:\r\n\t\t\t\tself.add_star(body)\r\n\r\n\t\t\telif type(body) == Planet:\r\n\t\t\t\tself.add_planet(body)\r\n\t\t\t\tbody.defineOrbit(Sun)\r\n\r\n\t\t\telif type(body) == Moon:\r\n\t\t\t\tself.add_moon(body)\r\n\t\t\t\tbody.defineOrbit(body.parentPlanet)\r\n\r\n\t\t\telif type(body) == Ring:\r\n\t\t\t\tself.add_ring(body)\r\n\r\n\t\t\telif type(body) == AsteroidBelt:\r\n\t\t\t\tself.add_asteroidBelt(body)\r\n\t\t\t\t\r\n\tdef generateCelestialBodyPoints(self):\r\n\t\tself.setStarPoints()\r\n\t\tself.setPlanetPoints()\r\n\t\tself.setMoonPoints()\r\n\t\tself.setRingPoints()\r\n\t\tself.setBeltPoints()\r\n\t\r\n\tdef updateInternalTimeState(self):\r\n\t\tself.Time = self.Time + self.unitTime\r\n\r\n\r\n\tdef orbit(self):\r\n\t\tfor planet, target in self.orbits.items():\r\n\t\t\tdistance = target[1]\r\n\t\t\torbitialSpeed = target[2]\r\n\t\t\ttheta = orbitialSpeed*solarSystem.Time\r\n\t\t\t\r\n\t\t\tx = distance*cos(theta) + target[0].point.getX()\r\n\t\t\ty = distance*sin(theta) + target[0].point.getY()\r\n\t\t\t\r\n\t\t\tdx = x - planet.point.getX()\r\n\t\t\tdy = y - planet.point.getY()\r\n\r\n\t\t\tplanet.obj.move(dx,dy)\r\n\t\t\tplanet.point = graphics.Point(x,y)\r\n\r\n\t\t\t\r\n\t\r\n\tdef tether(self):\r\n\t\tfor tethered, target in self.tethers.items():\r\n\r\n\t\t\tx = target.point.getX()\r\n\t\t\ty = target.point.getY()\r\n\r\n\t\t\tdx = x - tethered.point.getX()\r\n\t\t\tdy = y - tethered.point.getY()\r\n\r\n\t\t\ttethered.objs(graphics.GraphicsObject.move, [dx,dy])\r\n\t\t\ttethered.point = graphics.Point(x,y)\r\n\r\n\tdef update(self):\r\n\t\tself.updateInternalTimeState()\r\n\t\tself.orbit()\r\n\t\tself.tether()\r\n\t\tgraphics.update(rate)\r\n\r\n", "description": null, "category": "graphics", "imports": ["from ctypes.wintypes import tagRECT\r", "from math import cos, dist, sin, sqrt\r", "import random\r", "from re import X\r", "from tkinter import Variable\r", "from turtle import distance\r", "import graphics\r"]}, {"term": "class", "name": "classCelestialBody:\r", "data": "class CelestialBody:\r\n\r\n\tdef __init__(self, name, size, color, speed):\r\n\t\tsolarSystem.celestialBodyList.append(self)\r\n\t\tself.name = name\r\n\t\tself.size = size/2\r\n\t\tself.color = color\r\n\t\tself.speed = speed\r\n\r\n\tdef initiateCelestialBody(self):\r\n\t\tself.generateGraphicsObjFromBody()\r\n\t\tself.draw()\r\n\r\n\tdef generateGraphicsObjFromBody(self):\r\n\t\tobjTypeDict = {\r\n\t\t\tMoon : graphics.Circle,\r\n\t\t\tPlanet : graphics.Circle,\r\n\t\t\tStar : graphics.Circle,\r\n\t\t\tRing : Ring.Make3Rings,\r\n\t\t\tAsteroidBelt : AsteroidBelt.asteroidBelt\r\n\t\t}\r\n\t\tobjType = objTypeDict[type(self)]\r\n\r\n\t\tringToPlanetScale = 1.2\r\n\t\tobjVariableDict = {\r\n\t\t\tgraphics.Circle : (self.point, self.size),\r\n\t\t\tRing.Make3Rings : (self, graphics.Point(self.point.x-self.size*ringToPlanetScale, self.point.y-self.size),graphics.Point(self.point.x+self.size*ringToPlanetScale, self.point.y+self.size)),\r\n\t\t\tAsteroidBelt.asteroidBelt : [self]\r\n\t\t}\r\n\t\tobjVariables = objVariableDict[objType]\r\n\r\n\t\tobj = objType(*objVariables)\r\n\r\n\t\tif objType == graphics.Circle:\r\n\t\t\tobj.setFill(self.color)\r\n\t\tself.obj = obj\r\n\t\r\n\tdef defineOrbit(self, target):\r\n\t\tsolarSystem.orbits[self] = [target, dist((self.point.getX(),self.point.getY()),(target.point.getX(), target.point.getY())), self.speed]\r\n\r\n\tdef defineTether(self, target):\r\n\t\tsolarSystem.tethers[self] = target\r\n\r\n\r\n\r\n", "description": null, "category": "graphics", "imports": ["from ctypes.wintypes import tagRECT\r", "from math import cos, dist, sin, sqrt\r", "import random\r", "from re import X\r", "from tkinter import Variable\r", "from turtle import distance\r", "import graphics\r"]}, {"term": "class", "name": "Planet", "data": "class Planet(CelestialBody):\r\n\r\n\tdef __init__(self, name, size, color, speed, distancefromsun):\r\n\t\tCelestialBody.__init__(self, name, size, color, speed)\r\n\t\tself.point = graphics.Point(0,0)\r\n\t\tself.distancefromsun = distancefromsun\r\n\t\r\n\tdef draw(self):\r\n\t\tezpz = graphics.GraphicsObject.draw\r\n\t\tezpz(self.obj, win)\r\n", "description": null, "category": "graphics", "imports": ["from ctypes.wintypes import tagRECT\r", "from math import cos, dist, sin, sqrt\r", "import random\r", "from re import X\r", "from tkinter import Variable\r", "from turtle import distance\r", "import graphics\r"]}, {"term": "class", "name": "Moon", "data": "class Moon(CelestialBody):\r\n\r\n\tdef __init__(self, name, size, color, speed, parentPlanet, distanceFromParentPlanet):\r\n\t\tCelestialBody.__init__(self, name, size, color, speed)\r\n\t\tself.point = graphics.Point(0,0)\r\n\t\tself.parentPlanet = parentPlanet\r\n\t\tself.distanceFromParentPlanet = distanceFromParentPlanet\r\n\t\r\n\tdef draw(self):\r\n\t\tgraphics.GraphicsObject.draw(self.obj, win)\r\n", "description": null, "category": "graphics", "imports": ["from ctypes.wintypes import tagRECT\r", "from math import cos, dist, sin, sqrt\r", "import random\r", "from re import X\r", "from tkinter import Variable\r", "from turtle import distance\r", "import graphics\r"]}, {"term": "class", "name": "Star", "data": "class Star(CelestialBody):\r\n\r\n\tdef __init__(self, name, size, color, speed):\r\n\t\tCelestialBody.__init__(self, name, size, color, speed)\r\n\t\tself.point = graphics.Point(0,0)\r\n\r\n\tdef draw(self):\r\n\t\tgraphics.GraphicsObject.draw(self.obj, win)\r\n", "description": null, "category": "graphics", "imports": ["from ctypes.wintypes import tagRECT\r", "from math import cos, dist, sin, sqrt\r", "import random\r", "from re import X\r", "from tkinter import Variable\r", "from turtle import distance\r", "import graphics\r"]}, {"term": "class", "name": "Ring", "data": "class Ring(CelestialBody):\r\n\r\n\tdef __init__(self, name, size, color, speed, parentPlanet):\r\n\t\tCelestialBody.__init__(self, name, size, color, speed)\r\n\t\tself.point = graphics.Point(0,0)\r\n\t\tself.parentPlanet = parentPlanet\r\n\r\n\tdef objs(self, function, variables):\r\n\t\tfor obj in self.obj:\r\n\t\t\tfunction(obj, *variables)\r\n\r\n\tdef draw(self):\r\n\t\tself.objs(graphics.GraphicsObject.draw, [win])\r\n\r\n\tdef Make3Rings(self, p1, p2):\r\n\t\t\tobj = []\r\n\t\t\tringScales = [0.9,1,1.1]\r\n\t\t\tfor ringScale in ringScales:\r\n\t\t\t\tcenterX = (p1.x+p2.x)/2.0\r\n\t\t\t\tcenterY = (p1.y+p2.y)/2.0\r\n\r\n\t\t\t\tx = centerX-((centerX-p1.x)*ringScale)\r\n\t\t\t\ty = centerY-((centerY-p1.y)*ringScale)\r\n\t\t\t\tnewp1 = graphics.Point(x,y)\r\n\r\n\t\t\t\tx = centerX-((centerX-p2.x)*ringScale)\r\n\t\t\t\ty = centerY-((centerY-p2.y)*ringScale)\r\n\t\t\t\tnewp2 = graphics.Point(x,y)\r\n\r\n\t\t\t\tring = graphics.Oval(newp1, newp2)\r\n\t\t\t\tobj.append(ring)\r\n\t\t\treturn obj\r\n", "description": null, "category": "graphics", "imports": ["from ctypes.wintypes import tagRECT\r", "from math import cos, dist, sin, sqrt\r", "import random\r", "from re import X\r", "from tkinter import Variable\r", "from turtle import distance\r", "import graphics\r"]}, {"term": "class", "name": "AsteroidBelt", "data": "class AsteroidBelt(CelestialBody):\r\n\r\n\tdef __init__(self, name, size, color, speed, distancefromsun):\r\n\t\tCelestialBody.__init__(self, name, size, color, speed)\r\n\t\tself.point = graphics.Point(0,0)\r\n\t\tself.distancefromsun = distancefromsun\r\n\r\n\tdef asteroidBelt(self):\r\n\t\ti = 0\r\n\t\tobj = []\r\n\t\trefrence = MainAsteroidBelt\r\n\t\tdensity = (self.size/refrence.size)*(self.distancefromsun/refrence.distancefromsun)\r\n\t\tamountOfAsteroids = 2000*density\r\n\t\twhile i < amountOfAsteroids:\r\n\t\t\ttheta = random.randint(0,36000)/100\r\n\t\t\tr = (weightedRandom(1,2) * self.size)+self.distancefromsun+Sun.size\r\n\t\t\tx = r*cos(theta) + Sun.point.getX()\r\n\t\t\ty = r*sin(theta) + Sun.point.getY()\r\n\t\t\tp = graphics.Point(x,y)\r\n\t\t\t#gx = x // (win.size/2)\r\n\t\t\t#gy =  y // (win.height/2)\r\n\t\t\tobj.append(p)\r\n\t\t\t#SolarSystem.partitioningDict[Point(gx,gy).__repr__()].append(p)\r\n\t\t\ti += 1\r\n\t\treturn obj\r\n\r\n\tdef objs(self, function):\r\n\t\tfor obj in self.obj:\r\n\t\t\tfunction(obj, win)\r\n\r\n\tdef draw(self):\r\n\t\tself.obj = self.asteroidBelt()\r\n\t\tself.objs(graphics.GraphicsObject.draw)\r\n", "description": null, "category": "graphics", "imports": ["from ctypes.wintypes import tagRECT\r", "from math import cos, dist, sin, sqrt\r", "import random\r", "from re import X\r", "from tkinter import Variable\r", "from turtle import distance\r", "import graphics\r"]}, {"term": "def", "name": "initialize", "data": "def initialize():\r\n\tglobal win\r\n\twin = graphics.GraphWin(\"SolarSystem\", 1920, 1080, autoflush=False)\r\n\twin.setCoords(-960, -540, 960, 540)\r\n\twin.setBackground(\"light grey\")\r\n\tsolarSystem.generateCelestialBodyLists()\r\n\tsolarSystem.generateCelestialBodyPoints()\r\n\t\r\n\r\n\tfor Body in solarSystem.celestialBodyList:\r\n\t\tBody.initiateCelestialBody()\r\n\t\tif type(Body) == Planet:\r\n\t\t\tBody.defineOrbit(Sun)\r\n\t\telif type(Body) == Moon:\r\n\t\t\tBody.defineOrbit(Body.parentPlanet)\r\n\t\telif type(Body) == Ring:\r\n\t\t\tBody.defineTether(Body.parentPlanet)\r\n\r\n", "description": null, "category": "graphics", "imports": ["from ctypes.wintypes import tagRECT\r", "from math import cos, dist, sin, sqrt\r", "import random\r", "from re import X\r", "from tkinter import Variable\r", "from turtle import distance\r", "import graphics\r"]}, {"term": "def", "name": "run", "data": "def run():\r\n\tclose = False\r\n\twhile close == False:\r\n\t\tpoint = win.checkMouse()\r\n\t\tif point:\r\n\t\t\tx1 = point.x-(win.getWidth()/2)\r\n\t\t\ty1 = point.y-(win.getHeight()/2)\r\n\t\t\tx2 = point.x+(win.getWidth()/2)\r\n\t\t\ty2 = point.y+(win.getHeight()/2)\r\n\t\t\twin.setCoords(x1,y1,x2,y2)\r\n\t\tsolarSystem.update()\r\n\t\t\r\n", "description": null, "category": "graphics", "imports": ["from ctypes.wintypes import tagRECT\r", "from math import cos, dist, sin, sqrt\r", "import random\r", "from re import X\r", "from tkinter import Variable\r", "from turtle import distance\r", "import graphics\r"]}, {"term": "def", "name": "main", "data": "def main():\r\n\tinitialize()\r\n\trun()\r\n\twin.getMouse()\r\n\twin.close()\r\n\r\n", "description": null, "category": "graphics", "imports": ["from ctypes.wintypes import tagRECT\r", "from math import cos, dist, sin, sqrt\r", "import random\r", "from re import X\r", "from tkinter import Variable\r", "from turtle import distance\r", "import graphics\r"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tnum_lives = NUM_LIVES\n\n\t# Add the animation loop here!\n\twhile True:\n\t\tif graphics.start == 1:  # initiates the movement of the ball\n\t\t\tgraphics.ball.move(graphics.vx, graphics.vy)  # the ball's moving speed\n\t\t\t# if the ball bumps the left or right side of the window\n\t\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window_width:\n\t\t\t\tgraphics.vx = -graphics.vx  # its horizontal speed will change reversely\n\t\t\t# if the ball bumps the upper side of the window\n\t\t\tif graphics.ball.y <= 0:\n\t\t\t\tgraphics.vy = -graphics.vy  # its vertical speed will change reversely\n\t\t\tgraphics.bump_paddle()  # execute the bump_paddle method defined in breakoutgraphic class\n\t\t\tgraphics.bump_brick()  # execute the bump_brick method defined in breakoutgraphic class\n\t\t\tif graphics.brick_number == 0: # when there is no brick left\n\t\t\t\tgraphics.reset_ball()  # make the ball still in the center\n\t\t\t\tbreak  # break the loop to stop the game\n\t\t\tif graphics.ball.y >= graphics.window_height:  # if the ball exceeds the bottom side of the window\n\t\t\t\tnum_lives -= 1  # the number of chance user plays will minus one\n\t\t\t\tif num_lives == 0:  # when the number of chance the user plays is zero\n\t\t\t\t\tgraphics.reset_ball() # make the ball still in the center\n\t\t\t\t\tbreak # break the loop to stop the game\n\t\t\t\tgraphics.reset_ball() # reset the ball in the center when the number of chance minus one\n\t\tpause(FRAME_RATE)  # pause the while loop to prevent the program execute too fast\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "def", "name": "main", "data": "def main():\n\twin = graphics.GraphWin(\"\u56db\u5219\u8fd0\u7b97\", 700, 230)\n\n\t# \u6570\u5b571\u8f93\u5165\u6846\n\tgraphics.Text(graphics.Point(80, 50), \"\u6570\u5b571\").draw(win)\n\tinput_num1 = graphics.Entry(graphics.Point(160, 50), 8)\n\tinput_num1.setFill(\"white\")\t # \u8f93\u5165\u6846\u5e95\u8272\n\tinput_num1.setText(\"0.0\")\n\tinput_num1.draw(win)\n\n\t# \u6570\u5b572\u8f93\u5165\u6846\n\tgraphics.Text(graphics.Point(280, 50), \"\u6570\u5b572\").draw(win)\n\tinput_num2 = graphics.Entry(graphics.Point(360, 50), 8)\n\tinput_num2.setFill(\"white\")\t # \u8f93\u5165\u6846\u5e95\u8272\n\tinput_num2.setText(\"0.0\")\n\tinput_num2.draw(win)\n\n\t# \u63d0\u793a\u4fe1\u606f\n\tgraphics.Text(graphics.Point(80, 100), \"\u3010\u56db\u5219\u8fd0\u7b97\u3011\").draw(win)\n\n\t# \u52a0\u6cd5\n\tgraphics.Text(graphics.Point(120, 150), \"\u52a0\u6cd5\").draw(win)\n\toutput_add = graphics.Entry(graphics.Point(250, 150), 15)\n\toutput_add.setFill(\"white\")\n\toutput_add.draw(win)\n\n\t# \u51cf\u6cd5\n\tgraphics.Text(graphics.Point(400, 150), \"\u51cf\u6cd5\").draw(win)\n\toutput_sub = graphics.Entry(graphics.Point(530, 150), 15)\n\toutput_sub.setFill(\"white\")\n\toutput_sub.draw(win)\n\n\t# \u4e58\u6cd5\n\tgraphics.Text(graphics.Point(120, 200), \"\u4e58\u6cd5\").draw(win)\n\toutput_mul = graphics.Entry(graphics.Point(250, 200), 15)\n\toutput_mul.setFill(\"white\")\n\toutput_mul.draw(win)\n\n\t# \u9664\u6cd5\n\tgraphics.Text(graphics.Point(400, 200), \"\u9664\u6cd5\").draw(win)\n\toutput_div = graphics.Entry(graphics.Point(530, 200), 15)\n\toutput_div.setFill(\"white\")\n\toutput_div.draw(win)\n\n\t# \u9f20\u6807\u5355\u51fb\u5f00\u59cb\u8ba1\u7b97\n\twin.getMouse()\n\n\t# \u8ba1\u7b97\u5e76\u663e\u793a\u7ed3\u679c\n\toutput_add.setText(\n\t\teval(input_num1.getText()) + eval(input_num2.getText())\n\t)\n\toutput_sub.setText(\n\t\teval(input_num1.getText()) - eval(input_num2.getText())\n\t)\n\toutput_mul.setText(\n\t\teval(input_num1.getText()) * eval(input_num2.getText())\n\t)\n\toutput_div.setText(\n\t\teval(input_num1.getText()) / eval(input_num2.getText())\n\t)\n\n\twin.mainloop()\n", "description": null, "category": "graphics", "imports": ["import graphics"]}], [], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\n\t# Add animation loop here!\n\tlives = NUM_LIVES\n\twhile True:\n\t\tgraphics.ball.move(graphics.get_dx(), graphics.get_dy())\n\t\tgraphics.ball_collide_paddle()\n\n\t\tif graphics.ball.x <= 0 or graphics.ball.x+graphics.ball.width > graphics.window.width:\n\t\t\tgraphics.set_dx(graphics.get_dx()*-1)\n\t\telif graphics.ball.y <= 0:\n\t\t\tgraphics.set_dy(graphics.get_dy()*-1)\n\t\telse:\n\t\t\tpass\n\t\tpause(FRAME_RATE)\n\n\t\tif graphics.ball.y > graphics.window_height + graphics.ball_radius * 2:\n\t\t\tlives -= 1\n\t\t\t# \u505a\u4e00\u500b\u958b\u95dc\uff0c\u628a\u6ed1\u9f20\u8cc7\u8a0a\u6253\u958b\uff0c\u4e0b\u6b21\u9ede\u64ca\u624d\u53ef\u4ee5\u518d\u767c\u7403\n\t\t\tgraphics.dead()\n\t\t\tif lives > 0:\n\t\t\t\tgraphics.reset_ball()\n\t\t\telse:\n\t\t\t\tgraphics.game_over()\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tnum_lives = 0\n\n\twhile True:\n\t\t# Update\n\t\tvx = graphics.get_dx()\n\t\tvy = graphics.get_dy()\n\t\tgraphics.ball.move(vx, vy)\n\n\t\t# Check\n\t\tgraphics.check_border()\n\t\tgraphics.bumping()\n\n\t\t# Pause\n\t\tpause(FRAME_RATE)\n\n\t\t# Reset\n\t\tif graphics.ball.y > graphics.window.height:\n\t\t\tnum_lives += 1\n\t\t\tgraphics.add_ball()\n\n\t\t# End game\n\t\tif num_lives > NUM_LIVES - 1:\n\t\t\tgraphics.game_over()\n\t\t\tbreak\n\t\telif graphics.no_bricks():\n\t\t\tgraphics.win()\n\t\t\tbreak\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [], [], [{"term": "class", "name": "GraphicsFacadeRemoteAdapter", "data": "class GraphicsFacadeRemoteAdapter(object):\n\t\"\"\"GraphicsFacadeRemoteAdapter remotely monitors graphics hangs.\"\"\"\n\n\n\tdef __init__(self, remote_facade_proxy):\n\t\t\"\"\"Construct a GraphicsFacadeRemoteAdapter.\n\n\t\t@param remote_facade_proxy: RemoteFacadeProxy object.\n\n\t\t\"\"\"\n\t\tself._proxy = remote_facade_proxy\n\n\n\t@property\n\tdef _graphics_proxy(self):\n\t\t\"\"\"Gets the proxy to DUT USB facade.\n\n\t\t@return XML RPC proxy to DUT graphics facade.\n\n\t\t\"\"\"\n\t\treturn self._proxy.graphics\n\n\n\tdef graphics_state_checker_initialize(self):\n\t\t\"\"\"Create and initialize the graphics state checker object.\n\n\t\tThis will establish existing errors and take a snapshot of graphics\n\t\tkernel memory.\n\n\t\t\"\"\"\n\t\tself._graphics_proxy.graphics_state_checker_initialize()\n\n\n\tdef graphics_state_checker_finalize(self):\n\t\t\"\"\"Throw an error on new GPU hang messages in system logs.\"\"\"\n\t\tself._graphics_proxy.graphics_state_checker_finalize()\n", "description": "GraphicsFacadeRemoteAdapter remotely monitors graphics hangs.", "category": "graphics", "imports": []}], [{"term": "def", "name": "setup", "data": "  def setup(self):\n\tos.chdir(self.srcdir)\n\tutils.make('clean')\n\tutils.make('all')\n", "description": null, "category": "graphics", "imports": ["import logging", "import os", "import time", "from autotest_lib.client.bin import test", "from autotest_lib.client.bin import utils as bin_utils", "from autotest_lib.client.common_lib import error, utils", "from autotest_lib.client.cros.graphics import graphics_utils"]}, {"term": "def", "name": "initialize", "data": "  def initialize(self):\n\t# GpuReset should pretty much be the only test where we don't want to raise\n\t# a test error when we detect a GPU hang.\n\tsuper(graphics_GpuReset, self).initialize(raise_error_on_hang=False)\n", "description": null, "category": "graphics", "imports": ["import logging", "import os", "import time", "from autotest_lib.client.bin import test", "from autotest_lib.client.bin import utils as bin_utils", "from autotest_lib.client.common_lib import error, utils", "from autotest_lib.client.cros.graphics import graphics_utils"]}, {"term": "def", "name": "cleanup", "data": "  def cleanup(self):\n\tsuper(graphics_GpuReset, self).cleanup()\n", "description": null, "category": "graphics", "imports": ["import logging", "import os", "import time", "from autotest_lib.client.bin import test", "from autotest_lib.client.bin import utils as bin_utils", "from autotest_lib.client.common_lib import error, utils", "from autotest_lib.client.cros.graphics import graphics_utils"]}, {"term": "def", "name": "run_once", "data": "  def run_once(self, options=''):\n\tgpu_family = bin_utils.get_gpu_family()\n\tif gpu_family == 'stoney':\n\t\toptions = '-s 7 -t 1'\n\t\texefile = 'amdgpu_test'\n\telse:\n\t\toptions = ''\n\t\texefile = os.path.join(self.srcdir, 'gpureset')\n\t\tif not os.path.isfile(exefile):\n\t\t  raise error.TestFail('Failed: could not locate gpureset executable (' +\n\t\t\t\t\t\t\t   exefile + ').')\n\n\tcmd = '%s %s' % (exefile, options)\n\n\t# If UI is running, we must stop it and restore later.\n\tneed_restart_ui = False\n\tstatus_output = utils.system_output('initctl status ui')\n\t# If chrome is running, result will be similar to:\n\t#   ui start/running, process 11895\n\tlogging.info('initctl status ui returns: %s', status_output)\n\tneed_restart_ui = status_output.startswith('ui start')\n\tsummary = ''\n\n\t# Run the gpureset test in a loop to stress the recovery.\n\tfor i in range(1, self.loops + 1):\n\t  summary += 'graphics_GpuReset iteration %d of %d\\n' % (i, self.loops)\n\t  if need_restart_ui:\n\t\tsummary += 'initctl stop ui\\n'\n\t\tutils.system('initctl stop ui', ignore_status=True)\n\t\t# TODO(ihf): Remove this code if no improvement for issue 409019.\n\t\tlogging.info('Make sure chrome is dead before triggering hang.')\n\t\tutils.system('killall -9 chrome', ignore_status=True)\n\t\ttime.sleep(3)\n\t  try:\n\t\tsummary += utils.system_output(cmd, retain_output=True)\n\t\tsummary += '\\n'\n\t  finally:\n\t\tif need_restart_ui:\n\t\t  summary += 'initctl start ui\\n'\n\t\t  utils.system('initctl start ui')\n\n\t# Write a copy of stdout to help debug failures.\n\tresults_path = os.path.join(self.outputdir, 'summary.txt')\n\tf = open(results_path, 'w+')\n\tf.write('# need ui restart: %s\\n' % need_restart_ui)\n\tf.write('# ---------------------------------------------------\\n')\n\tf.write('# [' + cmd + ']\\n')\n\tf.write(summary)\n\tf.write('\\n# -------------------------------------------------\\n')\n\tf.write('# [graphics_GpuReset.py postprocessing]\\n')\n\n\t# Analyze the output. Sample:\n\t# [\t   OK ] graphics_GpuReset\n\t# [  FAILED  ] graphics_GpuReset\n\tresults = summary.splitlines()\n\tif not results:\n\t  f.close()\n\t  raise error.TestFail('Failed: No output from test. Check /tmp/' +\n\t\t\t\t\t\t   'test_that_latest/graphics_GpuReset/summary.txt' +\n\t\t\t\t\t\t   ' for details.')\n\t# Analyze summary and count number of passes.\n\tpass_count = 0\n\tfor line in results:\n\t  if gpu_family == 'stoney':\n\t\tif \"passed\" in line:\n\t\t  pass_count += 1\n\t\tif \"failed\" in line:\n\t\t  raise error.TestFail('Failed: %s' % line)\n\t  else:\n\t\tif line.strip().startswith('[\t   OK ] graphics_GpuReset'):\n\t\t  pass_count += 1\n\t\tif line.strip().startswith('[  FAILED  ] graphics_GpuReset'):\n\t\t  msg = line.strip()[30:]\n\t\t  failed_msg = 'Test failed with %s' % msg\n\t\t  raise error.TestFail('Failed: %s' % failed_msg)\n\tf.close()\n\n\t# Final chance to fail.\n\tif pass_count != self.loops:\n\t  failed_msg = 'Test failed with incomplete output. System hung? '\n\t  failed_msg += '(pass_count=%d of %d)' % (pass_count, self.loops)\n\t  raise error.TestFail('Failed: %s' % failed_msg)\n\n\t# We need to wait a bit for X to come back after the 'start ui'.\n\ttime.sleep(5)\n", "description": null, "category": "graphics", "imports": ["import logging", "import os", "import time", "from autotest_lib.client.bin import test", "from autotest_lib.client.bin import utils as bin_utils", "from autotest_lib.client.common_lib import error, utils", "from autotest_lib.client.cros.graphics import graphics_utils"]}], [{"term": "def", "name": "assemble", "data": "def assemble():\n\tfor i in range(0, 2):\n\n\t\t#standing still\n\t\tstatic = tools.transform.split_sheet(pygame.image.load(os.path.join(\"resources\", \"images\", \"player\", str(i), \"static.png\")))\n\n\t\tgraphics.add(AnimationGraphic([[static[0][x], static[1][x]] for x in range(0, 4)]), \"player_static_\" + str(i))\n\n\t\t#walking/jumping\n\t\tmoving = tools.transform.split_sheet(pygame.image.load(os.path.join(\"resources\", \"images\", \"player\", str(i), \"moving.png\")))\n\n\t\tgraphics.add(AnimationGraphic([[moving[0][x], moving[1][x]] for x in range(0, 4)]), \"player_walking_\" + str(i))\n\t\tgraphics.add(AnimationGraphic([[moving[2][0], moving[2][1]]]), \"player_jumping_\" + str(i))\n\n\t\t#laser\n\t\tlaser = tools.transform.split_sheet(pygame.image.load(os.path.join(\"resources\", \"images\", \"player\", str(i), \"laser.png\")))\n\t\timages = []\n\t\tfor j in range(0, 4):\n\t\t\timg = tools.transform.get_clear_surface((84, 42))\n\t\t\timg.blit(laser[0][j], (0, 0))\n\t\t\timg.blit(laser[0][j], (42, 0))\n\t\t\timages.append(img)\n\n\t\tgraphics.add(AnimationGraphic(laser[0][0:4]), \"player_laser_\" + str(i))\n\t\tgraphics.add(AnimationGraphic(laser[0][0:4]), \"player_laser_impact_\" + str(i))\n\t\tgraphics.add(AnimationGraphic(images), \"player_laser_long_\" + str(i))\n\n\t\t# movement belt\n\t\tm_belt = tools.transform.split_sheet(pygame.image.load(os.path.join(\"resources\", \"images\", \"player\", \"movement_belt.png\")))\n\n\t\t# double jump animation\n\t\tgraphics.add(AnimationGraphic(m_belt[0][0:6]), \"player_double_jump\")\n\n\t\t# dash animation things\n\t\tgraphics.add(ShuffleAnimationGraphic(m_belt[1][0:8]), \"player_dash\")\n\n\t\t# yoyo animations\n\t\tgraphics.add(AnimationGraphic(m_belt[3][0:15]), \"player_yoyo_portal\")\n\t\tgraphics.add(AnimationGraphic(m_belt[4][0:5]), \"player_yoyo_teleport\")\n\t\tgraphics.add(AnimationGraphic(m_belt[5][0:5]), \"player_yoyo_portal_end\")\n\n\t\t# level builder player\n\t\tlevel_builder_player = tools.transform.split_sheet(pygame.image.load(os.path.join(\"resources\", \"images\", \"player\", \"level_builder_player.png\")))\n\n\t\tgraphics.add(Graphic(level_builder_player[0][0]), \"level_builder_player\")\n\t\tgraphics.add(Graphic(level_builder_player[0][1]), \"level_builder_player_background\")\n\n", "description": null, "category": "graphics", "imports": ["import os.path", "import numpy", "import pygame.image", "import tools.transform", "from graphics import graphics", "from graphics.graphic_class.animation_graphic import AnimationGraphic", "from graphics.graphic_class.graphic import Graphic", "from graphics.graphic_class.shuffle_animation_graphic import ShuffleAnimationGraphic", "from graphics.graphic_class.shuffle_graphic import ShuffleGraphic"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tcount_lives = 0  # number of out_ball\n\tcount_bricks = 0  # number of bricks player hit\n\t# Add animation loop here!\n\twhile True:\n\t\tpause(FRAME_RATE)\n\t\tgraphics.ball.move(graphics.get_dx(), graphics.get_dy())\n\t\tif graphics.ball_hit_thing() is not None:  # hit the paddle or brick\n\t\t\tif graphics.ball_hit_thing() is not graphics.paddle:  # hit the brick\n\t\t\t\tgraphics.chang_dy_direction()\n\t\t\t\tgraphics.window.remove(graphics.ball_hit_thing())\n\t\t\t\tcount_bricks += 1\n\t\t\t\tif count_bricks == graphics.bricks_number:  # clear all bricks\n\t\t\t\t\tbreak\n\t\t\telse:  # hit the paddle\n\t\t\t\tif graphics.get_dy() > 0:  # makes ball do not stick on the paddle\n\t\t\t\t\tgraphics.chang_dy_direction()\n\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.r * 2 >= graphics.window.width:\n\t\t\t# between two sides of window\n\t\t\tgraphics.chang_dx_direction()\n\t\tif graphics.ball.y <= 0:  # up_side of window\n\t\t\tgraphics.chang_dy_direction()\n\t\tif graphics.ball.y >= graphics.window.height:  # ball is out of window\n\t\t\tgraphics.reset_ball()\n\t\t\tcount_lives += 1\n\t\t\tif count_lives == NUM_LIVES:\n\t\t\t\tbreak\n\n\n\n\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [], [{"term": "class", "name": "classGameDrawDataContainer:", "data": "class GameDrawDataContainer:\n\n\tgraphics_data: GraphicsData\n\n\tdef __init__(self, graphics_data: GraphicsData):\n\t\tself.graphics_data = graphics_data\n\n\tdef draw(self):\n\t\tpass\n", "description": null, "category": "graphics", "imports": ["from pyglet.resource import image", "from graphics.data import graphics_data", "from graphics.data.graphics_data import GraphicsData", "from graphics.data.image_names import UIImageNames, GameImageNames", "from graphics.graphics_helper_functions import set_pyglet_resource_paths", "import pyglet"]}], [], [], [], [], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tgraphics.window.add(graphics.lives_label, x=graphics.window.width - 70, y=25)\n\twhile True:\n\t\tif graphics.lives == 0:\n\t\t\tgraphics.game_over()\n\t\t\tgraphics.window.add(graphics.bye, (graphics.window.width - graphics.bye.width) / 2, graphics.window.height / 2)\n\t\t\tbreak\n\t\telse:\n\t\t\tdx = graphics.dx\n\t\t\tdy = graphics.dy\n\t\t\tpause(FRAME_RATE)\n\t\t\tgraphics.ball.move(dx, dy)\n\t\t\tpause(FRAME_RATE)\n\t\t\tgraphics.window_check()\n\t\t\tif graphics.open == 1:\n\t\t\t\tgraphics.object_check()\n\t\t\t\t# graphics.show()\n\t\t\t\t# if graphics.ball.y >= graphics.window.height - graphics.ball.height:\n\t\t\t\t#\t graphics.lives -= 1\n\t\t\t\t#\t graphics.lives_label.text = 'Lives: ' + str(graphics.lives)\n\t\t\t\t#\t graphics.window.add(graphics.lives_label, x=graphics.window.width - 70, y=25)\n\n\n\n\n\n\n\n\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [], [{"term": "class", "name": "ActionIconGraphics", "data": "class ActionIconGraphics(ActionGraphics):\n\n\tTEXT_X_OFFSET = 10\n\tTEXT_SCALE_FACTOR = 0.99\n\tTEXT_DEFAULT_SIZE = 16\n\t\n\tdef __init__(self, action: 'Action', parent:QGraphicsItem=None) -> 'ActionGraphics':\n\t\t\"\"\"\n\t\tCreates an ActionIconGraphics object.\n\t\t\n\t\t:param action: The action to create icon graphics for.\n\t\t:type action: Action\n\t\t:param parent: The parent graphics item.\n\t\t:type parent: QGraphicsItem\n\t\t\"\"\"\n\t\tActionGraphics.__init__(self, action, parent)\n\t\tself._interactivePorts = False\n\t\tself._textItem = QGraphicsSimpleTextItem(self._action.getName(), self)\n\t\tself._textItem.setFont(QFont(\"Sans Serif\", ActionIconGraphics.TEXT_DEFAULT_SIZE, QFont.Bold))\n\t\tself._textItem.setBrush(QColor(Qt.white))\n\t\tself.updateGraphics()\n\t\n\tdef createPortGraphics(self) -> None:\n\t\t\"\"\"\n\t\tOverride the ActionGraphics createPortGraphics method to not allow context-menu summoning.\n\t\t\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\tself._interactivePorts = False\n\t\treturn ActionGraphics.createPortGraphics(self)\n\n\tdef updateGraphics(self) -> None:\n\t\t\"\"\"\n\t\tUpdates the text, then calls the super method.\n\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\tself._textItem.setText(self._action.getName())\n\t\tself._textItem.setFont(QFont(\"Sans Serif\", ActionIconGraphics.TEXT_DEFAULT_SIZE, QFont.Bold))\n\t\tbr = self.boundingRect()\n\n\t\t# shrink text to fit in action\n\t\tnumShrinks = 0\n\t\twhile True:\n\t\t\ttbr = self._textItem.boundingRect()\n\t\t\tif tbr.width() > br.width() - 2 * ActionIconGraphics.TEXT_X_OFFSET:\n\t\t\t\tnumShrinks += 1\n\t\t\t\ttextSize = ActionIconGraphics.TEXT_DEFAULT_SIZE * (ActionIconGraphics.TEXT_SCALE_FACTOR ** numShrinks)\n\t\t\t\tself._textItem.setFont(QFont(\"Sans Serif\", textSize, QFont.Bold))\n\t\t\telse:\n\t\t\t\tbreak\n\n\t\tx = br.x() + ActionIconGraphics.TEXT_X_OFFSET\n\t\ty = - tbr.height() / 2\n\t\tself._textItem.setPos(x, y)\n\n", "description": "\n\t\tCreates an ActionIconGraphics object.\n\t\t\n\t\t:param action: The action to create icon graphics for.\n\t\t:type action: Action\n\t\t:param parent: The parent graphics item.\n\t\t:type parent: QGraphicsItem\n\t\t", "category": "graphics", "imports": ["from PySide2.QtWidgets import QGraphicsItem, QGraphicsSimpleTextItem", "from PySide2.QtGui import QFont, QColor", "from PySide2.QtCore import Qt", "from graphics.apim.actiongraphics import ActionGraphics"]}], [{"term": "class", "name": "DataView", "data": "class DataView(QtWidgets.QWidget, Ui_DataView):\n\tcursorPosChanged = QtCore.Signal(QtCore.QPointF, CustomGraphicsView)\n\n\tdef __init__(self, parent, *args, **kwargs):\n\t\tsuper().__init__(parent, *args, **kwargs)\n\t\tself.setupUi(self)\n\n\t\tself.graphicsViewVolume.cursorPosChanged.connect(self.emit_volume_pos)\n\t\tself.graphicsViewLocalizer.cursorPosChanged.connect(self.emit_localizer_pos)\n\n\t\tself.graphicsViewLocalizer.hide()\n\t\tself.graphicsViewVolume.hide()\n\n\t\tself.data = None\n\n\tdef set_data(self, data: ep.EyeVolume):\n\t\tlogger.debug(\"DataView: set_data\")\n\t\tself.data = data\n\t\tself.graphicsViewVolume.set_data(self.data, name=\"Volume\")\n\t\tself.graphicsViewLocalizer.set_data(self.data.localizer, name=\"Enface\")\n\n\t\tself.graphicsViewLocalizer.show()\n\t\tself.graphicsViewVolume.show()\n\n\tdef emit_volume_pos(self, pos, sender):\n\t\t# The position coming from the volume is in the localizer space.\n\t\t# Since other views can only map from the localizer to their space\n\t\t# replace the sender here.\n\t\tself.cursorPosChanged.emit(pos, self.graphicsViewLocalizer)\n\t\tself.graphicsViewLocalizer.set_fake_cursor(pos)\n\n\tdef emit_localizer_pos(self, pos, sender):\n\t\tself.graphicsViewVolume.set_fake_cursor(pos, sender)\n\t\tself.cursorPosChanged.emit(pos, sender)\n\n\tdef set_fake_cursor(self, pos, sender):\n\t\tpos = self.graphicsViewLocalizer.map_from_sender(pos, sender)\n\t\tself.graphicsViewLocalizer.set_fake_cursor(pos, self.graphicsViewLocalizer)\n\t\tself.graphicsViewVolume.set_fake_cursor(pos, self.graphicsViewLocalizer)\n", "description": null, "category": "graphics", "imports": ["import logging", "import eyepy as ep", "from PySide6 import QtCore, QtWidgets", "from eyelab.views.graphicsview import CustomGraphicsView", "from eyelab.views.ui.ui_data_view import Ui_DataView"]}], [], [], [{"term": "def", "name": "AddBenchmarkCommandLineArgs", "data": "  def AddBenchmarkCommandLineArgs(cls, parser):\n\tparser.add_option('--scroll-forever', action='store_true',\n\t\t\t\t\t  help='If set, continuously scroll up and down forever. '\n\t\t\t\t\t\t   'This is useful for analysing scrolling behaviour '\n\t\t\t\t\t\t   'with tools such as perf.')\n", "description": null, "category": "graphics", "imports": ["import sys", "from core import perf_benchmark", "import page_sets", "from page_sets.system_health import platforms", "from telemetry import benchmark", "from telemetry import story as story_module", "from telemetry.timeline import chrome_trace_category_filter", "from telemetry.web_perf import timeline_based_measurement"]}, {"term": "def", "name": "CreateStorySet", "data": "  def CreateStorySet(self, options):\n\treturn page_sets.RenderingStorySet(platform=self.PLATFORM_NAME)\n", "description": null, "category": "graphics", "imports": ["import sys", "from core import perf_benchmark", "import page_sets", "from page_sets.system_health import platforms", "from telemetry import benchmark", "from telemetry import story as story_module", "from telemetry.timeline import chrome_trace_category_filter", "from telemetry.web_perf import timeline_based_measurement"]}, {"term": "def", "name": "SetExtraBrowserOptions", "data": "  def SetExtraBrowserOptions(self, options):\n\toptions.AppendExtraBrowserArgs('--enable-gpu-benchmarking')\n\toptions.AppendExtraBrowserArgs('--touch-events=enabled')\n\toptions.AppendExtraBrowserArgs('--disable-software-compositing-fallback')\n", "description": null, "category": "graphics", "imports": ["import sys", "from core import perf_benchmark", "import page_sets", "from page_sets.system_health import platforms", "from telemetry import benchmark", "from telemetry import story as story_module", "from telemetry.timeline import chrome_trace_category_filter", "from telemetry.web_perf import timeline_based_measurement"]}, {"term": "def", "name": "CreateCoreTimelineBasedMeasurementOptions", "data": "  def CreateCoreTimelineBasedMeasurementOptions(self):\n\tcategory_filter = chrome_trace_category_filter.CreateLowOverheadFilter()\n\toptions = timeline_based_measurement.Options(category_filter)\n\toptions.config.chrome_trace_config.EnableUMAHistograms(\n\t\t*RENDERING_BENCHMARK_UMA)\n\toptions.SetTimelineBasedMetrics(['renderingMetric', 'umaMetric'])\n\treturn options\n\n", "description": null, "category": "graphics", "imports": ["import sys", "from core import perf_benchmark", "import page_sets", "from page_sets.system_health import platforms", "from telemetry import benchmark", "from telemetry import story as story_module", "from telemetry.timeline import chrome_trace_category_filter", "from telemetry.web_perf import timeline_based_measurement"]}, {"term": "def", "name": "Name", "data": "  def Name(cls):\n\treturn 'rendering.desktop'\n", "description": null, "category": "graphics", "imports": ["import sys", "from core import perf_benchmark", "import page_sets", "from page_sets.system_health import platforms", "from telemetry import benchmark", "from telemetry import story as story_module", "from telemetry.timeline import chrome_trace_category_filter", "from telemetry.web_perf import timeline_based_measurement"]}, {"term": "def", "name": "SetExtraBrowserOptions", "data": "  def SetExtraBrowserOptions(self, options):\n\tsuper(RenderingDesktop, self).SetExtraBrowserOptions(options)\n\t# The feature below is only needed for macOS.\n\t# We found that the normal priorities used for mac is resulting into\n\t# unreliable values for avg_fps and frame_times. Increasing the priority\n\t# and using it in telemetry tests can help with more accurate values.\n\t# crbug.com/970607\n\tif sys.platform == 'darwin':\n\t  options.AppendExtraBrowserArgs(\n\t\t  '--use-gpu-high-thread-priority-for-perf-tests')\n\n", "description": null, "category": "graphics", "imports": ["import sys", "from core import perf_benchmark", "import page_sets", "from page_sets.system_health import platforms", "from telemetry import benchmark", "from telemetry import story as story_module", "from telemetry.timeline import chrome_trace_category_filter", "from telemetry.web_perf import timeline_based_measurement"]}, {"term": "def", "name": "Name", "data": "  def Name(cls):\n\treturn 'rendering.mobile'\n", "description": null, "category": "graphics", "imports": ["import sys", "from core import perf_benchmark", "import page_sets", "from page_sets.system_health import platforms", "from telemetry import benchmark", "from telemetry import story as story_module", "from telemetry.timeline import chrome_trace_category_filter", "from telemetry.web_perf import timeline_based_measurement"]}, {"term": "def", "name": "SetExtraBrowserOptions", "data": "  def SetExtraBrowserOptions(self, options):\n\tsuper(RenderingMobile, self).SetExtraBrowserOptions(options)\n\t# Disable locking the controls as visible for a minimum duration. This\n\t# allows controls to unlock after page load, rather than in the middle of a\n\t# story.\n\toptions.AppendExtraBrowserArgs('--disable-minimum-show-duration')\n", "description": null, "category": "graphics", "imports": ["import sys", "from core import perf_benchmark", "import page_sets", "from page_sets.system_health import platforms", "from telemetry import benchmark", "from telemetry import story as story_module", "from telemetry.timeline import chrome_trace_category_filter", "from telemetry.web_perf import timeline_based_measurement"]}, {"term": "def", "name": "CreateCoreTimelineBasedMeasurementOptions", "data": "  def CreateCoreTimelineBasedMeasurementOptions(self):\n\toptions = super(\n\t\tRenderingMobile, self).CreateCoreTimelineBasedMeasurementOptions()\n\toptions.config.enable_platform_display_trace = True\n\treturn options\n", "description": null, "category": "graphics", "imports": ["import sys", "from core import perf_benchmark", "import page_sets", "from page_sets.system_health import platforms", "from telemetry import benchmark", "from telemetry import story as story_module", "from telemetry.timeline import chrome_trace_category_filter", "from telemetry.web_perf import timeline_based_measurement"]}], [{"term": "class", "name": "TestGlider", "data": "class TestGlider(GliderTestClass):\n\tdef test_show_lastcell(self):\n\t\tthaglider = self.glider\n\t\tcell = thaglider.cells[-1]\n\t\t#print(cell.normvectors)\n\t\topenglider.graphics.Graphics([openglider.graphics.Line(cell.rib1.profile_3d.data),\n\t\t\t\t\t\t\t\t\t  openglider.graphics.Line(cell.rib2.profile_3d.data)])\n\n\t@staticmethod\n\tdef show_glider(glider, num=5):\n\t\tleft = glider.copy()\n\t\tright = left.copy()\n\t\tright.mirror()\n\t\tribs = left.return_ribs(num)\n\t\tpolygons = left.return_polygon_indices(ribs)\n\t\tpoints = np.concatenate(ribs)\n\t\tobjects = []\n\t\tobjects += [openglider.graphics.Red]\n\t\tobjects += map(openglider.graphics.Polygon, polygons)\n\t\tobjects += [openglider.graphics.Green]\n\t\tobjects += [openglider.graphics.Polygon(rib.profile_3d.data) for rib in right.ribs]\n\t\tblue = openglider.graphics.Blue\n\t\tobjects += map(lambda line: openglider.graphics.Line(line.get_line_points(), colour=blue.colour),\n\t\t\t\t\t   left.lineset.lines)\n\n\t\t#objects += [openglider.graphics.Axes(size=1.2)] #, openglider.graphics.Green]\n\t\t#objects.append(openglider.graphics.Blue)\n\t\t#objects += [openglider.graphics.Line(rib.profile_3d.data) for rib in left.ribs]\n\n\t\topenglider.graphics.Graphics3D(objects, points)\n\n\t@unittest.skip('TODO')\n\tdef test_show_shape(self):\n\t\tself.glider = self.glider.copy_complete()\n\t\tleft, right = self.glider.shape_flattened\n\t\t#left.rotate(math.pi/2)\n\t\t#right.rotate(math.pi/2, [0, 0])\n\t\tdata = [left,\n\t\t\t\tright]\n\t\tdata += [[left[i], right[i]] for i in range(len(left))]\n\t\topenglider.graphics.Graphics2D([openglider.graphics.Line(obj) for obj in data])\n\n\t@unittest.skip('TODO')\n\tdef test_show_shape_simple(self):\n\t\tfront, back = self.glider.shape_simple\n\t\topenglider.graphics.Graphics2D([openglider.graphics.Line(obj) for obj in (front, back)])\n\n\tdef test_show_ribs(self):\n\t\t#self.glider = self.glider.copy_complete()\n\t\tself.glider.mirror()\n\t\topenglider.graphics.Graphics([openglider.graphics.Line(rib.profile_3d.data) for rib in self.glider.ribs])\n\n\t@unittest.skip(\"skipped\")\n\tdef test_midrib_projection(self):\n\t\tnum = 3\n\t\tdata = []\n\t\tfor i in range(num):\n\t\t\tcell = self.glider.cells[random.randint(0, len(self.glider.cells) - 1)]\n\t\t\tprof = cell.midrib(random.random())\n\t\t\tprof.projection_layer()\n\t\t\tdata += [prof.data,\n\t\t\t\t\t [prof.data[0], prof.data[0] + prof.xvect],\n\t\t\t\t\t [prof.data[0], prof.data[0] + prof.yvect]]\n\n\t\topenglider.graphics.Graphics([openglider.graphics.Line(obj) for obj in data])\n\n\tdef test_midrib_flattened(self):\n\t\tnum = 2\n\t\tcell = self.glider.cells[random.randint(0, len(self.glider.cells) - 1)]\n\t\tprofs = [cell.rib1.profile_2d.data]\n\t\tprofs += [cell.midrib(random.random()).flatten().data + [0, (i + 1) * 0.] for i in range(num)]\n\t\topenglider.graphics.Graphics2D([openglider.graphics.Line(prof) for prof in profs])\n\n\t@unittest.skip('TODO')\n\tdef test_brake(self):\n\t\tglider = self.glider\n\t\tbrake = Bezier([[0., 0.], [1., 0.], [1., -0.2]])\n\t\tnum = 60\n\t\tbrakeprof = openglider.airfoil.Profile2D([brake(i / num) for i in reversed(range(num + 1))][:-1] +\n\t\t\t\t\t\t\t\t\t\t\t\t [brake(i / num) for i in range(num + 1)])\n\n\t\tfor i, rib in enumerate(glider.ribs):\n\t\t\trib.profile_2d = rib.profile_2d + brakeprof * (3 * i / len(glider.ribs))\n\n\t\tself.show_glider(glider)\n\n\t@unittest.skip('TODO')\n\tdef test_show_glider(self):\n\t\tself.show_glider(self.glider)\n\n\t@unittest.skip('notyet')\n\tdef test_export_json(self):\n\t\t#path = os.tmpfile()\n\t\tpath = os.tmpnam() + \".json\"\n\t\tself.glider.export_3d(path)\n\t\timport openglider.jsonify\n\n\t\tfile = open(path, \"r\")\n\t\tdata = openglider.jsonify.load(file)\n\t\tgraphics.Graphics([graphics.Polygon(panel[\"node_no\"]) for panel in data[\"panels\"] if not panel[\"is_wake\"]],\n\t\t\t\t\t\t  #G.Graphics([G.Polygon(data[\"panels\"][0][\"node_no\"])],\n\t\t\t\t\t\t  data[\"nodes\"])\n\n\tdef test_singleskin(self):\n\t\trib = self.glider.ribs[1]\n\t\trib.single_skin_par = {\"att_dist\": 0.05, \"height\": 0.5}\n\t\tprint(rib.get_hull(self.glider))\n\t\tgraphics.Graphics([openglider.graphics.Line(rib.get_hull(self.glider))])\n\n", "description": null, "category": "graphics", "imports": ["from __future__ import division", "import os", "import random", "import sys", "import numpy as np", "\timport openglider", "\timport openglider", "import openglider.graphics", "import openglider.graphics as graphics", "from openglider.vector.spline import Bezier", "from test_glider import GliderTestClass", "import unittest", "\t\timport openglider.jsonify"]}], [{"term": "class", "name": "GraphicsBindingsDocument", "data": "class GraphicsBindingsDocument(NSDocument):\n\tgraphicsView = objc.IBOutlet()\n\tshadowInspector = objc.IBOutlet()\n\tgraphicsController = objc.IBOutlet()\n\tgraphics = objc.ivar()\n\n\tdef init(self):\n\t\tself = super().init()\n\t\tif self is None:\n\t\t\treturn None\n\t\tself.graphics = []  # NSMutableArray.array()\n\t\tself.bindings = []\n\t\treturn self\n\n\tdef windowNibName(self):\n\t\treturn \"GraphicsBindingsDocument\"\n\n\tdef makeBinding_fromObject_toObject_withKeyPath_options_(\n\t\tself, key, fromObject, toObject, withKeyPath, options\n\t):\n\t\tself.bindings.append((fromObject, key))\n\t\tfromObject.bind_toObject_withKeyPath_options_(\n\t\t\tkey, toObject, withKeyPath, options\n\t\t)\n\n\tdef windowControllerDidLoadNib_(self, controller):\n\t\tsuper().windowControllerDidLoadNib_(controller)\n\n\t\t# we can't do these in IB at the moment, as\n\t\t# we don't have palette items for them\n\n\t\t# allow the shadow inspector (joystick) to handle multiple selections\n\t\toffsetOptions = {\"NSAllowsEditingMultipleValuesSelection\": True}\n\t\tangleOptions = {\n\t\t\t\"NSValueTransformerName\": \"RadiansToDegreesTransformer\",\n\t\t\t\"NSAllowsEditingMultipleValuesSelection\": True,\n\t\t}\n\n\t\tBINDINGS = [\n\t\t\t(\n\t\t\t\t\"graphics\",\n\t\t\t\tself.graphicsView,\n\t\t\t\tself.graphicsController,\n\t\t\t\t\"arrangedObjects\",\n\t\t\t\tNone,\n\t\t\t),\n\t\t\t(\n\t\t\t\t\"selectionIndexes\",\n\t\t\t\tself.graphicsView,\n\t\t\t\tself.graphicsController,\n\t\t\t\t\"selectionIndexes\",\n\t\t\t\tNone,\n\t\t\t),\n\t\t\t(\n\t\t\t\t\"offset\",\n\t\t\t\tself.shadowInspector,\n\t\t\t\tself.graphicsController,\n\t\t\t\t\"selection.shadowOffset\",\n\t\t\t\toffsetOptions,\n\t\t\t),\n\t\t\t(\n\t\t\t\t\"angle\",\n\t\t\t\tself.shadowInspector,\n\t\t\t\tself.graphicsController,\n\t\t\t\t\"selection.shadowAngle\",\n\t\t\t\tangleOptions,\n\t\t\t),\n\t\t]\n\t\tfor binding in BINDINGS:\n\t\t\tself.makeBinding_fromObject_toObject_withKeyPath_options_(*binding)\n\n\t\t# \"fake\" what should be set in IB if we had a palette...\n\t\tself.shadowInspector.maxOffset = 15\n\n\tdef close(self):\n\t\twhile self.bindings:\n\t\t\tobj, binding = self.bindings.pop()\n\t\t\tobj.unbind_(binding)\n\t\tsuper().close()\n\n\tdef dataRepresentationOfType_(self, aType):\n\t\treturn NSKeyedArchiver.archivedDataWithRootObject_(self.graphics)\n\n\tdef loadDataRepresentation_ofType_(self, data, aType):\n\t\tself.graphics = NSKeyedUnarchiver.unarchiveObjectWithData_(data)\n\t\treturn True\n\n", "description": null, "category": "graphics", "imports": ["import objc", "from Cocoa import NSDocument, NSKeyedArchiver, NSKeyedUnarchiver, NSValueTransformer", "from objc import super", "from RadiansToDegreesTransformer import RadiansToDegreesTransformer"]}], [{"term": "class", "name": "GraphicsResult", "data": "class GraphicsResult(object):\n\t\"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n\tRef: https://openapi-generator.tech\n\n\tDo not edit the class manually.\n\t\"\"\"\n\n\t\"\"\"\n\tAttributes:\n\t  openapi_types (dict): The key is attribute name\n\t\t\t\t\t\t\tand the value is attribute type.\n\t  attribute_map (dict): The key is attribute name\n\t\t\t\t\t\t\tand the value is json key in definition.\n\t\"\"\"\n\topenapi_types = {\n\t\t'doc_graphics_info': 'GraphicFieldsList',\n\t\t'buf_length': 'int',\n\t\t'light': 'int',\n\t\t'list_idx': 'int',\n\t\t'page_idx': 'int',\n\t\t'result_type': 'int'\n\t}\n\n\tattribute_map = {\n\t\t'doc_graphics_info': 'DocGraphicsInfo',\n\t\t'buf_length': 'buf_length',\n\t\t'light': 'light',\n\t\t'list_idx': 'list_idx',\n\t\t'page_idx': 'page_idx',\n\t\t'result_type': 'result_type'\n\t}\n\n\tdef __init__(self, doc_graphics_info=None, buf_length=None, light=None, list_idx=None, page_idx=None, result_type=0, local_vars_configuration=None):  # noqa: E501\n\t\t\"\"\"GraphicsResult - a model defined in OpenAPI\"\"\"  # noqa: E501\n\t\tif local_vars_configuration is None:\n\t\t\tlocal_vars_configuration = Configuration()\n\t\tself.local_vars_configuration = local_vars_configuration\n\n\t\tself._doc_graphics_info = None\n\t\tself._buf_length = None\n\t\tself._light = None\n\t\tself._list_idx = None\n\t\tself._page_idx = None\n\t\tself._result_type = None\n\t\tself.discriminator = None\n\n\t\tself.doc_graphics_info = doc_graphics_info\n\t\tif buf_length is not None:\n\t\t\tself.buf_length = buf_length\n\t\tif light is not None:\n\t\t\tself.light = light\n\t\tif list_idx is not None:\n\t\t\tself.list_idx = list_idx\n\t\tif page_idx is not None:\n\t\t\tself.page_idx = page_idx\n\t\tself.result_type = result_type\n\n\t@property\n\tdef doc_graphics_info(self):\n\t\t\"\"\"Gets the doc_graphics_info of this GraphicsResult.  # noqa: E501\n\n\n\t\t:return: The doc_graphics_info of this GraphicsResult.  # noqa: E501\n\t\t:rtype: GraphicFieldsList\n\t\t\"\"\"\n\t\treturn self._doc_graphics_info\n\n\t@doc_graphics_info.setter\n\tdef doc_graphics_info(self, doc_graphics_info):\n\t\t\"\"\"Sets the doc_graphics_info of this GraphicsResult.\n\n\n\t\t:param doc_graphics_info: The doc_graphics_info of this GraphicsResult.  # noqa: E501\n\t\t:type doc_graphics_info: GraphicFieldsList\n\t\t\"\"\"\n\t\tif self.local_vars_configuration.client_side_validation and doc_graphics_info is None:  # noqa: E501\n\t\t\traise ValueError(\"Invalid value for `doc_graphics_info`, must not be `None`\")  # noqa: E501\n\n\t\tself._doc_graphics_info = doc_graphics_info\n\n\t@property\n\tdef buf_length(self):\n\t\t\"\"\"Gets the buf_length of this GraphicsResult.  # noqa: E501\n\n\n\t\t:return: The buf_length of this GraphicsResult.  # noqa: E501\n\t\t:rtype: int\n\t\t\"\"\"\n\t\treturn self._buf_length\n\n\t@buf_length.setter\n\tdef buf_length(self, buf_length):\n\t\t\"\"\"Sets the buf_length of this GraphicsResult.\n\n\n\t\t:param buf_length: The buf_length of this GraphicsResult.  # noqa: E501\n\t\t:type buf_length: int\n\t\t\"\"\"\n\n\t\tself._buf_length = buf_length\n\n\t@property\n\tdef light(self):\n\t\t\"\"\"Gets the light of this GraphicsResult.  # noqa: E501\n\n\n\t\t:return: The light of this GraphicsResult.  # noqa: E501\n\t\t:rtype: int\n\t\t\"\"\"\n\t\treturn self._light\n\n\t@light.setter\n\tdef light(self, light):\n\t\t\"\"\"Sets the light of this GraphicsResult.\n\n\n\t\t:param light: The light of this GraphicsResult.  # noqa: E501\n\t\t:type light: int\n\t\t\"\"\"\n\n\t\tself._light = light\n\n\t@property\n\tdef list_idx(self):\n\t\t\"\"\"Gets the list_idx of this GraphicsResult.  # noqa: E501\n\n\n\t\t:return: The list_idx of this GraphicsResult.  # noqa: E501\n\t\t:rtype: int\n\t\t\"\"\"\n\t\treturn self._list_idx\n\n\t@list_idx.setter\n\tdef list_idx(self, list_idx):\n\t\t\"\"\"Sets the list_idx of this GraphicsResult.\n\n\n\t\t:param list_idx: The list_idx of this GraphicsResult.  # noqa: E501\n\t\t:type list_idx: int\n\t\t\"\"\"\n\n\t\tself._list_idx = list_idx\n\n\t@property\n\tdef page_idx(self):\n\t\t\"\"\"Gets the page_idx of this GraphicsResult.  # noqa: E501\n\n\n\t\t:return: The page_idx of this GraphicsResult.  # noqa: E501\n\t\t:rtype: int\n\t\t\"\"\"\n\t\treturn self._page_idx\n\n\t@page_idx.setter\n\tdef page_idx(self, page_idx):\n\t\t\"\"\"Sets the page_idx of this GraphicsResult.\n\n\n\t\t:param page_idx: The page_idx of this GraphicsResult.  # noqa: E501\n\t\t:type page_idx: int\n\t\t\"\"\"\n\n\t\tself._page_idx = page_idx\n\n\t@property\n\tdef result_type(self):\n\t\t\"\"\"Gets the result_type of this GraphicsResult.  # noqa: E501\n\n\t\tSame as Result type, but used for safe parsing of not-described values. See Result type.  # noqa: E501\n\n\t\t:return: The result_type of this GraphicsResult.  # noqa: E501\n\t\t:rtype: int\n\t\t\"\"\"\n\t\treturn self._result_type\n\n\t@result_type.setter\n\tdef result_type(self, result_type):\n\t\t\"\"\"Sets the result_type of this GraphicsResult.\n\n\t\tSame as Result type, but used for safe parsing of not-described values. See Result type.  # noqa: E501\n\n\t\t:param result_type: The result_type of this GraphicsResult.  # noqa: E501\n\t\t:type result_type: int\n\t\t\"\"\"\n\t\tif self.local_vars_configuration.client_side_validation and result_type is None:  # noqa: E501\n\t\t\traise ValueError(\"Invalid value for `result_type`, must not be `None`\")  # noqa: E501\n\n\t\tself._result_type = result_type\n\n\tdef to_dict(self):\n\t\t\"\"\"Returns the model properties as a dict\"\"\"\n\t\tresult = {}\n\n\t\tfor attr, _ in six.iteritems(self.openapi_types):\n\t\t\tvalue = getattr(self, attr)\n\t\t\tif isinstance(value, list):\n\t\t\t\tresult[attr] = list(map(\n\t\t\t\t\tlambda x: x.to_dict() if hasattr(x, \"to_dict\") else x,\n\t\t\t\t\tvalue\n\t\t\t\t))\n\t\t\telif hasattr(value, \"to_dict\"):\n\t\t\t\tresult[attr] = value.to_dict()\n\t\t\telif isinstance(value, dict):\n\t\t\t\tresult[attr] = dict(map(\n\t\t\t\t\tlambda item: (item[0], item[1].to_dict())\n\t\t\t\t\tif hasattr(item[1], \"to_dict\") else item,\n\t\t\t\t\tvalue.items()\n\t\t\t\t))\n\t\t\telse:\n\t\t\t\tresult[attr] = value\n\n\t\treturn result\n\n\tdef to_str(self):\n\t\t\"\"\"Returns the string representation of the model\"\"\"\n\t\treturn pprint.pformat(self.to_dict())\n\n\tdef __repr__(self):\n\t\t\"\"\"For `print` and `pprint`\"\"\"\n\t\treturn self.to_str()\n\n\tdef __eq__(self, other):\n\t\t\"\"\"Returns true if both objects are equal\"\"\"\n\t\tif not isinstance(other, GraphicsResult):\n\t\t\treturn False\n\n\t\treturn self.to_dict() == other.to_dict()\n\n\tdef __ne__(self, other):\n\t\t\"\"\"Returns true if both objects are not equal\"\"\"\n\t\tif not isinstance(other, GraphicsResult):\n\t\t\treturn True\n\n\t\treturn self.to_dict() != other.to_dict()\n", "description": "NOTE: This class is auto generated by OpenAPI Generator.\n\tRef: https://openapi-generator.tech\n\n\tDo not edit the class manually.\n\t", "category": "graphics", "imports": ["import pprint", "import re  # noqa: F401", "import six", "from regula.documentreader.webclient.gen.configuration import Configuration", "from regula.documentreader.webclient.gen.models import *"]}], [], [{"term": "class", "name": "GraphicsWidget", "data": "class GraphicsWidget(GraphicsItem, QtGui.QGraphicsWidget):\n\t\n\t_qtBaseClass = QtGui.QGraphicsWidget\n\tdef __init__(self, *args, **kargs):\n\t\t\"\"\"\n\t\t**Bases:** :class:`GraphicsItem `, :class:`QtGui.QGraphicsWidget`\n\t\t\n\t\tExtends QGraphicsWidget with several helpful methods and workarounds for PyQt bugs. \n\t\tMost of the extra functionality is inherited from :class:`GraphicsItem `.\n\t\t\"\"\"\n\t\tQtGui.QGraphicsWidget.__init__(self, *args, **kargs)\n\t\tGraphicsItem.__init__(self)\n\t\t\n\t\t## done by GraphicsItem init\n\t\t#GraphicsScene.registerObject(self)  ## workaround for pyqt bug in graphicsscene.items()\n\n\t# Removed due to https://bugreports.qt-project.org/browse/PYSIDE-86\n\t#def itemChange(self, change, value):\n\t\t## BEWARE: Calling QGraphicsWidget.itemChange can lead to crashing!\n\t\t##ret = QtGui.QGraphicsWidget.itemChange(self, change, value)  ## segv occurs here\n\t\t## The default behavior is just to return the value argument, so we'll do that\n\t\t## without calling the original method.\n\t\t#ret = value\n\t\t#if change in [self.ItemParentHasChanged, self.ItemSceneHasChanged]:\n\t\t\t#self._updateView()\n\t\t#return ret\n\n\tdef setFixedHeight(self, h):\n\t\tself.setMaximumHeight(h)\n\t\tself.setMinimumHeight(h)\n\n\tdef setFixedWidth(self, h):\n\t\tself.setMaximumWidth(h)\n\t\tself.setMinimumWidth(h)\n\t\t\n\tdef height(self):\n\t\treturn self.geometry().height()\n\t\n\tdef width(self):\n\t\treturn self.geometry().width()\n\n\tdef boundingRect(self):\n\t\tbr = self.mapRectFromParent(self.geometry()).normalized()\n\t\t#print \"bounds:\", br\n\t\treturn br\n\t\t\n\tdef shape(self):  ## No idea why this is necessary, but rotated items do not receive clicks otherwise.\n\t\tp = QtGui.QPainterPath()\n\t\tp.addRect(self.boundingRect())\n\t\t#print \"shape:\", p.boundingRect()\n\t\treturn p\n\n\n", "description": "\n\t\t**Bases:** :class:`GraphicsItem `, :class:`QtGui.QGraphicsWidget`\n\t\t\n\t\tExtends QGraphicsWidget with several helpful methods and workarounds for PyQt bugs. \n\t\tMost of the extra functionality is inherited from :class:`GraphicsItem `.\n\t\t", "category": "graphics", "imports": ["from ..Qt import QtGui, QtCore  ", "from ..GraphicsScene import GraphicsScene", "from .GraphicsItem import GraphicsItem"]}], [{"term": "class", "name": "_PanTool", "data": "class _PanTool(GraphicsTool):\n\tname = 'Pan'\n\n\tdef init(self):\n\t\tself.origin = None\n\t\tself.prevCursor = None\n\t\tbutton = self.factory.button\n\t\tself.buttonTest = lambda mouse: getattr(mouse.buttons, button)\n\n\tdef mouse_pressed(self):\n\t\tif self.buttonTest(self.mouse):\n\t\t\tself.origin = self.mouse.screenCoords\n\t\t\tself.prevCursor = self.graphics.cursor()\n\t\t\tself.graphics.setCursor(Qt.ClosedHandCursor)\n\n\tdef mouse_moved(self):\n\t\tif self.buttonTest(self.mouse) and self.origin:\n\t\t\tvBar = self.graphics.verticalScrollBar()\n\t\t\thBar = self.graphics.horizontalScrollBar();\n\t\t\tox,oy = self.origin\n\t\t\tx,y = self.mouse.screenCoords\n\t\t\tdx,dy = x-ox,y-oy\n\t\t\thBar.setValue(hBar.value() - dx)\n\t\t\tvBar.setValue(vBar.value() - dy)\n\t\t\tself.origin = (x,y)\n\n\tdef mouse_released(self):\n\t\tif self.origin:\n\t\t\tself.graphics.setCursor(self.prevCursor)\n\t\t\tself.origin = None\n\n", "description": null, "category": "graphics", "imports": ["from PySide.QtCore import Qt", "from PySide.QtGui import QGraphicsView", "from traits.api import Enum", "from arrview.tools.base import GraphicsTool, GraphicsToolFactory"]}, {"term": "class", "name": "PanTool", "data": "class PanTool(GraphicsToolFactory):\n\tklass = _PanTool\n\tbutton = Enum('left','middle','right')\n\n", "description": null, "category": "graphics", "imports": ["from PySide.QtCore import Qt", "from PySide.QtGui import QGraphicsView", "from traits.api import Enum", "from arrview.tools.base import GraphicsTool, GraphicsToolFactory"]}, {"term": "class", "name": "_ZoomTool", "data": "class _ZoomTool(GraphicsTool):\n\tname = 'Zoom'\n\n\tdef init(self):\n\t\tself.graphics.setTransformationAnchor(\n\t\t\t\tQGraphicsView.ViewportAnchor.AnchorUnderMouse)\n\t\tself._default_scale = self.graphics.transform().m11()\n\n\tdef mouse_wheeled(self):\n\t\tcurrentScale = self.graphics.transform().m11()\n\t\tzoomIn = self.mouse.delta < 0\n\t\ts = 1.2 if zoomIn else 1/1.2\n\t\tlessThanMax = zoomIn and currentScale < 20\n\t\tgreaterThanMin = not zoomIn and currentScale > 0.1\n\t\tif lessThanMax or greaterThanMin:\n\t\t\tself.graphics.scale(s,s)\n\n\tdef mouse_double_clicked(self):\n\t\tif self.mouse.buttons.middle:\n\t\t\ts = self._default_scale\n\t\t\tself.graphics.scale(s,s)\n\n", "description": null, "category": "graphics", "imports": ["from PySide.QtCore import Qt", "from PySide.QtGui import QGraphicsView", "from traits.api import Enum", "from arrview.tools.base import GraphicsTool, GraphicsToolFactory"]}, {"term": "class", "name": "ZoomTool", "data": "class ZoomTool(GraphicsToolFactory):\n\tklass = _ZoomTool\n", "description": null, "category": "graphics", "imports": ["from PySide.QtCore import Qt", "from PySide.QtGui import QGraphicsView", "from traits.api import Enum", "from arrview.tools.base import GraphicsTool, GraphicsToolFactory"]}], [], [{"term": "class", "name": "classAnimationPlayer:", "data": "class AnimationPlayer:\n\tdef __init__(self):\n\t\tself.frames = {\n\t\t\t# magic\n\t\t\t'flame': import_folder(res('../graphics/particles/flame/frames')),\n\t\t\t'aura': import_folder(res('../graphics/particles/aura')),\n\t\t\t'heal': import_folder(res('../graphics/particles/heal/frames')),\n\n\t\t\t# attacks\n\t\t\t'claw': import_folder(res('../graphics/particles/claw')),\n\t\t\t'slash': import_folder(res('../graphics/particles/slash')),\n\t\t\t'sparkle': import_folder(res('../graphics/particles/sparkle')),\n\t\t\t'leaf_attack': import_folder(res('../graphics/particles/leaf_attack')),\n\t\t\t'thunder': import_folder(res('../graphics/particles/thunder')),\n\n\t\t\t# monster deaths\n\t\t\t'squid': import_folder(res('../graphics/particles/smoke_orange')),\n\t\t\t'raccoon': import_folder(res('../graphics/particles/raccoon')),\n\t\t\t'spirit': import_folder(res('../graphics/particles/nova')),\n\t\t\t'bamboo': import_folder(res('../graphics/particles/bamboo')),\n\n\t\t\t# leafs\n\t\t\t'leaf': (\n\t\t\t\timport_folder(res('../graphics/particles/leaf1')),\n\t\t\t\timport_folder(res('../graphics/particles/leaf2')),\n\t\t\t\timport_folder(res('../graphics/particles/leaf3')),\n\t\t\t\timport_folder(res('../graphics/particles/leaf4')),\n\t\t\t\timport_folder(res('../graphics/particles/leaf5')),\n\t\t\t\timport_folder(res('../graphics/particles/leaf6')),\n\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf1'))),\n\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf2'))),\n\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf3'))),\n\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf4'))),\n\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf5'))),\n\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf6'))),\n\t\t\t\t)\n\t\t\t}\n\n\t@staticmethod\n\tdef reflect_images(frames):\n\t\tnew_frames = []\n\t\tfor frame in frames:\n\t\t\tflipped_frame = pygame.transform.flip(frame, True, False)\n\t\t\tnew_frames.append(flipped_frame)\n\t\treturn new_frames\n\n\tdef create_grass_particles(self, pos, groups):\n\t\tanimation_frames = choice(self.frames['leaf'])\n\t\tParticleEffect(pos, animation_frames, groups, 0.25)\n\n\tdef create_particles(self, animation_type, pos, groups):\n\t\tanimation_frames = self.frames[animation_type]\n\t\tParticleEffect(pos, animation_frames, groups)\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "from file_path import res", "\t\t\t'flame': import_folder(res('../graphics/particles/flame/frames')),", "\t\t\t'aura': import_folder(res('../graphics/particles/aura')),", "\t\t\t'heal': import_folder(res('../graphics/particles/heal/frames')),", "\t\t\t'claw': import_folder(res('../graphics/particles/claw')),", "\t\t\t'slash': import_folder(res('../graphics/particles/slash')),", "\t\t\t'sparkle': import_folder(res('../graphics/particles/sparkle')),", "\t\t\t'leaf_attack': import_folder(res('../graphics/particles/leaf_attack')),", "\t\t\t'thunder': import_folder(res('../graphics/particles/thunder')),", "\t\t\t'squid': import_folder(res('../graphics/particles/smoke_orange')),", "\t\t\t'raccoon': import_folder(res('../graphics/particles/raccoon')),", "\t\t\t'spirit': import_folder(res('../graphics/particles/nova')),", "\t\t\t'bamboo': import_folder(res('../graphics/particles/bamboo')),", "\t\t\t\timport_folder(res('../graphics/particles/leaf1')),", "\t\t\t\timport_folder(res('../graphics/particles/leaf2')),", "\t\t\t\timport_folder(res('../graphics/particles/leaf3')),", "\t\t\t\timport_folder(res('../graphics/particles/leaf4')),", "\t\t\t\timport_folder(res('../graphics/particles/leaf5')),", "\t\t\t\timport_folder(res('../graphics/particles/leaf6')),", "\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf1'))),", "\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf2'))),", "\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf3'))),", "\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf4'))),", "\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf5'))),", "\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf6'))),"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\n\tdef __init__(self, pos, animation_frames, groups, animation_speed = 0.18):\n\t\tsuper().__init__(groups)\n\t\tself.sprite_type = 'magic'\n\t\tself.frame_index = 0\n\t\tself.animation_speed = animation_speed\n\t\tself.frames = animation_frames\n\t\tself.image = self.frames[self.frame_index]\n\t\tself.rect = self.image.get_rect(center = pos)\n\n\tdef animate(self):\n\t\tself.frame_index += self.animation_speed\n\t\tif self.frame_index >= len(self.frames):\n\t\t\tself.kill()\n\t\telse:\n\t\t\tself.image = self.frames[int(self.frame_index)]\n\n\tdef update(self):\n", "description": null, "category": "graphics", "imports": ["import pygame", "from support import import_folder", "from random import choice", "from file_path import res", "\t\t\t'flame': import_folder(res('../graphics/particles/flame/frames')),", "\t\t\t'aura': import_folder(res('../graphics/particles/aura')),", "\t\t\t'heal': import_folder(res('../graphics/particles/heal/frames')),", "\t\t\t'claw': import_folder(res('../graphics/particles/claw')),", "\t\t\t'slash': import_folder(res('../graphics/particles/slash')),", "\t\t\t'sparkle': import_folder(res('../graphics/particles/sparkle')),", "\t\t\t'leaf_attack': import_folder(res('../graphics/particles/leaf_attack')),", "\t\t\t'thunder': import_folder(res('../graphics/particles/thunder')),", "\t\t\t'squid': import_folder(res('../graphics/particles/smoke_orange')),", "\t\t\t'raccoon': import_folder(res('../graphics/particles/raccoon')),", "\t\t\t'spirit': import_folder(res('../graphics/particles/nova')),", "\t\t\t'bamboo': import_folder(res('../graphics/particles/bamboo')),", "\t\t\t\timport_folder(res('../graphics/particles/leaf1')),", "\t\t\t\timport_folder(res('../graphics/particles/leaf2')),", "\t\t\t\timport_folder(res('../graphics/particles/leaf3')),", "\t\t\t\timport_folder(res('../graphics/particles/leaf4')),", "\t\t\t\timport_folder(res('../graphics/particles/leaf5')),", "\t\t\t\timport_folder(res('../graphics/particles/leaf6')),", "\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf1'))),", "\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf2'))),", "\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf3'))),", "\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf4'))),", "\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf5'))),", "\t\t\t\tself.reflect_images(import_folder(res('../graphics/particles/leaf6'))),"]}], [{"term": "class", "name": "classlayout:\r", "data": "class layout:\r\n\t\"\"\"A class to represent keyboard layout.\r\n\r\n\tLayout class has 2 major functions. At first is holds an information\r\n\tabout the keyboard layout (position of buttons on keyboard). \r\n\tSecondly, it provides mapping from symbols (e.g. ['z', 'Z'] maps \r\n\tto button 'Z', ['~','`'] maps to button 'Tilde'). This mapping needs\r\n\tto be unique in order to be reversible. The one-to-many \r\n\t(further refered as button-to-symbol mapping is stored in \r\n\tdictionary _K[]['symbol']). The one-to-one mapping \r\n\t(further refered to as symbol-to-button is obtained by reversing \r\n\tthe mapping _K and is stored in dictionary _M[symbol]).\r\n\r\n\tAttributes:\r\n\t\tself.allButtons\r\n\t\tself.alphabetButtons\r\n\t\tself.numericButtons\r\n\t\tself.punctuationButtons\r\n\t\tself.functionalButtons \r\n\t\tself.extendedButtons\r\n\t\tself.finger1Buttons\r\n\t\tself.finger2Buttons\r\n\t\tself.finger3Buttons\r\n\t\tself.finger4Buttons\r\n\t\tself.finger7Buttons\r\n\t\tself.finger8Buttons\r\n\t\tself.finger9Buttons\r\n\t\tself.finger10Buttons\r\n\t\tself.leftHandButtons\r\n\t\tself.rightHandButtons\t \r\n\t\t\tPredefined lists of buttons list() to provide \r\n\t\t\t\tsimple way to partition the keyboard layout.\r\n\r\n\tMethods:\r\n\t\tlayout(keyboardType='external', qwerty=True, shift_l_long=True, enter_tall=True, language='englishUS', alpha=0.1, facecolor='blue', edgecolor='black')\r\n\t\tbindSymbolToButton(symbol, button)\r\n\t\tunbindSymbolFromButton(symbol, button)\r\n\t\tcreateButton(button, x, y, symbols, dx, dy, z = 0.0, dz=1.0, edgecolor='black',facecolor='blue', alpha=0.1)\r\n\t\tdeleteButton(button)\r\n\t\tsymbol2button(symbol)\r\n\t\tgetButtonList()\r\n\t\tgetSymbolList()\r\n\t\tgetButtonToSymbolDict()\r\n\t\tgetSymbolToButtonDict()\r\n\t\tsetButtonValue(button, labels, value)\r\n\t\tgetButtonValue(button, labels)\r\n\t\tplotKeyboard3D(axis, defaultLook=True, nameShow=True, bindShow=False, dzShow=True, textOffset=[0.0, 0.0, 0.0], aspectRatioModifier=[1.0, 1.0, 1.0], fontSize=10)\r\n\t\tplotKeyboard2D(axis, defaultLook=True, nameShow=True, bindShow=False, dzShow=True, textOffset=[0.0, 0.0, 0.0], fontSize=10)\t\t\r\n\t\"\"\"\r\n\t#%% init\r\n\tdef __init__(self, keyboardType='external', qwerty=True, shift_l_long=True, enter_tall=True, language='englishUS', alpha=0.1, facecolor='blue', edgecolor='black'):\r\n\t\t\"\"\"Inits layout class with default parameters.\r\n\t\t\r\n\t\tArguments:\r\n\t\t\tkeyboardType: \r\n\t\t\t\t'external': (default) large format keyboard (e.g. desktop)\r\n\t\t\t\t'builtin': small form-factor keyboard (e.g. laptop)\r\n\t\t\tqwerty : \r\n\t\t\t\tTrue: (default) QWERTY\r\n\t\t\t\tFalse: QWERTZ\r\n\t\t\tshift_l_long: \r\n\t\t\t\tTrue: (default) left SHIFT is followed by the letter 'Z' \r\n\t\t\t\t\t(qwerty: True) or 'Y' (qwerty: False)\r\n\t\t\t\tFalse: left sHIFT is followed by 's10' (symbol button 10)\r\n\t\t\tenter_tall: \r\n\t\t\t\tTrue: (default) Enter button streches across row 2 and 3\r\n\t\t\t\tFalse: Enter button occupies row 3, s6 is moved above Enter\r\n\t\t\tlanguage: \r\n\t\t\t\t'englishUS': (default) US English keyboard (e.g. SHIFT+3=#)\r\n\t\t\t\t'englishUK': UK English keyboard (e.g. SHIFT+3=\u00a3)\r\n\t\t\talpha: \r\n\t\t\t\t0.1: (default) initial value of alpha channel\r\n\t\t\tfacecolor:  or )>\r\n\t\t\t\t'blue': (default) inital value of button color\r\n\t\t\tedgecolor:  or )>\r\n\t\t\t\t'black': (default) inital value of buttonedge color\r\n\t\t\t\t\r\n\t\tRaises:\r\n\t\t\tUserInput: an error occured due to changes in mapping \r\n\t\t\t\tof symbol to button (changes to internal variable _K)\r\n\t\t\t\t\r\n\t\tReturns:\r\n\t\t\"\"\"\r\n\t\t### input check\r\n\t\t# keyboardType\r\n\t\tif(keyboardType=='external' or  keyboardType=='builtin'):\r\n\t\t\tself._keyboardType = keyboardType\r\n\t\telse:\r\n\t\t\traise Exception(\"layout.__init__(..., keyboardType=<'external', 'builtin'>, ...): incorrect parameter keyboardType=<\"+keyboardType+\">\")\r\n\t\t# language\r\n\t\tif(language=='englishUS' or  language=='englishUK'):\r\n\t\t\tself._language = language\r\n\t\telse:\r\n\t\t\traise Exception(\"layout.__init__(..., language=<'englishUS','englishUK'>, ...): incorrect parameter language=<\"+language+\">\")\r\n\t\tself._qwerty = qwerty\r\n\t\tself._shift_l_long = shift_l_long\r\n\t\tself._enter_tall   = enter_tall\r\n\t\t\r\n\t\t#%% keyboard layout dict\r\n\t\tself._K = {}\r\n\t\t\r\n\t\t## abbreviated language variable for terniary operator\r\n\t\tif(self._language == 'englishUS'):\r\n\t\t\t_L = True\r\n\t\telse:\r\n\t\t\t_L = False\r\n\t\t\r\n\t\t### external keyboard\r\n\t\tif(self._keyboardType=='external'):\r\n\t\t\t# row 1\r\n\t\t\t_rowX = 0\r\n\t\t\tself._K['Esc']   = {'symbol':['esc'],\t\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F1']\t= {'symbol':['f1'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']+1\t, 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F2']\t= {'symbol':['f2'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F3']\t= {'symbol':['f3'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F4']\t= {'symbol':['f4'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F5']\t= {'symbol':['f5'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']+0.25 , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F6']\t= {'symbol':['f6'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F7']\t= {'symbol':['f7'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F8']\t= {'symbol':['f8'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F9']\t= {'symbol':['f9'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']+0.25 , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F10']   = {'symbol':['f10'],\t\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F11']   = {'symbol':['f11'],\t\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F12']   = {'symbol':['f12'],\t\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\t\r\n\t\t\tself._K['PrtSc']   = {'symbol':['print_screen'],\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']+0.25 , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['ScrLk']   = {'symbol':['scroll_lock'],\t\t\t\t\t 'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['PauBrk']  = {'symbol':['pause'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\t# row 2\r\n\t\t\t_rowX = 1\r\n\t\t\tself._K['Tilde']   = {'symbol':['`','~'] if _L else ['`','\u00ac','\u00a6','\u00a7','\u00b1'],  'graphics': {'x':_rowX, 'y':0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ,  'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['1']\t   = {'symbol':['1','!'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['2']\t   = {'symbol':['2','@'] if _L else ['2','\"'],\t  'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['3']\t   = {'symbol':['3','#'] if _L else ['3','\u00a3'],\t  'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['4']\t   = {'symbol':['4','$'] if _L else ['4','$','\u20ac'],  'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['5']\t   = {'symbol':['5','%'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['6']\t   = {'symbol':['6','^'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['7']\t   = {'symbol':['7','&'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['8']\t   = {'symbol':['8','*'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['9']\t   = {'symbol':['9','('],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['0']\t   = {'symbol':['0',')'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s0']\t  = {'symbol':['-','_'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s1']\t  = {'symbol':['=','+'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['BckSpc']  = {'symbol':['backspace'],\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1.5, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\r\n\t\t\tself._K['Ins']\t = {'symbol':['insert'],\t\t\t\t\t\t  'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']+0.25 , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['Home']\t= {'symbol':['home'],\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['PgUp']\t= {'symbol':['page_up'],\t\t\t\t\t\t 'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\t## row 3\r\n\t\t\t_rowX = 2\r\n\t\t\tself._K['Tab']\t = {'symbol':['tab'],\t\t\t\t\t\t\t 'graphics': {'x':_rowX, 'y':0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['Q']\t   = {'symbol':['q','Q'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['W']\t   = {'symbol':['w','W'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['E']\t   = {'symbol':['e','E'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['R']\t   = {'symbol':['r','R'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['T']\t   = {'symbol':['t','T'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tif(self._qwerty):\r\n\t\t\t\tself._K['Y']\t  = {'symbol':['y','Y'],\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\telse:\r\n\t\t\t\tself._K['Z']\t  = {'symbol':['z','Z'],\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['U']\t   = {'symbol':['u','U'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['I']\t   = {'symbol':['i','I'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['O']\t   = {'symbol':['o','O'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['P']\t   = {'symbol':['p','P'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s2']\t  = {'symbol':['[','{'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s3']\t  = {'symbol':[']','}'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tif(self._enter_tall):\t\t\r\n\t\t\t\tself._K['Enter']   = {'symbol':['enter'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']+0.5  , 'z':0, 'dx':2, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\telse:\r\n\t\t\t\tself._K['s6']\t  = {'symbol':['\\\\','|'] if _L else ['#','~','\\\\'],\t  'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1.5, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\t\t\r\n\t\t\tself._K['Del']\t = {'symbol':['delete'],\t\t\t\t\t\t  'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']+0.25 , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['End']\t = {'symbol':['end'],\t\t\t\t\t\t\t 'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['PgDn']\t= {'symbol':['page_down'],\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\t# row 4\r\n\t\t\t_rowX = 3\r\n\t\t\tself._K['CapsLck'] = {'symbol':['caps_lock'],\t\t\t\t\t   'graphics': {'x':_rowX, 'y':0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t , 'z':0, 'dx':1, 'dy':1.5,'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['A']\t   = {'symbol':['a','A'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['S']\t   = {'symbol':['s','S'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['D']\t   = {'symbol':['d','D'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F']\t   = {'symbol':['f','F'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['G']\t   = {'symbol':['g','G'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['H']\t   = {'symbol':['h','H'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['J']\t   = {'symbol':['j','J'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['K']\t   = {'symbol':['k','K'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['L']\t   = {'symbol':['l','L'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s4']\t  = {'symbol':[';',':'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s5']\t  = {'symbol':[\"'\",'\"'] if _L else [\"'\",'@'],\t  'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tif(self._enter_tall):\r\n\t\t\t\tself._K['s6']\t  = {'symbol':['\\\\','|'] if _L else ['#','~','\\\\'],\t  'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\telse:\r\n\t\t\t\tself._K['Enter']   = {'symbol':['enter'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']  , 'z':0, 'dx':1, 'dy':2, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\r\n\t\t\t# row 5\r\n\t\t\t_rowX = 4\r\n\t\t\tif(self._shift_l_long):\r\n\t\t\t\tself._K['Shift_l'] = {'symbol':['shift','shift_l'],\t\t\t\t\t 'graphics': {'x':_rowX, 'y':0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t , 'z':0, 'dx':1, 'dy':2.0,'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\telse:\r\n\t\t\t\t self._K['Shift_l'] = {'symbol':['shift','shift_l'],\t\t\t\t\t'graphics': {'x':_rowX, 'y':0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t , 'z':0, 'dx':1, 'dy':1.0,'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\t\t # add new button\r\n\t\t\t\t self._K['s10'] = {'symbol':['\\\\','|'],\t\t\t\t\t\t\t\t 'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1.0,'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\t\t # change symbol assignmnet at 's6'\r\n\t\t\t\t self._K['s6']['symbol'] = []\t\t\t   \r\n\t\t\t\t\r\n\t\t\tif(qwerty):\r\n\t\t\t\tself._K['Z']\t   = {'symbol':['z','Z'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\telse:\t\r\n\t\t\t\tself._K['Y']\t   = {'symbol':['y','Y'],\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['X']\t   = {'symbol':['x','X'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['C']\t   = {'symbol':['c','C'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['V']\t   = {'symbol':['v','V'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['B']\t   = {'symbol':['b','B'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['N']\t   = {'symbol':['n','N'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['M']\t   = {'symbol':['m','M'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s7']\t  = {'symbol':[',','<'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s8']\t  = {'symbol':['.','>'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s9']\t  = {'symbol':['/','?'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['Shift_r'] = {'symbol':['shift_r'],\t\t\t\t\t\t 'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':2.5, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\r\n\t\t\tself._K['aUp']\t= {'symbol':['up'],\t\t\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']+1.25\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\t## row 6\r\n\t\t\t_rowX = 5\r\n\t\t\tself._K['Ctrl_l']  = {'symbol':['ctrl','ctrl_l'],\t\t\t\t   'graphics': {'x':_rowX, 'y':0\t\t, 'z':0, 'dx':1, 'dy':1.5, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['Alt_l']   = {'symbol':['alt', 'alt_l'],\t\t\t\t\t'graphics': {'x':_rowX, 'y':3\t\t, 'z':0, 'dx':1, 'dy':1.5, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['Space']   = {'symbol':['space', ' '],\t\t\t\t\t  'graphics': {'x':_rowX, 'y':4.5\t  , 'z':0, 'dx':1, 'dy':5.0, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['Alt_r']   = {'symbol':['alt_r','alt_gr'],\t\t\t\t  'graphics': {'x':_rowX, 'y':9.5\t  , 'z':0, 'dx':1, 'dy':1.5, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['Ctrl_r']  = {'symbol':['ctrl_r'],\t\t\t\t\t\t  'graphics': {'x':_rowX, 'y':13.0\t , 'z':0, 'dx':1, 'dy':1.5, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\r\n\t\t\tself._K['aLeft']  = {'symbol':['left'],\t\t\t\t\t\t\t 'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']+0.25 , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['aDown']  = {'symbol':['down'],\t\t\t\t\t\t\t 'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['aRight'] = {'symbol':['right'],\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\r\n\t\t### builtin keyboard (different geometry of arrow keys and functional keys)\r\n\t\tif(keyboardType=='builtin'):\r\n\t\t\t# row 1\r\n\t\t\t_rowX = 0\r\n\t\t\tself._K['Esc']   = {'symbol':['esc'],\t\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F1']\t= {'symbol':['f1'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':0.9, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F2']\t= {'symbol':['f2'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':0.9, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F3']\t= {'symbol':['f3'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':0.9, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F4']\t= {'symbol':['f4'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':0.9, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F5']\t= {'symbol':['f5'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':0.9, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F6']\t= {'symbol':['f6'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':0.9, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F7']\t= {'symbol':['f7'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':0.9, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F8']\t= {'symbol':['f8'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':0.9, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F9']\t= {'symbol':['f9'],\t\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':0.9, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F10']   = {'symbol':['f10'],\t\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':0.9, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F11']   = {'symbol':['f11'],\t\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':0.9, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F12']   = {'symbol':['f12'],\t\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':0.9, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['PrtSc'] = {'symbol':['print_screen'],\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t\t, 'z':0, 'dx':1, 'dy':0.9, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['Ins']   = {'symbol':['insert'],\t\t\t\t\t 'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t\t\t , 'z':0, 'dx':1, 'dy':0.9, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['Del']   = {'symbol':['delete'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t   , 'z':0, 'dx':1, 'dy':0.9, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\t# row 2\r\n\t\t\t_rowX = 1\r\n\t\t\tself._K['Tilde']   = {'symbol':['`','~'] if _L else ['`','\u00ac','\u00a6','\u00a7','\u00b1'],  'graphics': {'x':_rowX, 'y':0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ,  'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['1']\t   = {'symbol':['1','!'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['2']\t   = {'symbol':['2','@'] if _L else ['2','\"'],\t  'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['3']\t   = {'symbol':['3','#'] if _L else ['3','\u00a3'],\t  'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['4']\t   = {'symbol':['4','$'] if _L else ['4','$','\u20ac'],  'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['5']\t   = {'symbol':['5','%'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['6']\t   = {'symbol':['6','^'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['7']\t   = {'symbol':['7','&'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['8']\t   = {'symbol':['8','*'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['9']\t   = {'symbol':['9','('],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['0']\t   = {'symbol':['0',')'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s0']\t  = {'symbol':['-','_'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s1']\t  = {'symbol':['=','+'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['BckSpc']  = {'symbol':['backspace'],\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1.5, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\t## row 3\r\n\t\t\t_rowX = 2\r\n\t\t\tself._K['Tab']\t = {'symbol':['tab'],\t\t\t\t\t\t\t 'graphics': {'x':_rowX, 'y':0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['Q']\t   = {'symbol':['q','Q'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['W']\t   = {'symbol':['w','W'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['E']\t   = {'symbol':['e','E'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['R']\t   = {'symbol':['r','R'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['T']\t   = {'symbol':['t','T'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tif(qwerty):\r\n\t\t\t\tself._K['Y']\t  = {'symbol':['y','Y'],\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\telse:\r\n\t\t\t\tself._K['Z']\t  = {'symbol':['z','Z'],\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['U']\t   = {'symbol':['u','U'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['I']\t   = {'symbol':['i','I'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['O']\t   = {'symbol':['o','O'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['P']\t   = {'symbol':['p','P'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s2']\t  = {'symbol':['[','{'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s3']\t  = {'symbol':[']','}'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tif(self._enter_tall):\t\t\r\n\t\t\t\tself._K['Enter']   = {'symbol':['enter'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']+0.5  , 'z':0, 'dx':2, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\telse:\r\n\t\t\t\tself._K['s6']\t  = {'symbol':['\\\\','|'] if _L else ['#','~','\\\\'],\t  'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1.5, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\t# row 4\r\n\t\t\t_rowX = 3\r\n\t\t\tself._K['CapsLck'] = {'symbol':['caps_lock'],\t\t\t\t\t   'graphics': {'x':_rowX, 'y':0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t , 'z':0, 'dx':1, 'dy':1.5,'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['A']\t   = {'symbol':['a','A'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['S']\t   = {'symbol':['s','S'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['D']\t   = {'symbol':['d','D'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['F']\t   = {'symbol':['f','F'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['G']\t   = {'symbol':['g','G'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['H']\t   = {'symbol':['h','H'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['J']\t   = {'symbol':['j','J'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['K']\t   = {'symbol':['k','K'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['L']\t   = {'symbol':['l','L'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s4']\t  = {'symbol':[';',':'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s5']\t  = {'symbol':[\"'\",'\"'] if _L else [\"'\",'@'],\t  'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tif(self._enter_tall):\r\n\t\t\t\tself._K['s6']\t  = {'symbol':['\\\\','|'] if _L else ['#','~','\\\\'],\t  'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\telse:\r\n\t\t\t\tself._K['Enter']   = {'symbol':['enter'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']  , 'z':0, 'dx':1, 'dy':2, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\t# row 5\r\n\t\t\t_rowX = 4\r\n\t\t\tif(self._shift_l_long):\r\n\t\t\t\tself._K['Shift_l'] = {'symbol':['shift','shift_l'],\t\t\t\t\t 'graphics': {'x':_rowX, 'y':0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t , 'z':0, 'dx':1, 'dy':2.0,'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\telse:\r\n\t\t\t\t self._K['Shift_l'] = {'symbol':['shift','shift_l'],\t\t\t\t\t'graphics': {'x':_rowX, 'y':0\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t , 'z':0, 'dx':1, 'dy':1.0,'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\t\t # add new button\r\n\t\t\t\t self._K['s10'] = {'symbol':['\\\\','|'],\t\t\t\t\t\t\t\t 'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1.0,'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\t\t # change symbol assignmnet at 's6'\r\n\t\t\t\t self._K['s6']['symbol'] = []\t\t\t   \r\n\t\t\tif(qwerty):\r\n\t\t\t\tself._K['Z']\t   = {'symbol':['z','Z'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\telse:\t\r\n\t\t\t\tself._K['Y']\t   = {'symbol':['y','Y'],\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['X']\t   = {'symbol':['x','X'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['C']\t   = {'symbol':['c','C'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['V']\t   = {'symbol':['v','V'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['B']\t   = {'symbol':['b','B'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['N']\t   = {'symbol':['n','N'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['M']\t   = {'symbol':['m','M'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s7']\t  = {'symbol':[',','<'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s8']\t  = {'symbol':['.','>'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['s9']\t  = {'symbol':['/','?'],\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['Shift_r'] = {'symbol':['shift_r'],\t\t\t\t\t\t 'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':2.5, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\t## row 6\r\n\t\t\t_rowX = 5\r\n\t\t\tself._K['Ctrl_l']  = {'symbol':['ctrl','ctrl_l'],\t\t\t\t   'graphics': {'x':_rowX, 'y':0\t\t, 'z':0, 'dx':1, 'dy':1.5, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['Alt_l']   = {'symbol':['alt', 'alt_l'],\t\t\t\t\t'graphics': {'x':_rowX, 'y':3\t\t, 'z':0, 'dx':1, 'dy':1.5, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['Space']   = {'symbol':['space', ' '],\t\t\t\t\t  'graphics': {'x':_rowX, 'y':4.5\t  , 'z':0, 'dx':1, 'dy':5.0, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['Alt_r']   = {'symbol':['alt_r','alt_gr'],\t\t\t\t  'graphics': {'x':_rowX, 'y':9.5\t  , 'z':0, 'dx':1, 'dy':1.0, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['Ctrl_r']  = {'symbol':['ctrl_r'],\t\t\t\t\t\t  'graphics': {'x':_rowX, 'y':10.5\t  , 'z':0, 'dx':1, 'dy':1.0, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\r\n\t\t\tself._K['aLeft']  = {'symbol':['left'],\t\t\t\t\t\t\t 'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['aUp']\t= {'symbol':['up'],\t\t\t\t\t\t\t   'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':0.5, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['aDown']  = {'symbol':['down'],\t\t\t\t\t\t\t 'graphics': {'x':_rowX+0.5, 'y':self._K[list(self._K)[-1]]['graphics']['y']\t\t\t\t\t\t\t\t\t\t\t   , 'z':0, 'dx':0.5, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\tself._K['aRight'] = {'symbol':['right'],\t\t\t\t\t\t\t'graphics': {'x':_rowX, 'y':self._K[list(self._K)[-1]]['graphics']['y']+self._K[list(self._K)[-1]]['graphics']['dy']\t  , 'z':0, 'dx':1, 'dy':1, 'dz':1, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\r\n\t\t#%% keyboard layout definition\r\n\t\t# predefined button sets\r\n\t\tself.allButtons\t\t = self._K.keys()\r\n\t\tself.alphabetButtons\t= ['Q', 'W','E','R','T','Y','U','I','O','P','A','S','D','F','G','H','J','K','L','Z','X','C','V','B','N','M']\r\n\t\tself.numericButtons\t = ['1','2','3','4','5','6','7','8','9','0']\r\n\t\tif(shift_l_long):\r\n\t\t\tself.punctuationButtons = ['s0','s1','s2','s3','s4','s5','s6','s7','s8','s9']\r\n\t\telse:\r\n\t\t\tself.punctuationButtons = ['s0','s1','s2','s3','s4','s5','s6','s7','s8','s9', 's10']\t \r\n\t\tif(keyboardType=='external'):\r\n\t\t\tself.functionalButtons  = ['Esc','Tab','CapsLck','Shift_l','Ctrl_l','Alt_l','Space','BckSpc','Enter','Shift_r','Alt_r','Ctrl_r']   \r\n\t\t\tself.extendedButtons\t= ['PrtSc','ScrLk','PauBrk','Ins','Home','PgUp','Del','End','PgDn','aUp','aLeft','aDown','aRight']  \r\n\t\telif(keyboardType=='builtin'):\r\n\t\t\tself.functionalButtons  = ['Esc','Tab','CapsLck','Shift_l','Ctrl_l','Alt_l','Space','BckSpc','Enter','Shift_r','Alt_r','Ctrl_r']   \r\n\t\t\tself.extendedButtons\t= ['PrtSc','Ins','Del','aUp','aLeft','aDown','aRight']  \r\n\t\t# according to https://thekeyboardreviews.com/typing-speed-how-can-i-improve-myself/\r\n\t\tif(shift_l_long):\r\n\t\t\tself.finger1Buttons\t= ['1','Tab','Q','CapsLck', 'A', 'Shift_l', 'Z']\r\n\t\telse:\r\n\t\t\tself.finger1Buttons\t= ['1','Tab','Q','CapsLck', 'A', 'Shift_l', 'Z','s10']\r\n\t\tself.finger2Buttons\t= ['2','W','S','X']\r\n\t\tself.finger3Buttons\t= ['3','E','D','C']\r\n\t\tself.finger4Buttons\t= ['4','5','R','T','F','G','V','B']\r\n\t\tself.finger7Buttons\t= ['6','7','Y','U','H','J','N','M']\r\n\t\tself.finger8Buttons\t= ['8','I','K','s7']\r\n\t\tself.finger9Buttons\t= ['9','O','L','s8']\r\n\t\tself.finger10Buttons\t= ['0','s0','s1','P','s2','s3','s4','s5','s6','s9']\t\r\n\t\t\r\n\t\tself.leftHandButtons   = self.finger1Buttons + self.finger2Buttons + self.finger3Buttons + self.finger4Buttons\r\n\t\tself.rightHandButtons  = self.finger7Buttons + self.finger8Buttons + self.finger9Buttons + self.finger10Buttons\r\n\r\n\t\t#%% keyboard mapping dict\r\n\t\tself._M = {} \r\n\t\t# symbol to button mapping\r\n\t\t_doubleBind = self._updateSymbolToButtonMap()\r\n\t\tif(len(_doubleBind)>0):\r\n\t\t\twarnings.warn('Changes to _K[button][''symbol''] within the \\\r\n\t\t\t\t\t\t  class constructor __init__ raised a warning \\\r\n\t\t\t\t\t\t  that the symbol-to-button map is not unique. \\\r\n\t\t\t\t\t\t  The dictionary of {symbol:[button1, button2, \\\r\n\t\t\t\t\t\t  ...]} is printed to console.', \\\r\n\t\t\t\t\t\t\tUserWarning, stacklevel=1)\r\n\t\t\tprint(_doubleBind)\r\n\t\r\n\t#%% _updateSymbolToButtonMap\r\n\tdef _updateSymbolToButtonMap(self):\r\n\t\t\"\"\"Updates map _M providing unique symbol-to-button map. \r\n\t\t\r\n\t\tThis method updates the internal _M symbol-to-button map and \r\n\t\tchecks whether the mapping is unique. The method returns a list \r\n\t\tof symbol(s) bound to multiple buttons.\r\n\t\t\r\n\t\tReturns:\r\n\t\t\tdict={symbol: [button1, button2, ...]}\r\n\t\t\t\tA dictionary with a symbol bound to multiple buttons. \r\n\t\t\t\tThis requires correction, such that every symbol is \r\n\t\t\t\tmapped to unique button (the opposite doesn't hold, \r\n\t\t\t\tsince one button can produce multiple symbols)\r\n\t\t\"\"\"\r\n\t\t_ERRORdoubleBind = {}\r\n\t\tfor k in self._K:\r\n\t\t\tfor v in self._K[k]['symbol']:\r\n\t\t\t\tif(v in self._M.keys()): # the \"v\" is already mapped to a key\r\n\t\t\t\t\t# keep the double-bound keys in _ERRORdoubleBind\r\n\t\t\t\t\tif(k in _ERRORdoubleBind):\r\n\t\t\t\t\t\t_ERRORdoubleBind[v] = _ERRORdoubleBind[k] + [k] + [self._M[v]]\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\t_ERRORdoubleBind[v] = [k] + [self._M[v]]\r\n\t\t\t\tself._M[v] = k\r\n\t\treturn _ERRORdoubleBind\r\n\r\n\t#%% Bind symbol to button\r\n\tdef bindSymbolToButton(self, symbol, button):\r\n\t\t\"\"\"Create new binding of a symbol to a button.\r\n\t\t\r\n\t\tArguments:\r\n\t\t\tsymbol: \r\n\t\t\t\tA symbol on a keyboard (e.g. 'k', '!', ':', '\\\\', 'P').\r\n\t\t\tbutton: \r\n\t\t\t\tPredefined button name from self.allButtons list or\r\n\t\t\t\t\tuser-defined button.\r\n\t\t\t\t\t\r\n\t\tReturns:\r\n\t\t\t\r\n\t\t\t-1: error, raises warining\r\n\t\t\t0: a symbol is already bound to a button (no change)\r\n\t\t\t1: successfult binding of a symbol to a button\r\n\t\t\t\r\n\t\tRaises:\r\n\t\t\tUserWarning: Wrong button name.\r\n\t\t\tUserWarning: Non-unique symbol-to-button binding.\r\n\t\t\"\"\"\r\n\t\tif(button not in self._K.keys()):\r\n\t\t\twarnings.warn('Button \"'+button+'\" is not recognized as valid button name, see layout.allButtons for a list of valid button names.', \\\r\n\t\t\t\t\t\t\tUserWarning, stacklevel=1)\r\n\t\t\t# return that binding was not performed due to error\r\n\t\t\treturn -1\r\n\t\telse:\r\n\t\t\t# binding already exists\r\n\t\t\tif(symbol in self._K[button]['symbol']):\r\n\t\t\t\t# return no change\r\n\t\t\t\treturn 0\r\n\t\t\t# perform binding\r\n\t\t\telse:\r\n\t\t\t\t# add new bind\r\n\t\t\t\tself._K[button]['symbol'].append(symbol)\t\t\t\t\r\n\t\t\t\t# redo mapping\r\n\t\t\t\tself._M = {} \r\n\t\t\t\t# perform symbol-to-button mapping\r\n\t\t\t\t_doubleBind = self._updateSymbolToButtonMap()\r\n\t\t\t\t# check for inconsistency\r\n\t\t\t\tif(len(_doubleBind)>0):\r\n\t\t\t\t\twarnings.warn('Symbol-to-button map is not unique. The dictionary of {symbol:[button1, button2, ...]} is printed to console.', UserWarning, stacklevel=1)\r\n\t\t\t\t\tprint(_doubleBind)\r\n\t\t\t\t# return the new binding is performed\r\n\t\t\t\treturn 1\r\n\r\n\t#%% Unbind symbol from button\r\n\tdef unbindSymbolFromButton(self, symbol, button):\r\n\t\t\"\"\"Remove a binding of a symbol to a button.\r\n\t\t\r\n\t\tArguments:\r\n\t\t\tsymbol: \r\n\t\t\t\tA symbol on a keyboard (e.g. 'k', '!', ':', '\\\\', 'P').\r\n\t\t\tbutton: \r\n\t\t\t\tPredefined button name from self.allButtons list or\r\n\t\t\t\t\tuser-defined button.\r\n\t\t\t\t\t\r\n\t\tReturns:\r\n\t\t\t\r\n\t\t\t-1: error, raises warining\r\n\t\t\t0: a symbol is not bound to a button (no change)\r\n\t\t\t1: successfult unbinding of a symbol from a button\r\n\t\t\t\r\n\t\tRaises:\r\n\t\t\tUserWarning: Wrong button name.\r\n\t\t\tUserWarning: Non-unique symbol-to-button binding.\r\n\t\t\"\"\"\r\n\t\tif(button not in self._K.keys()):\r\n\t\t\twarnings.warn('Button \"'+button+'\" is not recognized as valid button name, see layout.allButtons for a list of valid button names.', \\\r\n\t\t\t\t\t\t\tUserWarning, stacklevel=1)\r\n\t\t\treturn -1\r\n\t\telse:\r\n\t\t\t# binding already exists\r\n\t\t\tif(symbol in self._K[button]['symbol']):\r\n\t\t\t\tself._K[button]['symbol'].remove(symbol)\r\n\t\t\t\t# redo mapping\r\n\t\t\t\tself._M = {} \r\n\t\t\t\t# symbol to button mapping\r\n\t\t\t\tself._updateSymbolToButtonMap()\r\n\t\t\t\treturn 1\r\n\t\t\t# perform binding\r\n\t\t\telse:\t\r\n\t\t\t\twarnings.warn('Symbol \"'+symbol+'\" is not bound to Button \"'+button+'\".', UserWarning, stacklevel=1)\r\n\t\t\t\treturn -1\r\n\t\t\t\r\n\t#%% Create new button\r\n\tdef createButton(self, button, x, y, symbols, dx, dy, z = 0.0, dz=1.0, edgecolor='black',facecolor='blue', alpha=0.1):\r\n\t\t\"\"\"Create a new button that will be displayed in the layout\r\n\t\t\r\n\t\tArguments:\r\n\t\t\tbutton:\t  \r\n\t\t\t\tUnique button name.\r\n\t\t\tx:\t\t\t\r\n\t\t\t\tKeyboard row (0->row with Esc, 5->row with Spacebar)\t\r\n\t\t\ty:\t\t\t\r\n\t\t\t\tKeyboard column (0->Esc,Tab,Caps,Shift_l,Ctrl_l, \r\n\t\t\t\t\talphabetic key size=1, size of Spacebar is 5).\r\n\t\t\tsymbols: list()\t \r\n\t\t\t\tList of strings, where each string represents \r\n\t\t\t\t\ta symbol that maps to the button.\r\n\t\t\tdx:\t\t   \r\n\t\t\t\tHeight of the button (alphabetic key height is 1.0)\r\n\t\t\tdy:\t\t   \r\n\t\t\t\tWidth of the button (alphabetic key width is 1.0)\r\n\t\t\tz:\t\t\t\r\n\t\t\t\tBottom of the button (default=0.0)\r\n\t\t\tdz:\t\t   \r\n\t\t\t\tTop of the button (default=1.0 but this is meant to be \r\n\t\t\t\t\tused to represent user data when plotting in 3D).\r\n\t\t\tedgecolor:\t  \r\n\t\t\t\tInitial edgecolor.\r\n\t\t\tedgecolor:\t  \r\n\t\t\t\tInitial facecolor.\r\n\t\t\tedgecolor:\t  \r\n\t\t\t\tInitial alpha-channel value.\r\n\t\t\t\t\t\r\n\t\tReturns:\r\n\t\t\t\r\n\t\t\t-1: error, raises exception\r\n\t\t\t1: successfult unbinding of a symbol from a button\r\n\t\t\t\r\n\t\tRaises:\r\n\t\t\tException: Wrong button name.\r\n\t\t\tUserWarning: Non-unique symbol-to-button binding.\r\n\t\t\"\"\"\t\t\r\n\t\tif(button in self._K.keys()):\t\r\n\t\t\traise Exception(\"layout.createButton(..., button, ...): Button \"+button+\" is already used.\")\r\n\t\t\treturn -1\r\n\t\telse:\r\n\t\t\tself._K[button]  = {'symbol':symbols, 'graphics': {'x':x, 'y':y, 'z':z, 'dx':dx, 'dy':dy, 'dz':dz, 'edgecolor':edgecolor, 'facecolor':facecolor, 'alpha':alpha}, 'value': {}}\r\n\t\t\t# redo mapping\r\n\t\t\tself._M = {} \r\n\t\t\t# symbol to button mapping\r\n\t\t\t_doubleBind = self._updateSymbolToButtonMap()\r\n\t\t\tif(len(_doubleBind)>0):\r\n\t\t\t\twarnings.warn('Symbol-to-button map is not unique. The dictionary of {symbol:[button1, button2, ...]} is printed to console.', UserWarning, stacklevel=1)\r\n\t\t\t\tprint(_doubleBind)\r\n\t\t\treturn 1\r\n\r\n\t#%% Delete button  \r\n\tdef deleteButton(self, button):\r\n\t\t\"\"\"Remove a button from layout.\r\n\t\t\r\n\t\tArguments:\r\n\t\t\tbutton:\t  \r\n\t\t\t\tName f an existing button.\r\n\t\t\t\t\t\r\n\t\tReturns:\r\n\t\t\t\r\n\t\t\t-1: error, raises exception\r\n\t\t\t1: successfult unbinding of a symbol from a button\r\n\t\t\t\r\n\t\tRaises:\r\n\t\t\tException: Wrong button name.\r\n\t\t\"\"\"\t \r\n\t\tif(button in self._K.keys()):  \r\n\t\t\tdel(self.K[button])\r\n\t\t\t# redo mapping\r\n\t\t\tself._M = {} \r\n\t\t\t# symbol to button mapping\r\n\t\t\tself._updateSymbolToButtonMap()\r\n\t\t\treturn 1\r\n\t\telse:\r\n\t\t\traise Exception(\"layout.deleteButton(..., button, ...): Button \"+button+\" does not exist.\")\r\n\t\t\treturn -1\r\n\r\n\t#%% Translate symbol to button\r\n\tdef symbol2button(self, symbol):\r\n\t\t\"\"\"Translate a symbol to a button.\r\n\t\t\r\n\t\tArguments:\r\n\t\t\tsymbol:\t  \r\n\t\t\t\tSymbol within a layout\r\n\t\t\t\t\t\r\n\t\tReturns:\r\n\t\t\t\r\n\t\t\t\tButton from self.allButtons.\r\n\t\t\t\r\n\t\t\t\tSymbol is not bound to any button in the layout.\r\n\t\t\"\"\"   \r\n\t\ttry:\r\n\t\t\treturn self._M[symbol]\r\n\t\texcept KeyError:\r\n\t\t\treturn None\r\n\t\t\r\n\t#%% Get list of all registered buttons  \r\n\tdef getButtonList(self):\r\n\t\t\"\"\"Get a list of all buttons in a layout.\r\n\t\t\r\n\t\tThis method returns a list of all buttons in the layout. \r\n\t\tThe returned list is updated according to any introduced \r\n\t\tchanges to original layout (binding, unbinding, \r\n\t\tbutton creation, button removal).\r\n\t\t\r\n\t\tArguments:\r\n\t\t\t\t\t\r\n\t\tReturns:\r\n\t\t\tlist()\r\n\t\t\t\tList of all buttons in the layout.\r\n\t\t\"\"\"   \r\n\t\t# return a list of symbol currenly bound to buttons\r\n\t\treturn list(flatten([k for k in self._K]))\t\r\n\t\r\n\t#%% Get list of all registered symbols  \r\n\tdef getSymbolList(self):\r\n\t\t\"\"\"Get a list of all symbols in a layout.\r\n\t\t\r\n\t\tThis method returns a list of all symbols in the layout. \r\n\t\tThe returned list is updated according to any introduced \r\n\t\tchanges to original layout (binding, unbinding, \r\n\t\tbutton creation, button removal).\r\n\t\t\r\n\t\tArguments:\r\n\t\t\t\t\t\r\n\t\tReturns:\r\n\t\t\tlist()\r\n\t\t\t\tList of all symbols in the layout.\r\n\t\t\"\"\"   \r\n\t\t# return a list of symbol currenly bound to buttons\r\n\t\treturn list(flatten([m for m in self._M]))\r\n\t\r\n\t#%% Get dictionary that translate a button to a list of bound symbols\r\n\t### retunrs\r\n\t#   Dictionary {button=:[symbols=]}\r\n\tdef getButtonToSymbolDict(self):\r\n\t\t\"\"\"Get a dictionary storing button-to-symbol map.\r\n\t\t\r\n\t\tThis method returns a dictionary in form:\r\n\t\t\t{button1: [symbol1, symbol2, ...],\r\n\t\t\t button2: [symbol3, symbol4, ...]}\r\n\t\t\r\n\t\tArguments:\r\n\t\t\t\t\t\r\n\t\tReturns:\r\n\t\t\tdict{button1: [symbol1, symbol2, ...],\r\n\t\t\t\t button2: [symbol3, symbol4, ...]}\r\n\t\t\t\tMap button-to-symbol.\r\n\t\t\"\"\"   \r\n\t\t# return a dictionary of buttons and symbols\r\n\t\treturn {k:self._K[k]['symbol'] for k in self._K}\r\n\t\r\n\t#%% Get dictionary that translate a symbol to a button\r\n\tdef getSymbolToButtonDict(self):\r\n\t\t\"\"\"Get a dictionary storing button-to-symbol map.\r\n\t\t\r\n\t\tThis method returns a dictionary in form:\r\n\t\t\t{symbol1: button1,\r\n\t\t\t symbol2: button2,\r\n\t\t\t symbol3: button1, ...}\r\n\t\tNotice, multiple symbols are ound to the same button \r\n\t\t(e.g. button 'Z' has symbols 'z', 'Z' bound to it).\r\n\t\t\r\n\t\tArguments:\r\n\t\t\t\t\t\r\n\t\tRaises:\r\n\t\t\tUserWarning: Mapping is not unique.\r\n\t\t\t\t\r\n\t\tReturns:\r\n\t\t\tdict{symbol1: button1,\r\n\t\t\t\t symbol2: button2,\r\n\t\t\t\t symbol3: button1, ...}\r\n\t\t\t\tMap symbol-to-button.\r\n\t\t\"\"\"   \r\n\t\t# redo mapping\r\n\t\tself._M = {} \r\n\t\t# symbol to button mapping\r\n\t\t_doubleBind = self._updateSymbolToButtonMap()\r\n\t\tif(len(_doubleBind)>0):\r\n\t\t\twarnings.warn('Symbol-to-button map is not unique. The dictionary of {symbol:[button1, button2, ...]} is printed to console.', UserWarning, stacklevel=1)\r\n\t\t\tprint(_doubleBind)\r\n\t\treturn self._M\r\n\t\r\n\t#%% Set value of button(s)\r\n\tdef setButtonValue(self, button, labels, value): \r\n\t\t\"\"\"Change a value of a button.\r\n\t\t\r\n\t\tThis method enables to change the look of the layout when \r\n\t\tplotted or store additional information \r\n\t\t(allowed but not recommended).\r\n\t\t\r\n\t\tArguments:\r\n\t\t\tbutton: list()\r\n\t\t\t\tA list of valid button names (e.g. self.allButtons) \r\n\t\t\tlabels: list()\r\n\t\t\t\tA list (up to 4 items) to change properties of a button.\r\n\t\t\t\t\tE.g. ['graphics', 'x'], ['graphics', 'edgecolor'],\r\n\t\t\t\t\t\t ['graphics', 'facecolor'], ['graphics', 'dx'],\r\n\t\t\t\t\t\t ['graphics', 'alpha']\r\n\r\n\t\tRaises:\r\n\t\t\tUserWarning: If len(labels)>4.\r\n\t\t\t\t\r\n\t\tReturns:\r\n\t\t\"\"\"   \r\n\t\tfor b in button:\r\n\t\t\tif(len(labels)==1):\r\n\t\t\t\tself._K[b][labels[0]] = value\r\n\t\t\telif(len(labels)==2):\r\n\t\t\t\tself._K[b][labels[0]][labels[1]] = value\r\n\t\t\telif(len(labels)==3):\r\n\t\t\t\tself._K[b][labels[0]][labels[1]][labels[2]] = value\r\n\t\t\telif(len(labels)==4):\r\n\t\t\t\tself._K[b][labels[0]][labels[1]][labels[2]][labels[3]] = value\r\n\t\t\telse:  \r\n\t\t\t\twarnings.warn('Only 4 levels are currently implemented.', UserWarning, stacklevel=1)\r\n\t\r\n\t#%% Return value of button\r\n\tdef getButtonValue(self, button, labels):   \r\n\t\t\"\"\"Get a value of a button.\r\n\t\t\r\n\t\tGetter method that returns a value assigned to a button.\r\n\t\t\r\n\t\tArguments:\r\n\t\t\tbutton: \r\n\t\t\t\tA valid button name (see self.allButtons).\r\n\t\t\tlabels: list()\r\n\t\t\t\tA list (up to 4 items) to change properties of a button.\r\n\t\t\t\t\tE.g. ['graphics', 'x'], ['graphics', 'edgecolor'],\r\n\t\t\t\t\t\t ['graphics', 'facecolor'], ['graphics', 'dx'],\r\n\t\t\t\t\t\t ['graphics', 'alpha']\r\n\r\n\t\tRaises:\r\n\t\t\tUserWarning: If len(labels)>4.\r\n\t\t\t\t\r\n\t\tReturns:\r\n\t\t\t,,,\r\n\t\t\t\tReturns a value stored within a button structure.\r\n\t\t\"\"\"   \r\n\t\tif(len(labels)==1):\r\n\t\t\treturn self._K[button][labels[0]]\r\n\t\telif(len(labels)==2):\r\n\t\t\treturn self._K[button][labels[0]][labels[1]]\r\n\t\telif(len(labels)==3):\r\n\t\t\treturn self._K[button][labels[0]][labels[1]][labels[2]]\r\n\t\telif(len(labels)==4):\r\n\t\t\treturn self._K[button][labels[0]][labels[1]][labels[2]][labels[3]]\r\n\t\telse:\r\n\t\t\twarnings.warn('Only 4 levels are currently implemented.', UserWarning, stacklevel=1)\r\n\t\t\t\r\n\t#%% Plot layout in 3D\r\n\tdef plotKeyboard3D(self, axis, defaultLook=True, nameShow=True, bindShow=False, dzShow=True, textOffset=[0.0, 0.0, 0.0], aspectRatioModifier=[1.0, 1.0, 1.0], fontSize=10):\r\n\t\t\"\"\"Produce a 3D plot of the keyboard layout.\r\n\t\t\r\n\t\tArguments:\r\n\t\t\taxis: \r\n\t\t\t\tA subplot axis.\r\n\t\t\tdefaultLook: \r\n\t\t\t\tTrue: (default) Applies predefined settings to create \r\n\t\t\t\t\ta nice and easy to read plot\r\n\t\t\t\tFalse: plot bar-graph to the axis, do not apply \r\n\t\t\t\t\tany changes to the axis\r\n\t\t\tnameShow: \r\n\t\t\t\tTrue: (default) plot the button names\r\n\t\t\t\tFalse: button names are not plotted\r\n\t\t\tbindShow: \r\n\t\t\t\tTrue: plot bound symbols\r\n\t\t\t\tFalse: (default) do not plot bound symbols\r\n\t\t\tdzShow: \r\n\t\t\t\tTrue: (default) plot the value ['graphics', 'dz'], \r\n\t\t\t\t\tor in other words, the height of the button \r\n\t\t\t\t\tto better visualize the data\r\n\t\t\t\tFalse: value is not plotted\r\n\t\t\ttextOffset: list(, , )\r\n\t\t\t\t[0.0, 0.0, 0.0]: (default) offset to the plotted text \r\n\t\t\t\t\t(depends on nameShow, bindShow, dzShow)\r\n\t\t\taspectRatioModifier:\r\n\t\t\t\t[1.0, 1.0, 1.0]: aspect ration modification \r\n\t\t\tfontSize=: \r\n\t\t\t\t10: (default) font size of the text\r\n\t\t\t\t\r\n\t\tRaises:\r\n\t\t\t\t\r\n\t\tReturns:\r\n\t\t\tbars: list()\r\n\t\t\t\thandles to the bars representing the buttons\r\n\t\t\ttexts: list()\r\n\t\t\t\thandles to the plotted text \r\n\t\t\t\t\t(depends on nameShow, bindShow, dzShow)\r\n\t\t\"\"\"\t\t   \r\n\t\t# abstract the \"graphics\" values and \"names\" from the internal structure _K\r\n\t\txs, ys, zs\t= [self._K[k]['graphics']['x'] for k in self._K],  [self._K[k]['graphics']['y'] for k in self._K],  [self._K[k]['graphics']['z'] for k in self._K]\r\n\t\tdxs, dys, dzs = [self._K[k]['graphics']['dx'] for k in self._K], [self._K[k]['graphics']['dy'] for k in self._K], [self._K[k]['graphics']['dz'] for k in self._K]\r\n\t\tfacecolors, edgecolors, alphas = [self._K[k]['graphics']['facecolor'] for k in self._K], [self._K[k]['graphics']['edgecolor'] for k in self._K], [self._K[k]['graphics']['alpha'] for k in self._K]\r\n\t\tnames = [k for k in self._K]\r\n\t\tbinds = [self._K[k]['symbol'] for k in self._K]\r\n\t\t# handles to be returned\r\n\t\tbars = []\r\n\t\ttexts = []\r\n\t\t# plotting and texting\r\n\t\tfor x,y,z,dx,dy,dz,facecolor,edgecolor,alpha,name,bind in zip(xs,ys,zs,dxs,dys,dzs,facecolors,edgecolors,alphas,names,binds):\r\n\t\t\tbars.append( axis.bar3d(x, y, z, dx, dy, dz, alpha=alpha/2, edgecolor=edgecolor, color=facecolor) )\r\n\t\t\tif(nameShow):\r\n\t\t\t\tif(bindShow):\r\n\t\t\t\t\tbindingStr = \" \"\r\n\t\t\t\t\ttexts.append( axis.text(x+textOffset[0]+0.35 ,y+textOffset[1]+0.25,z+textOffset[2],name,\t   horizontalalignment='left', verticalalignment='bottom', rotation_mode='anchor', fontsize=fontSize, weight='bold' ) )\r\n\t\t\t\t\tbindingStr = bindingStr.join(bind)\r\n\t\t\t\t\ttexts.append( axis.text(x+textOffset[0]+0.75,y+textOffset[1]+0.25,z+textOffset[2],bindingStr, horizontalalignment='left', verticalalignment='bottom', rotation_mode='anchor', fontsize=fontSize ) )\r\n\t\t\t\telse:\r\n\t\t\t\t\ttexts.append( axis.text(x+textOffset[0]+0.35 ,y+textOffset[1]+0.25,z+textOffset[2],name,\t   horizontalalignment='left', verticalalignment='bottom', rotation_mode='anchor', fontsize=fontSize, weight='bold'  ) )\r\n\t\t\tif(dzShow):\r\n\t\t\t\ttexts.append( axis.text(x+textOffset[0]+0.75,y+textOffset[1]+0.25,z+textOffset[2],'{:.2f}'.format(dz), horizontalalignment='left', verticalalignment='bottom', rotation_mode='anchor', fontsize=fontSize ) )\r\n\t\t# apply default look\r\n\t\tif(defaultLook):\r\n\t\t\taxis.view_init(60, -30)\r\n\t\t\taxis.set_xlim([0,6])\r\n\t\t\tif(self._keyboardType=='external'):\r\n\t\t\t\taxis.set_ylim([0,17.75])\r\n\t\t\t\taxis.set_box_aspect([1*aspectRatioModifier[0],17.75/6*aspectRatioModifier[1],1*aspectRatioModifier[2]])\r\n\t\t\telse:\r\n\t\t\t\taxis.set_ylim([0,14.5])\r\n\t\t\t\taxis.set_box_aspect([1*aspectRatioModifier[0],14.5/6*aspectRatioModifier[1],1*aspectRatioModifier[2]])\r\n\t\t\taxis.grid(False)\r\n\t\t\taxis.set_xticks([])\r\n\t\t\taxis.set_yticks([])\r\n\t\t\taxis.set_zticks([])\r\n\t\t# return\r\n\t\treturn bars, texts\r\n\t\r\n\t#%% Plot layout in 2D\r\n\tdef plotKeyboard2D(self, axis, defaultLook=True, nameShow=True, bindShow=False, dzShow=True, textOffset=[0.0, 0.0, 0.0], fontSize=10):\r\n\t\t\"\"\"Produce a 2D plot of the keyboard layout.\r\n\t\t\r\n\t\tArguments:\r\n\t\t\taxis: \r\n\t\t\t\tA subplot axis.\r\n\t\t\tdefaultLook: \r\n\t\t\t\tTrue: (default) Applies predefined settings to create \r\n\t\t\t\t\ta nice and easy to read plot\r\n\t\t\t\tFalse: plot bar-graph to the axis, do not apply \r\n\t\t\t\t\tany changes to the axis\r\n\t\t\tnameShow: \r\n\t\t\t\tTrue: (default) plot the button names\r\n\t\t\t\tFalse: button names are not plotted\r\n\t\t\tbindShow: \r\n\t\t\t\tTrue: plot bound symbols\r\n\t\t\t\tFalse: (default) do not plot bound symbols\r\n\t\t\tdzShow: \r\n\t\t\t\tTrue: (default) plot the value ['graphics', 'dz']\r\n\t\t\t\tFalse: value is not plotted\r\n\t\t\ttextOffset: list(, , )\r\n\t\t\t\t[0.0, 0.0, 0.0]: (default) offset to the plotted text \r\n\t\t\t\t\t(depends on nameShow, bindShow, dzShow)\r\n\t\t\tfontSize=: \r\n\t\t\t\t10: (default) font size of the text\r\n\t\t\t\t\r\n\t\tRaises:\r\n\t\t\t\t\r\n\t\tReturns:\r\n\t\t\tbars: list()\r\n\t\t\t\thandles to the patches (Rectangles) representing the buttons\r\n\t\t\ttexts: list()\r\n\t\t\t\thandles to the plotted text \r\n\t\t\t\t\t(depends on nameShow, bindShow, dzShow)\r\n\t\t\"\"\"\t\t   \r\n\t\t# abstract the \"graphics\" values and \"names\" from the internal structure _K\r\n\t\txs, ys = [self._K[k]['graphics']['x'] for k in self._K],  [self._K[k]['graphics']['y'] for k in self._K]\r\n\t\tdxs, dys, dzs = [self._K[k]['graphics']['dx'] for k in self._K], [self._K[k]['graphics']['dy'] for k in self._K], [self._K[k]['graphics']['dz'] for k in self._K]\r\n\t\tfacecolors, edgecolors, alphas = [self._K[k]['graphics']['facecolor'] for k in self._K], [self._K[k]['graphics']['edgecolor'] for k in self._K], [self._K[k]['graphics']['alpha'] for k in self._K]\r\n\t\tnames = [k for k in self._K]\r\n\t\tbinds = [self._K[k]['symbol'] for k in self._K]\r\n\t\t# handles to be returned\r\n\t\tbars = []\r\n\t\ttexts = []\r\n\t\t# plotting and texting\r\n\t\tfor x,y,dx,dy,dz,facecolor,edgecolor,alpha,name,bind in zip(xs,ys,dxs,dys,dzs,facecolors,edgecolors,alphas,names,binds):\r\n\t\t\tbars.append( axis.add_patch( patches.Rectangle((y, x), dy, dx,linewidth=1, alpha=alpha, edgecolor=edgecolor, facecolor=facecolor) ) )\r\n\t\t\tif(nameShow):\r\n\t\t\t\tif(bindShow):\r\n\t\t\t\t\tbindingStr = \" \"\r\n\t\t\t\t\ttexts.append( axis.text(y+textOffset[1]+0.25,x+textOffset[0]+0.35,name,\t   horizontalalignment='left', verticalalignment='bottom', rotation_mode='anchor', fontsize=fontSize, weight='bold' ) )\r\n\t\t\t\t\tbindingStr = bindingStr.join(bind)\r\n\t\t\t\t\ttexts.append( axis.text(y+textOffset[1]+0.25,x+textOffset[0]+0.75,bindingStr, horizontalalignment='left', verticalalignment='bottom', rotation_mode='anchor', fontsize=fontSize, rotation=0 ) )\r\n\t\t\t\telse:\r\n\t\t\t\t\ttexts.append( axis.text(y+textOffset[1]+0.25,x+textOffset[0]+0.35,name,\t   horizontalalignment='left', verticalalignment='bottom', rotation_mode='anchor', fontsize=fontSize, weight='bold' ) )\r\n\t\t\tif(dzShow):\r\n\t\t\t\ttexts.append( axis.text(y+textOffset[1]+0.25, x+textOffset[0]+0.75, '{:.2f}'.format(dz), horizontalalignment='left', verticalalignment='bottom', rotation_mode='anchor', fontsize=fontSize ) )\r\n\t\t# apply default look\r\n\t\tif(defaultLook):\r\n\t\t\taxis.set_ylim([0,6])\r\n\t\t\tif(self._keyboardType=='external'):\r\n\t\t\t\taxis.set_xlim([0,17.75])\r\n\t\t\t\taxis.set_box_aspect(6/17.75)\r\n\t\t\telse:\r\n\t\t\t\taxis.set_xlim([0,14.5])\r\n\t\t\t\taxis.set_box_aspect(6/14.5)\r\n\t\t\taxis.grid(False)\r\n\t\t\taxis.set_xticks([])\r\n\t\t\taxis.set_yticks([])\r\n\t\t\t# reverse the Y-axis\r\n\t\t\taxis.invert_yaxis()\r\n\t\t# return\r\n\t\treturn bars, texts\r\n\t\r\n\t#%% Plot layout in 2D\r\n\tdef plotButtonRelations(self, axis, relations):\r\n\t\t\"\"\"Produce a 2D plot of the keyboard layout.\r\n\t\t\r\n\t\tArguments:\r\n\t\t\taxis: \r\n\t\t\t\tA subplot axis.\r\n\t\t\tgroups: )>)>\r\n\t\t\t\tA list of lists, where every list includes strings, \r\n\t\t\t\treferencing button names.\r\n\t\t\trelations: )>\r\n\t\t\t\tA dictionary where the key is a tupple of button names\r\n\t\t\t\t(button1, button2) and the float is the value of \r\n\t\t\t\trelation.\r\n\t\t\tdefaultLook: \r\n\t\t\t\tTrue: (default) Applies predefined settings to create \r\n\t\t\t\t\ta nice and easy to read plot\r\n\t\t\t\tFalse: plot bar-graph to the axis, do not apply \r\n\t\t\t\t\tany changes to the axis\r\n\t\t\tfacecolor:  or )>\r\n\t\t\t\t'blue': (default) inital value of button color\r\n\t\t\t\t\r\n\t\tRaises:\r\n\t\t\t\t\r\n\t\tReturns:\r\n\t\t\tbars: list()\r\n\t\t\t\thandles to the patches (Rectangles) representing the buttons\r\n\t\t\ttexts: list()\r\n\t\t\t\thandles to the plotted text \r\n\t\t\t\t\t(depends on nameShow, bindShow, dzShow)\r\n\t\t\"\"\"\t\t   \r\n\t\tfor key, value in relations.items():\r\n\t\t\tbuttonA = key[0]\r\n\t\t\tbuttonB = key[1]\r\n\t\t\tif(not np.isnan(value[0])):\r\n\t\t\t\t# get the coordinates\r\n\t\t\t\txA, yA = self._K[buttonA]['graphics']['x'] + (self._K[buttonA]['graphics']['dx']/2), self._K[buttonA]['graphics']['y'] + (self._K[buttonA]['graphics']['dy']/2)\r\n\t\t\t\txB, yB = self._K[buttonB]['graphics']['x'] + (self._K[buttonB]['graphics']['dx']/2), self._K[buttonB]['graphics']['y'] + (self._K[buttonB]['graphics']['dy']/2)\r\n\t\t\t\t# coordinates depend on axis type (2D / 3D)\r\n\t\t\t\tif  axis.name == \"3d\":\r\n\t\t\t\t\twarnings.warn('layout.plotButtonRelations(...) is currently not implemented for 3D plots.', UserWarning, stacklevel=1)\r\n\t\t\t\t\treturn\r\n\t\t\t\telse:\r\n\t\t\t\t\taxis.arrow(yA, xA, yB-yA, xB-xA,  width=value[0], facecolor=value[1], head_width=value[0]*3, shape='full', length_includes_head=True, alpha=0.25)\r\n\t\t\t\t\t\r\n", "description": "A class to represent keyboard layout.\r\n\r\n\tLayout class has 2 major functions. At first is holds an information\r\n\tabout the keyboard layout (position of buttons on keyboard). \r\n\tSecondly, it provides mapping from symbols (e.g. ['z', 'Z'] maps \r\n\tto button 'Z', ['~','`'] maps to button 'Tilde'). This mapping needs\r\n\tto be unique in order to be reversible. The one-to-many \r\n\t(further refered as button-to-symbol mapping is stored in \r\n\tdictionary _K[]['symbol']). The one-to-one mapping \r\n\t(further refered to as symbol-to-button is obtained by reversing \r\n\tthe mapping _K and is stored in dictionary _M[symbol]).\r\n\r\n\tAttributes:\r\n\t\tself.allButtons\r\n\t\tself.alphabetButtons\r\n\t\tself.numericButtons\r\n\t\tself.punctuationButtons\r\n\t\tself.functionalButtons \r\n\t\tself.extendedButtons\r\n\t\tself.finger1Buttons\r\n\t\tself.finger2Buttons\r\n\t\tself.finger3Buttons\r\n\t\tself.finger4Buttons\r\n\t\tself.finger7Buttons\r\n\t\tself.finger8Buttons\r\n\t\tself.finger9Buttons\r\n\t\tself.finger10Buttons\r\n\t\tself.leftHandButtons\r\n\t\tself.rightHandButtons\t \r\n\t\t\tPredefined lists of buttons list() to provide \r\n\t\t\t\tsimple way to partition the keyboard layout.\r\n\r\n\tMethods:\r\n\t\tlayout(keyboardType='external', qwerty=True, shift_l_long=True, enter_tall=True, language='englishUS', alpha=0.1, facecolor='blue', edgecolor='black')\r\n\t\tbindSymbolToButton(symbol, button)\r\n\t\tunbindSymbolFromButton(symbol, button)\r\n\t\tcreateButton(button, x, y, symbols, dx, dy, z = 0.0, dz=1.0, edgecolor='black',facecolor='blue', alpha=0.1)\r\n\t\tdeleteButton(button)\r\n\t\tsymbol2button(symbol)\r\n\t\tgetButtonList()\r\n\t\tgetSymbolList()\r\n\t\tgetButtonToSymbolDict()\r\n\t\tgetSymbolToButtonDict()\r\n\t\tsetButtonValue(button, labels, value)\r\n\t\tgetButtonValue(button, labels)\r\n\t\tplotKeyboard3D(axis, defaultLook=True, nameShow=True, bindShow=False, dzShow=True, textOffset=[0.0, 0.0, 0.0], aspectRatioModifier=[1.0, 1.0, 1.0], fontSize=10)\r\n\t\tplotKeyboard2D(axis, defaultLook=True, nameShow=True, bindShow=False, dzShow=True, textOffset=[0.0, 0.0, 0.0], fontSize=10)\t\t\r\n\t", "category": "graphics", "imports": ["import matplotlib.patches as patches\r", "from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 unused import\r", "from pandas.core.common import flatten\r", "import warnings\r", "import numpy as np\r"]}], [{"term": "class", "name": "TopLevelWrapperGraphics", "data": "class TopLevelWrapperGraphics(QGraphicsRectItem):\n\t\"\"\"\n\tA wrapper for the top-level graphics item and the scrollable extra items.\n\t\"\"\"\n\t\n\tBUFFER = 1\n\tBUTTON_WIDTH = 60\n\tBACKGROUND_COLOR = QColor(120, 120, 120, 120)\n\tRESIZE_AREA_WIDTH = 8\n\t# Scrollable Item\n\tSGI_MIN_WIDTH = 500\n\tSGI_MIN_ASSGND_WIDTH = 1000\n\tSGI_MAX_ASSGND_WIDTH = 2000\n\n\tclass Button(QGraphicsRectItem):\n\t\t\"\"\"\n\t\tExpand/Collapse button to show/hide the scrollable extras\n\n\t\tThis class is only to be used within the TopLevelWrapperGraphics class\n\t\t\"\"\"\n\t\tARROW_COLOR = QColor(30, 30, 30)\n\t\tBACKGROUND_COLOR = QColor(56, 56, 56)\n\t\tBUTTON_IMG_THM = 0  # 0 is dark, 1 is light\n\n\t\tdef __init__(self, *args, left=True, onClicked=None, resizer=False):\n\t\t\tQGraphicsRectItem.__init__(self,*args)\n\t\t\tself._left = left\n\t\t\tself._onClicked = onClicked\n\t\t\tself._resizer = resizer\n\t\t\tself.setBrush(TopLevelWrapperGraphics.Button.BACKGROUND_COLOR)\n\t\t\tself.setAcceptHoverEvents(True)\n\t\t\tif not resizer:\n\t\t\t\tself.setCursor(QCursor(Qt.PointingHandCursor))\n\t\t\telse:\n\t\t\t\tself.setCursor(QCursor(Qt.SizeHorCursor))\n\n\t\tdef paint(self, painter: QPainter, option: QStyleOptionGraphicsItem, widget: QWidget):\n\n\t\t\tif not self._resizer:\n\t\t\t\tif self._left:\n\t\t\t\t\tif TopLevelWrapperGraphics.Button.BUTTON_IMG_THM == 0:\n\t\t\t\t\t\tfilename = 'button_col_dark.jpg'\n\t\t\t\t\telse:\n\t\t\t\t\t\tfilename = 'button_col_light.jpg'\n\t\t\t\telse:  # if right\n\t\t\t\t\tif TopLevelWrapperGraphics.Button.BUTTON_IMG_THM == 0:\n\t\t\t\t\t\tfilename = 'button_exp_dark.jpg'\n\t\t\t\t\telse:\n\t\t\t\t\t\tfilename = 'button_exp_light.jpg'\n\n\t\t\t\tir = QImageReader()\n\t\t\t\tfilename = \":/icon/resources/EC_Buttons/\" + filename\n\t\t\t\tir.setFileName(filename)\n\n\t\t\t\tpainter.drawImage(self.boundingRect(), ir.read())\n\t\t\telse:\n\t\t\t\tpainter.setPen(Qt.transparent)\n\t\t\t\tpainter.setBrush(QColor(0, 0, 200))\n\t\t\t\tpainter.drawRoundedRect(self.boundingRect(), 5, 5)\n\n\t\tdef mousePressEvent(self, event):\n\t\t\t\"\"\"\n\t\t\tOverloads the default mouse press event. Implemented to enable manual resizing.\n\n\t\t\t:param event: The mouse event\n\t\t\t:type event: QtWidgets.QGraphicsSceneMouseEvent\n\t\t\t\"\"\"\n\t\t\tif not self._resizer:\n\t\t\t\tevent.accept()\n\t\t\t\tself._onClicked()\n\t\t\telse:\n\t\t\t\ttlw: TopLevelWrapperGraphics = self.parentItem()\n\t\t\t\tif tlw._scrollableItem:\n\t\t\t\t\ttlw.mouseDragStartPos = event.pos()\n\t\t\t\t\ttlw.prevWidth = tlw._width\n\t\t\t\t# QGraphicsRectItem.mousePressEvent(self, event)\n\n\t\tdef mouseMoveEvent(self, event):\n\t\t\t\"\"\"\n\t\t\tOverloads the default mouse move event. Implemented to enable manual resizing.\n\n\t\t\t:param event: The mouse event\n\t\t\t:type event: QtWidgets.QGraphicsSceneMouseEvent\n\t\t\t\"\"\"\n\t\t\tif self._resizer:\n\t\t\t\ttlw: TopLevelWrapperGraphics = self.parentItem()\n\t\t\t\tif tlw._scrollableItem:\n\t\t\t\t\tif event.button() in (Qt.LeftButton, Qt.NoButton) and not tlw.mouseDragging:\n\t\t\t\t\t\ttlw.mouseDragging = True\n\n\t\t\t\t\tif tlw.mouseDragging:\n\t\t\t\t\t\ttlw.mouseDragEndPos = event.pos()\n\n\t\t\t\t\t\t# Calculate the difference in position\n\t\t\t\t\t\tdiff = tlw.mouseDragEndPos.x() - tlw.mouseDragStartPos.x()\n\n\t\t\t\t\t\t# Calculate the new sgi width\n\t\t\t\t\t\tsgi = tlw._scrollableItem\n\t\t\t\t\t\tsgiRect = sgi.rect()\n\t\t\t\t\t\tnewSGIWidth = sgiRect.width() + diff\n\t\t\t\t\t\tif newSGIWidth >= TopLevelWrapperGraphics.SGI_MIN_WIDTH:\n\t\t\t\t\t\t\t# Move Ghost container logically\n\t\t\t\t\t\t\tcanGoLeft = sgi.ghostCanGoLeft()\n\t\t\t\t\t\t\tcanGoRight = sgi.ghostCanGoRight()\n\t\t\t\t\t\t\tcurMaxX = tlw.scenePos().x() + tlw.rect().width() - self.rect().width() - \\\n\t\t\t\t\t\t\t\tTopLevelWrapperGraphics.BUTTON_WIDTH - TopLevelWrapperGraphics.BUFFER\n\n\t\t\t\t\t\t\tif diff > 0:  # Expanding self\n\t\t\t\t\t\t\t\t# We should move the ghost container with the expansion\n\t\t\t\t\t\t\t\tif canGoRight and not canGoLeft and sgi.getGhost().scenePos().x() < sgi.scenePos().x():\n\t\t\t\t\t\t\t\t\tsgi.getGhost().moveBy(diff, 0)\n\n\t\t\t\t\t\t\t\t# Prevent the expansion from going far past last item\n\t\t\t\t\t\t\t\telif curMaxX >= sgi.getMaxX():\n\t\t\t\t\t\t\t\t\treturn\n\n\t\t\t\t\t\t\t\t# Otherwise keep the container on the left\n\t\t\t\t\t\t\t\telif not canGoRight:\n\t\t\t\t\t\t\t\t\tsgi.getGhost().setPos(sgi.scenePos().x(), sgi.scenePos().y())\n\n\t\t\t\t\t\t\t# Resize SGI\n\t\t\t\t\t\t\tsgiRect.setWidth(newSGIWidth)\n\t\t\t\t\t\t\ttlw._scrollableItem.setRect(sgiRect)\n\n\t\t\t\t\t\t\t# Move collapse button and resizer (self)\n\t\t\t\t\t\t\ttlw._collapseButton.moveBy(diff, 0)\n\t\t\t\t\t\t\tself.moveBy(diff, 0)\n\n\t\t\t\t\t\t\t# Resize TLWGI\n\t\t\t\t\t\t\ttlwRect = tlw.rect()\n\t\t\t\t\t\t\ttlwRect.setWidth(tlwRect.width() + diff)\n\t\t\t\t\t\t\ttlw.setRect(tlwRect)\n\n\t\t\t\t\t\ttlw.prepareGeometryChange()\n\t\t\t\t\t\ttlw.update()\n\t\t\t\t\telse:\n\t\t\t\t\t\t# Allows the user to still move the scene w click & drag\n\t\t\t\t\t\tQGraphicsRectItem.mouseMoveEvent(self, event)\n\t\t\t\t\t\treturn\n\t\t\t\telse:\n\t\t\t\t\tQGraphicsRectItem.mouseMoveEvent(self, event)\n\t\t\telse:\n\t\t\t\tQGraphicsRectItem.mouseMoveEvent(self, event)\n\n\t\tdef mouseReleaseEvent(self, event):\n\t\t\t\"\"\"\n\t\t\tOverloads the default mouse release event. Implemented to enable manual resizing.\n\n\t\t\t:param event: The mouse event\n\t\t\t:type event: QtWidgets.QGraphicsSceneMouseEvent\n\t\t\t\"\"\"\n\t\t\tif self._resizer:\n\t\t\t\ttlw: TopLevelWrapperGraphics = self.parentItem()\n\t\t\t\tif tlw.mouseDragging:\n\t\t\t\t\ttlw.prepareGeometryChange()\n\t\t\t\t\ttlw._width = tlw.rect().width()\n\t\t\t\t\ttlw.mouseDragging = False\n\t\t\t\t\ttlw.update()\n\t\t\tQGraphicsRectItem.mouseReleaseEvent(self, event)\n\n\tdef __init__(self, topLevelGraphics=None):\n\t\tQGraphicsRectItem.__init__(self)\n\t\tself.setBrush(TopLevelWrapperGraphics.BACKGROUND_COLOR)\n\t\tself.setFlag(QGraphicsRectItem.ItemClipsChildrenToShape)\n\t\tself.setAcceptDrops(True)\n\t\t\n\t\t# Set the window\n\t\tself._topLevelGraphics = topLevelGraphics\n\t\tb = TopLevelWrapperGraphics.BUFFER\n\t\t\n\t\t# Get its size and position\n\t\tself._x = self._topLevelGraphics.x() - b\n\t\tself._yG = self._topLevelGraphics.y()\n\t\tself._width = self._topLevelGraphics.boundingRect().width()\n\t\tself._heightG = self._topLevelGraphics.boundingRect().height()\n\t\t\n\t\t# Add it to self and set its position to (0,0)\n\t\tself._topLevelGraphics.setParentItem(self)\n\t\t# self._topLevelGraphics.setPos(0, 0)\n\t\t\n\t\t# Set the unused parts to None for the moment.\n\t\tself._scrollableItem = None\n\t\tself._collapseButton = None\n\t\tself._expandButton = None\n\t\tself._resizer = None\n\n\t\t# Set size and position to the top-level graphics's position and size\n\t\tself.setRect(self._x, self._yG - b, self._width + b*2, self._heightG + b*2)\n\n\t\t# All things related to resizing\n\t\tself.mouseDragStartPos = None\n\t\tself.mouseDragEndPos = None\n\t\tself.mouseDragging = False\n\t\tself.prevWidth = self.rect().width()\n\n\tdef getWindowGraphics(self):\n\t\t\"\"\"\n\t\tGets the top-level component that is stored in this item.\n\t\t\n\t\t:return: Top-level window component being stored in this wrapper\n\t\t:rtype: ComponentGraphics\n\t\t\"\"\"\n\t\t\n\t\treturn self._topLevelGraphics\n\n\tdef addECSection(self, ecs: 'ScrollableGraphicsItem'):\n\t\t\"\"\"\n\t\tAdds the extra components section to this item, setting up the buttons with it.\n\t\t\n\t\t:param ecs: extra components section to add\n\t\t:type ecs: ScrollableGraphicsItem\n\t\t:return: None\n\t\t\"\"\"\n\n\t\tecs.setParentItem(self)\n\t\tself._scrollableItem = ecs\n\t\tecs.prepareGeometryChange()\n\n\t\t# Define some variables\n\t\tb = TopLevelWrapperGraphics.BUFFER\n\t\tbWidth = TopLevelWrapperGraphics.BUTTON_WIDTH\n\t\t\n\t\t# Set the section's position and size. It'll be the exact same size (width) as the window.\n\t\twin = self._topLevelGraphics\n\t\tecsWidth = min(TopLevelWrapperGraphics.SGI_MAX_ASSGND_WIDTH, max(TopLevelWrapperGraphics.SGI_MIN_ASSGND_WIDTH,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t win.width()))\n\t\tecs.setRect(win.scenePos().x() + win.width() + b, self._yG, ecsWidth, self._heightG)\n\n\t\t# Instantiate the Expand Button\n\t\ttlg = self._topLevelGraphics\n\t\tself._expandButton = TopLevelWrapperGraphics.Button(self, left=False, onClicked=self.onExpandClicked)\n\t\tself._expandButton.setRect(tlg.scenePos().x() + tlg.width() + b, self._yG, bWidth-4, self._heightG)\n\t\tself._expandButton.hide()\n\t\t\n\t\t# Instantiate the Collapse Button\n\t\tsig = self._scrollableItem\n\t\tself._collapseButton = TopLevelWrapperGraphics.Button(self, left=True, onClicked=self.onCollapseClicked)\n\t\tself._collapseButton.setRect(tlg.scenePos().x() + tlg.width() + ecsWidth + b, self._yG, bWidth-4,\n\t\t\t\t\t\t\t\t\t self._heightG)\n\n\t\t# Instantiate the resizing button\n\t\tresizeWidth = TopLevelWrapperGraphics.RESIZE_AREA_WIDTH\n\t\tself._resizer = TopLevelWrapperGraphics.Button(self, resizer=True)\n\t\tself._resizer.setRect(tlg.scenePos().x() + tlg.width() + ecsWidth + bWidth-b,\n\t\t\t\t\t\t\t\t\t self._yG, resizeWidth, self._heightG)\n\n\t\t# Adjust the size once we know how big things are\n\t\tcbbr = self._collapseButton.boundingRect()\n\t\tself._width = tlg.width() + sig.boundingRect().width() + cbbr.width() + b*4 + resizeWidth\n\t\tself.setRect(self._x, self._yG - b, self._width, self._heightG + b*2)\n\t\n\tdef onCollapseClicked(self):\n\t\t\"\"\"\n\t\tCollapses the extra component section\n\t\t\n\t\t:return: None\n\t\t\"\"\"\n\t\tself._scrollableItem.hide()\n\t\tself._collapseButton.hide()\n\t\tself._resizer.hide()\n\t\tself._expandButton.show()\n\t\tself._width = self._topLevelGraphics.width() + \\\n\t\t\t\tTopLevelWrapperGraphics.BUTTON_WIDTH\n\t\tself.setRect(self._x, self._yG - TopLevelWrapperGraphics.BUFFER,\n\t\t\t\t\t self._width, self._heightG + TopLevelWrapperGraphics.BUFFER*2)\n\t\t# self.boundingRect().setWidth(width)\n\n\tdef onExpandClicked(self):\n\t\t\"\"\"\n\t\tExpands the extra component section\n\t\t\n\t\t:return: None\n\t\t\"\"\"\n\t\tself._scrollableItem.show()\n\t\tself._collapseButton.show()\n\t\tself._expandButton.hide()\n\t\tself._resizer.show()\n\t\tself._width = self._topLevelGraphics.width() + \\\n\t\t\t\tself._scrollableItem.boundingRect().width() + \\\n\t\t\t\tTopLevelWrapperGraphics.BUTTON_WIDTH + \\\n\t\t\t\tTopLevelWrapperGraphics.RESIZE_AREA_WIDTH + \\\n\t\t\t\tTopLevelWrapperGraphics.BUFFER * 3\n\t\tself.setRect(self._x, self._yG - TopLevelWrapperGraphics.BUFFER,\n\t\t\t\t\t self._width, self._heightG + TopLevelWrapperGraphics.BUFFER*2)\n\n\tdef getLabel(self) -> str:\n\t\t\"\"\"\n\t\tGets the label from this TLW graphics item.\n\t\t\n\t\t:return: The label for this component.\n\t\t:rtype: str\n\t\t\"\"\"\n\t\n\t\treturn \"Wrapper for \" + self._topLevelGraphics.getLabel()\n\n\tdef paint(self, painter, option, widget):\n\t\t\"\"\"\n\t\tPaints the contents of the component. Override the parent paint function\n\n\t\t:param painter: Use a Qpainter object.\n\t\t:type painter: QPainter\n\t\t:param option: It provides style options for the item.\n\t\t:type option: QStyleOptionGraphicsItem\n\t\t:param widget: QWidget\n\t\t:type widget: It points to the widget that is being painted on; or make it = None.\n\t\t:return: None\n\t\t:rtype: NoneType\n\t\t\"\"\"\n\t\n\t\tboundingRect = self.boundingRect()\n\t\tpainter.setBrush(TopLevelWrapperGraphics.BACKGROUND_COLOR)\n\t\tpainter.drawRoundedRect(boundingRect, 5, 5)\n", "description": "\n\tA wrapper for the top-level graphics item and the scrollable extra items.\n\t", "category": "graphics", "imports": ["import os", "from PySide2.QtWidgets import QApplication, QGraphicsView, QGraphicsScene, QGraphicsRectItem, \\", "from PySide2.QtGui import QColor, QPainter, QPen, QImageReader, QCursor", "from PySide2.QtCore import Qt", "from graphics.tguim.scrollablegraphicsitem import ScrollableGraphicsItem"]}], [], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, **kargs):\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [{"term": "class", "name": "classAnimationPlayer:", "data": "class AnimationPlayer:\n\tdef __init__(self):\n\t\tself.frames = {\n\t\t\t# magic\n\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\n\t\t\t'aura': import_folder('../graphics/particles/aura'),\n\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\n\t\t\t\n\t\t\t# attacks \n\t\t\t'claw': import_folder('../graphics/particles/claw'),\n\t\t\t'slash': import_folder('../graphics/particles/slash'),\n\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\n\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\n\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\n\n\t\t\t# monster deaths\n\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\n\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\n\t\t\t'spirit': import_folder('../graphics/particles/nova'),\n\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\n\t\t\t\n\t\t\t# leafs \n\t\t\t'leaf': (\n\t\t\t\timport_folder('../graphics/particles/leaf1'),\n\t\t\t\timport_folder('../graphics/particles/leaf2'),\n\t\t\t\timport_folder('../graphics/particles/leaf3'),\n\t\t\t\timport_folder('../graphics/particles/leaf4'),\n\t\t\t\timport_folder('../graphics/particles/leaf5'),\n\t\t\t\timport_folder('../graphics/particles/leaf6'),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\n\t\t\t\t)\n\t\t\t}\n\n\t\n\tdef reflect_images(self, frames):\n\t\tnew_frames = []\n\t\tfor frame in frames:\n\t\t\tflipped_frame = pygame.transform.flip(frame, True, False)\n\t\t\tnew_frames.append(flipped_frame)\n\t\treturn new_frames\n\n\n\tdef create_grass_particles(self, pos, groups):\n\t\tanimation_frames = choice(self.frames['leaf'])\n\t\tParticleEffect(pos, animation_frames, groups)\n\n\n\tdef create_particles(self, animation_type, pos, groups):\n\t\tanimation_frames = self.frames[animation_type]\n\t\tParticleEffect(pos, animation_frames, groups)\n\n\n", "description": null, "category": "graphics", "imports": ["from matplotlib import animation", "import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\n\tdef __init__(self, pos, animation_frames, groups):\n\t\tsuper().__init__(groups)\n\t\tself.sprite_type = 'magic'\n\t\tself.frame_index = 0\n\t\tself.animation_speed = 0.15\n\t\tself.frames = animation_frames\n\t\tself.image = self.frames[self.frame_index]\n\t\tself.rect = self.image.get_rect(center=pos)\n\n\n\tdef animate(self):\n\t\tself.frame_index += self.animation_speed\n\t\tif self.frame_index >= len(self.frames):\n\t\t\tself.kill()\n\t\telse:\n\t\t\tself.image = self.frames[int(self.frame_index)]\n\t\n\n\tdef update(self):\n\t\tself.animate()\n\n", "description": null, "category": "graphics", "imports": ["from matplotlib import animation", "import pygame", "from support import import_folder", "from random import choice", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),", "\t\t\t'aura': import_folder('../graphics/particles/aura'),", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),", "\t\t\t'claw': import_folder('../graphics/particles/claw'),", "\t\t\t'slash': import_folder('../graphics/particles/slash'),", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),", "\t\t\t\timport_folder('../graphics/particles/leaf1'),", "\t\t\t\timport_folder('../graphics/particles/leaf2'),", "\t\t\t\timport_folder('../graphics/particles/leaf3'),", "\t\t\t\timport_folder('../graphics/particles/leaf4'),", "\t\t\t\timport_folder('../graphics/particles/leaf5'),", "\t\t\t\timport_folder('../graphics/particles/leaf6'),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))"]}], [], [], [], [{"term": "class", "name": "CGAffineTransform", "data": "class CGAffineTransform(Structure):\n\t_fields_ = [\n\t\t(\"a\", CGFloat),\n\t\t(\"b\", CGFloat),\n\t\t(\"c\", CGFloat),\n\t\t(\"d\", CGFloat),\n\t\t(\"tx\", CGFloat),\n\t\t(\"ty\", CGFloat),\n\t]\n\n", "description": null, "category": "graphics", "imports": ["from ctypes import (", "from rubicon.objc import CGFloat, CGRect", "from rubicon.objc.types import register_preferred_encoding", "from rubicon.objc.runtime import load_library"]}, {"term": "class", "name": "CGEventRef", "data": "class CGEventRef(c_void_p):\n\tpass\n\n", "description": null, "category": "graphics", "imports": ["from ctypes import (", "from rubicon.objc import CGFloat, CGRect", "from rubicon.objc.types import register_preferred_encoding", "from rubicon.objc.runtime import load_library"]}], [{"term": "class", "name": "UserReportAdmin", "data": "class UserReportAdmin(admin.ModelAdmin):\n\n\treadonly_fields = ['uploader', 'user_id_hash', 'upload_date', 'generation_date', 'data_type', 'data_version', 'data']\n\tfieldsets = [\n\t\t('User', {'fields': ['uploader', 'user_id_hash']}),\n\t\t('Dates', {'fields': ['upload_date', 'generation_date']}),\n\t\t(None, {'fields': ['data_type', 'data_version', 'data']}),\n\t]\n\tlist_display = ('uploader', 'user_id_hash', 'data_type', 'data_version', 'upload_date', 'generation_date')\n\tlist_filter = ['upload_date', 'generation_date', 'data_type']\n\tsearch_fields = ['=uploader', '=user_id_hash', 'data']\n\tdate_hierarchy = 'upload_date'\n", "description": null, "category": "graphics", "imports": ["from userreport.models import UserReport, GraphicsDevice, GraphicsExtension, GraphicsLimit", "from django.contrib import admin"]}, {"term": "class", "name": "GraphicsDeviceAdmin", "data": "class GraphicsDeviceAdmin(admin.ModelAdmin):\n\tpass\n", "description": null, "category": "graphics", "imports": ["from userreport.models import UserReport, GraphicsDevice, GraphicsExtension, GraphicsLimit", "from django.contrib import admin"]}, {"term": "class", "name": "GraphicsExtensionAdmin", "data": "class GraphicsExtensionAdmin(admin.ModelAdmin):\n\tpass\n", "description": null, "category": "graphics", "imports": ["from userreport.models import UserReport, GraphicsDevice, GraphicsExtension, GraphicsLimit", "from django.contrib import admin"]}, {"term": "class", "name": "GraphicsLimitAdmin", "data": "class GraphicsLimitAdmin(admin.ModelAdmin):\n\tpass\n", "description": null, "category": "graphics", "imports": ["from userreport.models import UserReport, GraphicsDevice, GraphicsExtension, GraphicsLimit", "from django.contrib import admin"]}], [{"term": "class", "name": "Display", "data": "class Display(object):\n\t\n\tWHITE = graphicsUtils.formatColor(1.0, 1.0, 1.0)\n\tRED = graphicsUtils.formatColor(1.0, 0.0, 0.0)\n\tGREEN = graphicsUtils.formatColor(0.16, 0.49, 0.31)\n\tBLUE = graphicsUtils.formatColor(0.0, 0.0, 1.0)\n\tBLACK = graphicsUtils.formatColor(0.0, 0.0, 0.0)\n\tGREY = graphicsUtils.formatColor(0.5, .5, 0.5)\n\t\n\tVISIBLE_CUTTOFF = 0.001\n\t\n\t\n\tpartDict = {}\n\tbeliefParts = []\n\tbeliefValue = []\n\tbeliefColor = []\n\tobservations = []\n\t\n\tgraphicsLock = threading.Lock()\n\t\n\tCOLORS = [\n\t\t'purple',\n\t\t'green',\n\t\t'teal',\n\t\t'red',\n\t\t'orange',\n\t\t'yellow'\n\t]\n\tCOLOR_HUES = {\n\t\t'purple' : 0.8,\n\t\t'green' : 0.3,\n\t\t'teal' : 0.49,\n\t\t'red' : 0.0,\n\t\t'orange' : 0.125,\n\t\t'yellow' : 0.21\n\t}\n\t\n\t@staticmethod\n\tdef initGraphics(layout):\n\t\tgraphicsUtils.begin_graphics(\n\t\t\twidth=layout.getWidth(), \n\t\t\theight=layout.getHeight(), \n\t\t\tcolor = Display.WHITE,\n\t\t\ttitle = Const.TITLE\n\t\t);\n\t\t\n\t@staticmethod\n\tdef endGraphics():\n\t\tgraphicsUtils.end_graphics()\n\n\t@staticmethod\n\tdef raiseEndGraphics():\n\t\tgraphicsUtils.raiseEndGraphics()\n\t\n\t@staticmethod\n\tdef drawCar(car):\n\t\tif car in Display.partDict:\n\t\t\tDisplay._remove(car)\n\t\tcolor = Display.GREY\n\t\tif car.isJunior():\n\t\t\tcolor = Display.BLACK\n\t\tparts = graphicsUtils.rectangle(\n\t\t\tcar.pos, Car.LENGTH, \n\t\t\tCar.WIDTH, \n\t\t\tcolor, \n\t\t\tcar.dir\n\t\t)\n\t\tDisplay.partDict[car] = parts\n\t\t\n\t@staticmethod\n\tdef drawObservation(obs):\n\t\tparts = Display.drawCircle(obs.pos, Observation.RADIUS)\n\t\tDisplay.partDict[obs] = parts\n\t\n\t@staticmethod\n\tdef drawSquare(pos, size, color):\n\t\treturn graphicsUtils.square(pos, size, color)\n\t\n\t@staticmethod\n\tdef drawFinish(block):\n\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.GREEN, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\n\t@staticmethod\n\tdef drawBlocks(blocks):\n\t\tfor block in blocks:\n\t\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.BLUE, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\t\n\t@staticmethod\n\tdef drawCircle(pos, radius):\n\t\treturn graphicsUtils.circle(pos, radius, Display.RED, Display.RED)\n\t\n\t@staticmethod\n\tdef drawBelief(model):\n\t\tDisplay.beliefVisible = []\n\t\tfor r in range(model.getBeliefRows()):\n\t\t\tbeliefValueRow = []\n\t\t\tbeliefPartRow = []\n\t\t\tbeliefColorRow = []\n\t\t\tfor c in range(model.getBeliefCols()):\n\t\t\t\tsquare = Display.drawBeliefSquare(r, c, 'purple', 0.0, model)\n\t\t\t\tbeliefPartRow.append(square)\n\t\t\t\tbeliefValueRow.append(0.0)\n\t\t\t\tbeliefColorRow.append(None)\n\t\t\tDisplay.beliefParts.append(beliefPartRow)\n\t\t\tDisplay.beliefValue.append(beliefValueRow)\n\t\t\tDisplay.beliefColor.append(beliefColorRow)\n\t\t\t\t\n\t@staticmethod\n\tdef drawBeliefSquare(row, col, color, value, model):\n\t\ttileSize = Const.BELIEF_TILE_SIZE\n\t\tx = col * tileSize + tileSize / 2.0\n\t\ty = row * tileSize + tileSize / 2.0\n\t\tif not model.inBounds(x, y): return None\n\t\tcolor = Display._getBeliefSquareColor(color, value)\n\t\treturn Display.drawSquare(Vec2d(x, y), tileSize, color)\n\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef getKeys():\n\t\t#print 'attempt get keys'\n\t\tDisplay._acquireLock()\n\t\t#print 'get keys'\n\t\tkeys = graphicsUtils.keys_waiting() + graphicsUtils.keys_pressed()\n\t\tDisplay._releaseLock()\n\t\treturn keys\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef graphicsSleep(timeToSleep):\n\t\tgraphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''for _ in range(int(timeToSleep / 0.005)):\n\t\t\t#print 'attempt sleep'\n\t\t\tDisplay._acquireLock()\n\t\t\t#print 'sleep'\n\t\t\tgraphicsUtils.sleep(0.001)\n\t\t\tDisplay._releaseLock()\n\t\t\ttime.sleep(0.004)'''\n\t\t\n\t\t#graphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''startWait = time.time()\n\t\tDisplay._acquireLock()\n\t\ttimeToSleep -= time.time() - startWait\n\t\tgraphicsUtils.refresh()\n\t\tif timeToSleep > 0:\n\t\t\tgraphicsUtils.sleep(timeToSleep)\n\t\tDisplay._releaseLock()'''\n\t\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef updateBelief(color, belief):\n\t\tDisplay._acquireLock()\n\t\ttotal = belief.getSum()\n\t\tif abs(total - 1.0) > 0.001:\n\t\t\traise Exception('belief does not sum to 1 ('+str(total)+'). Use the normalize method.')\n\t\tfor r in range(belief.getNumRows()):\n\t\t\tfor c in range(belief.getNumCols()):\n\t\t\t\tvalue = belief.getProb(r, c)\n\t\t\t\tDisplay._updateBeliefSquare(r, c, value, color)\n\t\tDisplay._releaseLock()\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef move(obj, delta):\n\t\t#print 'attempt move'\n\t\tDisplay._acquireLock()\n\t\t#print 'move'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.move_by(parts, delta.x, delta.y)\n\t\t#print 'end move'\n\t\tDisplay._releaseLock()\n\t\t\n\t# make thread safe\n\t@staticmethod\n\tdef rotate(obj, angle):\n\t\tif angle == 0: return\n\t\t#print 'attempt rotate'\n\t\tDisplay._acquireLock()\n\t\t#print 'rotate'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.rotate_by(parts, angle)\n\t\tDisplay._releaseLock()\n\t\t\t\t\n\t@staticmethod\n\tdef _getBeliefSquareColor(color, value):\n\t\tvalue = min(1.0, value * 15)\n\t\tsaturation = value\n\t\thue = Display.COLOR_HUES[color]\n\t\tr, g, b = colorsys.hsv_to_rgb(hue, saturation, 1.0)\n\t\tcolor = graphicsUtils.formatColor(r, g, b)\n\t\treturn color\t\t\n\t\n\t@staticmethod\n\tdef _isVisible(value):\n\t\treturn value >= Display.VISIBLE_CUTTOFF\n\t\n\t@staticmethod\n\tdef _updateBeliefSquare(r, c, value, colorName):\n\t\tpart = Display.beliefParts[r][c]\n\t\tif part == None: return\n\t\toldValue = Display.beliefValue[r][c]\n\t\toldColor = Display.beliefColor[r][c]\n\t\twasVisible = Display._isVisible(oldValue)\n\t\tisVisible = Display._isVisible(value) \n\t\tif not isVisible: value = 0.0\n\t\tif oldColor != colorName and oldValue >= value: return\n\t\tif not isVisible and not wasVisible: return\n\t\tcolor = Display._getBeliefSquareColor(colorName, value)\n\t\tgraphicsUtils.changeColor(part, color)\n\t\tDisplay.beliefValue[r][c] = value\n\t\tDisplay.beliefColor[r][c] = colorName\n\t\t\n\t@staticmethod\n\tdef _acquireLock():\n\t\treturn\n\t\t#print 'acquire'\n\t\treturn Display.graphicsLock.acquire()\n\t\n\t@staticmethod\n\tdef _releaseLock():\n\t\treturn\n\t\t#print 'release'\n\t\treturn Display.graphicsLock.release()\n\t \n\t####################################\n\t# Depreicated\n\t####################################\n\t\t\n\t@staticmethod\n\tdef _remove(obj):\n\t\tparts = Display.partDict[obj]\n\t\tgraphicsUtils.remove_from_screen(parts);\n\t\t\n\t@staticmethod\n\tdef redrawObservations(observations):\n\t\traise Exception('depreicated')\n\t\tfor obs in Display.observations:\n\t\t\tDisplay._remove(obs)\n\t\tfor obs in observations:\n\t\t\tDisplay.drawObservation(obs)\n\t\tDisplay.observations = observations\n", "description": null, "category": "graphics", "imports": ["from . import graphicsUtils", "from engine.model.car.car import Car", "from engine.const import Const", "from engine.model.observation import Observation", "from engine.vector import Vec2d", "import colorsys", "import threading"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\n\t# Add animation loop here!\n\tlives = NUM_LIVES\n\tdx = graphics.get_dx()\n\tdy = graphics.get_dy()\n\twhile True:\n\t\tpause(FRAME_RATE)\n\t\tif lives == 0:\n\t\t\tbreak\n\t\tif graphics.game_start:\n\t\t\tgraphics.ball.move(dx, dy)\n\t\t\tif graphics.ball.y >= graphics.window.height:\n\t\t\t\tlives -= 1\n\t\t\t\tgraphics.ball.x = (graphics.window_width - graphics.ball_radius * 2) // 2\n\t\t\t\tgraphics.ball.y = (graphics.window_height - graphics.ball_radius * 2) // 2\n\t\t\t\tgraphics.game_start = False\n\t\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\t\t\tdx = -dx\n\t\t\tif graphics.get_paddle_at():\n\t\t\t\tdy = -dy\n\t\t\tif graphics.get_brick_at():\n\t\t\t\tgraphics.window.remove(graphics.brick)\n\t\t\t\tdy = -dy\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "class", "name": "classAnimationPlayer:\r", "data": "class AnimationPlayer:\r\n\tdef __init__(self):\r\n\t\tself.frames = {\r\n\t\t\t# magic\r\n\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\r\n\t\t\t'aura': import_folder('../graphics/particles/aura'),\r\n\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\r\n\t\t\t\r\n\t\t\t# attacks \r\n\t\t\t'claw': import_folder('../graphics/particles/claw'),\r\n\t\t\t'slash': import_folder('../graphics/particles/slash'),\r\n\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\r\n\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\r\n\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\r\n\r\n\t\t\t# monster deaths\r\n\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\r\n\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\r\n\t\t\t'spirit': import_folder('../graphics/particles/nova'),\r\n\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\r\n\t\t\t\r\n\t\t\t# leafs \r\n\t\t\t'leaf': (\r\n\t\t\t\timport_folder('../graphics/particles/leaf1'),\r\n\t\t\t\timport_folder('../graphics/particles/leaf2'),\r\n\t\t\t\timport_folder('../graphics/particles/leaf3'),\r\n\t\t\t\timport_folder('../graphics/particles/leaf4'),\r\n\t\t\t\timport_folder('../graphics/particles/leaf5'),\r\n\t\t\t\timport_folder('../graphics/particles/leaf6'),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\r\n\tdef reflect_images(self,frames):\r\n\t\tnew_frames = []\r\n\r\n\t\tfor frame in frames:\r\n\t \t\tflipped_frame = pygame.transform.flip(frame,True,False)\r\n\t\tnew_frames.append(flipped_frame)\r\n\t\treturn new_frames\r\n\r\n\tdef create_grass_particles(self,pos,groups):\r\n\t \tanimation_frames = choice(self.frames['leaf'])\r\n\t \tParticleEffect(pos,animation_frames,groups)\r\n\r\n\tdef create_particles(self,animation_type,pos,groups):\r\n\t\tanimation_frames = self.frames[animation_type]\r\n\t\tParticleEffect(pos,animation_frames,groups)\r\n\r\n", "description": null, "category": "graphics", "imports": ["import pygame\r", "from support import import_folder\r", "from random import choice\r", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\r", "\t\t\t'aura': import_folder('../graphics/particles/aura'),\r", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\r", "\t\t\t'claw': import_folder('../graphics/particles/claw'),\r", "\t\t\t'slash': import_folder('../graphics/particles/slash'),\r", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\r", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\r", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\r", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\r", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\r", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),\r", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf1'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf2'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf3'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf4'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf5'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf6'),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\r"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\r\n\tdef __init__(self,pos,animation_frames,groups):\r\n\t\tsuper().__init__(groups)\r\n\t\tself.sprite_type = 'magic'\r\n\t\tself.frame_index = 0\r\n\t\tself.animation_speed = 0.15\r\n\t\tself.frames = animation_frames\r\n\t\tself.image = self.frames[self.frame_index]\r\n\t\tself.rect = self.image.get_rect(center = pos)\r\n\r\n\tdef animate(self):\r\n\t\tself.frame_index += self.animation_speed\r\n\t\tif self.frame_index >= len(self.frames):\r\n\t\t\tself.kill()\r\n\t\telse:\r\n\t\t\tself.image = self.frames[int(self.frame_index)]\r\n\r\n\tdef update(self):\r\n", "description": null, "category": "graphics", "imports": ["import pygame\r", "from support import import_folder\r", "from random import choice\r", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\r", "\t\t\t'aura': import_folder('../graphics/particles/aura'),\r", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\r", "\t\t\t'claw': import_folder('../graphics/particles/claw'),\r", "\t\t\t'slash': import_folder('../graphics/particles/slash'),\r", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\r", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\r", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\r", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\r", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\r", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),\r", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf1'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf2'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf3'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf4'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf5'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf6'),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\r"]}], [], [{"term": "class", "name": "SettingsParams", "data": "class SettingsParams(object):\n\n\tdef __settingsDiffPreprocessing(self, diff):\n\t\tsmoothing = diff.pop('smoothing', None)\n\t\tif smoothing is not None:\n\t\t\trppSetting = graphics.GRAPHICS_SETTINGS.RENDER_PIPELINE\n\t\t\trenderOptions = graphics.getGraphicsSetting(rppSetting)\n\t\t\tisAdvancedRender = renderOptions.value == _DEFERRED_RENDER_IDX\n\t\t\tif rppSetting in diff:\n\t\t\t\tisAdvancedRender = diff[rppSetting] == _DEFERRED_RENDER_IDX\n\t\t\tif isAdvancedRender:\n\t\t\t\tdiff[settings_constants.GRAPHICS.CUSTOM_AA] = smoothing\n\t\t\telse:\n\t\t\t\tdiff[settings_constants.GRAPHICS.MULTISAMPLING] = smoothing\n\t\treturn diff\n\n\tdef getGameSettings(self):\n\t\treturn g_settingsCore.packSettings(settings_constants.GAME.ALL())\n\n\tdef getSoundSettings(self):\n\t\treturn g_settingsCore.packSettings(settings_constants.SOUND.ALL())\n\n\tdef getGraphicsSettings(self):\n\t\treturn g_settingsCore.packSettings(settings_constants.GRAPHICS.ALL())\n\n\tdef getMarkersSettings(self):\n\t\treturn g_settingsCore.packSettings(settings_constants.MARKERS.ALL())\n\n\tdef getOtherSettings(self):\n\t\treturn g_settingsCore.packSettings(settings_constants.OTHER.ALL())\n\n\tdef getAimSettings(self):\n\t\treturn g_settingsCore.packSettings(settings_constants.AIM.ALL())\n\n\tdef getControlsSettings(self):\n\t\treturn g_settingsCore.packSettings(settings_constants.CONTROLS.ALL())\n\n\tdef getMonitorSettings(self):\n\t\treturn g_settingsCore.packSettings((settings_constants.GRAPHICS.MONITOR,\n\t\t settings_constants.GRAPHICS.FULLSCREEN,\n\t\t settings_constants.GRAPHICS.WINDOW_SIZE,\n\t\t settings_constants.GRAPHICS.RESOLUTION,\n\t\t settings_constants.GRAPHICS.REFRESH_RATE,\n\t\t settings_constants.GRAPHICS.DYNAMIC_RENDERER,\n\t\t settings_constants.GRAPHICS.INTERFACE_SCALE))\n\n\tdef preview(self, settingName, value):\n\t\tif settingName == 'smoothing':\n\t\t\trppSetting = graphics.GRAPHICS_SETTINGS.RENDER_PIPELINE\n\t\t\trenderOptions = graphics.getGraphicsSetting(rppSetting)\n\t\t\tisAdvancedRender = renderOptions.value == _DEFERRED_RENDER_IDX\n\t\t\tif isAdvancedRender:\n\t\t\t\tg_settingsCore.previewSetting(settings_constants.GRAPHICS.CUSTOM_AA, value)\n\t\t\telse:\n\t\t\t\tg_settingsCore.previewSetting(settings_constants.GRAPHICS.MULTISAMPLING, value)\n\t\t\treturn\n\t\tg_settingsCore.previewSetting(settingName, value)\n\n\tdef revert(self):\n\t\tg_settingsCore.revertSettings()\n\t\tg_settingsCore.clearStorages()\n\n\tdef apply(self, diff, restartApproved):\n\t\tdiff = self.__settingsDiffPreprocessing(diff)\n\t\tapplyMethod = self.getApplyMethod(diff)\n\t\tg_settingsCore.applySettings(diff)\n\t\tconfirmators = g_settingsCore.applyStorages(restartApproved)\n\t\tg_settingsCore.confirmChanges(confirmators)\n\t\tif len(set(graphics.GRAPHICS_SETTINGS.ALL()) & set(diff.keys())):\n\t\t\tBigWorld.commitPendingGraphicsSettings()\n\t\treturn applyMethod == options.APPLY_METHOD.RESTART\n\n\tdef getApplyMethod(self, diff):\n\t\tnewMonitorIndex = diff.get(settings_constants.GRAPHICS.MONITOR)\n\t\tisFullscreen = g_monitorSettings.isFullscreen or diff.get(settings_constants.GRAPHICS.FULLSCREEN)\n\t\tisMonitorChanged = g_monitorSettings.isMonitorChanged or newMonitorIndex is not None and g_monitorSettings.currentMonitor != int(newMonitorIndex)\n\t\tif isFullscreen and isMonitorChanged:\n\t\t\treturn options.APPLY_METHOD.RESTART\n\t\telse:\n\t\t\treturn g_settingsCore.getApplyMethod(diff)\n", "description": null, "category": "graphics", "imports": ["import BigWorld", "from account_helpers.settings_core import settings_constants, options", "from account_helpers.settings_core.SettingsCore import g_settingsCore", "from gui.shared.utils import graphics", "from gui.shared.utils.graphics import g_monitorSettings"]}], [{"term": "class", "name": "Display", "data": "class Display(object):\n\t\n\tWHITE = graphicsUtils.formatColor(1.0, 1.0, 1.0)\n\tRED = graphicsUtils.formatColor(1.0, 0.0, 0.0)\n\tGREEN = graphicsUtils.formatColor(0.16, 0.49, 0.31)\n\tBLUE = graphicsUtils.formatColor(0.0, 0.0, 1.0)\n\tBLACK = graphicsUtils.formatColor(0.0, 0.0, 0.0)\n\tGREY = graphicsUtils.formatColor(0.5, .5, 0.5)\n\t\n\tVISIBLE_CUTTOFF = 0.001\n\t\n\t\n\tpartDict = {}\n\tbeliefParts = []\n\tbeliefValue = []\n\tbeliefColor = []\n\tobservations = []\n\t\n\tgraphicsLock = threading.Lock()\n\t\n\tCOLORS = [\n\t\t'purple',\n\t\t'green',\n\t\t'teal',\n\t\t'red',\n\t\t'orange',\n\t\t'yellow'\n\t]\n\tCOLOR_HUES = {\n\t\t'purple' : 0.8,\n\t\t'green' : 0.3,\n\t\t'teal' : 0.49,\n\t\t'red' : 0.0,\n\t\t'orange' : 0.125,\n\t\t'yellow' : 0.21\n\t}\n\t\n\t@staticmethod\n\tdef initGraphics(layout):\n\t\tgraphicsUtils.begin_graphics(\n\t\t\twidth=layout.getWidth(), \n\t\t\theight=layout.getHeight(), \n\t\t\tcolor = Display.WHITE,\n\t\t\ttitle = Const.TITLE\n\t\t);\n\t\t\n\t@staticmethod\n\tdef endGraphics():\n\t\tgraphicsUtils.end_graphics()\n\n\t@staticmethod\n\tdef raiseEndGraphics():\n\t\tgraphicsUtils.raiseEndGraphics()\n\t\n\t@staticmethod\n\tdef drawCar(car):\n\t\tif car in Display.partDict:\n\t\t\tDisplay._remove(car)\n\t\tcolor = Display.GREY\n\t\tif car.isJunior():\n\t\t\tcolor = Display.BLACK\n\t\tparts = graphicsUtils.rectangle(\n\t\t\tcar.pos, Car.LENGTH, \n\t\t\tCar.WIDTH, \n\t\t\tcolor, \n\t\t\tcar.dir\n\t\t)\n\t\tDisplay.partDict[car] = parts\n\t\t\n\t@staticmethod\n\tdef drawObservation(obs):\n\t\tparts = Display.drawCircle(obs.pos, Observation.RADIUS)\n\t\tDisplay.partDict[obs] = parts\n\t\n\t@staticmethod\n\tdef drawSquare(pos, size, color):\n\t\treturn graphicsUtils.square(pos, size, color)\n\t\n\t@staticmethod\n\tdef drawFinish(block):\n\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.GREEN, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\n\t@staticmethod\n\tdef drawBlocks(blocks):\n\t\tfor block in blocks:\n\t\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.BLUE, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\t\n\t@staticmethod\n\tdef drawCircle(pos, radius):\n\t\treturn graphicsUtils.circle(pos, radius, Display.RED, Display.RED)\n\t\n\t@staticmethod\n\tdef drawBelief(model):\n\t\tDisplay.beliefVisible = []\n\t\tfor r in range(model.getBeliefRows()):\n\t\t\tbeliefValueRow = []\n\t\t\tbeliefPartRow = []\n\t\t\tbeliefColorRow = []\n\t\t\tfor c in range(model.getBeliefCols()):\n\t\t\t\tsquare = Display.drawBeliefSquare(r, c, 'purple', 0.0, model)\n\t\t\t\tbeliefPartRow.append(square)\n\t\t\t\tbeliefValueRow.append(0.0)\n\t\t\t\tbeliefColorRow.append(None)\n\t\t\tDisplay.beliefParts.append(beliefPartRow)\n\t\t\tDisplay.beliefValue.append(beliefValueRow)\n\t\t\tDisplay.beliefColor.append(beliefColorRow)\n\t\t\t\t\n\t@staticmethod\n\tdef drawBeliefSquare(row, col, color, value, model):\n\t\ttileSize = Const.BELIEF_TILE_SIZE\n\t\tx = col * tileSize + tileSize / 2.0\n\t\ty = row * tileSize + tileSize / 2.0\n\t\tif not model.inBounds(x, y): return None\n\t\tcolor = Display._getBeliefSquareColor(color, value)\n\t\treturn Display.drawSquare(Vec2d(x, y), tileSize, color)\n\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef getKeys():\n\t\t#print 'attempt get keys'\n\t\tDisplay._acquireLock()\n\t\t#print 'get keys'\n\t\tkeys = graphicsUtils.keys_waiting() + graphicsUtils.keys_pressed()\n\t\tDisplay._releaseLock()\n\t\treturn keys\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef graphicsSleep(timeToSleep):\n\t\tgraphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''for _ in range(int(timeToSleep / 0.005)):\n\t\t\t#print 'attempt sleep'\n\t\t\tDisplay._acquireLock()\n\t\t\t#print 'sleep'\n\t\t\tgraphicsUtils.sleep(0.001)\n\t\t\tDisplay._releaseLock()\n\t\t\ttime.sleep(0.004)'''\n\t\t\n\t\t#graphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''startWait = time.time()\n\t\tDisplay._acquireLock()\n\t\ttimeToSleep -= time.time() - startWait\n\t\tgraphicsUtils.refresh()\n\t\tif timeToSleep > 0:\n\t\t\tgraphicsUtils.sleep(timeToSleep)\n\t\tDisplay._releaseLock()'''\n\t\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef updateBelief(color, belief):\n\t\tDisplay._acquireLock()\n\t\ttotal = belief.getSum()\n\t\tif abs(total - 1.0) > 0.001:\n\t\t\traise Exception('belief does not sum to 1 ('+str(total)+'). Use the normalize method.')\n\t\tfor r in range(belief.getNumRows()):\n\t\t\tfor c in range(belief.getNumCols()):\n\t\t\t\tvalue = belief.getProb(r, c)\n\t\t\t\tDisplay._updateBeliefSquare(r, c, value, color)\n\t\tDisplay._releaseLock()\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef move(obj, delta):\n\t\t#print 'attempt move'\n\t\tDisplay._acquireLock()\n\t\t#print 'move'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.move_by(parts, delta.x, delta.y)\n\t\t#print 'end move'\n\t\tDisplay._releaseLock()\n\t\t\n\t# make thread safe\n\t@staticmethod\n\tdef rotate(obj, angle):\n\t\tif angle == 0: return\n\t\t#print 'attempt rotate'\n\t\tDisplay._acquireLock()\n\t\t#print 'rotate'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.rotate_by(parts, angle)\n\t\tDisplay._releaseLock()\n\t\t\t\t\n\t@staticmethod\n\tdef _getBeliefSquareColor(color, value):\n\t\tvalue = min(1.0, value * 15)\n\t\tsaturation = value\n\t\thue = Display.COLOR_HUES[color]\n\t\tr, g, b = colorsys.hsv_to_rgb(hue, saturation, 1.0)\n\t\tcolor = graphicsUtils.formatColor(r, g, b)\n\t\treturn color\t\t\n\t\n\t@staticmethod\n\tdef _isVisible(value):\n\t\treturn value >= Display.VISIBLE_CUTTOFF\n\t\n\t@staticmethod\n\tdef _updateBeliefSquare(r, c, value, colorName):\n\t\tpart = Display.beliefParts[r][c]\n\t\tif part == None: return\n\t\toldValue = Display.beliefValue[r][c]\n\t\toldColor = Display.beliefColor[r][c]\n\t\twasVisible = Display._isVisible(oldValue)\n\t\tisVisible = Display._isVisible(value) \n\t\tif not isVisible: value = 0.0\n\t\tif oldColor != colorName and oldValue >= value: return\n\t\tif not isVisible and not wasVisible: return\n\t\tcolor = Display._getBeliefSquareColor(colorName, value)\n\t\tgraphicsUtils.changeColor(part, color)\n\t\tDisplay.beliefValue[r][c] = value\n\t\tDisplay.beliefColor[r][c] = colorName\n\t\t\n\t@staticmethod\n\tdef _acquireLock():\n\t\treturn\n\t\t#print 'acquire'\n\t\treturn Display.graphicsLock.acquire()\n\t\n\t@staticmethod\n\tdef _releaseLock():\n\t\treturn\n\t\t#print 'release'\n\t\treturn Display.graphicsLock.release()\n\t \n\t####################################\n\t# Depreicated\n\t####################################\n\t\t\n\t@staticmethod\n\tdef _remove(obj):\n\t\tparts = Display.partDict[obj]\n\t\tgraphicsUtils.remove_from_screen(parts);\n\t\t\n\t@staticmethod\n\tdef redrawObservations(observations):\n\t\traise Exception('depreicated')\n\t\tfor obs in Display.observations:\n\t\t\tDisplay._remove(obs)\n\t\tfor obs in observations:\n\t\t\tDisplay.drawObservation(obs)\n\t\tDisplay.observations = observations\n", "description": null, "category": "graphics", "imports": ["import graphicsUtils", "from engine.model.car.car import Car", "from engine.const import Const", "from engine.model.observation import Observation", "from engine.vector import Vec2d", "import colorsys", "import threading"]}], [{"term": "class", "name": "MatrixPlot", "data": "class MatrixPlot(GraphicPrimitive):\n\t\"\"\"\n\tPrimitive class for the matrix plot graphics type.  See\n\t``matrix_plot?`` for help actually doing matrix plots.\n\n\tINPUT:\n\n\t- ``xy_data_array`` - list of lists giving matrix values corresponding to\n\t  the grid\n\n\t- ``xrange`` - tuple of 2 floats indicating range for horizontal direction\n\t  (number of columns in the matrix)\n\n\t- ``yrange`` - tuple of 2 floats indicating range for vertical direction\n\t  (number of rows in the matrix)\n\n\t- ``options`` - dict of valid plot options to pass to constructor\n\n\tEXAMPLES:\n\n\tNote this should normally be used indirectly via :func:`matrix_plot`::\n\n\t\tsage: from sage.plot.matrix_plot import MatrixPlot\n\t\tsage: M = MatrixPlot([[1,3],[2,4]],(1,2),(2,3),options={'cmap':'winter'})\n\t\tsage: M\n\t\tMatrixPlot defined by a 2 x 2 data grid\n\t\tsage: M.yrange\n\t\t(2, 3)\n\t\tsage: M.xy_data_array\n\t\t[[1, 3], [2, 4]]\n\t\tsage: M.options()\n\t\t{'cmap': 'winter'}\n\n\tExtra options will get passed on to :meth:`~Graphics.show`, as long as they are valid::\n\n\t\tsage: matrix_plot([[1, 0], [0, 1]], fontsize=10)\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: matrix_plot([[1, 0], [0, 1]]).show(fontsize=10) # These are equivalent\n\n\tTESTS:\n\n\tWe test creating a matrix plot::\n\n\t\tsage: matrix_plot([[mod(i,5)^j for i in range(5)] for j in range(1,6)])\n\t\tGraphics object consisting of 1 graphics primitive\n\t\"\"\"\n\tdef __init__(self, xy_data_array, xrange, yrange, options):\n\t\t\"\"\"\n\t\tInitializes base class MatrixPlot.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: M = matrix_plot([[mod(i,5)^j for i in range(5)] for j in range(1,6)], cmap='jet')\n\t\t\tsage: M[0].xrange\n\t\t\t(0, 5)\n\t\t\tsage: M[0].options()['cmap']\n\t\t\t'jet'\n\t\t\tsage: M[0].xy_array_row\n\t\t\t5\n\t\t\"\"\"\n\t\tself.xrange = xrange\n\t\tself.yrange = yrange\n\t\tself.xy_data_array = xy_data_array\n\t\tif hasattr(xy_data_array, 'shape'):\n\t\t\tself.xy_array_row = xy_data_array.shape[0]\n\t\t\tself.xy_array_col = xy_data_array.shape[1]\n\t\telse:\n\t\t\tself.xy_array_row = len(xy_data_array)\n\t\t\tself.xy_array_col = len(xy_data_array[0])\n\t\tGraphicPrimitive.__init__(self, options)\n\n\tdef get_minmax_data(self):\n\t\t\"\"\"\n\t\tReturns a dictionary with the bounding box data.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: m = matrix_plot(matrix([[1,3,5,1],[2,4,5,6],[1,3,5,7]]))[0]\n\t\t\tsage: list(sorted(m.get_minmax_data().items()))\n\t\t\t[('xmax', 3.5), ('xmin', -0.5), ('ymax', -0.5), ('ymin', 2.5)]\n\n\n\t\t\"\"\"\n\t\tfrom sage.plot.plot import minmax_data\n\t\tlimits= minmax_data(self.xrange, self.yrange, dict=True)\n\t\tif self.options()['origin']!='lower':\n\t\t\t# flip y-axis so that the picture looks correct.\n\t\t\tlimits['ymin'],limits['ymax']=limits['ymax'],limits['ymin']\n\n\t\t# center the matrix so that, for example, the square representing the\n\t\t# (0,0) entry is centered on the origin.\n\t\tfor k,v in limits.iteritems():\n\t\t\tlimits[k]-=0.5\n\t\treturn limits\n\n\tdef _allowed_options(self):\n\t\t\"\"\"\n\t\tReturn the allowed options for the MatrixPlot class.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: M = matrix_plot([[sin(i*j) for i in range(5)] for j in range(5)])\n\t\t\tsage: isinstance(M[0]._allowed_options(),dict)\n\t\t\tTrue\n\t\t\"\"\"\n\t\treturn {'cmap':\"\"\"the name of a predefined colormap,\n\t\t\t\t\t\ta list of colors, or an instance of a\n\t\t\t\t\t\tmatplotlib Colormap. Type: import matplotlib.cm; matplotlib.cm.datad.keys()\n\t\t\t\t\t\tfor available colormap names.\"\"\",\n\t\t\t\t'colorbar': \"Include a colorbar indicating the levels (dense matrices only)\",\n\t\t\t\t'colorbar_options': \"a dictionary of options for colorbars\",\n\t\t\t\t'zorder':\"The layer level in which to draw\",\n\t\t\t\t'marker':\"The marker for sparse plots\",\n\t\t\t\t'markersize':\"The marker size for sparse plots\",\n\t\t\t\t'norm': \"The normalization function\",\n\t\t\t\t'vmin': \"The minimum value\",\n\t\t\t\t'vmax': \"The maximum value\",\n\t\t\t\t'origin': \"If 'lower', draw the matrix with the first row on the bottom of the graph\",\n\t\t\t\t'subdivisions': \"If True, draw subdivisions of the matrix\",\n\t\t\t\t'subdivision_options': \"Options (boundaries and style) of the subdivisions\"}\n\n\tdef _repr_(self):\n\t\t\"\"\"\n\t\tString representation of MatrixPlot primitive.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: M = matrix_plot([[sin(i*j) for i in range(5)] for j in range(5)])\n\t\t\tsage: m = M[0]; m\n\t\t\tMatrixPlot defined by a 5 x 5 data grid\n\t\t\"\"\"\n\t\treturn \"MatrixPlot defined by a %s x %s data grid\"%(self.xy_array_row, self.xy_array_col)\n\n\tdef _render_on_subplot(self, subplot):\n\t\t\"\"\"\n\t\tTESTS::\n\n\t\t\tsage: matrix_plot(random_matrix(RDF, 50), cmap='jet')\n\t\t\tGraphics object consisting of 1 graphics primitive\n\t\t\"\"\"\n\t\toptions = self.options()\n\t\tcmap = get_cmap(options.pop('cmap',None))\n\t\torigin=options['origin']\n\n\t\tnorm=options['norm']\n\n\t\tif norm=='value':\n\t\t\timport matplotlib\n\t\t\tnorm=matplotlib.colors.NoNorm()\n\n\t\tif options['subdivisions']:\n\t\t\tsubdiv_options=options['subdivision_options']\n\t\t\tif isinstance(subdiv_options['boundaries'], (list, tuple)):\n\t\t\t\trowsub,colsub=subdiv_options['boundaries']\n\t\t\telse:\n\t\t\t\trowsub=subdiv_options['boundaries']\n\t\t\t\tcolsub=subdiv_options['boundaries']\n\t\t\tif isinstance(subdiv_options['style'], (list, tuple)):\n\t\t\t\trowstyle,colstyle=subdiv_options['style']\n\t\t\telse:\n\t\t\t\trowstyle=subdiv_options['style']\n\t\t\t\tcolstyle=subdiv_options['style']\n\t\t\tif rowstyle is None:\n\t\t\t\trowstyle=dict()\n\t\t\tif colstyle is None:\n\t\t\t\tcolstyle=dict()\n\n\t\t\t# Make line objects for subdivisions\n\t\t\tfrom line import line2d\n\t\t\tlim=self.get_minmax_data()\n\t\t\t# First draw horizontal lines representing row subdivisions\n\t\t\tfor y in rowsub:\n\t\t\t\tl=line2d([(lim['xmin'],y-0.5), (lim['xmax'],y-0.5)], **rowstyle)[0]\n\t\t\t\tl._render_on_subplot(subplot)\n\t\t\tfor x in colsub:\n\t\t\t\tl=line2d([(x-0.5, lim['ymin']), (x-0.5, lim['ymax'])], **colstyle)[0]\n\t\t\t\tl._render_on_subplot(subplot)\n\n\t\tif hasattr(self.xy_data_array, 'tocoo'):\n\t\t\t# Sparse matrix -- use spy\n\t\t\topts=options.copy()\n\t\t\tfor opt in ['vmin', 'vmax', 'norm', 'origin','subdivisions','subdivision_options',\n\t\t\t\t\t\t'colorbar','colorbar_options']:\n\t\t\t\tdel opts[opt]\n\t\t\tif origin=='lower':\n\t\t\t\tsubplot.spy(self.xy_data_array.tocsr()[::-1], **opts)\n\t\t\telse:\n\t\t\t\tsubplot.spy(self.xy_data_array, **opts)\n\t\telse:\n\t\t\topts = dict(cmap=cmap, interpolation='nearest', aspect='equal',\n\t\t\t\t\t  norm=norm, vmin=options['vmin'], vmax=options['vmax'],\n\t\t\t\t\t  origin=origin,zorder=options.get('zorder',None))\n\t\t\timage=subplot.imshow(self.xy_data_array, **opts)\n\n\t\t\tif options.get('colorbar', False):\n\t\t\t\tcolorbar_options = options['colorbar_options']\n\t\t\t\tfrom matplotlib import colorbar\n\t\t\t\tcax,kwds=colorbar.make_axes_gridspec(subplot,**colorbar_options)\n\t\t\t\tcb=colorbar.Colorbar(cax,image, **kwds)\n\n\t\tif origin=='upper':\n\t\t\tsubplot.xaxis.tick_top()\n\t\telif origin=='lower':\n\t\t\tsubplot.xaxis.tick_bottom()\n\t\tsubplot.xaxis.set_ticks_position('both') #only tick marks, not tick labels\n\n\n\n", "description": "\n\tPrimitive class for the matrix plot graphics type.  See\n\t``matrix_plot?`` for help actually doing matrix plots.\n\n\tINPUT:\n\n\t- ``xy_data_array`` - list of lists giving matrix values corresponding to\n\t  the grid\n\n\t- ``xrange`` - tuple of 2 floats indicating range for horizontal direction\n\t  (number of columns in the matrix)\n\n\t- ``yrange`` - tuple of 2 floats indicating range for vertical direction\n\t  (number of rows in the matrix)\n\n\t- ``options`` - dict of valid plot options to pass to constructor\n\n\tEXAMPLES:\n\n\tNote this should normally be used indirectly via :func:`matrix_plot`::\n\n\t\tsage: from sage.plot.matrix_plot import MatrixPlot\n\t\tsage: M = MatrixPlot([[1,3],[2,4]],(1,2),(2,3),options={'cmap':'winter'})\n\t\tsage: M\n\t\tMatrixPlot defined by a 2 x 2 data grid\n\t\tsage: M.yrange\n\t\t(2, 3)\n\t\tsage: M.xy_data_array\n\t\t[[1, 3], [2, 4]]\n\t\tsage: M.options()\n\t\t{'cmap': 'winter'}\n\n\tExtra options will get passed on to :meth:`~Graphics.show`, as long as they are valid::\n\n\t\tsage: matrix_plot([[1, 0], [0, 1]], fontsize=10)\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: matrix_plot([[1, 0], [0, 1]]).show(fontsize=10) # These are equivalent\n\n\tTESTS:\n\n\tWe test creating a matrix plot::\n\n\t\tsage: matrix_plot([[mod(i,5)^j for i in range(5)] for j in range(1,6)])\n\t\tGraphics object consisting of 1 graphics primitive\n\t", "category": "graphics", "imports": ["from sage.plot.primitive import GraphicPrimitive", "from sage.misc.decorators import options, suboptions", "from sage.plot.colors import get_cmap", "\t\tsage: from sage.plot.matrix_plot import MatrixPlot", "\t\tfrom sage.plot.plot import minmax_data", "\t\t\t\t\t\tmatplotlib Colormap. Type: import matplotlib.cm; matplotlib.cm.datad.keys()", "\t\t\timport matplotlib", "\t\t\tfrom line import line2d", "\t\t\t\tfrom matplotlib import colorbar", "\t  Type: ``import matplotlib.cm; matplotlib.cm.datad.keys()``", "\t\tsage: import numpy", "\timport numpy as np", "\timport scipy.sparse as scipysparse", "\tfrom sage.plot.all import Graphics", "\tfrom sage.matrix.matrix import is_Matrix", "\tfrom sage.rings.all import RDF"]}, {"term": "def", "name": "matrix_plot", "data": "def matrix_plot(mat, **options):\n\tr\"\"\"\n\tA plot of a given matrix or 2D array.\n\n\tIf the matrix is dense, each matrix element is given a different\n\tcolor value depending on its relative size compared to the other\n\telements in the matrix.  If the matrix is sparse, colors only\n\tindicate whether an element is nonzero or zero, so the plot\n\trepresents the sparsity pattern of the matrix.\n\n\tThe tick marks drawn on the frame axes denote the row numbers\n\t(vertical ticks) and the column numbers (horizontal ticks) of the\n\tmatrix.\n\n\tINPUT:\n\n\t- ``mat`` - a 2D matrix or array\n\n\tThe following input must all be passed in as named parameters, if\n\tdefault not used:\n\n\t- ``cmap`` - a colormap (default: 'gray'), the name of\n\t  a predefined colormap, a list of colors,\n\t  or an instance of a matplotlib Colormap.\n\t  Type: ``import matplotlib.cm; matplotlib.cm.datad.keys()``\n\t  for available colormap names.\n\n\t- ``colorbar`` -- boolean (default: False) Show a colorbar or not (dense matrices only).\n\n\t  The following options are used to adjust the style and placement\n\t  of colorbars.  They have no effect if a colorbar is not shown.\n\n\t  - ``colorbar_orientation`` -- string (default: 'vertical'),\n\t\tcontrols placement of the colorbar, can be either 'vertical'\n\t\tor 'horizontal'\n\n\t  - ``colorbar_format`` -- a format string, this is used to format\n\t\tthe colorbar labels.\n\n\t  - ``colorbar_options`` -- a dictionary of options for the matplotlib\n\t\tcolorbar API.  Documentation for the :mod:`matplotlib.colorbar` module\n\t\thas details.\n\n\t- ``norm`` - If None (default), the value range is scaled to the interval\n\t  [0,1].  If 'value', then the actual value is used with no\n\t  scaling.  A :class:`matplotlib.colors.Normalize` instance may\n\t  also passed.\n\n\t- ``vmin`` - The minimum value (values below this are set to this value)\n\n\t- ``vmax`` - The maximum value (values above this are set to this value)\n\n\t- ``origin`` - If 'upper' (default), the first row of the matrix\n\t  is on the top of the graph.  If 'lower', the first row is on the\n\t  bottom of the graph.\n\n\t- ``subdivisions`` - If True, plot the subdivisions of the matrix as lines.\n\n\t- ``subdivision_boundaries`` - a list of lists in the form\n\t  ``[row_subdivisions, column_subdivisions]``, which specifies\n\t  the row and column subdivisions to use.  If not specified,\n\t  defaults to the matrix subdivisions\n\n\t- ``subdivision_style`` - a dictionary of properties passed\n\t  on to the :func:`~sage.plot.line.line2d` command for plotting\n\t  subdivisions.  If this is a two-element list or tuple, then it\n\t  specifies the styles of row and column divisions, respectively.\n\n\tEXAMPLES:\n\n\tA matrix over `\\ZZ` colored with different grey levels::\n\n\t\tsage: matrix_plot(matrix([[1,3,5,1],[2,4,5,6],[1,3,5,7]]))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere we make a random matrix over `\\RR` and use ``cmap='hsv'``\n\tto color the matrix elements different RGB colors::\n\n\t\tsage: matrix_plot(random_matrix(RDF, 50), cmap='hsv')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tBy default, entries are scaled to the interval [0,1] before\n\tdetermining colors from the color map.  That means the two plots\n\tbelow are the same::\n\n\t\tsage: P = matrix_plot(matrix(2,[1,1,3,3]))\n\t\tsage: Q = matrix_plot(matrix(2,[2,2,3,3]))\n\t\tsage: P; Q\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHowever, we can specify which values scale to 0 or 1 with the\n\t``vmin`` and ``vmax`` parameters (values outside the range are\n\tclipped).  The two plots below are now distinguished::\n\n\t\tsage: P = matrix_plot(matrix(2,[1,1,3,3]), vmin=0, vmax=3, colorbar=True)\n\t\tsage: Q = matrix_plot(matrix(2,[2,2,3,3]), vmin=0, vmax=3, colorbar=True)\n\t\tsage: P; Q\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can also specify a norm function of 'value', which means that\n\tthere is no scaling performed::\n\n\t\tsage: matrix_plot(random_matrix(ZZ,10)*.05, norm='value', colorbar=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tMatrix subdivisions can be plotted as well::\n\n\t\tsage: m=random_matrix(RR,10)\n\t\tsage: m.subdivide([2,4],[6,8])\n\t\tsage: matrix_plot(m, subdivisions=True, subdivision_style=dict(color='red',thickness=3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tYou can also specify your own subdivisions and separate styles\n\tfor row or column subdivisions::\n\n\t\tsage: m=random_matrix(RR,10)\n\t\tsage: matrix_plot(m, subdivisions=True, subdivision_boundaries=[[2,4],[6,8]], subdivision_style=[dict(color='red',thickness=3),dict(linestyle='--',thickness=6)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tGenerally matrices are plotted with the (0,0) entry in the upper\n\tleft.  However, sometimes if we are plotting an image, we'd like\n\tthe (0,0) entry to be in the lower left.  We can do that with the\n\t``origin`` argument::\n\n\t\tsage: matrix_plot(identity_matrix(100), origin='lower')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAnother random plot, but over `\\GF{389}`::\n\n\t\tsage: m = random_matrix(GF(389), 10)\n\t\tsage: matrix_plot(m, cmap='Oranges')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tIt also works if you lift it to the polynomial ring::\n\n\t\tsage: matrix_plot(m.change_ring(GF(389)['x']), cmap='Oranges')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe have several options for colorbars::\n\n\t\tsage: matrix_plot(random_matrix(RDF, 50), colorbar=True, colorbar_orientation='horizontal')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: matrix_plot(random_matrix(RDF, 50), colorbar=True, colorbar_format='%.3f')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tThe length of a color bar and the length of the adjacent\n\tmatrix plot dimension may be quite different.  This example\n\tshows how to adjust the length of the colorbar by passing a\n\tdictionary of options to the matplotlib colorbar routines.  ::\n\n\t\tsage: m = random_matrix(ZZ, 40, 80, x=-10, y=10)\n\t\tsage: m.plot(colorbar=True, colorbar_orientation='vertical',\n\t\t....:\t\tcolorbar_options={'shrink':0.50})\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere we plot a random sparse matrix::\n\n\t\tsage: sparse = matrix(dict([((randint(0, 10), randint(0, 10)), 1) for i in xrange(100)]))\n\t\tsage: matrix_plot(sparse)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: A=random_matrix(ZZ,100000,density=.00001,sparse=True)\n\t\tsage: matrix_plot(A,marker=',')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAs with dense matrices, sparse matrix entries are automatically\n\tconverted to floating point numbers before plotting.  Thus the\n\tfollowing works::\n\n\t\tsage: b=random_matrix(GF(2),200,sparse=True,density=0.01)\n\t\tsage: matrix_plot(b)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWhile this returns an error::\n\n\t\tsage: b=random_matrix(CDF,200,sparse=True,density=0.01)\n\t\tsage: matrix_plot(b)\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: can not convert entries to floating point numbers\n\n\tTo plot the absolute value of a complex matrix, use the\n\t``apply_map`` method::\n\n\t\tsage: b=random_matrix(CDF,200,sparse=True,density=0.01)\n\t\tsage: matrix_plot(b.apply_map(abs))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tPlotting lists of lists also works::\n\n\t\tsage: matrix_plot([[1,3,5,1],[2,4,5,6],[1,3,5,7]])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAs does plotting of NumPy arrays::\n\n\t\tsage: import numpy\n\t\tsage: matrix_plot(numpy.random.rand(10, 10))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA plot title can be added to the matrix plot.::\n\n\t\tsage: matrix_plot(identity_matrix(50), origin='lower', title='not identity')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tThe title position is adjusted upwards if the ``origin`` keyword is set\n\tto ``\"upper\"`` (this is the default).::\n\n\t\tsage: matrix_plot(identity_matrix(50), title='identity')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tTESTS::\n\n\t\tsage: P. = RR[]\n\t\tsage: matrix_plot(random_matrix(P, 3, 3))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tTypeError: cannot coerce nonconstant polynomial to float\n\n\t::\n\n\t\tsage: matrix_plot([1,2,3])\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tTypeError: mat must be a Matrix or a two dimensional array\n\n\t::\n\n\t\tsage: matrix_plot([[sin(x), cos(x)], [1, 0]])\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tTypeError: mat must be a Matrix or a two dimensional array\n\n\tTest that sparse matrices also work with subdivisions::\n\n\t\tsage: matrix_plot(sparse, subdivisions=True, subdivision_boundaries=[[2,4],[6,8]])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tTest that matrix plots have aspect ratio one (see :trac:`15315`)::\n\n\t\tsage: P = matrix_plot(random_matrix(RDF, 5))\n\t\tsage: P.aspect_ratio()\n\t\t1\n\t\"\"\"\n\timport numpy as np\n\timport scipy.sparse as scipysparse\n\tfrom sage.plot.all import Graphics\n\tfrom sage.matrix.matrix import is_Matrix\n\tfrom sage.rings.all import RDF\n\torig_mat=mat\n\tif is_Matrix(mat):\n\t\tsparse = mat.is_sparse()\n\t\tif sparse:\n\t\t\tentries = list(mat._dict().items())\n\t\t\ttry:\n\t\t\t\tdata = np.asarray([d for _,d in entries], dtype=float)\n\t\t\texcept Exception:\n\t\t\t\traise ValueError(\"can not convert entries to floating point numbers\")\n\t\t\tpositions = np.asarray([[row for (row,col),_ in entries],\n\t\t\t\t\t\t\t\t\t[col for (row,col),_ in entries]], dtype=int)\n\t\t\tmat = scipysparse.coo_matrix((data,positions), shape=(mat.nrows(), mat.ncols()))\n\t\telse:\n\t\t\tmat = mat.change_ring(RDF).numpy()\n\telif hasattr(mat, 'tocoo'):\n\t\tsparse = True\n\telse:\n\t\tsparse = False\n\n\n\ttry:\n\t\tif sparse:\n\t\t\txy_data_array = mat\n\t\telse:\n\t\t\txy_data_array = np.asarray(mat, dtype = float)\n\texcept TypeError:\n\t\traise TypeError(\"mat must be a Matrix or a two dimensional array\")\n\texcept ValueError:\n\t\traise ValueError(\"can not convert entries to floating point numbers\")\n\n\tif len(xy_data_array.shape) < 2:\n\t\traise TypeError(\"mat must be a Matrix or a two dimensional array\")\n\n\txrange = (0, xy_data_array.shape[1])\n\tyrange = (0, xy_data_array.shape[0])\n\n\tif options['subdivisions'] and options['subdivision_options']['boundaries'] is None:\n\t\toptions['subdivision_options']['boundaries']=orig_mat.get_subdivisions()\n\n\t# Custom position the title. Otherwise it overlaps with tick labels\n\tif options['origin'] == 'upper' and 'title_pos' not in options:\n\t\toptions['title_pos'] = (0.5, 1.05)\n\n\tg = Graphics()\n\tg._set_extra_kwds(Graphics._extract_kwds_for_show(options))\n\tg.add_primitive(MatrixPlot(xy_data_array, xrange, yrange, options))\n\treturn g\n", "description": "\n\tA plot of a given matrix or 2D array.\n\n\tIf the matrix is dense, each matrix element is given a different\n\tcolor value depending on its relative size compared to the other\n\telements in the matrix.  If the matrix is sparse, colors only\n\tindicate whether an element is nonzero or zero, so the plot\n\trepresents the sparsity pattern of the matrix.\n\n\tThe tick marks drawn on the frame axes denote the row numbers\n\t(vertical ticks) and the column numbers (horizontal ticks) of the\n\tmatrix.\n\n\tINPUT:\n\n\t- ``mat`` - a 2D matrix or array\n\n\tThe following input must all be passed in as named parameters, if\n\tdefault not used:\n\n\t- ``cmap`` - a colormap (default: 'gray'), the name of\n\t  a predefined colormap, a list of colors,\n\t  or an instance of a matplotlib Colormap.\n\t  Type: ``import matplotlib.cm; matplotlib.cm.datad.keys()``\n\t  for available colormap names.\n\n\t- ``colorbar`` -- boolean (default: False) Show a colorbar or not (dense matrices only).\n\n\t  The following options are used to adjust the style and placement\n\t  of colorbars.  They have no effect if a colorbar is not shown.\n\n\t  - ``colorbar_orientation`` -- string (default: 'vertical'),\n\t\tcontrols placement of the colorbar, can be either 'vertical'\n\t\tor 'horizontal'\n\n\t  - ``colorbar_format`` -- a format string, this is used to format\n\t\tthe colorbar labels.\n\n\t  - ``colorbar_options`` -- a dictionary of options for the matplotlib\n\t\tcolorbar API.  Documentation for the :mod:`matplotlib.colorbar` module\n\t\thas details.\n\n\t- ``norm`` - If None (default), the value range is scaled to the interval\n\t  [0,1].  If 'value', then the actual value is used with no\n\t  scaling.  A :class:`matplotlib.colors.Normalize` instance may\n\t  also passed.\n\n\t- ``vmin`` - The minimum value (values below this are set to this value)\n\n\t- ``vmax`` - The maximum value (values above this are set to this value)\n\n\t- ``origin`` - If 'upper' (default), the first row of the matrix\n\t  is on the top of the graph.  If 'lower', the first row is on the\n\t  bottom of the graph.\n\n\t- ``subdivisions`` - If True, plot the subdivisions of the matrix as lines.\n\n\t- ``subdivision_boundaries`` - a list of lists in the form\n\t  ``[row_subdivisions, column_subdivisions]``, which specifies\n\t  the row and column subdivisions to use.  If not specified,\n\t  defaults to the matrix subdivisions\n\n\t- ``subdivision_style`` - a dictionary of properties passed\n\t  on to the :func:`~sage.plot.line.line2d` command for plotting\n\t  subdivisions.  If this is a two-element list or tuple, then it\n\t  specifies the styles of row and column divisions, respectively.\n\n\tEXAMPLES:\n\n\tA matrix over `\\ZZ` colored with different grey levels::\n\n\t\tsage: matrix_plot(matrix([[1,3,5,1],[2,4,5,6],[1,3,5,7]]))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere we make a random matrix over `\\RR` and use ``cmap='hsv'``\n\tto color the matrix elements different RGB colors::\n\n\t\tsage: matrix_plot(random_matrix(RDF, 50), cmap='hsv')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tBy default, entries are scaled to the interval [0,1] before\n\tdetermining colors from the color map.  That means the two plots\n\tbelow are the same::\n\n\t\tsage: P = matrix_plot(matrix(2,[1,1,3,3]))\n\t\tsage: Q = matrix_plot(matrix(2,[2,2,3,3]))\n\t\tsage: P; Q\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHowever, we can specify which values scale to 0 or 1 with the\n\t``vmin`` and ``vmax`` parameters (values outside the range are\n\tclipped).  The two plots below are now distinguished::\n\n\t\tsage: P = matrix_plot(matrix(2,[1,1,3,3]), vmin=0, vmax=3, colorbar=True)\n\t\tsage: Q = matrix_plot(matrix(2,[2,2,3,3]), vmin=0, vmax=3, colorbar=True)\n\t\tsage: P; Q\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can also specify a norm function of 'value', which means that\n\tthere is no scaling performed::\n\n\t\tsage: matrix_plot(random_matrix(ZZ,10)*.05, norm='value', colorbar=True)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tMatrix subdivisions can be plotted as well::\n\n\t\tsage: m=random_matrix(RR,10)\n\t\tsage: m.subdivide([2,4],[6,8])\n\t\tsage: matrix_plot(m, subdivisions=True, subdivision_style=dict(color='red',thickness=3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tYou can also specify your own subdivisions and separate styles\n\tfor row or column subdivisions::\n\n\t\tsage: m=random_matrix(RR,10)\n\t\tsage: matrix_plot(m, subdivisions=True, subdivision_boundaries=[[2,4],[6,8]], subdivision_style=[dict(color='red',thickness=3),dict(linestyle='--',thickness=6)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tGenerally matrices are plotted with the (0,0) entry in the upper\n\tleft.  However, sometimes if we are plotting an image, we'd like\n\tthe (0,0) entry to be in the lower left.  We can do that with the\n\t``origin`` argument::\n\n\t\tsage: matrix_plot(identity_matrix(100), origin='lower')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAnother random plot, but over `\\GF{389}`::\n\n\t\tsage: m = random_matrix(GF(389), 10)\n\t\tsage: matrix_plot(m, cmap='Oranges')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tIt also works if you lift it to the polynomial ring::\n\n\t\tsage: matrix_plot(m.change_ring(GF(389)['x']), cmap='Oranges')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe have several options for colorbars::\n\n\t\tsage: matrix_plot(random_matrix(RDF, 50), colorbar=True, colorbar_orientation='horizontal')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: matrix_plot(random_matrix(RDF, 50), colorbar=True, colorbar_format='%.3f')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tThe length of a color bar and the length of the adjacent\n\tmatrix plot dimension may be quite different.  This example\n\tshows how to adjust the length of the colorbar by passing a\n\tdictionary of options to the matplotlib colorbar routines.  ::\n\n\t\tsage: m = random_matrix(ZZ, 40, 80, x=-10, y=10)\n\t\tsage: m.plot(colorbar=True, colorbar_orientation='vertical',\n\t\t....:\t\tcolorbar_options={'shrink':0.50})\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere we plot a random sparse matrix::\n\n\t\tsage: sparse = matrix(dict([((randint(0, 10), randint(0, 10)), 1) for i in xrange(100)]))\n\t\tsage: matrix_plot(sparse)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: A=random_matrix(ZZ,100000,density=.00001,sparse=True)\n\t\tsage: matrix_plot(A,marker=',')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAs with dense matrices, sparse matrix entries are automatically\n\tconverted to floating point numbers before plotting.  Thus the\n\tfollowing works::\n\n\t\tsage: b=random_matrix(GF(2),200,sparse=True,density=0.01)\n\t\tsage: matrix_plot(b)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWhile this returns an error::\n\n\t\tsage: b=random_matrix(CDF,200,sparse=True,density=0.01)\n\t\tsage: matrix_plot(b)\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: can not convert entries to floating point numbers\n\n\tTo plot the absolute value of a complex matrix, use the\n\t``apply_map`` method::\n\n\t\tsage: b=random_matrix(CDF,200,sparse=True,density=0.01)\n\t\tsage: matrix_plot(b.apply_map(abs))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tPlotting lists of lists also works::\n\n\t\tsage: matrix_plot([[1,3,5,1],[2,4,5,6],[1,3,5,7]])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAs does plotting of NumPy arrays::\n\n\t\tsage: import numpy\n\t\tsage: matrix_plot(numpy.random.rand(10, 10))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA plot title can be added to the matrix plot.::\n\n\t\tsage: matrix_plot(identity_matrix(50), origin='lower', title='not identity')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tThe title position is adjusted upwards if the ``origin`` keyword is set\n\tto ``\"upper\"`` (this is the default).::\n\n\t\tsage: matrix_plot(identity_matrix(50), title='identity')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tTESTS::\n\n\t\tsage: P. = RR[]\n\t\tsage: matrix_plot(random_matrix(P, 3, 3))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tTypeError: cannot coerce nonconstant polynomial to float\n\n\t::\n\n\t\tsage: matrix_plot([1,2,3])\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tTypeError: mat must be a Matrix or a two dimensional array\n\n\t::\n\n\t\tsage: matrix_plot([[sin(x), cos(x)], [1, 0]])\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tTypeError: mat must be a Matrix or a two dimensional array\n\n\tTest that sparse matrices also work with subdivisions::\n\n\t\tsage: matrix_plot(sparse, subdivisions=True, subdivision_boundaries=[[2,4],[6,8]])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tTest that matrix plots have aspect ratio one (see :trac:`15315`)::\n\n\t\tsage: P = matrix_plot(random_matrix(RDF, 5))\n\t\tsage: P.aspect_ratio()\n\t\t1\n\t", "category": "graphics", "imports": ["from sage.plot.primitive import GraphicPrimitive", "from sage.misc.decorators import options, suboptions", "from sage.plot.colors import get_cmap", "\t\tsage: from sage.plot.matrix_plot import MatrixPlot", "\t\tfrom sage.plot.plot import minmax_data", "\t\t\t\t\t\tmatplotlib Colormap. Type: import matplotlib.cm; matplotlib.cm.datad.keys()", "\t\t\timport matplotlib", "\t\t\tfrom line import line2d", "\t\t\t\tfrom matplotlib import colorbar", "\t  Type: ``import matplotlib.cm; matplotlib.cm.datad.keys()``", "\t\tsage: import numpy", "\timport numpy as np", "\timport scipy.sparse as scipysparse", "\tfrom sage.plot.all import Graphics", "\tfrom sage.matrix.matrix import is_Matrix", "\tfrom sage.rings.all import RDF"]}], [{"term": "def", "name": "f_fromUtf8", "data": "\tdef _fromUtf8(s):\n\t\treturn s\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtCore, QtGui", "\timport sys"]}, {"term": "def", "name": "f_translate", "data": "\tdef _translate(context, text, disambig):\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtCore, QtGui", "\timport sys"]}, {"term": "def", "name": "f_translate", "data": "\tdef _translate(context, text, disambig):\n\t\treturn QtGui.QApplication.translate(context, text, disambig)\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtCore, QtGui", "\timport sys"]}, {"term": "class", "name": "Ui_MainWindow", "data": "class Ui_MainWindow(object):\n\tdef setupUi(self, MainWindow):\n\t\tMainWindow.setObjectName(_fromUtf8(\"MainWindow\"))\n\t\tMainWindow.resize(943, 616)\n\t\tself.centralwidget = QtGui.QWidget(MainWindow)\n\t\tself.centralwidget.setObjectName(_fromUtf8(\"centralwidget\"))\n\t\tself.horizontalLayout_2 = QtGui.QHBoxLayout(self.centralwidget)\n\t\tself.horizontalLayout_2.setObjectName(_fromUtf8(\"horizontalLayout_2\"))\n\n\t\tself.verticalLayout_3 = QtGui.QVBoxLayout()\n\t\tself.verticalLayout_3.setObjectName(_fromUtf8(\"verticalLayout_3\"))\n\t\tself.graphicsView = QtGui.QGraphicsView(self.centralwidget)\n\t\tself.graphicsView.setObjectName(_fromUtf8(\"graphicsView\"))\n\t\tself.verticalLayout_3.addWidget(self.graphicsView)\n\t\tself.graphicsView_2 = QtGui.QGraphicsView(self.centralwidget)\n\t\tself.graphicsView_2.setObjectName(_fromUtf8(\"graphicsView_2\"))\n\t\tself.verticalLayout_3.addWidget(self.graphicsView_2)\n\t\tself.horizontalLayout_2.addLayout(self.verticalLayout_3)\n\n\t\tself.verticalLayout_4 = QtGui.QVBoxLayout()\n\t\tself.verticalLayout_4.setObjectName(_fromUtf8(\"verticalLayout_4\"))\n\t\tself.graphicsView_3 = QtGui.QGraphicsView(self.centralwidget)\n\t\tself.graphicsView_3.setObjectName(_fromUtf8(\"graphicsView_3\"))\n\t\tself.verticalLayout_4.addWidget(self.graphicsView_3)\n\t\tself.graphicsView_4 = QtGui.QGraphicsView(self.centralwidget)\n\t\tself.graphicsView_4.setObjectName(_fromUtf8(\"graphicsView_4\"))\n\t\tself.verticalLayout_4.addWidget(self.graphicsView_4)\n\t\tself.horizontalLayout_2.addLayout(self.verticalLayout_4)\n\n\n\t\tself.pushButton = QtGui.QPushButton(self.centralwidget)\n\t\tself.pushButton.setObjectName(_fromUtf8(\"pushButton\"))\n\t\tself.horizontalLayout_2.addWidget(self.pushButton)\n\n\t\tself.verticalLayout_5 = QtGui.QVBoxLayout()\n\t\tself.verticalLayout_5.setObjectName(_fromUtf8(\"verticalLayout_5\"))\n\n\t\tself.horizontalLayout_3 = QtGui.QHBoxLayout()\n\t\tself.graphicsView_5 = QtGui.QGraphicsView(self.centralwidget)\n\t\tself.graphicsView_5.setObjectName(_fromUtf8(\"graphicsView_5\"))\n\t\tself.graphicsView_6 = QtGui.QGraphicsView(self.centralwidget)\n\t\tself.graphicsView_6.setObjectName(_fromUtf8(\"graphicsView_6\"))\n\t\tself.horizontalLayout_3.addWidget(self.graphicsView_5)\n\t\tself.horizontalLayout_3.addWidget(self.graphicsView_6)\n\n\t\tself.graphicsView_7 = QtGui.QGraphicsView(self.centralwidget)\n\t\tself.graphicsView_7.setObjectName(_fromUtf8(\"graphicsView_7\"))\n\n\t\tself.verticalLayout_5.addLayout(self.horizontalLayout_3)\n\t\tself.verticalLayout_5.addWidget(self.graphicsView_7)\n\n\t\tself.horizontalLayout_2.addLayout(self.verticalLayout_5)\n\n\n\n\t\t# self.horizontalLayout = QtGui.QHBoxLayout()\n\t\t# self.horizontalLayout.setObjectName(_fromUtf8(\"horizontalLayout\"))\n\t\t# self.graphicsView_6 = QtGui.QGraphicsView(self.centralwidget)\n\t\t# self.graphicsView_6.setObjectName(_fromUtf8(\"graphicsView_6\"))\n\t\t# self.horizontalLayout.addWidget(self.graphicsView_6)\n\t\t# self.graphicsView_5 = QtGui.QGraphicsView(self.centralwidget)\n\t\t# self.graphicsView_5.setObjectName(_fromUtf8(\"graphicsView_5\"))\n\t\t# self.horizontalLayout.addWidget(self.graphicsView_5)\n\t\t# self.horizontalLayout_2.addLayout(self.horizontalLayout)\n\t\t# self.graphicsView_7 = QtGui.QGraphicsView(self.centralwidget)\n\t\t# self.graphicsView_7.setObjectName(_fromUtf8(\"graphicsView_7\"))\n\t\t# self.horizontalLayout_2.addWidget(self.graphicsView_7)\n\t\tMainWindow.setCentralWidget(self.centralwidget)\n\t\tself.statusbar = QtGui.QStatusBar(MainWindow)\n\t\tself.statusbar.setObjectName(_fromUtf8(\"statusbar\"))\n\t\tMainWindow.setStatusBar(self.statusbar)\n\n\t\tself.retranslateUi(MainWindow)\n\t\tQtCore.QMetaObject.connectSlotsByName(MainWindow)\n\n\tdef retranslateUi(self, MainWindow):\n\t\tMainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\", None))\n\t\tself.pushButton.setText(_translate(\"MainWindow\", \"Calibrate!\", None))\n\n", "description": null, "category": "graphics", "imports": ["from PyQt4 import QtCore, QtGui", "\timport sys"]}], [], [], [{"term": "def", "name": "get_graphics_xml", "data": "def get_graphics_xml(params):\n\t\"\"\"\n\t\n\n\t- For spice graphics:\n\n\t\n\n\n\t\"\"\"\n\tgraphics = E.graphics(type=params['type'], autoport='yes',\n\t\t\t\t\t\t  listen=params['listen'])\n\tgraphics_xml = ET.tostring(graphics, encoding='utf-8', pretty_print=True)\n\n\tif params['type'] == 'vnc':\n\t\treturn graphics_xml\n\n\t# For spice graphics, a channel also must be configured\n\tchannel = E.channel(type='spicevmc')\n\tchannel.append(E.target(type='virtio', name='com.redhat.spice.0'))\n\tchannel_xml = ET.tostring(channel, encoding='utf-8', pretty_print=True)\n\treturn graphics_xml + channel_xml\n", "description": "\n\t\n\n\t- For spice graphics:\n\n\t\n\n\n\t", "category": "graphics", "imports": ["import lxml.etree as ET", "from lxml.builder import E"]}], [], [], [], [], [], [{"term": "class", "name": "classGame:", "data": "class Game:\n\t\"\"\"Class joining game logic and graphics. Started should output fully playable game.\n\n\tAttributes:\n\t  board:\n\t  characters:\n\t  graphics:\n\t  points:\n\n\t\"\"\"\n\tdef __init__(self):\n\n\t\tpygame.init()\n\t\tmaze = os.path.join(os.getcwd(), \"data/map.txt\")\n\t\tself.board = Board.from_file(maze)\n\t\tself.best_score_file = os.path.join(os.getcwd(), \"data/best.txt\")\n\t\tself.initialize()\n\n\n\tdef initialize(self):\n\t\tGhost = characters_factory.new_ghost\n\t\tself.board.reset()\n\t\tself.game_over = False\n\t\tself.started = False\n\t\tself.characters = {\"blue\": Ghost(\"Blue\"),\n\t\t\t\t\t\t   \"red\": Ghost(\"Red\"),\n\t\t\t\t\t\t   \"pink\": Ghost(\"Pink\"),\n\t\t\t\t\t\t   \"orange\": Ghost(\"Orange\"),\n\t\t\t\t\t\t   \"pacman\": characters_factory.Pacman(),\n\t\t\t\t\t\t   \"cherry\": characters_factory.Cherry()\n\t\t\t\t\t\t  }\n\n\t\tself.ghosts = [self.characters[name] for name in [\"blue\", \"pink\", \"red\", \"orange\"]]\n\n\t\tfor c in self.characters.values():\n\t\t\tc.set_board(self.board)\n\t\t\tc.set_other_movable(self.characters)\n\n\t\tself.score = 0\n\t\tself.pacman = self.characters[\"pacman\"]\n\t\tself.graphics = Graphics(self.characters, self.board)\n\n\t\t#TODO: Set chase state to ghosts after n seconds\n\t\tself.characters[\"red\"].chase_state()\n\n\t\tif not os.path.isfile(self.best_score_file):\n\t\t\tself.best_score = 0\n\t\telse:\n\t\t\tf = open(self.best_score_file, \"r\")\n\t\t\tbest_score = f.read().replace(\"\\n\", \"\")\n\t\t\tf.close()\n\t\t\tif best_score.isdigit():\n\t\t\t\tself.best_score = int(best_score)\n\t\t\telse:\n\t\t\t\tprint('ERROR WHILE READING BEST SCORE!')\n\t\t\t\tself.best_score = 0\n\n\t\tself.graphics.print_best_score(self.best_score)\n\t\tself.graphics.print_pacman_lifes(self.pacman.lifes)\n\t\tself.i = 0\n\n\tdef step(self):\n\t\t\"\"\"Performs one tick of a game, updating all its objects\"\"\"\n\t\tprev_lifes_nr = self.pacman.lifes\n\t\tfor name, character in self.characters.items():\n\t\t\tnewCords = character.step()\n\t\t\tif character.is_ghost():\n\t\t\t\tcharacter.set_target()\n\n\t\tif self.pacman.lifes == 0:\n\t\t\tself.graphics.print_game_over()\n\t\t\tself.game_over = True\n\n\t\tself.update_score()\n\t\tif self.pacman.lifes != prev_lifes_nr:\n\t\t\tself.graphics.pacman_life_minus()\n\t\t\tfor ghost in self.ghosts:\n\t\t\t\tghost.set_home()\n\t\t\t\tself.i = 0\n\t\t\t\tself.board.close_gate()\n\n\t\tself.graphics.update()\n\n\n\tdef start(self):\n\t\tself.clock = pygame.time.Clock()\n\t\tself.main_loop()\n\n\n\tdef main_loop(self):\n\t\twhile True:\n\t\t\tcurr = pygame.time.get_ticks()\n\t\t\tfor event in pygame.event.get():\n\t\t\t\tif event.type == pygame.QUIT:\n\t\t\t\t\tpygame.quit()\n\t\t\t\t\tsys.exit()\n\t\t\t\telif event.type == pygame.KEYDOWN:\n\t\t\t\t\tself.started = True\n\t\t\t\t\tif event.key == pygame.K_LEFT:\n\t\t\t\t\t\tself.pacman.set_velocity((-1,0))\n\t\t\t\t\telif event.key == pygame.K_RIGHT:\n\t\t\t\t\t\tself.pacman.set_velocity((1,0))\n\t\t\t\t\telif event.key == pygame.K_DOWN:\n\t\t\t\t\t\tself.pacman.set_velocity((0,1))\n\t\t\t\t\telif event.key == pygame.K_UP:\n\t\t\t\t\t\tself.pacman.set_velocity((0,-1))\n\t\t\t\t\telif event.key == pygame.K_SPACE and self.game_over:\n\t\t\t\t\t\tself.restart()\n\n\t\t\tif self.started and not self.game_over:\n\t\t\t\tself.clock.tick_busy_loop(5)\n\t\t\t\tself.step()\n\t\t\t\tif self.i < 21:\n\t\t\t\t\tself.i+=1\n\n\t\t\t\tif self.i == 20:\n\t\t\t\t\t#free another ghost wall y=12, x=13 , 14 dissapear\n\t\t\t\t\t# FIXME: If we open gate not instantly ghost do not leave box\n\t\t\t\t\tself.board.open_gate()\n\n\n\tdef restart(self):\n\t\tself.initialize()\n\n\n\tdef update_score(self):\n\t\t\"\"\"Calculates overall score based upon food pacman ate.\"\"\"\n\t\tpacman = self.pacman\n\t\tself.score = 10 * pacman.eatenFood + pacman.eatenSuperFood * 50 + pacman.eatenGhost * 200\n\t\t# Current score\n\t\tself.graphics.print_score(self.score)\n\t\tif self.game_over:\n\t\t\tif self.score > self.best_score:\n\t\t\t\tf = open(self.best_score_file, 'w')\n\t\t\t\tf.write(str(self.score))\n\t\t\t\tf.close()\n\t\t\t\tself.graphics.print_best_score(self.best_score)\n\n\n", "description": "Class joining game logic and graphics. Started should output fully playable game.\n\n\tAttributes:\n\t  board:\n\t  characters:\n\t  graphics:\n\t  points:\n\n\t", "category": "graphics", "imports": ["import pygame, sys, os", "from .board import Board", "from .graphics.graphics import Graphics", "from src.characters import characters_factory"]}], [], [], [], [], [{"term": "class", "name": "ImageCutter", "data": "class ImageCutter(QDialog, Ui_Dialog):\n\tsave_signal = Signal(QPixmap)\n\n\tdef __init__(self, image, name=None):\n\t\tsuper(ImageCutter, self).__init__()\n\t\tself.image = image\n\t\tself.setupUi(self)\n\t\tself.init_ui()\n\t\t# \u89c6\u56fe\u80cc\u666f\u989c\u8272\n\t\tself.setWindowTitle(f\"\u56fe\u7247\u9884\u5904\u7406 --- {name}\")\n\t\tself.initConnectSlot()\n\n\tdef init_ui(self):\n\t\twindow_icon = QIcon()\n\t\twindow_icon.addFile(u\"images/\u82b1\u6735(1).png\")\n\t\tself.setWindowIcon(window_icon)\n\t\tself.cutPushButton.setStyleSheet(u\"QPushButton{image: url(images/\u56fe\u7247\u526a\u5207.png);}\\n\"\n\t\t\t\t\t\t\t\t\t\t u\"QPushButton:hover{image: url(images/\u56fe\u7247\u526a\u5207.png);}\\n\"\n\t\t\t\t\t\t\t\t\t\t u\"QPushButton:pressed{image: url(images/\u526a\u5207.png); padding: 3px}\")\n\t\tself.graphicsView = GraphicsView(self.image, self)\n\t\tself.graphicsView.setBackgroundBrush(QColor(235, 255, 244))\n\t\tself.graphicsView.setGeometry(QRect(0, 0, 1101, 691))\n\t\tself.graphicsView.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n\t\tself.graphicsView.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n\n\tdef initConnectSlot(self):\n\t\t# self.graphicsView.save_signal.connect(self.savePushButton.setEnabled)\n\t\tself.cutPushButton.clicked.connect(self.pushButton_cut_clicked)\n\t\tself.savePushButton.clicked.connect(self.pushButton_save_clicked)\n\t\tself.rightRotateToolButton.clicked.connect(self.rightRotateToolButton_clicked)\n\t\tself.leftRotateToolButton.clicked.connect(self.leftRotateToolButton_clicked)\n\t\tself.horizontalFlipToolButton.clicked.connect(self.horizontalFlipToolButton_clicked)\n\t\tself.verticalFlipToolButton.clicked.connect(self.verticalFlipToolButton_clicked)\n\t\tself.rotationDial.valueChanged.connect(self.rotationDial_valueChanged)\n\t\tself.horizontalSliderBrightness.valueChanged.connect(self.horizontalSlider_valueChanged)\n\t\tself.horizontalSliderContrast.valueChanged.connect(self.horizontalSlider_valueChanged)\n\t\tself.horizontalSliderHues.valueChanged.connect(self.horizontalSlider_valueChanged)\n\t\tself.horizontalSliderSaturation.valueChanged.connect(self.horizontalSlider_valueChanged)\n\t\tself.brightness_label.installEventFilter(self)\n\t\tself.contrast_label.installEventFilter(self)\n\t\tself.hue_label.installEventFilter(self)\n\t\tself.saturation_label.installEventFilter(self)\n\n\tdef eventFilter(self, watched, event) -> bool:\n\t\tif watched == self.brightness_label:\n\t\t\tif event.type() == QEvent.MouseButtonDblClick:\n\t\t\t\tself.horizontalSliderBrightness.setValue(0)\n\t\tif watched == self.contrast_label:\n\t\t\tif event.type() == QEvent.MouseButtonDblClick:\n\t\t\t\tself.horizontalSliderContrast.setValue(0)\n\t\tif watched == self.hue_label:\n\t\t\tif event.type() == QEvent.MouseButtonDblClick:\n\t\t\t\tself.horizontalSliderHues.setValue(0)\n\t\tif watched == self.saturation_label:\n\t\t\tif event.type() == QEvent.MouseButtonDblClick:\n\t\t\t\tself.horizontalSliderSaturation.setValue(0)\n\t\treturn QDialog.eventFilter(self, watched, event)\n\n\tdef pushButton_cut_clicked(self):\n\t\tif self.graphicsView.image_item.is_start_cut:\n\t\t\tself.graphicsView.image_item.is_start_cut = False\n\t\t\tself.graphicsView.image_item.setCursor(Qt.OpenHandCursor)  # \u7bad\u5934\u5149\u6807\n\t\telse:\n\t\t\tself.graphicsView.image_item.is_start_cut = True\n\t\t\tself.graphicsView.image_item.setCursor(Qt.CrossCursor)  # \u5341\u5b57\u5149\u6807\n\n\tdef pushButton_save_clicked(self):\n\t\ttry:\n\t\t\tstart_point = QPointF(\n\t\t\t\tmin(self.graphicsView.image_item.start_point.x(), self.graphicsView.image_item.end_point.x()),\n\t\t\t\tmin(self.graphicsView.image_item.start_point.y(), self.graphicsView.image_item.end_point.y())\n\t\t\t)\n\t\t\tend_point = QPointF(\n\t\t\t\tmax(self.graphicsView.image_item.start_point.x(), self.graphicsView.image_item.end_point.x()),\n\t\t\t\tmax(self.graphicsView.image_item.start_point.y(), self.graphicsView.image_item.end_point.y()))\n\t\t\trect = QRect(start_point.toPoint(), end_point.toPoint())\n\t\t\tcropped_pixmap = self.graphicsView.image_item.pixmap().copy(rect)\n\t\t\tself.save_signal[QPixmap].emit(cropped_pixmap)\n\t\t\t# QMessageBox.information(self, \"\u5b8c\u6210\", \"\u56fe\u7247\u5904\u7406\u5b8c\u6210\uff01\", QMessageBox.Ok)\n\t\texcept AttributeError as e:\n\t\t\tprint(e)\n\t\tself.close()\n\n\tdef rightRotateToolButton_clicked(self):\n\t\tself.graphicsView.img_signal.emit(0)\n\n\tdef leftRotateToolButton_clicked(self):\n\t\tself.graphicsView.img_signal.emit(1)\n\n\tdef horizontalFlipToolButton_clicked(self):\n\t\tself.graphicsView.img_signal.emit(2)\n\n\tdef verticalFlipToolButton_clicked(self):\n\t\tself.graphicsView.img_signal.emit(3)\n\n\tdef rotationDial_valueChanged(self):\n\t\tself.graphicsView.img_rotation_signal.emit(self.rotationDial.value())\n\n\tdef horizontalSlider_valueChanged(self):\n\t\tbrightness = self.horizontalSliderBrightness.value()\n\t\tcontrast = self.horizontalSliderContrast.value()\n\t\thue = self.horizontalSliderHues.value()\n\t\tsaturation = self.horizontalSliderSaturation.value()\n\t\tself.graphicsView.img_attribute_signal.emit(brightness / 200, contrast, hue / 200, saturation)\n\n", "description": null, "category": "graphics", "imports": ["from PySide6.QtCore import Qt, QRect, Signal, QPointF, QEvent", "from PySide6.QtGui import QColor, QPixmap, QIcon", "from PySide6.QtWidgets import QApplication, QDialog", "from my_graphics_view import GraphicsView", "from ui_my_cutter import Ui_Dialog", "\timport sys"]}], [{"term": "def", "name": "PreStepUF", "data": "def PreStepUF(mbs, t):\n\tif useKT:\n\t\t[u,v,a] = bodyTrajectory.Evaluate(t)\n\t\n\t\t#in case of kinematic tree, very simple operations!\n\t\tmbs.SetObjectParameter(oKTarticulatedBody, 'jointPositionOffsetVector', u)\n\t\tmbs.SetObjectParameter(oKTarticulatedBody, 'jointVelocityOffsetVector', v)\n\t\t# if compensateStaticTorques:\n\t\t# mbs.SetObjectParameter(oKTarticulatedBody, 'jointForceVector', ComputeMBSstaticRobotTorques(articulatedBody))\n\tif addRobot:\n\t\t[u,v,a] = robotTrajectory.Evaluate(t)\n\t\n\t\t#in case of kinematic tree, very simple operations!\n\t\tmbs.SetObjectParameter(oKTrobot, 'jointPositionOffsetVector', u)\n\t\tmbs.SetObjectParameter(oKTrobot, 'jointVelocityOffsetVector', v)\n\t\t# if compensateStaticTorques:\n\t\t# mbs.SetObjectParameter(oKTrobot, 'jointForceVector', ComputeMBSstaticRobotTorques(articulatedBody))\n\t\n\treturn True\n", "description": null, "category": "graphics", "imports": ["import exudyn as exu", "from exudyn.itemInterface import *", "from exudyn.utilities import * #includes graphics and rigid body utilities", "import numpy as np", "from exudyn.robotics import *", "from exudyn.robotics.motion import Trajectory, ProfileConstantAcceleration, ProfilePTP", "from math import pi", "import copy", "import time", "\tfrom stl import mesh, Mode", "\tfrom exudyn.robotics.models import ManipulatorPuma560, ManipulatorUR5", "from exudyn.interactive import SolutionViewer", "\tfrom exudyn.plot import PlotSensor"]}], [{"term": "class", "name": "TGraphicsObject", "data": "class TGraphicsObject( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateGraphicsObject( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.GraphicsObject_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.GraphicsObject_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TFont", "data": "class TFont( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateFont( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Font_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Font_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TPen", "data": "class TPen( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreatePen( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Pen_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Pen_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBrush", "data": "class TBrush( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBrush( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Brush_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Brush_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TCanvas", "data": "class TCanvas( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateCanvas( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Canvas_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Canvas_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TGraphic", "data": "class TGraphic( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateGraphic( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Graphic_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Graphic_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TPicture", "data": "class TPicture( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreatePicture( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Picture_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Picture_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafileCanvas", "data": "class TMetafileCanvas( TCanvas ):\r\n\tdef Create( Self, AMetafile, ReferenceDevice ):\r\n\t\treturn _Graphics.CreateMetafileCanvas( Self, AMetafile, ReferenceDevice )\r\n\r\n\tdef CreateWithComment( Self, AMetafile, ReferenceDevice, CreatedBy, Description ):\r\n\t\treturn _Graphics.CreateWithCommentMetafileCanvas( Self, AMetafile, ReferenceDevice, CreatedBy, Description )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.MetafileCanvas_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.MetafileCanvas_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TSharedImage", "data": "class TSharedImage(TObject):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateSharedImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.SharedImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.SharedImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafileImage", "data": "class TMetafileImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateMetafileImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.MetafileImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.MetafileImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafile", "data": "class TMetafile( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateMetafile( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Metafile_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Metafile_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBitmapImage", "data": "class TBitmapImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBitmapImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.BitmapImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.BitmapImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBitmap", "data": "class TBitmap( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBitmap( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Bitmap_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Bitmap_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TIconImage", "data": "class TIconImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateIconImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.IconImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.IconImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TIcon", "data": "class TIcon( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateIcon( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Icon_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Icon_SetAttr( Self, Key, Value )\r\n\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}], [{"term": "class", "name": "TGraphicsObject", "data": "class TGraphicsObject( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateGraphicsObject( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.GraphicsObject_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.GraphicsObject_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TFont", "data": "class TFont( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateFont( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Font_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Font_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TPen", "data": "class TPen( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreatePen( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Pen_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Pen_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBrush", "data": "class TBrush( TGraphicsObject ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBrush( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Brush_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Brush_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TCanvas", "data": "class TCanvas( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateCanvas( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Canvas_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Canvas_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TGraphic", "data": "class TGraphic( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateGraphic( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Graphic_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Graphic_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TPicture", "data": "class TPicture( TPersistent ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreatePicture( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Picture_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Picture_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafileCanvas", "data": "class TMetafileCanvas( TCanvas ):\r\n\tdef Create( Self, AMetafile, ReferenceDevice ):\r\n\t\treturn _Graphics.CreateMetafileCanvas( Self, AMetafile, ReferenceDevice )\r\n\r\n\tdef CreateWithComment( Self, AMetafile, ReferenceDevice, CreatedBy, Description ):\r\n\t\treturn _Graphics.CreateWithCommentMetafileCanvas( Self, AMetafile, ReferenceDevice, CreatedBy, Description )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.MetafileCanvas_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.MetafileCanvas_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TSharedImage", "data": "class TSharedImage(TObject):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateSharedImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.SharedImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.SharedImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafileImage", "data": "class TMetafileImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateMetafileImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.MetafileImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.MetafileImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TMetafile", "data": "class TMetafile( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateMetafile( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Metafile_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Metafile_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBitmapImage", "data": "class TBitmapImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBitmapImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.BitmapImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.BitmapImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TBitmap", "data": "class TBitmap( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateBitmap( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Bitmap_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Bitmap_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TIconImage", "data": "class TIconImage( TSharedImage ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateIconImage( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.IconImage_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.IconImage_SetAttr( Self, Key, Value )\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}, {"term": "class", "name": "TIcon", "data": "class TIcon( TGraphic ):\r\n\tdef Create( Self ):\r\n\t\treturn _Graphics.CreateIcon( Self )\r\n\r\n\tdef __getattr__( Self, Key ):\r\n\t\treturn _Graphics.Icon_GetAttr( Self, Key )\r\n\r\n\tdef __setattr__( Self, Key, Value ):\r\n\t\treturn _Graphics.Icon_SetAttr( Self, Key, Value )\r\n\r\n", "description": null, "category": "graphics", "imports": ["from System import *\r", "from Classes import *\r", "import _Graphics\r"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tglobal NUM_LIVES\n\t# Make the ball move\n\tvx = graphics.get_vx()\n\tvy = graphics.get_vy()\n\tgraphics.ball.move(vx, vy)\n\t# Add the animation loop here!\n\twhile True:\n\t\tvx = graphics.get_vx()\n\t\tvy = graphics.get_vy()\n\t\tgraphics.ball.move(vx, vy)\n\n\t\t# Check boundary\n\t\tif graphics.ball.x < 0 or graphics.ball.x > graphics.window.width - graphics.ball.width:\n\t\t\tgraphics.set_vx()\n\t\tif graphics.ball.y < 0:\n\t\t\tgraphics.set_vy()\n\t\t# The ball drops, lose one live\n\t\tif graphics.ball.y > graphics.window.height - graphics.ball.height:\n\t\t\tNUM_LIVES -= 1\n\t\t\t# Reset the position of the ball in the start point\n\t\t\tif NUM_LIVES > 0:\n\t\t\t\tgraphics.set_ball_position()\n\t\t# When you win or lose the game, break the loop.\n\t\tif graphics.del_bricks == graphics.total or NUM_LIVES == 0:\n\t\t\tbreak\n\t\tgraphics.check_paddle()\n\t\tgraphics.check_bricks()\n\t\tpause(FRAME_RATE)\n\tif graphics.del_bricks == graphics.total:\n\t\tgraphics.win_game()\n\tif NUM_LIVES == 0:\n\t\tgraphics.lose_game()\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "class", "name": ",bar_chart,Axesclassusage", "data": "  arrow, bar_chart, Axes class usage (see axes.py)\n", "description": null, "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "_plot", "data": "def _plot(funcs, xrange, parametric=False,\n\t\t\t  polar=False, fill=False, label='', randomize=True, **options):\n\t\"\"\"\n\tInternal function which does the actual plotting.\n\n\tINPUT:\n\n\t- ``funcs`` - function or list of functions to be plotted\n\t- ``xrange`` - two or three tuple of [input variable], min and max\n\t- ``parametric`` - (default: False) a boolean for whether\n\t  this is a parametric plot\n\t- ``polar`` - (default: False) a boolean for whether\n\t  this is a polar plot\n\t- ``fill`` - (default: False) an input for whether\n\t  this plot is filled\n\t- ``randomize`` - (default: True) a boolean for whether\n\t  to use random plot points\n\n\tThe following option is deprecated in favor of ``legend_label``:\n\n\t- ``label`` - (default: '') a string for the label\n\n\tAll other usual plot options are also accepted, and a number\n\tare required (see the example below) which are normally passed\n\tthrough the options decorator to :func:`plot`.\n\n\tOUTPUT:\n\n\t- A ``Graphics`` object\n\n\tEXAMPLES::\n\n\tSee :func:`plot` for many, many implicit examples.\n\tHere is an explicit one::\n\n\t\tsage: from sage.plot.plot import _plot\n\t\tsage: P = _plot(e^(-x^2),(-3,3),fill=True,color='red',plot_points=50,adaptive_tolerance=2,adaptive_recursion=True,exclude=None)\n\t\tsage: P.show(aspect_ratio='automatic')\n\n\tTESTS:\n\n\tMake sure that we get the right number of legend entries as the number of\n\tfunctions varies (:trac:`10514`)::\n\n\t\tsage: p1 = plot(1*x, legend_label='1x')\n\t\tsage: p2 = plot(2*x, legend_label='2x', color='green')\n\t\tsage: p1+p2\n\t\tGraphics object consisting of 2 graphics primitives\n\n\t::\n\n\t\tsage: len(p1.matplotlib().axes[0].legend().texts)\n\t\t1\n\t\tsage: len((p1+p2).matplotlib().axes[0].legend().texts)\n\t\t2\n\t\tsage: q1 = plot([sin(x), tan(x)], legend_label='trig')\n\t\tsage: len((q1).matplotlib().axes[0].legend().texts) # used to raise AttributeError\n\t\t1\n\t\tsage: q1\n\t\tGraphics object consisting of 2 graphics primitives\n\n\t::\n\n\tMake sure that we don't get multiple legend labels for plot segments\n\t(:trac:`11998`)::\n\n\t\tsage: p1 = plot(1/(x^2-1),(x,-2,2),legend_label=\"foo\",detect_poles=True)\n\t\tsage: len(p1.matplotlib().axes[0].legend().texts)\n\t\t1\n\t\tsage: p1.show(ymin=-10,ymax=10) # should be one legend\n\n\tParametric plots that get evaluated at invalid points should still\n\tplot properly (:trac:`13246`)::\n\n\t\tsage: parametric_plot((x, arcsec(x)), (x, -2, 2))\n\t\tGraphics object consisting of 2 graphics primitives\n\n\t\"\"\"\n\n\tfrom sage.plot.misc import setup_for_eval_on_grid\n\tif funcs == []:\n\t\treturn Graphics()\n\texcluded_points = []\n\tfuncs, ranges = setup_for_eval_on_grid(funcs, [xrange], options['plot_points'])\n\txmin, xmax, delta = ranges[0]\n\txrange=ranges[0][:2]\n\t#parametric_plot will be a list or tuple of two functions (f,g)\n\t#and will plotted as (f(x), g(x)) for all x in the given range\n\tif parametric:\n\t\tf, g = funcs\n\t#or we have only a single function to be plotted:\n\telse:\n\t\tf = funcs\n\n\t#check to see if funcs is a list of functions that will\n\t#be all plotted together.\n\tif isinstance(funcs, (list, tuple)) and not parametric:\n\t\tfrom sage.plot.colors import rainbow\n\t\trainbow_colors = rainbow(len(funcs))\n\n\t\tG = Graphics()\n\t\tfor i, h in enumerate(funcs):\n\t\t\tif isinstance(fill, dict):\n\t\t\t\tif i in fill:\n\t\t\t\t\tfill_entry = fill[i]\n\t\t\t\t\tif isinstance(fill_entry, list):\n\t\t\t\t\t\tif fill_entry[0] < len(funcs):\n\t\t\t\t\t\t\tfill_temp = funcs[fill_entry[0]]\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tfill_temp = None\n\t\t\t\t\telse:\n\t\t\t\t\t\tfill_temp = fill_entry\n\t\t\t\telse:\n\t\t\t\t\tfill_temp = None\n\t\t\telse:\n\t\t\t\tfill_temp = fill\n\n\t\t\toptions_temp = options.copy()\n\t\t\tfillcolor_temp = options_temp.pop('fillcolor', 'automatic')\n\t\t\tif i >= 1:\n\t\t\t\tlegend_label=options_temp.pop('legend_label', None) # legend_label popped so the label isn't repeated for nothing\n\t\t\tif fillcolor_temp == 'automatic':\n\t\t\t\tfillcolor_temp = rainbow_colors[i]\n\n\t\t\tG += plot(h, xrange, polar = polar, fill = fill_temp, \\\n\t\t\t\t\t  fillcolor = fillcolor_temp, **options_temp)\n\t\treturn G\n\n\tadaptive_tolerance = options.pop('adaptive_tolerance')\n\tadaptive_recursion = options.pop('adaptive_recursion')\n\tplot_points = int(options.pop('plot_points'))\n\n\texclude = options.pop('exclude')\n\tif exclude is not None:\n\t\tfrom sage.symbolic.expression import Expression\n\t\tif isinstance(exclude, Expression) and exclude.is_relational() == True:\n\t\t\tif len(exclude.variables()) > 1:\n\t\t\t\traise ValueError('exclude has to be an equation of only one variable')\n\t\t\tv = exclude.variables()[0]\n\t\t\tpoints = [e.right() for e in exclude.solve(v) if e.left() == v and (v not in e.right().variables())]\n\t\t\t# We are only interested in real solutions\n\t\t\tfor x in points:\n\t\t\t\ttry:\n\t\t\t\t\texcluded_points.append(float(x))\n\t\t\t\texcept TypeError:\n\t\t\t\t\tpass\n\t\t\texcluded_points.sort()\n\n\t\t# We should either have a list in excluded points or exclude\n\t\t# itself must be a list\n\t\telif isinstance(exclude, (list, tuple)):\n\t\t\texcluded_points = sorted(exclude)\n\t\telse:\n\t\t\traise ValueError('exclude needs to be a list of numbers or an equation')\n\n\t\t# We make sure that points plot points close to the excluded points are computed\n\t\tepsilon = 0.001*(xmax - xmin)\n\t\tinitial_points = reduce(lambda a,b: a+b,\n\t\t\t\t\t\t\t\t[[x - epsilon, x + epsilon]\n\t\t\t\t\t\t\t\t for x in excluded_points], [])\n\t\tdata = generate_plot_points(f, xrange, plot_points,\n\t\t\t\t\t\t\t\t\tadaptive_tolerance, adaptive_recursion,\n\t\t\t\t\t\t\t\t\trandomize, initial_points)\n\telse:\n\t\tdata = generate_plot_points(f, xrange, plot_points,\n\t\t\t\t\t\t\t\t\tadaptive_tolerance, adaptive_recursion,\n\t\t\t\t\t\t\t\t\trandomize)\n\n\n\tfor i in range(len(data)-1):\n\t\t# If the difference between consecutive x-values is more than\n\t\t# 2 times the difference between two consecutive plot points, then\n\t\t# add an exclusion point.\n\t\tif abs(data[i+1][0] - data[i][0]) > 2*abs(xmax - xmin)/plot_points:\n\t\t\texcluded_points.append((data[i][0] + data[i+1][0])/2)\n\n\tif parametric:\n\t\t# We need the original x-values to be able to exclude points in parametric plots\n\t\texclude_data = data\n\t\tnewdata = []\n\t\tfor x,fdata in data:\n\t\t\ttry:\n\t\t\t\tnewdata.append((fdata, g(x)))\n\t\t\texcept (ValueError, TypeError):\n\t\t\t\tnewdata.append((fdata, 0)) # append a dummy value 0\n\t\t\t\texcluded_points.append(x)\n\t\tdata = newdata\n\n\texcluded_points.sort(reverse=True)\n\tG = Graphics()\n\n\tfillcolor = options.pop('fillcolor', 'automatic')\n\tfillalpha = options.pop('fillalpha', 0.5)\n\n\t# TODO: Use matplotlib's fill and fill_between commands.\n\tif fill is not False and fill is not None:\n\t\tif parametric:\n\t\t\tfilldata = data\n\t\telse:\n\t\t\tif fill == 'axis' or fill is True:\n\t\t\t\tbase_level = 0\n\t\t\telif fill == 'min':\n\t\t\t\tbase_level = min(t[1] for t in data)\n\t\t\telif fill == 'max':\n\t\t\t\tbase_level = max(t[1] for t in data)\n\t\t\telif hasattr(fill, '__call__'):\n\t\t\t\tif fill == max or fill == min:\n\t\t\t\t\tif fill == max:\n\t\t\t\t\t\tfstr = 'max'\n\t\t\t\t\telse:\n\t\t\t\t\t\tfstr = 'min'\n\t\t\t\t\tmsg = \"WARNING: You use the built-in function %s for filling. You probably wanted the string '%s'.\" % (fstr, fstr)\n\t\t\t\t\tsage.misc.misc.verbose(msg, level=0)\n\t\t\t\tif not is_fast_float(fill):\n\t\t\t\t\tfill_f = fast_float(fill, expect_one_var=True)\n\t\t\t\telse:\n\t\t\t\t\tfill_f = fill\n\n\t\t\t\tfilldata = generate_plot_points(fill_f, xrange, plot_points, adaptive_tolerance, \\\n\t\t\t\t\t\t\t\t\t\t\t\tadaptive_recursion, randomize)\n\t\t\t\tfilldata.reverse()\n\t\t\t\tfilldata += data\n\t\t\telse:\n\t\t\t\ttry:\n\t\t\t\t\tbase_level = float(fill)\n\t\t\t\texcept TypeError:\n\t\t\t\t\tbase_level = 0\n\n\t\t\tif not hasattr(fill, '__call__') and polar:\n\t\t\t\tfilldata = generate_plot_points(lambda x: base_level, xrange, plot_points, adaptive_tolerance, \\\n\t\t\t\t\t\t\t\t\t\t\t\tadaptive_recursion, randomize)\n\t\t\t\tfilldata.reverse()\n\t\t\t\tfilldata += data\n\t\t\tif not hasattr(fill, '__call__') and not polar:\n\t\t\t\tfilldata = [(data[0][0], base_level)] + data + [(data[-1][0], base_level)]\n\n\t\tif fillcolor == 'automatic':\n\t\t\tfillcolor = (0.5, 0.5, 0.5)\n\t\tfill_options = {}\n\t\tfill_options['rgbcolor'] = fillcolor\n\t\tfill_options['alpha'] = fillalpha\n\t\tfill_options['thickness'] = 0\n\t\tif polar:\n\t\t\tfilldata = [(y*cos(x), y*sin(x)) for x, y in filldata]\n\t\tG += polygon(filldata, **fill_options)\n\n\t# We need the original data to be able to exclude points in polar plots\n\tif not parametric:\n\t\texclude_data = data\n\tif polar:\n\t\tdata = [(y*cos(x), y*sin(x)) for x, y in data]\n\n\tfrom sage.plot.all import line, text\n\n\tdetect_poles = options.pop('detect_poles', False)\n\tlegend_label = options.pop('legend_label', None)\n\tif excluded_points or detect_poles != False:\n\t\tstart_index = 0\n\t\t# setup for pole detection\n\t\tfrom sage.rings.all import RDF\n\t\tepsilon = 0.0001\n\t\tpole_options = {}\n\t\tpole_options['linestyle'] = '--'\n\t\tpole_options['thickness'] = 1\n\t\tpole_options['rgbcolor'] = '#ccc'\n\n\t\t# setup for exclusion points\n\t\texclusion_point = 0\n\t\tif excluded_points:\n\t\t\texclusion_point = excluded_points.pop()\n\n\t\tflag = True\n\t\tfor i in range(len(data)-1):\n\t\t\tx0, y0 = exclude_data[i]\n\t\t\tx1, y1 = exclude_data[i+1]\n\n\t\t\t# detect poles\n\t\t\tif (not (polar or parametric)) and detect_poles != False \\\n\t\t\t   and ((y1 > 0 and y0 < 0) or (y1 < 0 and y0 > 0)):\n\t\t\t\t# calculate the slope of the line segment\n\t\t\t\tdy = abs(y1-y0)\n\t\t\t\tdx = x1 - x0\n\t\t\t\talpha = (RDF(dy)/RDF(dx)).arctan()\n\t\t\t\tif alpha >= RDF(pi/2) - epsilon:\n\t\t\t\t\tG += line(data[start_index:i], **options)\n\t\t\t\t\tif detect_poles == 'show':\n\t\t\t\t\t\t# draw a vertical asymptote\n\t\t\t\t\t\tG += line([(x0, y0), (x1, y1)], **pole_options)\n\t\t\t\t\tstart_index = i+2\n\n\t\t\t# exclude points\n\t\t\tif x0 > exclusion_point:\n\t\t\t\twhile exclusion_point <= x1:\n\t\t\t\t\ttry:\n\t\t\t\t\t\texclusion_point = excluded_points.pop()\n\t\t\t\t\texcept IndexError:\n\t\t\t\t\t\t# all excluded points were considered\n\t\t\t\t\t\tflag = False\n\t\t\t\t\t\tbreak\n\n\t\t\telif flag and (x0 <= exclusion_point <= x1):\n\t\t\t\tG += line(data[start_index:i], **options)\n\t\t\t\tstart_index = i + 2\n\t\t\t\twhile exclusion_point <= x1:\n\t\t\t\t\ttry:\n\t\t\t\t\t\texclusion_point = excluded_points.pop()\n\t\t\t\t\texcept IndexError:\n\t\t\t\t\t\t# all excluded points were considered\n\t\t\t\t\t\tflag = False\n\t\t\t\t\t\tbreak\n\n\t\tG += line(data[start_index:], legend_label=legend_label, **options)\n\telse:\n\t\tG += line(data, legend_label=legend_label, **options)\n\n\t# Label?\n\tif label:\n\t\tfrom sage.misc.superseded import deprecation\n\t\tdeprecation(4342, \"Consider using legend_label instead\")\n\t\tlabel = '  '+str(label)\n\t\tG += text(label, data[-1], horizontal_alignment='left',\n\t\t\t\t  vertical_alignment='center')\n\n\treturn G\n\n\n\n", "description": "\n\tInternal function which does the actual plotting.\n\n\tINPUT:\n\n\t- ``funcs`` - function or list of functions to be plotted\n\t- ``xrange`` - two or three tuple of [input variable], min and max\n\t- ``parametric`` - (default: False) a boolean for whether\n\t  this is a parametric plot\n\t- ``polar`` - (default: False) a boolean for whether\n\t  this is a polar plot\n\t- ``fill`` - (default: False) an input for whether\n\t  this plot is filled\n\t- ``randomize`` - (default: True) a boolean for whether\n\t  to use random plot points\n\n\tThe following option is deprecated in favor of ``legend_label``:\n\n\t- ``label`` - (default: '') a string for the label\n\n\tAll other usual plot options are also accepted, and a number\n\tare required (see the example below) which are normally passed\n\tthrough the options decorator to :func:`plot`.\n\n\tOUTPUT:\n\n\t- A ``Graphics`` object\n\n\tEXAMPLES::\n\n\tSee :func:`plot` for many, many implicit examples.\n\tHere is an explicit one::\n\n\t\tsage: from sage.plot.plot import _plot\n\t\tsage: P = _plot(e^(-x^2),(-3,3),fill=True,color='red',plot_points=50,adaptive_tolerance=2,adaptive_recursion=True,exclude=None)\n\t\tsage: P.show(aspect_ratio='automatic')\n\n\tTESTS:\n\n\tMake sure that we get the right number of legend entries as the number of\n\tfunctions varies (:trac:`10514`)::\n\n\t\tsage: p1 = plot(1*x, legend_label='1x')\n\t\tsage: p2 = plot(2*x, legend_label='2x', color='green')\n\t\tsage: p1+p2\n\t\tGraphics object consisting of 2 graphics primitives\n\n\t::\n\n\t\tsage: len(p1.matplotlib().axes[0].legend().texts)\n\t\t1\n\t\tsage: len((p1+p2).matplotlib().axes[0].legend().texts)\n\t\t2\n\t\tsage: q1 = plot([sin(x), tan(x)], legend_label='trig')\n\t\tsage: len((q1).matplotlib().axes[0].legend().texts) # used to raise AttributeError\n\t\t1\n\t\tsage: q1\n\t\tGraphics object consisting of 2 graphics primitives\n\n\t::\n\n\tMake sure that we don't get multiple legend labels for plot segments\n\t(:trac:`11998`)::\n\n\t\tsage: p1 = plot(1/(x^2-1),(x,-2,2),legend_label=\"foo\",detect_poles=True)\n\t\tsage: len(p1.matplotlib().axes[0].legend().texts)\n\t\t1\n\t\tsage: p1.show(ymin=-10,ymax=10) # should be one legend\n\n\tParametric plots that get evaluated at invalid points should still\n\tplot properly (:trac:`13246`)::\n\n\t\tsage: parametric_plot((x, arcsec(x)), (x, -2, 2))\n\t\tGraphics object consisting of 2 graphics primitives\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "parametric_plot", "data": "def parametric_plot(funcs, *args, **kwargs):\n\tr\"\"\"\n\tPlot a parametric curve or surface in 2d or 3d.\n\n\t:func:`parametric_plot` takes two or three functions as a\n\tlist or a tuple and makes a plot with the first function giving the\n\t`x` coordinates, the second function giving the `y`\n\tcoordinates, and the third function (if present) giving the\n\t`z` coordinates.\n\n\tIn the 2d case, :func:`parametric_plot` is equivalent to the :func:`plot` command\n\twith the option ``parametric=True``.  In the 3d case, :func:`parametric_plot`\n\tis equivalent to :func:`~sage.plot.plot3d.parametric_plot3d.parametric_plot3d`.\n\tSee each of these functions for more help and examples.\n\n\tINPUT:\n\n\n\t-  ``funcs`` - 2 or 3-tuple of functions, or a vector of dimension 2 or 3.\n\n\t-  ``other options`` - passed to :func:`plot` or :func:`~sage.plot.plot3d.parametric_plot3d.parametric_plot3d`\n\n\n\tEXAMPLES: We draw some 2d parametric plots.  Note that the default aspect ratio\n\tis 1, so that circles look like circles. ::\n\n\t\tsage: t = var('t')\n\t\tsage: parametric_plot( (cos(t), sin(t)), (t, 0, 2*pi))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: parametric_plot( (sin(t), sin(2*t)), (t, 0, 2*pi), color=hue(0.6) )\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: parametric_plot((1, t), (t, 0, 4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tNote that in parametric_plot, there is only fill or no fill.\n\n\t::\n\n\t\tsage: parametric_plot((t, t^2), (t, -4, 4), fill = True)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tA filled Hypotrochoid::\n\n\t\tsage: parametric_plot([cos(x) + 2 * cos(x/4), sin(x) - 2 * sin(x/4)], (x,0, 8*pi), fill = True)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\t\tsage: parametric_plot( (5*cos(x), 5*sin(x), x), (x,-12, 12), plot_points=150, color=\"red\") # long time\n\t\tGraphics3d Object\n\n\t\tsage: y=var('y')\n\t\tsage: parametric_plot( (5*cos(x), x*y, cos(x*y)), (x, -4,4), (y,-4,4)) # long time`\n\t\tGraphics3d Object\n\n\t\tsage: t=var('t')\n\t\tsage: parametric_plot( vector((sin(t), sin(2*t))), (t, 0, 2*pi), color='green') # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: parametric_plot( vector([t, t+1, t^2]), (t, 0, 1)) # long time\n\t\tGraphics3d Object\n\n\tPlotting in logarithmic scale is possible with 2D plots. The keyword\n\t``aspect_ratio`` will be ignored if the scale is not ``'loglog'`` or\n\t``'linear'``.::\n\n\t\tsage: parametric_plot((x, x**2), (x, 1, 10), scale='loglog')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can also change the scale of the axes in the graphics just before\n\tdisplaying. In this case, the ``aspect_ratio`` must be specified as\n\t``'automatic'`` if the ``scale`` is set to ``'semilogx'`` or ``'semilogy'``. For\n\tother values of the ``scale`` parameter, any ``aspect_ratio`` can be\n\tused, or the keyword need not be provided.::\n\n\t\tsage: p = parametric_plot((x, x**2), (x, 1, 10))\n\t\tsage: p.show(scale='semilogy', aspect_ratio='automatic')\n\n\tTESTS::\n\n\t\tsage: parametric_plot((x, t^2), (x, -4, 4))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\n\t\tsage: parametric_plot((1, x+t), (x, -4, 4))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\n\t\tsage: parametric_plot((-t, x+t), (x, -4, 4))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\n\t\tsage: parametric_plot((1, x+t, y), (x, -4, 4), (t, -4, 4))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\n\t\tsage: parametric_plot((1, x, y), 0, 4)\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\t\"\"\"\n\tnum_ranges=0\n\tfor i in args:\n\t\tif isinstance(i, (list, tuple)):\n\t\t\tnum_ranges+=1\n\t\telse:\n\t\t\tbreak\n\n\tif num_ranges==0 and len(args)>=2:\n\t\tfrom sage.misc.superseded import deprecation\n\t\tdeprecation(7008, \"variable ranges to parametric_plot must be given as tuples, like (2,4) or (t,2,3)\")\n\t\targs=tuple(args)\n\t\tnum_ranges=1\n\n\tnum_funcs = len(funcs)\n\n\tnum_vars=len(sage.plot.misc.unify_arguments(funcs)[0])\n\tif num_vars>num_ranges:\n\t\traise ValueError(\"there are more variables than variable ranges\")\n\n\t# Reset aspect_ratio to 'automatic' in case scale is 'semilog[xy]'.\n\t# Otherwise matplotlib complains.\n\tscale = kwargs.get('scale', None)\n\tif isinstance(scale, (list, tuple)):\n\t\tscale = scale[0]\n\tif scale == 'semilogy' or scale == 'semilogx':\n\t\tkwargs['aspect_ratio'] = 'automatic'\n\n\tif num_funcs == 2 and num_ranges == 1:\n\t\tkwargs['parametric'] = True\n\t\treturn plot(funcs, *args, **kwargs)\n\telif (num_funcs == 3 and num_ranges <= 2):\n\t\treturn sage.plot.plot3d.parametric_plot3d.parametric_plot3d(funcs, *args, **kwargs)\n\telse:\n\t\traise ValueError(\"the number of functions and the number of variable ranges is not a supported combination for a 2d or 3d parametric plots\")\n", "description": "\n\tPlot a parametric curve or surface in 2d or 3d.\n\n\t:func:`parametric_plot` takes two or three functions as a\n\tlist or a tuple and makes a plot with the first function giving the\n\t`x` coordinates, the second function giving the `y`\n\tcoordinates, and the third function (if present) giving the\n\t`z` coordinates.\n\n\tIn the 2d case, :func:`parametric_plot` is equivalent to the :func:`plot` command\n\twith the option ``parametric=True``.  In the 3d case, :func:`parametric_plot`\n\tis equivalent to :func:`~sage.plot.plot3d.parametric_plot3d.parametric_plot3d`.\n\tSee each of these functions for more help and examples.\n\n\tINPUT:\n\n\n\t-  ``funcs`` - 2 or 3-tuple of functions, or a vector of dimension 2 or 3.\n\n\t-  ``other options`` - passed to :func:`plot` or :func:`~sage.plot.plot3d.parametric_plot3d.parametric_plot3d`\n\n\n\tEXAMPLES: We draw some 2d parametric plots.  Note that the default aspect ratio\n\tis 1, so that circles look like circles. ::\n\n\t\tsage: t = var('t')\n\t\tsage: parametric_plot( (cos(t), sin(t)), (t, 0, 2*pi))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: parametric_plot( (sin(t), sin(2*t)), (t, 0, 2*pi), color=hue(0.6) )\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: parametric_plot((1, t), (t, 0, 4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tNote that in parametric_plot, there is only fill or no fill.\n\n\t::\n\n\t\tsage: parametric_plot((t, t^2), (t, -4, 4), fill = True)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tA filled Hypotrochoid::\n\n\t\tsage: parametric_plot([cos(x) + 2 * cos(x/4), sin(x) - 2 * sin(x/4)], (x,0, 8*pi), fill = True)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\t\tsage: parametric_plot( (5*cos(x), 5*sin(x), x), (x,-12, 12), plot_points=150, color=\"red\") # long time\n\t\tGraphics3d Object\n\n\t\tsage: y=var('y')\n\t\tsage: parametric_plot( (5*cos(x), x*y, cos(x*y)), (x, -4,4), (y,-4,4)) # long time`\n\t\tGraphics3d Object\n\n\t\tsage: t=var('t')\n\t\tsage: parametric_plot( vector((sin(t), sin(2*t))), (t, 0, 2*pi), color='green') # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: parametric_plot( vector([t, t+1, t^2]), (t, 0, 1)) # long time\n\t\tGraphics3d Object\n\n\tPlotting in logarithmic scale is possible with 2D plots. The keyword\n\t``aspect_ratio`` will be ignored if the scale is not ``'loglog'`` or\n\t``'linear'``.::\n\n\t\tsage: parametric_plot((x, x**2), (x, 1, 10), scale='loglog')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can also change the scale of the axes in the graphics just before\n\tdisplaying. In this case, the ``aspect_ratio`` must be specified as\n\t``'automatic'`` if the ``scale`` is set to ``'semilogx'`` or ``'semilogy'``. For\n\tother values of the ``scale`` parameter, any ``aspect_ratio`` can be\n\tused, or the keyword need not be provided.::\n\n\t\tsage: p = parametric_plot((x, x**2), (x, 1, 10))\n\t\tsage: p.show(scale='semilogy', aspect_ratio='automatic')\n\n\tTESTS::\n\n\t\tsage: parametric_plot((x, t^2), (x, -4, 4))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\n\t\tsage: parametric_plot((1, x+t), (x, -4, 4))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\n\t\tsage: parametric_plot((-t, x+t), (x, -4, 4))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\n\t\tsage: parametric_plot((1, x+t, y), (x, -4, 4), (t, -4, 4))\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\n\t\tsage: parametric_plot((1, x, y), 0, 4)\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: there are more variables than variable ranges\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "polar_plot", "data": "def polar_plot(funcs, *args, **kwds):\n\tr\"\"\"\n\t``polar_plot`` takes a single function or a list or\n\ttuple of functions and plots them with polar coordinates in the given\n\tdomain.\n\n\tThis function is equivalent to the :func:`plot` command with the options\n\t``polar=True`` and ``aspect_ratio=1``. For more help on options,\n\tsee the documentation for :func:`plot`.\n\n\tINPUT:\n\n\t- ``funcs`` - a function\n\t- other options are passed to plot\n\n\tEXAMPLES:\n\n\tHere is a blue 8-leaved petal::\n\n\t\tsage: polar_plot(sin(5*x)^2, (x, 0, 2*pi), color='blue')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA red figure-8::\n\n\t\tsage: polar_plot(abs(sqrt(1 - sin(x)^2)), (x, 0, 2*pi), color='red')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA green limacon of Pascal::\n\n\t\tsage: polar_plot(2 + 2*cos(x), (x, 0, 2*pi), color=hue(0.3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tSeveral polar plots::\n\n\t\tsage: polar_plot([2*sin(x), 2*cos(x)], (x, 0, 2*pi))\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tA filled spiral::\n\n\t\tsage: polar_plot(sqrt, 0, 2 * pi, fill = True)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tFill the area between two functions::\n\n\t\tsage: polar_plot(cos(4*x) + 1.5, 0, 2*pi, fill=0.5 * cos(4*x) + 2.5, fillcolor='orange')\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tFill the area between several spirals::\n\n\t\tsage: polar_plot([(1.2+k*0.2)*log(x) for k in range(6)], 1, 3 * pi, fill = {0: [1], 2: [3], 4: [5]})\n\t\tGraphics object consisting of 9 graphics primitives\n\n\tExclude points at discontinuities::\n\n\t\tsage: polar_plot(log(floor(x)), (x, 1, 4*pi), exclude = [1..12])\n\t\tGraphics object consisting of 12 graphics primitives\n\n\t\"\"\"\n\tkwds['polar']=True\n\treturn plot(funcs, *args, **kwds)\n", "description": "\n\t``polar_plot`` takes a single function or a list or\n\ttuple of functions and plots them with polar coordinates in the given\n\tdomain.\n\n\tThis function is equivalent to the :func:`plot` command with the options\n\t``polar=True`` and ``aspect_ratio=1``. For more help on options,\n\tsee the documentation for :func:`plot`.\n\n\tINPUT:\n\n\t- ``funcs`` - a function\n\t- other options are passed to plot\n\n\tEXAMPLES:\n\n\tHere is a blue 8-leaved petal::\n\n\t\tsage: polar_plot(sin(5*x)^2, (x, 0, 2*pi), color='blue')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA red figure-8::\n\n\t\tsage: polar_plot(abs(sqrt(1 - sin(x)^2)), (x, 0, 2*pi), color='red')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA green limacon of Pascal::\n\n\t\tsage: polar_plot(2 + 2*cos(x), (x, 0, 2*pi), color=hue(0.3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tSeveral polar plots::\n\n\t\tsage: polar_plot([2*sin(x), 2*cos(x)], (x, 0, 2*pi))\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tA filled spiral::\n\n\t\tsage: polar_plot(sqrt, 0, 2 * pi, fill = True)\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tFill the area between two functions::\n\n\t\tsage: polar_plot(cos(4*x) + 1.5, 0, 2*pi, fill=0.5 * cos(4*x) + 2.5, fillcolor='orange')\n\t\tGraphics object consisting of 2 graphics primitives\n\n\tFill the area between several spirals::\n\n\t\tsage: polar_plot([(1.2+k*0.2)*log(x) for k in range(6)], 1, 3 * pi, fill = {0: [1], 2: [3], 4: [5]})\n\t\tGraphics object consisting of 9 graphics primitives\n\n\tExclude points at discontinuities::\n\n\t\tsage: polar_plot(log(floor(x)), (x, 1, 4*pi), exclude = [1..12])\n\t\tGraphics object consisting of 12 graphics primitives\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "list_plot", "data": "def list_plot(data, plotjoined=False, **kwargs):\n\tr\"\"\"\n\t``list_plot`` takes either a list of numbers, a list of tuples, a numpy\n\tarray, or a dictionary and plots the corresponding points.\n\n\tIf given a list of numbers (that is, not a list of tuples or lists),\n\t``list_plot`` forms a list of tuples ``(i, x_i)`` where ``i`` goes from\n\t0 to ``len(data)-1`` and ``x_i`` is the ``i``-th data value, and puts\n\tpoints at those tuple values.\n\n\t``list_plot`` will plot a list of complex numbers in the obvious\n\tway; any numbers for which\n\t:func:`CC()` makes sense will\n\twork.\n\n\t``list_plot`` also takes a list of tuples ``(x_i, y_i)`` where ``x_i``\n\tand ``y_i`` are the ``i``-th values representing the ``x``- and\n\t``y``-values, respectively.\n\n\tIf given a dictionary, ``list_plot`` interprets the keys as\n\t`x`-values and the values as `y`-values.\n\n\tThe ``plotjoined=True`` option tells ``list_plot`` to plot a line\n\tjoining all the data.\n\n\tIt is possible to pass empty dictionaries, lists, or tuples to\n\t``list_plot``. Doing so will plot nothing (returning an empty plot).\n\n\tEXAMPLES::\n\n\t\tsage: list_plot([i^2 for i in range(5)]) # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere are a bunch of random red points::\n\n\t\tsage: r = [(random(),random()) for _ in range(20)]\n\t\tsage: list_plot(r,color='red')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tThis gives all the random points joined in a purple line::\n\n\t\tsage: list_plot(r, plotjoined=True, color='purple')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tYou can provide a numpy array.::\n\n\t\tsage: import numpy\n\t\tsage: list_plot(numpy.arange(10))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: list_plot(numpy.array([[1,2], [2,3], [3,4]]))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tPlot a list of complex numbers::\n\n\t\tsage: list_plot([1, I, pi + I/2, CC(.25, .25)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: list_plot([exp(I*theta) for theta in [0, .2..pi]])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tNote that if your list of complex numbers are all actually real,\n\tthey get plotted as real values, so this\n\n\t::\n\n\t\tsage: list_plot([CDF(1), CDF(1/2), CDF(1/3)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tis the same as ``list_plot([1, 1/2, 1/3])`` -- it produces a plot of\n\tthe points `(0,1)`, `(1,1/2)`, and `(2,1/3)`.\n\n\tIf you have separate lists of `x` values and `y` values which you\n\twant to plot against each other, use the ``zip`` command to make a\n\tsingle list whose entries are pairs of `(x,y)` values, and feed\n\tthe result into ``list_plot``::\n\n\t\tsage: x_coords = [cos(t)^3 for t in srange(0, 2*pi, 0.02)]\n\t\tsage: y_coords = [sin(t)^3 for t in srange(0, 2*pi, 0.02)]\n\t\tsage: list_plot(zip(x_coords, y_coords))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tIf instead you try to pass the two lists as separate arguments,\n\tyou will get an error message::\n\n\t\tsage: list_plot(x_coords, y_coords)\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tTypeError: The second argument 'plotjoined' should be boolean (True or False).  If you meant to plot two lists 'x' and 'y' against each other, use 'list_plot(zip(x,y))'.\n\n\tDictionaries with numeric keys and values can be plotted::\n\n\t\tsage: list_plot({22: 3365, 27: 3295, 37: 3135, 42: 3020, 47: 2880, 52: 2735, 57: 2550})\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tPlotting in logarithmic scale is possible for 2D list plots.\n\tThere are two different syntaxes available::\n\n\t\tsage: yl = [2**k for k in range(20)]\n\t\tsage: list_plot(yl, scale='semilogy')  # long time  # log axis on vertical\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: list_plot_semilogy(yl)\t   # same\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t.. warning::\n\n\t\tIf ``plotjoined`` is ``False`` then the axis that is in log scale\n\t\tmust have all points strictly positive. For instance, the following\n\t\tplot will show no points in the figure since the points in the\n\t\thorizontal axis starts from `(0,1)`.\n\n\t\t::\n\n\t\t\tsage: list_plot(yl, scale='loglog')\t\t # both axes are log\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tInstead this will work. We drop the point `(0,1)`.::\n\n\t\t\tsage: list_plot(zip(range(1,len(yl)), yl[1:]), scale='loglog') # long time \n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe use :func:`list_plot_loglog` and plot in a different base.::\n\n\t\tsage: list_plot_loglog(zip(range(1,len(yl)), yl[1:]), base=2) # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can also change the scale of the axes in the graphics just before\n\tdisplaying::\n\n\t\tsage: G = list_plot(yl) # long time\n\t\tsage: G.show(scale=('semilogy', 2)) # long time\n\n\tTESTS:\n\n\tWe check to see whether elements of the Symbolic Ring are properly\n\thandled; see :trac:`16378` ::\n\n\t\tsage: list_plot([1+I, 2+I])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: list_plot([1+I, 2, CC(3+I)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: list_plot([2, SR(1), CC(1+i)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe check to see that the x/y min/max data are set correctly::\n\n\t\tsage: d = list_plot([(100,100), (120, 120)]).get_minmax_data()\n\t\tsage: d['xmin']\n\t\t100.0\n\t\tsage: d['ymin']\n\t\t100.0\n\t\"\"\"\n\tfrom sage.plot.all import line, point\n\ttry:\n\t\tif not data:\n\t\t\treturn Graphics()\n\texcept ValueError: # numpy raises ValueError if it is not empty\n\t\tpass\n\tif not isinstance(plotjoined, bool):\n\t\traise TypeError(\"The second argument 'plotjoined' should be boolean \"\n\t\t\t\t\t\"(True or False).  If you meant to plot two lists 'x' \"\n\t\t\t\t\t\"and 'y' against each other, use 'list_plot(zip(x,y))'.\")\n\tif isinstance(data, dict):\n\t\tif plotjoined:\n\t\t\tlist_data = sorted(list(data.iteritems()))\n\t\telse:\n\t\t\tlist_data = list(data.iteritems())\n\t\treturn list_plot(list_data, plotjoined=plotjoined, **kwargs)\n\ttry:\n\t\tfrom sage.rings.all import RDF\n\t\ttmp = RDF(data[0])\n\t\tdata = list(enumerate(data))\n\texcept TypeError: # we can get this TypeError if the element is a list\n\t\t\t\t\t  # or tuple or numpy array, or an element of CC, CDF\n\t\t# We also want to avoid doing CC(data[0]) here since it will go\n\t\t# through if data[0] is really a tuple and every element of the\n\t\t# data will be converted to a complex and later converted back to\n\t\t# a tuple.\n\t\t# So, the only other check we need to do is whether data[0] is an\n\t\t# element of the Symbolic Ring.\n\t\tif data[0] in sage.symbolic.ring.SR:\n\t\t\tdata = list(enumerate(data))\n\n\ttry:\n\t\tif plotjoined:\n\t\t\treturn line(data, **kwargs)\n\t\telse:\n\t\t\treturn point(data, **kwargs)\n\texcept (TypeError, IndexError):\n\t\t# Assume we have complex-valued input and plot real and imaginary parts.\n\t\t# Need to catch IndexError because if data is, say, [(0, 1), (1, I)],\n\t\t# point3d() throws an IndexError on the (0,1) before it ever\n\t\t# gets to (1, I).\n\t\tfrom sage.rings.complex_field import ComplexField\n\t\tCC = ComplexField()\n\t\t# if we get here, we already did \"list(enumerate(data))\",\n\t\t# so look at z[1] in inner list\n\t\tdata = [(z.real(), z.imag()) for z in [CC(z[1]) for z in data]]\n\t\tif plotjoined:\n\t\t\treturn line(data, **kwargs)\n\t\telse:\n\t\t\treturn point(data, **kwargs)\n", "description": "\n\t``list_plot`` takes either a list of numbers, a list of tuples, a numpy\n\tarray, or a dictionary and plots the corresponding points.\n\n\tIf given a list of numbers (that is, not a list of tuples or lists),\n\t``list_plot`` forms a list of tuples ``(i, x_i)`` where ``i`` goes from\n\t0 to ``len(data)-1`` and ``x_i`` is the ``i``-th data value, and puts\n\tpoints at those tuple values.\n\n\t``list_plot`` will plot a list of complex numbers in the obvious\n\tway; any numbers for which\n\t:func:`CC()` makes sense will\n\twork.\n\n\t``list_plot`` also takes a list of tuples ``(x_i, y_i)`` where ``x_i``\n\tand ``y_i`` are the ``i``-th values representing the ``x``- and\n\t``y``-values, respectively.\n\n\tIf given a dictionary, ``list_plot`` interprets the keys as\n\t`x`-values and the values as `y`-values.\n\n\tThe ``plotjoined=True`` option tells ``list_plot`` to plot a line\n\tjoining all the data.\n\n\tIt is possible to pass empty dictionaries, lists, or tuples to\n\t``list_plot``. Doing so will plot nothing (returning an empty plot).\n\n\tEXAMPLES::\n\n\t\tsage: list_plot([i^2 for i in range(5)]) # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere are a bunch of random red points::\n\n\t\tsage: r = [(random(),random()) for _ in range(20)]\n\t\tsage: list_plot(r,color='red')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tThis gives all the random points joined in a purple line::\n\n\t\tsage: list_plot(r, plotjoined=True, color='purple')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tYou can provide a numpy array.::\n\n\t\tsage: import numpy\n\t\tsage: list_plot(numpy.arange(10))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: list_plot(numpy.array([[1,2], [2,3], [3,4]]))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tPlot a list of complex numbers::\n\n\t\tsage: list_plot([1, I, pi + I/2, CC(.25, .25)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: list_plot([exp(I*theta) for theta in [0, .2..pi]])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tNote that if your list of complex numbers are all actually real,\n\tthey get plotted as real values, so this\n\n\t::\n\n\t\tsage: list_plot([CDF(1), CDF(1/2), CDF(1/3)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tis the same as ``list_plot([1, 1/2, 1/3])`` -- it produces a plot of\n\tthe points `(0,1)`, `(1,1/2)`, and `(2,1/3)`.\n\n\tIf you have separate lists of `x` values and `y` values which you\n\twant to plot against each other, use the ``zip`` command to make a\n\tsingle list whose entries are pairs of `(x,y)` values, and feed\n\tthe result into ``list_plot``::\n\n\t\tsage: x_coords = [cos(t)^3 for t in srange(0, 2*pi, 0.02)]\n\t\tsage: y_coords = [sin(t)^3 for t in srange(0, 2*pi, 0.02)]\n\t\tsage: list_plot(zip(x_coords, y_coords))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tIf instead you try to pass the two lists as separate arguments,\n\tyou will get an error message::\n\n\t\tsage: list_plot(x_coords, y_coords)\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tTypeError: The second argument 'plotjoined' should be boolean (True or False).  If you meant to plot two lists 'x' and 'y' against each other, use 'list_plot(zip(x,y))'.\n\n\tDictionaries with numeric keys and values can be plotted::\n\n\t\tsage: list_plot({22: 3365, 27: 3295, 37: 3135, 42: 3020, 47: 2880, 52: 2735, 57: 2550})\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tPlotting in logarithmic scale is possible for 2D list plots.\n\tThere are two different syntaxes available::\n\n\t\tsage: yl = [2**k for k in range(20)]\n\t\tsage: list_plot(yl, scale='semilogy')  # long time  # log axis on vertical\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: list_plot_semilogy(yl)\t   # same\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t.. warning::\n\n\t\tIf ``plotjoined`` is ``False`` then the axis that is in log scale\n\t\tmust have all points strictly positive. For instance, the following\n\t\tplot will show no points in the figure since the points in the\n\t\thorizontal axis starts from `(0,1)`.\n\n\t\t::\n\n\t\t\tsage: list_plot(yl, scale='loglog')\t\t # both axes are log\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tInstead this will work. We drop the point `(0,1)`.::\n\n\t\t\tsage: list_plot(zip(range(1,len(yl)), yl[1:]), scale='loglog') # long time \n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe use :func:`list_plot_loglog` and plot in a different base.::\n\n\t\tsage: list_plot_loglog(zip(range(1,len(yl)), yl[1:]), base=2) # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe can also change the scale of the axes in the graphics just before\n\tdisplaying::\n\n\t\tsage: G = list_plot(yl) # long time\n\t\tsage: G.show(scale=('semilogy', 2)) # long time\n\n\tTESTS:\n\n\tWe check to see whether elements of the Symbolic Ring are properly\n\thandled; see :trac:`16378` ::\n\n\t\tsage: list_plot([1+I, 2+I])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: list_plot([1+I, 2, CC(3+I)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tsage: list_plot([2, SR(1), CC(1+i)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tWe check to see that the x/y min/max data are set correctly::\n\n\t\tsage: d = list_plot([(100,100), (120, 120)]).get_minmax_data()\n\t\tsage: d['xmin']\n\t\t100.0\n\t\tsage: d['ymin']\n\t\t100.0\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "plot_loglog", "data": "def plot_loglog(funcs, *args, **kwds):\n\t\"\"\"\n\tPlot graphics in 'loglog' scale, that is, both the horizontal and the\n\tvertical axes will be in logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1. The base can be also given as a list or tuple\n\t  ``(basex, basey)``.  ``basex`` sets the base of the logarithm along the\n\t  horizontal axis and ``basey`` sets the base along the vertical axis.\n\n\t- ``funcs`` -- any Sage object which is acceptable to the :func:`plot`.\n\n\tFor all other inputs, look at the documentation of :func:`plot`.\n\n\tEXAMPLES::\n\n\t\tsage: plot_loglog(exp, (1,10)) # plot in loglog scale with base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: plot_loglog(exp, (1,10), base=2.1) # long time # with base 2.1 on both axes\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: plot_loglog(exp, (1,10), base=(2,3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\"\"\"\n\treturn plot(funcs, *args, scale='loglog', **kwds)\n", "description": "\n\tPlot graphics in 'loglog' scale, that is, both the horizontal and the\n\tvertical axes will be in logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1. The base can be also given as a list or tuple\n\t  ``(basex, basey)``.  ``basex`` sets the base of the logarithm along the\n\t  horizontal axis and ``basey`` sets the base along the vertical axis.\n\n\t- ``funcs`` -- any Sage object which is acceptable to the :func:`plot`.\n\n\tFor all other inputs, look at the documentation of :func:`plot`.\n\n\tEXAMPLES::\n\n\t\tsage: plot_loglog(exp, (1,10)) # plot in loglog scale with base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: plot_loglog(exp, (1,10), base=2.1) # long time # with base 2.1 on both axes\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: plot_loglog(exp, (1,10), base=(2,3))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "plot_semilogx", "data": "def plot_semilogx(funcs, *args, **kwds):\n\t\"\"\"\n\tPlot graphics in 'semilogx' scale, that is, the horizontal axis will be\n\tin logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1.\n\n\t- ``funcs`` -- any Sage object which is acceptable to the :func:`plot`.\n\n\tFor all other inputs, look at the documentation of :func:`plot`.\n\n\tEXAMPLES::\n\n\t\tsage: plot_semilogx(exp, (1,10)) # long time # plot in semilogx scale, base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: plot_semilogx(exp, (1,10), base=2) # with base 2\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\"\"\"\n\treturn plot(funcs, *args, scale='semilogx', **kwds)\n", "description": "\n\tPlot graphics in 'semilogx' scale, that is, the horizontal axis will be\n\tin logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1.\n\n\t- ``funcs`` -- any Sage object which is acceptable to the :func:`plot`.\n\n\tFor all other inputs, look at the documentation of :func:`plot`.\n\n\tEXAMPLES::\n\n\t\tsage: plot_semilogx(exp, (1,10)) # long time # plot in semilogx scale, base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: plot_semilogx(exp, (1,10), base=2) # with base 2\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "plot_semilogy", "data": "def plot_semilogy(funcs, *args, **kwds):\n\t\"\"\"\n\tPlot graphics in 'semilogy' scale, that is, the vertical axis will be\n\tin logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1.\n\n\t- ``funcs`` -- any Sage object which is acceptable to the :func:`plot`.\n\n\tFor all other inputs, look at the documentation of :func:`plot`.\n\n\tEXAMPLES::\n\n\t\tsage: plot_semilogy(exp, (1,10)) # long time # plot in semilogy scale, base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: plot_semilogy(exp, (1,10), base=2) # long time # with base 2\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\"\"\"\n\treturn plot(funcs, *args, scale='semilogy', **kwds)\n", "description": "\n\tPlot graphics in 'semilogy' scale, that is, the vertical axis will be\n\tin logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1.\n\n\t- ``funcs`` -- any Sage object which is acceptable to the :func:`plot`.\n\n\tFor all other inputs, look at the documentation of :func:`plot`.\n\n\tEXAMPLES::\n\n\t\tsage: plot_semilogy(exp, (1,10)) # long time # plot in semilogy scale, base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: plot_semilogy(exp, (1,10), base=2) # long time # with base 2\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "list_plot_loglog", "data": "def list_plot_loglog(data, plotjoined=False, **kwds):\n\t\"\"\"\n\tPlot the ``data`` in 'loglog' scale, that is, both the horizontal and the\n\tvertical axes will be in logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1. The base can be also given as a list or tuple\n\t  ``(basex, basey)``.  ``basex`` sets the base of the logarithm along the\n\t  horizontal axis and ``basey`` sets the base along the vertical axis.\n\n\tFor all other inputs, look at the documentation of :func:`list_plot`.\n\n\n\tEXAMPLES::\n\n\t\tsage: yl = [5**k for k in range(10)]; xl = [2**k for k in range(10)]\n\t\tsage: list_plot_loglog(zip(xl, yl)) # long time # plot in loglog scale with base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: list_plot_loglog(zip(xl, yl), base=2.1) # long time # with base 2.1 on both axes\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: list_plot_loglog(zip(xl, yl), base=(2,5)) # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t.. warning::\n\n\t\tIf ``plotjoined`` is ``False`` then the axis that is in log scale\n\t\tmust have all points strictly positive. For instance, the following\n\t\tplot will show no points in the figure since the points in the\n\t\thorizontal axis starts from `(0,1)`.\n\n\t\t::\n\n\t\t\tsage: yl = [2**k for k in range(20)]\n\t\t\tsage: list_plot_loglog(yl)\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tInstead this will work. We drop the point `(0,1)`.::\n\n\t\t\tsage: list_plot_loglog(zip(range(1,len(yl)), yl[1:]))\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\"\"\"\n\treturn list_plot(data, plotjoined=plotjoined, scale='loglog', **kwds)\n", "description": "\n\tPlot the ``data`` in 'loglog' scale, that is, both the horizontal and the\n\tvertical axes will be in logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1. The base can be also given as a list or tuple\n\t  ``(basex, basey)``.  ``basex`` sets the base of the logarithm along the\n\t  horizontal axis and ``basey`` sets the base along the vertical axis.\n\n\tFor all other inputs, look at the documentation of :func:`list_plot`.\n\n\n\tEXAMPLES::\n\n\t\tsage: yl = [5**k for k in range(10)]; xl = [2**k for k in range(10)]\n\t\tsage: list_plot_loglog(zip(xl, yl)) # long time # plot in loglog scale with base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: list_plot_loglog(zip(xl, yl), base=2.1) # long time # with base 2.1 on both axes\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: list_plot_loglog(zip(xl, yl), base=(2,5)) # long time\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t.. warning::\n\n\t\tIf ``plotjoined`` is ``False`` then the axis that is in log scale\n\t\tmust have all points strictly positive. For instance, the following\n\t\tplot will show no points in the figure since the points in the\n\t\thorizontal axis starts from `(0,1)`.\n\n\t\t::\n\n\t\t\tsage: yl = [2**k for k in range(20)]\n\t\t\tsage: list_plot_loglog(yl)\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tInstead this will work. We drop the point `(0,1)`.::\n\n\t\t\tsage: list_plot_loglog(zip(range(1,len(yl)), yl[1:]))\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "list_plot_semilogx", "data": "def list_plot_semilogx(data, plotjoined=False, **kwds):\n\t\"\"\"\n\tPlot ``data`` in 'semilogx' scale, that is, the horizontal axis will be\n\tin logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1.\n\n\tFor all other inputs, look at the documentation of :func:`list_plot`.\n\n\tEXAMPLES::\n\n\t\tsage: yl = [2**k for k in range(12)]\n\t\tsage: list_plot_semilogx(zip(yl,yl))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t.. warning::\n\n\t\tIf ``plotjoined`` is ``False`` then the horizontal axis must have all\n\t\tpoints strictly positive. Otherwise the plot will come up empty.\n\t\tFor instance the following plot contains a point at `(0,1)`.\n\n\t\t::\n\n\t\t\tsage: yl = [2**k for k in range(12)]\n\t\t\tsage: list_plot_semilogx(yl) # plot is empty because of `(0,1)`\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tWe remove `(0,1)` to fix this.::\n\n\t\t\tsage: list_plot_semilogx(zip(range(1, len(yl)), yl[1:]))\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: list_plot_semilogx([(1,2),(3,4),(3,-1),(25,3)], base=2) # with base 2\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\"\"\"\n\treturn list_plot(data, plotjoined=plotjoined, scale='semilogx', **kwds)\n", "description": "\n\tPlot ``data`` in 'semilogx' scale, that is, the horizontal axis will be\n\tin logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1.\n\n\tFor all other inputs, look at the documentation of :func:`list_plot`.\n\n\tEXAMPLES::\n\n\t\tsage: yl = [2**k for k in range(12)]\n\t\tsage: list_plot_semilogx(zip(yl,yl))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t.. warning::\n\n\t\tIf ``plotjoined`` is ``False`` then the horizontal axis must have all\n\t\tpoints strictly positive. Otherwise the plot will come up empty.\n\t\tFor instance the following plot contains a point at `(0,1)`.\n\n\t\t::\n\n\t\t\tsage: yl = [2**k for k in range(12)]\n\t\t\tsage: list_plot_semilogx(yl) # plot is empty because of `(0,1)`\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tWe remove `(0,1)` to fix this.::\n\n\t\t\tsage: list_plot_semilogx(zip(range(1, len(yl)), yl[1:]))\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: list_plot_semilogx([(1,2),(3,4),(3,-1),(25,3)], base=2) # with base 2\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "list_plot_semilogy", "data": "def list_plot_semilogy(data, plotjoined=False, **kwds):\n\t\"\"\"\n\tPlot ``data`` in 'semilogy' scale, that is, the vertical axis will be\n\tin logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1.\n\n\tFor all other inputs, look at the documentation of :func:`list_plot`.\n\n\tEXAMPLES::\n\n\t\tsage: yl = [2**k for k in range(12)]\n\t\tsage: list_plot_semilogy(yl) # plot in semilogy scale, base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t.. warning::\n\n\t\tIf ``plotjoined`` is ``False`` then the vertical axis must have all\n\t\tpoints strictly positive. Otherwise the plot will come up empty.\n\t\tFor instance the following plot contains a point at `(1,0)`.\n\n\t\t::\n\n\t\t\tsage: xl = [2**k for k in range(12)]; yl = range(len(xl))\n\t\t\tsage: list_plot_semilogy(zip(xl,yl)) # plot empty due to (1,0)\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tWe remove `(1,0)` to fix this.::\n\n\t\t\tsage: list_plot_semilogy(zip(xl[1:],yl[1:]))\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\n\t::\n\n\t\tsage: list_plot_semilogy([2, 4, 6, 8, 16, 31], base=2) # with base 2\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t\"\"\"\n\treturn list_plot(data, plotjoined=plotjoined, scale='semilogy', **kwds)\n", "description": "\n\tPlot ``data`` in 'semilogy' scale, that is, the vertical axis will be\n\tin logarithmic scale.\n\n\tINPUTS:\n\n\t- ``base`` -- (default: 10) the base of the logarithm. This must be\n\t  greater than 1.\n\n\tFor all other inputs, look at the documentation of :func:`list_plot`.\n\n\tEXAMPLES::\n\n\t\tsage: yl = [2**k for k in range(12)]\n\t\tsage: list_plot_semilogy(yl) # plot in semilogy scale, base 10\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t.. warning::\n\n\t\tIf ``plotjoined`` is ``False`` then the vertical axis must have all\n\t\tpoints strictly positive. Otherwise the plot will come up empty.\n\t\tFor instance the following plot contains a point at `(1,0)`.\n\n\t\t::\n\n\t\t\tsage: xl = [2**k for k in range(12)]; yl = range(len(xl))\n\t\t\tsage: list_plot_semilogy(zip(xl,yl)) # plot empty due to (1,0)\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tWe remove `(1,0)` to fix this.::\n\n\t\t\tsage: list_plot_semilogy(zip(xl[1:],yl[1:]))\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\n\t::\n\n\t\tsage: list_plot_semilogy([2, 4, 6, 8, 16, 31], base=2) # with base 2\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "to_float_list", "data": "def to_float_list(v):\n\t\"\"\"\n\tGiven a list or tuple or iterable v, coerce each element of v to a\n\tfloat and make a list out of the result.\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.plot import to_float_list\n\t\tsage: to_float_list([1,1/2,3])\n\t\t[1.0, 0.5, 3.0]\n\t\"\"\"\n\treturn [float(x) for x in v]\n\n", "description": "\n\tGiven a list or tuple or iterable v, coerce each element of v to a\n\tfloat and make a list out of the result.\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.plot import to_float_list\n\t\tsage: to_float_list([1,1/2,3])\n\t\t[1.0, 0.5, 3.0]\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "reshape", "data": "def reshape(v, n, m):\n\t\"\"\"\n\tHelper function for creating graphics arrays.\n\n\tThe input array is flattened and turned into an `n\\times m`\n\tarray, with blank graphics object padded at the end, if\n\tnecessary.\n\n\tINPUT:\n\n\t-  ``v`` - a list of lists or tuples\n\n\t-  ``n, m`` - integers\n\n\tOUTPUT:\n\n\tA list of lists of graphics objects\n\n\tEXAMPLES::\n\n\t\tsage: L = [plot(sin(k*x),(x,-pi,pi)) for k in range(10)]\n\t\tsage: graphics_array(L,3,4)  # long time (up to 4s on sage.math, 2012)\n\t\tGraphics Array of size 3 x 4\n\n\t::\n\n\t\tsage: M = [[plot(sin(k*x),(x,-pi,pi)) for k in range(3)],[plot(cos(j*x),(x,-pi,pi)) for j in [3..5]]]\n\t\tsage: graphics_array(M,6,1)  # long time (up to 4s on sage.math, 2012)\n\t\tGraphics Array of size 6 x 1\n\n\tTESTS::\n\n\t\tsage: L = [plot(sin(k*x),(x,-pi,pi)) for k in [1..3]]\n\t\tsage: graphics_array(L,0,-1) # indirect doctest\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: array sizes must be positive\n\t\"\"\"\n\tif not (n > 0 and m > 0):\n\t\traise ValueError('array sizes must be positive')\n\tG = Graphics()\n\tG.axes(False)\n\tif len(v) == 0:\n\t\treturn [[G]*m]*n\n\n\tif not isinstance(v[0], Graphics):\n\t\t# a list of lists -- flatten it\n\t\tv = sum([list(x) for x in v], [])\n\n\t# Now v should be a single list.\n\t# First, make it have the right length.\n\tv = list(v)   # do not mutate the argument\n\tfor i in xrange(n*m - len(v)):\n\t\tv.append(G)\n\n\t# Next, create a list of lists out of it.\n\tL = []\n\tk = 0\n\tfor i in range(n):\n\t\tw = []\n\t\tfor j in range(m):\n\t\t\tw.append(v[k])\n\t\t\tk += 1\n\t\tL.append(w)\n\n\treturn L\n", "description": "\n\tHelper function for creating graphics arrays.\n\n\tThe input array is flattened and turned into an `n\\times m`\n\tarray, with blank graphics object padded at the end, if\n\tnecessary.\n\n\tINPUT:\n\n\t-  ``v`` - a list of lists or tuples\n\n\t-  ``n, m`` - integers\n\n\tOUTPUT:\n\n\tA list of lists of graphics objects\n\n\tEXAMPLES::\n\n\t\tsage: L = [plot(sin(k*x),(x,-pi,pi)) for k in range(10)]\n\t\tsage: graphics_array(L,3,4)  # long time (up to 4s on sage.math, 2012)\n\t\tGraphics Array of size 3 x 4\n\n\t::\n\n\t\tsage: M = [[plot(sin(k*x),(x,-pi,pi)) for k in range(3)],[plot(cos(j*x),(x,-pi,pi)) for j in [3..5]]]\n\t\tsage: graphics_array(M,6,1)  # long time (up to 4s on sage.math, 2012)\n\t\tGraphics Array of size 6 x 1\n\n\tTESTS::\n\n\t\tsage: L = [plot(sin(k*x),(x,-pi,pi)) for k in [1..3]]\n\t\tsage: graphics_array(L,0,-1) # indirect doctest\n\t\tTraceback (most recent call last):\n\t\t...\n\t\tValueError: array sizes must be positive\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "graphics_array", "data": "def graphics_array(array, nrows=None, ncols=None):\n\tr\"\"\"\n\t``graphics_array`` take a list of lists (or tuples) of\n\tgraphics objects and plots them all on one canvas (single plot).\n\n\tINPUT:\n\n\t- ``array`` -- a list of lists or tuples. The graphics objects to\n\t   combine into a graphics array.\n\n\t- ``nrows, ncols`` -- (optional) integers. If both are given then\n\t   the input array is flattened and turned into an ``nrows`` x\n\t   ``ncols`` array, with blank graphics objects padded at the end,\n\t   if necessary. If only one is specified, the other is chosen\n\t   automatically.\n\n\tEXAMPLE: Make some plots of `\\sin` functions::\n\n\t\tsage: f(x) = sin(x)\n\t\tsage: g(x) = sin(2*x)\n\t\tsage: h(x) = sin(4*x)\n\t\tsage: p1 = plot(f,(-2*pi,2*pi),color=hue(0.5)) # long time\n\t\tsage: p2 = plot(g,(-2*pi,2*pi),color=hue(0.9)) # long time\n\t\tsage: p3 = parametric_plot((f,g),(0,2*pi),color=hue(0.6)) # long time\n\t\tsage: p4 = parametric_plot((f,h),(0,2*pi),color=hue(1.0)) # long time\n\n\tNow make a graphics array out of the plots::\n\n\t\tsage: graphics_array(((p1,p2),(p3,p4))) # long time\n\t\tGraphics Array of size 2 x 2\n\n\tOne can also name the array, and then use :meth:`~sage.plot.graphics.GraphicsArray.show`\n\tor :meth:`~sage.plot.graphics.GraphicsArray.save`::\n\n\t\tsage: ga = graphics_array(((p1,p2),(p3,p4))) # long time\n\t\tsage: ga.show() # long time\n\n\tHere we give only one row::\n\n\t\tsage: p1 = plot(sin,(-4,4))\n\t\tsage: p2 = plot(cos,(-4,4))\n\t\tsage: g = graphics_array([p1, p2]); print g\n\t\tGraphics Array of size 1 x 2\n\t\tsage: g.show()\n\n\tIt is possible to use ``figsize`` to change the size of the plot\n\tas a whole::\n\n\t\tsage: L = [plot(sin(k*x),(x,-pi,pi)) for k in [1..3]]\n\t\tsage: G = graphics_array(L)\n\t\tsage: G.show(figsize=[5,3])  # smallish and compact\n\t\tsage: G.show(figsize=[10,20])  # bigger and tall and thin; long time (2s on sage.math, 2012)\n\t\tsage: G.show(figsize=8)  # figure as a whole is a square\n\n\tSpecifying only the number of rows or the number of columns\n\tcomputes the other dimension automatically::\n\n\t\tsage: ga = graphics_array([plot(sin)] * 10, nrows=3)\n\t\tsage: ga.nrows(), ga.ncols()\n\t\t(3, 4)\n\t\tsage: ga = graphics_array([plot(sin)] * 10, ncols=3)\n\t\tsage: ga.nrows(), ga.ncols()\n\t\t(4, 3)\n\t\"\"\"\n\t# TODO: refactor the whole array flattening and reshaping into a class\n\tif nrows is None and ncols is None:\n\t\tpass\n\telif nrows is not None and ncols is not None:\n\t\tnrows = int(nrows)\n\t\tncols = int(ncols)\n\t\tarray = reshape(array, nrows, ncols)\n\telse:\n\t\t# nrows is None xor ncols is None\n\t\tif len(array) > 0 and isinstance(array[0], Graphics):\n\t\t\tlength = len(array)\n\t\telse:\n\t\t\tlength = sum(map(len, array))\n\t\tif nrows is None:\n\t\t\tncols = int(ncols)\n\t\t\tnrows = length // ncols + 1\n\t\telif ncols is None:\n\t\t\tnrows = int(nrows)\n\t\t\tncols = length // nrows + 1\n\t\telse:\n\t\t\tassert False\n\t\tarray = reshape(array, nrows, ncols)\n\treturn GraphicsArray(array)\n", "description": "\n\t``graphics_array`` take a list of lists (or tuples) of\n\tgraphics objects and plots them all on one canvas (single plot).\n\n\tINPUT:\n\n\t- ``array`` -- a list of lists or tuples. The graphics objects to\n\t   combine into a graphics array.\n\n\t- ``nrows, ncols`` -- (optional) integers. If both are given then\n\t   the input array is flattened and turned into an ``nrows`` x\n\t   ``ncols`` array, with blank graphics objects padded at the end,\n\t   if necessary. If only one is specified, the other is chosen\n\t   automatically.\n\n\tEXAMPLE: Make some plots of `\\sin` functions::\n\n\t\tsage: f(x) = sin(x)\n\t\tsage: g(x) = sin(2*x)\n\t\tsage: h(x) = sin(4*x)\n\t\tsage: p1 = plot(f,(-2*pi,2*pi),color=hue(0.5)) # long time\n\t\tsage: p2 = plot(g,(-2*pi,2*pi),color=hue(0.9)) # long time\n\t\tsage: p3 = parametric_plot((f,g),(0,2*pi),color=hue(0.6)) # long time\n\t\tsage: p4 = parametric_plot((f,h),(0,2*pi),color=hue(1.0)) # long time\n\n\tNow make a graphics array out of the plots::\n\n\t\tsage: graphics_array(((p1,p2),(p3,p4))) # long time\n\t\tGraphics Array of size 2 x 2\n\n\tOne can also name the array, and then use :meth:`~sage.plot.graphics.GraphicsArray.show`\n\tor :meth:`~sage.plot.graphics.GraphicsArray.save`::\n\n\t\tsage: ga = graphics_array(((p1,p2),(p3,p4))) # long time\n\t\tsage: ga.show() # long time\n\n\tHere we give only one row::\n\n\t\tsage: p1 = plot(sin,(-4,4))\n\t\tsage: p2 = plot(cos,(-4,4))\n\t\tsage: g = graphics_array([p1, p2]); print g\n\t\tGraphics Array of size 1 x 2\n\t\tsage: g.show()\n\n\tIt is possible to use ``figsize`` to change the size of the plot\n\tas a whole::\n\n\t\tsage: L = [plot(sin(k*x),(x,-pi,pi)) for k in [1..3]]\n\t\tsage: G = graphics_array(L)\n\t\tsage: G.show(figsize=[5,3])  # smallish and compact\n\t\tsage: G.show(figsize=[10,20])  # bigger and tall and thin; long time (2s on sage.math, 2012)\n\t\tsage: G.show(figsize=8)  # figure as a whole is a square\n\n\tSpecifying only the number of rows or the number of columns\n\tcomputes the other dimension automatically::\n\n\t\tsage: ga = graphics_array([plot(sin)] * 10, nrows=3)\n\t\tsage: ga.nrows(), ga.ncols()\n\t\t(3, 4)\n\t\tsage: ga = graphics_array([plot(sin)] * 10, ncols=3)\n\t\tsage: ga.nrows(), ga.ncols()\n\t\t(4, 3)\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "var_and_list_of_values", "data": "def var_and_list_of_values(v, plot_points):\n\t\"\"\"\n\tINPUT:\n\n\n\t-  ``v`` - (v0, v1) or (var, v0, v1); if the former\n\t   return the range of values between v0 and v1 taking plot_points\n\t   steps; if var is given, also return var.\n\n\t-  ``plot_points`` - integer = 2 (the endpoints)\n\n\n\tOUTPUT:\n\n\n\t-  ``var`` - a variable or None\n\n\t-  ``list`` - a list of floats\n\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.plot import var_and_list_of_values\n\t\tsage: var_and_list_of_values((var('theta'), 2, 5),  5)\n\t\tdoctest:...: DeprecationWarning: var_and_list_of_values is deprecated.  Please use sage.plot.misc.setup_for_eval_on_grid; note that that function has slightly different calling and return conventions which make it more generally applicable\n\t\tSee http://trac.sagemath.org/7008 for details.\n\t\t(theta, [2.0, 2.75, 3.5, 4.25, 5.0])\n\t\tsage: var_and_list_of_values((2, 5),  5)\n\t\t(None, [2.0, 2.75, 3.5, 4.25, 5.0])\n\t\tsage: var_and_list_of_values((var('theta'), 2, 5),  2)\n\t\t(theta, [2.0, 5.0])\n\t\tsage: var_and_list_of_values((2, 5),  2)\n\t\t(None, [2.0, 5.0])\n\t\"\"\"\n\tfrom sage.misc.superseded import deprecation\n\tdeprecation(7008, \"var_and_list_of_values is deprecated.  Please use sage.plot.misc.setup_for_eval_on_grid; note that that function has slightly different calling and return conventions which make it more generally applicable\")\n\tplot_points = int(plot_points)\n\tif plot_points < 2:\n\t\traise ValueError(\"plot_points must be greater than 1\")\n\tif not isinstance(v, (tuple, list)):\n\t\traise TypeError(\"v must be a tuple or list\")\n\tif len(v) == 3:\n\t\tvar = v[0]\n\t\ta, b = v[1], v[2]\n\telif len(v) == 2:\n\t\tvar = None\n\t\ta, b = v\n\telse:\n\t\traise ValueError(\"parametric value range must be a list or tuple of length 2 or 3.\")\n\n\ta = float(a)\n\tb = float(b)\n\tif plot_points == 2:\n\t\treturn var, [a, b]\n\telse:\n\t\tstep = (b-a)/float(plot_points-1)\n\t\tvalues = [a + step*i for i in xrange(plot_points)]\n\t\treturn var, values\n\n\n", "description": "\n\tINPUT:\n\n\n\t-  ``v`` - (v0, v1) or (var, v0, v1); if the former\n\t   return the range of values between v0 and v1 taking plot_points\n\t   steps; if var is given, also return var.\n\n\t-  ``plot_points`` - integer = 2 (the endpoints)\n\n\n\tOUTPUT:\n\n\n\t-  ``var`` - a variable or None\n\n\t-  ``list`` - a list of floats\n\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.plot import var_and_list_of_values\n\t\tsage: var_and_list_of_values((var('theta'), 2, 5),  5)\n\t\tdoctest:...: DeprecationWarning: var_and_list_of_values is deprecated.  Please use sage.plot.misc.setup_for_eval_on_grid; note that that function has slightly different calling and return conventions which make it more generally applicable\n\t\tSee http://trac.sagemath.org/7008 for details.\n\t\t(theta, [2.0, 2.75, 3.5, 4.25, 5.0])\n\t\tsage: var_and_list_of_values((2, 5),  5)\n\t\t(None, [2.0, 2.75, 3.5, 4.25, 5.0])\n\t\tsage: var_and_list_of_values((var('theta'), 2, 5),  2)\n\t\t(theta, [2.0, 5.0])\n\t\tsage: var_and_list_of_values((2, 5),  2)\n\t\t(None, [2.0, 5.0])\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "setup_for_eval_on_grid", "data": "def setup_for_eval_on_grid(v, xrange, yrange, plot_points):\n\t\"\"\"\n\tThis function is deprecated.  Please use\n\t``sage.plot.misc.setup_for_eval_on_grid`` instead.  Please note that\n\tthat function has slightly different calling and return\n\tconventions which make it more generally applicable.\n\n\tINPUT:\n\n\n\t-  ``v`` - a list of functions\n\n\t-  ``xrange`` - 2 or 3 tuple (if 3, first is a\n\t   variable)\n\n\t-  ``yrange`` - 2 or 3 tuple\n\n\t-  ``plot_points`` - a positive integer\n\n\n\tOUTPUT:\n\n\n\t-  ``g`` - tuple of fast callable functions\n\n\t-  ``xstep`` - step size in xdirection\n\n\t-  ``ystep`` - step size in ydirection\n\n\t-  ``xrange`` - tuple of 2 floats\n\n\t-  ``yrange`` - tuple of 2 floats\n\n\n\tEXAMPLES::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: sage.plot.plot.setup_for_eval_on_grid([x^2 + y^2], (x,0,5), (y,0,pi), 11)\n\t\tdoctest:...: DeprecationWarning: sage.plot.plot.setup_for_eval_on_grid is deprecated.  Please use sage.plot.misc.setup_for_eval_on_grid; note that that function has slightly different calling and return conventions which make it more generally applicable\n\t\tSee http://trac.sagemath.org/7008 for details.\n\t\t([],\n\t\t 0.5,\n\t\t 0.3141592653589793,\n\t\t (0.0, 5.0),\n\t\t (0.0, 3.141592653589793))\n\n\tWe always plot at least two points; one at the beginning and one at the end of the ranges.\n\n\t::\n\n\t\tsage: sage.plot.plot.setup_for_eval_on_grid([x^2+y^2], (x,0,1), (y,-1,1), 1)\n\t\t([],\n\t\t1.0,\n\t\t2.0,\n\t\t(0.0, 1.0),\n\t\t(-1.0, 1.0))\n\n\n\t\"\"\"\n\tfrom sage.misc.superseded import deprecation\n\tdeprecation(7008, \"sage.plot.plot.setup_for_eval_on_grid is deprecated.  Please use sage.plot.misc.setup_for_eval_on_grid; note that that function has slightly different calling and return conventions which make it more generally applicable\")\n\n\tfrom sage.plot.misc import setup_for_eval_on_grid as setup\n\tg, ranges=setup(v, [xrange, yrange], plot_points)\n\treturn list(g), ranges[0][2], ranges[1][2], ranges[0][:2], ranges[1][:2]\n\n", "description": "\n\tThis function is deprecated.  Please use\n\t``sage.plot.misc.setup_for_eval_on_grid`` instead.  Please note that\n\tthat function has slightly different calling and return\n\tconventions which make it more generally applicable.\n\n\tINPUT:\n\n\n\t-  ``v`` - a list of functions\n\n\t-  ``xrange`` - 2 or 3 tuple (if 3, first is a\n\t   variable)\n\n\t-  ``yrange`` - 2 or 3 tuple\n\n\t-  ``plot_points`` - a positive integer\n\n\n\tOUTPUT:\n\n\n\t-  ``g`` - tuple of fast callable functions\n\n\t-  ``xstep`` - step size in xdirection\n\n\t-  ``ystep`` - step size in ydirection\n\n\t-  ``xrange`` - tuple of 2 floats\n\n\t-  ``yrange`` - tuple of 2 floats\n\n\n\tEXAMPLES::\n\n\t\tsage: x,y = var('x,y')\n\t\tsage: sage.plot.plot.setup_for_eval_on_grid([x^2 + y^2], (x,0,5), (y,0,pi), 11)\n\t\tdoctest:...: DeprecationWarning: sage.plot.plot.setup_for_eval_on_grid is deprecated.  Please use sage.plot.misc.setup_for_eval_on_grid; note that that function has slightly different calling and return conventions which make it more generally applicable\n\t\tSee http://trac.sagemath.org/7008 for details.\n\t\t([],\n\t\t 0.5,\n\t\t 0.3141592653589793,\n\t\t (0.0, 5.0),\n\t\t (0.0, 3.141592653589793))\n\n\tWe always plot at least two points; one at the beginning and one at the end of the ranges.\n\n\t::\n\n\t\tsage: sage.plot.plot.setup_for_eval_on_grid([x^2+y^2], (x,0,1), (y,-1,1), 1)\n\t\t([],\n\t\t1.0,\n\t\t2.0,\n\t\t(0.0, 1.0),\n\t\t(-1.0, 1.0))\n\n\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "minmax_data", "data": "def minmax_data(xdata, ydata, dict=False):\n\t\"\"\"\n\tReturns the minimums and maximums of xdata and ydata.\n\n\tIf dict is False, then minmax_data returns the tuple (xmin, xmax,\n\tymin, ymax); otherwise, it returns a dictionary whose keys are\n\t'xmin', 'xmax', 'ymin', and 'ymax' and whose values are the\n\tcorresponding values.\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.plot import minmax_data\n\t\tsage: minmax_data([], [])\n\t\t(-1, 1, -1, 1)\n\t\tsage: minmax_data([-1, 2], [4, -3])\n\t\t(-1, 2, -3, 4)\n\t\tsage: d = minmax_data([-1, 2], [4, -3], dict=True)\n\t\tsage: list(sorted(d.items()))\n\t\t[('xmax', 2), ('xmin', -1), ('ymax', 4), ('ymin', -3)]\n\t\"\"\"\n\txmin = min(xdata) if len(xdata) > 0 else -1\n\txmax = max(xdata) if len(xdata) > 0 else 1\n\tymin = min(ydata) if len(ydata) > 0 else -1\n\tymax = max(ydata) if len(ydata) > 0 else 1\n\tif dict:\n\t\treturn {'xmin':xmin, 'xmax':xmax,\n\t\t\t\t'ymin':ymin, 'ymax':ymax}\n\telse:\n\t\treturn xmin, xmax, ymin, ymax\n", "description": "\n\tReturns the minimums and maximums of xdata and ydata.\n\n\tIf dict is False, then minmax_data returns the tuple (xmin, xmax,\n\tymin, ymax); otherwise, it returns a dictionary whose keys are\n\t'xmin', 'xmax', 'ymin', and 'ymax' and whose values are the\n\tcorresponding values.\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.plot import minmax_data\n\t\tsage: minmax_data([], [])\n\t\t(-1, 1, -1, 1)\n\t\tsage: minmax_data([-1, 2], [4, -3])\n\t\t(-1, 2, -3, 4)\n\t\tsage: d = minmax_data([-1, 2], [4, -3], dict=True)\n\t\tsage: list(sorted(d.items()))\n\t\t[('xmax', 2), ('xmin', -1), ('ymax', 4), ('ymin', -3)]\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "adaptive_refinement", "data": "def adaptive_refinement(f, p1, p2, adaptive_tolerance=0.01, adaptive_recursion=5, level=0):\n\tr\"\"\"\n\tThe adaptive refinement algorithm for plotting a function ``f``. See\n\tthe docstring for plot for a description of the algorithm.\n\n\tINPUT:\n\n\n\t-  ``f`` - a function of one variable\n\n\t-  ``p1, p2`` - two points to refine between\n\n\t-  ``adaptive_recursion`` - (default: 5) how many\n\t   levels of recursion to go before giving up when doing adaptive\n\t   refinement. Setting this to 0 disables adaptive refinement.\n\n\t-  ``adaptive_tolerance`` - (default: 0.01) how large\n\t   a relative difference should be before the adaptive refinement\n\t   code considers it significant; see documentation for generate_plot_points\n\t   for more information.  See the documentation for :func:`plot` for more\n\t   information on how the adaptive refinement algorithm works.\n\n\tOUTPUT:\n\n\n\t-  ``list`` - a list of points to insert between ``p1`` and\n\t   ``p2`` to get a better linear approximation between them\n\n\n\tTESTS::\n\n\t\tsage: from sage.plot.plot import adaptive_refinement\n\t\tsage: adaptive_refinement(sin, (0,0), (pi,0), adaptive_tolerance=0.01, adaptive_recursion=0)\n\t\t[]\n\t\tsage: adaptive_refinement(sin, (0,0), (pi,0), adaptive_tolerance=0.01)\n\t\t[(0.125*pi, 0.3826834323650898), (0.1875*pi, 0.5555702330196022), (0.25*pi, 0.7071067811865475), (0.3125*pi, 0.8314696123025452), (0.375*pi, 0.9238795325112867), (0.4375*pi, 0.9807852804032304), (0.5*pi, 1.0), (0.5625*pi, 0.9807852804032304), (0.625*pi, 0.9238795325112867), (0.6875*pi, 0.8314696123025455), (0.75*pi, 0.7071067811865476), (0.8125*pi, 0.5555702330196022), (0.875*pi, 0.3826834323650899)]\n\n\tThis shows that lowering ``adaptive_tolerance`` and raising\n\t``adaptive_recursion`` both increase the number of subdivision\n\tpoints, though which one creates more points is heavily\n\tdependent upon the function being plotted.\n\n\t::\n\n\t\tsage: x = var('x')\n\t\tsage: f(x) = sin(1/x)\n\t\tsage: n1 = len(adaptive_refinement(f, (0,0), (pi,0), adaptive_tolerance=0.01)); n1\n\t\t15\n\t\tsage: n2 = len(adaptive_refinement(f, (0,0), (pi,0), adaptive_recursion=10, adaptive_tolerance=0.01)); n2\n\t\t79\n\t\tsage: n3 = len(adaptive_refinement(f, (0,0), (pi,0), adaptive_tolerance=0.001)); n3\n\t\t26\n\t\"\"\"\n\tif level >= adaptive_recursion:\n\t\treturn []\n\n\tx = (p1[0] + p2[0])/2.0\n\tmsg = ''\n\n\ttry:\n\t\ty = float(f(x))\n\t\tif str(y) in ['nan', 'NaN', 'inf', '-inf']:\n\t\t\tsage.misc.misc.verbose(\"%s\\nUnable to compute f(%s)\"%(msg, x),1)\n\t\t\t# give up for this branch\n\t\t\treturn []\n\n\texcept (ZeroDivisionError, TypeError, ValueError, OverflowError) as msg:\n\t\tsage.misc.misc.verbose(\"%s\\nUnable to compute f(%s)\"%(msg, x), 1)\n\t\t# give up for this branch\n\t\treturn []\n\n\t# this distance calculation is not perfect.\n\tif abs((p1[1] + p2[1])/2.0 - y) > adaptive_tolerance:\n\t\treturn adaptive_refinement(f, p1, (x, y),\n\t\t\t\t\tadaptive_tolerance=adaptive_tolerance,\n\t\t\t\t\tadaptive_recursion=adaptive_recursion,\n\t\t\t\t\tlevel=level+1) \\\n\t\t\t\t\t+ [(x, y)] + \\\n\t\t\tadaptive_refinement(f, (x, y), p2,\n\t\t\t\t\tadaptive_tolerance=adaptive_tolerance,\n\t\t\t\t\tadaptive_recursion=adaptive_recursion,\n\t\t\t\t\tlevel=level+1)\n\telse:\n\t\treturn []\n", "description": "\n\tThe adaptive refinement algorithm for plotting a function ``f``. See\n\tthe docstring for plot for a description of the algorithm.\n\n\tINPUT:\n\n\n\t-  ``f`` - a function of one variable\n\n\t-  ``p1, p2`` - two points to refine between\n\n\t-  ``adaptive_recursion`` - (default: 5) how many\n\t   levels of recursion to go before giving up when doing adaptive\n\t   refinement. Setting this to 0 disables adaptive refinement.\n\n\t-  ``adaptive_tolerance`` - (default: 0.01) how large\n\t   a relative difference should be before the adaptive refinement\n\t   code considers it significant; see documentation for generate_plot_points\n\t   for more information.  See the documentation for :func:`plot` for more\n\t   information on how the adaptive refinement algorithm works.\n\n\tOUTPUT:\n\n\n\t-  ``list`` - a list of points to insert between ``p1`` and\n\t   ``p2`` to get a better linear approximation between them\n\n\n\tTESTS::\n\n\t\tsage: from sage.plot.plot import adaptive_refinement\n\t\tsage: adaptive_refinement(sin, (0,0), (pi,0), adaptive_tolerance=0.01, adaptive_recursion=0)\n\t\t[]\n\t\tsage: adaptive_refinement(sin, (0,0), (pi,0), adaptive_tolerance=0.01)\n\t\t[(0.125*pi, 0.3826834323650898), (0.1875*pi, 0.5555702330196022), (0.25*pi, 0.7071067811865475), (0.3125*pi, 0.8314696123025452), (0.375*pi, 0.9238795325112867), (0.4375*pi, 0.9807852804032304), (0.5*pi, 1.0), (0.5625*pi, 0.9807852804032304), (0.625*pi, 0.9238795325112867), (0.6875*pi, 0.8314696123025455), (0.75*pi, 0.7071067811865476), (0.8125*pi, 0.5555702330196022), (0.875*pi, 0.3826834323650899)]\n\n\tThis shows that lowering ``adaptive_tolerance`` and raising\n\t``adaptive_recursion`` both increase the number of subdivision\n\tpoints, though which one creates more points is heavily\n\tdependent upon the function being plotted.\n\n\t::\n\n\t\tsage: x = var('x')\n\t\tsage: f(x) = sin(1/x)\n\t\tsage: n1 = len(adaptive_refinement(f, (0,0), (pi,0), adaptive_tolerance=0.01)); n1\n\t\t15\n\t\tsage: n2 = len(adaptive_refinement(f, (0,0), (pi,0), adaptive_recursion=10, adaptive_tolerance=0.01)); n2\n\t\t79\n\t\tsage: n3 = len(adaptive_refinement(f, (0,0), (pi,0), adaptive_tolerance=0.001)); n3\n\t\t26\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}, {"term": "def", "name": "generate_plot_points", "data": "def generate_plot_points(f, xrange, plot_points=5, adaptive_tolerance=0.01, adaptive_recursion=5, randomize = True, initial_points = None):\n\tr\"\"\"\n\tCalculate plot points for a function f in the interval xrange.  The\n\tadaptive refinement algorithm is also automatically invoked with a\n\t*relative* adaptive tolerance of adaptive_tolerance; see below.\n\n\tINPUT:\n\n\t- ``f`` - a function of one variable\n\n\t- ``p1, p2`` - two points to refine between\n\n\t- ``plot_points`` - (default: 5) the minimal number of plot points. (Note\n\t  however that in any actual plot a number is passed to this, with default\n\t  value 200.)\n\n\t- ``adaptive_recursion`` - (default: 5) how many levels of recursion to go\n\t  before giving up when doing adaptive refinement.  Setting this to 0\n\t  disables adaptive refinement.\n\n\t- ``adaptive_tolerance`` - (default: 0.01) how large the relative difference\n\t  should be before the adaptive refinement code considers it significant.  If\n\t  the actual difference is greater than adaptive_tolerance*delta, where delta\n\t  is the initial subinterval size for the given xrange and plot_points, then\n\t  the algorithm will consider it significant.\n\n\t- ``initial_points`` - (default: None) a list of points that should be evaluated.\n\n\tOUTPUT:\n\n\t- a list of points (x, f(x)) in the interval xrange, which approximate\n\t  the function f.\n\n\tTESTS::\n\n\t\tsage: from sage.plot.plot import generate_plot_points\n\t\tsage: generate_plot_points(sin, (0, pi), plot_points=2, adaptive_recursion=0)\n\t\t[(0.0, 0.0), (3.141592653589793, 1.2246...e-16)]\n\n\t\tsage: from sage.plot.plot import generate_plot_points\n\t\tsage: generate_plot_points(lambda x: x^2, (0, 6), plot_points=2, adaptive_recursion=0, initial_points = [1,2,3])\n\t\t[(0.0, 0.0), (1.0, 1.0), (2.0, 4.0), (3.0, 9.0), (6.0, 36.0)]\n\n\t\tsage: generate_plot_points(sin(x).function(x), (-pi, pi), randomize=False)\n\t\t[(-3.141592653589793, -1.2246...e-16), (-2.748893571891069,\n\t\t-0.3826834323650899), (-2.356194490192345, -0.707106781186547...),\n\t\t(-2.1598449493429825, -0.831469612302545...), (-1.9634954084936207,\n\t\t-0.9238795325112867), (-1.7671458676442586, -0.9807852804032304),\n\t\t(-1.5707963267948966, -1.0), (-1.3744467859455345,\n\t\t-0.9807852804032304), (-1.1780972450961724, -0.9238795325112867),\n\t\t(-0.9817477042468103, -0.831469612302545...), (-0.7853981633974483,\n\t\t-0.707106781186547...), (-0.39269908169872414, -0.3826834323650898),\n\t\t(0.0, 0.0), (0.39269908169872414, 0.3826834323650898),\n\t\t(0.7853981633974483, 0.707106781186547...), (0.9817477042468103,\n\t\t0.831469612302545...), (1.1780972450961724, 0.9238795325112867),\n\t\t(1.3744467859455345, 0.9807852804032304), (1.5707963267948966, 1.0),\n\t\t(1.7671458676442586, 0.9807852804032304), (1.9634954084936207,\n\t\t0.9238795325112867), (2.1598449493429825, 0.831469612302545...),\n\t\t(2.356194490192345, 0.707106781186547...), (2.748893571891069,\n\t\t0.3826834323650899), (3.141592653589793, 1.2246...e-16)]\n\n\tThis shows that lowering adaptive_tolerance and raising\n\tadaptive_recursion both increase the number of subdivision points.\n\t(Note that which creates more points is heavily dependent on the\n\tparticular function plotted.)\n\n\t::\n\n\t\tsage: x = var('x')\n\t\tsage: f(x) = sin(1/x)\n\t\tsage: [len(generate_plot_points(f, (-pi, pi), plot_points=16, adaptive_tolerance=i, randomize=False)) for i in [0.01, 0.001, 0.0001]]\n\t\t[97, 161, 275]\n\n\t\tsage: [len(generate_plot_points(f, (-pi, pi), plot_points=16, adaptive_recursion=i, randomize=False)) for i in [5, 10, 15]]\n\t\t[97, 499, 2681]\n\t\"\"\"\n\tfrom sage.plot.misc import setup_for_eval_on_grid\n\tignore, ranges = setup_for_eval_on_grid([], [xrange], plot_points)\n\txmin, xmax, delta = ranges[0]\n\tdata = srange(*ranges[0], include_endpoint=True)\n\n\trandom = current_randstate().python_random().random\n\n\tfor i in range(len(data)):\n\t\txi = data[i]\n\t\t# Slightly randomize the interior sample points if\n\t\t# randomize is true\n\t\tif randomize and i > 0 and i < plot_points-1:\n\t\t\txi += delta*(random() - 0.5)\n\t\t\tdata[i] = xi\n\n\t# add initial points\n\tif isinstance(initial_points, list):\n\t\tdata = sorted(data + initial_points)\n\n\texceptions = 0; msg=''\n\texception_indices = []\n\tfor i in range(len(data)):\n\t\txi = data[i]\n\n\t\ttry:\n\t\t\tdata[i] = (float(xi), float(f(xi)))\n\t\t\tif str(data[i][1]) in ['nan', 'NaN', 'inf', '-inf']:\n\t\t\t\tsage.misc.misc.verbose(\"%s\\nUnable to compute f(%s)\"%(msg, xi),1)\n\t\t\t\texceptions += 1\n\t\t\t\texception_indices.append(i)\n\n\t\texcept (ArithmeticError, TypeError, ValueError) as msg:\n\t\t\tsage.misc.misc.verbose(\"%s\\nUnable to compute f(%s)\"%(msg, xi),1)\n\n\t\t\tif i == 0: # Given an error for left endpoint, try to move it in slightly\n\t\t\t\tfor j in range(1, 99):\n\t\t\t\t\txj = xi + delta*j/100.0\n\t\t\t\t\ttry:\n\t\t\t\t\t\tdata[i] = (float(xj), float(f(xj)))\n\t\t\t\t\t\t# nan != nan\n\t\t\t\t\t\tif data[i][1] != data[i][1]:\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tbreak\n\t\t\t\t\texcept (ArithmeticError, TypeError, ValueError) as msg:\n\t\t\t\t\t\tpass\n\t\t\t\telse:\n\t\t\t\t\texceptions += 1\n\t\t\t\t\texception_indices.append(i)\n\n\t\t\telif i == plot_points-1: # Given an error for right endpoint, try to move it in slightly\n\t\t\t\tfor j in range(1, 99):\n\t\t\t\t\txj = xi - delta*j/100.0\n\t\t\t\t\ttry:\n\t\t\t\t\t\tdata[i] = (float(xj), float(f(xj)))\n\t\t\t\t\t\t# nan != nan\n\t\t\t\t\t\tif data[i][1] != data[i][1]:\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tbreak\n\t\t\t\t\texcept (ArithmeticError, TypeError, ValueError) as msg:\n\t\t\t\t\t\tpass\n\t\t\t\telse:\n\t\t\t\t\texceptions += 1\n\t\t\t\t\texception_indices.append(i)\n\t\t\telse:\n\t\t\t\texceptions += 1\n\t\t\t\texception_indices.append(i)\n\n\tdata = [data[i] for i in range(len(data)) if i not in exception_indices]\n\n\t# calls adaptive refinement\n\ti, j = 0, 0\n\tadaptive_tolerance = delta * float(adaptive_tolerance)\n\tadaptive_recursion = int(adaptive_recursion)\n\n\twhile i < len(data) - 1:\n\t   for p in adaptive_refinement(f, data[i], data[i+1],\n\t\t\t\t\t\t\t\t\t adaptive_tolerance=adaptive_tolerance,\n\t\t\t\t\t\t\t\t\t adaptive_recursion=adaptive_recursion):\n\t\t\tdata.insert(i+1, p)\n\t\t\ti += 1\n\t   i += 1\n\n\tif (len(data) == 0 and exceptions > 0) or exceptions > 10:\n\t\tsage.misc.misc.verbose(\"WARNING: When plotting, failed to evaluate function at %s points.\"%exceptions, level=0)\n\t\tsage.misc.misc.verbose(\"Last error message: '%s'\"%msg, level=0)\n\n\treturn data\n", "description": "\n\tCalculate plot points for a function f in the interval xrange.  The\n\tadaptive refinement algorithm is also automatically invoked with a\n\t*relative* adaptive tolerance of adaptive_tolerance; see below.\n\n\tINPUT:\n\n\t- ``f`` - a function of one variable\n\n\t- ``p1, p2`` - two points to refine between\n\n\t- ``plot_points`` - (default: 5) the minimal number of plot points. (Note\n\t  however that in any actual plot a number is passed to this, with default\n\t  value 200.)\n\n\t- ``adaptive_recursion`` - (default: 5) how many levels of recursion to go\n\t  before giving up when doing adaptive refinement.  Setting this to 0\n\t  disables adaptive refinement.\n\n\t- ``adaptive_tolerance`` - (default: 0.01) how large the relative difference\n\t  should be before the adaptive refinement code considers it significant.  If\n\t  the actual difference is greater than adaptive_tolerance*delta, where delta\n\t  is the initial subinterval size for the given xrange and plot_points, then\n\t  the algorithm will consider it significant.\n\n\t- ``initial_points`` - (default: None) a list of points that should be evaluated.\n\n\tOUTPUT:\n\n\t- a list of points (x, f(x)) in the interval xrange, which approximate\n\t  the function f.\n\n\tTESTS::\n\n\t\tsage: from sage.plot.plot import generate_plot_points\n\t\tsage: generate_plot_points(sin, (0, pi), plot_points=2, adaptive_recursion=0)\n\t\t[(0.0, 0.0), (3.141592653589793, 1.2246...e-16)]\n\n\t\tsage: from sage.plot.plot import generate_plot_points\n\t\tsage: generate_plot_points(lambda x: x^2, (0, 6), plot_points=2, adaptive_recursion=0, initial_points = [1,2,3])\n\t\t[(0.0, 0.0), (1.0, 1.0), (2.0, 4.0), (3.0, 9.0), (6.0, 36.0)]\n\n\t\tsage: generate_plot_points(sin(x).function(x), (-pi, pi), randomize=False)\n\t\t[(-3.141592653589793, -1.2246...e-16), (-2.748893571891069,\n\t\t-0.3826834323650899), (-2.356194490192345, -0.707106781186547...),\n\t\t(-2.1598449493429825, -0.831469612302545...), (-1.9634954084936207,\n\t\t-0.9238795325112867), (-1.7671458676442586, -0.9807852804032304),\n\t\t(-1.5707963267948966, -1.0), (-1.3744467859455345,\n\t\t-0.9807852804032304), (-1.1780972450961724, -0.9238795325112867),\n\t\t(-0.9817477042468103, -0.831469612302545...), (-0.7853981633974483,\n\t\t-0.707106781186547...), (-0.39269908169872414, -0.3826834323650898),\n\t\t(0.0, 0.0), (0.39269908169872414, 0.3826834323650898),\n\t\t(0.7853981633974483, 0.707106781186547...), (0.9817477042468103,\n\t\t0.831469612302545...), (1.1780972450961724, 0.9238795325112867),\n\t\t(1.3744467859455345, 0.9807852804032304), (1.5707963267948966, 1.0),\n\t\t(1.7671458676442586, 0.9807852804032304), (1.9634954084936207,\n\t\t0.9238795325112867), (2.1598449493429825, 0.831469612302545...),\n\t\t(2.356194490192345, 0.707106781186547...), (2.748893571891069,\n\t\t0.3826834323650899), (3.141592653589793, 1.2246...e-16)]\n\n\tThis shows that lowering adaptive_tolerance and raising\n\tadaptive_recursion both increase the number of subdivision points.\n\t(Note that which creates more points is heavily dependent on the\n\tparticular function plotted.)\n\n\t::\n\n\t\tsage: x = var('x')\n\t\tsage: f(x) = sin(1/x)\n\t\tsage: [len(generate_plot_points(f, (-pi, pi), plot_points=16, adaptive_tolerance=i, randomize=False)) for i in [0.01, 0.001, 0.0001]]\n\t\t[97, 161, 275]\n\n\t\tsage: [len(generate_plot_points(f, (-pi, pi), plot_points=16, adaptive_recursion=i, randomize=False)) for i in [5, 10, 15]]\n\t\t[97, 499, 2681]\n\t", "category": "graphics", "imports": ["\tsage: from pylab import *", "Verify that a clean sage startup does *not* import matplotlib::", "import os", "from functools import reduce", "## IMPORTANT: Do *not* import matplotlib at module scope.  It takes a", "## imported in functions, so it only gets started if it is actually", "import sage.misc.misc", "from sage.misc.misc import srange", "from sage.misc.randstate import current_randstate #for plot adaptive refinement", "from math import sin, cos, pi #for polar_plot", "from sage.ext.fast_eval import fast_float, fast_float_constant, is_fast_float", "from sage.misc.decorators import options, rename_keyword", "from graphics import Graphics, GraphicsArray", "#\timport matplotlib.transforms as mtransforms", "\tIt is important to mention that when we draw several graphs at the same time,", "\tfrom sage.structure.element import is_Vector", "\t\tsage: from sage.plot.plot import _plot", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "\t\tfrom sage.plot.colors import rainbow", "\t\tfrom sage.symbolic.expression import Expression", "\tfrom sage.plot.all import line, text", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.misc.superseded import deprecation", "\t\tfrom sage.misc.superseded import deprecation", "\t\tsage: import numpy", "\tfrom sage.plot.all import line, point", "\t\tfrom sage.rings.all import RDF", "\t\tfrom sage.rings.complex_field import ComplexField", "\t\tsage: from sage.plot.plot import to_float_list", "\t\tsage: from sage.plot.plot import var_and_list_of_values", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.misc.superseded import deprecation", "\tfrom sage.plot.misc import setup_for_eval_on_grid as setup", "\t\tsage: from sage.plot.plot import minmax_data", "\t\tsage: from sage.plot.plot import adaptive_refinement", "\t\tsage: from sage.plot.plot import generate_plot_points", "\t\tsage: from sage.plot.plot import generate_plot_points", "\tfrom sage.plot.misc import setup_for_eval_on_grid", "from line import line, line2d, Line as GraphicPrimitive_Line", "from arrow import arrow, Arrow as GraphicPrimitive_Arrow", "from bar_chart import bar_chart, BarChart as GraphicPrimitive_BarChart", "from disk import disk, Disk as GraphicPrimitive_Disk", "from point import point, points, point2d, Point as GraphicPrimitive_Point", "from matrix_plot import matrix_plot, MatrixPlot as GraphicPrimitive_MatrixPlot", "from plot_field import plot_vector_field, plot_slope_field, PlotField as GraphicPrimitive_PlotField", "from text import text, Text as GraphicPrimitive_Text", "from polygon import polygon, Polygon as GraphicPrimitive_Polygon", "from circle import circle, Circle as GraphicPrimtive_Circle", "from contour_plot import contour_plot, implicit_plot, ContourPlot as GraphicPrimitive_ContourPlot"]}], [{"term": "def", "name": "show_default", "data": "def show_default(default=None):\n\tr\"\"\"\n\tSet the default for showing plots using any plot commands. If\n\tcalled with no arguments, returns the current default.\n\n\tIf this is ``True`` (the default) then any plot object\n\twhen displayed will be displayed as an actual plot instead of text,\n\ti.e., the show command is not needed.\n\n\tEXAMPLES:\n\n\tThe default starts out as ``True`` in interactive use and\n\t``False`` in doctests::\n\n\t\tsage: show_default()  # long time\n\t\tdoctest:...: DeprecationWarning: this is done automatically by the doctest framework\n\t\tSee http://trac.sagemath.org/14469 for details.\n\t\tFalse\n\t\"\"\"\n\tfrom sage.misc.superseded import deprecation\n\tdeprecation(14469, 'this is done automatically by the doctest framework')\n\timport sage.doctest\n\tif default is None:\n\t\treturn not sage.doctest.DOCTEST_MODE\n\tsage.doctest.DOCTEST_MODE = not bool(default)\n", "description": "\n\tSet the default for showing plots using any plot commands. If\n\tcalled with no arguments, returns the current default.\n\n\tIf this is ``True`` (the default) then any plot object\n\twhen displayed will be displayed as an actual plot instead of text,\n\ti.e., the show command is not needed.\n\n\tEXAMPLES:\n\n\tThe default starts out as ``True`` in interactive use and\n\t``False`` in doctests::\n\n\t\tsage: show_default()  # long time\n\t\tdoctest:...: DeprecationWarning: this is done automatically by the doctest framework\n\t\tSee http://trac.sagemath.org/14469 for details.\n\t\tFalse\n\t", "category": "graphics", "imports": ["import os", "from math import isnan", "import sage.misc.misc", "from sage.misc.html import html", "from sage.misc.temporary_file import tmp_filename", "from sage.misc.fast_methods import WithEqualityById", "from sage.structure.sage_object import SageObject", "from sage.misc.decorators import suboptions", "from colors import rgbcolor", "\tfrom sage.misc.superseded import deprecation", "\timport sage.doctest", "\t\tsage: from sage.plot.graphics import is_Graphics", "\t\t\tsage: from sage.repl.rich_output import get_display_manager", "\t\tfrom sage.plot.primitive import GraphicPrimitive", "\t\t\tfrom sage.plot.plot3d.base import Graphics3d", "\t\t\tsage: from sage.plot.line import Line", "\t\t\tsage: from sage.plot.arrow import Arrow", "\t\tfrom sage.plot.plot3d.base import Graphics3dGroup", "\t\t  locators, type ``from matplotlib import ticker`` and then", "\t\t  formatters, type ``from matplotlib import ticker`` and then", "\t\t\tfrom sage.misc.superseded import deprecation", "\t\t\t\tfrom sage.misc.temporary_file import graphics_filename", "\t\tfrom sage.repl.rich_output import get_display_manager", "\t\t\tsage: from matplotlib.figure import Figure", "\t\tfrom matplotlib.ticker import (FixedLocator, Locator,", "\t\t\tfrom sage.functions.other import ceil, floor", "\t\t\tfrom sage.functions.other import ceil, floor", "\t\tfrom matplotlib.ticker import FuncFormatter, FixedFormatter", "\t\tfrom sage.misc.latex import latex", "\t\tfrom sage.symbolic.ring import SR", "\t\t\tfrom misc import _multiple_of_constant", "\t\t\tfrom misc import _multiple_of_constant", "\t\tfrom warnings import warn", "\t\timport math", "\t\tfrom sage.symbolic.ring import SR", "\t\tfrom matplotlib.figure import Figure", "\t\tfrom matplotlib import rcParams", "\t\t\tfrom matplotlib.font_manager import FontProperties", "\t\t\t\tfrom sage.plot.colors import to_mpl_color", "\t\t\t\tfrom sage.plot.plot import SelectiveFormatter", "\t\t\tfrom matplotlib.ticker import NullFormatter, NullLocator", "\t\t\tfrom matplotlib.ticker import (AutoMinorLocator, FixedLocator,", "\t\t\t\tfrom sage.misc.misc import srange", "\t\t\t\tfrom sage.misc.misc import srange", "\t\t\t\tfrom matplotlib.transforms import offset_copy", "\t\t\tfrom sage.misc.superseded import deprecation", "\t\t\tfrom sage.misc.temporary_file import graphics_filename", "\t\t\tfrom matplotlib import rcParams", "\t\t\tfrom matplotlib.backends.backend_agg import FigureCanvasAgg", "\t\t\tsage: from sage.repl.rich_output import get_display_manager", "\t\t\tsage: from sage.plot.graphics import GraphicsArray", "\t\t\tfrom sage.misc.superseded import deprecation", "\t\t\tfrom sage.misc.temporary_file import graphics_filename", "\t\tfrom matplotlib.figure import Figure", "\t\tfrom sage.repl.rich_output import get_display_manager"]}, {"term": "def", "name": "is_Graphics", "data": "def is_Graphics(x):\n\t\"\"\"\n\tReturn True if `x` is a Graphics object.\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.graphics import is_Graphics\n\t\tsage: is_Graphics(1)\n\t\tFalse\n\t\tsage: is_Graphics(disk((0.0, 0.0), 1, (0, pi/2)))\n\t\tTrue\n\t\"\"\"\n\treturn isinstance(x, Graphics)\n", "description": "\n\tReturn True if `x` is a Graphics object.\n\n\tEXAMPLES::\n\n\t\tsage: from sage.plot.graphics import is_Graphics\n\t\tsage: is_Graphics(1)\n\t\tFalse\n\t\tsage: is_Graphics(disk((0.0, 0.0), 1, (0, pi/2)))\n\t\tTrue\n\t", "category": "graphics", "imports": ["import os", "from math import isnan", "import sage.misc.misc", "from sage.misc.html import html", "from sage.misc.temporary_file import tmp_filename", "from sage.misc.fast_methods import WithEqualityById", "from sage.structure.sage_object import SageObject", "from sage.misc.decorators import suboptions", "from colors import rgbcolor", "\tfrom sage.misc.superseded import deprecation", "\timport sage.doctest", "\t\tsage: from sage.plot.graphics import is_Graphics", "\t\t\tsage: from sage.repl.rich_output import get_display_manager", "\t\tfrom sage.plot.primitive import GraphicPrimitive", "\t\t\tfrom sage.plot.plot3d.base import Graphics3d", "\t\t\tsage: from sage.plot.line import Line", "\t\t\tsage: from sage.plot.arrow import Arrow", "\t\tfrom sage.plot.plot3d.base import Graphics3dGroup", "\t\t  locators, type ``from matplotlib import ticker`` and then", "\t\t  formatters, type ``from matplotlib import ticker`` and then", "\t\t\tfrom sage.misc.superseded import deprecation", "\t\t\t\tfrom sage.misc.temporary_file import graphics_filename", "\t\tfrom sage.repl.rich_output import get_display_manager", "\t\t\tsage: from matplotlib.figure import Figure", "\t\tfrom matplotlib.ticker import (FixedLocator, Locator,", "\t\t\tfrom sage.functions.other import ceil, floor", "\t\t\tfrom sage.functions.other import ceil, floor", "\t\tfrom matplotlib.ticker import FuncFormatter, FixedFormatter", "\t\tfrom sage.misc.latex import latex", "\t\tfrom sage.symbolic.ring import SR", "\t\t\tfrom misc import _multiple_of_constant", "\t\t\tfrom misc import _multiple_of_constant", "\t\tfrom warnings import warn", "\t\timport math", "\t\tfrom sage.symbolic.ring import SR", "\t\tfrom matplotlib.figure import Figure", "\t\tfrom matplotlib import rcParams", "\t\t\tfrom matplotlib.font_manager import FontProperties", "\t\t\t\tfrom sage.plot.colors import to_mpl_color", "\t\t\t\tfrom sage.plot.plot import SelectiveFormatter", "\t\t\tfrom matplotlib.ticker import NullFormatter, NullLocator", "\t\t\tfrom matplotlib.ticker import (AutoMinorLocator, FixedLocator,", "\t\t\t\tfrom sage.misc.misc import srange", "\t\t\t\tfrom sage.misc.misc import srange", "\t\t\t\tfrom matplotlib.transforms import offset_copy", "\t\t\tfrom sage.misc.superseded import deprecation", "\t\t\tfrom sage.misc.temporary_file import graphics_filename", "\t\t\tfrom matplotlib import rcParams", "\t\t\tfrom matplotlib.backends.backend_agg import FigureCanvasAgg", "\t\t\tsage: from sage.repl.rich_output import get_display_manager", "\t\t\tsage: from sage.plot.graphics import GraphicsArray", "\t\t\tfrom sage.misc.superseded import deprecation", "\t\t\tfrom sage.misc.temporary_file import graphics_filename", "\t\tfrom matplotlib.figure import Figure", "\t\tfrom sage.repl.rich_output import get_display_manager"]}, {"term": "class", "name": "Graphics", "data": "class Graphics(WithEqualityById, SageObject):\n\t\"\"\"\n\tThe Graphics object is an empty list of graphics objects. It is\n\tuseful to use this object when initializing a for loop where\n\tdifferent graphics object will be added to the empty object.\n\n\tEXAMPLES::\n\n\t\tsage: G = Graphics(); print G\n\t\tGraphics object consisting of 0 graphics primitives\n\t\tsage: c = circle((1,1), 1)\n\t\tsage: G+=c; print G\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere we make a graphic of embedded isosceles triangles, coloring\n\teach one with a different color as we go::\n\n\t\tsage: h=10; c=0.4; p=0.5;\n\t\tsage: G = Graphics()\n\t\tsage: for x in srange(1,h+1):\n\t\t....:\t l = [[0,x*sqrt(3)],[-x/2,-x*sqrt(3)/2],[x/2,-x*sqrt(3)/2],[0,x*sqrt(3)]]\n\t\t....:\t G+=line(l,color=hue(c + p*(x/h)))\n\t\tsage: G.show(figsize=[5,5])\n\n\tWe can change the scale of the axes in the graphics before displaying.::\n\n\t\tsage: G = plot(exp, 1, 10) # long time\n\t\tsage: G.show(scale='semilogy') # long time\n\n\tTESTS:\n\n\tFrom :trac:`4604`, ensure Graphics can handle 3d objects::\n\n\t\tsage: g = Graphics()\n\t\tsage: g += sphere((1, 1, 1), 2)\n\t\tsage: g.show()\n\n\tWe check that graphics can be pickled (we can't use equality on\n\tgraphics so we just check that the load/dump cycle gives a\n\t:class:`Graphics` instance)::\n\n\t\tsage: g = Graphics()\n\t\tsage: g2 = loads(dumps(g))\n\t\tsage: g2.show()\n\n\t::\n\n\t\tsage: isinstance(g2, Graphics)\n\t\tTrue\n\n\tTESTS::\n\n\t\tsage: hash(Graphics()) # random\n\t\t42\n\n\t.. automethod:: _rich_repr_\n\t\"\"\"\n\n\tdef __init__(self):\n\t\t\"\"\"\n\t\tCreate a new empty Graphics objects with all the defaults.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: G = Graphics()\n\t\t\"\"\"\n\t\tself._axes_color = (0, 0, 0)\n\t\tself._axes_label_color = (0, 0, 0)\n\t\tself._axes_width = 0.8\n\t\tself._bbox_extra_artists = []\n\t\tself._extra_kwds = {}\n\t\tself._fontsize = 10\n\t\tself._axes_labels_size = 1.6\n\t\tself._legend_colors = []\n\t\tself._legend_opts = {}\n\t\tself._objects = []\n\t\tself._show_axes = True\n\t\tself._show_legend = False\n\t\tself._tick_label_color = (0, 0, 0)\n\n\tdef set_aspect_ratio(self, ratio):\n\t\t\"\"\"\n\t\tSet the aspect ratio, which is the ratio of height and width\n\t\tof a unit square (i.e., height/width of a unit square), or\n\t\t'automatic' (expand to fill the figure).\n\n\t\tINPUT:\n\n\n\t\t-  ``ratio`` - a positive real number or 'automatic'\n\n\n\t\tEXAMPLES: We create a plot of the upper half of a circle, but it\n\t\tdoesn't look round because the aspect ratio is off::\n\n\t\t\tsage: P = plot(sqrt(1-x^2),(x,-1,1)); P\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tSo we set the aspect ratio and now it is round::\n\n\t\t\tsage: P.set_aspect_ratio(1)\n\t\t\tsage: P.aspect_ratio()\n\t\t\t1.0\n\t\t\tsage: P\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tNote that the aspect ratio is inherited upon addition (which takes\n\t\tthe max of aspect ratios of objects whose aspect ratio has been\n\t\tset)::\n\n\t\t\tsage: P + plot(sqrt(4-x^2),(x,-2,2))\n\t\t\tGraphics object consisting of 2 graphics primitives\n\n\t\tIn the following example, both plots produce a circle that looks\n\t\ttwice as tall as wide::\n\n\t\t\tsage: Q = circle((0,0), 0.5); Q.set_aspect_ratio(2)\n\t\t\tsage: (P + Q).aspect_ratio(); P+Q\n\t\t\t2.0\n\t\t\tGraphics object consisting of 2 graphics primitives\n\t\t\tsage: (Q + P).aspect_ratio(); Q+P\n\t\t\t2.0\n\t\t\tGraphics object consisting of 2 graphics primitives\n\t\t\"\"\"\n\t\tif ratio != 'auto' and ratio != 'automatic':\n\t\t\tratio = float(ratio)\n\t\t\tif ratio <= 0:\n\t\t\t\traise ValueError(\"the aspect ratio must be positive or 'automatic'\")\n\t\telse:\n\t\t\tratio = 'automatic'\n\t\tself._extra_kwds['aspect_ratio'] = ratio\n\n\tdef aspect_ratio(self):\n\t\t\"\"\"\n\t\tGet the current aspect ratio, which is the ratio of height to\n\t\twidth of a unit square, or 'automatic'.\n\n\t\tOUTPUT: a positive float (height/width of a unit square), or 'automatic'\n\t\t(expand to fill the figure).\n\n\t\tEXAMPLES:\n\n\t\tThe default aspect ratio for a new blank Graphics object is 'automatic'::\n\n\t\t\tsage: P = Graphics()\n\t\t\tsage: P.aspect_ratio()\n\t\t\t'automatic'\n\n\t\tThe aspect ratio can be explicitly set different than the object's default::\n\n\t\t\tsage: P = circle((1,1), 1)\n\t\t\tsage: P.aspect_ratio()\n\t\t\t1.0\n\t\t\tsage: P.set_aspect_ratio(2)\n\t\t\tsage: P.aspect_ratio()\n\t\t\t2.0\n\t\t\tsage: P.set_aspect_ratio('automatic')\n\t\t\tsage: P.aspect_ratio()\n\t\t\t'automatic'\n\t\t\"\"\"\n\t\treturn self._extra_kwds.get('aspect_ratio', 'automatic')\n\n\tdef legend(self, show=None):\n\t\tr\"\"\"\n\t\tSet whether or not the legend is shown by default.\n\n\t\tINPUT:\n\n\t\t-  ``show`` - (default: None) a boolean\n\n\t\tIf called with no input, return the current legend setting.\n\n\t\tEXAMPLES:\n\n\t\tBy default no legend is displayed::\n\n\t\t\tsage: P = plot(sin)\n\t\t\tsage: P.legend()\n\t\t\tFalse\n\n\t\tBut if we put a label then the legend is shown::\n\n\t\t\tsage: P = plot(sin, legend_label='sin')\n\t\t\tsage: P.legend()\n\t\t\tTrue\n\n\t\tWe can turn it on or off::\n\n\t\t\tsage: P.legend(False)\n\t\t\tsage: P.legend()\n\t\t\tFalse\n\t\t\tsage: P.legend(True)\n\t\t\tsage: P # show with the legend\n\t\t\tGraphics object consisting of 1 graphics primitive\n\t\t\"\"\"\n\t\tif show is None:\n\t\t\treturn self._show_legend\n\t\telse:\n\t\t\tself._show_legend = bool(show)\n\n\tdef set_legend_options(self, **kwds):\n\t\tr\"\"\"\n\t\tSet various legend options.\n\n\t\tINPUT:\n\n\t\t- ``title`` - (default: None) string, the legend title\n\n\t\t- ``ncol`` - (default: 1) positive integer, the number of columns\n\n\t\t- ``columnspacing`` - (default: None) the spacing between columns\n\n\t\t- ``borderaxespad`` - (default: None) float, length between the axes and the legend\n\n\t\t- ``back_color`` - (default: (0.9, 0.9, 0.9)) This parameter can be a string\n\t\t  denoting a color or an RGB tuple. The string can be a color name\n\t\t  as in ('red', 'green', 'yellow', ...) or a floating point number\n\t\t  like '0.8' which gets expanded to (0.8, 0.8, 0.8). The\n\t\t  tuple form is just a floating point RGB tuple with all values ranging\n\t\t  from 0 to 1.\n\n\t\t- ``handlelength`` - (default: 0.05) float, the length of the legend handles\n\n\t\t- ``handletextpad`` - (default: 0.5) float, the pad between the legend handle and text\n\n\t\t- ``labelspacing`` - (default: 0.02) float, vertical space between legend entries\n\n\t\t- ``loc`` - (default: 'best') May be a string, an integer or a tuple. String or\n\t\t\t  integer inputs must be one of the following:\n\n\t\t  - 0, 'best'\n\n\t\t  - 1, 'upper right'\n\n\t\t  - 2, 'upper left'\n\n\t\t  - 3, 'lower left'\n\n\t\t  - 4, 'lower right'\n\n\t\t  - 5, 'right'\n\n\t\t  - 6, 'center left'\n\n\t\t  - 7, 'center right'\n\n\t\t  - 8, 'lower center'\n\n\t\t  - 9, 'upper center'\n\n\t\t  - 10, 'center'\n\n\t\t  - Tuple arguments represent an absolute (x, y) position on the plot\n\t\t\tin axes coordinates (meaning from 0 to 1 in each direction).\n\n\t\t- ``markerscale`` - (default: 0.6) float, how much to scale the markers in the legend.\n\n\t\t- ``numpoints`` - (default: 2) integer, the number of points in the legend for line\n\n\t\t- ``borderpad`` - (default: 0.6) float, the fractional whitespace inside the legend border\n\t\t  (between 0 and 1)\n\n\t\t- ``font_family`` - (default: 'sans-serif') string, one of 'serif', 'sans-serif',\n\t\t  'cursive', 'fantasy', 'monospace'\n\n\t\t- ``font_style`` - (default: 'normal') string, one of 'normal', 'italic', 'oblique'\n\n\t\t- ``font_variant`` - (default: 'normal') string, one of 'normal', 'small-caps'\n\n\t\t- ``font_weight`` - (default: 'medium') string, one of 'black', 'extra bold', 'bold',\n\t\t  'semibold', 'medium', 'normal', 'light'\n\n\t\t- ``font_size`` - (default: 'medium') string, one of 'xx-small', 'x-small', 'small',\n\t\t  'medium', 'large', 'x-large', 'xx-large' or an absolute font size (e.g. 12)\n\n\t\t-  ``shadow`` - (default: False) boolean - draw a shadow behind the legend\n\n\t\t- ``fancybox`` - (default: False) a boolean.  If True, draws a frame with a round\n\t\t  fancybox.\n\n\t\tThese are all keyword arguments.\n\n\t\tOUTPUT: a dictionary of all current legend options\n\n\t\tEXAMPLES:\n\n\t\tBy default, no options are set::\n\n\t\t\tsage: p = plot(tan, legend_label='tan')\n\t\t\tsage: p.set_legend_options()\n\t\t\t{}\n\n\t\tWe build a legend with a shadow::\n\n\t\t\tsage: p.set_legend_options(shadow=True)\n\t\t\tsage: p.set_legend_options()['shadow']\n\t\t\tTrue\n\n\t\tTo set the legend position to the center of the plot, all these\n\t\tmethods are roughly equivalent::\n\n\t\t\tsage: p.set_legend_options(loc='center'); p\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\t::\n\n\t\t\tsage: p.set_legend_options(loc=10); p\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\t::\n\n\t\t\tsage: p.set_legend_options(loc=(0.5,0.5)); p # aligns the bottom of the box to the center\n\t\t\tGraphics object consisting of 1 graphics primitive\n\t\t\"\"\"\n\t\tif len(kwds) == 0:\n\t\t\treturn self._legend_opts\n\t\telse:\n\t\t\tself._legend_opts.update(kwds)\n\n\n\tdef get_axes_range(self):\n\t\t\"\"\"\n\t\tReturns a dictionary of the range of the axes for this graphics\n\t\tobject.  This is fall back to the ranges in get_minmax_data() for\n\t\tany value which the user has not explicitly set.\n\n\t\t.. warning::\n\n\t\t   Changing the dictionary returned by this function does not\n\t\t   change the axes range for this object.  To do that, use the\n\t\t   :meth:`set_axes_range` method.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: L = line([(1,2), (3,-4), (2, 5), (1,2)])\n\t\t\tsage: list(sorted(L.get_axes_range().items()))\n\t\t\t[('xmax', 3.0), ('xmin', 1.0), ('ymax', 5.0), ('ymin', -4.0)]\n\t\t\tsage: L.set_axes_range(xmin=-1)\n\t\t\tsage: list(sorted(L.get_axes_range().items()))\n\t\t\t[('xmax', 3.0), ('xmin', -1.0), ('ymax', 5.0), ('ymin', -4.0)]\n\t\t\"\"\"\n\t\taxes_range = self.get_minmax_data()\n\t\taxes_range.update(self._get_axes_range_dict())\n\t\treturn axes_range\n\n\tdef set_axes_range(self, xmin=None, xmax=None, ymin=None, ymax=None):\n\t\t\"\"\"\n\t\tSet the ranges of the `x` and `y` axes.\n\n\t\tINPUT:\n\n\n\t\t-  ``xmin, xmax, ymin, ymax`` - floats\n\n\n\t\tEXAMPLES::\n\n\t\t\tsage: L = line([(1,2), (3,-4), (2, 5), (1,2)])\n\t\t\tsage: L.set_axes_range(-1, 20, 0, 2)\n\t\t\tsage: d = L.get_axes_range()\n\t\t\tsage: d['xmin'], d['xmax'], d['ymin'], d['ymax']\n\t\t\t(-1.0, 20.0, 0.0, 2.0)\n\t\t\"\"\"\n\t\tl = locals()\n\t\taxes_range = self._get_axes_range_dict()\n\t\tfor name in ['xmin', 'xmax', 'ymin', 'ymax']:\n\t\t\tif l[name] is not None:\n\t\t\t\taxes_range[name] = float(l[name])\n\n\taxes_range = set_axes_range\n\n\tdef _get_axes_range_dict(self):\n\t\t\"\"\"\n\t\tReturns the underlying dictionary used to store the user's\n\t\tcustom ranges for the axes on this object.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: L = line([(1,2), (3,-4), (2, 5), (1,2)])\n\t\t\tsage: L._get_axes_range_dict()\n\t\t\t{}\n\t\t\tsage: L.set_axes_range(xmin=-1)\n\t\t\tsage: L._get_axes_range_dict()\n\t\t\t{'xmin': -1.0}\n\t\t\"\"\"\n\t\ttry:\n\t\t\treturn self._axes_range\n\t\texcept AttributeError:\n\t\t\tself._axes_range = {}\n\t\t\treturn self._axes_range\n\n\tdef fontsize(self, s=None):\n\t\t\"\"\"\n\t\tSet the font size of axes labels and tick marks.\n\n\t\tNote that the relative size of the axes labels font w.r.t. the tick\n\t\tmarks font can be adjusted via :meth:`axes_labels_size`.\n\n\t\tINPUT:\n\n\n\t\t-  ``s`` - integer, a font size in points.\n\n\n\t\tIf called with no input, return the current fontsize.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: L = line([(1,2), (3,-4), (2, 5), (1,2)])\n\t\t\tsage: L.fontsize()\n\t\t\t10\n\t\t\tsage: L.fontsize(20)\n\t\t\tsage: L.fontsize()\n\t\t\t20\n\n\t\tAll the numbers on the axes will be very large in this plot::\n\n\t\t\tsage: L\n\t\t\tGraphics object consisting of 1 graphics primitive\n\t\t\"\"\"\n\t\tif s is None:\n\t\t\ttry:\n\t\t\t\treturn self._fontsize\n\t\t\texcept AttributeError:\n\t\t\t\tself._fontsize = 10\n\t\t\t\treturn self._fontsize\n\t\tself._fontsize = int(s)\n\n\tdef axes_labels_size(self, s=None):\n\t\t\"\"\"\n\t\tSet the relative size of axes labels w.r.t. the axes tick marks.\n\n\t\tINPUT:\n\n\t\t- ``s`` - float, relative size of axes labels w.r.t. to the tick marks,\n\t\t  the size of the tick marks being set by :meth:`fontsize`.\n\n\t\tIf called with no input, return the current relative size.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: p = plot(sin(x^2), (x, -3, 3), axes_labels=['$x$','$y$'])\n\t\t\tsage: p.axes_labels_size() # default value\n\t\t\t1.6\n\t\t\tsage: p.axes_labels_size(2.5)\n\t\t\tsage: p.axes_labels_size()\n\t\t\t2.5\n\n\t\tNow the axes labels are large w.r.t. the tick marks::\n\n\t\t\tsage: p\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\t\"\"\"\n\t\tif s is None:\n\t\t\ttry:\n\t\t\t\treturn self._axes_labels_size\n\t\t\texcept AttributeError:\n\t\t\t\tself._axes_labels_size = 1.6\n\t\t\t\treturn self._axes_labels_size\n\t\tself._axes_labels_size = float(s)\n\n\tdef axes(self, show=None):\n\t\t\"\"\"\n\t\tSet whether or not the `x` and `y` axes are shown\n\t\tby default.\n\n\t\tINPUT:\n\n\n\t\t-  ``show`` - bool\n\n\n\t\tIf called with no input, return the current axes setting.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: L = line([(1,2), (3,-4), (2, 5), (1,2)])\n\n\t\tBy default the axes are displayed.\n\n\t\t::\n\n\t\t\tsage: L.axes()\n\t\t\tTrue\n\n\t\tBut we turn them off, and verify that they are off\n\n\t\t::\n\n\t\t\tsage: L.axes(False)\n\t\t\tsage: L.axes()\n\t\t\tFalse\n\n\t\tDisplaying L now shows a triangle but no axes.\n\n\t\t::\n\n\t\t\tsage: L\n\t\t\tGraphics object consisting of 1 graphics primitive\n\t\t\"\"\"\n\t\tif show is None:\n\t\t\ttry:\n\t\t\t\treturn self._show_axes\n\t\t\texcept AttributeError:\n\t\t\t\tself._show_axes = True\n\t\t\t\treturn self._show_axes\n\t\tself._show_axes = bool(show)\n\n\tdef axes_color(self, c=None):\n\t\t\"\"\"\n\t\tSet the axes color.\n\n\t\tIf called with no input, return the current axes_color setting.\n\n\t\tINPUT:\n\n\n\t\t-  ``c`` - an RGB color 3-tuple, where each tuple entry\n\t\t   is a float between 0 and 1\n\n\n\t\tEXAMPLES: We create a line, which has like everything a default\n\t\taxes color of black.\n\n\t\t::\n\n\t\t\tsage: L = line([(1,2), (3,-4), (2, 5), (1,2)])\n\t\t\tsage: L.axes_color()\n\t\t\t(0, 0, 0)\n\n\t\tWe change the axes color to red and verify the change.\n\n\t\t::\n\n\t\t\tsage: L.axes_color((1,0,0))\n\t\t\tsage: L.axes_color()\n\t\t\t(1.0, 0.0, 0.0)\n\n\t\tWhen we display the plot, we'll see a blue triangle and bright red\n\t\taxes.\n\n\t\t::\n\n\t\t\tsage: L\n\t\t\tGraphics object consisting of 1 graphics primitive\n\t\t\"\"\"\n\t\tif c is None:\n\t\t\ttry:\n\t\t\t\treturn self._axes_color\n\n\t\t\texcept AttributeError:\n\t\t\t\tself._axes_color = (0.0, 0.0, 0.0)\n\t\t\t\treturn self._axes_color\n\t\tself._axes_color = rgbcolor(c)\n\n\tdef axes_labels(self, l=None):\n\t\t\"\"\"\n\t\tSet the axes labels.\n\n\t\tINPUT:\n\n\n\t\t-  ``l`` - (default: None) a list of two strings or\n\t\t   None\n\n\n\t\tOUTPUT: a 2-tuple of strings\n\n\t\tIf l is None, returns the current ``axes_labels``,\n\t\twhich is itself by default None. The default labels are both\n\t\tempty.\n\n\t\tEXAMPLES: We create a plot and put x and y axes labels on it.\n\n\t\t::\n\n\t\t\tsage: p = plot(sin(x), (x, 0, 10))\n\t\t\tsage: p.axes_labels(['$x$','$y$'])\n\t\t\tsage: p.axes_labels()\n\t\t\t('$x$', '$y$')\n\n\t\tNow when you plot p, you see x and y axes labels::\n\n\t\t\tsage: p\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tNotice that some may prefer axes labels which are not\n\t\ttypeset::\n\n\t\t\tsage: plot(sin(x), (x, 0, 10), axes_labels=['x','y'])\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tTESTS:\n\n\t\tUnicode strings are acceptable; see :trac:`13161`. Note that\n\t\tthis does not guarantee that matplotlib will handle the strings\n\t\tproperly, although it should.\n\n\t\t::\n\n\t\t\tsage: c = circle((0,0), 1)\n\t\t\tsage: c.axes_labels(['axe des abscisses', u'axe des ordonn\u00c3\u00a9es'])\n\t\t\tsage: c._axes_labels\n\t\t\t('axe des abscisses', u'axe des ordonn\\xc3\\xa9es')\n\n\t\t\"\"\"\n\t\tif l is None:\n\t\t\ttry:\n\t\t\t\treturn self._axes_labels\n\t\t\texcept AttributeError:\n\t\t\t\tself._axes_labels = None\n\t\t\t\treturn self._axes_labels\n\t\tif not isinstance(l, (list, tuple)):\n\t\t\traise TypeError(\"l must be a list or tuple\")\n\t\tif len(l) != 2:\n\t\t\traise ValueError(\"l must have length 2\")\n\t\tself._axes_labels = tuple(l)\n\n\tdef axes_label_color(self, c=None):\n\t\tr\"\"\"\n\t\tSet the color of the axes labels.\n\n\t\tThe axes labels are placed at the edge of the x and y axes, and are\n\t\tnot on by default (use the ``axes_labels`` command to\n\t\tset them; see the example below). This function just changes their\n\t\tcolor.\n\n\t\tINPUT:\n\n\n\t\t-  ``c`` - an RGB 3-tuple of numbers between 0 and 1\n\n\n\t\tIf called with no input, return the current axes_label_color\n\t\tsetting.\n\n\t\tEXAMPLES: We create a plot, which by default has axes label color\n\t\tblack.\n\n\t\t::\n\n\t\t\tsage: p = plot(sin, (-1,1))\n\t\t\tsage: p.axes_label_color()\n\t\t\t(0, 0, 0)\n\n\t\tWe change the labels to be red, and confirm this::\n\n\t\t\tsage: p.axes_label_color((1,0,0))\n\t\t\tsage: p.axes_label_color()\n\t\t\t(1.0, 0.0, 0.0)\n\n\t\tWe set labels, since otherwise we won't see anything.\n\n\t\t::\n\n\t\t\tsage: p.axes_labels(['$x$ axis', '$y$ axis'])\n\n\t\tIn the plot below, notice that the labels are red::\n\n\t\t\tsage: p\n\t\t\tGraphics object consisting of 1 graphics primitive\n\t\t\"\"\"\n\t\tif c is None:\n\t\t\ttry:\n\t\t\t\treturn self._axes_label_color\n\t\t\texcept AttributeError:\n\t\t\t\tself._axes_label_color = (0, 0, 0)\n\t\t\t\treturn self._axes_label_color\n\t\tself._axes_label_color = rgbcolor(c)\n\n\n\tdef axes_width(self, w=None):\n\t\tr\"\"\"\n\t\tSet the axes width. Use this to draw a plot with really fat or\n\t\treally thin axes.\n\n\t\tINPUT:\n\n\n\t\t-  ``w`` - a float\n\n\n\t\tIf called with no input, return the current\n\t\t``axes_width`` setting.\n\n\t\tEXAMPLE: We create a plot, see the default axes width (with funny\n\t\tPython float rounding), then reset the width to 10 (very fat).\n\n\t\t::\n\n\t\t\tsage: p = plot(cos, (-3,3))\n\t\t\tsage: p.axes_width()\n\t\t\t0.8\n\t\t\tsage: p.axes_width(10)\n\t\t\tsage: p.axes_width()\n\t\t\t10.0\n\n\t\tFinally we plot the result, which is a graph with very fat axes.\n\n\t\t::\n\n\t\t\tsage: p\n\t\t\tGraphics object consisting of 1 graphics primitive\n\t\t\"\"\"\n\t\tif w is None:\n\t\t\ttry:\n\t\t\t\treturn self._axes_width\n\t\t\texcept AttributeError:\n\t\t\t\tself._axes_width = True\n\t\t\t\treturn self._axes_width\n\t\tself._axes_width = float(w)\n\n\tdef tick_label_color(self, c=None):\n\t\t\"\"\"\n\t\tSet the color of the axes tick labels.\n\n\t\tINPUT:\n\n\n\t\t-  ``c`` - an RGB 3-tuple of numbers between 0 and 1\n\n\n\t\tIf called with no input, return the current tick_label_color\n\t\tsetting.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: p = plot(cos, (-3,3))\n\t\t\tsage: p.tick_label_color()\n\t\t\t(0, 0, 0)\n\t\t\tsage: p.tick_label_color((1,0,0))\n\t\t\tsage: p.tick_label_color()\n\t\t\t(1.0, 0.0, 0.0)\n\t\t\tsage: p\n\t\t\tGraphics object consisting of 1 graphics primitive\n\t\t\"\"\"\n\t\tif c is None:\n\t\t\ttry:\n\t\t\t\treturn self._tick_label_color\n\t\t\texcept AttributeError:\n\t\t\t\tself._tick_label_color = (0, 0, 0)\n\t\t\t\treturn self._tick_label_color\n\t\tself._tick_label_color = rgbcolor(c)\n\n\tdef _repr_(self):\n\t\tr\"\"\"\n\t\tReturn a string representation of the graphics objects.\n\n\t\tOUTPUT:\n\n\t\tString.\n\n\t\tEXAMPLES:\n\n\t\tWe create a plot and call :meth:`show` on it, which causes it\n\t\tto be displayed as a plot::\n\n\t\t\tsage: P = plot(cos, (-1,1))\n\t\t\tsage: P.show()\n\n\t\tJust doing this also displays the plot::\n\n\t\t\tsage: P\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tUsing the Python `repr` or `str` commands do not display the\n\t\tplot::\n\n\t\t\tsage: repr(P)\n\t\t\t'Graphics object consisting of 1 graphics primitive'\n\t\t\tsage: str(P)\n\t\t\t'Graphics object consisting of 1 graphics primitive'\n\t\t\tsage: print(P)\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tTESTS::\n\n\t\t\tsage: P._repr_()\n\t\t\t'Graphics object consisting of 1 graphics primitive'\n\t\t\"\"\"\n\t\treturn self.__str__()\n\n\tdef _rich_repr_(self, display_manager, **kwds):\n\t\t\"\"\"\n\t\tRich Output Magic Method\n\n\t\tSee :mod:`sage.repl.rich_output` for details.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: from sage.repl.rich_output import get_display_manager\n\t\t\tsage: dm = get_display_manager()\n\t\t\tsage: g = Graphics()\n\t\t\tsage: g._rich_repr_(dm)\n\t\t\tOutputImagePng container\n\t\t\"\"\"\n\t\ttypes = display_manager.types\n\t\tprefer_raster = (\n\t\t\t('.png', types.OutputImagePng),\n\t\t\t('.jpg', types.OutputImageJpg),\n\t\t\t('.gif', types.OutputImageGif),\n\t\t)\n\t\tprefer_vector = (\n\t\t\t('.svg', types.OutputImageSvg),\n\t\t\t('.pdf', types.OutputImagePdf),\n\t\t)\n\t\tgraphics = display_manager.preferences.graphics\n\t\tif graphics == 'disable':\n\t\t\treturn\n\t\telif graphics == 'raster' or graphics is None:\n\t\t\tpreferred = prefer_raster + prefer_vector\n\t\telif graphics == 'vector':\n\t\t\tpreferred = prefer_vector + prefer_raster\n\t\telse:\n\t\t\traise ValueError('unknown graphics output preference')\n\t\tfor file_ext, output_container in preferred:\n\t\t\tif output_container in display_manager.supported_output():\n\t\t\t\treturn display_manager.graphics_from_save(\n\t\t\t\t\tself.save, kwds, file_ext, output_container)\n\n\tdef __str__(self):\n\t\tr\"\"\"\n\t\tReturn string representation of this plot.\n\n\t\tOUTPUT:\n\n\t\tString.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: S = circle((0,0), 2); S.__str__()\n\t\t\t'Graphics object consisting of 1 graphics primitive'\n\t\t\tsage: str(S)\n\t\t\t'Graphics object consisting of 1 graphics primitive'\n\t\t\tsage: print S\n\t\t\tGraphics object consisting of 1 graphics primitive\n\t\t\"\"\"\n\t\ts = \"Graphics object consisting of %s graphics primitives\"%(len(self))\n\t\tif len(self) == 1:\n\t\t\ts = s[:-1]\n\t\treturn s\n\n\tdef __getitem__(self, i):\n\t\t\"\"\"\n\t\tReturns the ith graphics primitive object:\n\n\t\tEXAMPLE::\n\n\t\t\tsage: G = circle((1,1),2) + circle((2,2),5); print G\n\t\t\tGraphics object consisting of 2 graphics primitives\n\t\t\tsage: G[1]\n\t\t\tCircle defined by (2.0,2.0) with r=5.0\n\t\t\"\"\"\n\t\treturn self._objects[i]\n\n\tdef __len__(self):\n\t\t\"\"\"\n\t\tIf G is of type Graphics, then len(G) gives the number of distinct\n\t\tgraphics primitives making up that object.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: G = circle((1,1),1) + circle((1,2),1) + circle((1,2),5); print G\n\t\t\tGraphics object consisting of 3 graphics primitives\n\t\t\tsage: len(G)\n\t\t\t3\n\t\t\"\"\"\n\t\treturn len(self._objects)\n\n\tdef __delitem__(self, i):\n\t\t\"\"\"\n\t\tIf G is of type Graphics, then del(G[i]) removes the ith distinct\n\t\tgraphic primitive making up that object.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: G = circle((1,1),1) + circle((1,2),1) + circle((1,2),5); print G\n\t\t\tGraphics object consisting of 3 graphics primitives\n\t\t\tsage: len(G)\n\t\t\t3\n\t\t\tsage: del(G[2])\n\t\t\tsage: print G\n\t\t\tGraphics object consisting of 2 graphics primitives\n\t\t\tsage: len(G)\n\t\t\t2\n\t\t\"\"\"\n\t\tdel self._objects[int(i)]\n\n\tdef __setitem__(self, i, x):\n\t\t\"\"\"\n\t\tYou can replace a GraphicPrimitive (point, line, circle, etc...) in\n\t\ta Graphics object G with any other GraphicPrimitive\n\n\t\tEXAMPLES::\n\n\t\t\tsage: G = circle((1,1),1) + circle((1,2),1) + circle((1,2),5); print G\n\t\t\tGraphics object consisting of 3 graphics primitives\n\n\t\t::\n\n\t\t\tsage: p = polygon([[1,3],[2,-2],[1,1],[1,3]]); print p\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\t::\n\n\t\t\tsage: G[1] = p[0]\n\t\t\tsage: G\t# show the plot\n\t\t\tGraphics object consisting of 3 graphics primitives\n\t\t\"\"\"\n\t\tfrom sage.plot.primitive import GraphicPrimitive\n\t\tif not isinstance(x, GraphicPrimitive):\n\t\t\traise TypeError(\"x must be a GraphicPrimitive\")\n\t\tself._objects[int(i)] = x\n\n\tdef __radd__(self, other):\n\t\t\"\"\"\n\t\tCompute and return other + this graphics object.\n\n\t\tThis only works when other is a Python int equal to 0. In all other\n\t\tcases a TypeError is raised. The main reason for this function is\n\t\tto make summing a list of graphics objects easier.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: S = circle((0,0), 2)\n\t\t\tsage: print int(0) + S\n\t\t\tGraphics object consisting of 1 graphics primitive\n\t\t\tsage: print S + int(0)\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tThe following would fail were it not for this function::\n\n\t\t\tsage: v = [circle((0,0), 2), circle((2,3), 1)]\n\t\t\tsage: print sum(v)\n\t\t\tGraphics object consisting of 2 graphics primitives\n\t\t\"\"\"\n\t\tif isinstance(other, (int, long)) and other == 0:\n\t\t\treturn self\n\t\traise TypeError\n\n\tdef __add__(self, other):\n\t\t\"\"\"\n\t\tIf you have any Graphics object G1, you can always add any other\n\t\tamount of Graphics objects G2,G3,... to form a new Graphics object:\n\t\tG4 = G1 + G2 + G3.\n\n\t\tThe xmin, xmax, ymin, and ymax properties of the graphics objects\n\t\tare expanded to include all objects in both scenes. If the aspect\n\t\tratio property of either or both objects are set, then the larger\n\t\taspect ratio is chosen, with 'automatic' being overridden by a\n\t\tnumeric aspect ratio.\n\n\t\tIf one of the graphics object is set to show a legend, then\n\t\tthe resulting object will also be set to show a legend. Legend\n\t\toptions are propagated if set. If the same legend option is\n\t\tpresent in both arguments, the latter value is used.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: g1 = plot(abs(sqrt(x^3-1)), (x,1,5), frame=True)\n\t\t\tsage: g2 = plot(-abs(sqrt(x^3-1)), (x,1,5), color='red')\n\t\t\tsage: g1 + g2  # displays the plot\n\t\t\tGraphics object consisting of 2 graphics primitives\n\n\t\tTESTS:\n\n\t\tExtra keywords to show are propagated::\n\n\t\t\tsage: (g1 + g2)._extra_kwds=={'aspect_ratio': 'automatic', 'frame': True}\n\t\t\tTrue\n\t\t\tsage: g1.set_aspect_ratio(2)\n\t\t\tsage: (g1+g2).aspect_ratio()\n\t\t\t2.0\n\t\t\tsage: g2.set_aspect_ratio(3)\n\t\t\tsage: (g1+g2).aspect_ratio()\n\t\t\t3.0\n\n\t\tAs are legend options, :trac:`12936`::\n\n\t\t\tsage: p1 = plot(x, x, 0, 1)\n\t\t\tsage: p2 = p1\n\t\t\tsage: p1.set_legend_options(back_color = 'white')\n\t\t\tsage: p2.set_legend_options(shadow = True)\n\t\t\tsage: p3 = p1 + p2\n\t\t\tsage: p3._legend_opts\n\t\t\t{'back_color': 'white', 'shadow': True}\n\n\t\tIf the same legend option is specified more than once, the\n\t\tlatter takes precedence::\n\n\t\t\tsage: p1 = plot(x, x, 0, 1)\n\t\t\tsage: p2 = p1\n\t\t\tsage: p1.set_legend_options(shadow = True)\n\t\t\tsage: p2.set_legend_options(shadow = False)\n\t\t\tsage: p3 = p1 + p2\n\t\t\tsage: p3._legend_opts\n\t\t\t{'shadow': False}\n\n\t\t\"\"\"\n\t\tif isinstance(other, int) and other == 0:\n\t\t\treturn self\n\t\tif not isinstance(other, Graphics):\n\t\t\tfrom sage.plot.plot3d.base import Graphics3d\n\t\t\tif isinstance(other, Graphics3d):\n\t\t\t\treturn self.plot3d() + other\n\t\t\traise TypeError(\"other (=%s) must be a Graphics objects\"%other)\n\t\tg = Graphics()\n\t\tg._objects = self._objects + other._objects\n\t\tg._show_legend = self._show_legend or other._show_legend\n\t\tg._extra_kwds.update(self._extra_kwds)\n\t\tg._extra_kwds.update(other._extra_kwds)\n\t\tg._legend_colors = self._legend_colors + other._legend_colors\n\t\tg._legend_opts.update(self._legend_opts)\n\t\tg._legend_opts.update(other._legend_opts)\n\t\tif self.aspect_ratio()=='automatic':\n\t\t\tg.set_aspect_ratio(other.aspect_ratio())\n\t\telif other.aspect_ratio()=='automatic':\n\t\t\tg.set_aspect_ratio(self.aspect_ratio())\n\t\telse:\n\t\t\tg.set_aspect_ratio(max(self.aspect_ratio(), other.aspect_ratio()))\n\t\treturn g\n\n\tdef add_primitive(self, primitive):\n\t\t\"\"\"\n\t\tAdds a primitive to this graphics object.\n\n\t\tEXAMPLES:\n\n\t\tWe give a very explicit example::\n\n\t\t\tsage: G = Graphics()\n\t\t\tsage: from sage.plot.line import Line\n\t\t\tsage: from sage.plot.arrow import Arrow\n\t\t\tsage: L = Line([3,4,2,7,-2],[1,2,e,4,5.],{'alpha':1,'thickness':2,'rgbcolor':(0,1,1),'legend_label':''})\n\t\t\tsage: A = Arrow(2,-5,.1,.2,{'width':3,'head':0,'rgbcolor':(1,0,0),'linestyle':'dashed','zorder':8,'legend_label':''})\n\t\t\tsage: G.add_primitive(L)\n\t\t\tsage: G.add_primitive(A)\n\t\t\tsage: G\n\t\t\tGraphics object consisting of 2 graphics primitives\n\t\t\"\"\"\n\t\tself._objects.append(primitive)\n\n\tdef plot(self, *args, **kwds):\n\t\t\"\"\"\n\t\tDraw a 2D plot of this graphics object, which just returns this\n\t\tobject since this is already a 2D graphics object.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: S = circle((0,0), 2)\n\t\t\tsage: S.plot() is S\n\t\t\tTrue\n\t\t\"\"\"\n\t\treturn self\n\n\tdef plot3d(self, z=0, **kwds):\n\t\t\"\"\"\n\t\tReturns an embedding of this 2D plot into the xy-plane of 3D space,\n\t\tas a 3D plot object. An optional parameter z can be given to\n\t\tspecify the z-coordinate.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: sum([plot(z*sin(x), 0, 10).plot3d(z) for z in range(6)]) # long time\n\t\t\tGraphics3d Object\n\t\t\"\"\"\n\t\tfrom sage.plot.plot3d.base import Graphics3dGroup\n\t\tg = Graphics3dGroup([g.plot3d(**kwds) for g in self._objects])\n\t\tif z:\n\t\t\tg = g.translate(0,0,z)\n\t\treturn g\n\n\t@classmethod\n\tdef _extract_kwds_for_show(cls, kwds, ignore=[]):\n\t\t\"\"\"\n\t\tExtract keywords relevant to show() from the provided dictionary.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: kwds = {'f': lambda x: x, 'xmin': 0, 'figsize': [1,1], 'plot_points': (40, 40)}\n\t\t\tsage: G_kwds = Graphics._extract_kwds_for_show(kwds, ignore='xmin')\n\t\t\tsage: kwds # Note how this action modifies the passed dictionary\n\t\t\t{'f':  at 0x...>,\n\t\t\t 'plot_points': (40, 40),\n\t\t\t 'xmin': 0}\n\t\t\tsage: G_kwds\n\t\t\t{'figsize': [1, 1]}\n\n\t\tThis method is intended to be used with _set_extra_kwds(). Here is an\n\t\tidiom to ensure the correct keywords will get passed on to show()::\n\n\t\t\tsage: options = {} # Usually this will come from an argument\n\t\t\tsage: g = Graphics()\n\t\t\tsage: g._set_extra_kwds(Graphics._extract_kwds_for_show(options))\n\t\t\"\"\"\n\t\tresult = {}\n\t\tfor option in cls.SHOW_OPTIONS:\n\t\t\tif option not in ignore:\n\t\t\t\ttry:\n\t\t\t\t\tresult[option] = kwds.pop(option)\n\t\t\t\texcept KeyError:\n\t\t\t\t\tpass\n\t\treturn result\n\n\tdef _set_extra_kwds(self, kwds):\n\t\t\"\"\"\n\t\tSet a dictionary of keywords that will get passed on to show().\n\n\t\tTESTS::\n\n\t\t\tsage: g = Graphics()\n\t\t\tsage: g._extra_kwds\n\t\t\t{}\n\t\t\tsage: g._set_extra_kwds({'figsize': [10,10]})\n\t\t\tsage: g._extra_kwds\n\t\t\t{'figsize': [10, 10]}\n\t\t\tsage: g.show() # Now the (blank) plot will be extra large\n\t\t\"\"\"\n\t\tself._extra_kwds = kwds\n\n\tdef _set_scale(self, figure, scale=None, base=None):\n\t\t\"\"\"\n\t\tSet the scale of the axes in the current figure. This function is\n\t\tonly for internal use.\n\n\t\tINPUT:\n\t\t- ``figure`` -- the matplotlib figure instance.\n\t\t- ``scale`` -- the scale of the figure. Values it can take are\n\t\t  ``\"linear\"``, ``\"loglog\"``, ``\"semilogx\"``, ``\"semilogy\"``. See\n\t\t  :meth:`show` for other options it can take.\n\t\t- ``base`` -- the base of the logarithm if a logarithmic scale is\n\t\t  set. See :meth:`show` for the options it can take.\n\n\t\tOUTPUT:\n\t\tThe scale in the form of a tuple: (xscale, yscale, basex, basey)\n\n\t\tEXAMPLES::\n\n\t\t\tsage: p = plot(x,1,10)\n\t\t\tsage: fig = p.matplotlib()\n\t\t\tsage: p._set_scale(fig, scale='linear', base=2)\n\t\t\t('linear', 'linear', 10, 10)\n\t\t\tsage: p._set_scale(fig, scale='semilogy', base=2)\n\t\t\t('linear', 'log', 10, 2)\n\t\t\tsage: p._set_scale(fig, scale=('loglog', 2, 3))\n\t\t\t('log', 'log', 2, 3)\n\t\t\tsage: p._set_scale(fig, scale=['semilogx', 2])\n\t\t\t('log', 'linear', 2, 10)\n\n\t\tTESTS::\n\n\t\t\tsage: p._set_scale(fig, 'log')\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tValueError: The scale must be one of 'linear', 'loglog', 'semilogx' or 'semilogy' -- got 'log'\n\t\t\tsage: p._set_scale(fig, ('loglog', 1))\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tValueError: The base of the logarithm must be greater than 1\n\t\t\"\"\"\n\t\tif scale is None:\n\t\t\treturn ('linear', 'linear', 10, 10)\n\t\tif isinstance(scale, (list, tuple)):\n\t\t\tif len(scale) != 2 and len(scale) != 3:\n\t\t\t\traise ValueError(\"If the input is a tuple, it must be of \"\n\t\t\t\t\t\"the form (scale, base) or (scale, basex, basey)\")\n\t\t\tif len(scale) == 2:\n\t\t\t\tbase = scale[1]\n\t\t\telse:\n\t\t\t\tbase = scale[1:]\n\t\t\tscale = scale[0]\n\n\t\tif scale not in ('linear', 'loglog', 'semilogx', 'semilogy'):\n\t\t\traise ValueError(\"The scale must be one of 'linear', 'loglog',\"\n\t\t\t\t\t\" 'semilogx' or 'semilogy' -- got '{0}'\".format(scale))\n\n\t\tif isinstance(base, (list, tuple)):\n\t\t\tbasex, basey = base\n\t\telif base is None:\n\t\t\tbasex = basey = 10\n\t\telse:\n\t\t\tbasex = basey = base\n\n\t\tif basex <= 1 or basey <= 1:\n\t\t\traise ValueError(\"The base of the logarithm must be greater \"\n\t\t\t\t\t\t\t \"than 1\")\n\n\t\tax = figure.get_axes()[0]\n\t\txscale = yscale = 'linear'\n\t\tif scale == 'linear':\n\t\t\tbasex = basey = 10\n\t\telif scale == 'loglog':\n\t\t\tax.set_xscale('log', basex=basex)\n\t\t\tax.set_yscale('log', basey=basey)\n\t\t\txscale = yscale = 'log'\n\t\telif scale == 'semilogx':\n\t\t\tax.set_xscale('log', basex=basex)\n\t\t\tbasey = 10\n\t\t\txscale = 'log'\n\t\telif scale == 'semilogy':\n\t\t\tax.set_yscale('log', basey=basey)\n\t\t\tbasex = 10\n\t\t\tyscale = 'log'\n\n\t\treturn (xscale, yscale, basex, basey)\n\n\n\t# This dictionary has the default values for the keywords to show(). When\n\t# show is invoked with keyword arguments, those arguments are merged with\n\t# this dictionary to create a set of keywords with the defaults filled in.\n\t# Then, those keywords are passed on to save().\n\n\t# NOTE: If you intend to use a new parameter in show(), you should update\n\t# this dictionary to contain the default value for that parameter.\n\n\tSHOW_OPTIONS = dict(# axes options\n\t\t\t\t\t\taxes=None, axes_labels=None, axes_labels_size=None,\n\t\t\t\t\t\taxes_pad=None, base=None, scale=None,\n\t\t\t\t\t\txmin=None, xmax=None, ymin=None, ymax=None,\n\t\t\t\t\t\t# Figure options\n\t\t\t\t\t\taspect_ratio=None, dpi=DEFAULT_DPI, fig_tight=True,\n\t\t\t\t\t\tfigsize=None, fontsize=None, frame=False,\n\t\t\t\t\t\ttitle=None, title_pos=None, transparent=False,\n\t\t\t\t\t\t# Grid options\n\t\t\t\t\t\tgridlines=None, gridlinesstyle=None,\n\t\t\t\t\t\thgridlinesstyle=None, vgridlinesstyle=None,\n\t\t\t\t\t\t# Legend options\n\t\t\t\t\t\tlegend_options={}, show_legend=None,\n\t\t\t\t\t\t# Ticks options\n\t\t\t\t\t\tticks=None, tick_formatter=None, ticks_integer=False,\n\t\t\t\t\t\t# Text options\n\t\t\t\t\t\ttypeset='default')\n\n\t@suboptions('legend',\n\t\t\t\tback_color=(0.9, 0.9, 0.9), borderpad=0.6,\n\t\t\t\tborderaxespad=None,\n\t\t\t\tcolumnspacing=None,\n\t\t\t\tfancybox=False, font_family='sans-serif',\n\t\t\t\tfont_size='medium', font_style='normal',\n\t\t\t\tfont_variant='normal', font_weight='medium',\n\t\t\t\thandlelength=0.05, handletextpad=0.5,\n\t\t\t\tlabelspacing=0.02, loc='best',\n\t\t\t\tmarkerscale=0.6, ncol=1, numpoints=2,\n\t\t\t\tshadow=False, title=None)\n\tdef show(self, filename=None, linkmode=False, **kwds):\n\t\tr\"\"\"\n\t\tShow this graphics image immediately.\n\n\t\tThis method attempts to display the graphics immediately,\n\t\twithout waiting for the currently running code (if any) to\n\t\treturn to the command line. Be careful, calling it from within\n\t\ta loop will potentially launch a large number of external\n\t\tviewer programs.\n\n\t\tOPTIONAL INPUT:\n\n\t\t- ``dpi`` - (default: 100) dots per inch\n\n\t\t- ``figsize`` - (default: [8.0,6.0]) [width, height] inches. The\n\t\t  maximum value of each of the width and the height can be 327\n\t\t  inches, at the default ``dpi`` of 100 dpi, which is just shy of\n\t\t  the maximum allowed value of 32768 dots (pixels).\n\n\t\t- ``fig_tight`` - (default: True) whether to clip the drawing\n\t\t  tightly around drawn objects.  If True, then the resulting\n\t\t  image will usually not have dimensions corresponding to\n\t\t  ``figsize``.  If False, the resulting image will have\n\t\t  dimensions corresponding to ``figsize``.\n\n\t\t- ``aspect_ratio`` - the perceived height divided by the\n\t\t  perceived width. For example, if the aspect ratio is set to ``1``, circles\n\t\t  will look round and a unit square will appear to have sides\n\t\t  of equal length, and if the aspect ratio is set ``2``, vertical units will be\n\t\t  twice as long as horizontal units, so a unit square will be twice as\n\t\t  high as it is wide.  If set to ``'automatic'``, the aspect ratio\n\t\t  is determined by ``figsize`` and the picture fills the figure.\n\n\t\t- ``axes`` - (default: True)\n\n\t\t- ``axes_labels`` - (default: None) list (or tuple) of two\n\t\t  strings; the first is used as the label for the horizontal\n\t\t  axis, and the second for the vertical axis.\n\n\t\t- ``axes_labels_size`` - (default: current setting -- 1.6) scale factor\n\t\t  relating the size of the axes labels with respect to the size of the\n\t\t  tick marks.\n\n\t\t- ``fontsize`` - (default: current setting -- 10) positive\n\t\t  integer; used for axes labels; if you make this very large,\n\t\t  you may have to increase figsize to see all labels.\n\n\t\t- ``frame`` - (default: False) draw a frame around the image\n\n\t\t- ``gridlines`` - (default: None) can be any of the following:\n\n\t\t  - None, False: do not add grid lines.\n\n\t\t  - True, \"automatic\", \"major\": add grid lines at major ticks of the axes.\n\n\t\t  - \"minor\": add grid at major and minor ticks.\n\n\t\t  - [xlist,ylist]: a tuple or list containing\n\t\t\ttwo elements, where xlist (or ylist) can be\n\t\t\tany of the following.\n\n\n\t\t\t- None, False: don't add horizontal (or vertical) lines.\n\n\t\t\t- True, \"automatic\", \"major\": add horizontal (or vertical) grid lines at\n\t\t\t  the major ticks of the axes.\n\n\t\t\t- \"minor\": add horizontal (or vertical) grid lines at major and minor ticks of\n\t\t\t  axes.\n\n\t\t\t- an iterable yielding numbers n or pairs (n,opts), where n\n\t\t\t  is the coordinate of the line and opt is a dictionary of\n\t\t\t  MATPLOTLIB options for rendering the line.\n\n\n\t\t- ``gridlinesstyle, hgridlinesstyle, vgridlinesstyle`` -\n\t\t  (default: None) a dictionary of MATPLOTLIB options for the\n\t\t  rendering of the grid lines, the horizontal grid lines or the\n\t\t  vertical grid lines, respectively.\n\n\t\t- ``transparent`` - (default: False) If True, make the background transparent.\n\n\t\t- ``axes_pad`` - (default: 0.02 on ``\"linear\"`` scale, 1 on\n\t\t  ``\"log\"`` scale).\n\n\t\t  - In the ``\"linear\"`` scale, it determines the percentage of the\n\t\t\taxis range that is added to each end of each axis. This helps\n\t\t\tavoid problems like clipping lines because of line-width, etc.\n\t\t\tTo get axes that are exactly the specified limits, set\n\t\t\t``axes_pad`` to zero.\n\n\t\t  - On the ``\"log\"`` scale, it determines the exponent of the\n\t\t\tfraction of the minimum (resp. maximum) that is subtracted from\n\t\t\tthe minimum (resp. added to the maximum) value of the axis. For\n\t\t\tinstance if the minimum is `m` and the base of the axis is `b`\n\t\t\tthen the new minimum after padding the axis will be\n\t\t\t`m - m/b^{\\mathrm{axes\\_pad}}`.\n\n\t\t- ``ticks_integer`` - (default: False) guarantee that the ticks\n\t\t  are integers (the ``ticks`` option, if specified, will\n\t\t  override this)\n\n\t\t- ``ticks`` - A matplotlib locator for the major ticks, or\n\t\t  a number. There are several options.  For more information about\n\t\t  locators, type ``from matplotlib import ticker`` and then\n\t\t  ``ticker?``.\n\n\t\t  - If this is a locator object, then it is the locator for\n\t\t\tthe horizontal axis.  A value of None means use the default\n\t\t\tlocator.\n\n\t\t  - If it is a list of two locators, then the first is for the\n\t\t\thorizontal axis and one for the vertical axis.  A value of\n\t\t\tNone means use the default locator (so a value of\n\t\t\t[None, my_locator] uses my_locator for the vertical axis and\n\t\t\tthe default for the horizontal axis).\n\n\t\t  - If in either case above one of the entries is a number `m`\n\t\t\t(something which can be coerced to a float), it will be\n\t\t\treplaced by a MultipleLocator which places major ticks at\n\t\t\tinteger multiples of `m`.  See examples.\n\n\t\t  - If in either case above one of the entries is a list of\n\t\t\tnumbers, it will be replaced by a FixedLocator which places\n\t\t\tticks at the locations specified.  This includes the case of\n\t\t\tof the empty list, which will give no ticks.  See examples.\n\n\t\t- ``tick_formatter`` - A matplotlib formatter for the major\n\t\t  ticks. There are several options.  For more information about\n\t\t  formatters, type ``from matplotlib import ticker`` and then\n\t\t  ``ticker?``.\n\n\t\t  If the value of this keyword is a single item, then this will\n\t\t  give the formatting for the horizontal axis *only* (except for\n\t\t  the ``\"latex\"`` option).  If it is a list or tuple, the first\n\t\t  is for the horizontal axis, the second for the vertical axis.\n\t\t  The options are below:\n\n\t\t  - If one of the entries is a formatter object, then it used.\n\t\t\tA value of None means to use the default locator (so using\n\t\t\t``tick_formatter=[None, my_formatter]`` uses my_formatter\n\t\t\tfor the vertical axis and the default for the horizontal axis).\n\n\t\t  - If one of the entries is a symbolic constant such as `\\pi`,\n\t\t\t`e`, or `sqrt(2)`, ticks will be formatted nicely at rational\n\t\t\tmultiples of this constant.\n\n\t\t  .. warning::\n\n\t\t\t This should only be used with the ``ticks`` option using nice\n\t\t\t rational multiples of that constant!\n\n\t\t  - If one of the entries is the string ``\"latex\"``, then the\n\t\t\tformatting will be nice typesetting of the ticks.  This is\n\t\t\tintended to be used when the tick locator for at least one of\n\t\t\tthe axes is a list including some symbolic elements. This uses\n\t\t\tmatplotlib's internal LaTeX rendering engine. If you want to\n\t\t\tuse an external LaTeX compiler, then set the keyword option\n\t\t\t``typeset``.  See examples.\n\n\t\t- ``title`` - (default: None) The title for the plot\n\n\t\t- ``title_pos`` - (default: None) The position of the title for the\n\t\t\tplot. It must be a tuple or a list of two real numbers\n\t\t\t``(x_pos, y_pos)`` which indicate the relative position of the\n\t\t\ttitle within the plot. The plot itself can be considered to\n\t\t\toccupy, in relative terms, the region within a unit square\n\t\t\t`[0,1]\\\\times[0,1]`.  The title text is centered around the\n\t\t\thorizontal factor ``x_pos`` of the plot. The baseline of the\n\t\t\ttitle text is present at the vertical factor ``y_pos`` of the\n\t\t\tplot. Hence, ``title_pos=(0.5, 0.5)`` will center the title in\n\t\t\tthe plot, whereas ``title_pos=(0.5, 1.1)`` will center the\n\t\t\ttitle along the horizontal direction, but will place the title\n\t\t\ta fraction `0.1` times above the plot.\n\n\t\t  - If the first entry is a list of strings (or numbers), then the\n\t\t\tformatting for the horizontal axis will be typeset with the strings\n\t\t\tpresent in the list. Each entry of the list of strings must be\n\t\t\tprovided with a corresponding number in the first entry of\n\t\t\t``ticks`` to indicate its position on the axis. To typeset the\n\t\t\tstrings with ``\"latex\"`` enclose them within ``\"$\"`` symbols. To\n\t\t\thave similar custom formatting of the labels along the vertical\n\t\t\taxis, the second entry must be a list of strings and the second\n\t\t\tentry of ``ticks`` must also be a list of numbers which give the\n\t\t\tpositions of the labels. See the examples below.\n\n\t\t- ``show_legend`` - (default: None) If True, show the legend\n\n\t\t- ``legend_*`` - all the options valid for :meth:`set_legend_options`\n\t\t\tprefixed with ``legend_``\n\n\t\t- ``base`` - (default: 10) the base of the logarithm if\n\t\t  a logarithmic scale is set. This must be greater than 1. The base\n\t\t  can be also given as a list or tuple ``(basex, basey)``.\n\t\t  ``basex`` sets the base of the logarithm along the horizontal\n\t\t  axis and ``basey`` sets the base along the vertical axis.\n\n\t\t- ``scale`` -- (default: ``\"linear\"``) string. The scale of the axes.\n\t\t  Possible values are\n\n\t\t  - ``\"linear\"`` -- linear scaling of both the axes\n\t\t  - ``\"loglog\"`` -- sets both the horizontal and vertical axes to\n\t\t\tlogarithmic scale\n\t\t  - ``\"semilogx\"`` -- sets only the horizontal axis to logarithmic\n\t\t\tscale.\n\t\t  - ``\"semilogy\"`` -- sets only the vertical axis to logarithmic\n\t\t\tscale.\n\n\t\t  The scale can be also be given as single argument that is a list\n\t\t  or tuple ``(scale, base)`` or ``(scale, basex, basey)``.\n\n\t\t  .. note::\n\n\t\t\t- If the ``scale`` is ``\"linear\"``, then irrespective of what\n\t\t\t  ``base`` is set to, it will default to 10 and will remain\n\t\t\t  unused.\n\n\t\t- ``xmin`` -- starting x value in the rendered figure.\n\n\t\t- ``xmax`` -- ending x value in the rendered figure.\n\n\t\t- ``ymin`` -- starting y value in the rendered figure.\n\n\t\t- ``ymax`` -- ending y value in the rendered figure.\n\n\t\t- ``typeset`` -- (default: ``\"default\"``) string. The type of\n\t\t  font rendering that should be used for the text. The possible\n\t\t  values are\n\n\t\t  - ``\"default\"`` -- Uses matplotlib's internal text rendering\n\t\t\tengine called Mathtext ( see\n\t\t\thttp://matplotlib.org/users/mathtext.html ). If you have\n\t\t\tmodified the default matplotlib settings, for instance via\n\t\t\ta matplotlibrc file, then this option will not change any of\n\t\t\tthose settings.\n\t\t  - ``\"latex\"`` -- LaTeX is used for rendering the fonts. This\n\t\t\trequires LaTeX, dvipng and Ghostscript to be installed.\n\t\t  - ``\"type1\"`` -- Type 1 fonts are used by matplotlib in the text\n\t\t\tin the figure.  This requires LaTeX, dvipng and Ghostscript to\n\t\t\tbe installed.\n\n\t\tOUTPUT:\n\n\t\tThis method does not return anything. Use :meth:`save` if you\n\t\twant to save the figure as an image.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: c = circle((1,1), 1, color='red')\n\t\t\tsage: c.show(xmin=-1, xmax=3, ymin=-1, ymax=3)\n\n\t\tYou can make the picture larger by changing ``figsize`` with width,\n\t\theight each having a maximum value of 327 inches at default dpi::\n\n\t\t\tsage: p = ellipse((0,0),4,1)\n\t\t\tsage: p.show(figsize=[327,10],dpi=100)\n\t\t\tsage: p.show(figsize=[328,10],dpi=80)\n\n\t\tYou can turn off the drawing of the axes::\n\n\t\t\tsage: show(plot(sin,-4,4), axes=False)\n\n\t\tYou can also label the axes.  Putting something in dollar\n\t\tsigns formats it as a mathematical expression::\n\n\t\t\tsage: show(plot(sin,-4,4), axes_labels=('$x$','$y$'))\n\n\t\tYou can add a title to a plot::\n\n\t\t\tsage: show(plot(sin,-4,4), title='A plot of $\\sin(x)$')\n\n\t\tYou can also provide the position for the title to the plot. In the\n\t\tplot below the title is placed on the bottom left of the figure.::\n\n\t\t\tsage: plot(sin, -4, 4, title='Plot sin(x)', title_pos=(0.05,-0.05))\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tIf you want all the text to be rendered by using an external LaTeX\n\t\tinstallation then set the ``typeset`` to ``\"latex\"``. This\n\t\trequires that LaTeX, dvipng and Ghostscript be installed::\n\n\t\t\tsage: plot(x, typeset='latex') # optional - latex\n\n\t\tIf you want all the text in your plot to use Type 1 fonts, then\n\t\tset the ``typeset`` option to ``\"type1\"``. This requires that\n\t\tLaTeX, dvipng and Ghostscript be installed::\n\n\t\t\tsage: plot(x, typeset='type1') # optional - latex\n\n\t\tYou can turn on the drawing of a frame around the plots::\n\n\t\t\tsage: show(plot(sin,-4,4), frame=True)\n\n\t\tYou can make the background transparent::\n\n\t\t\tsage: plot(sin(x), (x, -4, 4), transparent=True)\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tWe can change the scale of the axes in the graphics before\n\t\tdisplaying::\n\n\t\t\tsage: G = plot(exp, 1, 10)\n\t\t\tsage: G.show(scale='semilogy')\n\n\t\tWe can change the base of the logarithm too. The following changes\n\t\tthe vertical axis to be on log scale, and with base 2. Note that\n\t\tthe ``base`` argument will ignore any changes to the axis which is\n\t\tin linear scale.::\n\n\t\t\tsage: G.show(scale='semilogy', base=2) # long time # y axis as powers of 2\n\n\t\t::\n\n\t\t\tsage: G.show(scale='semilogy', base=(3,2)) # base ignored for x-axis\n\n\t\tThe scale can be also given as a 2-tuple or a 3-tuple.::\n\n\t\t\tsage: G.show(scale=('loglog', 2.1)) # long time # both x and y axes in base 2.1\n\n\t\t::\n\n\t\t\tsage: G.show(scale=('loglog', 2, 3)) # long time # x in base 2, y in base 3\n\n\t\tThe base need not be an integer, though it does have to be made\n\t\ta float.::\n\n\t\t\tsage: G.show(scale='semilogx', base=float(e)) # base is e\n\n\t\tLogarithmic scale can be used for various kinds of plots. Here are\n\t\tsome examples.::\n\n\t\t\tsage: G = list_plot(map(lambda i: 10**i, range(10))) # long time\n\t\t\tsage: G.show(scale='semilogy') # long time\n\n\t\t::\n\n\t\t\tsage: G = parametric_plot((x, x**2), (x, 1, 10))\n\t\t\tsage: G.show(scale='loglog')\n\n\t\t::\n\n\t\t\tsage: disk((5,5), 4, (0, 3*pi/2)).show(scale='loglog',base=2)\n\n\t\t::\n\n\t\t\tsage: x, y = var('x, y')\n\t\t\tsage: G =  plot_vector_field((2^x,y^2),(x,1,10),(y,1,100))\n\t\t\tsage: G.show(scale='semilogx',base=2)\n\n\t\tAdd grid lines at the major ticks of the axes.\n\n\t\t::\n\n\t\t\tsage: c = circle((0,0), 1)\n\t\t\tsage: c.show(gridlines=True)\n\t\t\tsage: c.show(gridlines=\"automatic\")\n\t\t\tsage: c.show(gridlines=\"major\")\n\n\t\tAdd grid lines at the major and minor ticks of the axes.\n\n\t\t::\n\n\t\t\tsage: u,v = var('u v')\n\t\t\tsage: f = exp(-(u^2+v^2))\n\t\t\tsage: p = plot_vector_field(f.gradient(), (u,-2,2), (v,-2,2))\n\t\t\tsage: p.show(gridlines=\"minor\")\n\n\t\tAdd only horizontal or vertical grid lines.\n\n\t\t::\n\n\t\t\tsage: p = plot(sin,-10,20)\n\t\t\tsage: p.show(gridlines=[None, \"automatic\"])\n\t\t\tsage: p.show(gridlines=[\"minor\", False])\n\n\t\tAdd grid lines at specific positions (using lists/tuples).\n\n\t\t::\n\n\t\t\tsage: x, y = var('x, y')\n\t\t\tsage: p = implicit_plot((y^2-x^2)*(x-1)*(2*x-3)-4*(x^2+y^2-2*x)^2, \\\n\t\t\t....:\t\t\t (x,-2,2), (y,-2,2), plot_points=1000)\n\t\t\tsage: p.show(gridlines=[[1,0],[-1,0,1]])\n\n\t\tAdd grid lines at specific positions (using iterators).\n\n\t\t::\n\n\t\t\tsage: def maple_leaf(t):\n\t\t\t....:\t return (100/(100+(t-pi/2)^8))*(2-sin(7*t)-cos(30*t)/2)\n\t\t\tsage: p = polar_plot(maple_leaf, -pi/4, 3*pi/2, color=\"red\",plot_points=1000) # long time\n\t\t\tsage: p.show(gridlines=( [-3,-2.75,..,3], xrange(-1,5,2) )) # long time\n\n\t\tAdd grid lines at specific positions (using functions).\n\n\t\t::\n\n\t\t\tsage: y = x^5 + 4*x^4 - 10*x^3 - 40*x^2 + 9*x + 36\n\t\t\tsage: p = plot(y, -4.1, 1.1)\n\t\t\tsage: xlines = lambda a,b: [z for z,m in y.roots()]\n\t\t\tsage: p.show(gridlines=[xlines, [0]], frame=True, axes=False)\n\n\t\tChange the style of all the grid lines.\n\n\t\t::\n\n\t\t\tsage: b = bar_chart([-3,5,-6,11], color='red')\n\t\t\tsage: b.show(gridlines=([-1,-0.5,..,4],True),\n\t\t\t....:\t gridlinesstyle=dict(color=\"blue\", linestyle=\":\"))\n\n\t\tChange the style of the horizontal or vertical grid lines\n\t\tseparately.\n\n\t\t::\n\n\t\t\tsage: p = polar_plot(2 + 2*cos(x), 0, 2*pi, color=hue(0.3))\n\t\t\tsage: p.show(gridlines=True,\n\t\t\t....:\t hgridlinesstyle=dict(color=\"orange\", linewidth=1.0),\n\t\t\t....:\t vgridlinesstyle=dict(color=\"blue\", linestyle=\":\"))\n\n\t\tChange the style of each grid line individually.\n\n\t\t::\n\n\t\t\tsage: x, y = var('x, y')\n\t\t\tsage: p = implicit_plot((y^2-x^2)*(x-1)*(2*x-3)-4*(x^2+y^2-2*x)^2,\n\t\t\t....:\t\t\t (x,-2,2), (y,-2,2), plot_points=1000)\n\t\t\tsage: p.show(gridlines=(\n\t\t\t....:\t[\n\t\t\t....:\t (1,{\"color\":\"red\",\"linestyle\":\":\"}),\n\t\t\t....:\t (0,{\"color\":\"blue\",\"linestyle\":\"--\"})\n\t\t\t....:\t],\n\t\t\t....:\t[\n\t\t\t....:\t (-1,{\"color\":\"red\",\"linestyle\":\":\"}),\n\t\t\t....:\t (0,{\"color\":\"blue\",\"linestyle\":\"--\"}),\n\t\t\t....:\t (1,{\"color\":\"red\",\"linestyle\":\":\"}),\n\t\t\t....:\t]\n\t\t\t....:\t),\n\t\t\t....:\tgridlinesstyle=dict(marker='x',color=\"black\"))\n\n\t\tGrid lines can be added to contour plots.\n\n\t\t::\n\n\t\t\tsage: f = sin(x^2 + y^2)*cos(x)*sin(y)\n\t\t\tsage: c = contour_plot(f, (x, -4, 4), (y, -4, 4), plot_points=100)\n\t\t\tsage: c.show(gridlines=True, gridlinesstyle={'linestyle':':','linewidth':1, 'color':'red'})\n\n\t\tGrid lines can be added to matrix plots.\n\n\t\t::\n\n\t\t\tsage: M = MatrixSpace(QQ,10).random_element()\n\t\t\tsage: matrix_plot(M).show(gridlines=True)\n\n\t\tBy default, Sage increases the horizontal and vertical axes\n\t\tlimits by a certain percentage in all directions.  This is\n\t\tcontrolled by the ``axes_pad`` parameter.  Increasing the range\n\t\tof the axes helps avoid problems with lines and dots being\n\t\tclipped because the linewidth extends beyond the axes.  To get\n\t\taxes limits that are exactly what is specified, set\n\t\t``axes_pad`` to zero.  Compare the following two examples\n\n\t\t::\n\n\t\t\tsage: plot(sin(x), (x, -pi, pi),thickness=2)+point((pi, -1), pointsize=15)\n\t\t\tGraphics object consisting of 2 graphics primitives\n\t\t\tsage: plot(sin(x), (x, -pi, pi),thickness=2,axes_pad=0)+point((pi, -1), pointsize=15)\n\t\t\tGraphics object consisting of 2 graphics primitives\n\n\t\tThe behavior of the ``axes_pad`` parameter is different if the axis\n\t\tis in the ``\"log\"`` scale. If `b` is the base of the axis, the\n\t\tminimum value of the axis, is decreased by the factor\n\t\t`1/b^{\\mathrm{axes\\_pad}}` of the minimum and the maximum value of the axis\n\t\tis increased by the same factor of the maximum value.  Compare the\n\t\taxes in the following two plots to see the difference.\n\n\t\t::\n\n\t\t\tsage: plot_loglog(x, (1.1*10**-2, 9990))\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\t\tsage: plot_loglog(x, (1.1*10**-2, 9990), axes_pad=0)\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tVia matplotlib, Sage allows setting of custom ticks.  See above\n\t\tfor more details.\n\n\t\tHere the labels are not so useful::\n\n\t\t\tsage: plot(sin(pi*x), (x, -8, 8))\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tNow put ticks at multiples of 2::\n\n\t\t\tsage: plot(sin(pi*x), (x, -8, 8), ticks=2)\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tOr just choose where you want the ticks::\n\n\t\t\tsage: plot(sin(pi*x), (x, -8, 8), ticks=[[-7,-3,0,3,7],[-1/2,0,1/2]])\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tOr no ticks at all::\n\n\t\t\tsage: plot(sin(pi*x), (x, -8, 8), ticks=[[],[]])\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tThis can be very helpful in showing certain features of plots. ::\n\n\t\t\tsage: plot(1.5/(1+e^(-x)), (x, -10, 10)) # doesn't quite show value of inflection point\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\t::\n\n\t\t\tsage: plot(1.5/(1+e^(-x)), (x, -10, 10), ticks=[None, 1.5/4]) # It's right at f(x)=0.75!\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tBut be careful to leave enough room for at least two major ticks, so that\n\t\tthe user can tell what the scale is::\n\n\t\t\tsage: plot(x^2,(x,1,8),ticks=6).show()\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tValueError: Expand the range of the independent variable to\n\t\t\tallow two multiples of your tick locator (option `ticks`).\n\n\t\tWe can also do custom formatting if you need it.  See above for full\n\t\tdetails::\n\n\t\t\tsage: plot(2*x+1,(x,0,5),ticks=[[0,1,e,pi,sqrt(20)],2],tick_formatter=\"latex\")\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tThis is particularly useful when setting custom ticks in multiples\n\t\tof `\\pi`.\n\n\t\t::\n\n\t\t\tsage: plot(sin(x),(x,0,2*pi),ticks=pi/3,tick_formatter=pi)\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tBut keep in mind that you will get exactly the formatting you asked\n\t\tfor if you specify both formatters.  The first syntax is recommended\n\t\tfor best style in that case. ::\n\n\t\t\tsage: plot(arcsin(x),(x,-1,1),ticks=[None,pi/6],tick_formatter=[\"latex\",pi]) # Nice-looking!\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\t::\n\n\t\t\tsage: plot(arcsin(x),(x,-1,1),ticks=[None,pi/6],tick_formatter=[None,pi]) # Not so nice-looking\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tCustom tick labels can be provided by providing the keyword\n\t\t``tick_formatter`` with the list of labels, and simultaneously\n\t\tproviding the keyword ``ticks`` with the positions of the labels. ::\n\n\t\t\tsage: plot(x, (x,0,3), ticks=[[1,2.5],[0.5,1,2]], tick_formatter=[[\"$x_1$\",\"$x_2$\"],[\"$y_1$\",\"$y_2$\",\"$y_3$\"]])\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tThe following sets the custom tick labels only along the horizontal\n\t\taxis. ::\n\n\t\t\tsage: plot(x**2, (x,0,2), ticks=[[1,2], None], tick_formatter=[[\"$x_1$\",\"$x_2$\"], None])\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tIf the number of tick labels do not match the number of positions of\n\t\ttick labels, then it results in an error.::\n\n\t\t\tsage: plot(x**2, (x,0,2), ticks=[[2], None], tick_formatter=[[\"$x_1$\",\"$x_2$\"], None]).show()\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tValueError: If the first component of the list `tick_formatter` is a list then the first component of `ticks` must also be a list of equal length.\n\n\t\tWhen using logarithmic scale along the axis, make sure to have\n\t\tenough room for two ticks so that the user can tell what the scale\n\t\tis. This can be effected by increasing the range of the independent\n\t\tvariable, or by changing the ``base``, or by providing enough tick\n\t\tlocations by using the ``ticks`` parameter.\n\n\t\tBy default, Sage will expand the variable range so that at least two\n\t\tticks are included along the logarithmic axis. However, if you\n\t\tspecify ``ticks`` manually, this safety measure can be defeated::\n\n\t\t\tsage: list_plot_loglog([(1,2),(2,3)], plotjoined=True, ticks=[[1],[1]])\n\t\t\tdoctest:...: UserWarning: The x-axis contains fewer than 2 ticks;\n\t\t\tthe logarithmic scale of the plot may not be apparent to the reader.\n\t\t\tdoctest:...: UserWarning: The y-axis contains fewer than 2 ticks;\n\t\t\tthe logarithmic scale of the plot may not be apparent to the reader.\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tThis one works, since the horizontal axis is automatically expanded\n\t\tto contain two ticks and the vertical axis is provided with two ticks::\n\n\t\t\tsage: list_plot_loglog([(1,2),(2,3)], plotjoined=True, ticks=[None,[1,10]])\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tAnother example in the log scale where both the axes are automatically\n\t\texpanded to show two major ticks::\n\n\t\t\tsage: list_plot_loglog([(2,0.5), (3, 4)], plotjoined=True)\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tWhen using ``title_pos``, it must be ensured that a list or a tuple\n\t\tof length two is used. Otherwise, an error is raised.::\n\n\t\t\tsage; plot(x, -4, 4, title='Plot x', title_pos=0.05)\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tValueError: 'title_pos' must be a list or tuple of two real numbers.\n\n\t\tTESTS:\n\n\t\tThe figsize width and height parameters (at default dpi) must be\n\t\tless than 328 inches each, corresponding to the maximum allowed\n\t\tpixels in each direction of 32768.  See :trac:`5956` for more about\n\t\tthe next several tests::\n\n\t\t\tsage: p = ellipse((0,0),4,1)\n\t\t\tsage: p.show(figsize=[328,10],dpi=100)\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tValueError: width and height must each be below 32768\n\n\t\tThe following tests result in a segmentation fault and should not\n\t\tbe run or doctested::\n\n\t\t\tsage: p = ellipse((0,0),4,1)\n\t\t\tsage: #p.show(figsize=[232,232],dpi=100) # not tested\n\t\t\t------------------------------------------------------------------------\n\t\t\tUnhandled SIGSEGV: A segmentation fault occurred in Sage.\n\t\t\tThis probably occurred because a *compiled* component of Sage has a bug\n\t\t\tin it and is not properly wrapped with sig_on(), sig_off().\n\t\t\tSage will now terminate.\n\t\t\t------------------------------------------------------------------------\n\t\t\tsage: #p.show(figsize=[327,181],dpi=100) # not tested\n\t\t\t------------------------------------------------------------------------\n\t\t\tUnhandled SIGSEGV: A segmentation fault occurred in Sage.\n\t\t\tThis probably occurred because a *compiled* component of Sage has a bug\n\t\t\tin it and is not properly wrapped with sig_on(), sig_off().\n\t\t\tSage will now terminate.\n\t\t\t------------------------------------------------------------------------\n\n\t\tThe following tests ensure we give a good error message for\n\t\tnegative figsizes::\n\n\t\t\tsage: P = plot(x^2,(x,0,1))\n\t\t\tsage: P.show(figsize=[-1,1])\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tValueError: figsize should be positive numbers, not -1.0 and 1.0\n\t\t\tsage: P.show(figsize=-1)\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tValueError: figsize should be positive, not -1.0\n\t\t\tsage: P.show(figsize=x^2)\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tTypeError: figsize should be a positive number, not x^2\n\t\t\tsage: P.show(figsize=[2,3,4])\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tValueError: figsize should be a positive number or a list of two positive numbers, not [2, 3, 4]\n\t\t\tsage: P.show(figsize=[sqrt(2),sqrt(3)])\n\n\t\tTESTS::\n\n\t\t\tsage: P = plot(x^2,(x,0,1))\n\t\t\tsage: P.show(linkmode=True)\n\t\t\tdoctest:...: DeprecationWarning: the filename and linkmode arguments are deprecated, use save() to save\n\t\t\tSee http://trac.sagemath.org/17234 for details.\n\t\t\tdoctest:...: DeprecationWarning: use tmp_filename instead\n\t\t\tSee http://trac.sagemath.org/17234 for details.\n\t\t\t\"\"\n\t\t\"\"\"\n\t\tif filename or linkmode:\n\t\t\tfrom sage.misc.superseded import deprecation\n\t\t\tdeprecation(17234,'the filename and linkmode arguments are deprecated, '\n\t\t\t\t\t\t'use save() to save')\n\t\t\tif filename is None:\n\t\t\t\tfrom sage.misc.temporary_file import graphics_filename\n\t\t\t\tfilename = graphics_filename()\n\t\t\tself.save(filename, **kwds)\n\t\t\tif linkmode:\n\t\t\t\treturn \"\" % filename\n\t\t\telse:\n\t\t\t\thtml(\"\" % filename)\n\t\t\t\treturn\n\n\t\tfrom sage.repl.rich_output import get_display_manager\n\t\tdm = get_display_manager()\n\t\tdm.display_immediately(self, **kwds)\n\n\tdef xmin(self, xmin=None):\n\t\t\"\"\"\n\t\tEXAMPLES::\n\n\t\t\tsage: g = line([(-1,1), (3,2)])\n\t\t\tsage: g.xmin()\n\t\t\t-1.0\n\t\t\tsage: g.xmin(-3)\n\t\t\tsage: g.xmin()\n\t\t\t-3.0\n\t\t\"\"\"\n\t\tif xmin is None:\n\t\t\treturn self.get_axes_range()['xmin']\n\t\telse:\n\t\t\tself.set_axes_range(xmin=xmin)\n\n\tdef xmax(self, xmax=None):\n\t\t\"\"\"\n\t\tEXAMPLES::\n\n\t\t\tsage: g = line([(-1,1), (3,2)])\n\t\t\tsage: g.xmax()\n\t\t\t3.0\n\t\t\tsage: g.xmax(10)\n\t\t\tsage: g.xmax()\n\t\t\t10.0\n\t\t\"\"\"\n\t\tif xmax is None:\n\t\t\treturn self.get_axes_range()['xmax']\n\t\telse:\n\t\t\tself.set_axes_range(xmax=xmax)\n\n\tdef ymin(self, ymin=None):\n\t\t\"\"\"\n\t\tEXAMPLES::\n\n\t\t\tsage: g = line([(-1,1), (3,2)])\n\t\t\tsage: g.ymin()\n\t\t\t1.0\n\t\t\tsage: g.ymin(-3)\n\t\t\tsage: g.ymin()\n\t\t\t-3.0\n\t\t\"\"\"\n\t\tif ymin is None:\n\t\t\treturn self.get_axes_range()['ymin']\n\t\telse:\n\t\t\tself.set_axes_range(ymin=ymin)\n\n\tdef ymax(self, ymax=None):\n\t\t\"\"\"\n\t\tEXAMPLES::\n\n\t\t\tsage: g = line([(-1,1), (3,2)])\n\t\t\tsage: g.ymax()\n\t\t\t2.0\n\t\t\tsage: g.ymax(10)\n\t\t\tsage: g.ymax()\n\t\t\t10.0\n\t\t\"\"\"\n\t\tif ymax is None:\n\t\t\treturn self.get_axes_range()['ymax']\n\t\telse:\n\t\t\tself.set_axes_range(ymax=ymax)\n\n\n\tdef get_minmax_data(self):\n\t\tr\"\"\"\n\t\tReturn the x and y coordinate minimum and maximum\n\n\t\t.. warning::\n\n\t\t   The returned dictionary is mutable, but changing it does\n\t\t   not change the xmin/xmax/ymin/ymax data.  The minmax data is a function\n\t\t   of the primitives which make up this Graphics object.  To change the\n\t\t   range of the axes, call methods :meth:`xmin`, :meth:`xmax`,\n\t\t   :meth:`ymin`, :meth:`ymax`, or :meth:`set_axes_range`.\n\n\t\tOUTPUT:\n\n\t\tA dictionary whose keys give the xmin, xmax, ymin, and ymax\n\t\tdata for this graphic.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: g = line([(-1,1), (3,2)])\n\t\t\tsage: list(sorted(g.get_minmax_data().items()))\n\t\t\t[('xmax', 3.0), ('xmin', -1.0), ('ymax', 2.0), ('ymin', 1.0)]\n\n\t\tNote that changing ymax doesn't change the output of get_minmax_data::\n\n\t\t\tsage: g.ymax(10)\n\t\t\tsage: list(sorted(g.get_minmax_data().items()))\n\t\t\t[('xmax', 3.0), ('xmin', -1.0), ('ymax', 2.0), ('ymin', 1.0)]\n\n\t\tThe width/height ratio (in output units, after factoring in the\n\t\tchosen aspect ratio) of the plot is limited to `10^{-15}\\dots\n\t\t10^{15}`, otherwise floating point errors cause problems in\n\t\tmatplotlib::\n\n\t\t\tsage: l = line([(1e-19,-1), (-1e-19,+1)], aspect_ratio=1.0)\n\t\t\tsage: l.get_minmax_data()\n\t\t\t{'xmax': 1.00010000000000e-15,\n\t\t\t 'xmin': -9.99900000000000e-16,\n\t\t\t 'ymax': 1.0,\n\t\t\t 'ymin': -1.0}\n\t\t\tsage: l = line([(0,0), (1,1)], aspect_ratio=1e19)\n\t\t\tsage: l.get_minmax_data()\n\t\t\t{'xmax': 5000.50000000000, 'xmin': -4999.50000000000, 'ymax': 1.0, 'ymin': 0.0}\n\t\t\"\"\"\n\t\tobjects = self._objects\n\t\tif objects:\n\t\t\tminmax_data = [o.get_minmax_data() for o in objects]\n\t\t\txmin = min(d['xmin'] for d in minmax_data)\n\t\t\txmax = max(d['xmax'] for d in minmax_data)\n\t\t\tymin = min(d['ymin'] for d in minmax_data)\n\t\t\tymax = max(d['ymax'] for d in minmax_data)\n\t\t\tif isnan(xmin):\n\t\t\t\txmin=0; sage.misc.misc.verbose(\"xmin was NaN (setting to 0)\", level=0)\n\t\t\tif isnan(xmax):\n\t\t\t\txmax=0; sage.misc.misc.verbose(\"xmax was NaN (setting to 0)\", level=0)\n\t\t\tif isnan(ymin):\n\t\t\t\tymin=0; sage.misc.misc.verbose(\"ymin was NaN (setting to 0)\", level=0)\n\t\t\tif isnan(ymax):\n\t\t\t\tymax=0; sage.misc.misc.verbose(\"ymax was NaN (setting to 0)\", level=0)\n\t\telse:\n\t\t\txmin = xmax = ymin = ymax = 0\n\n\t\tif xmin == xmax:\n\t\t\txmin -= 1\n\t\t\txmax += 1\n\t\tif ymin == ymax:\n\t\t\tymin -= 1\n\t\t\tymax += 1\n\t\treturn self._limit_output_aspect_ratio(xmin, xmax, ymin, ymax)\n\n\tdef _limit_output_aspect_ratio(self, xmin, xmax, ymin, ymax):\n\t\t\"\"\"\n\t\tPrivate helper function for :meth:`get_minmax_data`\n\n\t\tINPUT:\n\n\t\t- ``xmin``, ``xmax``, ``ymin``, ``ymax`` -- bounding box for\n\t\t  the graphics.\n\n\t\tOUTPUT:\n\n\t\tA dictionary whose keys give the xmin, xmax, ymin, and ymax\n\t\tdata for this graphic. Possibly enlarged in order to keep the\n\t\twidth/height ratio (in output units, after factoring in the\n\t\tchosen aspect ratio) of the plot is limited to `10^{-15}\\dots\n\t\t10^{15}` to avoid floating point issues in matplotlib.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: l = line([(0,0), (1,1)], aspect_ratio=1.0)\n\t\t\tsage: l._limit_output_aspect_ratio(1, 2, 1e19, 3)\n\t\t\t{'xmax': -4999.50000000000,\n\t\t\t 'xmin': 5000.50000000000,\n\t\t\t 'ymax': 3,\n\t\t\t 'ymin': 1.00000000000000e19}\n\t\t\tsage: l._limit_output_aspect_ratio(1, 2, 3, 1e19)\n\t\t\t{'xmax': 5000.50000000000,\n\t\t\t 'xmin': -4999.50000000000,\n\t\t\t 'ymax': 1.00000000000000e19,\n\t\t\t 'ymin': 3}\n\t\t\tsage: l = line([(0,0), (1,1)], aspect_ratio=1e16)\n\t\t\tsage: l._limit_output_aspect_ratio(0, 1, 2, 3)\n\t\t\t{'xmax': 5.50000000000000, 'xmin': -4.50000000000000, 'ymax': 3, 'ymin': 2}\n\t\t\"\"\"\n\t\taspect_ratio = self.aspect_ratio()\n\t\tif aspect_ratio != 'automatic':\n\t\t\twidth = xmax - xmin\n\t\t\theight = ymax - ymin\n\t\t\toutput_aspect = abs(width/height/aspect_ratio)\n\t\t\tif output_aspect > 1e15:\n\t\t\t\theight = 1e15 * width / aspect_ratio\n\t\t\t\tycenter = (ymax - ymin) / 2\n\t\t\t\tymin = ycenter - height/2\n\t\t\t\tymax = ycenter + height/2\n\t\t\tif output_aspect < 1e-15:\n\t\t\t\twidth = 1e-15 * height * aspect_ratio\n\t\t\t\txcenter = (xmax - xmin) / 2\n\t\t\t\txmin = xcenter - width/2\n\t\t\t\txmax = xcenter + width/2\n\t\treturn {'xmin':xmin, 'xmax':xmax, 'ymin':ymin, 'ymax':ymax}\n\n\tdef _matplotlib_tick_formatter(self, subplot, base=(10, 10),\n\t\t\t\t\t\t\tlocator_options={}, scale=('linear', 'linear'),\n\t\t\t\t\t\t\ttick_formatter=(None, None), ticks=(None, None),\n\t\t\t\t\t\t\txmax=None, xmin=None, ymax=None, ymin=None):\n\t\tr\"\"\"\n\t\tTake a matplotlib subplot instance representing the graphic and set\n\t\tthe ticks formatting. This function is only for internal use.\n\n\t\tINPUT:\n\t\t- ``subplot`` -- the subplot instance.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: from matplotlib.figure import Figure\n\t\t\tsage: p = plot(x); d = p.get_minmax_data()\n\t\t\tsage: subplot = Figure().add_subplot(111)\n\t\t\tsage: p._objects[0]._render_on_subplot(subplot)\n\t\t\tsage: p._matplotlib_tick_formatter(subplot, **d)\n\t\t\t(,\n\t\t\t,\n\t\t\t,\n\t\t\t,\n\t\t\t)\n\t\t\"\"\"\n\t\t# This function is created to refactor some code that is repeated\n\t\t# in the matplotlib function\n\t\tfrom matplotlib.ticker import (FixedLocator, Locator,\n\t\t\t\tLogFormatterMathtext, LogLocator, MaxNLocator,\n\t\t\t\tMultipleLocator, NullLocator, OldScalarFormatter)\n\n\t\tx_locator, y_locator = ticks\n\t\t#---------------------- Location of x-ticks ---------------------#\n\n\t\tif x_locator is None:\n\t\t\tif scale[0] == 'log':\n\t\t\t\tx_locator = LogLocator(base=base[0])\n\t\t\telse:\n\t\t\t\tx_locator = MaxNLocator(**locator_options)\n\t\telif isinstance(x_locator,Locator):\n\t\t\tpass\n\t\telif x_locator == []:\n\t\t\tx_locator = NullLocator()\n\t\telif isinstance(x_locator,list):\n\t\t\tx_locator = FixedLocator(x_locator)\n\t\telse: # x_locator is a number which can be made a float\n\t\t\tfrom sage.functions.other import ceil, floor\n\t\t\tif floor(xmax/x_locator)-ceil(xmin/x_locator)>1:\n\t\t\t\tx_locator=MultipleLocator(float(x_locator))\n\t\t\telse: # not enough room for two major ticks\n\t\t\t\traise ValueError('Expand the range of the independent '\n\t\t\t\t'variable to allow two multiples of your tick locator '\n\t\t\t\t'(option `ticks`).')\n\n\t\t#---------------------- Location of y-ticks ---------------------#\n\t\tif y_locator is None:\n\t\t\tif scale[1] == 'log':\n\t\t\t\ty_locator = LogLocator(base=base[1])\n\t\t\telse:\n\t\t\t\ty_locator = MaxNLocator(**locator_options)\n\t\telif isinstance(y_locator,Locator):\n\t\t\tpass\n\t\telif y_locator == []:\n\t\t\ty_locator = NullLocator()\n\t\telif isinstance(y_locator,list):\n\t\t\ty_locator = FixedLocator(y_locator)\n\t\telse: # y_locator is a number which can be made a float\n\t\t\tfrom sage.functions.other import ceil, floor\n\t\t\tif floor(ymax/y_locator)-ceil(ymin/y_locator)>1:\n\t\t\t\ty_locator=MultipleLocator(float(y_locator))\n\t\t\telse: # not enough room for two major ticks\n\t\t\t\traise ValueError('Expand the range of the dependent '\n\t\t\t\t'variable to allow two multiples of your tick locator '\n\t\t\t\t'(option `ticks`).')\n\n\t\tx_formatter, y_formatter = tick_formatter\n\t\tfrom matplotlib.ticker import FuncFormatter, FixedFormatter\n\t\tfrom sage.misc.latex import latex\n\t\tfrom sage.symbolic.ring import SR\n\t\t#---------------------- Formatting x-ticks ----------------------#\n\t\tif x_formatter is None:\n\t\t\tif scale[0] == 'log':\n\t\t\t\tx_formatter = LogFormatterMathtext(base=base[0])\n\t\t\telse:\n\t\t\t\tx_formatter = OldScalarFormatter()\n\t\telif x_formatter in SR:\n\t\t\tfrom misc import _multiple_of_constant\n\t\t\tx_const = x_formatter\n\t\t\tx_formatter = FuncFormatter(lambda n,pos:\n\t\t\t\t\t\t\t\t\t\t_multiple_of_constant(n,pos,x_const))\n\t\telif x_formatter == \"latex\":\n\t\t\tif scale[0] == 'log':\n\t\t\t\t# We need to strip out '\\\\mathdefault' from the string\n\t\t\t\tx_formatter = FuncFormatter(lambda n,pos:\n\t\t\t\t\tLogFormatterMathtext(base=base[0])(n,pos).replace(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"\\\\mathdefault\",\"\"))\n\t\t\telse:\n\t\t\t\tx_formatter = FuncFormatter(lambda n,pos: '$%s$'%latex(n))\n\t\telif isinstance(x_formatter, (list, tuple)):\n\t\t\tif (not isinstance(ticks[0], (list, tuple)) or\n\t\t\t\t\tlen(ticks[0]) != len(x_formatter)):\n\t\t\t\traise ValueError(\"If the first component of the list \"\n\t\t\t\t\t\"`tick_formatter` is a list then the first component \"\n\t\t\t\t\t\"of `ticks` must also be a list of equal length.\")\n\t\t\tx_formatter = FixedFormatter(x_formatter)\n\t\t#---------------------- Formatting y-ticks ----------------------#\n\t\tif y_formatter is None:\n\t\t\tif scale[1] == 'log':\n\t\t\t\ty_formatter = LogFormatterMathtext(base=base[1])\n\t\t\telse:\n\t\t\t\ty_formatter = OldScalarFormatter()\n\t\telif y_formatter in SR:\n\t\t\tfrom misc import _multiple_of_constant\n\t\t\ty_const = y_formatter\n\t\t\ty_formatter = FuncFormatter(lambda n,pos:\n\t\t\t\t\t\t\t\t\t\t_multiple_of_constant(n,pos,y_const))\n\t\telif y_formatter == \"latex\":\n\t\t\tif scale[1] == 'log':\n\t\t\t\t# We need to strip out '\\\\mathdefault' from the string\n\t\t\t\ty_formatter = FuncFormatter(lambda n,pos:\n\t\t\t\t\tLogFormatterMathtext(base=base[1])(n,pos).replace(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"\\\\mathdefault\",\"\"))\n\t\t\telse:\n\t\t\t\ty_formatter = FuncFormatter(lambda n,pos: '$%s$'%latex(n))\n\t\telif isinstance(y_formatter, (list, tuple)):\n\t\t\tif (not isinstance(ticks[1], (list, tuple)) or\n\t\t\t\t\tlen(ticks[1]) != len(y_formatter)):\n\t\t\t\traise ValueError(\"If the second component of the list \"\n\t\t\t\t\t\"`tick_formatter` is a list then the second component \"\n\t\t\t\t\t\"of `ticks` must also be a list of equal length.\")\n\t\t\ty_formatter = FixedFormatter(y_formatter)\n\n\t\tsubplot.xaxis.set_major_locator(x_locator)\n\t\tsubplot.yaxis.set_major_locator(y_locator)\n\t\tsubplot.xaxis.set_major_formatter(x_formatter)\n\t\tsubplot.yaxis.set_major_formatter(y_formatter)\n\n\t\t# Check for whether there will be too few ticks in the log scale case.\n\t\t# If there are not enough ticks (2 or more) to determine that the scale\n\t\t# is non-linear, we throw a warning.\n\t\tfrom warnings import warn\n\t\ttickwarnmsg  = 'The %s-axis contains fewer than 2 ticks; '\n\t\ttickwarnmsg += 'the logarithmic scale of the plot may not be apparent '\n\t\ttickwarnmsg += 'to the reader.'\n\n\t\tif (scale[0] == 'log' and not isinstance(x_locator, NullLocator)\n\t\t\t\tand len(subplot.xaxis.get_ticklocs()) < 2):\n\t\t\twarn(tickwarnmsg % 'x')\n\n\t\tif (scale[1] == 'log' and not isinstance(y_locator, NullLocator)\n\t\t\t\tand len(subplot.yaxis.get_ticklocs()) < 2):\n\t\t\twarn(tickwarnmsg % 'y')\n\n\t\treturn (subplot, x_locator, y_locator, x_formatter, y_formatter)\n\n\n\tdef _get_vmin_vmax(self, vmin, vmax, basev, axes_pad):\n\t\tr\"\"\"\n\t\tDetermine the min/max value for a variable plotted on a logarithmic\n\t\tscale. The motivation is that we desire at least two ticks for a log\n\t\tplot; otherwise the reader may assume that the scale is linear. For\n\t\tinternal use only.\n\n\t\tWe check if this case occurs (for e.g. assuming xmin < xmax):\n\n\t\t   floor(logxmin)\t\t\t  ceil(logxmax)\n\t\t   ----|---------+----------+----------|----------------------|--\n\t\t\t\t\t  logxmin\t logxmax\n\n\t\tOr if this case occurs (assuming xmin < xmax):\n\n\t\t   floor(logxmin)\t\t\t floor(logxmax)\t\t ceil(logxmax)\n\t\t   ----|---------+---------------------|-----+----------------|--\n\t\t\t\t\t  logxmin\t\t\t\t\t logxmax\n\n\n\t\tINPUT:\n\n\t\t-  ``vmin`` - the current min for this variable (e.g. xmin or ymin)\n\n\t\t-  ``vmax`` - the current max for this variable (e.g. xmax or ymax)\n\n\t\t-  ``basev`` - the base of the logarithmic scale for this variable\n\n\t\t- ``axes_pad`` - the padding for the axis. It determines the\n\t\t  exponent of the fraction of the minimum (resp. maximum) that is\n\t\t  subtracted from the minimum (resp. added to the maximum) value of\n\t\t  the axis. For instance if the minimum is `m` and the base of the\n\t\t  axis is `b` then the new minimum after padding the axis will be\n\t\t  `m - m/b^{\\mathrm{axes\\_pad}}`.\n\n\t\tOUTPUT:\n\n\t\tA new (min,max) pair for this variable, suitable for its logarithmic\n\t\tscale.\n\n\t\tEXAMPLES:\n\n\t\tOn a base-10 logarithmic scale, we should have ``vmin``/``vmax``\n\t\tat least 10 units apart::\n\n\t\t\tsage: p = Graphics()\n\t\t\tsage: p._get_vmin_vmax(1, 2, 10, None)\n\t\t\t(9/10, 10.0)\n\t\t\tsage: p._get_vmin_vmax(1, 5, 10, None)\n\t\t\t(9/10, 10.0)\n\t\t\tsage: p._get_vmin_vmax(1, 10, 10, None)\n\t\t\t(9/10, 11)\n\t\t\tsage: p._get_vmin_vmax(1, 11, 10, None)\n\t\t\t(9/10, 121/10)\n\t\t\tsage: p._get_vmin_vmax(1, 50, 10, None)\n\t\t\t(9/10, 55)\n\n\t\tWe can set the ``axes_pad`` separately::\n\n\t\t\tsage: p._get_vmin_vmax(1, 50, 2, 2)\n\t\t\t(0.75, 62.5)\n\n\t\tNonpositive values of ``vmin`` are not accepted due to the domain\n\t\tof the logarithm function::\n\n\t\t\tsage: p = Graphics()\n\t\t\tsage: p._get_vmin_vmax(-1,2,10, None)\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tValueError: vmin must be positive\n\n\t\tAnd ``vmax`` must be greater than ``vmin``::\n\n\t\t\tsage: p._get_vmin_vmax(1,-2,10, None)\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tValueError: vmin must be less than vmax\n\n\t\t\"\"\"\n\t\tif vmin <= 0:\n\t\t\traise ValueError('vmin must be positive')\n\n\t\tif vmin >= vmax:\n\t\t\traise ValueError('vmin must be less than vmax')\n\n\t\timport math\n\t\tif axes_pad is None:\n\t\t\taxes_pad = 1\n\t\telse:\n\t\t\taxes_pad = float(abs(axes_pad))\n\n\t\tlogvmin = math.log(vmin)/math.log(basev)\n\t\tlogvmax = math.log(vmax)/math.log(basev)\n\n\t\tif math.floor(logvmax) - math.ceil(logvmin) < 0:\n\t\t\tvmax = basev**math.ceil(logvmax)\n\t\t\tvmin = basev**math.floor(logvmin)\n\t\telif math.floor(logvmax) - math.ceil(logvmin) < 1:\n\t\t\tif logvmax-math.floor(logvmax) > math.ceil(logvmin)-logvmin:\n\t\t\t\tvmax = basev**math.ceil(logvmax)\n\t\t\t\tif axes_pad > 0:\n\t\t\t\t\tvmin -= vmin * basev**(-axes_pad)\n\t\t\telse:\n\t\t\t\tvmin = basev**math.floor(logvmin)\n\t\t\t\tif axes_pad > 0:\n\t\t\t\t\tvmax += vmax * basev**(-axes_pad)\n\t\telif axes_pad > 0:\n\t\t\t# pad the axes if we haven't expanded the axes earlier.\n\t\t\tvmin -= vmin * basev**(-axes_pad)\n\t\t\tvmax += vmax * basev**(-axes_pad)\n\n\t\treturn vmin,vmax\n\n\n\tdef matplotlib(self, filename=None,\n\t\t\t\t   xmin=None, xmax=None, ymin=None, ymax=None,\n\t\t\t\t   figsize=None, figure=None, sub=None,\n\t\t\t\t   axes=None, axes_labels=None, axes_labels_size=None,\n\t\t\t\t   fontsize=None, frame=False, verify=True,\n\t\t\t\t   aspect_ratio = None,\n\t\t\t\t   gridlines=None, gridlinesstyle=None,\n\t\t\t\t   vgridlinesstyle=None, hgridlinesstyle=None,\n\t\t\t\t   show_legend=None, legend_options={},\n\t\t\t\t   axes_pad=None, ticks_integer=None,\n\t\t\t\t   tick_formatter=None, ticks=None, title=None,\n\t\t\t\t   title_pos=None, base=None, scale=None,\n\t\t\t\t   typeset='default'):\n\t\tr\"\"\"\n\t\tReturn a matplotlib figure object representing the graphic\n\n\t\tEXAMPLES::\n\n\t\t\tsage: c = circle((1,1),1)\n\t\t\tsage: print c.matplotlib()\n\t\t\tFigure(640x480)\n\n\t\tTo obtain the first matplotlib axes object inside of the\n\t\tfigure, you can do something like the following.\n\n\t\t::\n\n\t\t\tsage: p=plot(sin(x), (x, -2*pi, 2*pi))\n\t\t\tsage: figure=p.matplotlib()\n\t\t\tsage: axes=figure.axes[0]\n\n\t\tFor input parameters, see the documentation for the\n\t\t:meth:`show` method (this function accepts all except the\n\t\ttransparent argument).\n\n\t\tTESTS:\n\n\t\tWe verify that :trac:`10291` is fixed::\n\n\t\t\tsage: p = plot(sin(x), (x, -2*pi, 2*pi))\n\t\t\tsage: figure = p.matplotlib()\n\t\t\tsage: axes_range = p.get_axes_range()\n\t\t\tsage: figure = p.matplotlib()\n\t\t\tsage: axes_range2 = p.get_axes_range()\n\t\t\tsage: axes_range == axes_range2\n\t\t\tTrue\n\n\t\tWe verify that legend options are properly handled (:trac:`12960`).\n\t\tFirst, we test with no options, and next with an incomplete set of\n\t\toptions.::\n\n\t\t\tsage: p = plot(x, legend_label='aha')\n\t\t\tsage: p.legend(True)\n\t\t\tsage: pm = p.matplotlib()\n\t\t\tsage: pm = p.matplotlib(legend_options={'font_size':'small'})\n\n\t\tThe title should not overlap with the axes labels nor the frame in\n\t\tthe following plot (see :trac:`10512`)::\n\n\t\t\tsage: plot(sin(x^2), (x, -3, 3), title='Plot of sin(x^2)', axes_labels=['x','y'],frame=True)\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\t``typeset`` must not be set to an arbitrary string::\n\n\t\t\tsage: plot(x, typeset='garbage')\n\t\t\tdoctest:...: RichReprWarning: Exception in _rich_repr_ while\n\t\t\tdisplaying object: typeset must be set to one of 'default',\n\t\t\t'latex', or 'type1'; got 'garbage'.\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tWe verify that numerical options are changed to float before saving (:trac:`14741`).\n\t\tBy default, Sage 5.10 changes float objects to the `RealLiteral` type.\n\t\tThe patch changes them to float before creating `matplotlib` objects.::\n\n\t\t\tsage: f = lambda x, y : (abs(cos((x + I * y) ** 4)) - 1) # long time\n\t\t\tsage: g = implicit_plot(f,(-4, 4),(-3, 3),linewidth=0.6) # long time\n\t\t\tsage: gm = g.matplotlib() # long time # without the patch, this goes BOOM -- er, TypeError\n\t\t\"\"\"\n\t\tif not isinstance(ticks, (list, tuple)):\n\t\t\tticks = (ticks, None)\n\n\t\tfrom sage.symbolic.ring import SR\n\t\tif not isinstance(tick_formatter, (list, tuple)):  # make sure both formatters typeset or both don't\n\t\t\tif tick_formatter == \"latex\" or tick_formatter in SR:\n\t\t\t\ttick_formatter = (tick_formatter, \"latex\")\n\t\t\telse:\n\t\t\t\ttick_formatter = (tick_formatter, None)\n\n\t\tglobal do_verify\n\t\tdo_verify = verify\n\n\t\tif axes is None:\n\t\t\taxes = self._show_axes\n\n\t\tfrom matplotlib.figure import Figure\n\t\tfrom matplotlib import rcParams\n\t\tif typeset == 'type1': # Requires LaTeX, dvipng, gs to be installed.\n\t\t\trcParams['ps.useafm'] = True\n\t\t\trcParams['pdf.use14corefonts'] = True\n\t\t\trcParams['text.usetex'] = True\n\t\telif typeset == 'latex': # Requires LaTeX, dvipng, gs to be installed.\n\t\t\trcParams['ps.useafm'] = False\n\t\t\trcParams['pdf.use14corefonts'] = False\n\t\t\trcParams['text.usetex'] = True\n\t\telif typeset != 'default': # We won't change (maybe user-set) defaults\n\t\t\traise ValueError(\"typeset must be set to one of 'default', 'latex',\"\n\t\t\t\t\t\t\t \" or 'type1'; got '{}'.\".format(typeset))\n\n\t\tself.fontsize(fontsize)\n\t\tself.axes_labels(l=axes_labels)\n\t\tself.axes_labels_size(s=axes_labels_size)\n\n\t\tif figsize is not None and not isinstance(figsize, (list, tuple)):\n\t\t\t# in this case, figsize is a number and should be positive\n\t\t\ttry:\n\t\t\t\tfigsize = float(figsize) # to pass to mpl\n\t\t\texcept TypeError:\n\t\t\t\traise TypeError(\"figsize should be a positive number, not {0}\".format(figsize))\n\t\t\tif figsize > 0:\n\t\t\t\tdefault_width, default_height=rcParams['figure.figsize']\n\t\t\t\tfigsize=(figsize, default_height*figsize/default_width)\n\t\t\telse:\n\t\t\t\traise ValueError(\"figsize should be positive, not {0}\".format(figsize))\n\n\t\tif figsize is not None:\n\t\t\t# then the figsize should be two positive numbers\n\t\t\tif len(figsize) != 2:\n\t\t\t\traise ValueError(\"figsize should be a positive number or a list of two positive numbers, not {0}\".format(figsize))\n\t\t\tfigsize = (float(figsize[0]),float(figsize[1])) # floats for mpl\n\t\t\tif not (figsize[0] > 0 and figsize[1] > 0):\n\t\t\t\traise ValueError(\"figsize should be positive numbers, not {0} and {1}\".format(figsize[0],figsize[1]))\n\n\t\tif figure is None:\n\t\t\tfigure=Figure(figsize=figsize)\n\n\t\t#the incoming subplot instance\n\t\tsubplot = sub\n\t\tif not subplot:\n\t\t\tsubplot = figure.add_subplot(111)\n\t\t#add all the primitives to the subplot\n\t\told_opts = dict()\n\t\tfor g in self._objects:\n\t\t\topts, old_opts[g] = g.options(), g.options()\n\t\t\tfor k,v in opts.items():\n\t\t\t\ttry:\n\t\t\t\t\tif v.parent() in sage.categories.fields.Fields(): opts[k] = float(v)\n\t\t\t\texcept (AttributeError, TypeError): pass\n\t\t\tg.set_options(opts)\n\t\t\tg._render_on_subplot(subplot)\n\t\t\tif hasattr(g, '_bbox_extra_artists'):\n\t\t\t\tself._bbox_extra_artists.extend(g._bbox_extra_artists)\n\t\t# Set the aspect ratio\n\t\tif aspect_ratio is None:\n\t\t\taspect_ratio=self.aspect_ratio()\n\t\tif aspect_ratio == 'automatic':\n\t\t\tsubplot.set_aspect('auto', adjustable='box')\n\t\telse:\n\t\t\tsubplot.set_aspect(aspect_ratio, adjustable='box')\n\n\t\t#---------------- Set the axes limits and scale ------------------#\n\t\tself.set_axes_range(xmin, xmax, ymin, ymax)\n\t\td = self.get_axes_range()\n\t\txmin = d['xmin']\n\t\txmax = d['xmax']\n\t\tymin = d['ymin']\n\t\tymax = d['ymax']\n\n\t\txscale, yscale, basex, basey = self._set_scale(figure, scale=scale,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   base=base)\n\n\t\t# If any of the x-data are negative, we leave the min/max alone.\n\t\tif xscale == 'log' and min(xmin, xmax) > 0:\n\t\t\tif xmin < xmax:\n\t\t\t\txmin, xmax = self._get_vmin_vmax(xmin, xmax, basex, axes_pad)\n\t\t\telse:\n\t\t\t\txmax, xmin = self._get_vmin_vmax(xmax, xmin, basex, axes_pad)\n\t\telse:\n\t\t\txpad = 0.02 if axes_pad is None else axes_pad\n\t\t\txpad = (xmax - xmin)*float(xpad)\n\t\t\txmax += xpad\n\t\t\txmin -= xpad\n\n\t\t# Likewise for the y-data.\n\t\tif yscale == 'log' and min(ymin, ymax) > 0:\n\t\t\tif ymin < ymax:\n\t\t\t\tymin, ymax = self._get_vmin_vmax(ymin, ymax, basey, axes_pad)\n\t\t\telse:\n\t\t\t\tymax, ymin = self._get_vmin_vmax(ymax, ymin, basey, axes_pad)\n\t\telse:\n\t\t\typad = 0.02 if axes_pad is None else axes_pad\n\t\t\typad = (ymax - ymin)*float(ypad)\n\t\t\tymax += ypad\n\t\t\tymin -= ypad\n\n\t\t#-------------------------- Set the legend -----------------------#\n\t\tif show_legend is None:\n\t\t\tshow_legend = self._show_legend\n\n\t\tif show_legend:\n\t\t\tfrom matplotlib.font_manager import FontProperties\n\t\t\tlopts = dict()\n\t\t\tlopts.update(legend_options)\n\t\t\tlopts.update(self._legend_opts)\n\t\t\tprop = FontProperties(\n\t\t\t\t\tfamily  = lopts.pop('font_family', 'sans-serif'),\n\t\t\t\t\tsize\t= lopts.pop('font_size', 'medium'),\n\t\t\t\t\tstyle   = lopts.pop('font_style', 'normal'),\n\t\t\t\t\tweight  = lopts.pop('font_weight', 'medium'),\n\t\t\t\t\tvariant = lopts.pop('font_variant', 'normal')\n\t\t\t\t   )\n\t\t\tcolor = lopts.pop('back_color', (0.9, 0.9, 0.9))\n\t\t\tleg = subplot.legend(prop=prop, **lopts)\n\t\t\tif leg is None:\n\t\t\t\tsage.misc.misc.warn(\"legend requested but no items are labeled\")\n\t\t\telse:\n\t\t\t\t# color\n\t\t\t\tlframe = leg.get_frame()\n\t\t\t\tlframe.set_facecolor(color)\n\t\t\t\tfrom sage.plot.colors import to_mpl_color\n\t\t\t\tfor txt,color in zip(leg.get_texts(), self._legend_colors):\n\t\t\t\t\tif color is not None:\n\t\t\t\t\t\ttxt.set_color(to_mpl_color(color))\n\n\t\tsubplot.set_xlim([xmin, xmax])\n\t\tsubplot.set_ylim([ymin, ymax])\n\n\t\tlocator_options=dict(nbins=9,steps=[1,2,5,10],integer=ticks_integer)\n\n\t\tif axes is None:\n\t\t\taxes = self._show_axes\n\n\t\tfor spine in subplot.spines.values():\n\t\t\tspine.set_color(self._axes_color)\n\t\t\tspine.set_linewidth(self._axes_width)\n\n\n\t\tif frame:\n\t\t\t# For now, set the formatter to the old one, since that is\n\t\t\t# sort of what we are used to.  We should eventually look at\n\t\t\t# the default one to see if we like it better.\n\n\t\t\t(subplot, x_locator, y_locator,\n\t\t\t\tx_formatter, y_formatter) = self._matplotlib_tick_formatter(\n\t\t\t\t\t\t\tsubplot, base=(basex, basey),\n\t\t\t\t\t\t\tlocator_options=locator_options,\n\t\t\t\t\t\t\tscale=(xscale, yscale),\n\t\t\t\t\t\t\ttick_formatter=tick_formatter, ticks=ticks,\n\t\t\t\t\t\t\txmax=xmax, xmin=xmin, ymax=ymax, ymin=ymin)\n\n\t\t\tsubplot.set_frame_on(True)\n\t\t\tif axes and xscale == 'linear' and yscale == 'linear':\n\t\t\t\tif (ymin<=0 and ymax>=0) or (ymax<=0 and ymin>=0):\n\t\t\t\t\tsubplot.axhline(color=self._axes_color,\n\t\t\t\t\t\t\t\t\tlinewidth=self._axes_width)\n\t\t\t\tif (xmin<=0 and xmax>=0) or (xmax<=0 and xmin>=0):\n\t\t\t\t\tsubplot.axvline(color=self._axes_color,\n\t\t\t\t\t\t\t\t\tlinewidth=self._axes_width)\n\n\t\telif axes:\n\t\t\tymiddle=False\n\t\t\txmiddle=False\n\t\t\t# Note that the user may specify a custom xmin and xmax which\n\t\t\t# flips the axis horizontally. Hence we need to check for both\n\t\t\t# the possibilities in the if statements below. Similar\n\t\t\t# comments hold for ymin and ymax.\n\t\t\tif xscale == 'log':\n\t\t\t\tif xmax > xmin:\n\t\t\t\t\tsubplot.spines['right'].set_visible(False)\n\t\t\t\t\tsubplot.spines['left'].set_position(('outward',10))\n\t\t\t\t\tsubplot.yaxis.set_ticks_position('left')\n\t\t\t\t\tsubplot.yaxis.set_label_position('left')\n\t\t\t\t\tyaxis='left'\n\t\t\t\telif xmax < xmin:\n\t\t\t\t\tsubplot.spines['left'].set_visible(False)\n\t\t\t\t\tsubplot.spines['right'].set_position(('outward',10))\n\t\t\t\t\tsubplot.yaxis.set_ticks_position('right')\n\t\t\t\t\tsubplot.yaxis.set_label_position('right')\n\t\t\t\t\tyaxis='right'\n\t\t\telif (xmin > 0 and xmax > xmin) or (xmax > 0 and xmin > xmax):\n\t\t\t\tsubplot.spines['right'].set_visible(False)\n\t\t\t\tsubplot.spines['left'].set_position(('outward',10))\n\t\t\t\tsubplot.yaxis.set_ticks_position('left')\n\t\t\t\tsubplot.yaxis.set_label_position('left')\n\t\t\t\tyaxis='left'\n\t\t\telif (xmax < 0 and xmax > xmin) or (xmin < 0 and xmin > xmax):\n\t\t\t\tsubplot.spines['left'].set_visible(False)\n\t\t\t\tsubplot.spines['right'].set_position(('outward',10))\n\t\t\t\tsubplot.yaxis.set_ticks_position('right')\n\t\t\t\tsubplot.yaxis.set_label_position('right')\n\t\t\t\tyaxis='right'\n\t\t\telse:\n\t\t\t\tsubplot.spines['left'].set_position('zero')\n\t\t\t\tsubplot.yaxis.set_ticks_position('left')\n\t\t\t\tsubplot.yaxis.set_label_position('left')\n\t\t\t\tsubplot.spines['right'].set_visible(False)\n\t\t\t\tymiddle=True\n\t\t\t\tyaxis='left'\n\n\t\t\tif yscale == 'log':\n\t\t\t\tif ymax > ymin:\n\t\t\t\t\tsubplot.spines['top'].set_visible(False)\n\t\t\t\t\tsubplot.spines['bottom'].set_position(('outward',10))\n\t\t\t\t\tsubplot.xaxis.set_ticks_position('bottom')\n\t\t\t\t\tsubplot.xaxis.set_label_position('bottom')\n\t\t\t\t\txaxis='bottom'\n\t\t\t\telif ymax < ymin:\n\t\t\t\t\tsubplot.spines['bottom'].set_visible(False)\n\t\t\t\t\tsubplot.spines['top'].set_position(('outward',10))\n\t\t\t\t\tsubplot.xaxis.set_ticks_position('top')\n\t\t\t\t\tsubplot.xaxis.set_label_position('top')\n\t\t\t\t\txaxis='top'\n\t\t\telif (ymin > 0 and ymax > ymin) or (ymax > 0 and ymin > ymax):\n\t\t\t\tsubplot.spines['top'].set_visible(False)\n\t\t\t\tsubplot.spines['bottom'].set_position(('outward',10))\n\t\t\t\tsubplot.xaxis.set_ticks_position('bottom')\n\t\t\t\tsubplot.xaxis.set_label_position('bottom')\n\t\t\t\txaxis='bottom'\n\t\t\telif (ymax < 0 and ymax > ymin) or (ymin < 0 and ymin > ymax):\n\t\t\t\tsubplot.spines['bottom'].set_visible(False)\n\t\t\t\tsubplot.spines['top'].set_position(('outward',10))\n\t\t\t\tsubplot.xaxis.set_ticks_position('top')\n\t\t\t\tsubplot.xaxis.set_label_position('top')\n\t\t\t\txaxis='top'\n\t\t\telse:\n\t\t\t\tsubplot.spines['bottom'].set_position('zero')\n\t\t\t\tsubplot.xaxis.set_ticks_position('bottom')\n\t\t\t\tsubplot.xaxis.set_label_position('bottom')\n\t\t\t\tsubplot.spines['top'].set_visible(False)\n\t\t\t\txmiddle=True\n\t\t\t\txaxis='bottom'\n\n\t\t\t# For now, set the formatter to the old one, since that is\n\t\t\t# sort of what we are used to.  We should eventually look at\n\t\t\t# the default one to see if we like it better.\n\n\t\t\t(subplot, x_locator, y_locator,\n\t\t\t\tx_formatter, y_formatter) = self._matplotlib_tick_formatter(\n\t\t\t\t\t\t\tsubplot, base=(basex, basey),\n\t\t\t\t\t\t\tlocator_options=locator_options,\n\t\t\t\t\t\t\tscale=(xscale, yscale),\n\t\t\t\t\t\t\ttick_formatter=tick_formatter, ticks=ticks,\n\t\t\t\t\t\t\txmax=xmax, xmin=xmin, ymax=ymax, ymin=ymin)\n\n\t\t\t# Make ticklines go on both sides of the axes\n\t\t\t#\t\t\t if xmiddle:\n\t\t\t#\t\t\t\t for t in subplot.xaxis.get_majorticklines():\n\t\t\t#\t\t\t\t\t t.set_marker(\"|\")\n\t\t\t#\t\t\t\t\t t.set_markersize(8)\n\t\t\t#\t\t\t\t for t in subplot.xaxis.get_minorticklines():\n\t\t\t#\t\t\t\t\t t.set_marker(\"|\")\n\t\t\t#\t\t\t\t\t t.set_markersize(4)\n\n\t\t\t#\t\t\t if ymiddle:\n\t\t\t#\t\t\t\t for t in subplot.yaxis.get_majorticklines():\n\t\t\t#\t\t\t\t\t t.set_marker(\"|\")\n\t\t\t#\t\t\t\t\t t.set_markersize(8)\n\t\t\t#\t\t\t\t for t in subplot.yaxis.get_minorticklines():\n\t\t\t#\t\t\t\t\t t.set_marker(\"|\")\n\t\t\t#\t\t\t\t\t t.set_markersize(4)\n\n\t\t\t# Make the zero tick labels disappear if the axes cross\n\t\t\t# inside the picture, but only if log scale is not used\n\t\t\tif (xmiddle and ymiddle and xscale == 'linear' and\n\t\t\t\tyscale == 'linear'):\n\t\t\t\tfrom sage.plot.plot import SelectiveFormatter\n\t\t\t\tsubplot.yaxis.set_major_formatter(SelectiveFormatter(\n\t\t\t\t\tsubplot.yaxis.get_major_formatter(), skip_values=[0]))\n\t\t\t\tsubplot.xaxis.set_major_formatter(SelectiveFormatter(\n\t\t\t\t\tsubplot.xaxis.get_major_formatter(), skip_values=[0]))\n\n\t\telse:\n\t\t\tfor spine in subplot.spines.values():\n\t\t\t\tspine.set_visible(False)\n\t\t\tfrom matplotlib.ticker import NullFormatter, NullLocator\n\t\t\tsubplot.xaxis.set_major_formatter(NullFormatter())\n\t\t\tsubplot.yaxis.set_major_formatter(NullFormatter())\n\t\t\tsubplot.xaxis.set_major_locator(NullLocator())\n\t\t\tsubplot.yaxis.set_major_locator(NullLocator())\n\n\t\tif frame or axes:\n\t\t\t# Make minor tickmarks, unless we specify fixed ticks or no ticks\n\t\t\t# We do this change only on linear scale, otherwise matplotlib\n\t\t\t# errors out with a memory error.\n\t\t\tfrom matplotlib.ticker import (AutoMinorLocator, FixedLocator,\n\t\t\t\t\tLogLocator, NullLocator)\n\t\t\tif isinstance(x_locator, (NullLocator, FixedLocator)):\n\t\t\t\tsubplot.xaxis.set_minor_locator(NullLocator())\n\t\t\telif xscale == 'linear':\n\t\t\t\tsubplot.xaxis.set_minor_locator(AutoMinorLocator())\n\t\t\telse: # log scale\n\t\t\t\tfrom sage.misc.misc import srange\n\t\t\t\tbase_inv = 1.0/basex\n\t\t\t\tsubs = [float(_) for _ in srange(2*base_inv, 1, base_inv)]\n\t\t\t\tsubplot.xaxis.set_minor_locator(LogLocator(base=basex,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   subs=subs))\n\t\t\tif isinstance(y_locator, (NullLocator, FixedLocator)):\n\t\t\t\tsubplot.yaxis.set_minor_locator(NullLocator())\n\t\t\telif yscale == 'linear':\n\t\t\t\tsubplot.yaxis.set_minor_locator(AutoMinorLocator())\n\t\t\telse: # log scale\n\t\t\t\tfrom sage.misc.misc import srange\n\t\t\t\tbase_inv = 1.0/basey\n\t\t\t\tsubs = [float(_) for _ in srange(2*base_inv, 1, base_inv)]\n\t\t\t\tsubplot.yaxis.set_minor_locator(LogLocator(base=basey,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   subs=subs))\n\n\t\t\t# Set the color and fontsize of ticks\n\t\t\tfigure.get_axes()[0].tick_params(color=self._axes_color,\n\t\t\t\t\tlabelcolor=self._tick_label_color,\n\t\t\t\t\tlabelsize=self._fontsize, which='both')\n\n\n\t\tif gridlines is not None:\n\t\t\tif isinstance(gridlines, (list, tuple)):\n\t\t\t\tvgridlines,hgridlines=gridlines\n\t\t\telse:\n\t\t\t\thgridlines=gridlines\n\t\t\t\tvgridlines=gridlines\n\n\t\t\tif gridlinesstyle is None:\n\t\t\t\t# Set up the default grid style\n\t\t\t\tgridlinesstyle=dict(color='black',linestyle=':',linewidth=0.5)\n\n\t\t\tvgridstyle=gridlinesstyle.copy()\n\t\t\tif vgridlinesstyle is not None:\n\t\t\t\tvgridstyle.update(vgridlinesstyle)\n\n\t\t\thgridstyle=gridlinesstyle.copy()\n\t\t\tif hgridlinesstyle is not None:\n\t\t\t\thgridstyle.update(hgridlinesstyle)\n\n\t\t\tif hgridlines=='minor':\n\t\t\t\thgridstyle['which']='both'\n\t\t\tif vgridlines=='minor':\n\t\t\t\tvgridstyle['which']='both'\n\n\t\t\tif hasattr(hgridlines, '__iter__'):\n\t\t\t\thlines=iter(hgridlines)\n\t\t\t\thgridstyle.pop(\"minor\",None)\n\t\t\t\tfor hline in hlines:\n\t\t\t\t\tif isinstance(hline, (list, tuple)):\n\t\t\t\t\t\thl, style=hline\n\t\t\t\t\t\tst=hgridstyle.copy()\n\t\t\t\t\t\tst.update(style)\n\t\t\t\t\telse:\n\t\t\t\t\t\thl=hline\n\t\t\t\t\t\tst=hgridstyle\n\t\t\t\t\tsubplot.axhline(hl,**st)\n\t\t\telse:\n\t\t\t\tif hgridlines not in (None, False):\n\t\t\t\t\tsubplot.yaxis.grid(True, **hgridstyle)\n\n\t\t\tif hasattr(vgridlines, '__iter__'):\n\t\t\t\tvlines=iter(vgridlines)\n\t\t\t\tvgridstyle.pop(\"minor\",None)\n\t\t\t\tfor vline in vlines:\n\t\t\t\t\tif isinstance(vline, (list, tuple)):\n\t\t\t\t\t\tvl, style=vline\n\t\t\t\t\t\tst=vgridstyle.copy()\n\t\t\t\t\t\tst.update(style)\n\t\t\t\t\telse:\n\t\t\t\t\t\tvl=vline\n\t\t\t\t\t\tst=vgridstyle\n\t\t\t\t\tsubplot.axvline(vl,**st)\n\t\t\telse:\n\t\t\t\tif vgridlines not in (None, False):\n\t\t\t\t\tsubplot.xaxis.grid(True, **vgridstyle)\n\n\n\n\t\tif self._axes_labels is not None:\n\t\t\tlabel_options={}\n\t\t\tlabel_options['color']=self._axes_label_color\n\t\t\tlabel_options['size']=int(self._axes_labels_size * self._fontsize)\n\t\t\tsubplot.set_xlabel(self._axes_labels[0], **label_options)\n\t\t\tsubplot.set_ylabel(self._axes_labels[1], **label_options)\n\n\n\t\t\tif axes is True and frame is False:\n\t\t\t\t# We set the label positions according to where we are\n\t\t\t\t# drawing the axes.\n\t\t\t\tif xaxis=='bottom':\n\t\t\t\t\tyaxis_labely=subplot.get_ylim()[1]\n\t\t\t\t\tyaxis_labeloffset=8\n\t\t\t\t\tyaxis_vert='bottom'\n\t\t\t\t\txaxis_labely=0\n\t\t\t\t\txaxis_vert='baseline'\n\t\t\t\telse:\n\t\t\t\t\tyaxis_labely=subplot.get_ylim()[0]\n\t\t\t\t\tyaxis_labeloffset=-8\n\t\t\t\t\tyaxis_vert='top'\n\t\t\t\t\txaxis_labely=1\n\t\t\t\t\txaxis_vert='top'\n\n\t\t\t\tif yaxis=='left':\n\t\t\t\t\txaxis_labelx=subplot.get_xlim()[1]\n\t\t\t\t\txaxis_labeloffset=8\n\t\t\t\t\txaxis_horiz='left'\n\t\t\t\t\tyaxis_labelx=0\n\t\t\t\telse:\n\t\t\t\t\txaxis_labelx=subplot.get_xlim()[0]\n\t\t\t\t\txaxis_labeloffset=-8\n\t\t\t\t\txaxis_horiz='right'\n\t\t\t\t\tyaxis_labelx=1\n\n\t\t\t\tfrom matplotlib.transforms import offset_copy\n\t\t\t\txlabel=subplot.xaxis.get_label()\n\t\t\t\txlabel.set_horizontalalignment(xaxis_horiz)\n\t\t\t\txlabel.set_verticalalignment(xaxis_vert)\n\t\t\t\ttrans=subplot.spines[xaxis].get_transform()\n\t\t\t\tlabeltrans=offset_copy(trans, figure, x=xaxis_labeloffset,\n\t\t\t\t\t\t\t\t\ty=0, units='points')\n\t\t\t\tsubplot.xaxis.set_label_coords(x=xaxis_labelx,\n\t\t\t\t\t\t\t\t\ty=xaxis_labely, transform=labeltrans)\n\n\t\t\t\tylabel=subplot.yaxis.get_label()\n\t\t\t\tylabel.set_horizontalalignment('center')\n\t\t\t\tylabel.set_verticalalignment(yaxis_vert)\n\t\t\t\tylabel.set_rotation('horizontal')\n\t\t\t\ttrans=subplot.spines[yaxis].get_transform()\n\t\t\t\tlabeltrans=offset_copy(trans, figure, x=0,\n\t\t\t\t\t\t\t\t\ty=yaxis_labeloffset, units='points')\n\t\t\t\tsubplot.yaxis.set_label_coords(x=yaxis_labelx,\n\t\t\t\t\t\t\t\t\ty=yaxis_labely, transform=labeltrans)\n\n\t\t# This option makes the xlim and ylim limits not take effect\n\t\t# todo: figure out which limits were specified, and let the\n\t\t# free limits autoscale\n\t\t#subplot.autoscale_view(tight=True)\n\t\tif title is not None:\n\t\t\tif title_pos is not None:\n\t\t\t\tif ((not isinstance(title_pos, (list, tuple)))\n\t\t\t\t\tor (len(title_pos) != 2)):\n\t\t\t\t\traise ValueError(\"'title_pos' must be a list or tuple \"\n\t\t\t\t\t\t\t\t\t \"of two real numbers.\")\n\t\t\t\ttitle_pos = (float(title_pos[0]), float(title_pos[1]))\n\n\t\t\tif (frame) or (axes_labels is None):\n\t\t\t\tif title_pos is not None:\n\t\t\t\t\tsubplot.set_title(title, fontsize=fontsize,\n\t\t\t\t\t\t\t\t\t  position=title_pos)\n\t\t\t\telse:\n\t\t\t\t\tsubplot.set_title(title, fontsize=fontsize)\n\t\t\telse: # frame is false axes is not None, and neither is axes_labels\n\t\t\t\t# Then, the title is moved up to avoid overlap with axes labels\n\t\t\t\tif title_pos is None:\n\t\t\t\t\ttitle_pos = (0.5, 1.05)\n\t\t\t\tsubplot.set_title(title, fontsize=fontsize, position=title_pos)\n\n\t\tfor g in self._objects:\n\t\t\tg.set_options(old_opts[g])\n\n\t\treturn figure\n\n\tdef save_image(self, filename=None, *args, **kwds):\n\t\tr\"\"\"\n\t\tSave an image representation of self.  The image type is\n\t\tdetermined by the extension of the filename.  For example,\n\t\tthis could be ``.png``, ``.jpg``, ``.gif``, ``.pdf``,\n\t\t``.svg``.  Currently this is implemented by calling the\n\t\t:meth:`save` method of self, passing along all arguments and\n\t\tkeywords.\n\n\t\t.. Note::\n\n\t\t\tNot all image types are necessarily implemented for all\n\t\t\tgraphics types.  See :meth:`save` for more details.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: c = circle((1,1), 1, color='red')\n\t\t\tsage: filename = os.path.join(SAGE_TMP, 'test.png')\n\t\t\tsage: c.save_image(filename, xmin=-1, xmax=3, ymin=-1, ymax=3)\n\t\t\"\"\"\n\t\tself.save(filename, *args, **kwds)\n\n\n\t# ALLOWED_EXTENSIONS is the list of recognized formats.\n\t# filename argument is written explicitly so that it can be used as a\n\t# positional one, which is a very likely usage for this function.\n\t@suboptions('legend',\n\t\t\t\tback_color=(0.9, 0.9, 0.9), borderpad=0.6,\n\t\t\t\tborderaxespad=None,\n\t\t\t\tcolumnspacing=None,\n\t\t\t\tfancybox=False, font_family='sans-serif',\n\t\t\t\tfont_size='medium', font_style='normal',\n\t\t\t\tfont_variant='normal', font_weight='medium',\n\t\t\t\thandlelength=0.05, handletextpad=0.5,\n\t\t\t\tlabelspacing=0.02, loc='best',\n\t\t\t\tmarkerscale=0.6, ncol=1, numpoints=2,\n\t\t\t\tshadow=False, title=None)\n\tdef save(self, filename=None, **kwds):\n\t\tr\"\"\"\n\t\tSave the graphics to an image file.\n\n\t\tINPUT:\n\n\t\t- ``filename`` -- string. The filename and the image format\n\t\t  given by the extension, which can be one of the following:\n\n\t\t\t* ``.eps``,\n\n\t\t\t* ``.pdf``,\n\n\t\t\t* ``.png``,\n\n\t\t\t* ``.ps``,\n\n\t\t\t* ``.sobj`` (for a Sage object you can load later),\n\n\t\t\t* ``.svg``,\n\n\t\t\t* empty extension will be treated as ``.sobj``.\n\n\t\tAll other keyword arguments will be passed to the plotter.\n\n\t\tOUTPUT:\n\n\t\t- none.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: c = circle((1,1), 1, color='red')\n\t\t\tsage: filename = os.path.join(SAGE_TMP, 'test.png')\n\t\t\tsage: c.save(filename, xmin=-1, xmax=3, ymin=-1, ymax=3)\n\n\t\tTo make a figure bigger or smaller, use ``figsize``::\n\n\t\t\tsage: c.save(filename, figsize=5, xmin=-1, xmax=3, ymin=-1, ymax=3)\n\n\t\tBy default, the figure grows to include all of the graphics and text,\n\t\tso the final image may not be exactly the figure size you specified.\n\t\tIf you want a figure to be exactly a certain size, specify the keyword\n\t\t``fig_tight=False``::\n\n\t\t\tsage: c.save(filename, figsize=[8,4], fig_tight=False,\n\t\t\t....:\t   xmin=-1, xmax=3, ymin=-1, ymax=3)\n\n\t\tYou can also pass extra options to the plot command instead of this\n\t\tmethod, e.g. ::\n\n\t\t\tsage: plot(x^2 - 5, (x, 0, 5), ymin=0).save(tmp_filename(ext='.png'))\n\n\t\twill save the same plot as the one shown by this command::\n\n\t\t\tsage: plot(x^2 - 5, (x, 0, 5), ymin=0)\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\t(This test verifies that :trac:`8632` is fixed.)\n\n\t\tTESTS:\n\n\t\tLegend labels should save correctly::\n\n\t\t\tsage: P = plot(x,(x,0,1),legend_label='$xyz$')\n\t\t\tsage: P.set_legend_options(back_color=(1,0,0))\n\t\t\tsage: P.set_legend_options(loc=7)\n\t\t\tsage: filename=os.path.join(SAGE_TMP, 'test.png')\n\t\t\tsage: P.save(filename)\n\n\t\tThis plot should save with the frame shown, showing :trac:`7524`\n\t\tis fixed (same issue as :trac:`7981` and :trac:`8632`)::\n\n\t\t\tsage: var('x,y')\n\t\t\t(x, y)\n\t\t\tsage: a = plot_vector_field((x,-y),(x,-1,1),(y,-1,1))\n\t\t\tsage: filename=os.path.join(SAGE_TMP, 'test2.png')\n\t\t\tsage: a.save(filename)\n\n\t\tThe following plot should show the axes; fixes :trac:`14782` ::\n\n\t\t\tsage: plot(x^2, (x, 1, 2), ticks=[[], []])\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\t\"\"\"\n\t\toptions = dict()\n\t\toptions.update(self.SHOW_OPTIONS)\n\t\toptions.update(self._extra_kwds)\n\t\toptions.update(kwds)\n\t\tdpi = options.pop('dpi')\n\t\ttransparent = options.pop('transparent')\n\t\tfig_tight = options.pop('fig_tight')\n\n\t\tif filename is None:\n\t\t\tfrom sage.misc.superseded import deprecation\n\t\t\tdeprecation(17234,'the filename argument is now mandatory')\n\t\t\tfrom sage.misc.temporary_file import graphics_filename\n\t\t\tfilename = graphics_filename()\n\t\text = os.path.splitext(filename)[1].lower()\n\n\t\tif ext not in ALLOWED_EXTENSIONS:\n\t\t\traise ValueError(\"allowed file extensions for images are '\"\n\t\t\t\t\t\t\t + \"', '\".join(ALLOWED_EXTENSIONS) + \"'!\")\n\t\telif ext in ['', '.sobj']:\n\t\t\tSageObject.save(self, filename)\n\t\telse:\n\t\t\tfrom matplotlib import rcParams\n\t\t\trc_backup = (rcParams['ps.useafm'], rcParams['pdf.use14corefonts'],\n\t\t\t\t\t\t rcParams['text.usetex']) # save the rcParams\n\t\t\tfigure = self.matplotlib(**options)\n\t\t\t# You can output in PNG, PS, EPS, PDF, or SVG format, depending\n\t\t\t# on the file extension.\n\t\t\t# matplotlib looks at the file extension to see what the renderer should be.\n\t\t\t# The default is FigureCanvasAgg for PNG's because this is by far the most\n\t\t\t# common type of files rendered, like in the notebook, for example.\n\t\t\t# if the file extension is not '.png', then matplotlib will handle it.\n\t\t\tfrom matplotlib.backends.backend_agg import FigureCanvasAgg\n\t\t\tfigure.set_canvas(FigureCanvasAgg(figure))\n\t\t\t# this messes up the aspect ratio!\n\t\t\t#figure.canvas.mpl_connect('draw_event', pad_for_tick_labels)\n\n\t\t\t# tight_layout adjusts the *subplot* parameters so ticks aren't cut off, etc.\n\t\t\tfigure.tight_layout()\n\n\t\t\topts = dict(dpi=dpi, transparent=transparent)\n\t\t\tif fig_tight is True:\n\t\t\t\topts['bbox_inches'] = 'tight'\n\t\t\tif self._bbox_extra_artists:\n\t\t\t\topts['bbox_extra_artists'] = self._bbox_extra_artists\n\n\t\t\tfigure.savefig(filename, **opts)\n\n\t\t\t# Restore the rcParams to the original, possibly user-set values\n\t\t\t(rcParams['ps.useafm'], rcParams['pdf.use14corefonts'],\n\t\t\t\t\t\t\t\t\t\t   rcParams['text.usetex']) = rc_backup\n\n\tdef description(self):\n\t\tr\"\"\"\n\t\tPrint a textual description to stdout.\n\n\t\tThis method is mostly used for doctests.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: print polytopes.hypercube(2).plot().description()\n\t\t\tPolygon defined by 4 points: [(1.0, 1.0), (-1.0, 1.0), (-1.0, -1.0), (1.0, -1.0)]\n\t\t\tLine defined by 2 points: [(-1.0, -1.0), (-1.0, 1.0)]\n\t\t\tLine defined by 2 points: [(-1.0, -1.0), (1.0, -1.0)]\n\t\t\tLine defined by 2 points: [(-1.0, 1.0), (1.0, 1.0)]\n\t\t\tLine defined by 2 points: [(1.0, -1.0), (1.0, 1.0)]\n\t\t\tPoint set defined by 4 point(s): [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]\n\t\t\"\"\"\n\t\tdata = []\n\t\tfor g in self:\n\t\t\tg_zorder = g.options().get('zorder', 0)\n\t\t\tif hasattr(g, 'xdata'):\n\t\t\t\tg_str = '{0}:\\t{1}'.format(g, zip(g.xdata, g.ydata))\n\t\t\telse:\n\t\t\t\tg_str = repr(g)\n\t\t\tdata.append([g_zorder, g_str, g])\n\t\tdata.sort()\n\t\treturn '\\n'.join(g[1] for g in data)\n\n", "description": "\n\tThe Graphics object is an empty list of graphics objects. It is\n\tuseful to use this object when initializing a for loop where\n\tdifferent graphics object will be added to the empty object.\n\n\tEXAMPLES::\n\n\t\tsage: G = Graphics(); print G\n\t\tGraphics object consisting of 0 graphics primitives\n\t\tsage: c = circle((1,1), 1)\n\t\tsage: G+=c; print G\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tHere we make a graphic of embedded isosceles triangles, coloring\n\teach one with a different color as we go::\n\n\t\tsage: h=10; c=0.4; p=0.5;\n\t\tsage: G = Graphics()\n\t\tsage: for x in srange(1,h+1):\n\t\t....:\t l = [[0,x*sqrt(3)],[-x/2,-x*sqrt(3)/2],[x/2,-x*sqrt(3)/2],[0,x*sqrt(3)]]\n\t\t....:\t G+=line(l,color=hue(c + p*(x/h)))\n\t\tsage: G.show(figsize=[5,5])\n\n\tWe can change the scale of the axes in the graphics before displaying.::\n\n\t\tsage: G = plot(exp, 1, 10) # long time\n\t\tsage: G.show(scale='semilogy') # long time\n\n\tTESTS:\n\n\tFrom :trac:`4604`, ensure Graphics can handle 3d objects::\n\n\t\tsage: g = Graphics()\n\t\tsage: g += sphere((1, 1, 1), 2)\n\t\tsage: g.show()\n\n\tWe check that graphics can be pickled (we can't use equality on\n\tgraphics so we just check that the load/dump cycle gives a\n\t:class:`Graphics` instance)::\n\n\t\tsage: g = Graphics()\n\t\tsage: g2 = loads(dumps(g))\n\t\tsage: g2.show()\n\n\t::\n\n\t\tsage: isinstance(g2, Graphics)\n\t\tTrue\n\n\tTESTS::\n\n\t\tsage: hash(Graphics()) # random\n\t\t42\n\n\t.. automethod:: _rich_repr_\n\t", "category": "graphics", "imports": ["import os", "from math import isnan", "import sage.misc.misc", "from sage.misc.html import html", "from sage.misc.temporary_file import tmp_filename", "from sage.misc.fast_methods import WithEqualityById", "from sage.structure.sage_object import SageObject", "from sage.misc.decorators import suboptions", "from colors import rgbcolor", "\tfrom sage.misc.superseded import deprecation", "\timport sage.doctest", "\t\tsage: from sage.plot.graphics import is_Graphics", "\t\t\tsage: from sage.repl.rich_output import get_display_manager", "\t\tfrom sage.plot.primitive import GraphicPrimitive", "\t\t\tfrom sage.plot.plot3d.base import Graphics3d", "\t\t\tsage: from sage.plot.line import Line", "\t\t\tsage: from sage.plot.arrow import Arrow", "\t\tfrom sage.plot.plot3d.base import Graphics3dGroup", "\t\t  locators, type ``from matplotlib import ticker`` and then", "\t\t  formatters, type ``from matplotlib import ticker`` and then", "\t\t\tfrom sage.misc.superseded import deprecation", "\t\t\t\tfrom sage.misc.temporary_file import graphics_filename", "\t\tfrom sage.repl.rich_output import get_display_manager", "\t\t\tsage: from matplotlib.figure import Figure", "\t\tfrom matplotlib.ticker import (FixedLocator, Locator,", "\t\t\tfrom sage.functions.other import ceil, floor", "\t\t\tfrom sage.functions.other import ceil, floor", "\t\tfrom matplotlib.ticker import FuncFormatter, FixedFormatter", "\t\tfrom sage.misc.latex import latex", "\t\tfrom sage.symbolic.ring import SR", "\t\t\tfrom misc import _multiple_of_constant", "\t\t\tfrom misc import _multiple_of_constant", "\t\tfrom warnings import warn", "\t\timport math", "\t\tfrom sage.symbolic.ring import SR", "\t\tfrom matplotlib.figure import Figure", "\t\tfrom matplotlib import rcParams", "\t\t\tfrom matplotlib.font_manager import FontProperties", "\t\t\t\tfrom sage.plot.colors import to_mpl_color", "\t\t\t\tfrom sage.plot.plot import SelectiveFormatter", "\t\t\tfrom matplotlib.ticker import NullFormatter, NullLocator", "\t\t\tfrom matplotlib.ticker import (AutoMinorLocator, FixedLocator,", "\t\t\t\tfrom sage.misc.misc import srange", "\t\t\t\tfrom sage.misc.misc import srange", "\t\t\t\tfrom matplotlib.transforms import offset_copy", "\t\t\tfrom sage.misc.superseded import deprecation", "\t\t\tfrom sage.misc.temporary_file import graphics_filename", "\t\t\tfrom matplotlib import rcParams", "\t\t\tfrom matplotlib.backends.backend_agg import FigureCanvasAgg", "\t\t\tsage: from sage.repl.rich_output import get_display_manager", "\t\t\tsage: from sage.plot.graphics import GraphicsArray", "\t\t\tfrom sage.misc.superseded import deprecation", "\t\t\tfrom sage.misc.temporary_file import graphics_filename", "\t\tfrom matplotlib.figure import Figure", "\t\tfrom sage.repl.rich_output import get_display_manager"]}, {"term": "class", "name": "GraphicsArray", "data": "class GraphicsArray(WithEqualityById, SageObject):\n\t\"\"\"\n\tGraphicsArray takes a (`m` x `n`) list of lists of\n\tgraphics objects and plots them all on one canvas.\n\n\t.. automethod:: _rich_repr_\n\t\"\"\"\n\tdef __init__(self, array):\n\t\t\"\"\"\n\t\tConstructor for ``GraphicsArray`` class.  Normally used only\n\t\tvia :func:`graphics_array` function.\n\n\t\tINPUT: a list or list of lists/tuples, all of which are graphics objects\n\n\t\tEXAMPLES::\n\n\t\t\tsage: L = [plot(sin(k*x),(x,-pi,pi)) for k in range(10)]\n\t\t\tsage: G = graphics_array(L)\n\t\t\tsage: G.ncols()\n\t\t\t10\n\t\t\tsage: M = [[plot(x^2)],[plot(x^3)]]\n\t\t\tsage: H = graphics_array(M)\n\t\t\tsage: str(H[1])\n\t\t\t'Graphics object consisting of 1 graphics primitive'\n\n\t\tTESTS::\n\n\t\t\tsage: L = [[plot(sin),plot(cos)],[plot(tan)]]\n\t\t\tsage: graphics_array(L)\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tTypeError: array (=[[Graphics object consisting of 1 graphics primitive, Graphics object consisting of 1 graphics primitive], [Graphics object consisting of 1 graphics primitive]]) must be a list of lists of Graphics objects\n\t\t\tsage: G = plot(x,(x,0,1))\n\t\t\tsage: graphics_array(G)\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tTypeError: array (=Graphics object consisting of 1 graphics primitive) must be a list of lists of Graphics objects\n\t\t\tsage: G = [[plot(x,(x,0,1)),x]]\n\t\t\tsage: graphics_array(G)\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tTypeError: every element of array must be a Graphics object\n\n\t\t\tsage: hash(graphics_array([])) # random\n\t\t\t42\n\t\t\"\"\"\n\t\tif not isinstance(array, (list, tuple)):\n\t\t\traise TypeError(\"array (=%s) must be a list of lists of Graphics objects\"%(array))\n\t\tarray = list(array)\n\t\tself._glist = []\n\t\tself._rows = len(array)\n\t\tif self._rows > 0:\n\t\t\tif not isinstance(array[0], (list, tuple)):\n\t\t\t\tarray = [array]\n\t\t\t\tself._rows = 1\n\t\t\tself._cols = len(array[0])\n\t\telse:\n\t\t\tself._cols = 0\n\t\tself._dims = self._rows*self._cols\n\t\tfor row in array: #basically flatten the list\n\t\t\tif not isinstance(row, (list, tuple)) or len(row) != self._cols:\n\t\t\t\traise TypeError(\"array (=%s) must be a list of lists of Graphics objects\"%(array))\n\t\t\tfor g in row:\n\t\t\t\tif not isinstance(g, Graphics):\n\t\t\t\t\traise TypeError(\"every element of array must be a Graphics object\")\n\t\t\t\tself._glist.append(g)\n\t\tself._figsize = None\n\n\tdef _repr_(self):\n\t\t\"\"\"\n\t\tRepresentation of the graphics array.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: R = rainbow(6)\n\t\t\tsage: L = [plot(x^n,(x,0,1),color=R[n]) for n in range(6)]\n\t\t\tsage: graphics_array(L,2,3)\n\t\t\tGraphics Array of size 2 x 3\n\t\t\"\"\"\n\t\treturn self.__str__()\n\n\tdef _rich_repr_(self, display_manager, **kwds):\n\t\t\"\"\"\n\t\tRich Output Magic Method\n\n\t\tSee :mod:`sage.repl.rich_output` for details.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: from sage.repl.rich_output import get_display_manager\n\t\t\tsage: dm = get_display_manager()\n\t\t\tsage: g = graphics_array([Graphics(), Graphics()], 1, 2)\n\t\t\tsage: g._rich_repr_(dm)\n\t\t\tOutputImagePng container\n\t\t\"\"\"\n\t\ttypes = display_manager.types\n\t\tprefer_raster = (\n\t\t\t('.png', types.OutputImagePng),\n\t\t\t('.jpg', types.OutputImageJpg),\n\t\t\t('.gif', types.OutputImageGif),\n\t\t)\n\t\tprefer_vector = (\n\t\t\t('.svg', types.OutputImageSvg),\n\t\t\t('.pdf', types.OutputImagePdf),\n\t\t)\n\t\tgraphics = display_manager.preferences.graphics\n\t\tif graphics == 'disable':\n\t\t\treturn\n\t\telif graphics == 'raster' or graphics is None:\n\t\t\tpreferred = prefer_raster + prefer_vector\n\t\telif graphics == 'vector':\n\t\t\tpreferred = prefer_vector + prefer_raster\n\t\telse:\n\t\t\traise ValueError('unknown graphics output preference')\n\t\tfor file_ext, output_container in preferred:\n\t\t\tif output_container in display_manager.supported_output():\n\t\t\t\treturn display_manager.graphics_from_save(\n\t\t\t\t\tself.save, kwds, file_ext, output_container)\n\n\tdef __str__(self):\n\t\t\"\"\"\n\t\tString representation of the graphics array.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: R = rainbow(6)\n\t\t\tsage: L = [plot(x^n,(x,0,1),color=R[n]) for n in range(6)]\n\t\t\tsage: G = graphics_array(L,2,3)\n\t\t\tsage: G.__str__()\n\t\t\t'Graphics Array of size 2 x 3'\n\t\t\tsage: str(G)\n\t\t\t'Graphics Array of size 2 x 3'\n\t\t\"\"\"\n\t\treturn \"Graphics Array of size %s x %s\"%(self._rows, self._cols)\n\n\tdef nrows(self):\n\t\t\"\"\"\n\t\tNumber of rows of the graphics array.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: R = rainbow(6)\n\t\t\tsage: L = [plot(x^n,(x,0,1),color=R[n]) for n in range(6)]\n\t\t\tsage: G = graphics_array(L,2,3)\n\t\t\tsage: G.nrows()\n\t\t\t2\n\t\t\tsage: graphics_array(L).nrows()\n\t\t\t1\n\t\t\"\"\"\n\t\treturn self._rows\n\n\tdef ncols(self):\n\t\t\"\"\"\n\t\tNumber of columns of the graphics array.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: R = rainbow(6)\n\t\t\tsage: L = [plot(x^n,(x,0,1),color=R[n]) for n in range(6)]\n\t\t\tsage: G = graphics_array(L,2,3)\n\t\t\tsage: G.ncols()\n\t\t\t3\n\t\t\tsage: graphics_array(L).ncols()\n\t\t\t6\n\t\t\"\"\"\n\t\treturn self._cols\n\n\tdef __getitem__(self, i):\n\t\t\"\"\"\n\t\tReturn the ``i``th element of the list of graphics\n\t\tin the (flattened) array.\n\n\t\tEXAMPLES:\n\n\t\tWe can access and view individual plots::\n\n\t\t\tsage: M = [[plot(x^2)],[plot(x^3)]]\n\t\t\tsage: H = graphics_array(M)\n\t\t\tsage: H[1]\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tThey can also be represented::\n\n\t\t\tsage: str(H[1])\n\t\t\t'Graphics object consisting of 1 graphics primitive'\n\n\t\tAnother example::\n\n\t\t\tsage: L = [plot(sin(k*x),(x,-pi,pi))+circle((k,k),1,color='red') for k in range(10)]\n\t\t\tsage: G = graphics_array(L,5,2)\n\t\t\tsage: str(G[3])\n\t\t\t'Graphics object consisting of 2 graphics primitives'\n\t\t\tsage: G[3]\n\t\t\tGraphics object consisting of 2 graphics primitives\n\t\t\"\"\"\n\t\ti = int(i)\n\t\treturn self._glist[i]\n\n\tdef __setitem__(self, i, g):\n\t\t\"\"\"\n\t\tSet the ``i``th element of the list of graphics\n\t\tin the (flattened) array.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: M = [[plot(x^2)],[plot(x^3)]]\n\t\t\tsage: H = graphics_array(M)\n\t\t\tsage: str(H[1])\n\t\t\t'Graphics object consisting of 1 graphics primitive'\n\n\t\tWe can check this is one primitive::\n\n\t\t\tsage: H[1] # the plot of x^3\n\t\t\tGraphics object consisting of 1 graphics primitive\n\n\t\tNow we change it::\n\n\t\t\tsage: H[1] = circle((1,1),2)+points([(1,2),(3,2),(5,5)],color='purple')\n\t\t\tsage: str(H[1])\n\t\t\t'Graphics object consisting of 2 graphics primitives'\n\n\t\tAnd we visually check that it's different::\n\n\t\t\tsage: H[1] # a circle and some purple points\n\t\t\tGraphics object consisting of 2 graphics primitives\n\t\t\"\"\"\n\t\ti = int(i)\n\t\tself._glist[i] = g\n\n\tdef _set_figsize_(self, ls):\n\t\t\"\"\"\n\t\tSet the figsize of all plots in the array.\n\n\t\tThis is normally only used via the ``figsize`` keyword in\n\t\t:meth:`save` or :meth:`show`.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: L = [plot(sin(k*x),(x,-pi,pi)) for k in [1..3]]\n\t\t\tsage: G = graphics_array(L)\n\t\t\tsage: G.show(figsize=[5,3])  # smallish and compact\n\n\t\t::\n\n\t\t\tsage: G.show(figsize=[10,20])  # bigger and tall and thin; long time (2s on sage.math, 2012)\n\n\t\t::\n\n\t\t\tsage: G.show(figsize=8)  # figure as a whole is a square\n\t\t\"\"\"\n\t\t# if just one number is passed in for figsize, as documented\n\t\tif not isinstance(ls,list):\n\t\t\tls = [ls,ls]\n\t\t# now the list is a list\n\t\tm = int(ls[0])\n\t\tn = int(ls[1])\n\t\tself._figsize = [m,n]\n\n\tdef __len__(self):\n\t\t\"\"\"\n\t\tTotal number of elements of the graphics array.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: R = rainbow(6)\n\t\t\tsage: L = [plot(x^n,(x,0,1),color=R[n]) for n in range(6)]\n\t\t\tsage: G = graphics_array(L,2,3)\n\t\t\tsage: G.ncols()\n\t\t\t3\n\t\t\tsage: graphics_array(L).ncols()\n\t\t\t6\n\t\t\"\"\"\n\t\treturn len(self._glist)\n\n\tdef append(self, g):\n\t\t\"\"\"\n\t\tAppends a graphic to the array.  Currently\n\t\tnot implemented.\n\n\t\tTESTS::\n\n\t\t\tsage: from sage.plot.graphics import GraphicsArray\n\t\t\tsage: G = GraphicsArray([plot(sin),plot(cos)])\n\t\t\tsage: G.append(plot(tan))\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tNotImplementedError: Appending to a graphics array is not yet implemented\n\t\t\"\"\"\n\t\t# Not clear if there is a way to do this\n\t\traise NotImplementedError('Appending to a graphics array is not yet implemented')\n\n\tdef save(self, filename=None, dpi=DEFAULT_DPI, figsize=None, axes=None,\n\t\t\t **kwds):\n\t\tr\"\"\"\n\t\tSave the graphics array.\n\n\t\tINPUT:\n\n\t\t- ``filename`` -- string. The filename and the image format\n\t\t  given by the extension, which can be one of the following:\n\n\t\t\t* ``.eps``,\n\n\t\t\t* ``.pdf``,\n\n\t\t\t* ``.png``,\n\n\t\t\t* ``.ps``,\n\n\t\t\t* ``.sobj`` (for a Sage object you can load later),\n\n\t\t\t* ``.svg``,\n\n\t\t\t* empty extension will be treated as ``.sobj``.\n\n\t\t-  ``dpi`` - dots per inch\n\n\t\t-  ``figsize`` - width or [width, height] See documentation\n\t\t   for :meth:`sage.plot.graphics.Graphics.show` for more details.\n\n\t\t-  ``axes`` - (default: True)\n\n\t\tEXAMPLES::\n\n\t\t\tsage: F = tmp_filename(ext='.png')\n\t\t\tsage: L = [plot(sin(k*x),(x,-pi,pi)) for k in [1..3]]\n\t\t\tsage: G = graphics_array(L)\n\t\t\tsage: G.save(F, dpi=500, axes=False)  # long time (6s on sage.math, 2012)\n\n\t\tTESTS::\n\n\t\t\tsage: graphics_array([]).save(F)\n\t\t\tsage: graphics_array([[]]).save(F)\n\t\t\"\"\"\n\t\tif figsize is not None:\n\t\t\tself._set_figsize_(figsize)\n\t\tif filename is None:\n\t\t\tfrom sage.misc.superseded import deprecation\n\t\t\tdeprecation(17234,'the filename argument is now mandatory')\n\t\t\tfrom sage.misc.temporary_file import graphics_filename\n\t\t\tfilename = graphics_filename()\n\n\t\t#glist is a list of Graphics objects:\n\t\tglist = self._glist\n\t\trows = self._rows\n\t\tcols = self._cols\n\t\tdims = self._dims\n\t\tif rows == 0 or cols == 0:\n\t\t\tglist = [Graphics()]\n\t\t\trows = cols = dims = 1\n\t\t#make a blank matplotlib Figure:\n\t\tfrom matplotlib.figure import Figure\n\t\tfigure = Figure(self._figsize)\n\t\tglobal do_verify\n\t\tdo_verify = True\n\t\tfor i,g in zip(range(1, dims+1), glist):\n\t\t\tsubplot = figure.add_subplot(rows, cols, i)\n\t\t\tg.matplotlib(filename, figure=figure, sub=subplot,\n\t\t\t\t\t\t verify=do_verify, axes = axes, **kwds)\n\t\tg.save(filename, dpi=dpi, figure=figure, sub=subplot,\n\t\t\t   verify=do_verify, axes=axes, **kwds)\n\n\tdef save_image(self, filename=None, *args, **kwds):\n\t\tr\"\"\"\n\t\tSave an image representation of self.  The image type is\n\t\tdetermined by the extension of the filename.  For example,\n\t\tthis could be ``.png``, ``.jpg``, ``.gif``, ``.pdf``,\n\t\t``.svg``.  Currently this is implemented by calling the\n\t\t:meth:`save` method of self, passing along all arguments and\n\t\tkeywords.\n\n\t\t.. Note::\n\n\t\t\tNot all image types are necessarily implemented for all\n\t\t\tgraphics types.  See :meth:`save` for more details.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: plots = [[plot(m*cos(x + n*pi/4), (x,0, 2*pi)) for n in range(3)] for m in range(1,3)]\n\t\t\tsage: G = graphics_array(plots)\n\t\t\tsage: G.save_image(tmp_filename(ext='.png'))\n\t\t\"\"\"\n\t\tself.save(filename, *args, **kwds)\n\n\tdef show(self, **kwds):\n\t\tr\"\"\"\n\t\tShow this graphics array immediately.\n\n\t\tThis method attempts to display the graphics immediately,\n\t\twithout waiting for the currently running code (if any) to\n\t\treturn to the command line. Be careful, calling it from within\n\t\ta loop will potentially launch a large number of external\n\t\tviewer programs.\n\n\t\tOPTIONAL INPUT:\n\n\t\t-  ``dpi`` - dots per inch\n\n\t\t-  ``figsize`` - width or [width, height]  See the\n\t\t   documentation for :meth:`sage.plot.graphics.Graphics.show`\n\t\t   for more information.\n\n\t\t-  ``axes`` - (default: True)\n\n\t\t-  ``fontsize`` - positive integer\n\n\t\t-  ``frame`` - (default: False) draw a frame around the\n\t\t   image\n\n\t\tOUTPUT:\n\n\t\tThis method does not return anything. Use :meth:`save` if you\n\t\twant to save the figure as an image.\n\n\t\tEXAMPLES:\n\n\t\tThis draws a graphics array with four trig plots and no\n\t\taxes in any of the plots::\n\n\t\t\tsage: G = graphics_array([[plot(sin), plot(cos)], [plot(tan), plot(sec)]])\n\t\t\tsage: G.show(axes=False)\n\t\t\"\"\"\n\t\tfrom sage.repl.rich_output import get_display_manager\n\t\tdm = get_display_manager()\n\t\tdm.display_immediately(self, **kwds)\n", "description": "\n\tGraphicsArray takes a (`m` x `n`) list of lists of\n\tgraphics objects and plots them all on one canvas.\n\n\t.. automethod:: _rich_repr_\n\t", "category": "graphics", "imports": ["import os", "from math import isnan", "import sage.misc.misc", "from sage.misc.html import html", "from sage.misc.temporary_file import tmp_filename", "from sage.misc.fast_methods import WithEqualityById", "from sage.structure.sage_object import SageObject", "from sage.misc.decorators import suboptions", "from colors import rgbcolor", "\tfrom sage.misc.superseded import deprecation", "\timport sage.doctest", "\t\tsage: from sage.plot.graphics import is_Graphics", "\t\t\tsage: from sage.repl.rich_output import get_display_manager", "\t\tfrom sage.plot.primitive import GraphicPrimitive", "\t\t\tfrom sage.plot.plot3d.base import Graphics3d", "\t\t\tsage: from sage.plot.line import Line", "\t\t\tsage: from sage.plot.arrow import Arrow", "\t\tfrom sage.plot.plot3d.base import Graphics3dGroup", "\t\t  locators, type ``from matplotlib import ticker`` and then", "\t\t  formatters, type ``from matplotlib import ticker`` and then", "\t\t\tfrom sage.misc.superseded import deprecation", "\t\t\t\tfrom sage.misc.temporary_file import graphics_filename", "\t\tfrom sage.repl.rich_output import get_display_manager", "\t\t\tsage: from matplotlib.figure import Figure", "\t\tfrom matplotlib.ticker import (FixedLocator, Locator,", "\t\t\tfrom sage.functions.other import ceil, floor", "\t\t\tfrom sage.functions.other import ceil, floor", "\t\tfrom matplotlib.ticker import FuncFormatter, FixedFormatter", "\t\tfrom sage.misc.latex import latex", "\t\tfrom sage.symbolic.ring import SR", "\t\t\tfrom misc import _multiple_of_constant", "\t\t\tfrom misc import _multiple_of_constant", "\t\tfrom warnings import warn", "\t\timport math", "\t\tfrom sage.symbolic.ring import SR", "\t\tfrom matplotlib.figure import Figure", "\t\tfrom matplotlib import rcParams", "\t\t\tfrom matplotlib.font_manager import FontProperties", "\t\t\t\tfrom sage.plot.colors import to_mpl_color", "\t\t\t\tfrom sage.plot.plot import SelectiveFormatter", "\t\t\tfrom matplotlib.ticker import NullFormatter, NullLocator", "\t\t\tfrom matplotlib.ticker import (AutoMinorLocator, FixedLocator,", "\t\t\t\tfrom sage.misc.misc import srange", "\t\t\t\tfrom sage.misc.misc import srange", "\t\t\t\tfrom matplotlib.transforms import offset_copy", "\t\t\tfrom sage.misc.superseded import deprecation", "\t\t\tfrom sage.misc.temporary_file import graphics_filename", "\t\t\tfrom matplotlib import rcParams", "\t\t\tfrom matplotlib.backends.backend_agg import FigureCanvasAgg", "\t\t\tsage: from sage.repl.rich_output import get_display_manager", "\t\t\tsage: from sage.plot.graphics import GraphicsArray", "\t\t\tfrom sage.misc.superseded import deprecation", "\t\t\tfrom sage.misc.temporary_file import graphics_filename", "\t\tfrom matplotlib.figure import Figure", "\t\tfrom sage.repl.rich_output import get_display_manager"]}], [{"term": "class", "name": "classAnimationPlayer:\r", "data": "class AnimationPlayer:\r\n\tdef __init__(self):\r\n\t\tself.frames = {\r\n\t\t\t# magic\r\n\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\r\n\t\t\t'aura': import_folder('../graphics/particles/aura'),\r\n\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\r\n\t\t\t\r\n\t\t\t# attacks \r\n\t\t\t'claw': import_folder('../graphics/particles/claw'),\r\n\t\t\t'slash': import_folder('../graphics/particles/slash'),\r\n\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\r\n\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\r\n\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\r\n\r\n\t\t\t# monster deaths\r\n\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\r\n\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\r\n\t\t\t'spirit': import_folder('../graphics/particles/nova'),\r\n\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\r\n\t\t\t\r\n\t\t\t# leafs \r\n\t\t\t'leaf': (\r\n\t\t\t\timport_folder('../graphics/particles/leaf1'),\r\n\t\t\t\timport_folder('../graphics/particles/leaf2'),\r\n\t\t\t\timport_folder('../graphics/particles/leaf3'),\r\n\t\t\t\timport_folder('../graphics/particles/leaf4'),\r\n\t\t\t\timport_folder('../graphics/particles/leaf5'),\r\n\t\t\t\timport_folder('../graphics/particles/leaf6'),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\r\n\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\r\n\tdef reflect_images(self,frames):\r\n\t\tnew_frames = []\r\n\r\n\t\tfor frame in frames:\r\n\t \t\tflipped_frame = pygame.transform.flip(frame,True,False)\r\n\t \t\tnew_frames.append(flipped_frame)\r\n\t\treturn new_frames\r\n\r\n\tdef create_grass_particles(self,pos,groups):\r\n\t \tanimation_frames = choice(self.frames['leaf'])\r\n\t \tParticleEffect(pos,animation_frames,groups)\r\n\r\n\tdef create_particles(self,animation_type,pos,groups):\r\n\t\tanimation_frames = self.frames[animation_type]\r\n\t\tParticleEffect(pos,animation_frames,groups)\r\n\r\n", "description": null, "category": "graphics", "imports": ["import pygame\r", "from support import import_folder\r", "from random import choice\r", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\r", "\t\t\t'aura': import_folder('../graphics/particles/aura'),\r", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\r", "\t\t\t'claw': import_folder('../graphics/particles/claw'),\r", "\t\t\t'slash': import_folder('../graphics/particles/slash'),\r", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\r", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\r", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\r", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\r", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\r", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),\r", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf1'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf2'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf3'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf4'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf5'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf6'),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\r"]}, {"term": "class", "name": "ParticleEffect", "data": "class ParticleEffect(pygame.sprite.Sprite):\r\n\tdef __init__(self,pos,animation_frames,groups):\r\n\t\tsuper().__init__(groups)\r\n\t\tself.sprite_type = 'magic'\r\n\t\tself.frame_index = 0\r\n\t\tself.animation_speed = 0.15\r\n\t\tself.frames = animation_frames\r\n\t\tself.image = self.frames[self.frame_index]\r\n\t\tself.rect = self.image.get_rect(center = pos)\r\n\r\n\tdef animate(self):\r\n\t\tself.frame_index += self.animation_speed\r\n\t\tif self.frame_index >= len(self.frames):\r\n\t\t\tself.kill()\r\n\t\telse:\r\n\t\t\tself.image = self.frames[int(self.frame_index)]\r\n\r\n\tdef update(self):\r\n\t\tself.animate()\r\n", "description": null, "category": "graphics", "imports": ["import pygame\r", "from support import import_folder\r", "from random import choice\r", "\t\t\t'flame': import_folder('../graphics/particles/flame/frames'),\r", "\t\t\t'aura': import_folder('../graphics/particles/aura'),\r", "\t\t\t'heal': import_folder('../graphics/particles/heal/frames'),\r", "\t\t\t'claw': import_folder('../graphics/particles/claw'),\r", "\t\t\t'slash': import_folder('../graphics/particles/slash'),\r", "\t\t\t'sparkle': import_folder('../graphics/particles/sparkle'),\r", "\t\t\t'leaf_attack': import_folder('../graphics/particles/leaf_attack'),\r", "\t\t\t'thunder': import_folder('../graphics/particles/thunder'),\r", "\t\t\t'squid': import_folder('../graphics/particles/smoke_orange'),\r", "\t\t\t'raccoon': import_folder('../graphics/particles/raccoon'),\r", "\t\t\t'spirit': import_folder('../graphics/particles/nova'),\r", "\t\t\t'bamboo': import_folder('../graphics/particles/bamboo'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf1'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf2'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf3'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf4'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf5'),\r", "\t\t\t\timport_folder('../graphics/particles/leaf6'),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf1')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf2')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf3')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf4')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf5')),\r", "\t\t\t\tself.reflect_images(import_folder('../graphics/particles/leaf6'))\r"]}], [{"term": "def", "name": "main", "data": "def main():\n\t\"\"\"\n\tThis program run a breakout game by object constructed by BreakoutGraphics class\n\t\"\"\"\n\tnum = NUM_LIVES\n\tanimation(num)\n\n", "description": "\n\tThis program run a breakout game by object constructed by BreakoutGraphics class\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "import random as r"]}, {"term": "def", "name": "animation", "data": "def animation(n):\n\t\"\"\"start to move the ball\n\n\t a series of conditional statements make sure the program run within the constrain\n\n\t deviation increase the difficulty by randomly change the dx and dy\n\n\t:param n: trace the number of attempts left\n\t\"\"\"\n\tnum = n\n\twhile True:\n\t\tpause(FRAME_RATE)\n\t\tif graphics.t and num >0:\n\t\t\t# move the ball\n\t\t\tgraphics.ball.move(graphics.getter_dx(), graphics.getter_dy())\n\n\t\t\t# check if the ball go off the boundary\n\t\t\tif graphics.ball.y + graphics.ball.height >= graphics.window.height:\n\t\t\t\tnum = num - 1\n\t\t\t\treset(num)\n\n\t\t\t# collision check\n\t\t\tcol = check_collision(graphics.ball.x, graphics.ball.y)\n\t\t\tif col:\n\t\t\t\t# include deviation so that the ball won't follow the original trajectory\n\t\t\t\tdeviation = r.randint(-2, 3)\n\t\t\t\tdeviation_y = r.randint(-1, 2)\n\t\t\t\tgraphics.setter_dx(-1, dev=deviation)\n\t\t\t\tgraphics.setter_dy(-1, dev=deviation_y)\n\n\t\t\t# wall rebound check-x\n\t\t\tif (graphics.ball.x + graphics.ball.width >= graphics.window.width\n\t\t\t\t\tor graphics.ball.x <= 0):\n\t\t\t\tgraphics.setter_dx(-1)\n\n\t\t\t# wall rebound check-y\n\t\t\tif graphics.ball.y <= 0:\n\t\t\t\tgraphics.setter_dy(-1)\n\n\t\t\t# paddle rebound check\n\t\t\tif (graphics.ball.y + graphics.ball.height >= graphics.paddle.y\n\t\t\t\t\tand graphics.paddle.x <= graphics.ball.x <= graphics.paddle.x + graphics.paddle.width):\n\t\t\t\tgraphics.setter_dy(-1)\n\n", "description": "start to move the ball\n\n\t a series of conditional statements make sure the program run within the constrain\n\n\t deviation increase the difficulty by randomly change the dx and dy\n\n\t:param n: trace the number of attempts left\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "import random as r"]}, {"term": "def", "name": "check_collision", "data": "def check_collision(xcord, ycord):\n\t\"\"\"check if the collision occur\n\n\tboolean det determine if collision occur\n\n\tdouble for loops traverse the position around the ball\n\n\tr*0.5 interval sets more sensor around the ball\n\n\t:param xcord: pass the x-coordinate of the ball\n\t:param ycord: pass the y-coordinate of the ball\n\t\"\"\"\n\tr = graphics.ball.r\n\tdefault_xcord = int(xcord - r)\n\tdefault_ycord = int(ycord - r)\n\tdet = False\n\tfor i in range(-r, r + 1, int(r*0.5)):\n\t\tfor j in range(-r, r + 1, int(r*0.5)):\n\t\t\ttarget_object = graphics.window.get_object_at(default_xcord + i, default_ycord + j)\n\t\t\tif target_object is not None and target_object is not graphics.attempt_label:\n\t\t\t\tgraphics.window.remove(target_object)\n\t\t\t\tdet = True\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tcontinue\n\treturn det\n\n", "description": "check if the collision occur\n\n\tboolean det determine if collision occur\n\n\tdouble for loops traverse the position around the ball\n\n\tr*0.5 interval sets more sensor around the ball\n\n\t:param xcord: pass the x-coordinate of the ball\n\t:param ycord: pass the y-coordinate of the ball\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "import random as r"]}, {"term": "def", "name": "reset", "data": "def reset(num):\n\t\"\"\"reset the ball to the original position and inactivate the graphics.t\n\n\treset the graphics.t, so that the program would start after the mouse click\n\n\tanimation() functionpull the program back to the while loop\n\n\t:param num: pass the attempts left\n\t\"\"\"\n\tgraphics.window.add(graphics.ball, x=(graphics.window_width - graphics.ball.r * 2) / 2, y=(\n\t\t\t\t\t\t\tgraphics.window_height - graphics.ball.r * 2) / 2)\n\tgraphics.t = False\n\tgraphics.reset_speed()\n\tgraphics.attempt_label.text = 'Turns left: ' + str(num)\n\tanimation(num)\n\n", "description": "reset the ball to the original position and inactivate the graphics.t\n\n\treset the graphics.t, so that the program would start after the mouse click\n\n\tanimation() functionpull the program back to the while loop\n\n\t:param num: pass the attempts left\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "import random as r"]}], [{"term": "class", "name": "graphics_Gbm", "data": "class graphics_Gbm(graphics_utils.GraphicsTest):\n\t\"\"\"\n\tTest the gbm implementation.\n\t\"\"\"\n\tversion = 1\n\tpreserve_srcdir = True\n\n\tdef setup(self):\n\t\tos.chdir(self.srcdir)\n\t\tutils.make('clean')\n\t\tutils.make('all')\n\n\tdef initialize(self):\n\t\tsuper(graphics_Gbm, self).initialize()\n\n\tdef cleanup(self):\n\t\tsuper(graphics_Gbm, self).cleanup()\n\n\t@graphics_utils.GraphicsTest.failure_report_decorator('graphics_Gbm')\n\tdef run_once(self):\n\t\tcmd = os.path.join(self.srcdir, 'gbmtest')\n\t\tresult = utils.run(cmd,\n\t\t\t\t\t\t   stderr_is_expected=False,\n\t\t\t\t\t\t   stdout_tee=utils.TEE_TO_LOGS,\n\t\t\t\t\t\t   stderr_tee=utils.TEE_TO_LOGS,\n\t\t\t\t\t\t   ignore_status=True)\n\t\treport = re.findall(r'\\[  PASSED  \\]', result.stdout)\n\t\tif not report:\n\t\t\traise error.TestFail('Failed: Gbm test failed (' + result.stdout +\n\t\t\t\t\t\t\t\t ')')\n", "description": "\n\tTest the gbm implementation.\n\t", "category": "graphics", "imports": ["import os, re", "from autotest_lib.client.bin import test", "from autotest_lib.client.common_lib import error, utils", "from autotest_lib.client.cros.graphics import graphics_utils"]}], [], [], [{"term": "def", "name": "get_image", "data": "def get_image(path):\n\tglobal _image_library\n\timage = _image_library.get(path)\n\tif image == None:\n\t\tcanonicalized_path = path.replace('/', os.sep).replace('\\\\', os.sep)\n\t\timage = pygame.image.load(canonicalized_path)\n\t\t_image_library[path] = image\n\treturn image\n\n", "description": null, "category": "graphics", "imports": ["import pygame", "from multi_harvest_zoo.multi_harvest_world.world_objects import *", "from multi_harvest_zoo.misc.game.utils import *", "from collections import defaultdict, namedtuple", "import numpy as np", "import pathlib", "import os.path", "import math"]}, {"term": "class", "name": "classGraphicPipeline:", "data": "class GraphicPipeline:\n\n\tPIXEL_PER_TILE = 80\n\tHOLDING_SCALE = 0.5\n\tCONTAINER_SCALE = 0.7\n\n\tdef __init__(self, env, display=False):\n\t\tself.env = env\n\t\tself.display = display\n\t\tself.screen = None\n\t\tself.graphics_dir = 'misc/game/graphics'\n\t\tself.graphics_properties = GraphicsProperties(self.PIXEL_PER_TILE, self.HOLDING_SCALE, self.CONTAINER_SCALE,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  self.PIXEL_PER_TILE * self.env.unwrapped.world.width,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  self.PIXEL_PER_TILE * self.env.unwrapped.world.height,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (self.PIXEL_PER_TILE, self.PIXEL_PER_TILE),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (self.PIXEL_PER_TILE * self.HOLDING_SCALE,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   self.PIXEL_PER_TILE * self.HOLDING_SCALE),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (self.PIXEL_PER_TILE * self.CONTAINER_SCALE,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   self.PIXEL_PER_TILE * self.CONTAINER_SCALE),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (self.PIXEL_PER_TILE * self.CONTAINER_SCALE * self.HOLDING_SCALE,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   self.PIXEL_PER_TILE * self.CONTAINER_SCALE * self.HOLDING_SCALE))\n\t\tmy_path = os.path.realpath(__file__)\n\t\tdir_name = os.path.dirname(my_path)\n\t\tpath = pathlib.Path(dir_name)\n\t\tself.root_dir = path.parent.parent\n\n\tdef on_init(self):\n\t\tif self.display:\n\t\t\tself.screen = pygame.display.set_mode((self.graphics_properties.width_pixel,\n\t\t\t\t\t\t\t\t\t\t\t\t   self.graphics_properties.height_pixel))\n\t\telse:\n\t\t\t# Create a hidden surface\n\t\t\tself.screen = pygame.Surface((self.graphics_properties.width_pixel, self.graphics_properties.height_pixel))\n\t\tself.screen = self.screen\n\t\treturn True\n\n\tdef on_render(self):\n\t\tself.screen.fill(Color.FLOOR)\n\n\t\tself.draw_static_objects()\n\n\t\tself.draw_agents()\n\n\t\tself.draw_dynamic_objects()\n\n\t\tself.draw_beam()\n\n\t\tif self.display:\n\t\t\tpygame.display.flip()\n\t\t\tpygame.display.update()\n\n\tdef draw_square(self):\n\t\tpass\n\n\tdef draw_beam(self):\n\t\tfor location in self.env.unwrapped.world.marked_squares:\n\t\t\tsl = self.scaled_location(location)\n\t\t\trect = pygame.Rect(sl[0], sl[1], self.graphics_properties.pixel_per_tile,\n\t\t\t\t\t\t\t   self.graphics_properties.pixel_per_tile)\n\t\t\tcolor = (0, 0, 255, 127)\n\t\t\tself.draw_rect_alpha(color, rect)\n\n\tdef draw_rect_alpha(self, color, rect):\n\t\tshape_surf = pygame.Surface(pygame.Rect(rect).size, pygame.SRCALPHA)\n\t\tpygame.draw.rect(shape_surf, color, shape_surf.get_rect())\n\t\tself.screen.blit(shape_surf, rect)\n\n\tdef draw_static_objects(self):\n\t\tobjects = self.env.unwrapped.world.get_object_list()\n\t\tstatic_objects = [obj for obj in objects if isinstance(obj, StaticObject)]\n\t\tfor static_object in static_objects:\n\t\t\tself.draw_static_object(static_object)\n\n\tdef draw_static_object(self, static_object: StaticObject):\n\t\tsl = self.scaled_location(static_object.location)\n\t\tfill = pygame.Rect(sl[0], sl[1], self.graphics_properties.pixel_per_tile,\n\t\t\t\t\t\t   self.graphics_properties.pixel_per_tile)\n\t\tif isinstance(static_object, Counter):\n\t\t\tpygame.draw.rect(self.screen, Color.COUNTER, fill)\n\t\t\tpygame.draw.rect(self.screen, Color.COUNTER_BORDER, fill, 1)\n\n\tdef draw_dynamic_objects(self):\n\t\tobjects = self.env.unwrapped.world.get_object_list()\n\t\tdynamic_objects = [obj for obj in objects if isinstance(obj, DynamicObject)]\n\t\tdynamic_objects_grouped = defaultdict(list)\n\t\tfor obj in dynamic_objects:\n\t\t\tdynamic_objects_grouped[obj.location].append(obj)\n\t\tfor location, obj_list in dynamic_objects_grouped.items():\n\t\t\tself.draw_dynamic_object_stack(obj_list, self.graphics_properties.tile_size, self.scaled_location(location))\n\n\tdef draw_dynamic_object_stack(self, dynamic_objects, base_size, base_location):\n\t\tself.draw_food_stack(dynamic_objects, base_size, base_location)\n\n\tdef draw_agents(self):\n\t\tfor agent in self.env.unwrapped.world.agents:\n\t\t\tself.draw('agent-{}'.format(agent.color), self.graphics_properties.tile_size,\n\t\t\t\t\t  self.scaled_location(agent.location))\n\t\t\tif agent.orientation == 1:\n\t\t\t\tfile_name = \"arrow_left\"\n\t\t\t\tlocation = self.scaled_location(agent.location)\n\t\t\t\tlocation = (location[0], location[1] + self.graphics_properties.tile_size[1] // 4)\n\t\t\t\tsize = (self.graphics_properties.tile_size[0] // 4, self.graphics_properties.tile_size[1] // 4)\n\t\t\telif agent.orientation == 2:\n\t\t\t\tfile_name = \"arrow_right\"\n\t\t\t\tlocation = self.scaled_location(agent.location)\n\t\t\t\tlocation = (location[0] + 3 * self.graphics_properties.tile_size[0] // 4,\n\t\t\t\t\t\t\tlocation[1] + self.graphics_properties.tile_size[1] // 4)\n\t\t\t\tsize = (self.graphics_properties.tile_size[0] // 4, self.graphics_properties.tile_size[1] // 4)\n\t\t\telif agent.orientation == 3:\n\t\t\t\tfile_name = \"arrow_down\"\n\t\t\t\tlocation = self.scaled_location(agent.location)\n\t\t\t\tlocation = (location[0] + self.graphics_properties.tile_size[0] // 4,\n\t\t\t\t\t\t\tlocation[1] + 3 * self.graphics_properties.tile_size[1] // 4)\n\t\t\t\tsize = (self.graphics_properties.tile_size[0] // 4, self.graphics_properties.tile_size[1] // 4)\n\t\t\telif agent.orientation == 4:\n\t\t\t\tfile_name = \"arrow_up\"\n\t\t\t\tlocation = self.scaled_location(agent.location)\n\t\t\t\tlocation = (location[0] + self.graphics_properties.tile_size[0] // 4, location[1])\n\t\t\t\tsize = (self.graphics_properties.tile_size[0] // 4, self.graphics_properties.tile_size[1] // 4)\n\t\t\telse:\n\t\t\t\traise ValueError(f\"Agent orientation invalid ({agent.orientation})\")\n\t\t\tself.draw(file_name, size, location)\n\n\tdef draw(self, path, size, location):\n\t\timage_path = f'{self.root_dir}/{self.graphics_dir}/{path}.png'\n\t\timage = pygame.transform.scale(get_image(image_path), (int(size[0]), int(size[1])))\n\t\tself.screen.blit(image, location)\n\n\tdef draw_food_stack(self, dynamic_objects, base_size, base_loc):\n\t\ttiles = int(math.floor(math.sqrt(len(dynamic_objects) - 1)) + 1)\n\t\tsize = (base_size[0] // tiles, base_size[1] // tiles)\n\t\tfor idx, obj in enumerate(dynamic_objects):\n\t\t\tlocation = (base_loc[0] + size[0] * (idx % tiles), base_loc[1] + size[1] * (idx // tiles))\n\t\t\tself.draw(obj.file_name(), size, location)\n\n\tdef scaled_location(self, loc):\n\t\t\"\"\"Return top-left corner of scaled location given coordinates loc, e.g. (3, 4)\"\"\"\n\t\treturn tuple(self.graphics_properties.pixel_per_tile * np.asarray(loc))\n\n\tdef holding_location(self, loc):\n\t\t\"\"\"Return top-left corner of location where agent holding will be drawn (bottom right corner)\n\t\tgiven coordinates loc, e.g. (3, 4)\"\"\"\n\t\tscaled_loc = self.scaled_location(loc)\n\t\treturn tuple((np.asarray(scaled_loc) + self.graphics_properties.pixel_per_tile *\n\t\t\t\t\t  (1 - self.HOLDING_SCALE)).astype(int))\n\n\tdef container_location(self, loc):\n\t\t\"\"\"Return top-left corner of location where contained (i.e. plated) object will be drawn,\n\t\tgiven coordinates loc, e.g. (3, 4)\"\"\"\n\t\tscaled_loc = self.scaled_location(loc)\n\t\treturn tuple((np.asarray(scaled_loc) + self.graphics_properties.pixel_per_tile *\n\t\t\t\t\t  (1 - self.CONTAINER_SCALE) / 2).astype(int))\n\t\n\tdef holding_container_location(self, loc):\n\t\t\"\"\"Return top-left corner of location where contained, held object will be drawn\n\t\tgiven coordinates loc, e.g. (3, 4)\"\"\"\n\t\tscaled_loc = self.scaled_location(loc)\n\t\tfactor = (1 - self.HOLDING_SCALE) + (1 - self.CONTAINER_SCALE) / 2 * self.HOLDING_SCALE\n\t\treturn tuple((np.asarray(scaled_loc) + self.graphics_properties.pixel_per_tile * factor).astype(int))\n\n\tdef get_image_obs(self):\n\t\tself.on_render()\n\t\timg_int = pygame.PixelArray(self.screen)\n\t\timg_rgb = np.zeros([img_int.shape[1], img_int.shape[0], 3], dtype=np.uint8)\n\t\tfor i in range(img_int.shape[0]):\n\t\t\tfor j in range(img_int.shape[1]):\n\t\t\t\tcolor = pygame.Color(img_int[i][j])\n\t\t\t\timg_rgb[j, i, 0] = color.g\n\t\t\t\timg_rgb[j, i, 1] = color.b\n\t\t\t\timg_rgb[j, i, 2] = color.r\n\t\treturn img_rgb\n\n\tdef save_image_obs(self, t):\n\t\tgame_record_dir = 'misc/game/record/example/'\n\t\tself.on_render()\n\t\tpygame.image.save(self.screen, '{}/t={:03d}.png'.format(game_record_dir, t))\n", "description": "Return top-left corner of scaled location given coordinates loc, e.g. (3, 4)", "category": "graphics", "imports": ["import pygame", "from multi_harvest_zoo.multi_harvest_world.world_objects import *", "from multi_harvest_zoo.misc.game.utils import *", "from collections import defaultdict, namedtuple", "import numpy as np", "import pathlib", "import os.path", "import math"]}], [], [{"term": "def", "name": "darken", "data": "def darken(color, factor=0.7):\n\t\"\"\"Returns darkened color as a ReportLab RGB color.\n\n\tTake a passed color and returns a Reportlab color that is darker by the\n\tfactor indicated in the parameter.\n\t\"\"\"\n\tnewcol = color_to_reportlab(color)\n\tfor a in ['red', 'green', 'blue']:\n\t\tsetattr(newcol, a, factor * getattr(newcol, a))\n\treturn newcol\n\n", "description": "Returns darkened color as a ReportLab RGB color.\n\n\tTake a passed color and returns a Reportlab color that is darker by the\n\tfactor indicated in the parameter.\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from itertools import chain", "from io import BytesIO", "from reportlab.lib import pagesizes", "from reportlab.lib import colors", "from reportlab.lib.utils import ImageReader", "from reportlab.graphics.shapes import *", "from reportlab.pdfgen import canvas", "from PIL import Image", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "def", "name": "color_to_reportlab", "data": "def color_to_reportlab(color):\n\t\"\"\"Returns the passed color in Reportlab Color format.\n\n\tWe allow colors to be specified as hex values, tuples, or Reportlab Color\n\tobjects, and with or without an alpha channel. This function acts as a\n\tRosetta stone for conversion of those formats to a Reportlab Color\n\tobject, with alpha value.\n\n\tAny other color specification is returned directly\n\t\"\"\"\n\t# Reportlab Color objects are in the format we want already\n\tif isinstance(color, colors.Color):\n\t\treturn color\n\telif isinstance(color, str):  # String implies hex color\n\t\tif color.startswith(\"0x\"):  # Standardise to octothorpe\n\t\t\tcolor.replace(\"0x\", \"#\")\n\t\tif len(color) == 7:\n\t\t\treturn colors.HexColor(color)\n\t\telse:\n\t\t\ttry:\n\t\t\t\treturn colors.HexColor(color, hasAlpha=True)\n\t\t\texcept TypeError:  # Catch pre-2.7 Reportlab\n\t\t\t\traise RuntimeError(\"Your reportlab seems to be too old, try 2.7 onwards\")\n\telif isinstance(color, tuple):  # Tuple implies RGB(alpha) tuple\n\t\treturn colors.Color(*color)\n\treturn color\n\n", "description": "Returns the passed color in Reportlab Color format.\n\n\tWe allow colors to be specified as hex values, tuples, or Reportlab Color\n\tobjects, and with or without an alpha channel. This function acts as a\n\tRosetta stone for conversion of those formats to a Reportlab Color\n\tobject, with alpha value.\n\n\tAny other color specification is returned directly\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from itertools import chain", "from io import BytesIO", "from reportlab.lib import pagesizes", "from reportlab.lib import colors", "from reportlab.lib.utils import ImageReader", "from reportlab.graphics.shapes import *", "from reportlab.pdfgen import canvas", "from PIL import Image", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "def", "name": "get_temp_imagefilename", "data": "def get_temp_imagefilename(url):\n\t\"\"\"Returns filename of temporary file containing downloaded image.\n\n\tCreate a new temporary file to hold the image file at the passed URL\n\tand return the filename.\n\t\"\"\"\n\timg = _urlopen(url).read()\n\tim = Image.open(BytesIO(img))\n\t# im.transpose(Image.FLIP_TOP_BOTTOM)\n\tf = tempfile.NamedTemporaryFile(delete=False, suffix='.png')\n\tfname = f.name\n\tf.close()\n\tim.save(fname, 'PNG')\n\treturn fname\n\n", "description": "Returns filename of temporary file containing downloaded image.\n\n\tCreate a new temporary file to hold the image file at the passed URL\n\tand return the filename.\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from itertools import chain", "from io import BytesIO", "from reportlab.lib import pagesizes", "from reportlab.lib import colors", "from reportlab.lib.utils import ImageReader", "from reportlab.graphics.shapes import *", "from reportlab.pdfgen import canvas", "from PIL import Image", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "class", "name": "KGMLCanvas", "data": "class KGMLCanvas(object):\n\t\"\"\"Reportlab Canvas-based representation of a KGML pathway map.\"\"\"\n\n\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,\n\t\t\t\t label_orthologs=True, label_reaction_entries=True,\n\t\t\t\t label_maps=True, show_maps=False, fontname='Helvetica',\n\t\t\t\t fontsize=6, draw_relations=True, show_orthologs=True,\n\t\t\t\t show_compounds=True, show_genes=True,\n\t\t\t\t show_reaction_entries=True, margins=(0.02, 0.02)):\n\t\tself.pathway = pathway\n\t\tself.show_maps = show_maps\n\t\tself.show_orthologs = show_orthologs\n\t\tself.show_compounds = show_compounds\n\t\tself.show_genes = show_genes\n\t\tself.show_reaction_entries = show_reaction_entries\n\t\tself.label_compounds = label_compounds\n\t\tself.label_orthologs = label_orthologs\n\t\tself.label_reaction_entries = label_reaction_entries\n\t\tself.label_maps = label_maps\n\t\tself.fontname = fontname\n\t\tself.fontsize = fontsize\n\t\tself.draw_relations = draw_relations\n\t\tself.non_reactant_transparency = 0.3\n\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL\n\t\t# percentage of canvas that will be margin in on either side in the\n\t\t# X and Y directions\n\t\tself.margins = margins\n\n\tdef draw(self, filename):\n\t\t\"\"\"Add the map elements to the drawing.\"\"\"\n\t\t# Instantiate the drawing, first\n\t\t# size x_max, y_max for now - we can add margins, later\n\t\tif self.import_imagemap:\n\t\t\t# We're drawing directly on the image, so we set the canvas to the\n\t\t\t# same size as the image\n\t\t\tif os.path.isfile(self.pathway.image):\n\t\t\t\timfilename = self.pathway.image\n\t\t\telse:\n\t\t\t\timfilename = get_temp_imagefilename(self.pathway.image)\n\t\t\tim = Image.open(imfilename)\n\t\t\tcwidth, cheight = im.size\n\t\telse:\n\t\t\t# No image, so we set the canvas size to accommodate visible\n\t\t\t# elements\n\t\t\tcwidth, cheight = (self.pathway.bounds[1][0],\n\t\t\t\t\t\t\t   self.pathway.bounds[1][1])\n\t\t# Instantiate canvas\n\t\tself.drawing = \\\n\t\t\tcanvas.Canvas(filename, bottomup=0,\n\t\t\t\t\t\t  pagesize=(cwidth *\n\t\t\t\t\t\t\t\t\t\t(1 + 2 * self.margins[0]),\n\t\t\t\t\t\t\t\t\tcheight *\n\t\t\t\t\t\t\t\t\t\t(1 + 2 * self.margins[1])))\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\t\t# Transform the canvas to add the margins\n\t\tself.drawing.translate(self.margins[0] * self.pathway.bounds[1][0],\n\t\t\t\t\t\t\t   self.margins[1] * self.pathway.bounds[1][1])\n\t\t# Add the map image, if required\n\t\tif self.import_imagemap:\n\t\t\tself.drawing.saveState()\n\t\t\tself.drawing.scale(1, -1)\n\t\t\tself.drawing.translate(0, -cheight)\n\t\t\tself.drawing.drawImage(imfilename, 0, 0)\n\t\t\tself.drawing.restoreState()\n\t\t# Add the reactions, compounds and maps\n\t\t# Maps go on first, to be overlaid by more information.\n\t\t# By default, they're slightly transparent.\n\t\tif self.show_maps:\n\t\t\tself.__add_maps()\n\t\tif self.show_reaction_entries:\n\t\t\tself.__add_reaction_entries()\n\t\tif self.show_orthologs:\n\t\t\tself.__add_orthologs()\n\t\tif self.show_compounds:\n\t\t\tself.__add_compounds()\n\t\tif self.show_genes:\n\t\t\tself.__add_genes()\n\t\t# TODO: complete draw_relations code\n\t\t# if self.draw_relations:\n\t\t#\tself.__add_relations()\n\t\t# Write the pathway map to PDF\n\t\tself.drawing.save()\n\n\tdef __add_maps(self):\n\t\t\"\"\"Adds maps to the drawing of the map.\n\n\t\tWe do this first, as they're regional labels to be overlaid by\n\t\tinformation.  Also, we want to set the color to something subtle.\n\n\t\tWe're using Hex colors because that's what KGML uses, and\n\t\tReportlab doesn't mind.\n\t\t\"\"\"\n\t\tfor m in self.pathway.maps:\n\t\t\tfor g in m.graphics:\n\t\t\t\tself.drawing.setStrokeColor('#888888')\n\t\t\t\tself.drawing.setFillColor('#DDDDDD')\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_maps:\n\t\t\t\t\tself.drawing.setFillColor('#888888')\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_graphics(self, graphics):\n\t\t\"\"\"Adds the passed graphics object to the map.\n\n\t\tAdd text, add after the graphics object, for sane Z-ordering.\n\t\t\"\"\"\n\t\tif graphics.type == 'line':\n\t\t\tp = self.drawing.beginPath()\n\t\t\tx, y = graphics.coords[0]\n\t\t\t# There are optional settings for lines that aren't necessarily\n\t\t\t# part of the KGML DTD\n\t\t\tif graphics.width is not None:\n\t\t\t\tself.drawing.setLineWidth(graphics.width)\n\t\t\telse:\n\t\t\t\tself.drawing.setLineWidth(1)\n\t\t\tp.moveTo(x, y)\n\t\t\tfor (x, y) in graphics.coords:\n\t\t\t\tp.lineTo(x, y)\n\t\t\tself.drawing.drawPath(p)\n\t\t\tself.drawing.setLineWidth(1)\t\t# Return to default\n\t\t# KGML defines the (x, y) coordinates as the centre of the circle/\n\t\t# rectangle/roundrectangle, but Reportlab uses the co-ordinates of the\n\t\t# lower-left corner for rectangle/elif.\n\t\tif graphics.type == 'circle':\n\t\t\tself.drawing.circle(graphics.x, graphics.y, graphics.width * 0.5,\n\t\t\t\t\t\t\t\tstroke=1, fill=1)\n\t\telif graphics.type == 'roundrectangle':\n\t\t\tself.drawing.roundRect(graphics.x - graphics.width * 0.5,\n\t\t\t\t\t\t\t\t   graphics.y - graphics.height * 0.5,\n\t\t\t\t\t\t\t\t   graphics.width, graphics.height,\n\t\t\t\t\t\t\t\t   min(graphics.width, graphics.height) * 0.1,\n\t\t\t\t\t\t\t\t   stroke=1, fill=1)\n\t\telif graphics.type == 'rectangle':\n\t\t\tself.drawing.rect(graphics.x - graphics.width * 0.5,\n\t\t\t\t\t\t\t  graphics.y - graphics.height * 0.5,\n\t\t\t\t\t\t\t  graphics.width, graphics.height,\n\t\t\t\t\t\t\t  stroke=1, fill=1)\n\n\tdef __add_labels(self, graphics):\n\t\t\"\"\"Adds labels for the passed graphics objects to the map (PRIVATE).\n\n\t\tWe don't check that the labels fit inside objects such as circles/\n\t\trectangles/roundrectangles.\n\t\t\"\"\"\n\t\tif graphics.type == 'line':\n\t\t\t# We use the midpoint of the line - sort of - we take the median\n\t\t\t# line segment (list-wise, not in terms of length), and use the\n\t\t\t# midpoint of that line.  We could have other options here,\n\t\t\t# maybe even parameterising it to a proportion of the total line\n\t\t\t# length.\n\t\t\tmid_idx = len(graphics.coords) * 0.5\n\t\t\tif not int(mid_idx) == mid_idx:\n\t\t\t\tidx1, idx2 = int(mid_idx - 0.5), int(mid_idx + 0.5)\n\t\t\telse:\n\t\t\t\tidx1, idx2 = int(mid_idx - 1), int(mid_idx)\n\t\t\tx1, y1 = graphics.coords[idx1]\n\t\t\tx2, y2 = graphics.coords[idx2]\n\t\t\tx, y = 0.5 * (x1 + x2), 0.5 * (y1 + y2)\n\t\telif graphics.type == 'circle':\n\t\t\tx, y = graphics.x, graphics.y\n\t\telif graphics.type in ('rectangle', 'roundrectangle'):\n\t\t\tx, y = graphics.x, graphics.y\n\t\t# How big so we want the text, and how many characters?\n\t\tif graphics._parent.type == 'map':\n\t\t\ttext = graphics.name\n\t\t\tself.drawing.setFont(self.fontname, self.fontsize + 2)\n\t\telif len(graphics.name) < 15:\n\t\t\ttext = graphics.name\n\t\telse:\n\t\t\ttext = graphics.name[:12] + '...'\n\t\tself.drawing.drawCentredString(x, y, text)\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\n\tdef __add_orthologs(self):\n\t\t\"\"\"Adds 'ortholog' Entry elements to the drawing of the map (PRIVATE).\n\n\t\tIn KGML, these are typically line objects, so we render them\n\t\tbefore the compound circles to cover the unsightly ends/junctions.\n\t\t\"\"\"\n\t\tfor ortholog in self.pathway.orthologs:\n\t\t\tfor g in ortholog.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_orthologs:\n\t\t\t\t\t# We want the label color to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_reaction_entries(self):\n\t\t\"\"\"Adds Entry elements for Reactions to the map drawing (PRIVATE).\n\n\t\tIn KGML, these are typically line objects, so we render them\n\t\tbefore the compound circles to cover the unsightly ends/junctions\n\t\t\"\"\"\n\t\tfor reaction in self.pathway.reaction_entries:\n\t\t\tfor g in reaction.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_reaction_entries:\n\t\t\t\t\t# We want the label color to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_compounds(self):\n\t\t\"\"\"Adds compound elements to the drawing of the map (PRIVATE).\"\"\"\n\t\tfor compound in self.pathway.compounds:\n\t\t\tfor g in compound.graphics:\n\t\t\t\t# Modify transparency of compounds that don't participate\n\t\t\t\t# in reactions\n\t\t\t\tfillcolor = color_to_reportlab(g.bgcolor)\n\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\tfillcolor.alpha *= self.non_reactant_transparency\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(fillcolor)\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\t\tt = 0.3\n\t\t\t\t\telse:\n\t\t\t\t\t\tt = 1\n\t\t\t\t\tself.drawing.setFillColor(colors.Color(0.2, 0.2, 0.2, t))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_genes(self):\n\t\t\"\"\"Adds gene elements to the drawing of the map (PRIVATE).\"\"\"\n\t\tfor gene in self.pathway.genes:\n\t\t\tfor g in gene.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_relations(self):\n\t\t\"\"\"Adds relations to the map (PRIVATE).\n\n\t\tThis is tricky. There is no defined graphic in KGML for a\n\t\trelation, and the corresponding entries are typically defined\n\t\tas objects 'to be connected somehow'.  KEGG uses KegSketch, which\n\t\tis not public, and most third-party software draws straight line\n\t\tarrows, with heads to indicate the appropriate direction\n\t\t(at both ends for reversible reactions), using solid lines for\n\t\tECrel relation types, and dashed lines for maplink relation types.\n\n\t\tThe relation has:\n\t\t- entry1: 'from' node\n\t\t- entry2: 'to' node\n\t\t- subtype: what the relation refers to\n\n\t\tTypically we have entry1 = map/ortholog; entry2 = map/ortholog,\n\t\tsubtype = compound.\n\t\t\"\"\"\n\t\t# Dashed lines for maplinks, solid for everything else\n\t\tfor relation in list(self.pathway.relations):\n\t\t\tif relation.type == 'maplink':\n\t\t\t\tself.drawing.setDash(6, 3)\n\t\t\telse:\n\t\t\t\tself.drawing.setDash()\n\t\t\tfor s in relation.subtypes:\n\t\t\t\tsubtype = self.pathway.entries[s[1]]\n\t\t\t\t# Our aim is to draw an arrow from the entry1 object to the\n\t\t\t\t# entry2 object, via the subtype object.\n\t\t\t\t# 1) Entry 1 to subtype\n\t\t\t\tself.__draw_arrow(relation.entry1, subtype)\n\t\t\t\t# 2) subtype to Entry 2\n\t\t\t\tself.__draw_arrow(subtype, relation.entry2)\n\n\tdef __draw_arrow(self, g_from, g_to):\n\t\t\"\"\"Draw an arrow between given Entry objects (PRIVATE).\n\n\t\tDraws an arrow from the g_from Entry object to the g_to\n\t\tEntry object; both must have Graphics objects.\n\t\t\"\"\"\n\t\t# Centre and bound co-ordinates for the from and two objects\n\t\tbounds_from, bounds_to = g_from.bounds, g_to.bounds\n\t\tcentre_from = (0.5 * (bounds_from[0][0] + bounds_from[1][0]),\n\t\t\t\t\t   0.5 * (bounds_from[0][1] + bounds_from[1][1]))\n\t\tcentre_to = (0.5 * (bounds_to[0][0] + bounds_to[1][0]),\n\t\t\t\t\t 0.5 * (bounds_to[0][1] + bounds_to[1][1]))\n\t\tp = self.drawing.beginPath()\n\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t# If the 'from' and 'to' graphics are vertically-aligned, draw a line\n\t\t# from the 'from' to the 'to' entity\n\t\tif bounds_to[0][0] < centre_from[0] < bounds_to[1][0]:\n\t\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t\tif centre_to[1] > centre_from[1]:  # to above from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\t\telse:\t\t\t\t\t\t\t # to below from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\telif bounds_from[0][0] < centre_to[0] < bounds_from[1][0]:\n\t\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t\tif centre_to[1] > centre_from[1]:  # to above from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\t\telse:\t\t\t\t\t\t\t # to below from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\tself.drawing.drawPath(p)\t# Draw arrow shaft\n\t\t# print(g_from)\n\t\t# print(bounds_from)\n\t\t# print(g_to)\n\t\t# print(bounds_to)\n", "description": "Reportlab Canvas-based representation of a KGML pathway map.", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from itertools import chain", "from io import BytesIO", "from reportlab.lib import pagesizes", "from reportlab.lib import colors", "from reportlab.lib.utils import ImageReader", "from reportlab.graphics.shapes import *", "from reportlab.pdfgen import canvas", "from PIL import Image", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\n\t# Add the animation loop here!\n\twhile 1:\n\t\tif graphics.go:\n\t\t\tif graphics.bricks_amount > 0:\n\t\t\t\t\n\t\t\t\tgraphics.ball.move(graphics.get_dx(), graphics.get_dy()) #Start move the ball \n\n\t\t\t\tif graphics.ball.x < 0 or graphics.ball.x + graphics.ball.width > graphics.window.width:\n\t\t\t\t\tgraphics.change_x_direction()\n\n\t\t\t\tgraphics.detect_hits() #Detect if ball hits brick\n\n\t\t\t\tif graphics.ball.y + graphics.ball.height > graphics.window.height:\n\t\t\t\t\tgraphics.reset()\n\t\t\t\t\t\t\t\t\t \n\t\tpause(FRAME_RATE)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "class", "name": "Event", "data": "class Event(QtCore.QEvent):\n\tdef __repr__(self):\n\t\treturn f\"{type(self).__name__}({self.type()})\"\n", "description": null, "category": "graphics", "imports": ["from __future__ import annotations", "from prettyqt.qt import QtCore", "from prettyqt.utils import bidict"]}], [], [{"term": "def", "name": "main", "data": "def main():\n\tonmouseclicked(handle_click)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.gui.events.mouse import onmouseclicked, onmousemoved"]}, {"term": "def", "name": "handle_click", "data": "def handle_click(event):\n\t\"\"\"\n\tThe animation that will happen after clicking the mouse.\n\tThe ball will start to move.\n\t\"\"\"\n\tglobal dy, dx, NUM_LIVES, count\n\tif count < NUM_LIVES:\n\t\twhile True:\n\t\t\tgraphics.find_ball()\n\t\t\tdy = graphics.get_dy()\n\t\t\tgraphics.ball.move(dx, dy)\n\t\t\t# When the ball bump into left and right window, it will bounce\n\t\t\tif graphics.ball.x <= 0 or graphics.ball.x >= graphics.window_width - graphics.ball_radius*2:\n\t\t\t\tdx = -dx\n\t\t\t# When the ball bump into the top of the window, it will bounce\n\t\t\tif graphics.ball.y <= 0:\n\t\t\t\tgraphics.y_bounce()\n\t\t\t# When the ball bump into the bottom of the window, it will lose one life and add the ball back to the window\n\t\t\tif graphics.ball.y >= graphics.window_height - graphics.ball_radius*2:\n\t\t\t\tcount += 1\n\t\t\t\tgraphics.window.add(graphics.ball, (graphics.window_width-graphics.ball_radius)/2,\n\t\t\t\t\t\t\t\t\t(graphics.window_height-graphics.ball_radius)/2)\n\t\t\t# When the bricks are all gone or the player has lose three times, the game will break\n\t\t\tif score == graphics.brick_rows*graphics.brick_cols or count == NUM_LIVES:\n\t\t\t\tbreak\n\t\t\tpause(FRAME_RATE)\n\n", "description": "\n\tThe animation that will happen after clicking the mouse.\n\tThe ball will start to move.\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.gui.events.mouse import onmouseclicked, onmousemoved"]}], [{"term": "class", "name": "Display", "data": "class Display(object):\n\t\n\tWHITE = graphicsUtils.formatColor(1.0, 1.0, 1.0)\n\tRED = graphicsUtils.formatColor(1.0, 0.0, 0.0)\n\tGREEN = graphicsUtils.formatColor(0.16, 0.49, 0.31)\n\tBLUE = graphicsUtils.formatColor(0.0, 0.0, 1.0)\n\tBLACK = graphicsUtils.formatColor(0.0, 0.0, 0.0)\n\tGREY = graphicsUtils.formatColor(0.5, .5, 0.5)\n\t\n\tVISIBLE_CUTTOFF = 0.001\n\t\n\t\n\tpartDict = {}\n\tbeliefParts = []\n\tbeliefValue = []\n\tbeliefColor = []\n\tobservations = []\n\t\n\tgraphicsLock = threading.Lock()\n\t\n\tCOLORS = [\n\t\t'purple',\n\t\t'green',\n\t\t'teal',\n\t\t'red',\n\t\t'orange',\n\t\t'yellow'\n\t]\n\tCOLOR_HUES = {\n\t\t'purple' : 0.8,\n\t\t'green' : 0.3,\n\t\t'teal' : 0.49,\n\t\t'red' : 0.0,\n\t\t'orange' : 0.125,\n\t\t'yellow' : 0.21\n\t}\n\t\n\t@staticmethod\n\tdef initGraphics(layout):\n\t\tgraphicsUtils.begin_graphics(\n\t\t\twidth=layout.getWidth(), \n\t\t\theight=layout.getHeight(), \n\t\t\tcolor = Display.WHITE,\n\t\t\ttitle = Const.TITLE\n\t\t);\n\t\t\n\t@staticmethod\n\tdef endGraphics():\n\t\tgraphicsUtils.end_graphics()\n\n\t@staticmethod\n\tdef raiseEndGraphics():\n\t\tgraphicsUtils.raiseEndGraphics()\n\t\n\t@staticmethod\n\tdef drawCar(car):\n\t\tif car in Display.partDict:\n\t\t\tDisplay._remove(car)\n\t\tcolor = Display.GREY\n\t\tif car.isJunior():\n\t\t\tcolor = Display.BLACK\n\t\tparts = graphicsUtils.rectangle(\n\t\t\tcar.pos, Car.LENGTH, \n\t\t\tCar.WIDTH, \n\t\t\tcolor, \n\t\t\tcar.dir\n\t\t)\n\t\tDisplay.partDict[car] = parts\n\t\t\n\t@staticmethod\n\tdef drawObservation(obs):\n\t\tparts = Display.drawCircle(obs.pos, Observation.RADIUS)\n\t\tDisplay.partDict[obs] = parts\n\t\n\t@staticmethod\n\tdef drawSquare(pos, size, color):\n\t\treturn graphicsUtils.square(pos, size, color)\n\t\n\t@staticmethod\n\tdef drawFinish(block):\n\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.GREEN, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\n\t@staticmethod\n\tdef drawBlocks(blocks):\n\t\tfor block in blocks:\n\t\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.BLUE, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\t\n\t@staticmethod\n\tdef drawCircle(pos, radius):\n\t\treturn graphicsUtils.circle(pos, radius, Display.RED, Display.RED)\n\t\n\t@staticmethod\n\tdef drawBelief(model):\n\t\tDisplay.beliefVisible = []\n\t\tfor r in range(model.getBeliefRows()):\n\t\t\tbeliefValueRow = []\n\t\t\tbeliefPartRow = []\n\t\t\tbeliefColorRow = []\n\t\t\tfor c in range(model.getBeliefCols()):\n\t\t\t\tsquare = Display.drawBeliefSquare(r, c, 'purple', 0.0, model)\n\t\t\t\tbeliefPartRow.append(square)\n\t\t\t\tbeliefValueRow.append(0.0)\n\t\t\t\tbeliefColorRow.append(None)\n\t\t\tDisplay.beliefParts.append(beliefPartRow)\n\t\t\tDisplay.beliefValue.append(beliefValueRow)\n\t\t\tDisplay.beliefColor.append(beliefColorRow)\n\t\t\t\t\n\t@staticmethod\n\tdef drawBeliefSquare(row, col, color, value, model):\n\t\ttileSize = Const.BELIEF_TILE_SIZE\n\t\tx = col * tileSize + tileSize / 2.0\n\t\ty = row * tileSize + tileSize / 2.0\n\t\tif not model.inBounds(x, y): return None\n\t\tcolor = Display._getBeliefSquareColor(color, value)\n\t\treturn Display.drawSquare(Vec2d(x, y), tileSize, color)\n\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef getKeys():\n\t\t#print 'attempt get keys'\n\t\tDisplay._acquireLock()\n\t\t#print 'get keys'\n\t\tkeys = graphicsUtils.keys_waiting() + graphicsUtils.keys_pressed()\n\t\tDisplay._releaseLock()\n\t\treturn keys\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef graphicsSleep(timeToSleep):\n\t\tgraphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''for _ in range(int(timeToSleep / 0.005)):\n\t\t\t#print 'attempt sleep'\n\t\t\tDisplay._acquireLock()\n\t\t\t#print 'sleep'\n\t\t\tgraphicsUtils.sleep(0.001)\n\t\t\tDisplay._releaseLock()\n\t\t\ttime.sleep(0.004)'''\n\t\t\n\t\t#graphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''startWait = time.time()\n\t\tDisplay._acquireLock()\n\t\ttimeToSleep -= time.time() - startWait\n\t\tgraphicsUtils.refresh()\n\t\tif timeToSleep > 0:\n\t\t\tgraphicsUtils.sleep(timeToSleep)\n\t\tDisplay._releaseLock()'''\n\t\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef updateBelief(color, belief):\n\t\tDisplay._acquireLock()\n\t\ttotal = belief.getSum()\n\t\tif abs(total - 1.0) > 0.001:\n\t\t\traise Exception('belief does not sum to 1 ('+str(total)+'). Use the normalize method.')\n\t\tfor r in range(belief.getNumRows()):\n\t\t\tfor c in range(belief.getNumCols()):\n\t\t\t\tvalue = belief.getProb(r, c)\n\t\t\t\tDisplay._updateBeliefSquare(r, c, value, color)\n\t\tDisplay._releaseLock()\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef move(obj, delta):\n\t\t#print 'attempt move'\n\t\tDisplay._acquireLock()\n\t\t#print 'move'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.move_by(parts, delta.x, delta.y)\n\t\t#print 'end move'\n\t\tDisplay._releaseLock()\n\t\t\n\t# make thread safe\n\t@staticmethod\n\tdef rotate(obj, angle):\n\t\tif angle == 0: return\n\t\t#print 'attempt rotate'\n\t\tDisplay._acquireLock()\n\t\t#print 'rotate'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.rotate_by(parts, angle)\n\t\tDisplay._releaseLock()\n\t\t\t\t\n\t@staticmethod\n\tdef _getBeliefSquareColor(color, value):\n\t\tvalue = min(1.0, value * 15)\n\t\tsaturation = value\n\t\thue = Display.COLOR_HUES[color]\n\t\tr, g, b = colorsys.hsv_to_rgb(hue, saturation, 1.0)\n\t\tcolor = graphicsUtils.formatColor(r, g, b)\n\t\treturn color\t\t\n\t\n\t@staticmethod\n\tdef _isVisible(value):\n\t\treturn value >= Display.VISIBLE_CUTTOFF\n\t\n\t@staticmethod\n\tdef _updateBeliefSquare(r, c, value, colorName):\n\t\tpart = Display.beliefParts[r][c]\n\t\tif part == None: return\n\t\toldValue = Display.beliefValue[r][c]\n\t\toldColor = Display.beliefColor[r][c]\n\t\twasVisible = Display._isVisible(oldValue)\n\t\tisVisible = Display._isVisible(value) \n\t\tif not isVisible: value = 0.0\n\t\tif oldColor != colorName and oldValue >= value: return\n\t\tif not isVisible and not wasVisible: return\n\t\tcolor = Display._getBeliefSquareColor(colorName, value)\n\t\tgraphicsUtils.changeColor(part, color)\n\t\tDisplay.beliefValue[r][c] = value\n\t\tDisplay.beliefColor[r][c] = colorName\n\t\t\n\t@staticmethod\n\tdef _acquireLock():\n\t\treturn\n\t\t#print 'acquire'\n\t\treturn Display.graphicsLock.acquire()\n\t\n\t@staticmethod\n\tdef _releaseLock():\n\t\treturn\n\t\t#print 'release'\n\t\treturn Display.graphicsLock.release()\n\t \n\t####################################\n\t# Depreicated\n\t####################################\n\t\t\n\t@staticmethod\n\tdef _remove(obj):\n\t\tparts = Display.partDict[obj]\n\t\tgraphicsUtils.remove_from_screen(parts);\n\t\t\n\t@staticmethod\n\tdef redrawObservations(observations):\n\t\traise Exception('depreicated')\n\t\tfor obs in Display.observations:\n\t\t\tDisplay._remove(obs)\n\t\tfor obs in observations:\n\t\t\tDisplay.drawObservation(obs)\n\t\tDisplay.observations = observations\n", "description": null, "category": "graphics", "imports": ["from . import graphicsUtils", "from engine.model.car.car import Car", "from engine.const import Const", "from engine.model.observation import Observation", "from engine.vector import Vec2d", "import colorsys", "import threading"]}], [{"term": "class", "name": "classWidgetMapScale:", "data": "class WidgetMapScale:\n\n\tdef __init__(self, drawingscale, maxlength, legend_fontsize, legend_linewidth):\n\t\tself.drawingscale = drawingscale\n\t\tself.maxlength = maxlength\n\t\tself.legend_fontsize = legend_fontsize\n\t\tself.legend_linewidth = legend_linewidth\n\t\tself._initialize()\n\n\tdef _initialize(self):\n\t\t# Determine a suitable scale ruler\n\t\tallowed_ruler = np.array([1, 5, 10, 30, 60, 120, 300.0, 600.0, 1200.0]) # arcminutes\n\t\tallowed_labels = ['1\\'', '5\\'', '10\\'', '30\\'', '1\u00b0', '2\u00b0', '5\u00b0', '10\u00b0', '20\u00b0']\n\n\t\truler_mm = allowed_ruler*np.pi/(180.0*60.0)*self.drawingscale\n\t\tself.ruler_label = ''\n\t\tself.ruler_length = 0.0\n\n\t\tfor i in range(len(allowed_ruler)):\n\t\t\tif ruler_mm[-(i+1)] <= self.maxlength:\n\t\t\t\tself.ruler_label = allowed_labels[-(i+1)]\n\t\t\t\tself.ruler_length = ruler_mm[-(i+1)]\n\t\t\t\tbreak\n\n\t\tfh = self.legend_fontsize * 0.66\n\t\tself.width, self.height = self.ruler_length + 2*fh, fh*3\n\n\tdef get_size(self):\n\t\treturn (self.width, self.height)\n\n\tdef draw(self, graphics, right, bottom, legend_only):\n\t\t\"\"\"\n\t\tx,y are the coordinates of the leftmost point of the horizontal line.\n\t\tThis is excluding the vertical end bars. maxlength is the maximum\n\t\tlength of the ruler line excluding the endbars.\n\t\t\"\"\"\n\t\tfh = self.legend_fontsize * 0.66\n\n\t\tx = right - fh\n\t\ty = bottom + fh + fh/2\n\n\t\tgraphics.set_linewidth(self.legend_linewidth)\n\n\t\tlw = graphics.gi_linewidth\n\n\t\tif legend_only and graphics.gi_background_rgb:\n\t\t\tgraphics.save()\n\t\t\tgraphics.set_fill_background()\n\t\t\tgraphics.rectangle(right-self.width, bottom+self.height, self.width, self.height, DrawMode.FILL)\n\t\t\tgraphics.restore()\n\n\t\tgraphics.line(x, y, x - self.ruler_length, y)\n\t\tgraphics.line(x - lw/2.0, y - 0.5*fh,\n\t\t\t\t\t  x - lw/2.0, y + 0.5*fh)\n\t\tgraphics.line(x - self.ruler_length + lw/2.0, y - 0.5*fh,\n\t\t\t\t\t  x - self.ruler_length + lw/2.0, y + 0.5*fh)\n\t\told_fontsize = graphics.gi_fontsize\n\t\tgraphics.set_font(graphics.gi_font, fh)\n\t\tgraphics.text_centred(x - self.ruler_length/2.0, y + graphics.gi_fontsize*2/3.0, self.ruler_label)\n\n\t\tgraphics.set_font(graphics.gi_font, old_fontsize)\n\n\t\tgraphics.line(right-self.width, bottom+self.height, right, bottom+self.height)\n\t\tgraphics.line(right-self.width, bottom+self.height, right-self.width, bottom)\n", "description": "\n\t\tx,y are the coordinates of the leftmost point of the horizontal line.\n\t\tThis is excluding the vertical end bars. maxlength is the maximum\n\t\tlength of the ruler line excluding the endbars.\n\t\t", "category": "graphics", "imports": ["import numpy as np", "from .graphics_interface import DrawMode"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\tlives = NUM_LIVES\n\tbricks_left = graphics.bricks_count()  # number of bricks left\n\n\t# animation loop\n\twhile True:\n\t\tpause(FRAME_RATE)\n\t\tgraphics.ball.move(graphics.get_dx(), graphics.get_dy())\n\n\t\t# lives count\n\t\tif graphics.ball.y + graphics.ball.height >= graphics.window.height:\n\t\t\tgraphics.reset_ball_position()\n\t\t\tlives -= 1\n\t\t\tif lives == 0:\n\t\t\t\tbreak\n\n\t\t# game progress\n\t\tif bricks_left == 0:\n\t\t\tbreak\n\n\t\t# window boarder bounce\n\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width >= graphics.window.width:\n\t\t\tgraphics.set_opp_dx()\n\t\tif graphics.ball.y <= 0:\n\t\t\tgraphics.set_opp_dy()\n\n\t\t# paddle bounce\n\t\tif graphics.ball.y >= graphics.window.height - graphics.get_paddle_offset() - 2*graphics.get_ball_radius():\n\t\t\tpad_1 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y + 2*graphics.get_ball_radius())\n\t\t\tpad_2 = graphics.window.get_object_at(graphics.ball.x + 2 * graphics.get_ball_radius(),\n\t\t\t\t\t\t\t\t\t\t\t\t  graphics.ball.y + 2 * graphics.get_ball_radius())\n\t\t\tif graphics.paddle.x - graphics.get_ball_radius() < graphics.ball.x < \\\n\t\t\t\t\tgraphics.paddle.x + graphics.paddle.width - graphics.get_ball_radius():  # right above board\n\t\t\t\tif pad_1 is not None or pad_2 is not None:\n\t\t\t\t\tgraphics.set_opp_dy()\n\t\t\t\t\tif graphics.get_dy() > 0:\n\t\t\t\t\t\tgraphics.set_opp_dy()\n\t\t\telse:\n\t\t\t\tif pad_1 or pad_2 is not None:\n\t\t\t\t\tgraphics.set_opp_dx()\n\n\t\t# destroy bricks\n\t\tif graphics.ball.y < graphics.window.height - graphics.get_paddle_offset() - 2 * graphics.get_ball_radius():\n\t\t\tobj_1 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y + 2*graphics.get_ball_radius())\n\t\t\tobj_2 = graphics.window.get_object_at(graphics.ball.x + 2 * graphics.get_ball_radius(),\n\t\t\t\t\t\t\t\t\t\t\t\t  graphics.ball.y + 2 * graphics.get_ball_radius())\n\t\t\tobj_3 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y)\n\t\t\tobj_4 = graphics.window.get_object_at(graphics.ball.x + 2 * graphics.get_ball_radius(), graphics.ball.y + 2)\n\t\t\tif obj_1 is not None:\n\t\t\t\tgraphics.window.remove(obj_1)\n\t\t\t\tbricks_left -= 1\n\t\t\t\tgraphics.set_opp_dy()\n\t\t\telif obj_2 is not None:\n\t\t\t\tgraphics.window.remove(obj_2)\n\t\t\t\tbricks_left -= 1\n\t\t\t\tgraphics.set_opp_dy()\n\t\t\telif obj_3 is not None:\n\t\t\t\tgraphics.window.remove(obj_3)\n\t\t\t\tbricks_left -= 1\n\t\t\t\tgraphics.set_opp_dy()\n\t\t\telif obj_4 is not None:\n\t\t\t\tgraphics.window.remove(obj_4)\n\t\t\t\tbricks_left -= 1\n\t\t\t\tgraphics.set_opp_dy()\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [{"term": "class", "name": "Graphics", "data": "class Graphics ( HasPrivateFacets ):\n\n\t#-- Facet Definitions ------------------------------------------------------\n\n\t# The GUI toolkit specific graphics object being adapted:\n\tgraphics = Any\n\n\t# The current pen:\n\tpen = Property\n\n\t# The current brush:\n\tbrush = Property\n\n\t# Should drawing be performed using the XOR drawing mode?\n\txor_mode = Property\n\n\t# Should anti-aliased drawing be performed (if possible)?\n\tanti_alias = Property\n\n\t# The current font being used by the graphics object:\n\tfont = Property\n\n\t# The color used to draw text:\n\ttext_color = Property\n\n\t# The background color used to draw text:\n\ttext_background_color = Property\n\n\t# The opacity used when drawing:\n\topacity = Property\n\n\t# The bounds of the clipping area:\n\tclipping_bounds = Property\n\n\t# The size of the graphics area:\n\tsize = Property\n\n\t# The bitmap associated with the graphics object (if any):\n\tbitmap = Any\n\n\t#-- Method Implementations -------------------------------------------------\n\n\tdef __init__ ( self, graphics, **facets ):\n\t\t\"\"\" Initializes the object by saving the graphics object being adapted.\n\t\t\"\"\"\n\t\tsuper( Graphics, self ).__init__( **facets )\n\n\t\tself.graphics = graphics\n\n\n\tdef __call__ ( self ):\n\t\t\"\"\" Returns the graphics object being adapted.\n\t\t\"\"\"\n\t\treturn self.graphics\n\n\t#-- Property Implementations -----------------------------------------------\n\n\tdef _get_pen ( self ):\n\t\traise NotImplementedError\n\n\tdef _set_pen ( self, color ):\n\t\traise NotImplementedError\n\n\n\tdef _get_brush ( self ):\n\t\traise NotImplementedError\n\n\tdef _set_brush ( self, color ):\n\t\traise NotImplementedError\n\n\n\tdef _set_xor_mode ( self, is_xor_mode ):\n\t\traise NotImplementedError\n\n\n\tdef _set_anti_alias ( self, anti_alias ):\n\t\traise NotImplementedError\n\n\n\tdef _get_font ( self ):\n\t\traise NotImplementedError\n\n\tdef _set_font ( self, font ):\n\t\traise NotImplementedError\n\n\n\tdef _get_text_color ( self ):\n\t\traise NotImplementedError\n\n\tdef _set_text_color ( self, color ):\n\t\traise NotImplementedError\n\n\n\tdef _get_text_background_color ( self ):\n\t\traise NotImplementedError\n\n\tdef _set_text_background_color ( self, color ):\n\t\traise NotImplementedError\n\n\n\tdef _get_opacity ( self ):\n\t\traise NotImplementedError\n\n\tdef _set_opacity ( self, opacity ):\n\t\traise NotImplementedError\n\n\n\tdef _get_clipping_bounds ( self ):\n\t\traise NotImplementedError\n\n\tdef _set_clipping_bounds ( self, x_y_dx_dy ):\n\t\traise NotImplementedError\n\n\n\tdef _get_size ( self ):\n\t\traise NotImplementedError\n\n\t#-- Method Definitions -----------------------------------------------------\n\n\tdef draw_rectangle ( self, x, y, dx, dy ):\n\t\t\"\"\" Draws a rectangle at the specified position and with the specified\n\t\t\twidth and height.\n\t\t\"\"\"\n\t\traise NotImplementedError\n\n\n\tdef draw_rounded_rectangle ( self, x, y, dx, dy, radius ):\n\t\t\"\"\" Draws a rectangle with rounded corners at the specified position\n\t\t\tand with the specified size and corner radius.\n\t\t\"\"\"\n\t\traise NotImplementedError\n\n\n\tdef draw_circle ( self, x, y, radius ):\n\t\t\"\"\" Draws a circle with the specified center point (x,y) and radius.\n\t\t\"\"\"\n\t\traise NotImplementedError\n\n\n\tdef draw_line ( self, x1, y1, x2, y2 ):\n\t\t\"\"\" Draws a line from (x1,y1) to (x2,y2).\n\t\t\"\"\"\n\t\traise NotImplementedError\n\n\n\tdef draw_polygon ( self, points ):\n\t\t\"\"\" Draws the closed polygon specified by *points*. *points* can either\n\t\t\tbe a list of Point objects or a Polygon object.\n\t\t\"\"\"\n\t\traise NotImplementedError\n\n\n\tdef draw_polyline ( self, points ):\n\t\t\"\"\" Draws the polyline specified by *points*. *points* can either\n\t\t\tbe a list of Point objects or a Polygon object.\n\t\t\"\"\"\n\t\traise NotImplementedError\n\n\n\tdef draw_bitmap ( self, bitmap, x, y ):\n\t\t\"\"\" Draws a specified bitmap at the specified location.\n\t\t\"\"\"\n\t\traise NotImplementedError\n\n\n\tdef bitmap_size ( self, bitmap ):\n\t\t\"\"\" Returns the size (dx,dy) of the specified toolkit specific bitmap:\n\t\t\"\"\"\n\t\traise NotImplementedError\n\n\n\tdef draw_text ( self, text, x, y ):\n\t\t\"\"\" Draws the specified text string at the specified (x,y) location.\n\t\t\"\"\"\n\t\traise NotImplementedError\n\n\n\tdef text_size ( self, text ):\n\t\t\"\"\" Returns the size (dx,dy) of the specified text using the current\n\t\t\tfont.\n\t\t\"\"\"\n\t\traise NotImplementedError\n\n\n\tdef graphics_bitmap ( self, bitmap ):\n\t\t\"\"\" Returns a new graphics memory object using the specified bitmap.\n\t\t\"\"\"\n\t\traise NotImplementedError\n\n\n\tdef graphics_buffer ( self, dx = None, dy = None, alpha = False ):\n\t\t\"\"\" Returns a new graphics memory object of the specified size (dx,dy)\n\t\t\tthat can be used to implement a buffered screen update. If\n\t\t\talpha is True, the resulting graphics object should support an\n\t\t\talpha channel; otherwise it does not need to.\n\t\t\"\"\"\n\t\traise NotImplementedError\n\n\n\tdef blit ( self, dst_x, dst_y, dst_dx, dst_dy, g,\n\t\t\t\t\t src_x = 0, src_y = 0, src_dx = None, src_dy = None ):\n\t\t\"\"\" Performs a standard BLT (block transfer) operation from one graphics\n\t\t\tobject to another, copying g(src_x,src_y,src_dx,syc_dy) to\n\t\t\tself(dst_x,dst_y,dst_dx,dst_dy). If src_dx or src_dy is None, then\n\t\t\tthe corresponding dst_dx or dst_dy value is used to determine the\n\t\t\tsource rectangle size. Note that g may also specify a bitmap, as\n\t\t\treturned by an ImageResource 'bitmap' attribute, in place of a\n\t\t\tgraphics adapter.\n\t\t\"\"\"\n\t\traise NotImplementedError\n\n\n\tdef copy ( self, x = 0, y = 0 ):\n\t\t\"\"\" Copies the contents of the graphics buffer back to the graphics\n\t\t\tobject it was created from at the specified (x,y) location.\n\t\t\"\"\"\n\t\traise NotImplementedError\n", "description": " Initializes the object by saving the graphics object being adapted.\n\t\t", "category": "graphics", "imports": ["\timport HasPrivateFacets, Property, Any"]}], [], [{"term": "class", "name": "TestManifest", "data": "class TestManifest(unittest.TestCase):\n\tdef process_test_vectors(self, test_vectors):\n\t\tindex = 0\n\t\tfor vector in test_vectors:\n\t\t\tprint(\"Testing index\", index)\n\t\t\texpected, yaml = vector\n\t\t\twith mozfile.NamedTemporaryFile() as tf:\n\t\t\t\ttf.write(yaml)\n\t\t\t\ttf.flush()\n\t\t\t\tif expected == \"exception\":\n\t\t\t\t\twith self.assertRaises(MozYamlVerifyError):\n\t\t\t\t\t\tload_moz_yaml(tf.name, require_license_file=False)\n\t\t\t\telse:\n\t\t\t\t\tself.assertDictEqual(\n\t\t\t\t\t\tload_moz_yaml(tf.name, require_license_file=False), expected\n\t\t\t\t\t)\n\t\t\tindex += 1\n\n\t# ===========================================================================================\n\tdef test_simple(self):\n\t\tsimple_dict = {\n\t\t\t\"schema\": \"1\",\n\t\t\t\"origin\": {\n\t\t\t\t\"description\": \"2D Graphics Library\",\n\t\t\t\t\"license\": [\"MPL-1.1\", \"LGPL-2.1\"],\n\t\t\t\t\"name\": \"cairo\",\n\t\t\t\t\"release\": \"version 1.6.4\",\n\t\t\t\t\"revision\": \"AA001122334455\",\n\t\t\t\t\"url\": \"https://www.cairographics.org/\",\n\t\t\t},\n\t\t\t\"bugzilla\": {\"component\": \"Graphics\", \"product\": \"Core\"},\n\t\t}\n\n\t\tself.process_test_vectors(\n\t\t\t[\n\t\t\t\t(\n\t\t\t\t\tsimple_dict,\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import, print_function, unicode_literals", "import unittest", "import mozfile", "from mozunit import main", "from mozbuild.vendor.moz_yaml import load_moz_yaml, MozYamlVerifyError"]}, {"term": "def", "name": "ftest_updatebot", "data": "\tdef test_updatebot(self):\n\t\tself.process_test_vectors(\n\t\t\t[\n\t\t\t\t(\n\t\t\t\t\t{\n\t\t\t\t\t\t\"schema\": \"1\",\n\t\t\t\t\t\t\"origin\": {\n\t\t\t\t\t\t\t\"description\": \"2D Graphics Library\",\n\t\t\t\t\t\t\t\"license\": [\"MPL-1.1\", \"LGPL-2.1\"],\n\t\t\t\t\t\t\t\"name\": \"cairo\",\n\t\t\t\t\t\t\t\"release\": \"version 1.6.4\",\n\t\t\t\t\t\t\t\"revision\": \"AA001122334455\",\n\t\t\t\t\t\t\t\"url\": \"https://www.cairographics.org/\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"bugzilla\": {\"component\": \"Graphics\", \"product\": \"Core\"},\n\t\t\t\t\t\t\"updatebot\": {\n\t\t\t\t\t\t\t\"maintainer-phab\": \"tjr\",\n\t\t\t\t\t\t\t\"maintainer-bz\": \"a@example.com\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import, print_function, unicode_literals", "import unittest", "import mozfile", "from mozunit import main", "from mozbuild.vendor.moz_yaml import load_moz_yaml, MozYamlVerifyError"]}, {"term": "def", "name": "ftest_malformed", "data": "\tdef test_malformed(self):\n\t\twith mozfile.NamedTemporaryFile() as tf:\n\t\t\ttf.write(b\"blah\")\n\t\t\ttf.flush()\n\t\t\twith self.assertRaises(MozYamlVerifyError):\n\t\t\t\tload_moz_yaml(tf.name, require_license_file=False)\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import, print_function, unicode_literals", "import unittest", "import mozfile", "from mozunit import main", "from mozbuild.vendor.moz_yaml import load_moz_yaml, MozYamlVerifyError"]}, {"term": "def", "name": "ftest_schema", "data": "\tdef test_schema(self):\n\t\twith mozfile.NamedTemporaryFile() as tf:\n\t\t\ttf.write(b\"schema: 99\")\n\t\t\ttf.flush()\n\t\t\twith self.assertRaises(MozYamlVerifyError):\n\t\t\t\tload_moz_yaml(tf.name, require_license_file=False)\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import, print_function, unicode_literals", "import unittest", "import mozfile", "from mozunit import main", "from mozbuild.vendor.moz_yaml import load_moz_yaml, MozYamlVerifyError"]}, {"term": "def", "name": "ftest_json", "data": "\tdef test_json(self):\n\t\twith mozfile.NamedTemporaryFile() as tf:\n\t\t\ttf.write(\n\t\t\t\tb'{\"origin\": {\"release\": \"version 1.6.4\", \"url\": \"https://w'\n\t\t\t\tb'ww.cairographics.org/\", \"description\": \"2D Graphics Libra'\n\t\t\t\tb'ry\", \"license\": [\"MPL-1.1\", \"LGPL-2.1\"], \"name\": \"cairo\"}'\n\t\t\t\tb', \"bugzilla\": {\"product\": \"Core\", \"component\": \"Graphics\"'\n\t\t\t\tb'}, \"schema\": 1}'\n\t\t\t)\n\t\t\ttf.flush()\n\t\t\twith self.assertRaises(MozYamlVerifyError):\n\t\t\t\tload_moz_yaml(tf.name, require_license_file=False)\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import, print_function, unicode_literals", "import unittest", "import mozfile", "from mozunit import main", "from mozbuild.vendor.moz_yaml import load_moz_yaml, MozYamlVerifyError"]}, {"term": "def", "name": "ftest_revision", "data": "\tdef test_revision(self):\n\t\tself.process_test_vectors(\n\t\t\t[\n\t\t\t\t(\n\t\t\t\t\t{\n\t\t\t\t\t\t\"schema\": \"1\",\n\t\t\t\t\t\t\"origin\": {\n\t\t\t\t\t\t\t\"description\": \"2D Graphics Library\",\n\t\t\t\t\t\t\t\"license\": [\"MPL-1.1\", \"LGPL-2.1\"],\n\t\t\t\t\t\t\t\"name\": \"cairo\",\n\t\t\t\t\t\t\t\"release\": \"version 1.6.4\",\n\t\t\t\t\t\t\t\"revision\": \"v1.6.37\",\n\t\t\t\t\t\t\t\"url\": \"https://www.cairographics.org/\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"bugzilla\": {\"component\": \"Graphics\", \"product\": \"Core\"},\n\t\t\t\t\t},\n", "description": null, "category": "graphics", "imports": ["from __future__ import absolute_import, print_function, unicode_literals", "import unittest", "import mozfile", "from mozunit import main", "from mozbuild.vendor.moz_yaml import load_moz_yaml, MozYamlVerifyError"]}], [{"term": "def", "name": "_swig_setattr_nondynamic", "data": "def _swig_setattr_nondynamic(self,class_type,name,value,static=1):\n\tif (name == \"thisown\"): return self.this.own(value)\n\tif (name == \"this\"):\n\t\tif type(value).__name__ == 'PySwigObject':\n\t\t\tself.__dict__[name] = value\n\t\t\treturn\n\tmethod = class_type.__swig_setmethods__.get(name,None)\n\tif method: return method(self,value)\n\tif (not static) or hasattr(self,name):\n\t\tself.__dict__[name] = value\n\telse:\n\t\traise AttributeError(\"You cannot add attributes to %s\" % self)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "def", "name": "_swig_setattr", "data": "def _swig_setattr(self,class_type,name,value):\n\treturn _swig_setattr_nondynamic(self,class_type,name,value,0)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "def", "name": "_swig_getattr", "data": "def _swig_getattr(self,class_type,name):\n\tif (name == \"thisown\"): return self.this.own()\n\tmethod = class_type.__swig_getmethods__.get(name,None)\n\tif method: return method(self)\n\traise AttributeError,name\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "def", "name": "_swig_repr", "data": "def _swig_repr(self):\n\ttry: strthis = \"proxy of \" + self.this.__repr__()\n\texcept: strthis = \"\"\n\treturn \"<%s.%s; %s >\" % (self.__class__.__module__, self.__class__.__name__, strthis,)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGFloatArray", "data": "class CGFloatArray(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGFloatArray, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGFloatArray, name)\n\t__repr__ = _swig_repr\n\tdef __init__(self, *args): \n\t\tthis = _CoreGraphics.new_CGFloatArray(*args)\n\t\ttry: self.this.append(this)\n\t\texcept: self.this = this\n\t__swig_destroy__ = _CoreGraphics.delete_CGFloatArray\n\t__del__ = lambda self : None;\n\tdef __getitem__(*args): return _CoreGraphics.CGFloatArray___getitem__(*args)\n\tdef __setitem__(*args): return _CoreGraphics.CGFloatArray___setitem__(*args)\n\tdef cast(*args): return _CoreGraphics.CGFloatArray_cast(*args)\n\t__swig_getmethods__[\"frompointer\"] = lambda x: _CoreGraphics.CGFloatArray_frompointer\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CFType", "data": "class CFType(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CFType, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CFType, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CFType\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGAffineTransform", "data": "class CGAffineTransform(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGAffineTransform, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGAffineTransform, name)\n\t__repr__ = _swig_repr\n\t__swig_setmethods__[\"a\"] = _CoreGraphics.CGAffineTransform_a_set\n\t__swig_getmethods__[\"a\"] = _CoreGraphics.CGAffineTransform_a_get\n\tif _newclass:a = _swig_property(_CoreGraphics.CGAffineTransform_a_get, _CoreGraphics.CGAffineTransform_a_set)\n\t__swig_setmethods__[\"b\"] = _CoreGraphics.CGAffineTransform_b_set\n\t__swig_getmethods__[\"b\"] = _CoreGraphics.CGAffineTransform_b_get\n\tif _newclass:b = _swig_property(_CoreGraphics.CGAffineTransform_b_get, _CoreGraphics.CGAffineTransform_b_set)\n\t__swig_setmethods__[\"c\"] = _CoreGraphics.CGAffineTransform_c_set\n\t__swig_getmethods__[\"c\"] = _CoreGraphics.CGAffineTransform_c_get\n\tif _newclass:c = _swig_property(_CoreGraphics.CGAffineTransform_c_get, _CoreGraphics.CGAffineTransform_c_set)\n\t__swig_setmethods__[\"d\"] = _CoreGraphics.CGAffineTransform_d_set\n\t__swig_getmethods__[\"d\"] = _CoreGraphics.CGAffineTransform_d_get\n\tif _newclass:d = _swig_property(_CoreGraphics.CGAffineTransform_d_get, _CoreGraphics.CGAffineTransform_d_set)\n\t__swig_setmethods__[\"tx\"] = _CoreGraphics.CGAffineTransform_tx_set\n\t__swig_getmethods__[\"tx\"] = _CoreGraphics.CGAffineTransform_tx_get\n\tif _newclass:tx = _swig_property(_CoreGraphics.CGAffineTransform_tx_get, _CoreGraphics.CGAffineTransform_tx_set)\n\t__swig_setmethods__[\"ty\"] = _CoreGraphics.CGAffineTransform_ty_set\n\t__swig_getmethods__[\"ty\"] = _CoreGraphics.CGAffineTransform_ty_get\n\tif _newclass:ty = _swig_property(_CoreGraphics.CGAffineTransform_ty_get, _CoreGraphics.CGAffineTransform_ty_set)\n\tdef translate(*args): return _CoreGraphics.CGAffineTransform_translate(*args)\n\tdef scale(*args): return _CoreGraphics.CGAffineTransform_scale(*args)\n\tdef rotate(*args): return _CoreGraphics.CGAffineTransform_rotate(*args)\n\tdef invert(*args): return _CoreGraphics.CGAffineTransform_invert(*args)\n\tdef concat(*args): return _CoreGraphics.CGAffineTransform_concat(*args)\n\tdef equalToTransform(*args): return _CoreGraphics.CGAffineTransform_equalToTransform(*args)\n\tdef transformIsIdentity(*args): return _CoreGraphics.CGAffineTransform_transformIsIdentity(*args)\n\tdef __init__(self, *args): \n\t\tthis = _CoreGraphics.new_CGAffineTransform(*args)\n\t\ttry: self.this.append(this)\n\t\texcept: self.this = this\n\t__swig_destroy__ = _CoreGraphics.delete_CGAffineTransform\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPoint", "data": "class CGPoint(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPoint, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPoint, name)\n\t__repr__ = _swig_repr\n\t__swig_setmethods__[\"x\"] = _CoreGraphics.CGPoint_x_set\n\t__swig_getmethods__[\"x\"] = _CoreGraphics.CGPoint_x_get\n\tif _newclass:x = _swig_property(_CoreGraphics.CGPoint_x_get, _CoreGraphics.CGPoint_x_set)\n\t__swig_setmethods__[\"y\"] = _CoreGraphics.CGPoint_y_set\n\t__swig_getmethods__[\"y\"] = _CoreGraphics.CGPoint_y_get\n\tif _newclass:y = _swig_property(_CoreGraphics.CGPoint_y_get, _CoreGraphics.CGPoint_y_set)\n\tdef equalToPoint(*args): return _CoreGraphics.CGPoint_equalToPoint(*args)\n\tdef applyAffineTransform(*args): return _CoreGraphics.CGPoint_applyAffineTransform(*args)\n\tdef __init__(self, *args): \n\t\tthis = _CoreGraphics.new_CGPoint(*args)\n\t\ttry: self.this.append(this)\n\t\texcept: self.this = this\n\t__swig_destroy__ = _CoreGraphics.delete_CGPoint\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGSize", "data": "class CGSize(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGSize, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGSize, name)\n\t__repr__ = _swig_repr\n\t__swig_setmethods__[\"width\"] = _CoreGraphics.CGSize_width_set\n\t__swig_getmethods__[\"width\"] = _CoreGraphics.CGSize_width_get\n\tif _newclass:width = _swig_property(_CoreGraphics.CGSize_width_get, _CoreGraphics.CGSize_width_set)\n\t__swig_setmethods__[\"height\"] = _CoreGraphics.CGSize_height_set\n\t__swig_getmethods__[\"height\"] = _CoreGraphics.CGSize_height_get\n\tif _newclass:height = _swig_property(_CoreGraphics.CGSize_height_get, _CoreGraphics.CGSize_height_set)\n\tdef equalToSize(*args): return _CoreGraphics.CGSize_equalToSize(*args)\n\tdef applyAffineTransform(*args): return _CoreGraphics.CGSize_applyAffineTransform(*args)\n\tdef __init__(self, *args): \n\t\tthis = _CoreGraphics.new_CGSize(*args)\n\t\ttry: self.this.append(this)\n\t\texcept: self.this = this\n\t__swig_destroy__ = _CoreGraphics.delete_CGSize\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGRect", "data": "class CGRect(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGRect, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGRect, name)\n\t__repr__ = _swig_repr\n\t__swig_setmethods__[\"origin\"] = _CoreGraphics.CGRect_origin_set\n\t__swig_getmethods__[\"origin\"] = _CoreGraphics.CGRect_origin_get\n\tif _newclass:origin = _swig_property(_CoreGraphics.CGRect_origin_get, _CoreGraphics.CGRect_origin_set)\n\t__swig_setmethods__[\"size\"] = _CoreGraphics.CGRect_size_set\n\t__swig_getmethods__[\"size\"] = _CoreGraphics.CGRect_size_get\n\tif _newclass:size = _swig_property(_CoreGraphics.CGRect_size_get, _CoreGraphics.CGRect_size_set)\n\tdef getMinX(*args): return _CoreGraphics.CGRect_getMinX(*args)\n\tdef getMidX(*args): return _CoreGraphics.CGRect_getMidX(*args)\n\tdef getMaxX(*args): return _CoreGraphics.CGRect_getMaxX(*args)\n\tdef getMinY(*args): return _CoreGraphics.CGRect_getMinY(*args)\n\tdef getMidY(*args): return _CoreGraphics.CGRect_getMidY(*args)\n\tdef getMaxY(*args): return _CoreGraphics.CGRect_getMaxY(*args)\n\tdef getWidth(*args): return _CoreGraphics.CGRect_getWidth(*args)\n\tdef getHeight(*args): return _CoreGraphics.CGRect_getHeight(*args)\n\tdef equalToRect(*args): return _CoreGraphics.CGRect_equalToRect(*args)\n\tdef standardize(*args): return _CoreGraphics.CGRect_standardize(*args)\n\tdef isEmpty(*args): return _CoreGraphics.CGRect_isEmpty(*args)\n\tdef isNull(*args): return _CoreGraphics.CGRect_isNull(*args)\n\tdef isInfinite(*args): return _CoreGraphics.CGRect_isInfinite(*args)\n\tdef inset(*args): return _CoreGraphics.CGRect_inset(*args)\n\tdef integral(*args): return _CoreGraphics.CGRect_integral(*args)\n\tdef union(*args): return _CoreGraphics.CGRect_Union(*args)\n\tdef intersection(*args): return _CoreGraphics.CGRect_intersection(*args)\n\tdef offset(*args): return _CoreGraphics.CGRect_offset(*args)\n\tdef divide(*args): return _CoreGraphics.CGRect_divide(*args)\n\tdef containsPoint(*args): return _CoreGraphics.CGRect_containsPoint(*args)\n\tdef containsRect(*args): return _CoreGraphics.CGRect_containsRect(*args)\n\tdef intersectsRect(*args): return _CoreGraphics.CGRect_intersectsRect(*args)\n\tdef applyAffineTransform(*args): return _CoreGraphics.CGRect_applyAffineTransform(*args)\n\tdef __init__(self, *args): \n\t\tthis = _CoreGraphics.new_CGRect(*args)\n\t\ttry: self.this.append(this)\n\t\texcept: self.this = this\n\t__swig_destroy__ = _CoreGraphics.delete_CGRect\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGColorSpace", "data": "class CGColorSpace(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGColorSpace, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGColorSpace, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGColorSpace\n\t__del__ = lambda self : None;\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGDataConsumer", "data": "class CGDataConsumer(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGDataConsumer, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGDataConsumer, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGDataConsumer\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGDataProvider", "data": "class CGDataProvider(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGDataProvider, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGDataProvider, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGDataProvider\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGImage", "data": "class CGImage(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGImage, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGImage, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGImage\n\t__del__ = lambda self : None;\n\tdef isMask(*args): return _CoreGraphics.CGImage_isMask(*args)\n\tdef getWidth(*args): return _CoreGraphics.CGImage_getWidth(*args)\n\tdef getHeight(*args): return _CoreGraphics.CGImage_getHeight(*args)\n\tdef getBitsPerComponent(*args): return _CoreGraphics.CGImage_getBitsPerComponent(*args)\n\tdef getBitsPerPixel(*args): return _CoreGraphics.CGImage_getBitsPerPixel(*args)\n\tdef getBytesPerRow(*args): return _CoreGraphics.CGImage_getBytesPerRow(*args)\n\tdef getColorSpace(*args): return _CoreGraphics.CGImage_getColorSpace(*args)\n\tdef getAlphaInfo(*args): return _CoreGraphics.CGImage_getAlphaInfo(*args)\n\tdef getDataProvider(*args): return _CoreGraphics.CGImage_getDataProvider(*args)\n\tdef getDecode(*args): return _CoreGraphics.CGImage_getDecode(*args)\n\tdef getShouldInterpolate(*args): return _CoreGraphics.CGImage_getShouldInterpolate(*args)\n\tdef getRenderingIntent(*args): return _CoreGraphics.CGImage_getRenderingIntent(*args)\n\tdef getBitmapInfo(*args): return _CoreGraphics.CGImage_getBitmapInfo(*args)\n\tdef createWithImageInRect(*args): return _CoreGraphics.CGImage_createWithImageInRect(*args)\n\tdef createWithMask(*args): return _CoreGraphics.CGImage_createWithMask(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGShading", "data": "class CGShading(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGShading, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGShading, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGShading\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPattern", "data": "class CGPattern(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPattern, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPattern, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGPattern\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGColor", "data": "class CGColor(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGColor, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGColor, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGColor\n\t__del__ = lambda self : None;\n\tdef equalToColor(*args): return _CoreGraphics.CGColor_equalToColor(*args)\n\tdef getNumberOfComponents(*args): return _CoreGraphics.CGColor_getNumberOfComponents(*args)\n\tdef getComponents(*args): return _CoreGraphics.CGColor_getComponents(*args)\n\tdef getAlpha(*args): return _CoreGraphics.CGColor_getAlpha(*args)\n\tdef getColorSpace(*args): return _CoreGraphics.CGColor_getColorSpace(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPath", "data": "class CGPath(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPath, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPath, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGPath\n\t__del__ = lambda self : None;\n\tdef equalToPath(*args): return _CoreGraphics.CGPath_equalToPath(*args)\n\tdef isEmpty(*args): return _CoreGraphics.CGPath_isEmpty(*args)\n\tdef isRect(*args): return _CoreGraphics.CGPath_isRect(*args)\n\tdef getCurrentPoint(*args): return _CoreGraphics.CGPath_getCurrentPoint(*args)\n\tdef getBoundingBox(*args): return _CoreGraphics.CGPath_getBoundingBox(*args)\n\tdef containsPoint(*args): return _CoreGraphics.CGPath_containsPoint(*args)\n\tdef moveToPoint(*args): return _CoreGraphics.CGPath_moveToPoint(*args)\n\tdef addLineToPoint(*args): return _CoreGraphics.CGPath_addLineToPoint(*args)\n\tdef addQuadCurveToPoint(*args): return _CoreGraphics.CGPath_addQuadCurveToPoint(*args)\n\tdef addCurveToPoint(*args): return _CoreGraphics.CGPath_addCurveToPoint(*args)\n\tdef closeSubpath(*args): return _CoreGraphics.CGPath_closeSubpath(*args)\n\tdef addRect(*args): return _CoreGraphics.CGPath_addRect(*args)\n\tdef addRects(*args): return _CoreGraphics.CGPath_addRects(*args)\n\tdef addLines(*args): return _CoreGraphics.CGPath_addLines(*args)\n\tdef addEllipseInRect(*args): return _CoreGraphics.CGPath_addEllipseInRect(*args)\n\tdef addArc(*args): return _CoreGraphics.CGPath_addArc(*args)\n\tdef addArcToPoint(*args): return _CoreGraphics.CGPath_addArcToPoint(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGContext", "data": "class CGContext(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGContext, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGContext, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGContext\n\t__del__ = lambda self : None;\n\tdef saveGState(*args): return _CoreGraphics.CGContext_saveGState(*args)\n\tdef restoreGState(*args): return _CoreGraphics.CGContext_restoreGState(*args)\n\tdef scaleCTM(*args): return _CoreGraphics.CGContext_scaleCTM(*args)\n\tdef translateCTM(*args): return _CoreGraphics.CGContext_translateCTM(*args)\n\tdef rotateCTM(*args): return _CoreGraphics.CGContext_rotateCTM(*args)\n\tdef concatCTM(*args): return _CoreGraphics.CGContext_concatCTM(*args)\n\tdef getCTM(*args): return _CoreGraphics.CGContext_getCTM(*args)\n\tdef setLineWidth(*args): return _CoreGraphics.CGContext_setLineWidth(*args)\n\tdef setLineCap(*args): return _CoreGraphics.CGContext_setLineCap(*args)\n\tdef setLineJoin(*args): return _CoreGraphics.CGContext_setLineJoin(*args)\n\tdef setMiterLimit(*args): return _CoreGraphics.CGContext_setMiterLimit(*args)\n\tdef setLineDash(*args): return _CoreGraphics.CGContext_setLineDash(*args)\n\tdef setFlatness(*args): return _CoreGraphics.CGContext_setFlatness(*args)\n\tdef setAlpha(*args): return _CoreGraphics.CGContext_setAlpha(*args)\n\tdef setBlendMode(*args): return _CoreGraphics.CGContext_setBlendMode(*args)\n\tdef beginPath(*args): return _CoreGraphics.CGContext_beginPath(*args)\n\tdef moveToPoint(*args): return _CoreGraphics.CGContext_moveToPoint(*args)\n\tdef addLineToPoint(*args): return _CoreGraphics.CGContext_addLineToPoint(*args)\n\tdef addCurveToPoint(*args): return _CoreGraphics.CGContext_addCurveToPoint(*args)\n\tdef addQuadCurveToPoint(*args): return _CoreGraphics.CGContext_addQuadCurveToPoint(*args)\n\tdef closePath(*args): return _CoreGraphics.CGContext_closePath(*args)\n\tdef addRect(*args): return _CoreGraphics.CGContext_addRect(*args)\n\tdef addRects(*args): return _CoreGraphics.CGContext_addRects(*args)\n\tdef addLines(*args): return _CoreGraphics.CGContext_addLines(*args)\n\tdef addEllipseInRect(*args): return _CoreGraphics.CGContext_addEllipseInRect(*args)\n\tdef addArc(*args): return _CoreGraphics.CGContext_addArc(*args)\n\tdef addArcToPoint(*args): return _CoreGraphics.CGContext_addArcToPoint(*args)\n\tdef addPath(*args): return _CoreGraphics.CGContext_addPath(*args)\n\tdef replacePathWithStrokedPath(*args): return _CoreGraphics.CGContext_replacePathWithStrokedPath(*args)\n\tdef isPathEmpty(*args): return _CoreGraphics.CGContext_isPathEmpty(*args)\n\tdef getPathCurrentPoint(*args): return _CoreGraphics.CGContext_getPathCurrentPoint(*args)\n\tdef getPathBoundingBox(*args): return _CoreGraphics.CGContext_getPathBoundingBox(*args)\n\tdef pathContainsPoint(*args): return _CoreGraphics.CGContext_pathContainsPoint(*args)\n\tdef drawPath(*args): return _CoreGraphics.CGContext_drawPath(*args)\n\tdef fillPath(*args): return _CoreGraphics.CGContext_fillPath(*args)\n\tdef eoFillPath(*args): return _CoreGraphics.CGContext_eoFillPath(*args)\n\tdef strokePath(*args): return _CoreGraphics.CGContext_strokePath(*args)\n\tdef fillRect(*args): return _CoreGraphics.CGContext_fillRect(*args)\n\tdef fillRects(*args): return _CoreGraphics.CGContext_fillRects(*args)\n\tdef strokeRect(*args): return _CoreGraphics.CGContext_strokeRect(*args)\n\tdef strokeRectWithWidth(*args): return _CoreGraphics.CGContext_strokeRectWithWidth(*args)\n\tdef clearRect(*args): return _CoreGraphics.CGContext_clearRect(*args)\n\tdef fillEllipseInRect(*args): return _CoreGraphics.CGContext_fillEllipseInRect(*args)\n\tdef strokeEllipseInRect(*args): return _CoreGraphics.CGContext_strokeEllipseInRect(*args)\n\tdef strokeLineSegments(*args): return _CoreGraphics.CGContext_strokeLineSegments(*args)\n\tdef clip(*args): return _CoreGraphics.CGContext_clip(*args)\n\tdef eoClip(*args): return _CoreGraphics.CGContext_eoClip(*args)\n\tdef clipToMask(*args): return _CoreGraphics.CGContext_clipToMask(*args)\n\tdef clipToRect(*args): return _CoreGraphics.CGContext_clipToRect(*args)\n\tdef clipToRects(*args): return _CoreGraphics.CGContext_clipToRects(*args)\n\tdef setFillColorWithColor(*args): return _CoreGraphics.CGContext_setFillColorWithColor(*args)\n\tdef setStrokeColorWithColor(*args): return _CoreGraphics.CGContext_setStrokeColorWithColor(*args)\n\tdef setFillColorSpace(*args): return _CoreGraphics.CGContext_setFillColorSpace(*args)\n\tdef setStrokeColorSpace(*args): return _CoreGraphics.CGContext_setStrokeColorSpace(*args)\n\tdef setFillColor(*args): return _CoreGraphics.CGContext_setFillColor(*args)\n\tdef setStrokeColor(*args): return _CoreGraphics.CGContext_setStrokeColor(*args)\n\tdef setFillPattern(*args): return _CoreGraphics.CGContext_setFillPattern(*args)\n\tdef setStrokePattern(*args): return _CoreGraphics.CGContext_setStrokePattern(*args)\n\tdef setPatternPhase(*args): return _CoreGraphics.CGContext_setPatternPhase(*args)\n\tdef setGrayFillColor(*args): return _CoreGraphics.CGContext_setGrayFillColor(*args)\n\tdef setGrayStrokeColor(*args): return _CoreGraphics.CGContext_setGrayStrokeColor(*args)\n\tdef setRGBFillColor(*args): return _CoreGraphics.CGContext_setRGBFillColor(*args)\n\tdef setRGBStrokeColor(*args): return _CoreGraphics.CGContext_setRGBStrokeColor(*args)\n\tdef setCMYKFillColor(*args): return _CoreGraphics.CGContext_setCMYKFillColor(*args)\n\tdef setCMYKStrokeColor(*args): return _CoreGraphics.CGContext_setCMYKStrokeColor(*args)\n\tdef setRenderingIntent(*args): return _CoreGraphics.CGContext_setRenderingIntent(*args)\n\tdef drawImage(*args): return _CoreGraphics.CGContext_drawImage(*args)\n\tdef drawLayerInRect(*args): return _CoreGraphics.CGContext_drawLayerInRect(*args)\n\tdef drawLayerAtPoint(*args): return _CoreGraphics.CGContext_drawLayerAtPoint(*args)\n\tdef getInterpolationQuality(*args): return _CoreGraphics.CGContext_getInterpolationQuality(*args)\n\tdef setInterpolationQuality(*args): return _CoreGraphics.CGContext_setInterpolationQuality(*args)\n\tdef setShadowWithColor(*args): return _CoreGraphics.CGContext_setShadowWithColor(*args)\n\tdef setShadow(*args): return _CoreGraphics.CGContext_setShadow(*args)\n\tdef drawShading(*args): return _CoreGraphics.CGContext_drawShading(*args)\n\tdef setCharacterSpacing(*args): return _CoreGraphics.CGContext_setCharacterSpacing(*args)\n\tdef setTextPosition(*args): return _CoreGraphics.CGContext_setTextPosition(*args)\n\tdef getTextPosition(*args): return _CoreGraphics.CGContext_getTextPosition(*args)\n\tdef setTextMatrix(*args): return _CoreGraphics.CGContext_setTextMatrix(*args)\n\tdef getTextMatrix(*args): return _CoreGraphics.CGContext_getTextMatrix(*args)\n\tdef setTextDrawingMode(*args): return _CoreGraphics.CGContext_setTextDrawingMode(*args)\n\tdef setFontSize(*args): return _CoreGraphics.CGContext_setFontSize(*args)\n\tdef selectFont(*args): return _CoreGraphics.CGContext_selectFont(*args)\n\tdef showText(*args): return _CoreGraphics.CGContext_showText(*args)\n\tdef showGlyphs(*args): return _CoreGraphics.CGContext_showGlyphs(*args)\n\tdef showTextAtPoint(*args): return _CoreGraphics.CGContext_showTextAtPoint(*args)\n\tdef showGlyphsAtPoint(*args): return _CoreGraphics.CGContext_showGlyphsAtPoint(*args)\n\tdef drawPlainTextInRect(*args): return _CoreGraphics.CGContext_drawPlainTextInRect(*args)\n\tdef drawRTFTextInRect(*args): return _CoreGraphics.CGContext_drawRTFTextInRect(*args)\n\tdef drawDocFormatTextInRect(*args): return _CoreGraphics.CGContext_drawDocFormatTextInRect(*args)\n\tdef drawWordMLFormatTextInRect(*args): return _CoreGraphics.CGContext_drawWordMLFormatTextInRect(*args)\n\tdef drawHTMLTextInRect(*args): return _CoreGraphics.CGContext_drawHTMLTextInRect(*args)\n\tdef drawPDFDocument(*args): return _CoreGraphics.CGContext_drawPDFDocument(*args)\n\tdef beginPage(*args): return _CoreGraphics.CGContext_beginPage(*args)\n\tdef endPage(*args): return _CoreGraphics.CGContext_endPage(*args)\n\tdef flush(*args): return _CoreGraphics.CGContext_flush(*args)\n\tdef synchronize(*args): return _CoreGraphics.CGContext_synchronize(*args)\n\tdef setShouldAntialias(*args): return _CoreGraphics.CGContext_setShouldAntialias(*args)\n\tdef setAllowsAntialiasing(*args): return _CoreGraphics.CGContext_setAllowsAntialiasing(*args)\n\tdef setShouldSmoothFonts(*args): return _CoreGraphics.CGContext_setShouldSmoothFonts(*args)\n\tdef beginTransparencyLayer(*args): return _CoreGraphics.CGContext_beginTransparencyLayer(*args)\n\tdef endTransparencyLayer(*args): return _CoreGraphics.CGContext_endTransparencyLayer(*args)\n\tdef getUserSpaceToDeviceSpaceTransform(*args): return _CoreGraphics.CGContext_getUserSpaceToDeviceSpaceTransform(*args)\n\tdef convertPointToDeviceSpace(*args): return _CoreGraphics.CGContext_convertPointToDeviceSpace(*args)\n\tdef convertPointToUserSpace(*args): return _CoreGraphics.CGContext_convertPointToUserSpace(*args)\n\tdef convertSizeToDeviceSpace(*args): return _CoreGraphics.CGContext_convertSizeToDeviceSpace(*args)\n\tdef convertSizeToUserSpace(*args): return _CoreGraphics.CGContext_convertSizeToUserSpace(*args)\n\tdef CGContextConvertRectToDeviceSpace(*args): return _CoreGraphics.CGContext_CGContextConvertRectToDeviceSpace(*args)\n\tdef convertRectToUserSpace(*args): return _CoreGraphics.CGContext_convertRectToUserSpace(*args)\n\tdef finish(self):\n\t  self.flush ()\n\t  if self.thisown:\n\t\t_CoreGraphics.delete_CGContext (self)\n\t\tself.thisown = 0; \n\tdef getData(*args): return _CoreGraphics.CGContext_getData(*args)\n\tdef getWidth(*args): return _CoreGraphics.CGContext_getWidth(*args)\n\tdef getHeight(*args): return _CoreGraphics.CGContext_getHeight(*args)\n\tdef getBitsPerComponent(*args): return _CoreGraphics.CGContext_getBitsPerComponent(*args)\n\tdef getBitsPerPixel(*args): return _CoreGraphics.CGContext_getBitsPerPixel(*args)\n\tdef getBytesPerRow(*args): return _CoreGraphics.CGContext_getBytesPerRow(*args)\n\tdef getColorSpace(*args): return _CoreGraphics.CGContext_getColorSpace(*args)\n\tdef getAlphaInfo(*args): return _CoreGraphics.CGContext_getAlphaInfo(*args)\n\tdef createImage(*args): return _CoreGraphics.CGContext_createImage(*args)\n\tdef writeToDataConsumer(*args): return _CoreGraphics.CGContext_writeToDataConsumer(*args)\n\tdef writeToFile(*args): return _CoreGraphics.CGContext_writeToFile(*args)\n\tdef setURLForRect(*args): return _CoreGraphics.CGContext_setURLForRect(*args)\n\tdef addDestinationAtPoint(*args): return _CoreGraphics.CGContext_addDestinationAtPoint(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPDFDictionary", "data": "class CGPDFDictionary(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPDFDictionary, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPDFDictionary, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\tdef getCount(*args): return _CoreGraphics.CGPDFDictionary_getCount(*args)\n\tdef getKeys(*args): return _CoreGraphics.CGPDFDictionary_getKeys(*args)\n\tdef getBoolean(*args): return _CoreGraphics.CGPDFDictionary_getBoolean(*args)\n\tdef getInteger(*args): return _CoreGraphics.CGPDFDictionary_getInteger(*args)\n\tdef getNumber(*args): return _CoreGraphics.CGPDFDictionary_getNumber(*args)\n\tdef getName(*args): return _CoreGraphics.CGPDFDictionary_getName(*args)\n\tdef getString(*args): return _CoreGraphics.CGPDFDictionary_getString(*args)\n\tdef getArray(*args): return _CoreGraphics.CGPDFDictionary_getArray(*args)\n\tdef getDictionary(*args): return _CoreGraphics.CGPDFDictionary_getDictionary(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPDFArray", "data": "class CGPDFArray(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPDFArray, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPDFArray, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\tdef getCount(*args): return _CoreGraphics.CGPDFArray_getCount(*args)\n\tdef getNull(*args): return _CoreGraphics.CGPDFArray_getNull(*args)\n\tdef getBoolean(*args): return _CoreGraphics.CGPDFArray_getBoolean(*args)\n\tdef getInteger(*args): return _CoreGraphics.CGPDFArray_getInteger(*args)\n\tdef getNumber(*args): return _CoreGraphics.CGPDFArray_getNumber(*args)\n\tdef getName(*args): return _CoreGraphics.CGPDFArray_getName(*args)\n\tdef getString(*args): return _CoreGraphics.CGPDFArray_getString(*args)\n\tdef getArray(*args): return _CoreGraphics.CGPDFArray_getArray(*args)\n\tdef getDictionary(*args): return _CoreGraphics.CGPDFArray_getDictionary(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPDFContentStream", "data": "class CGPDFContentStream(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPDFContentStream, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPDFContentStream, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGPDFContentStream\n\t__del__ = lambda self : None;\n\tdef retain(*args): return _CoreGraphics.CGPDFContentStream_retain(*args)\n\tdef release(*args): return _CoreGraphics.CGPDFContentStream_release(*args)\n\tdef getStreams(*args): return _CoreGraphics.CGPDFContentStream_getStreams(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPDFOperatorTable", "data": "class CGPDFOperatorTable(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPDFOperatorTable, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPDFOperatorTable, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGPDFOperatorTable\n\t__del__ = lambda self : None;\n\tdef retain(*args): return _CoreGraphics.CGPDFOperatorTable_retain(*args)\n\tdef release(*args): return _CoreGraphics.CGPDFOperatorTable_release(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPDFScanner", "data": "class CGPDFScanner(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPDFScanner, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPDFScanner, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGPDFScanner\n\t__del__ = lambda self : None;\n\tdef release(*args): return _CoreGraphics.CGPDFScanner_release(*args)\n\tdef scan(*args): return _CoreGraphics.CGPDFScanner_scan(*args)\n\tdef getContentStream(*args): return _CoreGraphics.CGPDFScanner_getContentStream(*args)\n\tdef popObject(*args): return _CoreGraphics.CGPDFScanner_popObject(*args)\n\tdef popBoolean(*args): return _CoreGraphics.CGPDFScanner_popBoolean(*args)\n\tdef popInteger(*args): return _CoreGraphics.CGPDFScanner_popInteger(*args)\n\tdef popNumber(*args): return _CoreGraphics.CGPDFScanner_popNumber(*args)\n\tdef popName(*args): return _CoreGraphics.CGPDFScanner_popName(*args)\n\tdef popString(*args): return _CoreGraphics.CGPDFScanner_popString(*args)\n\tdef popArray(*args): return _CoreGraphics.CGPDFScanner_popArray(*args)\n\tdef popDictionary(*args): return _CoreGraphics.CGPDFScanner_popDictionary(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPDFStream", "data": "class CGPDFStream(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPDFStream, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPDFStream, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\tdef getDictionary(*args): return _CoreGraphics.CGPDFStream_getDictionary(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPDFPage", "data": "class CGPDFPage(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPDFPage, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPDFPage, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGPDFPage\n\t__del__ = lambda self : None;\n\tdef getDocument(*args): return _CoreGraphics.CGPDFPage_getDocument(*args)\n\tdef getPageNumber(*args): return _CoreGraphics.CGPDFPage_getPageNumber(*args)\n\tdef getBoxRect(*args): return _CoreGraphics.CGPDFPage_getBoxRect(*args)\n\tdef getRotationAngle(*args): return _CoreGraphics.CGPDFPage_getRotationAngle(*args)\n\tdef getDrawingTransform(*args): return _CoreGraphics.CGPDFPage_getDrawingTransform(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPDFDocument", "data": "class CGPDFDocument(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPDFDocument, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPDFDocument, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGPDFDocument\n\t__del__ = lambda self : None;\n\tdef getVersion(*args): return _CoreGraphics.CGPDFDocument_getVersion(*args)\n\tdef isEncrypted(*args): return _CoreGraphics.CGPDFDocument_isEncrypted(*args)\n\tdef unlockWithPassword(*args): return _CoreGraphics.CGPDFDocument_unlockWithPassword(*args)\n\tdef isUnlocked(*args): return _CoreGraphics.CGPDFDocument_isUnlocked(*args)\n\tdef allowsPrinting(*args): return _CoreGraphics.CGPDFDocument_allowsPrinting(*args)\n\tdef allowsCopying(*args): return _CoreGraphics.CGPDFDocument_allowsCopying(*args)\n\tdef getNumberOfPages(*args): return _CoreGraphics.CGPDFDocument_getNumberOfPages(*args)\n\tdef getPage(*args): return _CoreGraphics.CGPDFDocument_getPage(*args)\n\tdef getCatalog(*args): return _CoreGraphics.CGPDFDocument_getCatalog(*args)\n\tdef getInfo(*args): return _CoreGraphics.CGPDFDocument_getInfo(*args)\n\tdef getID(*args): return _CoreGraphics.CGPDFDocument_getID(*args)\n\tdef getMediaBox(*args): return _CoreGraphics.CGPDFDocument_getMediaBox(*args)\n\tdef getCropBox(*args): return _CoreGraphics.CGPDFDocument_getCropBox(*args)\n\tdef getBleedBox(*args): return _CoreGraphics.CGPDFDocument_getBleedBox(*args)\n\tdef getTrimBox(*args): return _CoreGraphics.CGPDFDocument_getTrimBox(*args)\n\tdef getArtBox(*args): return _CoreGraphics.CGPDFDocument_getArtBox(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}, {"term": "class", "name": "CGPSConverter", "data": "class CGPSConverter(_object):\n\t__swig_setmethods__ = {}\n\t__setattr__ = lambda self, name, value: _swig_setattr(self, CGPSConverter, name, value)\n\t__swig_getmethods__ = {}\n\t__getattr__ = lambda self, name: _swig_getattr(self, CGPSConverter, name)\n\tdef __init__(self): raise AttributeError, \"No constructor defined\"\n\t__repr__ = _swig_repr\n\t__swig_destroy__ = _CoreGraphics.delete_CGPSConverter\n\t__del__ = lambda self : None;\n\tdef convert(*args): return _CoreGraphics.CGPSConverter_convert(*args)\n\tdef abort(*args): return _CoreGraphics.CGPSConverter_abort(*args)\n", "description": null, "category": "graphics", "imports": ["from _CoreGraphics import *", "import new", "import types"]}], [], [{"term": "class", "name": "Display", "data": "class Display(object):\n\t\n\tWHITE = graphicsUtils.formatColor(1.0, 1.0, 1.0)\n\tRED = graphicsUtils.formatColor(1.0, 0.0, 0.0)\n\tGREEN = graphicsUtils.formatColor(0.16, 0.49, 0.31)\n\tBLUE = graphicsUtils.formatColor(0.0, 0.0, 1.0)\n\tBLACK = graphicsUtils.formatColor(0.0, 0.0, 0.0)\n\tGREY = graphicsUtils.formatColor(0.5, .5, 0.5)\n\t\n\tVISIBLE_CUTTOFF = 0.001\n\t\n\t\n\tpartDict = {}\n\tbeliefParts = []\n\tbeliefValue = []\n\tbeliefColor = []\n\tobservations = []\n\t\n\tgraphicsLock = threading.Lock()\n\t\n\tCOLORS = [\n\t\t'purple',\n\t\t'green',\n\t\t'teal',\n\t\t'red',\n\t\t'orange',\n\t\t'yellow'\n\t]\n\tCOLOR_HUES = {\n\t\t'purple' : 0.8,\n\t\t'green' : 0.3,\n\t\t'teal' : 0.49,\n\t\t'red' : 0.0,\n\t\t'orange' : 0.125,\n\t\t'yellow' : 0.21\n\t}\n\t\n\t@staticmethod\n\tdef initGraphics(layout):\n\t\tgraphicsUtils.begin_graphics(\n\t\t\twidth=layout.getWidth(), \n\t\t\theight=layout.getHeight(), \n\t\t\tcolor = Display.WHITE,\n\t\t\ttitle = Const.TITLE\n\t\t);\n\t\t\n\t@staticmethod\n\tdef endGraphics():\n\t\tgraphicsUtils.end_graphics()\n\n\t@staticmethod\n\tdef raiseEndGraphics():\n\t\tgraphicsUtils.raiseEndGraphics()\n\t\n\t@staticmethod\n\tdef drawCar(car):\n\t\tif car in Display.partDict:\n\t\t\tDisplay._remove(car)\n\t\tcolor = Display.GREY\n\t\tif car.isJunior():\n\t\t\tcolor = Display.BLACK\n\t\tparts = graphicsUtils.rectangle(\n\t\t\tcar.pos, Car.LENGTH, \n\t\t\tCar.WIDTH, \n\t\t\tcolor, \n\t\t\tcar.dir\n\t\t)\n\t\tDisplay.partDict[car] = parts\n\t\t\n\t@staticmethod\n\tdef drawObservation(obs):\n\t\tparts = Display.drawCircle(obs.pos, Observation.RADIUS)\n\t\tDisplay.partDict[obs] = parts\n\t\n\t@staticmethod\n\tdef drawSquare(pos, size, color):\n\t\treturn graphicsUtils.square(pos, size, color)\n\t\n\t@staticmethod\n\tdef drawFinish(block):\n\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.GREEN, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\n\t@staticmethod\n\tdef drawBlocks(blocks):\n\t\tfor block in blocks:\n\t\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.BLUE, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\t\n\t@staticmethod\n\tdef drawCircle(pos, radius):\n\t\treturn graphicsUtils.circle(pos, radius, Display.RED, Display.RED)\n\t\n\t@staticmethod\n\tdef drawBelief(model):\n\t\tDisplay.beliefVisible = []\n\t\tfor r in range(model.getBeliefRows()):\n\t\t\tbeliefValueRow = []\n\t\t\tbeliefPartRow = []\n\t\t\tbeliefColorRow = []\n\t\t\tfor c in range(model.getBeliefCols()):\n\t\t\t\tsquare = Display.drawBeliefSquare(r, c, 'purple', 0.0, model)\n\t\t\t\tbeliefPartRow.append(square)\n\t\t\t\tbeliefValueRow.append(0.0)\n\t\t\t\tbeliefColorRow.append(None)\n\t\t\tDisplay.beliefParts.append(beliefPartRow)\n\t\t\tDisplay.beliefValue.append(beliefValueRow)\n\t\t\tDisplay.beliefColor.append(beliefColorRow)\n\t\t\t\t\n\t@staticmethod\n\tdef drawBeliefSquare(row, col, color, value, model):\n\t\ttileSize = Const.BELIEF_TILE_SIZE\n\t\tx = col * tileSize + tileSize / 2.0\n\t\ty = row * tileSize + tileSize / 2.0\n\t\tif not model.inBounds(x, y): return None\n\t\tcolor = Display._getBeliefSquareColor(color, value)\n\t\treturn Display.drawSquare(Vec2d(x, y), tileSize, color)\n\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef getKeys():\n\t\t#print 'attempt get keys'\n\t\tDisplay._acquireLock()\n\t\t#print 'get keys'\n\t\tkeys = graphicsUtils.keys_waiting() + graphicsUtils.keys_pressed()\n\t\tDisplay._releaseLock()\n\t\treturn keys\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef graphicsSleep(timeToSleep):\n\t\tgraphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''for _ in range(int(timeToSleep / 0.005)):\n\t\t\t#print 'attempt sleep'\n\t\t\tDisplay._acquireLock()\n\t\t\t#print 'sleep'\n\t\t\tgraphicsUtils.sleep(0.001)\n\t\t\tDisplay._releaseLock()\n\t\t\ttime.sleep(0.004)'''\n\t\t\n\t\t#graphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''startWait = time.time()\n\t\tDisplay._acquireLock()\n\t\ttimeToSleep -= time.time() - startWait\n\t\tgraphicsUtils.refresh()\n\t\tif timeToSleep > 0:\n\t\t\tgraphicsUtils.sleep(timeToSleep)\n\t\tDisplay._releaseLock()'''\n\t\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef updateBelief(color, belief):\n\t\tDisplay._acquireLock()\n\t\ttotal = belief.getSum()\n\t\tif abs(total - 1.0) > 0.001:\n\t\t\traise Exception('belief does not sum to 1 ('+str(total)+'). Use the normalize method.')\n\t\tfor r in range(belief.getNumRows()):\n\t\t\tfor c in range(belief.getNumCols()):\n\t\t\t\tvalue = belief.getProb(r, c)\n\t\t\t\tDisplay._updateBeliefSquare(r, c, value, color)\n\t\tDisplay._releaseLock()\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef move(obj, delta):\n\t\t#print 'attempt move'\n\t\tDisplay._acquireLock()\n\t\t#print 'move'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.move_by(parts, delta.x, delta.y)\n\t\t#print 'end move'\n\t\tDisplay._releaseLock()\n\t\t\n\t# make thread safe\n\t@staticmethod\n\tdef rotate(obj, angle):\n\t\tif angle == 0: return\n\t\t#print 'attempt rotate'\n\t\tDisplay._acquireLock()\n\t\t#print 'rotate'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.rotate_by(parts, angle)\n\t\tDisplay._releaseLock()\n\t\t\t\t\n\t@staticmethod\n\tdef _getBeliefSquareColor(color, value):\n\t\tvalue = min(1.0, value * 15)\n\t\tsaturation = value\n\t\thue = Display.COLOR_HUES[color]\n\t\tr, g, b = colorsys.hsv_to_rgb(hue, saturation, 1.0)\n\t\tcolor = graphicsUtils.formatColor(r, g, b)\n\t\treturn color\t\t\n\t\n\t@staticmethod\n\tdef _isVisible(value):\n\t\treturn value >= Display.VISIBLE_CUTTOFF\n\t\n\t@staticmethod\n\tdef _updateBeliefSquare(r, c, value, colorName):\n\t\tpart = Display.beliefParts[r][c]\n\t\tif part == None: return\n\t\toldValue = Display.beliefValue[r][c]\n\t\toldColor = Display.beliefColor[r][c]\n\t\twasVisible = Display._isVisible(oldValue)\n\t\tisVisible = Display._isVisible(value) \n\t\tif not isVisible: value = 0.0\n\t\tif oldColor != colorName and oldValue >= value: return\n\t\tif not isVisible and not wasVisible: return\n\t\tcolor = Display._getBeliefSquareColor(colorName, value)\n\t\tgraphicsUtils.changeColor(part, color)\n\t\tDisplay.beliefValue[r][c] = value\n\t\tDisplay.beliefColor[r][c] = colorName\n\t\t\n\t@staticmethod\n\tdef _acquireLock():\n\t\treturn\n\t\t#print 'acquire'\n\t\treturn Display.graphicsLock.acquire()\n\t\n\t@staticmethod\n\tdef _releaseLock():\n\t\treturn\n\t\t#print 'release'\n\t\treturn Display.graphicsLock.release()\n\t \n\t####################################\n\t# Depreicated\n\t####################################\n\t\t\n\t@staticmethod\n\tdef _remove(obj):\n\t\tparts = Display.partDict[obj]\n\t\tgraphicsUtils.remove_from_screen(parts);\n\t\t\n\t@staticmethod\n\tdef redrawObservations(observations):\n\t\traise Exception('depreicated')\n\t\tfor obs in Display.observations:\n\t\t\tDisplay._remove(obs)\n\t\tfor obs in observations:\n\t\t\tDisplay.drawObservation(obs)\n\t\tDisplay.observations = observations\n", "description": null, "category": "graphics", "imports": ["from . import graphicsUtils", "from engine.model.car.car import Car", "from engine.const import Const", "from engine.model.observation import Observation", "from engine.vector import Vec2d", "import colorsys", "import threading"]}], [{"term": "def", "name": "game_loop", "data": "def game_loop(board, player_symbol, ai_symbol):\n\t\n\tglobal NewGameClicked\n\tNewGameClicked = 0\n\n\t# AI loop\n\tBoard.print_board(Gameboard)\n\tGraphics.draw_symbols(Gameboard)\n\tprint (\"AI's turn\")\n\tif Board.count_chars(board, \"-\") > 7: # on the first turn, the AI uses a different logic for determining its first move\n\t\tInput.ai_first(Gameboard, ai_symbol)\n\telse:\n\t\tInput.ai_logic(Gameboard, ai_symbol, player_symbol)\n\tif Board.victory_check(Gameboard, ai_symbol) == 1:\n\t\tBoard.print_board(Gameboard)\n\t\tGraphics.draw_symbols(Gameboard)\n\t\tif Graphics.end_screen(3, Gameboard):\n\t\t\tmain()\n\telif Board.draw_check(Gameboard) == 1:\n\t\tGraphics.draw_symbols(Gameboard)\n\t\tif Graphics.end_screen(2, Gameboard):\n\t\t\tmain()\n\n\t# player loop\n\tBoard.print_board(Gameboard)\n\tGraphics.draw_symbols(Gameboard)\n\tprint (\"Player 1's turn\")\n\tInput.player_input(Gameboard, player_symbol, ai_symbol)\n\tif Board.victory_check(Gameboard, player_symbol) == 1:\n\t\tBoard.print_board(Gameboard)\n\t\tGraphics.draw_symbols(Gameboard)\n\t\tif Graphics.end_screen(1, Gameboard):\n\t\t\tmain()\n\telif Board.draw_check(Gameboard) == 1:\n\t\tGraphics.draw_symbols(Gameboard)\n\t\tif Graphics.end_screen(2, Gameboard):\n\t\t\tmain()\n", "description": null, "category": "graphics", "imports": ["import sdl2.ext", "import Graphics", "import Board", "import Input"]}, {"term": "def", "name": "main", "data": "def main():\n\twindow = Graphics.return_window()\n\n\trunning = True \n\t\n\tBoard.clear_board(Gameboard)\n\tGraphics.clear_screen()\n\t\n\twhile running == True:\n\t\tGraphics.refresh_screen(window)\n\t\tgame_loop(Gameboard, \"X\", \"O\")\n\t\tevents = sdl2.ext.get_events()\n\t\tfor event in events:\n\t\t\tif event.type == sdl2.SDL_QUIT:\n\t\t\t\tquit()\n\t\t\tif event.type == sdl2.SDL_WINDOWEVENT:\n\t\t\t\tif event.window.event == sdl2.SDL_WINDOWEVENT_RESIZED:\n\t\t\t\t\tprint(\"User resized window\")\n", "description": null, "category": "graphics", "imports": ["import sdl2.ext", "import Graphics", "import Board", "import Input"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\t# Add animation loop here!\n\n\twhile True:\n\t\t# graphics.click_to_start(graphics.mouse_click)\n\t\tif graphics.mouse_click == 1:  # \u5982\u679c\u6ed1\u9f20\u958b\u95dc\u6253\u958b\u4e86\n\t\t\twhile True:\n\t\t\t\tgraphics.ball_move()  # \u7403\u5c31\u958b\u59cb\u79fb\u52d5\n\t\t\t\tpause(FRAME_RATE)\n\t\t\t\tif graphics.ball.y + graphics.ball.height >= graphics.window.height:\n\t\t\t\t\tgraphics.times += 1  # \u6b7b\u4e86\u4e00\u6b21\n\t\t\t\t\tbreak\n\t\t\t\tp1 = graphics.ball_touch()  # \u5728\u79fb\u52d5\u7684\u904e\u7a0b\u4e2d\u5075\u6e2c\u662f\u5426\u649e\u5230\u7269\u9ad4\n\t\t\t\tif graphics.ball.y <= graphics.window.height / 2:  # \u7576\u7403\u5728\u8996\u7a97\u4e0a\u534a\u90e8\u79fb\u52d5\u6642\n\t\t\t\t\tif p1 is not None:  # \u649e\u5230\u4e86\u7269\u9ad4\n\t\t\t\t\t\tgraphics.window.remove(p1)  # \u79fb\u9664\u6389\u7269\u9ad4\n\t\t\t\t\t\tgraphics.set_dy()  # \u7403\u53cd\u5f48\n\t\t\t\telse:\n\t\t\t\t\tif p1 is not None:  # \u649e\u5230\u4e86\u7269\u9ad4\n\t\t\t\t\t\tgraphics.set_dy()  # \u7403\u53cd\u5f48\n\t\t\tgraphics.window.remove(graphics.ball)  # \u7403\u91cd\u65b0\u5f9e\u539f\u59cb\u4f4d\u7f6e\u958b\u59cb\n\t\t\tgraphics.window.add(graphics.ball, x=(graphics.window.width - graphics.ball.width) / 2,\n\t\t\t\ty=(graphics.window.height - graphics.ball.height) / 2)\n\t\t\tgraphics.mouse_click -= 1  # \u958b\u95dc\u56de\u5230\u521d\u59cb\u503c(0)\n\t\tpause(FRAME_RATE)\n\n\n\t\t\t# dx = graphics.get_dx()\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics"]}], [], [{"term": "def", "name": "darken", "data": "def darken(color, factor=0.7):\n\t\"\"\"Returns darkened color as a ReportLab RGB color.\n\n\tTake a passed color and returns a Reportlab color that is darker by the\n\tfactor indicated in the parameter.\n\t\"\"\"\n\tnewcol = color_to_reportlab(color)\n\tfor a in ['red', 'green', 'blue']:\n\t\tsetattr(newcol, a, factor * getattr(newcol, a))\n\treturn newcol\n\n", "description": "Returns darkened color as a ReportLab RGB color.\n\n\tTake a passed color and returns a Reportlab color that is darker by the\n\tfactor indicated in the parameter.\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "from reportlab.lib import colors", "from reportlab.graphics.shapes import *", "from reportlab.pdfgen import canvas", "from PIL import Image", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "def", "name": "color_to_reportlab", "data": "def color_to_reportlab(color):\n\t\"\"\"Returns the passed color in Reportlab Color format.\n\n\tWe allow colors to be specified as hex values, tuples, or Reportlab Color\n\tobjects, and with or without an alpha channel. This function acts as a\n\tRosetta stone for conversion of those formats to a Reportlab Color\n\tobject, with alpha value.\n\n\tAny other color specification is returned directly\n\t\"\"\"\n\t# Reportlab Color objects are in the format we want already\n\tif isinstance(color, colors.Color):\n\t\treturn color\n\telif isinstance(color, str):  # String implies hex color\n\t\tif color.startswith(\"0x\"):  # Standardise to octothorpe\n\t\t\tcolor.replace(\"0x\", \"#\")\n\t\tif len(color) == 7:\n\t\t\treturn colors.HexColor(color)\n\t\telse:\n\t\t\ttry:\n\t\t\t\treturn colors.HexColor(color, hasAlpha=True)\n\t\t\texcept TypeError:  # Catch pre-2.7 Reportlab\n\t\t\t\traise RuntimeError(\"Your reportlab seems to be too old, try 2.7 onwards\")\n\telif isinstance(color, tuple):  # Tuple implies RGB(alpha) tuple\n\t\treturn colors.Color(*color)\n\treturn color\n\n", "description": "Returns the passed color in Reportlab Color format.\n\n\tWe allow colors to be specified as hex values, tuples, or Reportlab Color\n\tobjects, and with or without an alpha channel. This function acts as a\n\tRosetta stone for conversion of those formats to a Reportlab Color\n\tobject, with alpha value.\n\n\tAny other color specification is returned directly\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "from reportlab.lib import colors", "from reportlab.graphics.shapes import *", "from reportlab.pdfgen import canvas", "from PIL import Image", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "def", "name": "get_temp_imagefilename", "data": "def get_temp_imagefilename(url):\n\t\"\"\"Returns filename of temporary file containing downloaded image.\n\n\tCreate a new temporary file to hold the image file at the passed URL\n\tand return the filename.\n\t\"\"\"\n\timg = _urlopen(url).read()\n\tim = Image.open(BytesIO(img))\n\t# im.transpose(Image.FLIP_TOP_BOTTOM)\n\tf = tempfile.NamedTemporaryFile(delete=False, suffix='.png')\n\tfname = f.name\n\tf.close()\n\tim.save(fname, 'PNG')\n\treturn fname\n\n", "description": "Returns filename of temporary file containing downloaded image.\n\n\tCreate a new temporary file to hold the image file at the passed URL\n\tand return the filename.\n\t", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "from reportlab.lib import colors", "from reportlab.graphics.shapes import *", "from reportlab.pdfgen import canvas", "from PIL import Image", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}, {"term": "class", "name": "KGMLCanvas", "data": "class KGMLCanvas(object):\n\t\"\"\"Reportlab Canvas-based representation of a KGML pathway map.\"\"\"\n\n\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,\n\t\t\t\t label_orthologs=True, label_reaction_entries=True,\n\t\t\t\t label_maps=True, show_maps=False, fontname='Helvetica',\n\t\t\t\t fontsize=6, draw_relations=True, show_orthologs=True,\n\t\t\t\t show_compounds=True, show_genes=True,\n\t\t\t\t show_reaction_entries=True, margins=(0.02, 0.02)):\n\t\tself.pathway = pathway\n\t\tself.show_maps = show_maps\n\t\tself.show_orthologs = show_orthologs\n\t\tself.show_compounds = show_compounds\n\t\tself.show_genes = show_genes\n\t\tself.show_reaction_entries = show_reaction_entries\n\t\tself.label_compounds = label_compounds\n\t\tself.label_orthologs = label_orthologs\n\t\tself.label_reaction_entries = label_reaction_entries\n\t\tself.label_maps = label_maps\n\t\tself.fontname = fontname\n\t\tself.fontsize = fontsize\n\t\tself.draw_relations = draw_relations\n\t\tself.non_reactant_transparency = 0.3\n\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL\n\t\t# percentage of canvas that will be margin in on either side in the\n\t\t# X and Y directions\n\t\tself.margins = margins\n\n\tdef draw(self, filename):\n\t\t\"\"\"Add the map elements to the drawing.\"\"\"\n\t\t# Instantiate the drawing, first\n\t\t# size x_max, y_max for now - we can add margins, later\n\t\tif self.import_imagemap:\n\t\t\t# We're drawing directly on the image, so we set the canvas to the\n\t\t\t# same size as the image\n\t\t\tif os.path.isfile(self.pathway.image):\n\t\t\t\timfilename = self.pathway.image\n\t\t\telse:\n\t\t\t\timfilename = get_temp_imagefilename(self.pathway.image)\n\t\t\tim = Image.open(imfilename)\n\t\t\tcwidth, cheight = im.size\n\t\telse:\n\t\t\t# No image, so we set the canvas size to accommodate visible\n\t\t\t# elements\n\t\t\tcwidth, cheight = (self.pathway.bounds[1][0],\n\t\t\t\t\t\t\t   self.pathway.bounds[1][1])\n\t\t# Instantiate canvas\n\t\tself.drawing = \\\n\t\t\tcanvas.Canvas(filename, bottomup=0,\n\t\t\t\t\t\t  pagesize=(cwidth *\n\t\t\t\t\t\t\t\t\t\t(1 + 2 * self.margins[0]),\n\t\t\t\t\t\t\t\t\tcheight *\n\t\t\t\t\t\t\t\t\t\t(1 + 2 * self.margins[1])))\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\t\t# Transform the canvas to add the margins\n\t\tself.drawing.translate(self.margins[0] * self.pathway.bounds[1][0],\n\t\t\t\t\t\t\t   self.margins[1] * self.pathway.bounds[1][1])\n\t\t# Add the map image, if required\n\t\tif self.import_imagemap:\n\t\t\tself.drawing.saveState()\n\t\t\tself.drawing.scale(1, -1)\n\t\t\tself.drawing.translate(0, -cheight)\n\t\t\tself.drawing.drawImage(imfilename, 0, 0)\n\t\t\tself.drawing.restoreState()\n\t\t# Add the reactions, compounds and maps\n\t\t# Maps go on first, to be overlaid by more information.\n\t\t# By default, they're slightly transparent.\n\t\tif self.show_maps:\n\t\t\tself.__add_maps()\n\t\tif self.show_reaction_entries:\n\t\t\tself.__add_reaction_entries()\n\t\tif self.show_orthologs:\n\t\t\tself.__add_orthologs()\n\t\tif self.show_compounds:\n\t\t\tself.__add_compounds()\n\t\tif self.show_genes:\n\t\t\tself.__add_genes()\n\t\t# TODO: complete draw_relations code\n\t\t# if self.draw_relations:\n\t\t#\tself.__add_relations()\n\t\t# Write the pathway map to PDF\n\t\tself.drawing.save()\n\n\tdef __add_maps(self):\n\t\t\"\"\"Adds maps to the drawing of the map.\n\n\t\tWe do this first, as they're regional labels to be overlaid by\n\t\tinformation.  Also, we want to set the color to something subtle.\n\n\t\tWe're using Hex colors because that's what KGML uses, and\n\t\tReportlab doesn't mind.\n\t\t\"\"\"\n\t\tfor m in self.pathway.maps:\n\t\t\tfor g in m.graphics:\n\t\t\t\tself.drawing.setStrokeColor('#888888')\n\t\t\t\tself.drawing.setFillColor('#DDDDDD')\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_maps:\n\t\t\t\t\tself.drawing.setFillColor('#888888')\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_graphics(self, graphics):\n\t\t\"\"\"Adds the passed graphics object to the map.\n\n\t\tAdd text, add after the graphics object, for sane Z-ordering.\n\t\t\"\"\"\n\t\tif graphics.type == 'line':\n\t\t\tp = self.drawing.beginPath()\n\t\t\tx, y = graphics.coords[0]\n\t\t\t# There are optional settings for lines that aren't necessarily\n\t\t\t# part of the KGML DTD\n\t\t\tif graphics.width is not None:\n\t\t\t\tself.drawing.setLineWidth(graphics.width)\n\t\t\telse:\n\t\t\t\tself.drawing.setLineWidth(1)\n\t\t\tp.moveTo(x, y)\n\t\t\tfor (x, y) in graphics.coords:\n\t\t\t\tp.lineTo(x, y)\n\t\t\tself.drawing.drawPath(p)\n\t\t\tself.drawing.setLineWidth(1)\t\t# Return to default\n\t\t# KGML defines the (x, y) coordinates as the centre of the circle/\n\t\t# rectangle/roundrectangle, but Reportlab uses the co-ordinates of the\n\t\t# lower-left corner for rectangle/elif.\n\t\tif graphics.type == 'circle':\n\t\t\tself.drawing.circle(graphics.x, graphics.y, graphics.width * 0.5,\n\t\t\t\t\t\t\t\tstroke=1, fill=1)\n\t\telif graphics.type == 'roundrectangle':\n\t\t\tself.drawing.roundRect(graphics.x - graphics.width * 0.5,\n\t\t\t\t\t\t\t\t   graphics.y - graphics.height * 0.5,\n\t\t\t\t\t\t\t\t   graphics.width, graphics.height,\n\t\t\t\t\t\t\t\t   min(graphics.width, graphics.height) * 0.1,\n\t\t\t\t\t\t\t\t   stroke=1, fill=1)\n\t\telif graphics.type == 'rectangle':\n\t\t\tself.drawing.rect(graphics.x - graphics.width * 0.5,\n\t\t\t\t\t\t\t  graphics.y - graphics.height * 0.5,\n\t\t\t\t\t\t\t  graphics.width, graphics.height,\n\t\t\t\t\t\t\t  stroke=1, fill=1)\n\n\tdef __add_labels(self, graphics):\n\t\t\"\"\"Adds labels for the passed graphics objects to the map (PRIVATE).\n\n\t\tWe don't check that the labels fit inside objects such as circles/\n\t\trectangles/roundrectangles.\n\t\t\"\"\"\n\t\tif graphics.type == 'line':\n\t\t\t# We use the midpoint of the line - sort of - we take the median\n\t\t\t# line segment (list-wise, not in terms of length), and use the\n\t\t\t# midpoint of that line.  We could have other options here,\n\t\t\t# maybe even parameterising it to a proportion of the total line\n\t\t\t# length.\n\t\t\tmid_idx = len(graphics.coords) * 0.5\n\t\t\tif not int(mid_idx) == mid_idx:\n\t\t\t\tidx1, idx2 = int(mid_idx - 0.5), int(mid_idx + 0.5)\n\t\t\telse:\n\t\t\t\tidx1, idx2 = int(mid_idx - 1), int(mid_idx)\n\t\t\tx1, y1 = graphics.coords[idx1]\n\t\t\tx2, y2 = graphics.coords[idx2]\n\t\t\tx, y = 0.5 * (x1 + x2), 0.5 * (y1 + y2)\n\t\telif graphics.type == 'circle':\n\t\t\tx, y = graphics.x, graphics.y\n\t\telif graphics.type in ('rectangle', 'roundrectangle'):\n\t\t\tx, y = graphics.x, graphics.y\n\t\t# How big so we want the text, and how many characters?\n\t\tif graphics._parent.type == 'map':\n\t\t\ttext = graphics.name\n\t\t\tself.drawing.setFont(self.fontname, self.fontsize + 2)\n\t\telif len(graphics.name) < 15:\n\t\t\ttext = graphics.name\n\t\telse:\n\t\t\ttext = graphics.name[:12] + '...'\n\t\tself.drawing.drawCentredString(x, y, text)\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\n\tdef __add_orthologs(self):\n\t\t\"\"\"Adds 'ortholog' Entry elements to the drawing of the map (PRIVATE).\n\n\t\tIn KGML, these are typically line objects, so we render them\n\t\tbefore the compound circles to cover the unsightly ends/junctions.\n\t\t\"\"\"\n\t\tfor ortholog in self.pathway.orthologs:\n\t\t\tfor g in ortholog.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_orthologs:\n\t\t\t\t\t# We want the label color to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_reaction_entries(self):\n\t\t\"\"\"Adds Entry elements for Reactions to the map drawing (PRIVATE).\n\n\t\tIn KGML, these are typically line objects, so we render them\n\t\tbefore the compound circles to cover the unsightly ends/junctions\n\t\t\"\"\"\n\t\tfor reaction in self.pathway.reaction_entries:\n\t\t\tfor g in reaction.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_reaction_entries:\n\t\t\t\t\t# We want the label color to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_compounds(self):\n\t\t\"\"\"Adds compound elements to the drawing of the map (PRIVATE).\"\"\"\n\t\tfor compound in self.pathway.compounds:\n\t\t\tfor g in compound.graphics:\n\t\t\t\t# Modify transparency of compounds that don't participate\n\t\t\t\t# in reactions\n\t\t\t\tfillcolor = color_to_reportlab(g.bgcolor)\n\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\tfillcolor.alpha *= self.non_reactant_transparency\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(fillcolor)\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\t\tt = 0.3\n\t\t\t\t\telse:\n\t\t\t\t\t\tt = 1\n\t\t\t\t\tself.drawing.setFillColor(colors.Color(0.2, 0.2, 0.2, t))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_genes(self):\n\t\t\"\"\"Adds gene elements to the drawing of the map (PRIVATE).\"\"\"\n\t\tfor gene in self.pathway.genes:\n\t\t\tfor g in gene.graphics:\n\t\t\t\tself.drawing.setStrokeColor(color_to_reportlab(g.fgcolor))\n\t\t\t\tself.drawing.setFillColor(color_to_reportlab(g.bgcolor))\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tself.drawing.setFillColor(darken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_relations(self):\n\t\t\"\"\"Adds relations to the map (PRIVATE).\n\n\t\tThis is tricky. There is no defined graphic in KGML for a\n\t\trelation, and the corresponding entries are typically defined\n\t\tas objects 'to be connected somehow'.  KEGG uses KegSketch, which\n\t\tis not public, and most third-party software draws straight line\n\t\tarrows, with heads to indicate the appropriate direction\n\t\t(at both ends for reversible reactions), using solid lines for\n\t\tECrel relation types, and dashed lines for maplink relation types.\n\n\t\tThe relation has:\n\t\t- entry1: 'from' node\n\t\t- entry2: 'to' node\n\t\t- subtype: what the relation refers to\n\n\t\tTypically we have entry1 = map/ortholog; entry2 = map/ortholog,\n\t\tsubtype = compound.\n\t\t\"\"\"\n\t\t# Dashed lines for maplinks, solid for everything else\n\t\tfor relation in list(self.pathway.relations):\n\t\t\tif relation.type == 'maplink':\n\t\t\t\tself.drawing.setDash(6, 3)\n\t\t\telse:\n\t\t\t\tself.drawing.setDash()\n\t\t\tfor s in relation.subtypes:\n\t\t\t\tsubtype = self.pathway.entries[s[1]]\n\t\t\t\t# Our aim is to draw an arrow from the entry1 object to the\n\t\t\t\t# entry2 object, via the subtype object.\n\t\t\t\t# 1) Entry 1 to subtype\n\t\t\t\tself.__draw_arrow(relation.entry1, subtype)\n\t\t\t\t# 2) subtype to Entry 2\n\t\t\t\tself.__draw_arrow(subtype, relation.entry2)\n\n\tdef __draw_arrow(self, g_from, g_to):\n\t\t\"\"\"Draw an arrow between given Entry objects (PRIVATE).\n\n\t\tDraws an arrow from the g_from Entry object to the g_to\n\t\tEntry object; both must have Graphics objects.\n\t\t\"\"\"\n\t\t# Centre and bound co-ordinates for the from and two objects\n\t\tbounds_from, bounds_to = g_from.bounds, g_to.bounds\n\t\tcentre_from = (0.5 * (bounds_from[0][0] + bounds_from[1][0]),\n\t\t\t\t\t   0.5 * (bounds_from[0][1] + bounds_from[1][1]))\n\t\tcentre_to = (0.5 * (bounds_to[0][0] + bounds_to[1][0]),\n\t\t\t\t\t 0.5 * (bounds_to[0][1] + bounds_to[1][1]))\n\t\tp = self.drawing.beginPath()\n\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t# If the 'from' and 'to' graphics are vertically-aligned, draw a line\n\t\t# from the 'from' to the 'to' entity\n\t\tif bounds_to[0][0] < centre_from[0] < bounds_to[1][0]:\n\t\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t\tif centre_to[1] > centre_from[1]:  # to above from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\t\telse:\t\t\t\t\t\t\t # to below from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\telif bounds_from[0][0] < centre_to[0] < bounds_from[1][0]:\n\t\t\t# print(True, g_from.name, g_to.name, bounds_to, bounds_from)\n\t\t\tif centre_to[1] > centre_from[1]:  # to above from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\t\telse:\t\t\t\t\t\t\t # to below from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point - TODO\n\t\tself.drawing.drawPath(p)\t# Draw arrow shaft\n\t\t# print(g_from)\n\t\t# print(bounds_from)\n\t\t# print(g_to)\n\t\t# print(bounds_to)\n", "description": "Reportlab Canvas-based representation of a KGML pathway map.", "category": "graphics", "imports": ["from __future__ import print_function", "import os", "import tempfile", "from io import BytesIO", "from reportlab.lib import colors", "from reportlab.graphics.shapes import *", "from reportlab.pdfgen import canvas", "from PIL import Image", "from Bio._py3k import urlopen as _urlopen", "from Bio.KEGG.KGML.KGML_pathway import Pathway", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:"]}], [{"term": "class", "name": "AgentGraphics", "data": "class AgentGraphics(object):\n\t\"\"\"\n\t\tGraphical visualization of any Agent implementing AbstractAgent.\n\t\"\"\"\n\t@classmethod\n\tdef display(cls, agent, agent_surface, sim_surface=None):\n\t\t\"\"\"\n\t\t\tDisplay an agent visualization on a pygame surface.\n\n\t\t:param agent: the agent to be displayed\n\t\t:param agent_surface: the pygame surface on which the agent is displayed\n\t\t:param sim_surface: the pygame surface on which the environment is displayed\n\t\t\"\"\"\n\n\t\tif isinstance(agent, AbstractDQNAgent):\n\t\t\tDQNGraphics.display(agent, agent_surface, sim_surface)\n\t\telif isinstance(agent, BFTQAgent):\n\t\t\tBFTQGraphics.display(agent, agent_surface)\n\t\telif isinstance(agent, ValueIterationAgent):\n\t\t\tValueIterationGraphics.display(agent, agent_surface)\n\t\telif isinstance(agent, MCTSAgent):\n\t\t\tMCTSGraphics.display(agent, agent_surface)\n\t\telif isinstance(agent, IntervalRobustPlannerAgent):\n\t\t\tIntervalRobustPlannerGraphics.display(agent, agent_surface, sim_surface)\n\t\telif isinstance(agent, DiscreteRobustPlannerAgent):\n\t\t\tDiscreteRobustPlannerGraphics.display(agent, agent_surface, sim_surface)\n\t\telif isinstance(agent, AbstractTreeSearchAgent):\n\t\t\tTreeGraphics.display(agent, agent_surface)\n", "description": "\n\t\tGraphical visualization of any Agent implementing AbstractAgent.\n\t", "category": "graphics", "imports": ["from __future__ import division, print_function", "from rl_agents.agents.budgeted_ftq.agent import BFTQAgent", "from rl_agents.agents.budgeted_ftq.graphics import BFTQGraphics", "from rl_agents.agents.deep_q_network.abstract import AbstractDQNAgent", "from rl_agents.agents.deep_q_network.graphics import DQNGraphics", "from rl_agents.agents.dynamic_programming.graphics import ValueIterationGraphics", "from rl_agents.agents.dynamic_programming.value_iteration import ValueIterationAgent", "from rl_agents.agents.tree_search.abstract import AbstractTreeSearchAgent", "from rl_agents.agents.tree_search.graphics import TreeGraphics, MCTSGraphics, DiscreteRobustPlannerGraphics, \\", "from rl_agents.agents.tree_search.mcts import MCTSAgent", "from rl_agents.agents.tree_search.robust import DiscreteRobustPlannerAgent, IntervalRobustPlannerAgent"]}], [{"term": "class", "name": "CGAffineTransform", "data": "class CGAffineTransform(Structure):\n\t_fields_ = [\n\t\t(\"a\", CGFloat),\n\t\t(\"b\", CGFloat),\n\t\t(\"c\", CGFloat),\n\t\t(\"d\", CGFloat),\n\t\t(\"tx\", CGFloat),\n\t\t(\"ty\", CGFloat),\n\t]\n\n", "description": null, "category": "graphics", "imports": ["from ctypes import (", "from rubicon.objc import CGFloat, CGPoint, CGRect, CGSize", "from rubicon.objc.types import register_preferred_encoding"]}, {"term": "class", "name": "CGRectMake", "data": "class CGRectMake(Structure):\n\t_fields_ = [\n\t\t(\"origin\", CGPoint),\n\t\t(\"size\", CGSize),\n\t]\n", "description": null, "category": "graphics", "imports": ["from ctypes import (", "from rubicon.objc import CGFloat, CGPoint, CGRect, CGSize", "from rubicon.objc.types import register_preferred_encoding"]}], [{"term": "def", "name": "main", "data": "def main():\n\t\"\"\"\n\tThis program plays a Python game 'zone'\n\tA ball will be bouncing around the GWindow\n\tPlayers must defend the zone indicated by black\n\tline at the middle of the GWindow by clicking on\n\tthe bouncing ball\n\t\"\"\"\n\tgraphics = ZoneGraphics()\n\n\twhile True:\n\t\t# Update\n\t\t# vx = graphics.get_vx()\n\t\tvy = graphics.get_vy()\n\t\tgraphics._ball.move(graphics.vx, vy)\n\t\tlives = NUM_LIVES\n\t\t# Chick\n\t\tif graphics.ball_in_zone() is True:\n\t\t\tgraphics.reset_ball()\n\t\tif graphics._ball.x <= 0 or graphics._ball.x + graphics._ball.width > graphics._window.width:\n\t\t\tgraphics.set_vx()\n\t\tif graphics._ball.y <= 0 or graphics._ball.y + graphics._ball.height > graphics._window.height:\n\t\t\tgraphics.set_vy()\n\t\tif graphics.ball_in_zone():\n\t\t\tlives -= 1\n\t\t\tif lives > 0:\n\t\t\t\tgraphics.reset_ball()\n\t\t\telse:\n\t\t\t\tprint(\"Game end\")\n\t\t\t\tbreak\n\n\t\t# Pause\n\t\tpause(FRAME_RATE)\n\n", "description": "\n\tThis program plays a Python game 'zone'\n\tA ball will be bouncing around the GWindow\n\tPlayers must defend the zone indicated by black\n\tline at the middle of the GWindow by clicking on\n\tthe bouncing ball\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from zonegraphics import ZoneGraphics"]}], [], [{"term": "class", "name": "GraphicsObject", "data": "class GraphicsObject(GraphicsItem, QtGui.QGraphicsObject):\n\t\"\"\"\n\t**Bases:** :class:`GraphicsItem `, :class:`QtGui.QGraphicsObject`\n\n\tExtension of QGraphicsObject with some useful methods (provided by :class:`GraphicsItem `)\n\t\"\"\"\n\t_qtBaseClass = QtGui.QGraphicsObject\n\tdef __init__(self, *args):\n\t\tself.__inform_view_on_changes = True\n\t\tQtGui.QGraphicsObject.__init__(self, *args)\n\t\tself.setFlag(self.ItemSendsGeometryChanges)\n\t\tGraphicsItem.__init__(self)\n\t\t\n\tdef itemChange(self, change, value):\n\t\tret = QtGui.QGraphicsObject.itemChange(self, change, value)\n\t\tif change in [self.ItemParentHasChanged, self.ItemSceneHasChanged]:\n\t\t\tself.parentChanged()\n\t\ttry:\n\t\t\tinform_view_on_change = self.__inform_view_on_changes\n\t\texcept AttributeError:\n\t\t\t# It's possible that the attribute was already collected when the itemChange happened\n\t\t\t# (if it was triggered during the gc of the object).\n\t\t\tpass\n\t\telse:\n\t\t\tif inform_view_on_change and change in [self.ItemPositionHasChanged, self.ItemTransformHasChanged]:\n\t\t\t\tself.informViewBoundsChanged()\n\t\t\t\n\t\t## workaround for pyqt bug:\n\t\t## http://www.riverbankcomputing.com/pipermail/pyqt/2012-August/031818.html\n\t\tif not USE_PYSIDE and change == self.ItemParentChange and isinstance(ret, QtGui.QGraphicsItem):\n\t\t\tret = sip.cast(ret, QtGui.QGraphicsItem)\n\n\t\treturn ret\n", "description": "\n\t**Bases:** :class:`GraphicsItem `, :class:`QtGui.QGraphicsObject`\n\n\tExtension of QGraphicsObject with some useful methods (provided by :class:`GraphicsItem `)\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui, QtCore, USE_PYSIDE", "\timport sip", "from .GraphicsItem import GraphicsItem"]}], [], [], [{"term": "class", "name": "Display", "data": "class Display(object):\n\t\n\tWHITE = graphicsUtils.formatColor(1.0, 1.0, 1.0)\n\tRED = graphicsUtils.formatColor(1.0, 0.0, 0.0)\n\tGREEN = graphicsUtils.formatColor(0.16, 0.49, 0.31)\n\tBLUE = graphicsUtils.formatColor(0.0, 0.0, 1.0)\n\tBLACK = graphicsUtils.formatColor(0.0, 0.0, 0.0)\n\tGREY = graphicsUtils.formatColor(0.5, .5, 0.5)\n\t\n\tVISIBLE_CUTTOFF = 0.001\n\t\n\t\n\tpartDict = {}\n\tbeliefParts = []\n\tbeliefValue = []\n\tbeliefColor = []\n\tobservations = []\n\t\n\tgraphicsLock = threading.Lock()\n\t\n\tCOLORS = [\n\t\t'purple',\n\t\t'green',\n\t\t'teal',\n\t\t'red',\n\t\t'orange',\n\t\t'yellow'\n\t]\n\tCOLOR_HUES = {\n\t\t'purple' : 0.8,\n\t\t'green' : 0.3,\n\t\t'teal' : 0.49,\n\t\t'red' : 0.0,\n\t\t'orange' : 0.125,\n\t\t'yellow' : 0.21\n\t}\n\t\n\t@staticmethod\n\tdef initGraphics(layout):\n\t\tgraphicsUtils.begin_graphics(\n\t\t\twidth=layout.getWidth(), \n\t\t\theight=layout.getHeight(), \n\t\t\tcolor = Display.WHITE,\n\t\t\ttitle = Const.TITLE\n\t\t);\n\t\t\n\t@staticmethod\n\tdef endGraphics():\n\t\tgraphicsUtils.end_graphics()\n\n\t@staticmethod\n\tdef raiseEndGraphics():\n\t\tgraphicsUtils.raiseEndGraphics()\n\t\n\t@staticmethod\n\tdef drawCar(car):\n\t\tif car in Display.partDict:\n\t\t\tDisplay._remove(car)\n\t\tcolor = Display.GREY\n\t\tif car.isJunior():\n\t\t\tcolor = Display.BLACK\n\t\tparts = graphicsUtils.rectangle(\n\t\t\tcar.pos, Car.LENGTH, \n\t\t\tCar.WIDTH, \n\t\t\tcolor, \n\t\t\tcar.dir\n\t\t)\n\t\tDisplay.partDict[car] = parts\n\t\t\n\t@staticmethod\n\tdef drawObservation(obs):\n\t\tparts = Display.drawCircle(obs.pos, Observation.RADIUS)\n\t\tDisplay.partDict[obs] = parts\n\t\n\t@staticmethod\n\tdef drawSquare(pos, size, color):\n\t\treturn graphicsUtils.square(pos, size, color)\n\t\n\t@staticmethod\n\tdef drawFinish(block):\n\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.GREEN, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\n\t@staticmethod\n\tdef drawBlocks(blocks):\n\t\tfor block in blocks:\n\t\t\tgraphicsUtils.rectangle(\n\t\t\t\tblock.getCenter(), \n\t\t\t\tblock.getHeight(), \n\t\t\t\tblock.getWidth(), \n\t\t\t\tDisplay.BLUE, \n\t\t\t\tNone,\n\t\t\t\t1.0\n\t\t\t)\n\t\t\n\t@staticmethod\n\tdef drawCircle(pos, radius):\n\t\treturn graphicsUtils.circle(pos, radius, Display.RED, Display.RED)\n\t\n\t@staticmethod\n\tdef drawBelief(model):\n\t\tDisplay.beliefVisible = []\n\t\tfor r in range(model.getBeliefRows()):\n\t\t\tbeliefValueRow = []\n\t\t\tbeliefPartRow = []\n\t\t\tbeliefColorRow = []\n\t\t\tfor c in range(model.getBeliefCols()):\n\t\t\t\tsquare = Display.drawBeliefSquare(r, c, 'purple', 0.0, model)\n\t\t\t\tbeliefPartRow.append(square)\n\t\t\t\tbeliefValueRow.append(0.0)\n\t\t\t\tbeliefColorRow.append(None)\n\t\t\tDisplay.beliefParts.append(beliefPartRow)\n\t\t\tDisplay.beliefValue.append(beliefValueRow)\n\t\t\tDisplay.beliefColor.append(beliefColorRow)\n\t\t\t\t\n\t@staticmethod\n\tdef drawBeliefSquare(row, col, color, value, model):\n\t\ttileSize = Const.BELIEF_TILE_SIZE\n\t\tx = col * tileSize + tileSize / 2.0\n\t\ty = row * tileSize + tileSize / 2.0\n\t\tif not model.inBounds(x, y): return None\n\t\tcolor = Display._getBeliefSquareColor(color, value)\n\t\treturn Display.drawSquare(Vec2d(x, y), tileSize, color)\n\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef getKeys():\n\t\t#print 'attempt get keys'\n\t\tDisplay._acquireLock()\n\t\t#print 'get keys'\n\t\tkeys = graphicsUtils.keys_waiting() + graphicsUtils.keys_pressed()\n\t\tDisplay._releaseLock()\n\t\treturn keys\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef graphicsSleep(timeToSleep):\n\t\tgraphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''for _ in range(int(timeToSleep / 0.005)):\n\t\t\t#print 'attempt sleep'\n\t\t\tDisplay._acquireLock()\n\t\t\t#print 'sleep'\n\t\t\tgraphicsUtils.sleep(0.001)\n\t\t\tDisplay._releaseLock()\n\t\t\ttime.sleep(0.004)'''\n\t\t\n\t\t#graphicsUtils.sleep(timeToSleep)\n\t\t#time.sleep(timeToSleep)\n\t\t'''startWait = time.time()\n\t\tDisplay._acquireLock()\n\t\ttimeToSleep -= time.time() - startWait\n\t\tgraphicsUtils.refresh()\n\t\tif timeToSleep > 0:\n\t\t\tgraphicsUtils.sleep(timeToSleep)\n\t\tDisplay._releaseLock()'''\n\t\t\t \n\t# make thread safe\n\t@staticmethod\n\tdef updateBelief(color, belief):\n\t\tDisplay._acquireLock()\n\t\ttotal = belief.getSum()\n\t\tif abs(total - 1.0) > 0.001:\n\t\t\traise Exception('belief does not sum to 1 ('+str(total)+'). Use the normalize method.')\n\t\tfor r in range(belief.getNumRows()):\n\t\t\tfor c in range(belief.getNumCols()):\n\t\t\t\tvalue = belief.getProb(r, c)\n\t\t\t\tDisplay._updateBeliefSquare(r, c, value, color)\n\t\tDisplay._releaseLock()\n\t\n\t# make thread safe\n\t@staticmethod\n\tdef move(obj, delta):\n\t\t#print 'attempt move'\n\t\tDisplay._acquireLock()\n\t\t#print 'move'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.move_by(parts, delta.x, delta.y)\n\t\t#print 'end move'\n\t\tDisplay._releaseLock()\n\t\t\n\t# make thread safe\n\t@staticmethod\n\tdef rotate(obj, angle):\n\t\tif angle == 0: return\n\t\t#print 'attempt rotate'\n\t\tDisplay._acquireLock()\n\t\t#print 'rotate'\n\t\tparts = Display.partDict[obj]\n\t\t#assert(parts)\n\t\tgraphicsUtils.rotate_by(parts, angle)\n\t\tDisplay._releaseLock()\n\t\t\t\t\n\t@staticmethod\n\tdef _getBeliefSquareColor(color, value):\n\t\tvalue = min(1.0, value * 15)\n\t\tsaturation = value\n\t\thue = Display.COLOR_HUES[color]\n\t\tr, g, b = colorsys.hsv_to_rgb(hue, saturation, 1.0)\n\t\tcolor = graphicsUtils.formatColor(r, g, b)\n\t\treturn color\t\t\n\t\n\t@staticmethod\n\tdef _isVisible(value):\n\t\treturn value >= Display.VISIBLE_CUTTOFF\n\t\n\t@staticmethod\n\tdef _updateBeliefSquare(r, c, value, colorName):\n\t\tpart = Display.beliefParts[r][c]\n\t\tif part == None: return\n\t\toldValue = Display.beliefValue[r][c]\n\t\toldColor = Display.beliefColor[r][c]\n\t\twasVisible = Display._isVisible(oldValue)\n\t\tisVisible = Display._isVisible(value) \n\t\tif not isVisible: value = 0.0\n\t\tif oldColor != colorName and oldValue >= value: return\n\t\tif not isVisible and not wasVisible: return\n\t\tcolor = Display._getBeliefSquareColor(colorName, value)\n\t\tgraphicsUtils.changeColor(part, color)\n\t\tDisplay.beliefValue[r][c] = value\n\t\tDisplay.beliefColor[r][c] = colorName\n\t\t\n\t@staticmethod\n\tdef _acquireLock():\n\t\treturn\n\t\t#print 'acquire'\n\t\treturn Display.graphicsLock.acquire()\n\t\n\t@staticmethod\n\tdef _releaseLock():\n\t\treturn\n\t\t#print 'release'\n\t\treturn Display.graphicsLock.release()\n\t \n\t####################################\n\t# Depreicated\n\t####################################\n\t\t\n\t@staticmethod\n\tdef _remove(obj):\n\t\tparts = Display.partDict[obj]\n\t\tgraphicsUtils.remove_from_screen(parts);\n\t\t\n\t@staticmethod\n\tdef redrawObservations(observations):\n\t\traise Exception('depreicated')\n\t\tfor obs in Display.observations:\n\t\t\tDisplay._remove(obs)\n\t\tfor obs in observations:\n\t\t\tDisplay.drawObservation(obs)\n\t\tDisplay.observations = observations\n", "description": null, "category": "graphics", "imports": ["from . import graphicsUtils", "from engine.model.car.car import Car", "from engine.const import Const", "from engine.model.observation import Observation", "from engine.vector import Vec2d", "import colorsys", "import threading"]}], [{"term": "def", "name": "main", "data": "def main():\n\tglobal brick_knocked\n\tglobal scores\n\tgraphics = BreakoutGraphics()\n\tdeath = 0\n\tscoreboard = GLabel(f'Score: {scores}')\n\tscoreboard.font = '-30'\n\tscoreboard.color = 'seagreen'\n\tgraphics.window.add(scoreboard, x=0, y=scoreboard.height)\n\tlives_left = GLabel(f'Lives: {NUM_LIVES-death}')\n\tlives_left.font = '-20'\n\tlives_left.color = 'crimson'\n\tgraphics.window.add(lives_left, x=10, y=graphics.window.height)\n\tsign = GRect(300, 40)\n\tsign.filled = True\n\tsign.color = 'seagreen'\n\tsign.fill_color = 'seagreen'\n\tsign_double = GLabel('Score Doubled!!!')\n\tsign_double.font = '-40'\n\tsign_double.color = 'white'\n\tsign_bigger = GLabel('Bigger paddle!!!')\n\tsign_bigger.font = '-40'\n\tsign_bigger.color = 'white'\n\n\twhile True:\n\t\tdx = graphics.get_dx()\n\t\tdy = graphics.get_dy()\n\t\tgraphics.ball.move(dx, dy)\n\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.width > graphics.window.width:\n\t\t\tgraphics.set_dx()\n\t\tif graphics.ball.y <= 0:\n\t\t\tgraphics.set_dy()\n\t\tif graphics.ball.y > graphics.window.height:\n\t\t\tgraphics.return_ball()\n\t\t\tdeath += 1\n\t\t\tlives_left.text = f'Lives: {NUM_LIVES-death}'\n\t\t\tif death == NUM_LIVES:\n\t\t\t\tbreak\n\t\t# These are the four collision points of the ball.\n\t\tcollision1 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y)\n\t\tcollision2 = graphics.window.get_object_at(graphics.ball.x+graphics.ball.width, graphics.ball.y)\n\t\tcollision3 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y+graphics.ball.height)\n\t\tcollision4 = graphics.window.get_object_at(graphics.ball.x+graphics.ball.width,\n\t\t\t\t\t\t\t\t\t\t\t\t   graphics.ball.y+graphics.ball.height)\n\t\tif collision1 is not None:\n\t\t\tif collision1 is not graphics.paddle:\n\t\t\t\tif collision1 is not scoreboard:\n\t\t\t\t\tif collision1 is not lives_left:\n\t\t\t\t\t\tgraphics.window.remove(collision1)\n\t\t\t\t\t\tbrick_knocked += 1\n\t\t\t\t\t\tif collision1 is graphics.brickred1:\n\t\t\t\t\t\t\tscores *= 2\n\t\t\t\t\t\t\tdouble_score(graphics, sign, sign_double)\n\t\t\t\t\t\telif collision1 is graphics.brickred2:\n\t\t\t\t\t\t\tscores *= 2\n\t\t\t\t\t\t\tdouble_score(graphics, sign, sign_double)\n\t\t\t\t\t\telif collision1 is graphics.brickred3:\n\t\t\t\t\t\t\tscores *= 2\n\t\t\t\t\t\t\tdouble_score(graphics, sign, sign_double)\n\t\t\t\t\t\telif collision1 is graphics.brickblue1:\n\t\t\t\t\t\t\tscores += 1\n\t\t\t\t\t\t\tgraphics.bigger_paddle()\n\t\t\t\t\t\t\tpaddle_bigger(graphics, sign, sign_bigger)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tscores += 1\n\t\t\t\t\t\tscoreboard.text = f'Score: {scores}'\n\t\t\t\t\t\tgraphics.set_dy()\n\t\t\tif collision1 is graphics.paddle and dy > 0:\n\t\t\t\tgraphics.set_dy()\n\t\telif collision2 is not None:\n\t\t\tif collision2 is not graphics.paddle:\n\t\t\t\tif collision2 is not scoreboard:\n\t\t\t\t\tif collision2 is not lives_left:\n\t\t\t\t\t\tgraphics.window.remove(collision2)\n\t\t\t\t\t\tbrick_knocked += 1\n\t\t\t\t\t\tif collision2 is graphics.brickred1:\n\t\t\t\t\t\t\tscores *= 2\n\t\t\t\t\t\t\tdouble_score(graphics, sign, sign_double)\n\t\t\t\t\t\telif collision2 is graphics.brickred2:\n\t\t\t\t\t\t\tscores *= 2\n\t\t\t\t\t\t\tdouble_score(graphics, sign, sign_double)\n\t\t\t\t\t\telif collision2 is graphics.brickred3:\n\t\t\t\t\t\t\tscores *= 2\n\t\t\t\t\t\t\tdouble_score(graphics, sign, sign_double)\n\t\t\t\t\t\telif collision2 is graphics.brickblue1:\n\t\t\t\t\t\t\tscores += 1\n\t\t\t\t\t\t\tgraphics.bigger_paddle()\n\t\t\t\t\t\t\tpaddle_bigger(graphics, sign, sign_bigger)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tscores += 1\n\t\t\t\t\t\tscoreboard.text = f'Score: {scores}'\n\t\t\t\t\t\tgraphics.set_dy()\n\t\t\tif collision2 is graphics.paddle and dy > 0:\n\t\t\t\tgraphics.set_dy()\n\t\telif collision3 is not None:\n\t\t\tif collision3 is not graphics.paddle:\n\t\t\t\tif collision3 is not scoreboard:\n\t\t\t\t\tif collision3 is not lives_left:\n\t\t\t\t\t\tgraphics.window.remove(collision3)\n\t\t\t\t\t\tbrick_knocked += 1\n\t\t\t\t\t\tif collision3 is graphics.brickred1:\n\t\t\t\t\t\t\tscores *= 2\n\t\t\t\t\t\t\tdouble_score(graphics, sign, sign_double)\n\t\t\t\t\t\telif collision3 is graphics.brickred2:\n\t\t\t\t\t\t\tscores *= 2\n\t\t\t\t\t\t\tdouble_score(graphics, sign, sign_double)\n\t\t\t\t\t\telif collision3 is graphics.brickred3:\n\t\t\t\t\t\t\tscores *= 2\n\t\t\t\t\t\t\tdouble_score(graphics, sign, sign_double)\n\t\t\t\t\t\telif collision3 is graphics.brickblue1:\n\t\t\t\t\t\t\tscores += 1\n\t\t\t\t\t\t\tgraphics.bigger_paddle()\n\t\t\t\t\t\t\tpaddle_bigger(graphics, sign, sign_bigger)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tscores += 1\n\t\t\t\t\t\tscoreboard.text = f'Score: {scores}'\n\t\t\t\t\t\tgraphics.set_dy()\n\t\t\tif collision3 is graphics.paddle and dy > 0:\n\t\t\t\tgraphics.set_dy()\n\t\telif collision4 is not None:\n\t\t\tif collision4 is not graphics.paddle:\n\t\t\t\tif collision4 is not scoreboard:\n\t\t\t\t\tif collision4 is not lives_left:\n\t\t\t\t\t\tgraphics.window.remove(collision4)\n\t\t\t\t\t\tbrick_knocked += 1\n\t\t\t\t\t\tif collision4 is graphics.brickred1:\n\t\t\t\t\t\t\tscores *= 2\n\t\t\t\t\t\t\tdouble_score(graphics, sign, sign_double)\n\t\t\t\t\t\telif collision4 is graphics.brickred2:\n\t\t\t\t\t\t\tscores *= 2\n\t\t\t\t\t\t\tdouble_score(graphics, sign, sign_double)\n\t\t\t\t\t\telif collision4 is graphics.brickred3:\n\t\t\t\t\t\t\tscores *= 2\n\t\t\t\t\t\t\tdouble_score(graphics, sign, sign_double)\n\t\t\t\t\t\telif collision4 is graphics.brickblue1:\n\t\t\t\t\t\t\tscores += 1\n\t\t\t\t\t\t\tgraphics.bigger_paddle()\n\t\t\t\t\t\t\tpaddle_bigger(graphics, sign, sign_bigger)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tscores += 1\n\t\t\t\t\t\tscoreboard.text = f'Score: {scores}'\n\t\t\t\t\t\tgraphics.set_dy()\n\t\t\tif collision4 is graphics.paddle and dy > 0:\n\t\t\t\tgraphics.set_dy()\n\t\tif brick_knocked == graphics.brick_num:\n\t\t\tbreak\n\t\tpause(FRAME_RATE)\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from campy.graphics.gobjects import GOval, GRect, GLabel", "from breakoutgraphics_extension import BreakoutGraphics"]}, {"term": "def", "name": "double_score", "data": "def double_score(graphics, sign, sign_double):\n\t\"\"\"\n\t:param graphics: BreakoutGraphics\n\t:param sign: GRect\n\t:param sign_double: GLabel\n\n\tThis function pops a message on the top-right corner\n\tof the window.\n\t\"\"\"\n\tgraphics.window.add(sign, x=graphics.window.width - sign.width, y=0)\n\tgraphics.window.add(sign_double, x=150, y=sign_double.height)\n\tpause(100)\n\tgraphics.window.remove(sign)\n\tgraphics.window.remove(sign_double)\n\tpause(100)\n\tgraphics.window.add(sign, x=graphics.window.width - sign.width, y=0)\n\tgraphics.window.add(sign_double, x=150, y=sign_double.height)\n\tpause(100)\n\tgraphics.window.remove(sign)\n\tgraphics.window.remove(sign_double)\n\n", "description": "\n\t:param graphics: BreakoutGraphics\n\t:param sign: GRect\n\t:param sign_double: GLabel\n\n\tThis function pops a message on the top-right corner\n\tof the window.\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from campy.graphics.gobjects import GOval, GRect, GLabel", "from breakoutgraphics_extension import BreakoutGraphics"]}, {"term": "def", "name": "paddle_bigger", "data": "def paddle_bigger(graphics, sign, sign_bigger):\n\t\"\"\"\n\t:param graphics: BreakoutGraphics\n\t:param sign: GRect\n\t:param sign_bigger: GLabel\n\n\tThis function pops a message on the top-right corner\n\tof the window.\n\t\"\"\"\n\tgraphics.window.add(sign, x=graphics.window.width - sign.width, y=0)\n\tgraphics.window.add(sign_bigger, x=150, y=sign_bigger.height)\n\tpause(100)\n\tgraphics.window.remove(sign)\n\tgraphics.window.remove(sign_bigger)\n\tpause(100)\n\tgraphics.window.add(sign, x=graphics.window.width - sign.width, y=0)\n\tgraphics.window.add(sign_bigger, x=150, y=sign_bigger.height)\n\tpause(100)\n\tgraphics.window.remove(sign)\n\tgraphics.window.remove(sign_bigger)\n\n", "description": "\n\t:param graphics: BreakoutGraphics\n\t:param sign: GRect\n\t:param sign_bigger: GLabel\n\n\tThis function pops a message on the top-right corner\n\tof the window.\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from campy.graphics.gobjects import GOval, GRect, GLabel", "from breakoutgraphics_extension import BreakoutGraphics"]}], [], [{"term": "def", "name": "openWindow", "data": "def openWindow(width=800, height=600, title=\"Graphics Window\"):\n\t\"\"\" Opens a window of specified size, with specified title.\n\tDefault 800x600 pixels, title \"Graphics Window\".\n\n\t@param width Width of the window in pixels\n\t@param height Height of the window in pixels\n\t@param title Title of the window (String)\n\t\"\"\"\n\tglobal _window\n\tglobal _current_point\n\n\t# Open the window\n\t_window = graphics.GraphWin(title, width, height)\n\n\t# Set a current point to start drawing from as (0, 0)\n\t_current_point = graphics.Point(0, 0)\n\n", "description": " Opens a window of specified size, with specified title.\n\tDefault 800x600 pixels, title \"Graphics Window\".\n\n\t@param width Width of the window in pixels\n\t@param height Height of the window in pixels\n\t@param title Title of the window (String)\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "closeWindow", "data": "def closeWindow():\n\t\"\"\"Closes graphics window\n\t\"\"\"\n\t_window.close()\n\n", "description": "Closes graphics window\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "updateCanvas", "data": "def updateCanvas():\n\t\"\"\"Updates the canvas. I.E. draws all the objects onto the canvas\n\tthat have been added since the last update or clear. \n\t\"\"\"\n\tglobal _clear_canvas\n\tif _clear_canvas:\n\t\tfor i in _window.items[:]:\n\t\t\ti.undraw()\n\t\tdel _window.items[:]\n\t\t_window.items = []\n\t\tdel _objects[:_clear_canvas]\n\t_clear_canvas = False\n\n\t# Draw all objects that belong on the canvas in the order they were added\n\tfor i in _objects:\n\t\ttry:\n\t\t\ti.draw(_window)\n\t\texcept graphics.GraphicsError as e:\n\t\t\t# Catch error where object is already drawn - this is okay.\n\t\t\tpass\n\n", "description": "Updates the canvas. I.E. draws all the objects onto the canvas\n\tthat have been added since the last update or clear. \n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "clearCanvas", "data": "def clearCanvas():\n\t\"\"\"Clears the canvas to background colour.\n\t\"\"\"\n\tglobal _clear_canvas\n\tglobal _objects\n\t_clear_canvas = len(_objects)\n\n", "description": "Clears the canvas to background colour.\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "setCanvasColour", "data": "def setCanvasColour(colour):\n\t\"\"\"Sets the background colour of the canvas to the specified colour\n\t\"\"\"\n\t_window.setBackground(colour)\n\n", "description": "Sets the background colour of the canvas to the specified colour\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "moveTo", "data": "def moveTo(x, y):\n\t\"\"\"Moves the graphics pen to specified cooordinate\n\t@param x X coordinate to move graphics pen to\n\t@param y Y coordinate to move graphics pen to\n\t\"\"\"\n\t_current_point.x = x\n\t_current_point.y = y\n\n", "description": "Moves the graphics pen to specified cooordinate\n\t@param x X coordinate to move graphics pen to\n\t@param y Y coordinate to move graphics pen to\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "drawLine", "data": "def drawLine(x, y):\n\t\"\"\"Draws a line from the current graphics pen point given\n\tby vector (x, y). Moves the graphics pen point\n\t@param x Length of line in X direction\n\t@param y Length of line in Y direction\n\t\"\"\"\n\t# For some silly reason, the line takes its fill colour\n\tshape = graphics.Line(_current_point,\n\t\t\t\t\t\t  graphics.Point(_current_point.x + x, _current_point.y + y))\n\tshape.setFill(_current_line_colour)\n\tshape.setWidth(_current_line_thickness)\n\t_objects.append(shape)\n\tmoveTo(_current_point.x + x, _current_point.y + y)\n\n", "description": "Draws a line from the current graphics pen point given\n\tby vector (x, y). Moves the graphics pen point\n\t@param x Length of line in X direction\n\t@param y Length of line in Y direction\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "drawImage", "data": "def drawImage(filename):\n\t\"\"\"Draws an image given by filename (should be in the same folder as your\n\tpython script). The top left of the image is the current graphics pen point.\n\t@param filename Filename of image to display. Must be a gif.\n\t\"\"\"\n\tim = graphics.Image(_current_point, [filename])\n\tim.config[\"anchor\"] = \"nw\"\n\t_objects.append(im)\n\n", "description": "Draws an image given by filename (should be in the same folder as your\n\tpython script). The top left of the image is the current graphics pen point.\n\t@param filename Filename of image to display. Must be a gif.\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "drawText", "data": "def drawText(text):\n\t\"\"\"Draws text anchored at graphics pen point. The colour is given by the\n\tcurrent line colour, and the properties of the text can be changed by\n\tsetTextProperties().\n\t@param text String to write to screen\n\t\"\"\"\n\ttext = graphics.Text(_current_point, text)\n\ttext.setFace(_text_properties[\"face\"])\n\ttext.setSize(_text_properties[\"size\"])\n\ttext.setStyle(_text_properties[\"style\"])\n\ttext.setTextColor(_current_line_colour)\n\t# Hack into the graphics library to set both justification and anchor point\n\ttext.config[\"justify\"] = _text_properties[\"align\"]\n\ttext.config[\"anchor\"] = _text_properties[\"anchor\"]\n\t_objects.append(text)\n\n", "description": "Draws text anchored at graphics pen point. The colour is given by the\n\tcurrent line colour, and the properties of the text can be changed by\n\tsetTextProperties().\n\t@param text String to write to screen\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "setTextProperties", "data": "def setTextProperties(face=None, size=None, style=None, align=None, anchor=None):\n\t\"\"\"Sets the properties of the next text objects to write.\n\t@param face Face (font) of the text. Legal values: \"helvetica\", \"arial\",\n\t\"courier\", \"times roman\". Passing None will not change the current font.\n\t@param size Size of the text, numberical, range 5-36. Passing None will leave this\n\talone\n\t@param style Style of the text. Legal values: \"bold\",\"normal\",\"italic\",\n\t\"bold italic\". Passing None will not change the current style.\n\t@param align Alignment of text from anchor point. Legal values:\n\t\"centre\", \"left\", right\".\n\t@param anchor Anchor location. Defines where the text is drawn relative to the\n\tgraphics pen point. Legal values: \"n\", \"ne\", \"e\", \"se\", \"s\", \"sw\", \"w\", \"nw\", or\n\t\"centre\"\n\t\"\"\"\n\tif face != None:\n\t\t_text_properties[\"face\"] = face\n\tif size != None:\n\t\t_text_properties[\"size\"] = size\n\tif style != None:\n\t\t_text_properties[\"style\"] = style\n\n\tif align != None:\n\t\t# Align requires manual processing since it's an extension on the\n\t\t# graphics library in use.\n\t\tif align in [\"centre\", \"left\", \"right\"]:\n\t\t\t# Americanize\n\t\t\tif align == \"centre\":\n\t\t\t\talign = \"center\"\n\t\t\t_text_properties[\"align\"] = align\n\t\telse:\n\t\t\traise graphics.GraphicsError(\"Invalid align string\")\n\n\tif anchor != None:\n\t\t# Anchor requires manual processing since it's an extension on the\n\t\t# graphics library in use.\n\t\tif anchor in [\"n\", \"ne\", \"e\", \"se\", \"s\", \"sw\", \"w\", \"nw\", \"centre\"]:\n\t\t\t# Americanize\n\t\t\tif anchor == \"centre\":\n\t\t\t\tanchor = \"center\"\n\t\t\t_text_properties[\"anchor\"] = anchor\n\t\telse:\n\t\t\traise graphics.GraphicsError(\"Invalid anchor string\")\n\n", "description": "Sets the properties of the next text objects to write.\n\t@param face Face (font) of the text. Legal values: \"helvetica\", \"arial\",\n\t\"courier\", \"times roman\". Passing None will not change the current font.\n\t@param size Size of the text, numberical, range 5-36. Passing None will leave this\n\talone\n\t@param style Style of the text. Legal values: \"bold\",\"normal\",\"italic\",\n\t\"bold italic\". Passing None will not change the current style.\n\t@param align Alignment of text from anchor point. Legal values:\n\t\"centre\", \"left\", right\".\n\t@param anchor Anchor location. Defines where the text is drawn relative to the\n\tgraphics pen point. Legal values: \"n\", \"ne\", \"e\", \"se\", \"s\", \"sw\", \"w\", \"nw\", or\n\t\"centre\"\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "setLineColour", "data": "def setLineColour(colour):\n\t\"\"\"Sets the line colour of any subsequent objects to be drawn\n\t@param colour Colour to use, see note in file\n\t\"\"\"\n\tglobal _current_line_colour\n\t_current_line_colour = colour\n\n", "description": "Sets the line colour of any subsequent objects to be drawn\n\t@param colour Colour to use, see note in file\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "setLineThickness", "data": "def setLineThickness(thickness):\n\t\"\"\"Sets the line thickness of any subsequent objects to be drawn\n\t@param thickness Thickness of lines in pixels\n\t\"\"\"\n\tglobal _current_line_thickness\n\t_current_line_thickness = thickness\n\n", "description": "Sets the line thickness of any subsequent objects to be drawn\n\t@param thickness Thickness of lines in pixels\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "waitForKeyPress", "data": "def waitForKeyPress():\n\t\"\"\"Waits for a key press and returns press as string.\n\n\t@return the key pressed\n\t\"\"\"\n\treturn _window.getKey()\n\n", "description": "Waits for a key press and returns press as string.\n\n\t@return the key pressed\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "getKeyPress", "data": "def getKeyPress():\n\t\"\"\"Waits for a key press and returns press as string.\n\n\t@return the key pressed\n\t\"\"\"\n\treturn _window.checkKey()\n\n", "description": "Waits for a key press and returns press as string.\n\n\t@return the key pressed\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "waitForMouseClick", "data": "def waitForMouseClick():\n\t\"\"\"Waits for a mouse click and returns the coordinates of\n\tthe click as a tuple.\n\n\t@return (x, y) x and y coordinates of mouse click.\n\t\"\"\"\n\t# Call graphics library and return coordinates of click as tuple\n\tmouse_point = _window.getMouse()\n\treturn (mouse_point.x, mouse_point.y)\n\n", "description": "Waits for a mouse click and returns the coordinates of\n\tthe click as a tuple.\n\n\t@return (x, y) x and y coordinates of mouse click.\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "getRGBColour", "data": "def getRGBColour(r, g, b):\n\t\"\"\"Returns a string that represents any RGB colour\n\t@param r Red component of colour (0-255)\n\t@param g Green component of colour (0-255)\n\t@param b Blue component of colour (0-255)\n\t@return colour to use in functions\n\t\"\"\"\n\treturn graphics.color_rgb(r, g, b)\n", "description": "Returns a string that represents any RGB colour\n\t@param r Red component of colour (0-255)\n\t@param g Green component of colour (0-255)\n\t@param b Blue component of colour (0-255)\n\t@return colour to use in functions\n\t", "category": "graphics", "imports": ["import graphics"]}], [{"term": "def", "name": "openWindow", "data": "def openWindow(width=800, height=600, title=\"Graphics Window\"):\n\t\"\"\" Opens a window of specified size, with specified title.\n\tDefault 800x600 pixels, title \"Graphics Window\".\n\n\t@param width Width of the window in pixels\n\t@param height Height of the window in pixels\n\t@param title Title of the window (String)\n\t\"\"\"\n\tglobal _window\n\tglobal _current_point\n\n\t# Open the window\n\t_window = graphics.GraphWin(title, width, height)\n\n\t# Set a current point to start drawing from as (0, 0)\n\t_current_point = graphics.Point(0, 0)\n\n", "description": " Opens a window of specified size, with specified title.\n\tDefault 800x600 pixels, title \"Graphics Window\".\n\n\t@param width Width of the window in pixels\n\t@param height Height of the window in pixels\n\t@param title Title of the window (String)\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "closeWindow", "data": "def closeWindow():\n\t\"\"\"Closes graphics window\n\t\"\"\"\n\t_window.close()\n\n", "description": "Closes graphics window\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "updateCanvas", "data": "def updateCanvas():\n\t\"\"\"Updates the canvas. I.E. draws all the objects onto the canvas\n\tthat have been added since the last update or clear. \n\t\"\"\"\n\tglobal _clear_canvas\n\tif _clear_canvas:\n\t\tfor i in _window.items[:]:\n\t\t\ti.undraw()\n\t\tdel _window.items[:]\n\t\t_window.items = []\n\t\tdel _objects[:_clear_canvas]\n\t_clear_canvas = False\n\n\t# Draw all objects that belong on the canvas in the order they were added\n\tfor i in _objects:\n\t\ttry:\n\t\t\ti.draw(_window)\n\t\texcept graphics.GraphicsError as e:\n\t\t\t# Catch error where object is already drawn - this is okay.\n\t\t\tpass\n\n", "description": "Updates the canvas. I.E. draws all the objects onto the canvas\n\tthat have been added since the last update or clear. \n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "clearCanvas", "data": "def clearCanvas():\n\t\"\"\"Clears the canvas to background colour.\n\t\"\"\"\n\tglobal _clear_canvas\n\tglobal _objects\n\t_clear_canvas = len(_objects)\n\n", "description": "Clears the canvas to background colour.\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "setCanvasColour", "data": "def setCanvasColour(colour):\n\t\"\"\"Sets the background colour of the canvas to the specified colour\n\t\"\"\"\n\t_window.setBackground(colour)\n\n", "description": "Sets the background colour of the canvas to the specified colour\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "moveTo", "data": "def moveTo(x, y):\n\t\"\"\"Moves the graphics pen to specified cooordinate\n\t@param x X coordinate to move graphics pen to\n\t@param y Y coordinate to move graphics pen to\n\t\"\"\"\n\t_current_point.x = x\n\t_current_point.y = y\n\n", "description": "Moves the graphics pen to specified cooordinate\n\t@param x X coordinate to move graphics pen to\n\t@param y Y coordinate to move graphics pen to\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "drawLine", "data": "def drawLine(x, y):\n\t\"\"\"Draws a line from the current graphics pen point given\n\tby vector (x, y). Moves the graphics pen point\n\t@param x Length of line in X direction\n\t@param y Length of line in Y direction\n\t\"\"\"\n\t# For some silly reason, the line takes its fill colour\n\tshape = graphics.Line(_current_point,\n\t\t\t\t\t\t  graphics.Point(_current_point.x + x, _current_point.y + y))\n\tshape.setFill(_current_line_colour)\n\tshape.setWidth(_current_line_thickness)\n\t_objects.append(shape)\n\tmoveTo(_current_point.x + x, _current_point.y + y)\n\n", "description": "Draws a line from the current graphics pen point given\n\tby vector (x, y). Moves the graphics pen point\n\t@param x Length of line in X direction\n\t@param y Length of line in Y direction\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "drawImage", "data": "def drawImage(filename):\n\t\"\"\"Draws an image given by filename (should be in the same folder as your\n\tpython script). The top left of the image is the current graphics pen point.\n\t@param filename Filename of image to display. Must be a gif.\n\t\"\"\"\n\tim = graphics.Image(_current_point, [filename])\n\tim.config[\"anchor\"] = \"nw\"\n\t_objects.append(im)\n\n", "description": "Draws an image given by filename (should be in the same folder as your\n\tpython script). The top left of the image is the current graphics pen point.\n\t@param filename Filename of image to display. Must be a gif.\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "drawText", "data": "def drawText(text):\n\t\"\"\"Draws text anchored at graphics pen point. The colour is given by the\n\tcurrent line colour, and the properties of the text can be changed by\n\tsetTextProperties().\n\t@param text String to write to screen\n\t\"\"\"\n\ttext = graphics.Text(_current_point, text)\n\ttext.setFace(_text_properties[\"face\"])\n\ttext.setSize(_text_properties[\"size\"])\n\ttext.setStyle(_text_properties[\"style\"])\n\ttext.setTextColor(_current_line_colour)\n\t# Hack into the graphics library to set both justification and anchor point\n\ttext.config[\"justify\"] = _text_properties[\"align\"]\n\ttext.config[\"anchor\"] = _text_properties[\"anchor\"]\n\t_objects.append(text)\n\n", "description": "Draws text anchored at graphics pen point. The colour is given by the\n\tcurrent line colour, and the properties of the text can be changed by\n\tsetTextProperties().\n\t@param text String to write to screen\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "setTextProperties", "data": "def setTextProperties(face=None, size=None, style=None, align=None, anchor=None):\n\t\"\"\"Sets the properties of the next text objects to write.\n\t@param face Face (font) of the text. Legal values: \"helvetica\", \"arial\",\n\t\"courier\", \"times roman\". Passing None will not change the current font.\n\t@param size Size of the text, numberical, range 5-36. Passing None will leave this\n\talone\n\t@param style Style of the text. Legal values: \"bold\",\"normal\",\"italic\",\n\t\"bold italic\". Passing None will not change the current style.\n\t@param align Alignment of text from anchor point. Legal values:\n\t\"centre\", \"left\", right\".\n\t@param anchor Anchor location. Defines where the text is drawn relative to the\n\tgraphics pen point. Legal values: \"n\", \"ne\", \"e\", \"se\", \"s\", \"sw\", \"w\", \"nw\", or\n\t\"centre\"\n\t\"\"\"\n\tif face != None:\n\t\t_text_properties[\"face\"] = face\n\tif size != None:\n\t\t_text_properties[\"size\"] = size\n\tif style != None:\n\t\t_text_properties[\"style\"] = style\n\n\tif align != None:\n\t\t# Align requires manual processing since it's an extension on the\n\t\t# graphics library in use.\n\t\tif align in [\"centre\", \"left\", \"right\"]:\n\t\t\t# Americanize\n\t\t\tif align == \"centre\":\n\t\t\t\talign = \"center\"\n\t\t\t_text_properties[\"align\"] = align\n\t\telse:\n\t\t\traise graphics.GraphicsError(\"Invalid align string\")\n\n\tif anchor != None:\n\t\t# Anchor requires manual processing since it's an extension on the\n\t\t# graphics library in use.\n\t\tif anchor in [\"n\", \"ne\", \"e\", \"se\", \"s\", \"sw\", \"w\", \"nw\", \"centre\"]:\n\t\t\t# Americanize\n\t\t\tif anchor == \"centre\":\n\t\t\t\tanchor = \"center\"\n\t\t\t_text_properties[\"anchor\"] = anchor\n\t\telse:\n\t\t\traise graphics.GraphicsError(\"Invalid anchor string\")\n\n", "description": "Sets the properties of the next text objects to write.\n\t@param face Face (font) of the text. Legal values: \"helvetica\", \"arial\",\n\t\"courier\", \"times roman\". Passing None will not change the current font.\n\t@param size Size of the text, numberical, range 5-36. Passing None will leave this\n\talone\n\t@param style Style of the text. Legal values: \"bold\",\"normal\",\"italic\",\n\t\"bold italic\". Passing None will not change the current style.\n\t@param align Alignment of text from anchor point. Legal values:\n\t\"centre\", \"left\", right\".\n\t@param anchor Anchor location. Defines where the text is drawn relative to the\n\tgraphics pen point. Legal values: \"n\", \"ne\", \"e\", \"se\", \"s\", \"sw\", \"w\", \"nw\", or\n\t\"centre\"\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "setLineColour", "data": "def setLineColour(colour):\n\t\"\"\"Sets the line colour of any subsequent objects to be drawn\n\t@param colour Colour to use, see note in file\n\t\"\"\"\n\tglobal _current_line_colour\n\t_current_line_colour = colour\n\n", "description": "Sets the line colour of any subsequent objects to be drawn\n\t@param colour Colour to use, see note in file\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "setLineThickness", "data": "def setLineThickness(thickness):\n\t\"\"\"Sets the line thickness of any subsequent objects to be drawn\n\t@param thickness Thickness of lines in pixels\n\t\"\"\"\n\tglobal _current_line_thickness\n\t_current_line_thickness = thickness\n\n", "description": "Sets the line thickness of any subsequent objects to be drawn\n\t@param thickness Thickness of lines in pixels\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "waitForKeyPress", "data": "def waitForKeyPress():\n\t\"\"\"Waits for a key press and returns press as string.\n\n\t@return the key pressed\n\t\"\"\"\n\treturn _window.getKey()\n\n", "description": "Waits for a key press and returns press as string.\n\n\t@return the key pressed\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "getKeyPress", "data": "def getKeyPress():\n\t\"\"\"Waits for a key press and returns press as string.\n\n\t@return the key pressed\n\t\"\"\"\n\treturn _window.checkKey()\n\n", "description": "Waits for a key press and returns press as string.\n\n\t@return the key pressed\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "waitForMouseClick", "data": "def waitForMouseClick():\n\t\"\"\"Waits for a mouse click and returns the coordinates of\n\tthe click as a tuple.\n\n\t@return (x, y) x and y coordinates of mouse click.\n\t\"\"\"\n\t# Call graphics library and return coordinates of click as tuple\n\tmouse_point = _window.getMouse()\n\treturn (mouse_point.x, mouse_point.y)\n\n", "description": "Waits for a mouse click and returns the coordinates of\n\tthe click as a tuple.\n\n\t@return (x, y) x and y coordinates of mouse click.\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "getRGBColour", "data": "def getRGBColour(r, g, b):\n\t\"\"\"Returns a string that represents any RGB colour\n\t@param r Red component of colour (0-255)\n\t@param g Green component of colour (0-255)\n\t@param b Blue component of colour (0-255)\n\t@return colour to use in functions\n\t\"\"\"\n\treturn graphics.color_rgb(r, g, b)\n", "description": "Returns a string that represents any RGB colour\n\t@param r Red component of colour (0-255)\n\t@param g Green component of colour (0-255)\n\t@param b Blue component of colour (0-255)\n\t@return colour to use in functions\n\t", "category": "graphics", "imports": ["import graphics"]}], [{"term": "def", "name": "openWindow", "data": "def openWindow(width=800, height=600, title=\"Graphics Window\"):\n\t\"\"\" Opens a window of specified size, with specified title.\n\tDefault 800x600 pixels, title \"Graphics Window\".\n\n\t@param width Width of the window in pixels\n\t@param height Height of the window in pixels\n\t@param title Title of the window (String)\n\t\"\"\"\n\tglobal _window\n\tglobal _current_point\n\n\t# Open the window\n\t_window = graphics.GraphWin(title, width, height)\n\n\t# Set a current point to start drawing from as (0, 0)\n\t_current_point = graphics.Point(0, 0)\n\n", "description": " Opens a window of specified size, with specified title.\n\tDefault 800x600 pixels, title \"Graphics Window\".\n\n\t@param width Width of the window in pixels\n\t@param height Height of the window in pixels\n\t@param title Title of the window (String)\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "closeWindow", "data": "def closeWindow():\n\t\"\"\"Closes graphics window\n\t\"\"\"\n\t_window.close()\n\n", "description": "Closes graphics window\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "updateCanvas", "data": "def updateCanvas():\n\t\"\"\"Updates the canvas. I.E. draws all the objects onto the canvas\n\tthat have been added since the last update or clear. \n\t\"\"\"\n\tglobal _clear_canvas\n\tif _clear_canvas:\n\t\tfor i in _window.items[:]:\n\t\t\ti.undraw()\n\t\tdel _window.items[:]\n\t\t_window.items = []\n\t\tdel _objects[:_clear_canvas]\n\t_clear_canvas = False\n\n\t# Draw all objects that belong on the canvas in the order they were added\n\tfor i in _objects:\n\t\ttry:\n\t\t\ti.draw(_window)\n\t\texcept graphics.GraphicsError as e:\n\t\t\t# Catch error where object is already drawn - this is okay.\n\t\t\tpass\n\n", "description": "Updates the canvas. I.E. draws all the objects onto the canvas\n\tthat have been added since the last update or clear. \n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "clearCanvas", "data": "def clearCanvas():\n\t\"\"\"Clears the canvas to background colour.\n\t\"\"\"\n\tglobal _clear_canvas\n\tglobal _objects\n\t_clear_canvas = len(_objects)\n\n", "description": "Clears the canvas to background colour.\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "setCanvasColour", "data": "def setCanvasColour(colour):\n\t\"\"\"Sets the background colour of the canvas to the specified colour\n\t\"\"\"\n\t_window.setBackground(colour)\n\n", "description": "Sets the background colour of the canvas to the specified colour\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "moveTo", "data": "def moveTo(x, y):\n\t\"\"\"Moves the graphics pen to specified cooordinate\n\t@param x X coordinate to move graphics pen to\n\t@param y Y coordinate to move graphics pen to\n\t\"\"\"\n\t_current_point.x = x\n\t_current_point.y = y\n\n", "description": "Moves the graphics pen to specified cooordinate\n\t@param x X coordinate to move graphics pen to\n\t@param y Y coordinate to move graphics pen to\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "drawLine", "data": "def drawLine(x, y):\n\t\"\"\"Draws a line from the current graphics pen point given\n\tby vector (x, y). Moves the graphics pen point\n\t@param x Length of line in X direction\n\t@param y Length of line in Y direction\n\t\"\"\"\n\t# For some silly reason, the line takes its fill colour\n\tshape = graphics.Line(_current_point,\n\t\t\t\t\t\t  graphics.Point(_current_point.x + x, _current_point.y + y))\n\tshape.setFill(_current_line_colour)\n\tshape.setWidth(_current_line_thickness)\n\t_objects.append(shape)\n\tmoveTo(_current_point.x + x, _current_point.y + y)\n\n", "description": "Draws a line from the current graphics pen point given\n\tby vector (x, y). Moves the graphics pen point\n\t@param x Length of line in X direction\n\t@param y Length of line in Y direction\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "drawImage", "data": "def drawImage(filename):\n\t\"\"\"Draws an image given by filename (should be in the same folder as your\n\tpython script). The top left of the image is the current graphics pen point.\n\t@param filename Filename of image to display. Must be a gif.\n\t\"\"\"\n\tim = graphics.Image(_current_point, [filename])\n\tim.config[\"anchor\"] = \"nw\"\n\t_objects.append(im)\n\n", "description": "Draws an image given by filename (should be in the same folder as your\n\tpython script). The top left of the image is the current graphics pen point.\n\t@param filename Filename of image to display. Must be a gif.\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "drawText", "data": "def drawText(text):\n\t\"\"\"Draws text anchored at graphics pen point. The colour is given by the\n\tcurrent line colour, and the properties of the text can be changed by\n\tsetTextProperties().\n\t@param text String to write to screen\n\t\"\"\"\n\ttext = graphics.Text(_current_point, text)\n\ttext.setFace(_text_properties[\"face\"])\n\ttext.setSize(_text_properties[\"size\"])\n\ttext.setStyle(_text_properties[\"style\"])\n\ttext.setTextColor(_current_line_colour)\n\t# Hack into the graphics library to set both justification and anchor point\n\ttext.config[\"justify\"] = _text_properties[\"align\"]\n\ttext.config[\"anchor\"] = _text_properties[\"anchor\"]\n\t_objects.append(text)\n\n", "description": "Draws text anchored at graphics pen point. The colour is given by the\n\tcurrent line colour, and the properties of the text can be changed by\n\tsetTextProperties().\n\t@param text String to write to screen\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "setTextProperties", "data": "def setTextProperties(face=None, size=None, style=None, align=None, anchor=None):\n\t\"\"\"Sets the properties of the next text objects to write.\n\t@param face Face (font) of the text. Legal values: \"helvetica\", \"arial\",\n\t\"courier\", \"times roman\". Passing None will not change the current font.\n\t@param size Size of the text, numberical, range 5-36. Passing None will leave this\n\talone\n\t@param style Style of the text. Legal values: \"bold\",\"normal\",\"italic\",\n\t\"bold italic\". Passing None will not change the current style.\n\t@param align Alignment of text from anchor point. Legal values:\n\t\"centre\", \"left\", right\".\n\t@param anchor Anchor location. Defines where the text is drawn relative to the\n\tgraphics pen point. Legal values: \"n\", \"ne\", \"e\", \"se\", \"s\", \"sw\", \"w\", \"nw\", or\n\t\"centre\"\n\t\"\"\"\n\tif face != None:\n\t\t_text_properties[\"face\"] = face\n\tif size != None:\n\t\t_text_properties[\"size\"] = size\n\tif style != None:\n\t\t_text_properties[\"style\"] = style\n\n\tif align != None:\n\t\t# Align requires manual processing since it's an extension on the\n\t\t# graphics library in use.\n\t\tif align in [\"centre\", \"left\", \"right\"]:\n\t\t\t# Americanize\n\t\t\tif align == \"centre\":\n\t\t\t\talign = \"center\"\n\t\t\t_text_properties[\"align\"] = align\n\t\telse:\n\t\t\traise graphics.GraphicsError(\"Invalid align string\")\n\n\tif anchor != None:\n\t\t# Anchor requires manual processing since it's an extension on the\n\t\t# graphics library in use.\n\t\tif anchor in [\"n\", \"ne\", \"e\", \"se\", \"s\", \"sw\", \"w\", \"nw\", \"centre\"]:\n\t\t\t# Americanize\n\t\t\tif anchor == \"centre\":\n\t\t\t\tanchor = \"center\"\n\t\t\t_text_properties[\"anchor\"] = anchor\n\t\telse:\n\t\t\traise graphics.GraphicsError(\"Invalid anchor string\")\n\n", "description": "Sets the properties of the next text objects to write.\n\t@param face Face (font) of the text. Legal values: \"helvetica\", \"arial\",\n\t\"courier\", \"times roman\". Passing None will not change the current font.\n\t@param size Size of the text, numberical, range 5-36. Passing None will leave this\n\talone\n\t@param style Style of the text. Legal values: \"bold\",\"normal\",\"italic\",\n\t\"bold italic\". Passing None will not change the current style.\n\t@param align Alignment of text from anchor point. Legal values:\n\t\"centre\", \"left\", right\".\n\t@param anchor Anchor location. Defines where the text is drawn relative to the\n\tgraphics pen point. Legal values: \"n\", \"ne\", \"e\", \"se\", \"s\", \"sw\", \"w\", \"nw\", or\n\t\"centre\"\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "setLineColour", "data": "def setLineColour(colour):\n\t\"\"\"Sets the line colour of any subsequent objects to be drawn\n\t@param colour Colour to use, see note in file\n\t\"\"\"\n\tglobal _current_line_colour\n\t_current_line_colour = colour\n\n", "description": "Sets the line colour of any subsequent objects to be drawn\n\t@param colour Colour to use, see note in file\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "setLineThickness", "data": "def setLineThickness(thickness):\n\t\"\"\"Sets the line thickness of any subsequent objects to be drawn\n\t@param thickness Thickness of lines in pixels\n\t\"\"\"\n\tglobal _current_line_thickness\n\t_current_line_thickness = thickness\n\n", "description": "Sets the line thickness of any subsequent objects to be drawn\n\t@param thickness Thickness of lines in pixels\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "waitForKeyPress", "data": "def waitForKeyPress():\n\t\"\"\"Waits for a key press and returns press as string.\n\n\t@return the key pressed\n\t\"\"\"\n\treturn _window.getKey()\n\n", "description": "Waits for a key press and returns press as string.\n\n\t@return the key pressed\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "getKeyPress", "data": "def getKeyPress():\n\t\"\"\"Waits for a key press and returns press as string.\n\n\t@return the key pressed\n\t\"\"\"\n\treturn _window.checkKey()\n\n", "description": "Waits for a key press and returns press as string.\n\n\t@return the key pressed\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "waitForMouseClick", "data": "def waitForMouseClick():\n\t\"\"\"Waits for a mouse click and returns the coordinates of\n\tthe click as a tuple.\n\n\t@return (x, y) x and y coordinates of mouse click.\n\t\"\"\"\n\t# Call graphics library and return coordinates of click as tuple\n\tmouse_point = _window.getMouse()\n\treturn (mouse_point.x, mouse_point.y)\n\n", "description": "Waits for a mouse click and returns the coordinates of\n\tthe click as a tuple.\n\n\t@return (x, y) x and y coordinates of mouse click.\n\t", "category": "graphics", "imports": ["import graphics"]}, {"term": "def", "name": "getRGBColour", "data": "def getRGBColour(r, g, b):\n\t\"\"\"Returns a string that represents any RGB colour\n\t@param r Red component of colour (0-255)\n\t@param g Green component of colour (0-255)\n\t@param b Blue component of colour (0-255)\n\t@return colour to use in functions\n\t\"\"\"\n\treturn graphics.color_rgb(r, g, b)\n", "description": "Returns a string that represents any RGB colour\n\t@param r Red component of colour (0-255)\n\t@param g Green component of colour (0-255)\n\t@param b Blue component of colour (0-255)\n\t@return colour to use in functions\n\t", "category": "graphics", "imports": ["import graphics"]}], [{"term": "class", "name": "CGAffineTransform", "data": "class CGAffineTransform(Structure):\n\t_fields_ = [\n\t\t(\"a\", CGFloat),\n\t\t(\"b\", CGFloat),\n\t\t(\"c\", CGFloat),\n\t\t(\"d\", CGFloat),\n\t\t(\"tx\", CGFloat),\n\t\t(\"ty\", CGFloat),\n\t]\n\n", "description": null, "category": "graphics", "imports": ["from ctypes import (", "from rubicon.objc import CGFloat, CGRect", "from rubicon.objc.types import register_preferred_encoding", "from rubicon.objc.runtime import load_library"]}, {"term": "class", "name": "CGEventRef", "data": "class CGEventRef(c_void_p):\n\tpass\n\n", "description": null, "category": "graphics", "imports": ["from ctypes import (", "from rubicon.objc import CGFloat, CGRect", "from rubicon.objc.types import register_preferred_encoding", "from rubicon.objc.runtime import load_library"]}], [{"term": "class", "name": "classGraphicsPresets:", "data": "class GraphicsPresets:\n\t\"\"\"\n\tThis class implements the GraphicsPresets functionality.\n\t\n\tThe graphics presets store a number of graphics settings in a dictionary\n\tand lets you apply them all at once.\n\t\n\tThe graphics presets are stored in an xml file.\n\t\n\tWhen initialised, the graphics presets will check against the currently set\n\tgraphics options to see if any of its options are selected.\n\t\n\tThe graphics presets have the following members:\n\t\n\tGraphicsPresets.entries - a dictionary of dictionaries that store the values\n\tfor each preset graphics setting\n\t\n\tGraphicsPresets.entryNames - a list of the names of the presets in the order\n\tthey appear in the .xml file. These names are the same as the keys for the \n\tGraphicsSettings.entries dictionary\n\t\n\tGraphicsPresets.selectedOption - this is an index into the GraphicsPresets.entryNames\n\tmember or -1 if a preset has not been set\n\t\"\"\"\n\n\tdef __init__(self):\n\t\tsect = ResMgr.openSection(graphicsPresetsResource)\n\t\tself.entries = {}\n\t\tself.entryNames = []\n\t\tself.selectedOption = -1\n\t\tfor group in sect.values():\n\t\t\tif group.asString != '':\n\t\t\t\tentry = {}\n\t\t\t\tfor setting in group.values():\n\t\t\t\t\tif setting.name == 'entry':\n\t\t\t\t\t\tentry[setting.readString('label')] = setting.readInt('activeOption')\n\n\t\t\t\tself.entries[group.asString] = entry\n\t\t\t\tself.entryNames.append(group.asString)\n\n\t\tself.setSelectedOption()\n\n\tdef setSelectedOption(self):\n\t\tself.selectedOption = -1\n\t\tcurrentOptionMap = {}\n\t\tfor currentOption in BigWorld.graphicsSettings():\n\t\t\tcurrentOptionMap[currentOption[0]] = currentOption[1]\n\n\t\tfor i in range(0, len(self.entryNames)):\n\t\t\tfoundOption = True\n\t\t\tfor setting in self.entries[self.entryNames[i]].items():\n\t\t\t\tif currentOptionMap.get(setting[0]) != setting[1]:\n\t\t\t\t\tfoundOption = False\n\t\t\t\t\tbreak\n\n\t\t\tif foundOption == True:\n\t\t\t\tself.selectedOption = i\n\t\t\t\tbreak\n\n\tdef selectGraphicsOptions(self, option):\n\t\tcurrentOption = self.entries[self.entryNames[option]]\n\t\tfor setting in currentOption.items():\n\t\t\ttry:\n\t\t\t\tBigWorld.setGraphicsSetting(setting[0], setting[1])\n\t\t\texcept:\n\t\t\t\tprint 'selectGraphicsOptions: unable to set option ', setting[0]\n\n", "description": "\n\tThis class implements the GraphicsPresets functionality.\n\t\n\tThe graphics presets store a number of graphics settings in a dictionary\n\tand lets you apply them all at once.\n\t\n\tThe graphics presets are stored in an xml file.\n\t\n\tWhen initialised, the graphics presets will check against the currently set\n\tgraphics options to see if any of its options are selected.\n\t\n\tThe graphics presets have the following members:\n\t\n\tGraphicsPresets.entries - a dictionary of dictionaries that store the values\n\tfor each preset graphics setting\n\t\n\tGraphicsPresets.entryNames - a list of the names of the presets in the order\n\tthey appear in the .xml file. These names are the same as the keys for the \n\tGraphicsSettings.entries dictionary\n\t\n\tGraphicsPresets.selectedOption - this is an index into the GraphicsPresets.entryNames\n\tmember or -1 if a preset has not been set\n\t", "category": "graphics", "imports": ["import BigWorld", "import ResMgr"]}], [{"term": "def", "name": "export", "data": "def export(graphics, path, width=None, height=None, **options):\n\t\"\"\"\n\tDraws given graphics into specified image file. The image format is\n\tdetermined from the extension of given file path. Supported extensions are\n\t.bmp, .jpg, .jpeg, .png, .pcx, .pnm, .tif, .tiff, .xpm, .ico, .cur, .svg,\n\t.pdf and .eps.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tpath: str\n\t\t\tFull path of a file to save the image into.\n\t\t\n\t\twidth: float or None\n\t\t\tImage width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage height in device units.\n\t\t\n\t\tdraw_scale: float\n\t\t\tDrawing scaling factor.\n\t\t\n\t\tline_scale: float\n\t\t\tLine scaling factor.\n\t\t\n\t\tfont_scale: float\n\t\t\tFont scaling factor.\n\t\t\n\t\tdpi: int\n\t\t\tImage resolution as dots-per-inch.\n\t\t\n\t\tquality: int\n\t\t\tImage quality in range between 0 and 100 with 0 meaning very poor\n\t\t\tand 100 excellent. This option is only available for JPEG format.\n\t\"\"\"\n\t\n\t# get filename and extension\n\tdirname, filename = os.path.split(path)\n\tbasename, extension = os.path.splitext(filename)\n\textension = extension.lower()\n\t\n\t# export as raster image\n\tif extension in CAIRO_RASTER_TYPES:\n\t\texport_raster(graphics, path, width, height, **options)\n\t\n\t# export as vector format\n\telif extension in CAIRO_VECTOR_TYPES:\n\t\texport_vector(graphics, path, width, height, **options)\n\t\n\t# unsupported image format\n\telse:\n\t\tmessage = \"Unsupported image format! -> %s\" % extension\n\t\traise NotImplementedError(message)\n\n", "description": "\n\tDraws given graphics into specified image file. The image format is\n\tdetermined from the extension of given file path. Supported extensions are\n\t.bmp, .jpg, .jpeg, .png, .pcx, .pnm, .tif, .tiff, .xpm, .ico, .cur, .svg,\n\t.pdf and .eps.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tpath: str\n\t\t\tFull path of a file to save the image into.\n\t\t\n\t\twidth: float or None\n\t\t\tImage width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage height in device units.\n\t\t\n\t\tdraw_scale: float\n\t\t\tDrawing scaling factor.\n\t\t\n\t\tline_scale: float\n\t\t\tLine scaling factor.\n\t\t\n\t\tfont_scale: float\n\t\t\tFont scaling factor.\n\t\t\n\t\tdpi: int\n\t\t\tImage resolution as dots-per-inch.\n\t\t\n\t\tquality: int\n\t\t\tImage quality in range between 0 and 100 with 0 meaning very poor\n\t\t\tand 100 excellent. This option is only available for JPEG format.\n\t", "category": "graphics", "imports": ["import os.path", "import cairo", "import PIL", "import numpy", "from . enums import *", "from . canvas import CairoCanvas"]}, {"term": "def", "name": "export_raster", "data": "def export_raster(graphics, path, width=None, height=None, **options):\n\t\"\"\"\n\tDraws given graphics as raster image into specified file. The image format\n\tis determined from the extension of given file path. Supported extensions\n\tare .bmp, .jpg, .jpeg, .png, .pcx, .tif and .tiff.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tpath: str\n\t\t\tFull path of a file to save the image into.\n\t\t\n\t\twidth: float or None\n\t\t\tImage width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage height in device units.\n\t\t\n\t\tdraw_scale: float\n\t\t\tDrawing scaling factor.\n\t\t\n\t\tline_scale: float\n\t\t\tLine scaling factor.\n\t\t\n\t\tfont_scale: float\n\t\t\tFont scaling factor.\n\t\t\n\t\tdpi: int\n\t\t\tImage resolution as dots-per-inch.\n\t\t\n\t\tquality: int\n\t\t\tImage quality in range between 0 and 100 with 0 meaning very poor\n\t\t\tand 100 excellent. This option is only available for JPEG format.\n\t\"\"\"\n\t\n\t# get filename and extension\n\tdirname, filename = os.path.split(path)\n\tbasename, extension = os.path.splitext(filename)\n\textension = extension.lower()\n\t\n\t# check format\n\tif extension not in CAIRO_RASTER_TYPES:\n\t\tmessage = \"Unsupported image format! -> %s\" % extension\n\t\traise NotImplementedError(message)\n\t\n\t# check size\n\tif not width:\n\t\twidth = EXPORT_WIDTH\n\tif not height:\n\t\theight = EXPORT_HEIGHT\n\t\n\t# create DC\n\tsurface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n\tdc = cairo.Context(surface)\n\tdc.set_fill_rule(cairo.FILL_RULE_EVEN_ODD)\n\t\n\t# init canvas\n\tcanvas = CairoCanvas(dc, width=width, height=height)\n\t\n\tif 'draw_scale' in options:\n\t\tcanvas.draw_scale = options['draw_scale']\n\t\n\tif 'line_scale' in options:\n\t\tcanvas.line_scale = options['line_scale']\n\t\n\tif 'font_scale' in options:\n\t\tcanvas.font_scale = options['font_scale']\n\t\n\t# draw graphics\n\tgraphics.draw(canvas)\n\t\n\t# convert to PIL image (and convert ARGB to RGBA)\n\twidth, height = surface.get_width(), surface.get_height()\n\tdata = numpy.frombuffer(surface.get_data(), numpy.uint8)\n\tdata.shape = (width, height, 4)\n\ttmp = numpy.copy(data[:, :, 0])\n\tdata[:, :, 0] = data[:, :, 2]\n\tdata[:, :, 2] = tmp\n\timage = PIL.Image.frombuffer(\"RGBA\", (width, height), data, 'raw', \"RGBA\", 0, 1)\n\t\n\t# get image options\n\tparams = {\n\t\t'dpi': (options.get('dpi', 72), options.get('dpi', 72)),\n\t\t'quality': options.get('quality', 95)}\n\t\n\t# save to file\n\timage.save(path, CAIRO_RASTER_TYPES[extension], **params)\n\n", "description": "\n\tDraws given graphics as raster image into specified file. The image format\n\tis determined from the extension of given file path. Supported extensions\n\tare .bmp, .jpg, .jpeg, .png, .pcx, .tif and .tiff.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tpath: str\n\t\t\tFull path of a file to save the image into.\n\t\t\n\t\twidth: float or None\n\t\t\tImage width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage height in device units.\n\t\t\n\t\tdraw_scale: float\n\t\t\tDrawing scaling factor.\n\t\t\n\t\tline_scale: float\n\t\t\tLine scaling factor.\n\t\t\n\t\tfont_scale: float\n\t\t\tFont scaling factor.\n\t\t\n\t\tdpi: int\n\t\t\tImage resolution as dots-per-inch.\n\t\t\n\t\tquality: int\n\t\t\tImage quality in range between 0 and 100 with 0 meaning very poor\n\t\t\tand 100 excellent. This option is only available for JPEG format.\n\t", "category": "graphics", "imports": ["import os.path", "import cairo", "import PIL", "import numpy", "from . enums import *", "from . canvas import CairoCanvas"]}, {"term": "def", "name": "export_vector", "data": "def export_vector(graphics, path, width=None, height=None, **options):\n\t\"\"\"\n\tDraws given graphics as vector image into specified file. The image format\n\tis determined from the extension of given file path. Supported extensions\n\tare .svg, .pdf and .eps.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tpath: str\n\t\t\tFull path of a file to save the image into.\n\t\t\n\t\twidth: float or None\n\t\t\tImage width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage height in device units.\n\t\t\n\t\tline_scale: float\n\t\t\tLine scaling factor.\n\t\t\n\t\tfont_scale: float\n\t\t\tFont scaling factor.\n\t\"\"\"\n\t\n\t# get filename and extension\n\tdirname, filename = os.path.split(path)\n\tbasename, extension = os.path.splitext(filename)\n\textension = extension.lower()\n\t\n\t# check format\n\tif extension not in CAIRO_VECTOR_TYPES:\n\t\tmessage = \"Unsupported image format! -> %s\" % extension\n\t\traise NotImplementedError(message)\n\t\n\t# check size\n\tif not width:\n\t\twidth = EXPORT_WIDTH\n\tif not height:\n\t\theight = EXPORT_HEIGHT\n\t\n\t# create surface\n\tif extension == '.svg':\n\t\tsurface = cairo.SVGSurface(path, width, height)\n\t\n\telif extension == '.pdf':\n\t\tsurface = cairo.PDFSurface(path, width, height)\n\t\n\telif extension == '.eps':\n\t\tsurface = cairo.PSSurface(path, width, height)\n\t\tsurface.set_eps(True)\n\t\n\telse:\n\t\tmessage = \"Unsupported image format! -> %s\" % extension\n\t\traise ValueError(message)\n\t\n\t# create DC\n\tdc = cairo.Context(surface)\n\tdc.set_fill_rule(cairo.FILL_RULE_EVEN_ODD)\n\t\n\t# init canvas\n\tcanvas = CairoCanvas(dc, width=width, height=height)\n\t\n\tif 'draw_scale' in options:\n\t\tcanvas.draw_scale = options['draw_scale']\n\t\n\tif 'line_scale' in options:\n\t\tcanvas.line_scale = options['line_scale']\n\t\n\tif 'font_scale' in options:\n\t\tcanvas.font_scale = options['font_scale']\n\t\n\t# draw graphics\n\tgraphics.draw(canvas)\n\t\n\t# save to file\n\tdc.show_page()\n", "description": "\n\tDraws given graphics as vector image into specified file. The image format\n\tis determined from the extension of given file path. Supported extensions\n\tare .svg, .pdf and .eps.\n\t\n\tArgs:\n\t\tgraphics: pero.Graphics\n\t\t\tGraphics to be drawn.\n\t\t\n\t\tpath: str\n\t\t\tFull path of a file to save the image into.\n\t\t\n\t\twidth: float or None\n\t\t\tImage width in device units.\n\t\t\n\t\theight: float or None\n\t\t\tImage height in device units.\n\t\t\n\t\tline_scale: float\n\t\t\tLine scaling factor.\n\t\t\n\t\tfont_scale: float\n\t\t\tFont scaling factor.\n\t", "category": "graphics", "imports": ["import os.path", "import cairo", "import PIL", "import numpy", "from . enums import *", "from . canvas import CairoCanvas"]}], [], [{"term": "class", "name": "classGameGraphics:", "data": "class GameGraphics:\n\t# gameGraphics is basically initializing a new game\n\t# if you want your game graphics to be added to the game loop you need to add it to the game graphics list\n\t# you can have multiple games running at the same time\n\t# this helps making multiple game servers\n\t# you can select which game graphics is your main graphics, and show it in your server side\n\n\tdef __init__(self, screen, camera, background_color=(0, 0, 0)):\n\t\tself.screen = screen\n\t\tself.width = screen.screen.get_width()\n\t\tself.height = screen.screen.get_height()\n\t\tself.background_color = background_color\n\t\tself.shape_list = []\n\t\tself.on_input_list = []\n\t\tself.looper_list = []\n\t\tself.camera = camera\n\t\tself.center = (self.width/2, self.height/2)\n\t\tself.storage = {}\n\n\tdef add_shape(self, shape):\n\t\tself.shape_list.append(shape)\n\n\tdef insert_shape(self, index, shape):\n\t\tself.shape_list.insert(index, shape)\n\n\tdef add_input_func(self, input_func):\n\t\tself.on_input_list.append(input_func)\n\n\tdef insert_input_func(self, index, input_func):\n\t\tself.on_input_list.insert(index, input_func)\n\n\tdef add_looper(self, looper):\n\t\tself.looper_list.append(looper)\n\n\tdef insert_looper(self, index, looper):\n\t\tself.looper_list.insert(index, looper)\n\n\tdef restart(self):\n\t\tself.shape_list.clear()\n\t\tself.on_input_list.clear()\n\n\tdef on_input(self, event):\n\t\tfor input_func in self.on_input_list:\n\t\t\tif input_func.state:\n\t\t\t\tinput_func.check(event)\n\n\tdef run_loopers(self):\n\t\tfor looper in self.looper_list:\n\t\t\tif looper.state:\n\t\t\t\tlooper.run()\n\n\tdef pause_user_input(self):\n\t\tfor on_input in self.on_input_list:\n\t\t\ton_input.state = False\n\n\tdef unpause_user_input(self):\n\t\tfor on_input in self.on_input_list:\n\t\t\ton_input.state = True\n\n\tdef pause_loopers(self):\n\t\tfor looper in self.looper_list:\n\t\t\tlooper.state = False\n\n\tdef unpause_loopers(self):\n\t\tfor looper in self.looper_list:\n\t\t\tlooper.state = True\n\n\tdef pause(self):\n\t\tglobal game_graphics_list\n\t\tif self in game_graphics_list:\n\t\t\tgame_graphics_list.remove(self)\n\n\tdef start(self):\n\t\tglobal game_graphics_list\n\t\tif self not in game_graphics_list:\n\t\t\tgame_graphics_list.append(self)\n\n\tdef change_dimensions(self, dimensions):\n\t\tpygame.transform.scale(self.screen.screen, dimensions)\n\n\tdef draw(self):\n\t\tfor shape in self.shape_list:\n\t\t\tshape.draw()\n\n\tdef draw_background(self):\n\t\tself.screen.screen.fill(self.background_color)\n\n", "description": null, "category": "graphics", "imports": ["import mathematics as math", "import pygame", "import copy"]}, {"term": "class", "name": "classCamera:", "data": "class Camera:\n\tdef __init__(self, x, y, z, game_graphics, original_at=1, x_rotation=0, y_rotation=0, z_rotation=0):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.z = z\n\t\tself.x_rotation = x_rotation\n\t\tself.y_rotation = y_rotation\n\t\tself.z_rotation = z_rotation\n\t\tself.game_graphics = game_graphics\n\t\tself.original_at = original_at\n\n\tdef move(self, move):\n\t\tself.x += move[0]\n\t\tself.y += move[1]\n\n\tdef get_origin(self, point):\n\t\tcenter = self.game_graphics.center\n\n\t\t#d1 = math.calculate_parallel_distant((self.x, self.z), (point[0], point[2]), self.y_rotation)\n\t\t#d2 = math.calculate_parallel_distant((self.z, self.y), point, self.x_rotation)\n\t\t#d3 = math.calculate_parallel_distant((self.x, self.y), point, self.z_rotation)\n\t\t#distant = math.math.sqrt((d1 ** 2) + (d2 ** 2) + (d3 ** 2))\n\t\tdistant = point[2] - self.z\n\t\t#distant = d1\n\t\tif distant <= 0:\n\t\t\treturn False\n\t\tmagnify = self.original_at/distant\n\t\tpoint = (-self.x, -self.y)\n\t\tpoint = (magnify*point[0], magnify*point[1])\n\t\treturn center[0]+point[0], center[1]-point[1]\n\n\tdef vr_to_real(self, point):\n\n\t\tprintIt = False\n\t\tif point == (0, 0, 10):\n\t\t\tprintIt = True\n\n\t\tz, y = math.rotate_point((point[2], point[1]), -self.x_rotation, rotation_center=(self.z, self.y))\n\t\tpoint = [point[0], y, z]\n\n\t\tz, x = math.rotate_point((point[2], point[0]), -self.y_rotation, rotation_center=(self.z, self.x))\n\t\tpoint = [x, point[1], z]\n\n\t\tx, y = math.rotate_point((point[0], point[1]), -self.z_rotation, rotation_center=(self.x, self.y))\n\t\tpoint = [x, y, point[2]]\n\n\t\t#d1 = math.calculate_parallel_distant((self.x, self.z), (point[0], point[2]), self.y_rotation)\n\t\t#d2 = math.calculate_parallel_distant((self.z, self.y), point, self.x_rotation)\n\t\t#d3 = math.calculate_parallel_distant((self.x, self.y), point, self.z_rotation)\n\t\t#distant = math.math.sqrt((d1 ** 2) + (d2 ** 2) + (d3 ** 2))\n\t\tdistant = point[2] - self.z\n\t\t#distant = d1\n\t\t#print(distant, (self.z, self.x), (point[2], point[0]), self.y_rotation)\n\t\torigin = self.get_origin(point)\n\n\t\tif distant <= 0:\n\t\t\treturn False\n\t\tmagnify = self.original_at/distant\n\t\tpoint = (magnify*point[0], magnify*point[1])\n\n\t\treturn origin[0]+point[0], origin[1]-point[1]\n\n", "description": null, "category": "graphics", "imports": ["import mathematics as math", "import pygame", "import copy"]}, {"term": "class", "name": "classScreen:", "data": "class Screen:\n\tdef __init__(self, width, height):\n\t\tself.width = width\n\t\tself.height = height\n\t\tself.screen = pygame.Surface((width, height))\n\n", "description": null, "category": "graphics", "imports": ["import mathematics as math", "import pygame", "import copy"]}, {"term": "class", "name": "classObject:", "data": "class Object:\n\tdef __init__(self, game_graphics, shapes):\n\t\tself.game_graphics = game_graphics\n\t\tself.shapes = shapes\n\n", "description": null, "category": "graphics", "imports": ["import mathematics as math", "import pygame", "import copy"]}, {"term": "class", "name": "classShape:", "data": "class Shape:\n\tdef __init__(self, game_graphics, shape_type):\n\t\tglobal types\n\t\tself.game_graphics = game_graphics\n\t\tself.shape_type = shape_type\n\t\tself.draw_func = self.shape_type.draw\n\t\tself.move_func = self.shape_type.move\n\t\tself.collide_func = self.shape_type.collider\n\t\tself.loop_functions_list = []\n\t\tif self.shape_type.loop_function:\n\t\t\tself.loop_functions_list.append(self.shape_type.loop_function)\n\n\tdef draw(self):\n\t\tself.draw_func(self)\n\n\tdef move(self, movement):\n\t\tif self.move_func:\n\t\t\tself.move_func(self, movement)\n\n\tdef collide(self, point):\n\t\tif self.collide_func:\n\t\t\treturn self.collide_func(self, point)\n\n\tdef loop_functions(self):\n\t\tfor func in self.loop_functions_list:\n\t\t\tfunc(self)\n\n", "description": null, "category": "graphics", "imports": ["import mathematics as math", "import pygame", "import copy"]}, {"term": "class", "name": "classType:", "data": "class Type:\n\tdef __init__(self, name, draw, move=None, collider=None, loop_function=None):\n\t\tself.name = name\n\t\tself.draw = draw\n\t\tself.move = move\n\t\tself.collider = collider\n\t\tself.loop_function = loop_function\n\n", "description": null, "category": "graphics", "imports": ["import mathematics as math", "import pygame", "import copy"]}, {"term": "def", "name": "add_type", "data": "def add_type(shape_type):\n\tglobal types\n\ttypes.append(shape_type)\n\n", "description": null, "category": "graphics", "imports": ["import mathematics as math", "import pygame", "import copy"]}, {"term": "def", "name": "add_game_graphics", "data": "def add_game_graphics(game_graphics_obj):\n\tglobal game_graphics_list\n\tgame_graphics_list.append(game_graphics_obj)\n\n", "description": null, "category": "graphics", "imports": ["import mathematics as math", "import pygame", "import copy"]}, {"term": "def", "name": "game_graphics_copy", "data": "def game_graphics_copy(game_graphics, new_screen):\n\ts = game_graphics.screen\n\tgame_graphics.screen = None\n\tnew_game_graphics = copy.deepcopy(game_graphics)\n\tnew_game_graphics.screen = new_screen\n\n\tgame_graphics.screen = s\n\treturn new_game_graphics\n\n", "description": null, "category": "graphics", "imports": ["import mathematics as math", "import pygame", "import copy"]}], [], [{"term": "def", "name": "graphics_pipe", "data": "def graphics_pipe():\n\tfrom panda3d.core import GraphicsPipeSelection\n\n\tpipe = GraphicsPipeSelection.get_global_ptr().make_default_pipe()\n\n\tif pipe is None or not pipe.is_valid():\n\t\tpytest.skip(\"GraphicsPipe is invalid\")\n\n\tyield pipe\n\n", "description": null, "category": "graphics", "imports": ["import pytest", "\tfrom panda3d.core import GraphicsPipeSelection", "\tfrom panda3d.core import GraphicsEngine", "\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties", "\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties"]}, {"term": "def", "name": "graphics_engine", "data": "def graphics_engine():\n\tfrom panda3d.core import GraphicsEngine\n\n\tengine = GraphicsEngine.get_global_ptr()\n\tyield engine\n\n\t# This causes GraphicsEngine to also terminate the render threads.\n\tengine.remove_all_windows()\n\n", "description": null, "category": "graphics", "imports": ["import pytest", "\tfrom panda3d.core import GraphicsPipeSelection", "\tfrom panda3d.core import GraphicsEngine", "\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties", "\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties"]}, {"term": "def", "name": "window", "data": "def window(graphics_pipe, graphics_engine):\n\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties\n\n\tfbprops = FrameBufferProperties.get_default()\n\twinprops = WindowProperties.get_default()\n\n\twin = graphics_engine.make_output(\n\t\tgraphics_pipe,\n\t\t'window',\n\t\t0,\n\t\tfbprops,\n\t\twinprops,\n\t\tGraphicsPipe.BF_require_window\n\t)\n\tgraphics_engine.open_windows()\n\n\tif win is None:\n\t\tpytest.skip(\"GraphicsPipe cannot make windows\")\n\n\tyield win\n\n\tif win is not None:\n\t\tgraphics_engine.remove_window(win)\n\n", "description": null, "category": "graphics", "imports": ["import pytest", "\tfrom panda3d.core import GraphicsPipeSelection", "\tfrom panda3d.core import GraphicsEngine", "\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties", "\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties"]}, {"term": "def", "name": "gsg", "data": "def gsg(graphics_pipe, graphics_engine):\n\t\"Returns a windowless GSG that can be used for offscreen rendering.\"\n\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties\n\n\tfbprops = FrameBufferProperties()\n\tfbprops.force_hardware = True\n\n\tbuffer = graphics_engine.make_output(\n\t\tgraphics_pipe,\n\t\t'buffer',\n\t\t0,\n\t\tfbprops,\n\t\tWindowProperties.size(32, 32),\n\t\tGraphicsPipe.BF_refuse_window\n\t)\n\tgraphics_engine.open_windows()\n\n\tif buffer is None:\n\t\tpytest.skip(\"GraphicsPipe cannot make offscreen buffers\")\n\n\tyield buffer.gsg\n\n\tif buffer is not None:\n\t\tgraphics_engine.remove_window(buffer)\n", "description": null, "category": "graphics", "imports": ["import pytest", "\tfrom panda3d.core import GraphicsPipeSelection", "\tfrom panda3d.core import GraphicsEngine", "\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties", "\tfrom panda3d.core import GraphicsPipe, FrameBufferProperties, WindowProperties"]}], [{"term": "class", "name": "class_Graphics:", "data": "class _Graphics:\n\t'''Class that represents a simple graphical window.\n\n\tThe class is meant to be private so that object instantiation is\n\tnot needed by the user and so that only one window is created.\n\n\t'''\n\tdef __init__(self):\n\t\t'''Initialize a Tkinter window.\n\n\t\tThe window will be filled with a canvas and with mouse and\n\t\tkeyboard handlers.  The window will not be displayed until one\n\t\tof the global draw functions is called so that the initial\n\t\tstate of the window can be changed before display.\n\n\t\t'''\n\n\t\t# Initialize attributes\n\t\tself.running = True\n\t\tself.images = {}\n\t\tself.keys_down = {}\n\t\tself.keys_pressed = []\n\t\tself.keys_released = []\n\t\tself.buttons_down = {}\n\t\tself.buttons_pressed = []\n\t\tself.buttons_released = []\n\t\tself.return_typed = False\n\t\tself.mouse_moved = False\n\t\tself.mouse_x = 0\n\t\tself.mouse_y = 0\n\t\tself.previous_time = time.perf_counter()\n\t\t# self.after_idle_id = None\n\t\tself.after_idle_ids = {}\n\n\t\t# Initialize window\n\t\tself.window = tkinter.Tk()\n\t\tself.window.resizable(0, 0)\n\t\tself.window.protocol(\"WM_DELETE_WINDOW\", self.handle_window_close)\n\t\tself.window.title(INITIAL_TITLE)\n\t\tself.frame = tkinter.Frame(self.window)\n\t\tself.frame.focus_set()\n\t\tself.frame.bind(\"\", self.handle_window_close)\n\t\tself.frame.bind(\"\", self.handle_key_press)\n\t\tself.frame.bind(\"\", self.handle_key_release)\n\t\tself.window.bind(\"\", self.handle_mouse_press)\n\t\tself.window.bind(\"\", self.handle_mouse_release)\n\t\tself.window.bind(\"\", self.handle_mouse_motion)\n\t\tself.window.bind(\"\", self.handle_mouse_motion)\n\t\tself.frame.pack()\n\t\tself.canvas = tkinter.Canvas(self.frame)\n\t\tself.canvas.config(width=INITIAL_WIDTH, height=INITIAL_HEIGHT)\n\t\tself.canvas.config(background=INITIAL_BACKGROUND_COLOR)\n\t\tself.canvas.config(borderwidth=0)\n\t\tself.canvas.config(highlightthickness=0)\n\t\tself.canvas.pack()\n\t\tif platform() == 'Darwin':\n\t\t\tsystem('''/usr/bin/osascript -e 'tell app \"Finder\" to set frontmost of process \"Python\" to true' ''')\n\n\tdef handle_window_close(self, event=None):\n\t\t'''Handle user closing the window.\n\n\t\tHandle window close by updating the running state so that\n\t\tredraw only occurs if the window is open.\n\n\t\t'''\n\t\tself.running = False\n\n\tdef handle_mouse_press(self, event):\n\t\t'''Handle mouse button press.\n\n\t\tHandle mouse button press, including the scroll wheel, by\n\t\tupdating the mouse button state dictionary.\n\n\t\t'''\n\t\tself.buttons_down[event.num] = True\n\t\tself.buttons_pressed.append(event.num)\n\n\tdef handle_mouse_release(self, event):\n\t\t'''Handle mouse button release.\n\n\t\tHandle mouse button release, including the scroll wheel, by\n\t\tupdating the mouse button state dictionary.\n\n\t\t'''\n\t\tself.buttons_down[event.num] = False\n\t\tself.buttons_released.append(event.num)\n\n\tdef handle_mouse_motion(self, event):\n\t\t'''Handle mouse movement.\n\n\t\tHandle mouse movement by updating the mouse movement state.\n\n\t\t'''\n\t\tself.mouse_moved = True\n\t\tself.mouse_x = event.x\n\t\tself.mouse_y = event.y\n\n\tdef handle_key_press(self, event):\n\t\t'''Handle keyboard key press.\n\n\t\tIf the event queue is empty, handle keyboard key press by\n\t\tupdating the keyboard key state dictionary.  If the event\n\t\tqueue is not empty, clear pending key release event.  See\n\t\t:func:`~graphics._Graphics.handle_after_idle` for a for more\n\t\tinformation.\n\n\t\t'''\n\t\tafter_idle_id = self.after_idle_ids.get(event.keysym, None)\n\t\tif after_idle_id != None:\n\t\t\tself.window.after_cancel(after_idle_id)\n\t\t\tself.after_idle_ids[event.keysym] = None\n\t\telse:\n\t\t\tself.keys_down[event.keysym] = True\n\t\t\tself.keys_pressed.append(event.keysym)\n\n\tdef handle_key_release(self, event):\n\t\t'''Handle keyboard key release.\n\n\t\tSchedule handling a keyboard key release when the event queue\n\t\tis empty.  See :func:`~graphics._Graphics.handle_after_idle`\n\t\tfor a for more information.\n\n\t\t'''\n\t\tafter_idle_id = self.window.after_idle(self.handle_after_idle, event)\n\t\tself.after_idle_ids[event.keysym] = after_idle_id\n\n\tdef handle_after_idle(self, event):\n\t\t'''Handle after idle event.\n\n\t\tOn OS X and Linux holding down a keyboard key uses the\n\t\toperating system key repeat, which causes repeated\n\t\tkey down/key up events.  To ignore the up-down events while the\n\t\tkey is pressed, key released events are not handled\n\t\timmediately.  Instead they are handled after the event queue\n\t\tis empty, by using the tkinter after_idle event.  If a\n\t\tsubsequent key down event occurs before the event queue is\n\t\temptied the release is ignored.  If no subsequent key down\n\t\tevent occurs the key release is handled.  Note this causes a\n\t\tslight delay in the handling of key release events.  This\n\t\tsolution is from `this\n\t\t`_\n\t\tarticle.\n\n\t\t'''\n\t\tself.after_idle_ids[event.keysym] = None\n\t\tself.keys_down[event.keysym] = False\n\t\tself.keys_released.append(event.keysym)\n\n\tdef handle_return(self, event):\n\t\tself.return_typed = True\n\t\tself.frame.focus_set()\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "image_size", "data": "def image_size(image_name):\n\t'''Return the size of the specified image when drawn to the Graphics window.\n\n\t:param str image_name: The file name of the image to draw.\n\n\t:return: (int, int) -- The width and height of the image as a tuple\n\t\tof integers.\n\n\tIf ``image_name`` is not a valid image file (0, 0) is returned.\n\n\t'''\n\tif image_name not in graphics.images:\n\t\ttry:\n\t\t\timage = tkinter.PhotoImage(file=image_name)\n\t\texcept:\n\t\t\tprint('ERROR: Could not load the file \"{}\".'.format(image_name))\n\t\t\timage = None\n\t\tgraphics.images[image_name] = image\n\telse:\n\t\timage = graphics.images[image_name]\n\tif image is not None:\n\t\treturn (image.width(), image.height())\n\telse:\n\t\treturn (0, 0)\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "image_width", "data": "def image_width(image_name):\n\t'''Return the width of the specified image when drawn to the Graphics window.\n\n\t:param str image_name: The file name of the image to draw.\n\n\t:return: int -- The width of the image as an integer.\n\n\tIf ``image_name`` is not a valid image file 0 is returned.\n\n\t'''\n\timage_width, image_height = image_size(image_name)\n\treturn image_width;\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "image_height", "data": "def image_height(image_name):\n\t'''Return the height of the specified image when drawn to the Graphics window.\n\n\t:param str image_name: The file name of the image to draw.\n\n\t:return: int -- The height of the image as an integer.\n\n\tIf ``image_name`` is not a valid image file 0 is returned.\n\n\t'''\n\timage_height, image_height = image_size(image_name)\n\treturn image_height;\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "draw_image", "data": "def draw_image(image_name, x, y):\n\t'''Draw the specified image to the Graphics window.\n\n\t:param str image_name: The file name of the image to draw.  The\n\t\timage must be a GIF file.\n\n\t:param float x: The x-coordinate, in pixels, of the center of the\n\t\timage to draw.\n\n\t:param float y: The y-coordinate, in pixels, of the center of the\n\t\timage to draw.\n\n\tSee :ref:`coordinate-system-label` for a description of the\n\tGraphics window coordinate system.\n\n\t'''\n\tif image_name not in graphics.images:\n\t\ttry:\n\t\t\timage = tkinter.PhotoImage(file=image_name)\n\t\texcept:\n\t\t\tprint('ERROR: Could not load the file \"{}\".'.format(image_name))\n\t\t\timage = None\n\t\tgraphics.images[image_name] = image\n\telse:\n\t\timage = graphics.images[image_name]\n\tif image is not None:\n\t\tgraphics.canvas.create_image((x, y), image=image)\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "draw_oval", "data": "def draw_oval(x, y, width, height, outline=\"black\", fill=\"\", thickness=1):\n\t'''Draw the specified axis-aligned oval the Graphics window.\n\n\t:param float x: The x-coordinate, in pixels, of the center of the\n\t\toval to draw.\n\n\t:param float y: The y-coordinate, in pixels, of the center of the\n\t\toval to draw.\n\n\t:param float width: The width, in pixels, of the oval to draw.\n\n\t:param float height: The height, in pixels, of the oval to draw.\n\n\t:param str outline: The outline color of the oval to draw.\n\t\tDefault value is 'black'.\n\n\t:param str fill: The fill color of the oval to draw.  Default\n\t\tvalue is an empty string, do not fill.\n\n\t:param float thickness: The thickness, in pixels, of the outline of\n\t\tthe oval to draw.  Default value is 1.\n\n\tSee :ref:`coordinate-system-label` for a description of the\n\tGraphics window coordinate system.\n\n\t'''\n\tleft = x - width / 2\n\ttop = y - height / 2\n\tright = x + width / 2\n\tbottom = y + height / 2\n\tgraphics.canvas.create_oval(left, top, right, bottom,\n\t\t\t\t\t\t\t\toutline=outline, fill=fill, width=thickness)\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "draw_rectangle", "data": "def draw_rectangle(x, y, width, height, outline=\"black\", fill=\"\",\n\t\t\t\t   thickness=1):\n\t'''Draw the specified axis-aligned rectangle the Graphics window.\n\n\t:param float x: The x-coordinate, in pixels, of the center of the\n\t\trectangle to draw.\n\n\t:param float y: The y-coordinate, in pixels, of the center of the\n\t\trectangle to draw.\n\n\t:param float width: The width, in pixels, of the rectangle to draw.\n\n\t:param float height: The height, in pixels, of the rectangle to draw.\n\n\t:param str outline: The outline color of the rectangle to draw.\n\t\tDefault value is 'black'.\n\n\t:param str fill: The fill color of the rectangle to draw.  Default\n\t\tvalue is an empty string, do not fill.\n\n\t:param float thickness: The thickness, in pixels, of the outline of\n\t\tthe rectangle to draw.  Default value is 1.\n\n\tSee :ref:`coordinate-system-label` for a description of the\n\tGraphics window coordinate system.\n\n\t'''\n\tleft = x - width / 2\n\ttop = y - height / 2\n\tright = x + width / 2\n\tbottom = y + height / 2\n\tgraphics.canvas.create_rectangle(left, top, right, bottom,\n\t\t\t\t\t\t\t\toutline=outline, fill=fill, width=thickness)\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "draw_line", "data": "def draw_line(x1, y1, x2, y2, fill=\"black\", thickness=1):\n\t'''Draw the specified line the Graphics window.\n\n\t:param float x1: The x-coordinate, in pixels, of first endpoint of\n\t\tthe line to draw.\n\n\t:param float y1: The y-coordinate, in pixels, of the frist\n\t\tendpoint of the line to draw.\n\n\t:param float x2: The x-coordinate, in pixels, of second endpoint of\n\t\tthe line to draw.\n\n\t:param float y2: The y-coordinate, in pixels, of the second\n\t\tendpoint of the line to draw.\n\n\t:param str fill: The color of the line to draw.  Default value is\n\t\tblack.\n\n\t:param float thickness: The thickness, in pixels, of the line to\n\t\tdraw.  Default value is 1.\n\n\tSee :ref:`coordinate-system-label` for a description of the\n\tGraphics window coordinate system.\n\n\t'''\n\tgraphics.canvas.create_line(x1, y1, x2, y2, fill=fill, width=thickness)\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "draw_sprite", "data": "def draw_sprite(sprite):\n\t'''Draw the specified sprite to the Graphics window.\n\n\t:param Sprite sprite: The sprite object to draw.\n\n\t'''\n\tdraw_image(sprite.image_name, sprite.x, sprite.y)\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "text_size", "data": "def text_size(text, size=12):\n\t'''Return the size of the specified text when drawn to the Graphics window.\n\n\t:param str text: The text to get the size of.\n\n\t:param int size: The size, in points, of the text to get the size of.\n\n\t:return: (int, int) -- The width and height of the text as a tuple\n\t\tof integers.\n\n\t'''\n\ttemp_canvas = tkinter.Canvas()\n\ttext_id = temp_canvas.create_text((0, 0), text=text, font=(TEXT_FONT, size))\n\tleft, top, right, bottom = temp_canvas.bbox(text_id)\n\twidth = right - left\n\theight = bottom - top\n\ttemp_canvas.destroy()\n\treturn (width, height)\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "draw_text", "data": "def draw_text(text, x, y, color=\"black\", size=12):\n\t'''Draw the specified text to the Graphics window.\n\n\t:param str text: The text to draw to the window.\n\n\t:param float x: The x-coordinate, in pixels, of the center of the\n\t\ttext to draw.\n\n\t:param float y: The y-coordinate, in pixels, of the center of the\n\t\ttext to draw.\n\n\t:param str color: The color of the text to draw.  Default value is\n\t\t'black'.\n\n\t:param int size: The size, in points, of the text to draw.\n\t\tDefault value is 12.\n\n\tSee :ref:`coordinate-system-label` for a description of the\n\tGraphics window coordinate system.\n\n\tSee :ref:`colors-label` for a description of valid TKinter color\n\tstrings.\n\n\t'''\n\tgraphics.canvas.create_text((x, y), text=text, fill=color,\n\t\t\t\t\t\t\t\tfont=(TEXT_FONT, size))\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "clear", "data": "def clear():\n\t'''Clear all images, shapes, and text drawn to the Graphics window.\n\n\t'''\n\tgraphics.canvas.delete(tkinter.ALL)\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "wait", "data": "def wait(seconds=0.033333333):\n\t'''Waits for the specified number of seconds.\n\n\tImages and text are drawn to a non-visible image buffer when the\n\tdraw functions are called so that multiple draw calls can be\n\tdisplayed at once using this function.  This makes for smoother,\n\tbetter looking animation.  This function also blocks until the\n\ttime specified has elapsed since the last time this function was\n\tcalled.  This allows the user to create animations at a constant\n\tframe rate by calling this function once for every frame of\n\tanimation.\n\n\tNote, this is a blocking function.  When invoked, the calling program\n\twill stop until the user releases a mouse button.\n\n\t'''\n\tgraphics.keys_pressed = []\n\tgraphics.keys_released = []\n\tgraphics.buttons_pressed = []\n\tgraphics.buttons_released = []\n\tgraphics.mouse_moved = False\n\tgraphics.window.update()\n\tcurrent_time = time.perf_counter()\n\telapsed_time = current_time - graphics.previous_time\n\tif elapsed_time < seconds:\n\t\tsleep_time = seconds - elapsed_time\n\t\telapsed_time = sleep_time\n\t\ttime.sleep(sleep_time)\n\tgraphics.previous_time = current_time\n\treturn elapsed_time\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "mainloop", "data": "def mainloop():\n\t'''Keep the Graphics window open.\n\n\tThis function is to be used to keep the program from ending when\n\tno animation is being done, aka displaying a drawing.  This will\n\tkeep the Graphics window open until the user closes the window,\n\teither by hitting the escape key or by clicking on the window\n\tclose button, or until ``window_open(False)`` is called.\n\n\tFor example::\n\t\t>>> draw_something_brilliant()  # you must supply this function\n\t\t>>> mainloop() # window will stay open\n\n\t'''\n\twhile graphics.running:\n\t\twait()\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "window_size", "data": "def window_size(width=None, height=None):\n\t'''Return or set size of the Graphics window.\n\n\t:param int width: The width of the window drawing area, in pixels.\n\n\t:param int height: The height of the window drawing area, in pixels.\n\n\t:return: (int, int) -- The current width and height of the window\n\t\tas a tuple of integers.\n\n\tFor example::\n\t\t>>> graphics.window_size(640, 480)  # the drawing area will be 640 x 480\n\t\t>>> print(graphics.window_size())\n\t\t>>> (640, 480)\n\t\t>>> graphics.window_size(width=480) # the drawing area width will be 480\n\t\t>>> print(graphics.window_size())\n\t\t>>> (480, 480)\n\n\t'''\n\tcanvas_width = int(graphics.canvas.cget(\"width\"))\n\tcanvas_height = int(graphics.canvas.cget(\"height\"))\n\tif width is None and height is None:\n\t\treturn (canvas_width, canvas_height)\n\tif width is not None:\n\t\tcanvas_width = width\n\tif height is not None:\n\t\tcanvas_height = height\n\tgraphics.canvas.config(width=canvas_width)\n\tgraphics.canvas.config(height=canvas_height)\n\tgraphics.canvas.pack()\n\treturn (canvas_width, canvas_height)\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "window_width", "data": "def window_width(width=None):\n\t'''Return or set width of the Graphics window.\n\n\t:param int width: The width of the window drawing area, in pixels.\n\n\t:return: int -- The current width of the window as an integer.\n\n\tFor example::\n\t\t>>> graphics.window_width(640)  # the drawing area will be 640px wide\n\t\t>>> print(graphics.window_width())\n\t\t>>> 640\n\t\t>>> graphics.window_size(480) # the drawing area will be 480px wide\n\t\t>>> print(graphics.window_width())\n\t\t>>> 480\n\n\t'''\n\tcanvas_width, canvas_height = window_size(width=width, height=None)\n\treturn canvas_width;\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "window_height", "data": "def window_height(height=None):\n\t'''Return or set height of the Graphics window.\n\n\t:param int height: The height of the window drawing area, in pixels.\n\n\t:return: int -- The current height of the window as an integer.\n\n\tFor example::\n\t\t>>> graphics.window_height(480)  # the drawing area will be 640px wide\n\t\t>>> print(graphics.window_height())\n\t\t>>> 480\n\t\t>>> graphics.window_size(640) # the drawing area will be 480px wide\n\t\t>>> print(graphics.window_height())\n\t\t>>> 640\n\n\t'''\n\tcanvas_width, canvas_height = window_size(width=None, height=height)\n\treturn canvas_height\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "window_title", "data": "def window_title(title=None):\n\t'''Return or set the title of the Graphics window.\n\n\t:param str title: The title of the Graphics window.\n\n\t:return: (str) -- The current window title.\n\n\tFor example::\n\t\t>>> graphics.window_title('Mine')  # window title will be 'Mine'\n\t\t>>> print(graphics.window_title())\n\t\t>>> Mine\n\t\t>>> graphics.window_title('Not Yours')  # window title will be 'Not Yours'\n\t\t>>> print(graphics.window_title())\n\t\t>>> Not Yours\n\n\t'''\n\tif title is None:\n\t\treturn graphics.window.title()\n\tgraphics.window.title(title)\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "window_background_color", "data": "def window_background_color(color=None):\n\t'''Return or set the background color of the Graphics window.\n\n\t:param str color: The color to set the background of the\n\t\twindow to.\n\n\t:return: (str) -- The current window background color.\n\n\tSee :ref:`colors-label` for a description of valid TKinter color\n\t\tstrings.\n\n\tFor example::\n\t\t>>> graphics.window_background_color('black')  # black window background\n\t\t>>> print(graphics.window_background_color())\n\t\t>>> black\n\t\t>>> graphics.window_background_color('white')  # white window background\n\t\t>>> print(graphics.window_background_color())\n\t\t>>> white\n\n\t'''\n\tif color is None:\n\t\treturn graphics.canvas.cget(\"background\")\n\tgraphics.canvas.config(background=color)\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "window_open", "data": "def window_open(win_open=None):\n\t'''Return or set  whether the Graphics window is open.\n\n\t:param bool win_open: Whether to open or close the window.\n\n\t:return: (bool) -- Whether the window is open or closed.\n\n\tFor example::\n\t\t>>> graphics.window_open(True)  # The window will open if it isn't already\n\t\t>>> print(graphics.window_open())\n\t\t>>> True\n\t\t>>> graphics.window_open(False) # The window will close if it isn't already\n\t\t>>> print(graphics.window_open())\n\t\t>>> False\n\n\t'''\n\tif win_open is None:\n\t\treturn graphics.running\n\tgraphics.running = win_open\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "key_down", "data": "def key_down(key_symbol):\n\t'''Return whether the specified keyboard key is currently down.\n\n\t:param str button_symbol: A valid TKinter key symbol string.\n\n\t:return: (bool) -- True if the specified keyboard key is\n\t\tbeing pressed, false otherwise.\n\n\tSee :ref:`key-symbols-label` for a list of valid key symbols.\n\n\t'''\n\treturn graphics.keys_down.get(key_symbol, False)\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "key_up", "data": "def key_up(key_symbol):\n\t'''Return whether the specified keyboard key is currently up.\n\n\t:param str button_symbol: A valid TKinter key symbol string.\n\n\t:return: (bool) -- True if the specified keyboard key is not\n\t\tbeing pressed, false otherwise.\n\n\tSee :ref:`key-symbols-label` for a list of valid key symbols.\n\n\t'''\n\treturn not graphics.keys_down.get(key_symbol, False)\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "key_pressed", "data": "def key_pressed(key_symbol):\n\t'''Return whether the specified keyboard key was pressed.\n\n\t:param str key_symbol: A valid TKinter key symbol string.\n\n\t:return: (bool) -- True if the specified keyboard key was\n\t\tpressed, false otherwise.\n\n\tSee :ref:`key-symbols-label` for a list of valid key symbols.\n\n\tNote, this function returns whether the specified key was pressed\n\tsince the last time the wait function was called.  It is\n\tmeant to be used in a program with an active loop that calls the\n\twait function every iteration.\n\n\t'''\n\treturn key_symbol in graphics.keys_pressed\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "key_released", "data": "def key_released(key_symbol):\n\t'''Return whether the specified keyboard key was released.\n\n\t:param str key_symbol: A valid TKinter key symbol string.\n\n\t:return: (bool) -- True if the specified keyboard key was\n\t\treleased, false otherwise.\n\n\tSee :ref:`key-symbols-label` for a list of valid key symbols.\n\n\tNote, this function returns whether the specified key was released\n\tsince the last time the wait function was called.  It is\n\tmeant to be used in a program with an active loop that calls the\n\twait function every iteration.\n\n\t'''\n\treturn key_symbol in graphics.keys_released\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "wait_for_key_press", "data": "def wait_for_key_press():\n\t'''Waits for the user to press a key and returns the key symbol.\n\n\t:return: (str) -- The TKinter key symbol string of the key pressed\n\t\tby the user.\n\n\tSee :ref:`key-symbols-label` for a list of key symbols.\n\n\tNote, this is a blocking function.  When invoked, the calling program\n\twill stop until the user presses a keyboard key.\n\n\t'''\n\twhile not graphics.keys_pressed:\n\t\twait()\n\tkey_pressed = graphics.keys_pressed.pop(0)\n\treturn key_pressed\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "wait_for_key_release", "data": "def wait_for_key_release():\n\t'''Waits for the user to release a key and returns the key symbol.\n\n\t:return: (str) -- The TKinter key symbol string of the key released\n\t\tby the user.\n\n\tSee :ref:`key-symbols-label` for a list of key symbols.\n\n\tNote, this is a blocking function.  When invoked, the calling program\n\twill stop until the user releases a keyboard key.\n\n\t'''\n\twhile not graphics.keys_released:\n\t\twait()\n\tkey_released = graphics.keys_released.pop(0)\n\treturn key_released\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "wait_for_text", "data": "def wait_for_text(x, y, foreground='black', background='white',\n\t\t\t\t  size=12, width=20):\n\t'''Waits for the user to type text into text box and returns text\n\n\t:param float x: The x-coordinate, in pixels, of the center of the\n\t\ttext box.\n\n\t:param float y: The y-coordinate, in pixels, of the center of the\n\t\ttext box.\n\n\t:param str foreground: The color of the text in the text box.\n\t\tDefault value is 'black'.\n\n\t:param str background: The color of the background of the text\n\t\tbox.  Default value is 'white'.\n\n\t:param int size: The font size, in points, of the text in the text\n\t\tbox.  Default value is 12.\n\n\t:param int width: The width, in characters, of the text box.\n\t\tDefault value is 20.\n\n\t:return: (str) -- The text entered by the user.\n\n\tNote, this is a blocking function.  When invoked, the calling program\n\twill stop until the user presses the return key.\n\n\t'''\n\tentry = tkinter.Entry(graphics.window, bg=background, fg=foreground,\n\t\t\t\t\t\t  borderwidth=size/12, font=(TEXT_FONT, size),\n\t\t\t\t\t\t  highlightthickness=0, width=width)\n\tentry.bind('', graphics.handle_return)\n\tentry_window = graphics.canvas.create_window(x, y, window=entry)\n\tentry.focus_set()\n\twhile not graphics.return_typed:\n\t\twait()\n\tgraphics.return_typed = False\n\tentered_text = entry.get()\n\tentry.destroy()\n\treturn entered_text\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "button_down", "data": "def button_down(button_number):\n\t'''Return whether the specified mouse button is currently down.\n\n\t:param int button_number: A valid TKinter button number.\n\n\t:return: (bool) -- True if the specified mouse button is\n\t\tbeing pressed, false otherwise.\n\n\tSee :ref:`button-numbers-label` for a list of valid button numbers.\n\n\t'''\n\treturn graphics.buttons_down.get(button_number, False)\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "button_up", "data": "def button_up(button_number):\n\t'''Return whether the specified mouse button is currently up.\n\n\t:param int button_number: A valid TKinter button number.\n\n\t:return: (bool) -- True if the specified mouse button is not\n\t\tbeing pressed, false otherwise.\n\n\tSee :ref:`button-numbers-label` for a list of valid button numbers.\n\n\t'''\n\treturn not graphics.buttons_down.get(button_number, False)\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "button_pressed", "data": "def button_pressed(button_number):\n\t'''Return whether the specified mouse button was pressed.\n\n\t:param int button_number: A valid TKinter button number.\n\n\t:return: (bool) -- True if the specified mouse button was\n\t\tpressed, false otherwise.\n\n\tSee :ref:`button-numbers-label` for a list of valid button numbers.\n\n\tNote, this function returns whether the specified button was\n\tpressed since the last time the wait function was called.\n\tIt is meant to be used in a program with an active loop that calls\n\tthe wait function every iteration.\n\n\t'''\n\treturn button_number in graphics.buttons_pressed\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "button_released", "data": "def button_released(button_number):\n\t'''Return whether the specified mouse button was released.\n\n\t:param int button_number: A valid TKinter button number.\n\n\t:return: (bool) -- True if the specified mouse button was\n\t\treleased, false otherwise.\n\n\tSee :ref:`button-numbers-label` for a list of valid button numbers.\n\n\tNote, this function returns whether the specified button was\n\treleased since the last time the wait function was called.  It is\n\tmeant to be used in a program with an active loop that calls the\n\twait function every iteration.\n\n\t'''\n\treturn button_number in graphics.buttons_released\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "wait_for_button_press", "data": "def wait_for_button_press():\n\t'''Waits for the user to press a mouse button and returns the number.\n\n\t:return: (int) -- The TKinter mouse button number of the mouse\n\t\tbutton pressed by the user.\n\n\tSee :ref:`button-numbers-label` for a list of button numbers.\n\n\tNote, this is a blocking function.  When invoked, the calling program\n\twill stop until the user presses a mouse button.\n\n\t'''\n\twhile not graphics.buttons_pressed:\n\t\twait()\n\tbutton_pressed = graphics.buttons_pressed.pop(0)\n\treturn button_pressed\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "wait_for_button_release", "data": "def wait_for_button_release():\n\t'''Waits for the user to release a mouse button and returns the number.\n\n\t:return: (int) -- The TKinter mouse button number of the mouse\n\t\tbutton released by the user.\n\n\tSee :ref:`button-numbers-label` for a list of button numbers.\n\n\tNote, this is a blocking function.  When invoked, the calling program\n\twill stop until the user releases a mouse button.\n\n\t'''\n\twhile not graphics.buttons_released:\n\t\twait()\n\tbutton_released = graphics.buttons_released.pop(0)\n\treturn button_released\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "mouse_x", "data": "def mouse_x():\n\t'''Return the x coordinate of the mouse's current location.'''\n\treturn graphics.mouse_x\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "mouse_y", "data": "def mouse_y():\n\t'''Return the y coordinate of the mouse's current location.'''\n\treturn graphics.mouse_y\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}, {"term": "def", "name": "mouse_moved", "data": "def mouse_moved():\n\t'''Return whether the mouse moved.\n\n\tNote, this function returns whether the mouse moved since the last\n\ttime the wait function was called.  It is meant to be used in a\n\tprogram with an active loop that calls the wait function every\n\titeration.\n\n\t'''\n\treturn graphics.mouse_moved\n", "description": null, "category": "graphics", "imports": ["import tkinter", "import time", "from os import system", "from platform import system as platform"]}], [], [{"term": "class", "name": "Polygon", "data": "class Polygon(GraphicPrimitive_xydata):\n\t\"\"\"\n\tPrimitive class for the Polygon graphics type.  For information\n\ton actual plotting, please see :func:`polygon`, :func:`polygon2d`,\n\tor :func:`~sage.plot.plot3d.shapes2.polygon3d`.\n\n\tINPUT:\n\n\t- xdata - list of `x`-coordinates of points defining Polygon\n\n\t- ydata - list of `y`-coordinates of points defining Polygon\n\n\t- options - dict of valid plot options to pass to constructor\n\n\tEXAMPLES:\n\n\tNote this should normally be used indirectly via :func:`polygon`::\n\n\t\tsage: from sage.plot.polygon import Polygon\n\t\tsage: P = Polygon([1,2,3],[2,3,2],{'alpha':.5})\n\t\tsage: P\n\t\tPolygon defined by 3 points\n\t\tsage: P.options()['alpha']\n\t\t0.500000000000000\n\t\tsage: P.ydata\n\t\t[2, 3, 2]\n\n\tTESTS:\n\n\tWe test creating polygons::\n\n\t\tsage: polygon([(0,0), (1,1), (0,1)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: polygon([(0,0,1), (1,1,1), (2,0,1)])\n\t\tGraphics3d Object\n\t\"\"\"\n\tdef __init__(self, xdata, ydata, options):\n\t\t\"\"\"\n\t\tInitializes base class Polygon.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: P = polygon([(0,0), (1,1), (-1,3)], thickness=2)\n\t\t\tsage: P[0].xdata\n\t\t\t[0.0, 1.0, -1.0]\n\t\t\tsage: P[0].options()['thickness']\n\t\t\t2\n\t\t\"\"\"\n\t\tself.xdata = xdata\n\t\tself.ydata = ydata\n\t\tGraphicPrimitive_xydata.__init__(self, options)\n\n\tdef _repr_(self):\n\t\t\"\"\"\n\t\tString representation of Polygon primitive.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: P = polygon([(0,0), (1,1), (-1,3)])\n\t\t\tsage: p=P[0]; p\n\t\t\tPolygon defined by 3 points\n\t\t\"\"\"\n\t\treturn \"Polygon defined by %s points\"%len(self)\n\n\tdef __getitem__(self, i):\n\t\t\"\"\"\n\t\tReturns `i`th vertex of Polygon primitive, starting count\n\t\tfrom 0th vertex.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: P = polygon([(0,0), (1,1), (-1,3)])\n\t\t\tsage: p=P[0]\n\t\t\tsage: p[0]\n\t\t\t(0.0, 0.0)\n\t\t\"\"\"\n\t\treturn self.xdata[i], self.ydata[i]\n\n\tdef __setitem__(self, i, point):\n\t\t\"\"\"\n\t\tChanges `i`th vertex of Polygon primitive, starting count\n\t\tfrom 0th vertex.  Note that this only changes a vertex,\n\t\tbut does not create new vertices.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: P = polygon([(0,0), (1,2), (0,1), (-1,2)])\n\t\t\tsage: p=P[0]\n\t\t\tsage: [p[i] for i in range(4)]\n\t\t\t[(0.0, 0.0), (1.0, 2.0), (0.0, 1.0), (-1.0, 2.0)]\n\t\t\tsage: p[2]=(0,.5)\n\t\t\tsage: p[2]\n\t\t\t(0.0, 0.5)\n\t\t\"\"\"\n\t\ti = int(i)\n\t\tself.xdata[i] = float(point[0])\n\t\tself.ydata[i] = float(point[1])\n\n\tdef __len__(self):\n\t\t\"\"\"\n\t\tReturns number of vertices of Polygon primitive.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: P = polygon([(0,0), (1,2), (0,1), (-1,2)])\n\t\t\tsage: p=P[0]\n\t\t\tsage: len(p)\n\t\t\t4\n\t\t\"\"\"\n\t\treturn len(self.xdata)\n\n\tdef _allowed_options(self):\n\t\t\"\"\"\n\t\tReturn the allowed options for the Polygon class.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: P = polygon([(1,1), (1,2), (2,2), (2,1)], alpha=.5)\n\t\t\tsage: P[0]._allowed_options()['alpha']\n\t\t\t'How transparent the figure is.'\n\t\t\"\"\"\n\t\treturn {'alpha':'How transparent the figure is.',\n\t\t\t\t'thickness': 'How thick the border line is.',\n\t\t\t\t'edgecolor':'The color for the border of filled polygons.',\n\t\t\t\t'fill':'Whether or not to fill the polygon.',\n\t\t\t\t'legend_label':'The label for this item in the legend.',\n\t\t\t\t'legend_color':'The color of the legend text.',\n\t\t\t\t'rgbcolor':'The color as an RGB tuple.',\n\t\t\t\t'hue':'The color given as a hue.',\n\t\t\t\t'zorder':'The layer level in which to draw'}\n\n\tdef _plot3d_options(self, options=None):\n\t\t\"\"\"\n\t\tTranslate 2d plot options into 3d plot options.\n\n\t\tEXAMPLES::\n\n\t\t\tsage: P = polygon([(1,1), (1,2), (2,2), (2,1)], alpha=.5)\n\t\t\tsage: p=P[0]; p\n\t\t\tPolygon defined by 4 points\n\t\t\tsage: q=p.plot3d()\n\t\t\tsage: q.texture.opacity\n\t\t\t0.5\n\t\t\"\"\"\n\t\tif options is None:\n\t\t\toptions = dict(self.options())\n\t\tfor o in ['thickness', 'zorder', 'legend_label', 'fill', 'edgecolor']:\n\t\t\toptions.pop(o, None)\n\t\treturn GraphicPrimitive_xydata._plot3d_options(self, options)\n\n\tdef plot3d(self, z=0, **kwds):\n\t\t\"\"\"\n\t\tPlots a 2D polygon in 3D, with default height zero.\n\n\t\tINPUT:\n\n\n\t\t-  ``z`` - optional 3D height above `xy`-plane, or a list of\n\t\t   heights corresponding to the list of 2D polygon points.\n\n\t\tEXAMPLES:\n\n\t\tA pentagon::\n\n\t\t\tsage: polygon([(cos(t), sin(t)) for t in srange(0, 2*pi, 2*pi/5)]).plot3d()\n\t\t\tGraphics3d Object\n\n\t\tShowing behavior of the optional parameter z::\n\n\t\t\tsage: P = polygon([(0,0), (1,2), (0,1), (-1,2)])\n\t\t\tsage: p = P[0]; p\n\t\t\tPolygon defined by 4 points\n\t\t\tsage: q = p.plot3d()\n\t\t\tsage: q.obj_repr(q.testing_render_params())[2]\n\t\t\t['v 0 0 0', 'v 1 2 0', 'v 0 1 0', 'v -1 2 0']\n\t\t\tsage: r = p.plot3d(z=3)\n\t\t\tsage: r.obj_repr(r.testing_render_params())[2]\n\t\t\t['v 0 0 3', 'v 1 2 3', 'v 0 1 3', 'v -1 2 3']\n\t\t\tsage: s = p.plot3d(z=[0,1,2,3])\n\t\t\tsage: s.obj_repr(s.testing_render_params())[2]\n\t\t\t['v 0 0 0', 'v 1 2 1', 'v 0 1 2', 'v -1 2 3']\n\n\t\tTESTS:\n\n\t\tHeights passed as a list should have same length as\n\t\tnumber of points::\n\n\t\t\tsage: P = polygon([(0,0), (1,2), (0,1), (-1,2)])\n\t\t\tsage: p = P[0]\n\t\t\tsage: q = p.plot3d(z=[2,-2])\n\t\t\tTraceback (most recent call last):\n\t\t\t...\n\t\t\tValueError: Incorrect number of heights given\n\t\t\"\"\"\n\t\tfrom sage.plot.plot3d.index_face_set import IndexFaceSet\n\t\toptions = self._plot3d_options()\n\t\toptions.update(kwds)\n\t\tzdata=[]\n\t\tif isinstance(z, list):\n\t\t\tzdata=z\n\t\telse:\n\t\t\tzdata=[z]*len(self.xdata)\n\t\tif len(zdata)==len(self.xdata):\n\t\t\treturn IndexFaceSet([[(x, y, z) for x, y, z in zip(self.xdata, self.ydata, zdata)]], **options)\n\t\telse:\n\t\t\traise ValueError('Incorrect number of heights given')\n\n\tdef _render_on_subplot(self, subplot):\n\t\t\"\"\"\n\t\tTESTS::\n\n\t\t\tsage: P = polygon([(0,0), (1,2), (0,1), (-1,2)])\n\t\t\"\"\"\n\t\timport matplotlib.patches as patches\n\t\toptions = self.options()\n\t\tp = patches.Polygon([(self.xdata[i],self.ydata[i]) for i in xrange(len(self.xdata))])\n\t\tp.set_linewidth(float(options['thickness']))\n\t\ta = float(options['alpha'])\n\t\tz = int(options.pop('zorder', 1))\n\t\tp.set_alpha(a)\n\t\tf = options.pop('fill')\n\t\tp.set_fill(f)\n\t\tc = to_mpl_color(options['rgbcolor'])\n\t\tif f:\n\t\t\tec = options['edgecolor']\n\t\t\tif ec is None:\n\t\t\t\tp.set_color(c)\n\t\t\telse:\n\t\t\t\tp.set_facecolor(c)\n\t\t\t\tp.set_edgecolor(to_mpl_color(ec))\n\t\telse:\n\t\t\tp.set_color(c)\n\t\tp.set_label(options['legend_label'])\n\t\tp.set_zorder(z)\n\t\tsubplot.add_patch(p)\n\n", "description": "\n\tPrimitive class for the Polygon graphics type.  For information\n\ton actual plotting, please see :func:`polygon`, :func:`polygon2d`,\n\tor :func:`~sage.plot.plot3d.shapes2.polygon3d`.\n\n\tINPUT:\n\n\t- xdata - list of `x`-coordinates of points defining Polygon\n\n\t- ydata - list of `y`-coordinates of points defining Polygon\n\n\t- options - dict of valid plot options to pass to constructor\n\n\tEXAMPLES:\n\n\tNote this should normally be used indirectly via :func:`polygon`::\n\n\t\tsage: from sage.plot.polygon import Polygon\n\t\tsage: P = Polygon([1,2,3],[2,3,2],{'alpha':.5})\n\t\tsage: P\n\t\tPolygon defined by 3 points\n\t\tsage: P.options()['alpha']\n\t\t0.500000000000000\n\t\tsage: P.ydata\n\t\t[2, 3, 2]\n\n\tTESTS:\n\n\tWe test creating polygons::\n\n\t\tsage: polygon([(0,0), (1,1), (0,1)])\n\t\tGraphics object consisting of 1 graphics primitive\n\n\t::\n\n\t\tsage: polygon([(0,0,1), (1,1,1), (2,0,1)])\n\t\tGraphics3d Object\n\t", "category": "graphics", "imports": ["from sage.plot.primitive import GraphicPrimitive_xydata", "from sage.misc.decorators import options, rename_keyword", "from sage.plot.colors import to_mpl_color", "\t\tsage: from sage.plot.polygon import Polygon", "\t\tfrom sage.plot.plot3d.index_face_set import IndexFaceSet", "\t\timport matplotlib.patches as patches", "\t\tfrom sage.plot.plot3d.shapes2 import polygon3d", "\tfrom sage.plot.plot import xydata_from_point_list", "\tfrom sage.plot.all import Graphics"]}, {"term": "def", "name": "polygon", "data": "def polygon(points, **options):\n\t\"\"\"\n\tReturns either a 2-dimensional or 3-dimensional polygon depending\n\ton value of points.\n\n\tFor information regarding additional arguments, see either\n\t:func:`polygon2d` or :func:`~sage.plot.plot3d.shapes2.polygon3d`.\n\tOptions may be found and set using the dictionaries ``polygon2d.options``\n\tand ``polygon3d.options``.\n\n\tEXAMPLES::\n\n\t\tsage: polygon([(0,0), (1,1), (0,1)])\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: polygon([(0,0,1), (1,1,1), (2,0,1)])\n\t\tGraphics3d Object\n\n\tExtra options will get passed on to show(), as long as they are valid::\n\n\t\tsage: polygon([(0,0), (1,1), (0,1)], axes=False)\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: polygon([(0,0), (1,1), (0,1)]).show(axes=False) # These are equivalent\n\t\"\"\"\n\ttry:\n\t\treturn polygon2d(points, **options)\n\texcept ValueError:\n\t\tfrom sage.plot.plot3d.shapes2 import polygon3d\n\t\treturn polygon3d(points, **options)\n", "description": "\n\tReturns either a 2-dimensional or 3-dimensional polygon depending\n\ton value of points.\n\n\tFor information regarding additional arguments, see either\n\t:func:`polygon2d` or :func:`~sage.plot.plot3d.shapes2.polygon3d`.\n\tOptions may be found and set using the dictionaries ``polygon2d.options``\n\tand ``polygon3d.options``.\n\n\tEXAMPLES::\n\n\t\tsage: polygon([(0,0), (1,1), (0,1)])\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: polygon([(0,0,1), (1,1,1), (2,0,1)])\n\t\tGraphics3d Object\n\n\tExtra options will get passed on to show(), as long as they are valid::\n\n\t\tsage: polygon([(0,0), (1,1), (0,1)], axes=False)\n\t\tGraphics object consisting of 1 graphics primitive\n\t\tsage: polygon([(0,0), (1,1), (0,1)]).show(axes=False) # These are equivalent\n\t", "category": "graphics", "imports": ["from sage.plot.primitive import GraphicPrimitive_xydata", "from sage.misc.decorators import options, rename_keyword", "from sage.plot.colors import to_mpl_color", "\t\tsage: from sage.plot.polygon import Polygon", "\t\tfrom sage.plot.plot3d.index_face_set import IndexFaceSet", "\t\timport matplotlib.patches as patches", "\t\tfrom sage.plot.plot3d.shapes2 import polygon3d", "\tfrom sage.plot.plot import xydata_from_point_list", "\tfrom sage.plot.all import Graphics"]}, {"term": "def", "name": "polygon2d", "data": "def polygon2d(points, **options):\n\tr\"\"\"\n\tReturns a 2-dimensional polygon defined by ``points``.\n\n\tType ``polygon2d.options`` for a dictionary of the default\n\toptions for polygons.  You can change this to change the\n\tdefaults for all future polygons.  Use ``polygon2d.reset()``\n\tto reset to the default options.\n\n\tEXAMPLES:\n\n\tWe create a purple-ish polygon::\n\n\t\tsage: polygon2d([[1,2], [5,6], [5,0]], rgbcolor=(1,0,1))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tBy default, polygons are filled in, but we can make them\n\twithout a fill as well::\n\n\t\tsage: polygon2d([[1,2], [5,6], [5,0]], fill=False)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tIn either case, the thickness of the border can be controlled::\n\n\t\tsage: polygon2d([[1,2], [5,6], [5,0]], fill=False, thickness=4, color='orange')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tFor filled polygons, one can use different colors for the border\n\tand the interior as follows::\n\n\t\tsage: L = [[0,0]]+[[i/100, 1.1+cos(i/20)] for i in range(100)]+[[1,0]]\n\t\tsage: polygon2d(L, color=\"limegreen\", edgecolor=\"black\", axes=False)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tSome modern art -- a random polygon, with legend::\n\n\t\tsage: v = [(randrange(-5,5), randrange(-5,5)) for _ in range(10)]\n\t\tsage: polygon2d(v, legend_label='some form')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA purple hexagon::\n\n\t\tsage: L = [[cos(pi*i/3),sin(pi*i/3)] for i in range(6)]\n\t\tsage: polygon2d(L, rgbcolor=(1,0,1))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA green deltoid::\n\n\t\tsage: L = [[-1+cos(pi*i/100)*(1+cos(pi*i/100)),2*sin(pi*i/100)*(1-cos(pi*i/100))] for i in range(200)]\n\t\tsage: polygon2d(L, rgbcolor=(1/8,3/4,1/2))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA blue hypotrochoid::\n\n\t\tsage: L = [[6*cos(pi*i/100)+5*cos((6/2)*pi*i/100),6*sin(pi*i/100)-5*sin((6/2)*pi*i/100)] for i in range(200)]\n\t\tsage: polygon2d(L, rgbcolor=(1/8,1/4,1/2))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAnother one::\n\n\t\tsage: n = 4; h = 5; b = 2\n\t\tsage: L = [[n*cos(pi*i/100)+h*cos((n/b)*pi*i/100),n*sin(pi*i/100)-h*sin((n/b)*pi*i/100)] for i in range(200)]\n\t\tsage: polygon2d(L, rgbcolor=(1/8,1/4,3/4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA purple epicycloid::\n\n\t\tsage: m = 9; b = 1\n\t\tsage: L = [[m*cos(pi*i/100)+b*cos((m/b)*pi*i/100),m*sin(pi*i/100)-b*sin((m/b)*pi*i/100)] for i in range(200)]\n\t\tsage: polygon2d(L, rgbcolor=(7/8,1/4,3/4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA brown astroid::\n\n\t\tsage: L = [[cos(pi*i/100)^3,sin(pi*i/100)^3] for i in range(200)]\n\t\tsage: polygon2d(L, rgbcolor=(3/4,1/4,1/4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAnd, my favorite, a greenish blob::\n\n\t\tsage: L = [[cos(pi*i/100)*(1+cos(pi*i/50)), sin(pi*i/100)*(1+sin(pi*i/50))] for i in range(200)]\n\t\tsage: polygon2d(L, rgbcolor=(1/8, 3/4, 1/2))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tThis one is for my wife::\n\n\t\tsage: L = [[sin(pi*i/100)+sin(pi*i/50),-(1+cos(pi*i/100)+cos(pi*i/50))] for i in range(-100,100)]\n\t\tsage: polygon2d(L, rgbcolor=(1,1/4,1/2))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tOne can do the same one with a colored legend label::\n\n\t\tsage: polygon2d(L, color='red', legend_label='For you!', legend_color='red')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tPolygons have a default aspect ratio of 1.0::\n\n\t\tsage: polygon2d([[1,2], [5,6], [5,0]]).aspect_ratio()\n\t\t1.0\n\n\tAUTHORS:\n\n\t- David Joyner (2006-04-14): the long list of examples above.\n\n\t\"\"\"\n\tfrom sage.plot.plot import xydata_from_point_list\n\tfrom sage.plot.all import Graphics\n\tif options[\"thickness\"] is None:   # If the user did not specify thickness\n\t\tif options[\"fill\"] and options[\"edgecolor\"] is None:\n\t\t\t# If the user chose fill\n\t\t\toptions[\"thickness\"] = 0\n\t\telse:\n\t\t\toptions[\"thickness\"] = 1\n\txdata, ydata = xydata_from_point_list(points)\n\tg = Graphics()\n\n\t# Reset aspect_ratio to 'automatic' in case scale is 'semilog[xy]'.\n\t# Otherwise matplotlib complains.\n\tscale = options.get('scale', None)\n\tif isinstance(scale, (list, tuple)):\n\t\tscale = scale[0]\n\tif scale == 'semilogy' or scale == 'semilogx':\n\t\toptions['aspect_ratio'] = 'automatic'\n\n\tg._set_extra_kwds(Graphics._extract_kwds_for_show(options))\n\tg.add_primitive(Polygon(xdata, ydata, options))\n\tif options['legend_label']:\n\t\tg.legend(True)\n\t\tg._legend_colors = [options['legend_color']]\n\treturn g\n", "description": "\n\tReturns a 2-dimensional polygon defined by ``points``.\n\n\tType ``polygon2d.options`` for a dictionary of the default\n\toptions for polygons.  You can change this to change the\n\tdefaults for all future polygons.  Use ``polygon2d.reset()``\n\tto reset to the default options.\n\n\tEXAMPLES:\n\n\tWe create a purple-ish polygon::\n\n\t\tsage: polygon2d([[1,2], [5,6], [5,0]], rgbcolor=(1,0,1))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tBy default, polygons are filled in, but we can make them\n\twithout a fill as well::\n\n\t\tsage: polygon2d([[1,2], [5,6], [5,0]], fill=False)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tIn either case, the thickness of the border can be controlled::\n\n\t\tsage: polygon2d([[1,2], [5,6], [5,0]], fill=False, thickness=4, color='orange')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tFor filled polygons, one can use different colors for the border\n\tand the interior as follows::\n\n\t\tsage: L = [[0,0]]+[[i/100, 1.1+cos(i/20)] for i in range(100)]+[[1,0]]\n\t\tsage: polygon2d(L, color=\"limegreen\", edgecolor=\"black\", axes=False)\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tSome modern art -- a random polygon, with legend::\n\n\t\tsage: v = [(randrange(-5,5), randrange(-5,5)) for _ in range(10)]\n\t\tsage: polygon2d(v, legend_label='some form')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA purple hexagon::\n\n\t\tsage: L = [[cos(pi*i/3),sin(pi*i/3)] for i in range(6)]\n\t\tsage: polygon2d(L, rgbcolor=(1,0,1))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA green deltoid::\n\n\t\tsage: L = [[-1+cos(pi*i/100)*(1+cos(pi*i/100)),2*sin(pi*i/100)*(1-cos(pi*i/100))] for i in range(200)]\n\t\tsage: polygon2d(L, rgbcolor=(1/8,3/4,1/2))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA blue hypotrochoid::\n\n\t\tsage: L = [[6*cos(pi*i/100)+5*cos((6/2)*pi*i/100),6*sin(pi*i/100)-5*sin((6/2)*pi*i/100)] for i in range(200)]\n\t\tsage: polygon2d(L, rgbcolor=(1/8,1/4,1/2))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAnother one::\n\n\t\tsage: n = 4; h = 5; b = 2\n\t\tsage: L = [[n*cos(pi*i/100)+h*cos((n/b)*pi*i/100),n*sin(pi*i/100)-h*sin((n/b)*pi*i/100)] for i in range(200)]\n\t\tsage: polygon2d(L, rgbcolor=(1/8,1/4,3/4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA purple epicycloid::\n\n\t\tsage: m = 9; b = 1\n\t\tsage: L = [[m*cos(pi*i/100)+b*cos((m/b)*pi*i/100),m*sin(pi*i/100)-b*sin((m/b)*pi*i/100)] for i in range(200)]\n\t\tsage: polygon2d(L, rgbcolor=(7/8,1/4,3/4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tA brown astroid::\n\n\t\tsage: L = [[cos(pi*i/100)^3,sin(pi*i/100)^3] for i in range(200)]\n\t\tsage: polygon2d(L, rgbcolor=(3/4,1/4,1/4))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tAnd, my favorite, a greenish blob::\n\n\t\tsage: L = [[cos(pi*i/100)*(1+cos(pi*i/50)), sin(pi*i/100)*(1+sin(pi*i/50))] for i in range(200)]\n\t\tsage: polygon2d(L, rgbcolor=(1/8, 3/4, 1/2))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tThis one is for my wife::\n\n\t\tsage: L = [[sin(pi*i/100)+sin(pi*i/50),-(1+cos(pi*i/100)+cos(pi*i/50))] for i in range(-100,100)]\n\t\tsage: polygon2d(L, rgbcolor=(1,1/4,1/2))\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tOne can do the same one with a colored legend label::\n\n\t\tsage: polygon2d(L, color='red', legend_label='For you!', legend_color='red')\n\t\tGraphics object consisting of 1 graphics primitive\n\n\tPolygons have a default aspect ratio of 1.0::\n\n\t\tsage: polygon2d([[1,2], [5,6], [5,0]]).aspect_ratio()\n\t\t1.0\n\n\tAUTHORS:\n\n\t- David Joyner (2006-04-14): the long list of examples above.\n\n\t", "category": "graphics", "imports": ["from sage.plot.primitive import GraphicPrimitive_xydata", "from sage.misc.decorators import options, rename_keyword", "from sage.plot.colors import to_mpl_color", "\t\tsage: from sage.plot.polygon import Polygon", "\t\tfrom sage.plot.plot3d.index_face_set import IndexFaceSet", "\t\timport matplotlib.patches as patches", "\t\tfrom sage.plot.plot3d.shapes2 import polygon3d", "\tfrom sage.plot.plot import xydata_from_point_list", "\tfrom sage.plot.all import Graphics"]}], [{"term": "def", "name": "setup", "data": "def setup():\n\torig_graphics = capable.OF_GRAPHICS\n\tcapable.OF_GRAPHICS = True\n", "description": null, "category": "graphics", "imports": ["import pytest", "import os", "from .utils import HAS_IRAF", "from pyraf import gki", "from ..tools import capable", "\tfrom pyraf import iraf", "\timport tkinter"]}, {"term": "def", "name": "test_plot_prow", "data": "def test_plot_prow(marker, graphics):\n\tos.environ['PYRAFGRAPHICS'] = graphics\n\tapd = False\n\tfor row in range(150, 331, 90):\n\t\tif marker is None:\n\t\t\tiraf.prow('dev$pix', row, wy2=400, append=apd, pointmode=False)\n\t\telse:\n\t\t\tiraf.prow('dev$pix', row, wy2=400, append=apd, pointmode=True,\n\t\t\t\t\t  marker=marker)\n\t\tapd = True\n\n", "description": null, "category": "graphics", "imports": ["import pytest", "import os", "from .utils import HAS_IRAF", "from pyraf import gki", "from ..tools import capable", "\tfrom pyraf import iraf", "\timport tkinter"]}, {"term": "def", "name": "test_plot_graph", "data": "def test_plot_graph(marker, graphics):\n\tos.environ['PYRAFGRAPHICS'] = graphics\n\ttstr = ''\n\tfor row in range(150, 331, 90):\n\t\ttstr += 'dev$pix[*,' + str(row) + '],'\n\ttstr = tstr[:-1]  # rm final comma\n\tif marker is None:\n\t\tiraf.graph(tstr, wy2=400, pointmode=False, ltypes='1')\n\telse:\n\t\tiraf.graph(tstr, wy2=400, pointmode=True, marker=marker)\n\n", "description": null, "category": "graphics", "imports": ["import pytest", "import os", "from .utils import HAS_IRAF", "from pyraf import gki", "from ..tools import capable", "\tfrom pyraf import iraf", "\timport tkinter"]}, {"term": "def", "name": "test_plot_contour", "data": "def test_plot_contour(graphics):\n\tos.environ['PYRAFGRAPHICS'] = graphics\n\tiraf.contour(\"dev$pix\", Stderr='/dev/null')\n\n", "description": null, "category": "graphics", "imports": ["import pytest", "import os", "from .utils import HAS_IRAF", "from pyraf import gki", "from ..tools import capable", "\tfrom pyraf import iraf", "\timport tkinter"]}, {"term": "def", "name": "test_plot_surface", "data": "def test_plot_surface(graphics):\n\tos.environ['PYRAFGRAPHICS'] = graphics\n\tiraf.surface(\"dev$pix\", Stderr='/dev/null')\n", "description": null, "category": "graphics", "imports": ["import pytest", "import os", "from .utils import HAS_IRAF", "from pyraf import gki", "from ..tools import capable", "\tfrom pyraf import iraf", "\timport tkinter"]}], [{"term": "class", "name": "Renderer", "data": "class Renderer(Component):\n\n\tdef __init__(self, engineobj=None, graphicscomponent=None, window=None):\n\t\tsuper().__init__(engineobj)\n\n\t\tself.graphics_component = graphicscomponent\n\t\tself.add_container(graphicscomponent)\n\t\tself.graphics_component_id = graphicscomponent.id\n\n\t\tself.window = window\n\n\n\tdef draw_static(self, name, x1=None, y1=None, rectangle=None, anchor=None):\n\t\t\"\"\"\n\t\tname - name of sprite in db\n\t\tx1, y1 - coords; if None - previous position\n\t\t\"\"\"\n\n\t\tsprites_container = self.graphics_component.sprites_container\n\n\n\t\t# ~sprite = sprites_container.data[self.graphics_component_id]['static'][name]\n\t\tsprite = sprites_container.data[self.graphics_component_id][name]['sprite']\n\n\t\twidth = sprite.texture.width\n\t\theight = sprite.texture.height\n\n\t\tif not x1 is None and not y1 is None:\n\t\t\tsprite.position = (x1, y1)\n\n\t\tif not rectangle is None:\n\t\t\tsprite.texture_rectangle = rectangle\n\t\t\twidth = rectangle.width\n\t\t\theight = rectangle.height\n\n\t\tif not anchor is None:\n\t\t\tsprite.origin = (anchor[0]*width, anchor[1]*height)\n\n\t\tself.window.draw(sprite)\n\n\n\n\tdef draw_sprite(self, name, x1=None, y1=None, rectangle=None, anchor=None, category='static'):\n\t\t\"\"\"\n\t\tname - name of sprite in db\n\t\tx1, y1 - coords; if None - previous position\n\t\t\"\"\"\n\n\t\tsprites_container = self.graphics_component.sprites_container\n\n\n\t\t# ~sprite = sprites_container.data[self.graphics_component_id]['static'][name]\n\t\tsprite = sprites_container.data[self.graphics_component_id][name]['sprite']\n\n\t\twidth = sprite.texture.width\n\t\theight = sprite.texture.height\n\n\t\tif not x1 is None and not y1 is None:\n\t\t\tsprite.position = (x1, y1)\n\n\t\tif not rectangle is None:\n\t\t\tsprite.texture_rectangle = rectangle\n\n\n\n\t\tif not anchor is None:\n\t\t\tsprite.origin = (anchor[0]*width, anchor[1]*height)\n\n\t\tself.window.draw(sprite)\n\n\n\tdef draw_animation(self, name, x1, y1, x2, y2, step=100, steps=0, category='animation'):\n\t\t\"\"\"\n\t\tname - name of animation in db\n\t\tx1, y1 - start\n\t\tx2, y2 - finish\n\t\tstep - size of dx in pixels\n\t\tspeed - length of pause after each frame, in ms\n\t\t\"\"\"\n\n\t\tsprites_container = self.graphics_component.sprites_container\n\n\t\tsprite = sprites_container.data[self.graphics_component_id]['animation'][name][0]\n\t\tframes = sprites_container.data[self.graphics_component_id]['animation'][name][1]\n\n\t\tx1 = int(x1)\n\t\ty1 = int(y1)\n\t\tx2 = int(x2)\n\t\ty2 = int(y2)\n\n\t\tdx = x2 - x1\n\t\tdy = y2 - y1\n\n\n\n\t\tif abs(dx)>S/100:\n\n\n\t\t\tsteps = abs(int(dx//step))\n\t\telse:\n\n\n\t\t\tsteps = abs(int(dy//step))\n\n\n\t\twidth = int(sprite.texture.width)\n\n\t\tframewidth = int(width//frames)\n\n\t\theight = int(sprite.texture.height)\n\n\t\tcur_x = 0\n\n\t\trectangle = (cur_x, 0, cur_x+framewidth, height)\n\n\t\tsprite.texture_rectangle = rectangle\n\n\t\tfor i in range(steps):\n\n\n\n\t\t\tcur_x = (cur_x+framewidth)%width\n\n\t\t\trectangle = sf.Rectangle((cur_x, 0), (framewidth, height))\n\n\n\n\n\t\t\tself.engine.push_event(DrawMapEvent(layer='Surfaces'))\n\t\t\tself.engine.push_event(DrawMapEvent(layer='UnitsTextures'))\n\n\n\n\t\t\tself.engine.push_event(DrawStaticEvent(name=name, x1=int(x1+i*dx/steps), y1=int(y1+i*dy/steps), anchor=(0.5, 0.5), rectangle=rectangle))\n\t\t\tself.engine.push_event(DisplayEvent())\n\n\n\tdef animate(self, name, x1, y1, x2, y2, step=100, steps=0):\n\t\t\"\"\"\n\t\tname - name of animation in db\n\t\tx1, y1 - start\n\t\tx2, y2 - finish\n\t\tstep - size of dx in pixels\n\t\tspeed - length of pause after each frame, in ms\n\t\t\"\"\"\n\n\t\tsprites_container = self.graphics_component.sprites_container\n\n\t\t# ~print('sprites_container.data[self.graphics_component_id].keys():', sprites_container.data[self.graphics_component_id].keys())\n\n\t\tsprite = sprites_container.data[self.graphics_component_id][name]['sprite']\n\t\tframes = sprites_container.data[self.graphics_component_id][name]['frames']\n\n\t\tx1 = int(x1)\n\t\ty1 = int(y1)\n\t\tx2 = int(x2)\n\t\ty2 = int(y2)\n\n\t\tdx = x2 - x1\n\t\tdy = y2 - y1\n\n\n\n\t\tif abs(dx)>S/100:\n\n\n\t\t\tsteps = abs(int(dx//step))\n\t\telse:\n\n\n\t\t\tsteps = abs(int(dy//step))\n\n\n\t\twidth = int(sprite.texture.width)\n\n\t\tframewidth = int(width//frames)\n\n\t\theight = int(sprite.texture.height)\n\n\t\tcur_x = 0\n\n\t\trectangle = (cur_x, 0, cur_x+framewidth, height)\n\n\t\tsprite.texture_rectangle = rectangle\n\n\t\tfor i in range(steps):\n\n\t\t\tcur_x = (cur_x+framewidth)%width\n\n\t\t\trectangle = sf.Rectangle((cur_x, 0), (framewidth, height))\n\n\t\t\t# ~self.engine.push_event(DrawMapEvent(layer='Surfaces'))\n\t\t\t# ~self.engine.push_event(DrawMapEvent(layer='UnitsTextures'))\n\n\t\t\tself.engine.push_event(UpdateSceneEvent(layers_order=['Surfaces', 'Buildings', 'UnitsTextures']))\n\n\t\t\tself.engine.push_event(DrawStaticEvent(name=name, x1=int(x1+i*dx/steps), y1=int(y1+i*dy/steps), anchor=(0.5, 0.5), rectangle=rectangle))\n\t\t\t# ~self.engine.push_event(DisplayEvent())\n\n\n\tdef render_prerendered_map(self, layer='Surfaces'):\n\n\t\tmapobj = self.engine.containers['MAP']\n\n\t\tsprites_container = self.graphics_component.sprites_container\n\n\t\tsprites = sprites_container.data[self.graphics_component_id]['prerendered']\n\n\t\tmap_texture = sprites[layer]\n\n\t\tsprite = sf.Sprite(map_texture.texture)\n\n\n\t\tself.window.draw(sprite)\n\n\n\tdef draw_map_layer(self, layer='Surfaces'):\n\n\t\tmapobj = self.engine.containers['MAP']\n\n\t\tsprites_container = self.graphics_component.sprites_container\n\n\t\tsprites = sprites_container.data[self.graphics_component_id]['prerendered']\n\n\t\tmap_texture = sprites[layer]\n\n\t\tsprite = sf.Sprite(map_texture.texture)\n\n\t\tself.window.draw(sprite)\n\n\t\t# ~view = sf.View()\n\t\t# ~view.viewport = (0.75, 0, 0.25, 0.3)\n\t\t# ~oldview = self.window.view\n\t\t# ~self.window.view = view\n\t\t# ~self.window.draw(sprite)\n\t\t# ~self.window.view = oldview\n\n\n\n\n\tdef render_map(self):\n\n\t\tmapobj = self.engine.containers['MAP']\n\n\t\tt = mapobj.type\n\n\t\tsprites_container = self.graphics_component.sprites_container\n\n\t\tsprites = sprites_container.data[self.graphics_component_id]['static']\n\n\t\tsurfaces_layer = [[sprites[i] for i in j] for j in mapobj.layers['Surfaces']]\n\n\t\tfor i in enumerate(surfaces_layer):\n\t\t\tfor j in enumerate(surfaces_layer[i[0]]):\n\n\t\t\t\tsprite = j[1]\n\n\t\t\t\twidth = sprite.texture.width\n\n\t\t\t\theight = sprite.texture.height\n\n\t\t\t\tsprite.origin = (width//2, height//2)\n\n\t\t\t\tsprite.position = (t['hex_x'](i[0], j[0], S), t['hex_y'](i[0], j[0], S))\n\n\t\t\t\tself.window.draw(sprite)\n\n\n", "description": "\n\t\tname - name of sprite in db\n\t\tx1, y1 - coords; if None - previous position\n\t\t", "category": "graphics", "imports": ["import sys", "import sfml as sf", "#~ from sfml import sf", "# ~from engine.engine import Engine", "# ~from components.components import *", "from .component import *", "# ~from models.models import *", "from events.events import *", "from support.support import *"]}], [{"term": "class", "name": "Labeling_Tool_GUI", "data": "class Labeling_Tool_GUI(QMainWindow):\n\n\tdef __init__(self, scale_factor, margin_factor=0.85):\n\t\tsuper(Labeling_Tool_GUI, self).__init__()\n\t\t# Set the window to the foreground\n\t\t# self.setWindowFlags(QtCore.Qt.Window | QtCore.Qt.CustomizeWindowHint | Qt.WindowStaysOnTopHint | QtCore.Qt.WindowCloseButtonHint | QtCore.Qt.WindowMinimizeButtonHint)\n\n\t\t# print(\"self.getWindowFlags() =\", self.windowFlags())\n\t\tself.gui_path = os.getcwd() + os.sep\n\t\tself.parrent_path = (os.sep).join(os.getcwd().split(os.sep)[:-1]) + os.sep\n\t\tself.anno_path = self.parrent_path + \"Annotation_Files\" + os.sep\n\t\tself.pred_path = self.parrent_path + \"Predicted_Labels\" + os.sep\n\t\tself.video_path = self.parrent_path + \"Videos\" + os.sep + \"ARG 19 SS16 OBC NEU POV\" + os.sep\n\t\tprint(\"self.gui_path =\", self.gui_path)\n\t\tprint(\"self.parrent_path =\", self.parrent_path)\n\t\tprint(\"self.anno_path =\", self.anno_path)\n\t\tprint(\"self.pred_path =\", self.pred_path)\n\t\tprint(\"self.video_path =\", self.video_path)\n\n\t\tfor cur_path in [self.gui_path, self.parrent_path, self.anno_path, self.pred_path, self.video_path]:\n\t\t\tif not os.path.isdir(cur_path):\n\t\t\t\tos.makedirs(cur_path)\n\n\t\tself.cur_video_path = \"\"\n\n\t\tif self.cur_video_path == \"\":\n\t\t\tself.all_videos_in_video_dir = [elem for elem in glob.glob(self.video_path + \"*.mp4\")]\n\t\telse:\n\t\t\tself.all_videos_in_video_dir = [self.cur_video_path]\n\n\t\tself.scale_factor = scale_factor\n\t\tself.scene_factor = margin_factor\n\t\tself.org_height, self.org_width, self.org_channels = 1080, 1920, 3\n\t\tif len(self.all_videos_in_video_dir) > 0:\n\t\t\tself.cur_video_path = self.all_videos_in_video_dir[0]\n\n\t\t\t# OpenCV stuff:\n\t\t\t# self.cur_video_path = \"D:/Dropbox/Dropbox/DFKI (Arbeit)/WRC/Videos/ARG 19 SS16 OBC NEU POV/ARG 19 SS16 OBC NEU POV.mp4\"\n\t\t\ttemp_vidcap = cv2.VideoCapture(self.cur_video_path)\n\t\t\tsuccess, image = temp_vidcap.read()\n\t\t\tself.total_num_frames = int(temp_vidcap.get(cv2.CAP_PROP_FRAME_COUNT))\n\t\t\ttemp_vidcap.release()\n\n\t\t\tself.org_height, self.org_width, self.org_channels = image.shape\n\t\t\t# self.margin_right = 175\n\t\t\t# self.margin_bottom = 100\n\t\t\t# self.scale_height, self.scale_width, _ = (self.scale_factor * np.array(image.shape)).astype(int)\n\t\t\tself.scale_height, self.scale_width = int(self.scale_factor * self.org_height), int(self.scale_factor * self.org_width)\n\t\t\t# self.scene_height, self.scene_width = (0.85 * np.array([self.scale_height, self.scale_width])).astype(int)\n\t\t\t# self.scene_height, self.scene_width = int(self.scale_height - self.margin_bottom), int(self.scale_width - self.margin_right)\n\t\t\tself.scene_height, self.scene_width = int(self.scene_factor * self.scale_height), int(self.scene_factor * self.scale_width)\n\t\t\tself.margin_right = self.scale_width - self.scene_width\n\t\t\tself.margin_bottom = self.scale_height - self.scene_height\n\t\t\tprint(\"self.org_height, self.org_width, self.org_channels =\", self.org_height, self.org_width, self.org_channels)\n\t\t\tprint(\"self.scale_height, self.scale_width =\", self.scale_height, self.scale_width)\n\t\t\tprint(\"self.scene_height, self.scene_width =\", self.scene_height, self.scene_width)\n\t\telse:\n\t\t\tself.cur_video_path = \"\"\n\t\t\tself.total_num_frames = -1\n\n\n\t\t\t# self.margin_right = 175\n\t\t\t# self.margin_bottom = 100\n\t\t\tself.scale_height, self.scale_width, _ = (self.scale_factor * np.array([self.org_height, self.org_width, self.org_channels])).astype(int)\n\t\t\t# self.scene_height, self.scene_width = (0.85 * np.array([self.scale_height, self.scale_width])).astype(int)\n\t\t\t# self.scene_height, self.scene_width = int(self.scale_height - self.margin_bottom), int(self.scale_width - self.margin_right)\n\t\t\tself.scene_height, self.scene_width = int(self.scene_factor * self.scale_height), int(self.scene_factor * self.scale_width)\n\t\t\tself.margin_right = self.scale_width - self.scene_width\n\t\t\tself.margin_bottom = self.scale_height - self.scene_height\n\t\t\tprint(\"self.org_height, self.org_width, self.org_channels =\", self.org_height, self.org_width, self.org_channels)\n\t\t\tprint(\"self.scale_height, self.scale_width =\", self.scale_height, self.scale_width)\n\t\t\tprint(\"self.scene_height, self.scene_width =\", self.scene_height, self.scene_width)\n\n\t\tself.frame_counter = 0\n\t\tself.cur_class = 0\n\t\tself.class_list = [\"No Class\",\n\t\t\t\t\t\t   \"Safe Person\",\n\t\t\t\t\t\t   \"Partially Safe Person\",\n\t\t\t\t\t\t   \"Unsafe Person\"\n\t\t\t\t\t\t   ]\n\n\t\tself.class_colors = [(0, 163, 232),\n\t\t\t\t\t\t\t (0, 200, 0),\n\t\t\t\t\t\t\t (232, 163, 0),\n\t\t\t\t\t\t\t (200, 0, 0)\n\t\t\t\t\t\t\t ]\n\n\t\t\"\"\"\n\t\tself.tag_list = sorted([\"blurry\",\n\t\t\t\t\t\t\t   \"covered\",\n\t\t\t\t\t\t\t   \"noisy\",\n\t\t\t\t\t\t\t   \"size-L\",\n\t\t\t\t\t\t\t   \"size-M\",\n\t\t\t\t\t\t\t   \"size-S\"\n\t\t\t\t\t\t\t   ])\n\t\t\"\"\"\n\n\t\tself.config_path = os.getcwd() + os.sep + \"config.csv\"\n\t\tself.tag_list = []\n\t\tif os.path.isfile(self.config_path):\n\t\t\tconfig_file = open(self.config_path, 'r', encoding=\"utf-8\")\n\t\t\tclass_csv_Reader = list(csv.reader(config_file, delimiter=','))\n\t\t\tprint(\"class_csv_Reader =\", class_csv_Reader)\n\t\t\tself.tag_list = [tag for row in class_csv_Reader for tag in row[1:] if row[0] == \"tags\"]\n\t\t\tprint(\"self.tag_list =\", self.tag_list)\n\t\t\tconfig_file.close()\n\n\t\tif not os.path.isfile(self.config_path) or len(self.tag_list) == 0:\n\t\t\tconfig_file = open(self.config_path, 'a+')\n\t\t\tconfig_file.write(\"tags,blurry,covered,noisy\\n\")\n\t\t\tself.tag_list = [\"blurry\", \"covered\", \"noisy\"]\n\t\t\tconfig_file.close()\n\n\t\tself.tag_list = sorted(list(set(self.tag_list)))\n\t\tself.used_tags = []\n\n\t\tself.load_layout()\n\n\t\tself.graphics_scene.chk_box_list = self.chk_box_list\n\t\tself.graphics_scene.tag_list = self.tag_list\n\t\tself.graphics_scene.combo_box = self.combo_box\n\n\t\t# For zoom-function\n\t\tself._zoom = 0.0\n\t\tself.graphics_viewer.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)\n\t\tself.graphics_viewer.setResizeAnchor(QGraphicsView.AnchorUnderMouse)\n\n\t\t# self.graphics_viewer.setTransformationAnchor(QGraphicsView.AnchorViewCenter)\n\t\t# self.graphics_viewer.setResizeAnchor(QGraphicsView.AnchorViewCenter)\n\t\t# self.graphics_viewer.setTransformationAnchor(QGraphicsView.NoAnchor)\n\t\t# self.graphics_viewer.setResizeAnchor(QGraphicsView.NoAnchor)\n\t\tself.graphics_viewer.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n\t\tself.graphics_viewer.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n\t\t# self.graphics_viewer.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)\n\t\t# self.graphics_viewer.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)\n\n\t\tself.m_originalX = 0.0\n\t\tself.m_originalY = 0.0\n\t\tself.m_moving = False\n\t\t# self.graphics_scene.graphics_view = self.graphics_viewer\n\n\t\t# self.setMinimumSize(self.scale_width, self.scale_height)\n\t\t# self.setMaximumSize(self.scale_width, self.scale_height)\n\t\tself.setFixedWidth(self.scale_width)\n\t\tself.setFixedHeight(self.scale_height)\n\n\t\t# self.grabKeyboard()\n\t\t# self.setMouseTracking(True)\n\t\t# self.installEventFilter(self)\n\t\tself.load_frame()\n\n\tdef load_layout(self):\n\t\tuic.loadUi(\"My_Labeling_GUI.ui\", self)  # Load the .ui file\n\t\tself.setGeometry(0, 0, self.scale_width, self.scale_height)\n\n\t\tself.main_window = self.findChild(QMainWindow, 'mainWindow')\n\t\tself.centralwidget = self.findChild(QWidget, 'centralwidget')\n\n\t\t# Find Menu-Bar Entries and set the corresponding methods: ---------------------------\n\t\tself.action_Load_Video = self.findChild(QAction, 'action_Load_Video')\n\t\tself.action_Set_Anno_Path = self.findChild(QAction, 'action_Set_Anno_Path')\n\t\tself.action_Set_Pred_Path = self.findChild(QAction, 'action_Set_Pred_Path')\n\t\tself.action_Load_Annotations = self.findChild(QAction, 'action_Load_Annotations')\n\t\tself.action_Load_Predictions = self.findChild(QAction, 'action_Load_Predictions')\n\t\tself.action_Add_new_Tag = self.findChild(QAction, 'action_Add_new_Tag')\n\t\tself.action_Change_Window_Size = self.findChild(QAction, 'action_Change_Window_Size')\n\t\tself.action_Change_Margin_Size = self.findChild(QAction, 'action_Change_Margin_Size')\n\n\t\tself.action_Load_Video.setShortcut('Ctrl+L')\n\t\tself.action_Load_Video.triggered.connect(self.load_video)\n\n\n\t\tself.action_Set_Anno_Path.triggered.connect(self.set_anno_path)\n\t\tself.action_Set_Pred_Path.triggered.connect(self.set_pred_path)\n\n\t\tself.action_Load_Annotations.setShortcut('Ctrl+G')\n\t\tself.action_Load_Annotations.triggered.connect(self.load_anno)\n\n\t\tself.action_Load_Predictions.setShortcut('Ctrl+P')\n\t\tself.action_Load_Predictions.triggered.connect(self.load_pred)\n\n\n\t\tself.action_Add_new_Tag.setShortcut('Ctrl+T')\n\t\tself.action_Add_new_Tag.triggered.connect(self.add_new_tag)\n\n\t\tself.action_Change_Window_Size.setShortcut('Ctrl+S')\n\t\tself.action_Change_Window_Size.triggered.connect(self.change_window_size)\n\n\t\tself.action_Change_Margin_Size.setShortcut('Ctrl+M')\n\t\tself.action_Change_Margin_Size.triggered.connect(self.change_margin_size)\n\t\t# End of Menu-Bar definition: --------------------------------------------------------\n\n\n\t\t# Find all labels in the layout: -----------------------------------------------------\n\t\tlabel_width = 70\n\t\tlabel_height = 50\n\t\tlabel_x_pos = 20\n\t\tlabel_y_pos = self.scale_height - self.margin_bottom + 15\n\t\tself.label_1 = self.findChild(QLabel, 'label_1')\n\t\t# self.label_1.setGeometry(QRect(label_x_pos, label_y_pos, label_width, label_height))\n\t\tif not self.video_path == \"\":\n\t\t\tself.label_1.setText(\"Frame:\")\n\t\tself.label_1.setFixedWidth(label_width)\n\t\tself.label_1.setFixedHeight(label_height)\n\t\t# End of label definition ------------------------------------------------------------\n\n\t\t# Define LineEdit (Textline): --------------------------------------------------------\n\t\tedit_width = 100\n\t\tedit_height = 50\n\t\tedit_x_pos = 20\n\t\tedit_y_pos = self.scale_height - self.margin_bottom + 15\n\t\tself.text_edit = self.findChild(QLineEdit, 'lineEdit')\n\t\t# self.label_1.setGeometry(QRect(label_x_pos, label_y_pos, label_width, label_height))\n\t\tif not self.video_path == \"\":\n\t\t\tself.text_edit.setText(str(self.frame_counter))\n\t\tself.text_edit.setFixedWidth(edit_width)\n\t\tself.text_edit.setFixedHeight(edit_height)\n\t\t# self.text_edit.cursorPositionChanged.connect(self.text_edit_get_Focus)\n\t\tself.text_edit.returnPressed.connect(self.text_edit_enter)\n\t\t# self.text_edit.textChanged.connect(self.text_edit_textChanged)\n\t\t# End of LineEdit definition ---------------------------------------------------------\n\n\n\t\t# Find all sliders in the layout: ----------------------------------------------------\n\t\tslider_width = 300\n\t\tslider_height = 35\n\t\tslider_x_pos = label_x_pos + label_width + 10\n\t\tslider_y_pos = label_y_pos + slider_height/4# self.scale_height - self.margin_bottom + slider_height/2 + 5\n\t\tself.slider_frames = self.findChild(QSlider, 'frame_slider')\n\t\tif self.cur_video_path == \"\":\n\t\t\tself.slider_frames.setMaximum(0)\n\t\telse:\n\t\t\tself.slider_frames.setMaximum(self.total_num_frames - 1)\n\t\t# self.slider_frames.setGeometry(QRect(slider_x_pos, slider_y_pos, slider_width, slider_height))\n\t\tself.slider_frames.setFixedWidth(slider_width)\n\t\tself.slider_frames.setFixedHeight(slider_height)\n\t\t# End of sliders definition ----------------------------------------------------------\n\n\t\t# Find all buttons in the layout: ----------------------------------------------------\n\t\tsave_btn_width = self.scale_width - (self.scene_width + 30)  # 125\n\t\tsave_btn_height = 50\n\t\tsave_btn_x = self.scale_width - save_btn_width - 10\n\t\tsave_btn_y = label_y_pos\n\t\tself.btn_save_frame = self.findChild(QPushButton, 'pushButton')\n\t\t# self.btn_save_frame.setGeometry(QRect(save_btn_x, save_btn_y, save_btn_width, save_btn_height))\n\t\tself.btn_save_frame.setFixedWidth(save_btn_width)\n\t\tself.btn_save_frame.setFixedHeight(save_btn_height)\n\n\n\t\tforw_btn_width = 30\n\t\tforw_btn_height = save_btn_height\n\t\tforw_btn_x = slider_x_pos + slider_width + 10\n\t\tforw_btn_y = save_btn_y\n\t\tself.btn_frame_back = self.findChild(QPushButton, 'pushButton_2')\n\t\t# self.btn_frame_back.setGeometry(QRect(forw_btn_x, forw_btn_y, forw_btn_width, forw_btn_height))\n\t\tself.btn_frame_back.setFixedWidth(forw_btn_width)\n\t\tself.btn_frame_back.setFixedHeight(save_btn_height)\n\n\n\t\tself.btn_frame_forw = self.findChild(QPushButton, 'pushButton_3')\n\t\t# self.btn_frame_forw.setGeometry(QRect(forw_btn_x+forw_btn_width+5, forw_btn_y, forw_btn_width, forw_btn_height))\n\t\tself.btn_frame_forw.setFixedWidth(forw_btn_width)\n\t\tself.btn_frame_forw.setFixedHeight(save_btn_height)\n\t\t# End of button definition -----------------------------------------------------------\n\n\t\t# Define toggle-Button to activate tagging: ------------------------------------------\n\t\ttoggle_button_offset_width = 25\n\t\ttoggle_button_w = self.scale_width - self.scene_width - 40\n\t\ttoggle_button_h = 35\n\t\ttoggle_button_x = self.scene_width + toggle_button_offset_width  # checkbox_w/2\n\t\ttoggle_button_y = toggle_button_h\n\t\tself.toggle_button = QPushButton(\"Tagging off\", self)\n\t\t# self.toggle_button.setGeometry(toggle_button_x, toggle_button_y, toggle_button_w, toggle_button_h)\n\t\t# In the beginning there is no person, so we do not allow to activate the tagging mode.\n\t\tself.toggle_button.setCheckable(True)\n\n\t\tself.toggle_button.clicked.connect(self.toggle_button_method)\n\t\t# End of toggle-Button definition ----------------------------------------------------\n\n\n\t\t# Define all checkboxes through tag_list: --------------------------------------------\n\t\tself.chk_box_list = []\n\n\t\t# checkbox_size = (80, 20)\n\t\tcheckbox_w = 80\n\t\tcheckbox_h = 20\n\t\tcheckbox_offset_width = 25\n\t\tcheckbox_offset_height = 10\n\t\tlast_checkbox_coordinates = None\n\t\tfor i, elem in enumerate(self.tag_list):\n\t\t\tself.chk_box_list.append(QCheckBox(self.centralwidget))\n\t\t\tself.chk_box_list[i].setObjectName(u\"checkBox_\" + str((i+1)))\n\t\t\tcheckbox_x = self.scene_width + checkbox_offset_width # checkbox_w/2\n\t\t\tcheckbox_y = (i+1) * (checkbox_h + checkbox_offset_height) - checkbox_offset_height + toggle_button_y\n\t\t\t# self.chk_box_list[i].setGeometry(QRect(checkbox_x, checkbox_y, checkbox_w, checkbox_h))\n\t\t\tlast_checkbox_coordinates = (checkbox_x, checkbox_y, checkbox_w, checkbox_h)\n\t\t\tself.chk_box_list[i].setText(self.tag_list[i])\n\n\t\t\t# In the beginning there is no person, so we do not allow the tagging mode.\n\t\t\tself.chk_box_list[i].setChecked(False)\n\t\t\tself.chk_box_list[i].setCheckable(False)\n\t\t\tself.chk_box_list[i].setStyleSheet(\"color : rgb(150,150,150)\")\n\n\t\t\t# Set the function for all checkboxes.\n\t\t\tself.chk_box_list[i].stateChanged.connect(self.checkbox_method)\n\t\t# End of checkbox definition ---------------------------------------------------------\n\n\t\t# Define Combo Box for classes: ------------------------------------------------------\n\t\tself.combo_box = QComboBox(self.centralwidget)\n\t\tcombo_box_width_offset = 40\n\t\t# self.combo_box.setAlignment(Qt.AlignLeft)\n\t\tcombo_box_x = self.scene_width + combo_box_width_offset/2\n\t\tcombo_box_y = last_checkbox_coordinates[1] + checkbox_offset_height + checkbox_h\n\t\tcombo_box_w = self.scale_width - self.scene_width - combo_box_width_offset\n\t\tcombo_box_h = 25\n\t\tprint(\"combo_box_x, combo_box_y, combo_box_w, combo_box_h =\", combo_box_x, combo_box_y, combo_box_w, combo_box_h)\n\t\t# self.combo_box.setGeometry(QRect(combo_box_x, combo_box_y, combo_box_w, combo_box_h))\n\t\t# self.combo_box.setStyleSheet('selection-background-color: rgb(0,0,0,0)')\n\t\t# self.combo_box.setStyleSheet('selection-color: rgb(200,200,200,50)')\n\n\t\t# colors = [\"blue\", \"green\", \"orange\", \"red\"]\n\t\talpha = 128\n\t\tcolors = [QColor(0, 163, 232, alpha), QColor(0, 163, 0, alpha), QColor(232, 163, 0, alpha), QColor(255, 0, 0, alpha)]\n\n\t\tfor i, elem in enumerate(self.class_list):\n\t\t\t# print(\"self.class_list[i] =\", self.class_list[i])\n\t\t\t# self.combo_box.setItemText(i, self.class_list[i])\n\t\t\t# cur_color = QColor(colors[i])\n\t\t\tcur_color_QT = QColor(colors[i])\n\t\t\t# pixmap = QPixmap(100, 100)\n\t\t\t# pixmap.fill(cur_color)\n\n\t\t\t# self.combo_box.addItem(self.class_list[i])\n\t\t\tself.combo_box.addItem(self.class_list[i])\n\t\t\tself.combo_box.setItemData(i, cur_color_QT, Qt.BackgroundRole)\n\n\t\t\t# self.combo_box.setItemData(i, cur_color_QT, Qt.SelectionBackgroundRole)\n\t\t\t# self.combo_box.addItem(QIcon(pixmap), self.class_list[i])\n\n\t\t\t# pal = self.combo_box.palette()\n\t\t\t# pal.setColor(QPalette.Button, cur_color)\n\t\t\t# self.cb.setPalette(pal)\n\t\tself.combo_box.activated.connect(self.combo_box_method)\n\t\t# End of Combo Boc definition --------------------------------------------------------\n\n\n\t\t# Define toggle-Button for reclassification: -----------------------------------------\n\t\treset_button_offset_height = 35\n\t\treset_button_w = toggle_button_w\n\t\treset_button_h = toggle_button_h\n\t\treset_button_x = toggle_button_x\n\t\treset_button_y = combo_box_y + combo_box_h + reset_button_offset_height\n\t\tself.reset_button = QPushButton(\"Reset\", self)\n\t\t# self.reset_button.setGeometry(reset_button_x, reset_button_y, reset_button_w, reset_button_h)\n\t\t# In the beginning there is no person, so we do not allow to activate the tagging mode.\n\t\t# self.reset_button.setCheckable(False)\n\n\t\tself.reset_button.clicked.connect(self.reset_button_method)\n\t\t# End of toggle-Button definition (for reclassification) -----------------------------\n\n\t\t# Define a drag-vs-draw toggle-Button: -----------------------------------------------\n\t\tdrag_draw_button_offset_height = 35\n\t\tdrag_draw_button_w = reset_button_w\n\t\tdrag_draw_button_h = reset_button_h\n\t\tdrag_draw_button_x = reset_button_x\n\t\tdrag_draw_button_y = reset_button_y + reset_button_h + drag_draw_button_offset_height\n\t\tself.drag_draw_button = QPushButton(\"Draw Mode\", self)\n\t\t# self.drag_draw_button.setGeometry(drag_draw_button_x, drag_draw_button_y, drag_draw_button_w, drag_draw_button_h)\n\t\tself.drag_draw_button.setCheckable(True)\n\n\t\tself.drag_draw_button.clicked.connect(self.drag_draw_button_method)\n\t\t# End of drag-vs-draw toggle-Button definition (for reclassification) ----------------\n\n\n\t\t# Find the QGraphicsView in the layout and add underlying QGraphicsScene: ------------\n\t\t\"\"\"\n\t\tself.graphics_viewer = self.findChild(QGraphicsView, 'graphicsView')\n\t\tself.graphics_scene = GraphicsScene(self.scene_width, self.scene_height)\n\t\t# self.graphics_scene = GraphicsScene(self)\n\t\t\"\"\"\n\t\tself.graphics_scene = GraphicsScene(self.scene_width, self.scene_height)\n\t\t# self.graphics_viewer = self.findChild(QGraphicsView, 'graphicsView')\n\t\tself.graphics_viewer = GraphicsView(self.centralwidget)\n\t\t# self.graphics_viewer.setGeometry(QRect(9, 9, 961, 681))\n\t\tsizePolicy1 = QSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)\n\t\tsizePolicy1.setHorizontalStretch(1)\n\t\tsizePolicy1.setVerticalStretch(1)\n\t\tsizePolicy1.setHeightForWidth(self.graphics_viewer.sizePolicy().hasHeightForWidth())\n\t\tself.graphics_viewer.setSizePolicy(sizePolicy1)\n\t\tself.graphics_viewer.setSizePolicy(sizePolicy1)\n\t\tself.graphics_viewer.setMouseTracking(True)\n\t\tself.graphics_viewer.setTabletTracking(True)\n\t\tself.graphics_viewer.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n\t\tself.graphics_viewer.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n\t\tself.graphics_viewer.drag_draw_button = self.drag_draw_button\n\n\t\tself.graphics_viewer.setScene(self.graphics_scene)\n\t\tself.graphics_viewer.setFixedWidth(self.scene_width)\n\t\tself.graphics_viewer.setFixedHeight(self.scene_height)\n\n\t\tself.graphics_viewer.my_scene = self\n\t\tself.graphics_scene.main_window = self\n\t\tprint(\"self.graphics_viewer.size() =\", self.graphics_viewer.size())\n\t\t# End of the QGraphicsView and QGraphicsScene definition -----------------------------\n\n\n\t\t# Define Layouts ---------------------------------------------------------------------\n\t\tself.outher_vertical_layout = QVBoxLayout()\n\n\n\t\tself.horizontal_layout = QHBoxLayout()\n\t\t# self.horizontal_layout.addWidget(self.graphics_scene)\n\t\tself.horizontal_layout.addWidget(self.graphics_viewer)\n\t\t# self.horizontal_layout.addStretch(1)\n\n\t\tself.inner_vertical_layout = QVBoxLayout()\n\t\t# self.vertical_layout.setGeometry(QRect(self.scene_width, 0, self.scale_width, self.scene_height))\n\t\tself.inner_vertical_layout.addWidget(self.toggle_button)\n\n\t\tfor chk_box in self.chk_box_list:\n\t\t\tself.inner_vertical_layout.addWidget(chk_box)\n\n\t\tself.inner_vertical_layout.addWidget(self.combo_box)\n\t\tself.inner_vertical_layout.addWidget(self.reset_button)\n\t\tself.inner_vertical_layout.addWidget(self.drag_draw_button)\n\t\tself.inner_vertical_layout.addStretch(1)\n\n\t\t# self.horizontal_layout.setGeometry(QRect(0, 0, self.scale_width, self.scene_height))\n\t\t# vertical_layout = QHBoxLayout()\n\t\t# self.grid_layout = self.findChild(QGridLayout, 'gridLayout')\n\t\t# self.gridLayoutWidget.setGeometry(QRect(0, 0, self.scale_width, self.scale_height))\n\n\t\tself.inner_horizontal_layout = QHBoxLayout()\n\t\tself.inner_horizontal_layout.addWidget(self.label_1)\n\t\tself.inner_horizontal_layout.addWidget(self.text_edit)\n\t\tself.inner_horizontal_layout.addWidget(self.slider_frames)\n\t\tself.inner_horizontal_layout.addWidget(self.btn_frame_back)\n\t\tself.inner_horizontal_layout.addWidget(self.btn_frame_forw)\n\t\tself.inner_horizontal_layout.addStretch(1)\n\t\tself.inner_horizontal_layout.addWidget(self.btn_save_frame)\n\n\t\tself.horizontal_layout.addLayout(self.inner_vertical_layout)\n\t\tself.outher_vertical_layout.addLayout(self.horizontal_layout)\n\t\tself.outher_vertical_layout.addLayout(self.inner_horizontal_layout)\n\t\t# self.outher_vertical_layout.addStretch(1)\n\n\n\n\t\tself.centralwidget.setLayout(self.outher_vertical_layout)\n\n\t\t# End of Layout definition -----------------------------------------------------------\n\n\n\n\t\t# Bind the event handler on the buttons, sliders, checkboxes etc.\n\t\tself.btn_save_frame.clicked.connect(self.btn_save_frame_method)\n\t\tself.btn_frame_forw.clicked.connect(self.btn_forw_frame_method)\n\t\tself.btn_frame_back.clicked.connect(self.btn_back_frame_method)\n\t\tself.slider_frames.valueChanged.connect(self.slider_frames_method)\n\n\t\tself.update()\n\t\tself.show()\n\n\tdef keyPressEvent(self, event):\n\t\tif not event.isAutoRepeat():\n\t\t\tif event.key() == Qt.Key_W:\n\t\t\t\tself.graphics_scene.w_key_is_pressed = True\n\t\t\telif event.key() == Qt.Key_H:\n\t\t\t\tself.graphics_scene.h_key_is_pressed = True\n\t\t\telif event.key() == Qt.Key_Z:\n\t\t\t\tself.graphics_scene.strg_key_is_pressed = True\n\t\t\telif event.key() == Qt.Key_M:\n\t\t\t\tself.graphics_scene.m_key_is_pressed = True\n\n\n\t\tprint(\"keyPressEvent (0) -> self.main_window.text_edit.hasFocus() =\", event.key())\n\t\tprint(\"keyPressEvent (01) -> self.main_window.text_edit.hasFocus() =\", event.modifiers() == Qt.CTRL)\n\t\tprint(\"keyPressEvent (1) -> self.main_window.text_edit.hasFocus() =\", self.text_edit.hasFocus())\n\n\t\tif self.text_edit.hasFocus():\n\t\t\tcursor_pos = self.text_edit.cursorPosition()\n\t\t\tprint(\"cursor_pos =\", cursor_pos)\n\t\t\told_text = self.text_edit.text()\n\t\t\tprint(\"old_text =\", old_text)\n\t\t\tif Qt.Key_0 <= event.key() <= Qt.Key_9:\n\t\t\t\tprint(\"keyPressEvent (2) -> self.main_window.text_edit.hasFocus() =\", self.text_edit.hasFocus())\n\t\t\t\tnew_text = old_text[:cursor_pos] + chr(event.key()) + old_text[cursor_pos:]\n\t\t\t\tself.text_edit.setText(new_text)\n\t\t\t\tself.text_edit.setCursorPosition(cursor_pos+1)\n\t\t\t\tprint(\"new_text =\", new_text)\n\t\t\t\t# self.text_edit.setText(event.key().)\n\t\t\telif event.key() == 16777234:\n\t\t\t\tself.text_edit.setCursorPosition(cursor_pos-1)\n\t\t\telif event.key() == 16777236:\n\t\t\t\tself.text_edit.setCursorPosition(cursor_pos+1)\n\t\t\telif event.modifiers() == 16777249 and event.key() == Qt.Key_A:\n\t\t\t\tself.text_edit.setSelection(0,len(old_text))\n\n\n\t\t# print(\"self.m_key_is_pressed =\", self.m_key_is_pressed)\n\t\t# print(\"self.w_key_is_pressed =\", self.w_key_is_pressed)\n\t\t# print(\"self.h_key_is_pressed =\", self.h_key_is_pressed)\n\n\t\tsuper(Labeling_Tool_GUI, self).keyPressEvent(event)\n\n\n\tdef keyReleaseEvent(self, event):\n\t\tif not event.isAutoRepeat():\n\t\t\tif event.key() == Qt.Key_W:\n\t\t\t\tself.graphics_scene.w_key_is_pressed = False\n\t\t\telif event.key() == Qt.Key_H:\n\t\t\t\tself.graphics_scene.h_key_is_pressed = False\n\t\t\telif event.key() == Qt.Key_M:\n\t\t\t\tself.graphics_scene.m_key_is_pressed = False\n\t\t\t# print(\"self.m_key_is_pressed =\", self.m_key_is_pressed)\n\n\n\t\t# print(\"self.w_key_is_pressed =\", self.w_key_is_pressed)\n\t\t# print(\"self.h_key_is_pressed =\", self.h_key_is_pressed)\n\t\tsuper(Labeling_Tool_GUI, self).keyReleaseEvent(event)\n\n\n\tdef text_edit_enter(self):\n\t\tprint(\"text_edit_method -> self.text_edit.getText() =\", self.text_edit.text())\n\t\ttry:\n\t\t\tself.frame_counter = int(self.text_edit.text())\n\t\t\tself.load_frame()\n\t\t\tself.slider_frames.setValue(self.frame_counter)\n\t\texcept:\n\t\t\tself.text_edit.setText(str(self.frame_counter))\n\n\n\n\n\n\t\t# self.frame_counter =\n\n\t\"\"\"\n\tdef text_edit_get_Focus(self):\n\t\tprint(\"text_edit_get_Focus -Y self.text_edit.hasFocus() =\", self.text_edit.hasFocus())\n\t\tif self.text_edit.hasFocus():\n\t\t\tself.text_edit.grabKeyboard()\n\t\telse:\n\t\t\tself.graphics_viewer.grabKeyboard()\n\t\t\n\tdef text_edit_textChanged(self):\n\t\tprint(\"text_edit_textChanged -> self.text_edit.hasFocus() =\", self.text_edit.hasFocus())\n\t\"\"\"\n\n\tdef checkbox_method(self):\n\t\tif self.toggle_button.isChecked() and not self.graphics_scene.highlighted_person_id_in_coord_list is None:\n\t\t\ts = set()\n\t\t\tfor elem in self.chk_box_list:\n\t\t\t\tif elem.isChecked():\n\t\t\t\t\ts.add(elem.text())\n\t\t\tcur_coord = self.graphics_scene.coord_list[self.graphics_scene.highlighted_person_id_in_coord_list]\n\t\t\tprint(\"checkbox_method -> cur_coord = \", self.graphics_scene.coord_list[self.graphics_scene.highlighted_person_id_in_coord_list])\n\t\t\tif len(cur_coord) == 2:\n\t\t\t\tself.graphics_scene.coord_list[self.graphics_scene.highlighted_person_id_in_coord_list].append(list(s))\n\t\t\telse:\n\t\t\t\tself.graphics_scene.coord_list[self.graphics_scene.highlighted_person_id_in_coord_list][-1] = list(s)\n\t\t\tprint(\"self.graphics_scene.coord_list[self.graphics_scene.highlighted_person_id_in_coord_list] =\", self.graphics_scene.coord_list[self.graphics_scene.highlighted_person_id_in_coord_list])\n\n\tdef untoggle_tagging_button(self):\n\n\n\t\tself.graphics_scene.is_classifing = True\n\t\tself.graphics_scene.highlighted_person_id_in_coord_list = None\n\t\tself.graphics_scene.repaint()\n\n\t\t# set background color back to light-grey\n\t\tself.toggle_button.setStyleSheet(\"background-color : lightgrey\")\n\t\tself.toggle_button.setText(\"Tagging off\")\n\t\tself.toggle_button.setChecked(False)\n\n\t\tfor chk_box in self.chk_box_list:\n\t\t\tchk_box.setChecked(False)\n\t\t\tchk_box.setCheckable(False)\n\t\t\tchk_box.setStyleSheet(\"color : rgb(150,150,150)\")\n\n\tdef toggle_button_method(self):\n\t\t\"\"\"\n\t\tIdea how to tag persons:\n\t\t\tFirst, enable the tagging mode\n\t\t\t\t=> all checkboxes get unchecked\n\n\t\t\tSecond, click on a person.\n\t\t\t\t=> This person gets highlighted by a thicker bounding box.\n\t\t\t\t   If this person was already tagged, those tags should be loaded\n\n\t\t\tThird, choose some tags.\n\t\t\t\t=> The tags which are chosen, correspond to the currently highlighted person\n\n\t\t\tFourth, either choose a new person or disable the tagging mode.\n\t\t\t\t=> In both cases the last highlighted person get the previously chosen tags.\n\t\t:return:\n\t\t\"\"\"\n\n\n\t\tif len(self.graphics_scene.coord_list) > 0:\n\t\t\t# self.toggle_button.setChecked(True)\n\t\t\tself.toggle_button.setCheckable(True)\n\t\telse:\n\t\t\t# self.toggle_button.setChecked(False)\n\t\t\tself.toggle_button.setCheckable(False)\n\n\t\tif len(self.graphics_scene.coord_list) > 0:\n\t\t\t# if button is checked\n\t\t\tif self.toggle_button.isChecked():\n\t\t\t\tself.graphics_scene.is_classifing = False\n\n\t\t\t\t# setting background color to light-green\n\t\t\t\tself.toggle_button.setStyleSheet(\"background-color : lightgreen\")\n\t\t\t\tself.toggle_button.setText(\"Tagging on\")\n\n\t\t\t\t# If Tagging Mode is on, then uncheck all pervious checkboxes:\n\t\t\t\tfor chk_box in self.chk_box_list:\n\t\t\t\t\tchk_box.setChecked(False)\n\t\t\t\t\tchk_box.setCheckable(True)\n\t\t\t\t\tif darkdetect.isLight() is None or darkdetect.isLight():\n\t\t\t\t\t\tchk_box.setStyleSheet(\"color : rgb(50,50,50)\")\n\t\t\t\t\telse:\n\t\t\t\t\t\tchk_box.setStyleSheet(\"color : rgb(255,255,200)\")\n\n\t\t\telse:\n\t\t\t\tself.untoggle_tagging_button()\n\t\telse:\n\t\t\tself.untoggle_tagging_button()\n\n\n\tdef reset_button_method(self):\n\n\t\t\"\"\"\n\t\tDelete all bounding boxes and reset all button states (e.g. since not bounding box, therefore tagging\n\t\ttoggle-button cannot be activated)\n\t\t\"\"\"\n\t\tprint(\"You called the toggle_button_recls_method() method.\")\n\n\t\t# self.toggle_button.setCheckable(True)\n\n\t\tself.graphics_scene.is_classifing = True\n\t\tself.graphics_scene.temp_coord = []\n\t\tself.graphics_scene.coord_list = []\n\t\tself.graphics_scene.highlighted_person_id_in_coord_list = None\n\t\t# self.graphics_scene.cur_class = 0\n\n\t\tself.graphics_scene.chk_box_list = self.chk_box_list\n\t\tself.graphics_scene.tag_list = self.tag_list\n\t\tself.graphics_scene.combo_box = self.combo_box\n\n\t\t# self.toggle_button.setChecked(False)\n\t\tself.toggle_button_method()\n\n\t\tself.graphics_scene.repaint()\n\n\tdef drag_draw_button_method(self):\n\t\tif self.drag_draw_button.isChecked():\n\t\t\tself.graphics_scene.drag_on = True\n\n\t\t\t# setting background color to light-green\n\t\t\tself.drag_draw_button.setStyleSheet(\"background-color : lightgreen\")\n\t\t\tself.drag_draw_button.setText(\"Drag Mode\")\n\n\t\t\tself.drag_draw_button.setChecked(True)\n\n\t\t\tself.graphics_viewer.setDragMode(QGraphicsView.ScrollHandDrag)\n\t\telse:\n\t\t\tself.graphics_scene.drag_on = False\n\n\t\t\tself.drag_draw_button.setStyleSheet(\"background-color : lightgrey\")\n\t\t\tself.drag_draw_button.setText(\"Draw Mode\")\n\t\t\tself.drag_draw_button.setChecked(False)\n\n\t\t\tself.graphics_viewer.setDragMode(QGraphicsView.NoDrag)\n\n\tdef load_video(self):\n\t\t\"\"\"\n\t\tToDo: Use a QFileDialog to choose a path\n\t\t:return:\n\t\t\"\"\"\n\t\toptions = QFileDialog.Options()\n\t\tprint(type(options))\n\t\t# .setGeometry(QRect(500, 500, 400, 200))\n\t\t# options |= QFileDialog.setGeometry(QRect(500, 500, 400, 200))\n\t\t# options |= QFileDialog.DontUseNativeDialog\n\t\tfileName, _ = QFileDialog.getOpenFileName(self, caption=\"Choose a mp4 Video\",\n\t\t\t\t\t\t\t\t\t\t\t\t  directory=self.parrent_path,\n\t\t\t\t\t\t\t\t\t\t\t\t  filter=\"Video Files (*.mp4)\",\n\t\t\t\t\t\t\t\t\t\t\t\t  options=options)\n\n\t\tif fileName:\n\t\t\tfileName = fileName.replace('/', os.sep)\n\t\t\tprint(\"fileName =\", fileName)\n\t\t\tself.cur_video_path = fileName\n\t\t\tself.video_path = (os.sep).join(fileName.split(os.sep)[:-1]) + os.sep\n\t\t\ttemp_vidcap = cv2.VideoCapture(self.cur_video_path)\n\t\t\tprint(\"self.cur_video_path =\", self.cur_video_path)\n\t\t\tsuccess, image = temp_vidcap.read()\n\t\t\tprint(\"self.total_num_frames (old) =\", self.total_num_frames)\n\t\t\tself.total_num_frames = int(temp_vidcap.get(cv2.CAP_PROP_FRAME_COUNT))\n\t\t\tprint(\"self.total_num_frames (new) =\", self.total_num_frames)\n\t\t\ttemp_vidcap.release()\n\n\t\t\tself.slider_frames.setMaximum(self.total_num_frames - 1)\n\t\t\tself.text_edit.setText(str(self.frame_counter))\n\n\t\t\t# self.load_layout()\n\n\t\t\t# self.setFixedWidth(self.scale_width)\n\t\t\t# self.setFixedHeight(self.scale_height)\n\n\t\t\t# self.setMouseTracking(True)\n\n\t\t\t# self.frame_counter = 0\n\n\t\t\tself.load_frame()\n\n\n\n\tdef set_anno_path(self):\n\t\t\"\"\"\n\t\tToDo: Use a QFileDialog to choose a path\n\t\t:return:\n\t\t\"\"\"\n\t\tprint(\"You called the set_anno_path() method.\")\n\n\tdef set_pred_path(self):\n\t\t\"\"\"\n\t\tToDo: Use a QFileDialog to choose a path\n\t\t:return:\n\t\t\"\"\"\n\t\tprint(\"You called the set_pred_path() method.\")\n\n\n\tdef centered_and_rel_to_xyxy(self, coord):\n\t\tx_center_abs = float(coord[1]) * float(self.scene_width)\n\t\ty_center_abs = float(coord[2]) * float(self.scene_height)\n\t\twidth_abs = float(coord[3]) * float(self.scene_width)\n\t\theight_abs = float(coord[4]) * float(self.scene_height)\n\n\t\tx_left = x_center_abs - width_abs/2.0\n\t\ty_top = y_center_abs - height_abs/2.0\n\t\tx_right = x_center_abs + width_abs/2.0\n\t\ty_bottom = y_center_abs + height_abs/2.0\n\t\treturn x_left, y_top, x_right, y_bottom\n\n\n\n\tdef load_anno_or_preds(self, load_mode=0):\n\t\t\"\"\"\n\n\t\t:param load_mode: There are three load_modes 0,1 or 2.\n\t\t\t\t\t\t  0 -> load predictions\n\t\t\t\t\t\t  1 -> load annotations\n\t\t\t\t\t\t  2 -> load annotations if available otherwise try to load predictions (if available)\n\t\t:return:\n\t\t\"\"\"\n\t\t# pred_filename = self.pred_path + self.video_path.split(os.sep)[-2] + os.sep + self.video_path.split(os.sep)[-2] + \"_\" + str(self.frame_counter) + \".txt\"\n\t\t# anno_filename = self.anno_path + self.video_path.split(os.sep)[-2] + os.sep + self.video_path.split(os.sep)[-2] + \"_\" + str(self.frame_counter) + \".txt\"\n\n\t\tprint(\"self.video_path =\", self.video_path)\n\t\tprint(\"self.cur_video_path =\", self.cur_video_path)\n\t\tvideo_name = self.cur_video_path.split(os.sep)[-1].split('.')[0]\n\t\tpred_filename = self.pred_path + video_name + os.sep + video_name + \"_\" + str(self.frame_counter) + \".txt\"\n\t\tanno_filename = self.anno_path + video_name + os.sep + video_name\\\n\t\t\t\t\t\t+ \"_\" + str(self.frame_counter) + \".txt\"\n\n\t\tif load_mode == 0:\n\t\t\tused_filename = pred_filename\n\t\t\tprint(\"pred_filename =\", used_filename)\n\t\telif load_mode == 1:\n\t\t\tused_filename = anno_filename\n\t\t\tprint(\"anno_filename =\", used_filename)\n\t\telse:\n\t\t\tif os.path.isfile(anno_filename):\n\t\t\t\tused_filename = anno_filename\n\t\t\telif os.path.isfile(pred_filename):\n\t\t\t\tused_filename = pred_filename\n\t\t\telse:\n\t\t\t\t# There are no ground truth data and no predictions for the current frame\n\t\t\t\treturn None\n\n\t\tif os.path.isfile(used_filename):\n\t\t\tself.graphics_scene.reset_values()\n\n\t\t\t# ToDo: Load Annotations\n\t\t\tfile = open(used_filename, 'r')\n\t\t\tdata_str = list(csv.reader(file, delimiter=' '))\n\t\t\tfile.close()\n\n\t\t\tfor elem in data_str:\n\t\t\t\tx_left, y_top, x_right, y_bottom = self.centered_and_rel_to_xyxy(elem)\n\t\t\t\tif len(elem) == 5:\n\t\t\t\t\tself.graphics_scene.coord_list.append([int(elem[0]), [(float(x_left), float(y_top)), (float(x_right), float(y_bottom))]])\n\t\t\t\telif len(elem) > 5:\n\t\t\t\t\tprint(\"load Annotation elem[5:] =\", elem[5])\n\t\t\t\t\tprint(\"elem[5:].split(',') =\", elem[5].split(','))\n\t\t\t\t\tsaved_tag_ids = [saved_tag_str for saved_tag_str in elem[5].split(',') if saved_tag_str in self.tag_list]\n\t\t\t\t\t# refPt.append([int(elem[0]), [(float(elem[1]), float(elem[2])), (float(elem[3]), float(elem[4]))], elem[5].split(',')])\n\t\t\t\t\tself.graphics_scene.coord_list.append([int(elem[0]), [(float(x_left), float(y_top)), (float(x_right), float(y_bottom))], saved_tag_ids])\n\t\t\tself.graphics_scene.repaint()\n\t\t\tprint(\"self.graphics_scene.coord_list =\", self.graphics_scene.coord_list)\n\t\telse:\n\t\t\t# ToDo: Open a new small window with the message, that there are no annotations for this frame\n\t\t\tprint(\"\\n\\n\\n\\t----------------------------------------\")\n\t\t\tprint(\"\\tThere are no annotations for this frame.\")\n\t\t\tprint(\"\\t----------------------------------------\\n\\n\\n\")\n\n\n\tdef load_anno(self):\n\t\t\"\"\"\n\t\tToDo: Load the annotations from the annotation path\n\t\t:return:\n\t\t\"\"\"\n\t\tprint(\"You called the set_anno_path() method.\")\n\t\tself.load_anno_or_preds(load_mode=1)\n\n\n\n\n\tdef load_pred(self):\n\t\t\"\"\"\n\t\tToDo: Load the predictions from the prediction path\n\t\t:return:\n\t\t\"\"\"\n\t\tself.load_anno_or_preds(load_mode=0)\n\n\tdef add_new_tag(self):\n\t\t\"\"\"\n\t\tToDo: Open a new small window with a QEditLine in it, where a new Tag can be added.\n\t\t:return:\n\t\t\"\"\"\n\t\tprint(\"You called the add_new_tag() method.\")\n\n\t\t# self.tag_list\n\t\tself.secondary_window = Secondary_Window(main_labeling_tool=self, mode=\"add_new_tag\")\n\n\tdef change_window_size(self):\n\t\t\"\"\"\n\t\tToDo: Open a new small window with a QEditLine in it, where a number (between 0.6 and 1) can be written.\n\t\t\t  This number corresponds to scale_factor.\n\t\t:return:\n\t\t\"\"\"\n\t\tself.secondary_window = Secondary_Window(main_labeling_tool=self, mode=\"change_window_size\")\n\t\tprint(\"You called the change_window_size() method.\")\n\n\tdef change_margin_size(self):\n\t\tself.secondary_window = Secondary_Window(main_labeling_tool=self, mode=\"change_margin_size\")\n\t\tprint(\"You called the change_margin_size() method.\")\n\n\tdef load_frame(self):\n\t\tif not self.cur_video_path == \"\":\n\t\t\tprint(\"load_frame self.cur_video_path =\", self.cur_video_path)\n\t\t\tvidcap = cv2.VideoCapture(self.cur_video_path)\n\t\t\tprint(\"self.filename =\", self.cur_video_path)\n\t\t\tif self.total_num_frames == -1:\n\t\t\t\tself.total_num_frames = int(vidcap.get(cv2.CAP_PROP_FRAME_COUNT))\n\t\t\tvidcap.set(1, self.frame_counter)  # The first argument (1) corresponds to cv2.CV_CAP_PROP_POS_FRAMES\n\t\t\tsuccess, image = vidcap.read()\n\t\t\timage = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\t\t\timage = cv2.resize(image, (int(self.graphics_scene.width()+1), int(self.graphics_scene.height()+2)), interpolation=cv2.INTER_AREA)  # _LINEAR fastest\n\t\t\tvidcap.release()\n\n\t\t\t# self.graphics_scene.clear()\n\t\t\th, w, c = image.shape\n\t\t\tprint(\"w, h, c =\", w, h, c)\n\n\t\t\tbytesPerLine = c * w\n\t\t\tconvertToQtFormat = QImage(image.data, w, h, bytesPerLine, QImage.Format_RGB888)\n\n\t\t\t# p = convertToQtFormat.scaled(self.scene_width+5, self.scene_height+5)\n\t\t\t# p = convertToQtFormat.scaled(self.graphics_scene.scene_width, self.graphics_scene.scene_height)\n\t\t\tprint(\"self.scene_width, self.scene_height =\", self.scene_width, self.scene_height)\n\n\t\t\t# pixMap = QPixmap.fromImage(p)\n\t\t\tpixMap = QPixmap.fromImage(convertToQtFormat)\n\t\t\tself.graphics_scene.addPixmap(pixMap)\n\t\t\tself.graphics_scene.reset_values()\n\t\t\tself.graphics_scene.repaint()\n\t\t\tself.graphics_scene.update()\n\n\n\tdef read_checkboxes(self):\n\t\tused_tags = []\n\t\tfor idx, checkbox in enumerate(self.chk_box_list):\n\t\t\tif checkbox.isChecked():\n\t\t\t\tused_tags.append(self.tag_list[idx])\n\t\treturn used_tags\n\n\n\tdef btn_save_frame_method(self):\n\t\t# This is executed when the button is pressed\n\t\tif not self.cur_video_path == \"\":\n\t\t\tsave_list = self.graphics_scene.coord_list.copy()\n\n\t\t\tcur_video_name = '.'.join(self.cur_video_path.split(os.sep)[-1].split('.')[:-1])\n\t\t\tcur_filename = self.anno_path + cur_video_name + os.sep + cur_video_name + \"_\" + str(self.frame_counter) + \".txt\"\n\t\t\tprint(\"cur_filename =\", cur_filename)\n\n\t\t\tif not os.path.isdir(self.anno_path + cur_video_name):\n\t\t\t\tos.makedirs(self.anno_path + cur_video_name)\n\n\t\t\tif os.path.isfile(cur_filename):\n\t\t\t\tos.remove(cur_filename)\n\n\t\t\tfile = open(cur_filename, 'a+')\n\n\t\t\tfor elem in save_list:\n\t\t\t\tif len(elem) == 2:\n\t\t\t\t\tcls, coord = elem\n\t\t\t\telse:\n\t\t\t\t\tcls, coord, tags = elem\n\n\t\t\t\tprint(\"self.scene_width =\", self.scene_width)\n\t\t\t\tprint(\"self.scene_height =\", self.scene_height)\n\t\t\t\t# Compute some helper values\n\t\t\t\tx_left = float(min(coord[0][0], coord[1][0]))\n\t\t\t\tx_right = float(max(coord[0][0], coord[1][0]))\n\t\t\t\ty_top = float(min(coord[0][1], coord[1][1]))\n\t\t\t\ty_bottom = float(max(coord[0][1], coord[1][1]))\n\n\t\t\t\t# Compute the absolute values of x,y,w and h\n\t\t\t\tx_center_abs = (x_left + (x_right - x_left)/2.0)\n\t\t\t\ty_center_abs = (y_top + (y_bottom - y_top)/2.0)\n\t\t\t\twidth_abs = x_right - x_left\n\t\t\t\theight_abs = y_bottom - y_top\n\n\t\t\t\tx_center_rel = x_center_abs/float(self.graphics_scene.width())\n\t\t\t\ty_center_rel = y_center_abs/float(self.graphics_scene.height())\n\t\t\t\twidth_rel = width_abs/float(self.graphics_scene.width())\n\t\t\t\theight_rel = height_abs/float(self.graphics_scene.height())\n\n\t\t\t\tif len(elem) == 2:\n\t\t\t\t\tsave_str = str(cls) + \" \" + str(x_center_rel) + \" \" + str(y_center_rel) + \" \" + str(width_rel) + \" \" + str(height_rel) + \"\\n\"\n\t\t\t\telse:\n\t\t\t\t\tsave_str = str(cls) + \" \" + str(x_center_rel) + \" \" + str(y_center_rel) + \" \" + str(width_rel) + \" \" + str(height_rel) + \" \" + ','.join(tags) +  \"\\n\"\n\n\t\t\t\tprint(\"save_str =\", save_str)\n\t\t\t\tfile.write(save_str)\n\t\t\tprint(\"save_list =\", save_list)\n\t\t\tfile.close()\n\t\t\tself.used_tags = []\n\t\t\tself.toggle_button.setChecked(False)\n\t\t\tself.toggle_button_method()\n\n\t\t\tself.graphics_scene.reset_values()\n\n\t\t\t# self.graphics_scene.coord_list = []\n\t\t\t# self.graphics_scene.highlighted_person_id_in_coord_list = None\n\n\t\t\tself.frame_counter += 1\n\t\t\tself.text_edit.setText(str(self.frame_counter))\n\t\t\tself.slider_frames.setValue(self.frame_counter)\n\t\t\tself.load_frame()\n\n\n\tdef btn_forw_frame_method(self):\n\t\tif not self.cur_video_path == \"\":\n\t\t\tsave_list = self.graphics_scene.coord_list.copy()\n\n\t\t\t# self.graphics_scene.coord_list = []\n\t\t\tself.graphics_scene.reset_values()\n\n\t\t\tprint(\"save_list =\", save_list)\n\t\t\tself.frame_counter += 1\n\t\t\tself.text_edit.setText(str(self.frame_counter))\n\t\t\tself.slider_frames.setValue(self.frame_counter)\n\t\t\tself.untoggle_tagging_button()\n\t\t\tself.load_frame()\n\n\tdef btn_back_frame_method(self):\n\t\tif not self.cur_video_path == \"\":\n\t\t\tsave_list = self.graphics_scene.coord_list.copy()\n\n\t\t\t# self.graphics_scene.coord_list = []\n\t\t\tself.graphics_scene.reset_values()\n\n\t\t\tprint(\"save_list =\", save_list)\n\t\t\tself.frame_counter -= 1\n\t\t\tself.text_edit.setText(str(self.frame_counter))\n\t\t\tself.slider_frames.setValue(self.frame_counter)\n\t\t\tself.untoggle_tagging_button()\n\t\t\tself.load_frame()\n\n\tdef slider_frames_method(self):\n\t\t# This is executed when the button is pressed\n\t\tif not self.cur_video_path == \"\":\n\t\t\tself.frame_counter = self.slider_frames.value()\n\t\t\tself.text_edit.setText(str(self.frame_counter))\n\t\t\tself.load_frame()\n\n\tdef combo_box_method(self, idx):\n\t\tprint(\"You changed the class to index \", idx, \"\\t\\tThis cooresponds to the class name \", self.class_list[idx])\n\t\tself.cur_class = idx\n\n\t\t# self.graphics_scene.cur_class_GS = self.cur_class\n\t\t# self.graphics_scene.class_list_GS = self.class_list\n\t\t# self.graphics_scene.class_colors_GS = self.class_colors\n\t\t# self.graphics_scene.cur_class_color = self.class_colors[self.cur_class]\n\t\tself.graphics_scene.cur_class = self.cur_class\n\n\t\tif not self.graphics_scene.highlighted_person_id_in_coord_list is None:\n\t\t\tprint(\"combo --- 0\")\n\t\t\tself.graphics_scene.coord_list[self.graphics_scene.highlighted_person_id_in_coord_list][0] = idx\n\t\t\tprint(\"combo --- 1\")\n\t\t\tself.graphics_scene.repaint()\n\t\"\"\"\n\tdef fitInView(self, scale=True):\n\t\tunity = self.graphics_viewer.transform().mapRect(QtCore.QRectF(0, 0, 1, 1))\n\t\tself.graphics_viewer.scale(1 / unity.width(), 1 / unity.height())\n\t\tviewrect = self.graphics_viewer.viewport().rect()\n\t\tscenerect = self.graphics_viewer.transform().mapRect(self.graphics_viewer.rect())\n\t\tfactor = min(viewrect.width() / scenerect.width(),\n\t\t\t\t\t viewrect.height() / scenerect.height())\n\t\tself.graphics_viewer.scale(factor, factor)\n\n\n\t\n\tdef wheelEvent(self, event):\n\t\tif self.graphics_scene.w_key_is_pressed or self.graphics_scene.h_key_is_pressed:\n\t\t\tpass\n\t\telse:\n\t\t\t# self.graphics_viewer.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)\n\t\t\t# self.graphics_viewer.setResizeAnchor(QGraphicsView.AnchorUnderMouse)\n\t\t\tprint(\"event.angleDelta().y() =\", event.angleDelta().y())\n\t\t\tif event.angleDelta().y() > 0:\n\t\t\t\tfactor = 1.1\n\t\t\t\tself._zoom += 0.1\n\t\t\telse:\n\t\t\t\tfactor = 0.9\n\t\t\t\tself._zoom -= 0.1\n\t\t\tself._zoom = round(self._zoom, 1)\n\t\t\tprint(\"self._zoom =\", self._zoom)\n\t\t\tif self._zoom > 0:\n\t\t\t\tprint(\"self._zoom > 0 -> True\")\n\t\t\t\tprint(\"factor =\", factor)\n\t\t\t\tself.graphics_viewer.scale(factor, factor)\n\t\t\t\t# self.graphics_viewer.translate(0, -event.angleDelta().y() / 120.0)\n\t\t\t\tself.graphics_viewer.viewport()\n\t\t\telse:\n\t\t\t\tself.fitInView()\n\t\t\t\tself._zoom = 0.0\n\t\t\t\tself.graphics_scene.repaint()\n\n\t\t\tif self.drag_draw_button.isChecked():\n\t\t\t\tself.graphics_viewer.setDragMode(QGraphicsView.ScrollHandDrag)\n\t\t\telse:\n\t\t\t\tself.graphics_viewer.setDragMode(QGraphicsView.NoDrag)\n\t\n\n\tdef keyPressEvent(self, event):\n\t\tif event.key() == Qt.Key_W:\n\t\t\tself.graphics_scene.w_key_is_pressed = True\n\t\telif event.key() == Qt.Key_H:\n\t\t\tself.graphics_scene.h_key_is_pressed = True\n\t\telif event.key() == Qt.Key_M:\n\t\t\tself.graphics_scene.m_key_is_pressed = True\n\t\t# if event.modifiers() == Qt.ALT:\n\t\telif event.key() == Qt.Key_Z:\n\t\t\tself.graphics_scene.strg_key_is_pressed = True\n\n\tdef keyReleaseEvent(self, event):\n\t\tif event.key() == Qt.Key_W:\n\t\t\tself.graphics_scene.w_key_is_pressed = False\n\t\telif event.key() == Qt.Key_H:\n\t\t\tself.graphics_scene.h_key_is_pressed = False\n\t\telif event.key() == Qt.Key_M:\n\t\t\tself.graphics_scene.m_key_is_pressed = False\n\t\t# if event.modifiers() == Qt.ALT:\n\t\telif event.key() == Qt.Key_Z:\n\t\t\tself.graphics_scene.strg_key_is_pressed = False\n\n\t\t# print(\"self.w_key_is_pressed =\", self.w_key_is_pressed)\n\t\t# print(\"self.h_key_is_pressed =\", self.graphics_scene.h_key_is_pressed)\n\t\t# super(GraphicsScene, self).keyReleaseEvent(event)\n\t\"\"\"\n", "description": "\n\t\tself.tag_list = sorted([\"blurry\",\n\t\t\t\t\t\t\t   \"covered\",\n\t\t\t\t\t\t\t   \"noisy\",\n\t\t\t\t\t\t\t   \"size-L\",\n\t\t\t\t\t\t\t   \"size-M\",\n\t\t\t\t\t\t\t   \"size-S\"\n\t\t\t\t\t\t\t   ])\n\t\t", "category": "graphics", "imports": ["import sys", "import os", "import glob", "import csv", "import numpy as np", "import cv2", "import darkdetect", "from PyQt5.QtWidgets import *", "from PyQt5 import uic, QtCore", "from PyQt5.QtGui import *", "from PyQt5.QtCore import *"]}, {"term": "class", "name": "GraphicsView", "data": "class GraphicsView(QGraphicsView):\n\tdef __init__(self, parent=None):\n\t\tsuper(GraphicsView, self).__init__(QGraphicsScene(), parent)\n\t\tself.drag_draw_button = None\n\t\tself.main_window = None\n\t\tself._zoom = 0\n\n\n\t\tself.m_originalX = 0\n\t\tself.m_originalY = 0\n\t\tself.m_moving = False\n\n\t\t# self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)\n\t\t# self.setResizeAnchor(QGraphicsView.AnchorUnderMouse)\n\n\n\tdef mousePressEvent(self, event):\n\t\tprint(event)\n\t\tif event.button() == QtCore.Qt.MidButton:\n\t\t\tself.m_originalX = event.x()\n\t\t\tself.m_originalY = event.y()\n\t\t\tself.m_moving = True\n\t\t\tprint(\"self.m_originalX, self.m_originalX, self.m_moving =\", self.scene().m_originalX, self.scene().m_originalY, self.scene().m_moving)\n\t\tsuper(GraphicsView, self).mousePressEvent(event)\n\n\tdef mouseReleaseEvent(self, event):\n\t\tif event.button() == QtCore.Qt.MidButton:\n\t\t\tself.m_moving = False\n\t\tsuper(GraphicsView, self).mouseReleaseEvent(event)\n\n\tdef mouseMoveEvent(self, event):\n\t\t# print(\"mouseMoveEvent [GraphicsView] -> \", event.x(), event.y())\n\t\tif self.m_moving:\n\t\t\tprint(\"here------------------\")\n\t\t\tprint(\"self.m_originalX, self.m_originalY =\", self.m_originalX, self.m_originalY)\n\t\t\ttry:\n\t\t\t\toldp = self.mapToScene(self.m_originalX, self.m_originalY)\n\t\t\t\tnewp = self.mapToScene(event.x(), event.y())\n\t\t\t\ttranslation = (newp - oldp)\n\t\t\t\tprint(\"translation.x(), translation.y() =\", translation.x(), translation.y())\n\t\t\t\t# print(\"len(self.views()) =\", len(self.views()))\n\t\t\t\t# print(\"self.views()[0] =\", self.views()[0])\n\t\t\t\t# temp_view = QGraphicsView(self.views()[0])\n\n\t\t\t\t# print(self.views()[0]._zoom)\n\n\t\t\t\tself.translate(translation.x(), translation.y())\n\n\t\t\t\t# self.views()[0] = temp_view\n\t\t\t\tprint(\"hallo\")\n\n\t\t\t\tself.m_originalX = event.x()\n\t\t\t\tself.m_originalY = event.y()\n\t\t\texcept Exception as err:\n\t\t\t\tprint(\"Error:\", err)\n\t\tsuper(GraphicsView, self).mouseMoveEvent(event)\n\t\"\"\"\n\n\tdef mousePressEvent(self, event):\n\t\tif event.button() == Qt.MidButton:\n\t\t\tself.viewport().setCursor(Qt.ClosedHandCursor)\n\t\t\tself.original_event = event\n\t\t\thandmade_event = QMouseEvent(QEvent.MouseButtonPress, QPointF(event.pos()), Qt.LeftButton, event.buttons(), Qt.KeyboardModifiers())\n\t\t\tself.mousePressEvent(handmade_event)\n\t\tsuper(GraphicsView, self).mousePressEvent(event)\n\n\tdef mouseReleaseEvent(self, event):\n\t\tif event.button() == Qt.MidButton:\n\t\t\t# for changing back to Qt.OpenHandCursor\n\t\t\tself.viewport().setCursor(Qt.OpenHandCursor)\n\t\t\thandmade_event = QMouseEvent(QEvent.MouseButtonRelease, QPointF(event.pos()), Qt.LeftButton, event.buttons(), Qt.KeyboardModifiers())\n\t\t\tself.mouseReleaseEvent(handmade_event)\n\t\tsuper(GraphicsView, self).mouseReleaseEvent(event)\n\n\tdef hoverMoveEvent(self, event):\n\t\tpoint = event.pos().toPoint()\n\t\tprint(point)\n\t\tQGraphicsItem.hoverMoveEvent(self, event)\n\t\tsuper(GraphicsView, self).hoverMoveEvent(event)\n\t\"\"\"\n\n\n\tdef fitInView(self, scale=True):\n\t\tunity = self.transform().mapRect(QtCore.QRectF(0, 0, 1, 1))\n\t\tself.scale(1.0 / unity.width(), 1.0 / unity.height())\n\t\tviewrect = self.viewport().rect()\n\t\tscenerect = self.transform().mapRect(self.rect())\n\t\tfactor = min(viewrect.width() / scenerect.width(),\n\t\t\t\t\t viewrect.height() / scenerect.height())\n\t\tself.scale(factor, factor)\n\n\tdef wheelEvent(self, event):\n\t\tx = event.pos().x()\n\t\ty = event.pos().y()\n\t\t# point = QPoint(int(event.x()), int(event.y()))\n\t\tscene_coords = self.mapToScene(event.x(), event.y())\n\t\tx_scene, y_scene = scene_coords.x(), scene_coords.y()\n\t\tprint(\"x, y =\", x,y)\n\t\tprint(\"scene_coords =\", scene_coords)\n\t\tprint(\"x_scene, y_scene =\", x_scene, y_scene)\n\t\t# self.scene().pointPressed = (x,y)\n\t\t# self.scene().scene_width\n\t\t# print(\"a,b =\", a, b)\n\t\t# b = max(min(y, self.scene().scene_width), 0)\n\n\n\t\t# print(\"self.scene().self.pointPressed =\", self.pos().pointPressed)\n\t\tif self.scene().w_key_is_pressed or self.scene().h_key_is_pressed:\n\t\t\tself.scene().pointPressed = (x_scene, y_scene)\n\t\t\tincreasing = event.angleDelta().y() > 0\n\t\t\tself.scene().change_width_or_height(increasing)\n\t\telse:\n\t\t\t# self.graphics_viewer.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)\n\t\t\t# self.graphics_viewer.setResizeAnchor(QGraphicsView.AnchorUnderMouse)\n\t\t\tprint(\"event.angleDelta().y() =\", event.angleDelta().y())\n\t\t\tif event.angleDelta().y() > 0:\n\t\t\t\tfactor = 1.1\n\t\t\t\tself._zoom += 0.1\n\t\t\telse:\n\t\t\t\tfactor = 0.9\n\t\t\t\tself._zoom -= 0.1\n\t\t\tself._zoom = round(self._zoom, 1)\n\t\t\tprint(\"self._zoom =\", self._zoom)\n\t\t\tif self._zoom > 0:\n\t\t\t\tprint(\"self._zoom > 0 -> True\")\n\t\t\t\tprint(\"factor =\", factor)\n\t\t\t\tself.scale(factor, factor)\n\t\t\t\t# self.graphics_viewer.translate(0, -event.angleDelta().y() / 120.0)\n\t\t\t\t# self.viewport()\n\t\t\telse:\n\t\t\t\tself.fitInView()\n\t\t\t\tself._zoom = 0.0\n\t\t\t\tself.scene().repaint()\n\n\t\t\tif self.drag_draw_button.isChecked():\n\t\t\t\tself.setDragMode(QGraphicsView.ScrollHandDrag)\n\t\t\telse:\n\t\t\t\tself.setDragMode(QGraphicsView.NoDrag)\n\n", "description": "\n\n\tdef mousePressEvent(self, event):\n\t\tif event.button() == Qt.MidButton:\n\t\t\tself.viewport().setCursor(Qt.ClosedHandCursor)\n\t\t\tself.original_event = event\n\t\t\thandmade_event = QMouseEvent(QEvent.MouseButtonPress, QPointF(event.pos()), Qt.LeftButton, event.buttons(), Qt.KeyboardModifiers())\n\t\t\tself.mousePressEvent(handmade_event)\n\t\tsuper(GraphicsView, self).mousePressEvent(event)\n\n\tdef mouseReleaseEvent(self, event):\n\t\tif event.button() == Qt.MidButton:\n\t\t\t# for changing back to Qt.OpenHandCursor\n\t\t\tself.viewport().setCursor(Qt.OpenHandCursor)\n\t\t\thandmade_event = QMouseEvent(QEvent.MouseButtonRelease, QPointF(event.pos()), Qt.LeftButton, event.buttons(), Qt.KeyboardModifiers())\n\t\t\tself.mouseReleaseEvent(handmade_event)\n\t\tsuper(GraphicsView, self).mouseReleaseEvent(event)\n\n\tdef hoverMoveEvent(self, event):\n\t\tpoint = event.pos().toPoint()\n\t\tprint(point)\n\t\tQGraphicsItem.hoverMoveEvent(self, event)\n\t\tsuper(GraphicsView, self).hoverMoveEvent(event)\n\t", "category": "graphics", "imports": ["import sys", "import os", "import glob", "import csv", "import numpy as np", "import cv2", "import darkdetect", "from PyQt5.QtWidgets import *", "from PyQt5 import uic, QtCore", "from PyQt5.QtGui import *", "from PyQt5.QtCore import *"]}, {"term": "class", "name": "Secondary_Window", "data": "class Secondary_Window(QMainWindow):\n\n\tdef __init__(self, main_labeling_tool, mode):\n\t\tsuper(Secondary_Window, self).__init__()\n\t\tself.setWindowFlags(QtCore.Qt.Window | QtCore.Qt.CustomizeWindowHint | Qt.WindowStaysOnTopHint | QtCore.Qt.WindowCloseButtonHint | QtCore.Qt.WindowMinimizeButtonHint)\n\t\tself.labeling_tool = main_labeling_tool\n\t\tself.mode = mode\n\n\t\tprint(\"main_labeling_tool =\", main_labeling_tool.scale_factor)\n\t\twidth = 500\n\t\theight = 250\n\t\tself.setGeometry(200, 200, width, height)\n\t\tself.setFixedWidth(width)\n\t\tself.setFixedHeight(height)\n\n\t\tself.setWindowTitle(\"Change Window Size\")\n\t\t# self.show()\n\t\tprint(\"0\")\n\t\tself.centralwidget = QWidget(self)\n\n\t\t# self.horizontal_Layout = QHBoxLayout()\n\t\t# self.vertical_Layout = QVBoxLayout()\n\n\n\t\tfont1 = QFont()\n\t\tfont1.setPointSize(10)\n\n\t\tself.label_titel = QLabel(self.centralwidget)\n\t\tself.label_titel.setFont(font1)\n\t\tif mode == \"change_window_size\":\n\t\t\tself.label_titel.setText(\"Set a new scaling value: \\nRecommanded values are between 0.4 and 1.\")\n\n\n\t\tself.label_titel.setAlignment(QtCore.Qt.AlignCenter)\n\t\tlabel_width = int(width / 3)\n\t\tlabel_height = 50\n\t\t# self.label_titel.setFixedWidth(width)\n\t\t# self.label_titel.setFixedHeight(label_height)\n\t\t# self.label_titel.setGeometry(width/2, height/3, label_width, label_height)\n\n\t\tself.text_line = QLineEdit(self.centralwidget)\n\n\t\ttext_line_width = int(width/3)\n\t\ttext_line_height = 40\n\t\tself.text_line.setFont(font1)\n\t\tself.text_line.setFixedWidth(text_line_width)\n\t\tself.text_line.setFixedHeight(text_line_height)\n\t\t# self.text_line.setGeometry(int(width/2 - text_line_width/2), int(height/2 - text_line_height/2), text_line_width, text_line_height)\n\t\tif mode == \"change_window_size\":\n\t\t\tself.text_line.setText(str(self.labeling_tool.scale_factor))\n\t\tself.text_line.returnPressed.connect(self.text_line_enter)\n\n\t\tbutton_width = int(width/4)\n\t\tbutton_height = 40\n\t\tself.ok_button = QPushButton(\"Ok\", self.centralwidget)\n\t\tself.ok_button.setFixedWidth(button_width)\n\t\tself.ok_button.setFixedHeight(button_height)\n\t\t# self.ok_button.setGeometry(width-button_width, height-button_height, button_width, button_height)\n\t\tself.ok_button.clicked.connect(self.ok_clicked)\n\n\t\tself.setCentralWidget(self.centralwidget)\n\t\tself.grid_layout = QGridLayout()\n\n\n\t\tfor col in range(3):\n\t\t\tfor row in range(3):\n\t\t\t\tself.grid_layout.setColumnMinimumWidth(col, int(width/3.0))\n\t\t\t\tself.grid_layout.setRowMinimumHeight(row, int(height/3.0))\n\t\t\t\tself.grid_layout.setColumnStretch(col, 10)\n\t\t\t\tself.grid_layout.setRowStretch(row, 10)\n\n\n\n\t\t# self.grid_layout.setColumnMinimumWidth(1, int(width / 3.0))\n\t\t# self.grid_layout.setRowMinimumHeight(2, int(height / 3.0))\n\n\t\tself.grid_layout.addWidget(self.label_titel, 0, 0, 1, 3, QtCore.Qt.AlignCenter)\n\t\tself.grid_layout.addWidget(self.text_line, 1, 1, alignment=QtCore.Qt.AlignCenter)\n\t\tself.grid_layout.addWidget(self.ok_button, 2, 2, alignment=QtCore.Qt.AlignRight)\n\t\tself.centralwidget.setLayout(self.grid_layout)\n\n\t\tself.label_titel.move(0, -150)\n\t\t# self.label_titel.setGeometry(int(self.label_titel.width()/2), int(height/3), label_width, label_height)\n\t\t# self.vertical_Layout.addStretch(1)\n\t\t# self.vertical_Layout.addWidget(self.ok_button)\n\n\n\n\t\t# self.horizontal_Layout.addStretch(1)\n\t\t# self.horizontal_Layout.addWidget(self.text_line)\n\t\t# self.horizontal_Layout.addLayout(self.vertical_Layout)\n\n\t\t# self.centralwidget.setLayout(self.horizontal_Layout)\n\n\n\t\tself.show()\n\n\n\tdef check_new_size(self):\n\t\tglobal my_gui\n\t\ttry:\n\t\t\ttemp_factor = float(self.text_line.text())\n\t\t\tself.labeling_tool.close()\n\t\t\tmy_gui = Labeling_Tool_GUI(temp_factor)\n\t\t\tself.close()\n\t\texcept:\n\t\t\tself.text_line.setText(str(self.labeling_tool.scale_factor))\n\n\tdef change_margin(self):\n\t\tglobal my_gui\n\t\ttry:\n\t\t\tmarging_factor = float(self.text_line.text())\n\t\t\tself.labeling_tool.close()\n\t\t\tscale_factor = self.labeling_tool.scale_factor\n\t\t\tmy_gui = Labeling_Tool_GUI(scale_factor, marging_factor)\n\t\t\tself.close()\n\t\texcept:\n\t\t\tself.text_line.setText(str(self.labeling_tool.scale_factor))\n\n\tdef add_tag(self):\n\t\tglobal my_gui\n\t\tnew_tag = self.text_line.text()\n\t\tprint(\"new_tag =\", new_tag)\n\t\tconfig_file = open(self.labeling_tool.config_path, 'r', encoding=\"utf-8\")\n\t\tprint(\"111\")\n\t\told_config_file_content = [row for row in config_file.read().splitlines() if not row.split(',')[0] == \"tags\"]\n\t\tconfig_file.close()\n\t\tprint(\"111\")\n\t\tprint(old_config_file_content)\n\n\t\tprint(\"1\")\n\t\tos.remove(self.labeling_tool.config_path)\n\t\tprint(\"2\")\n\t\tconfig_file = open(self.labeling_tool.config_path, 'a+', encoding=\"utf-8\")\n\t\tprint(\"3\")\n\t\tself.labeling_tool.tag_list.append(new_tag)\n\n\t\tnew_tag_list = self.labeling_tool.tag_list.copy()\n\n\n\t\tconfig_file.write(\"tags,\" + ','.join(new_tag_list))\n\t\tfor row in old_config_file_content:\n\t\t\tconfig_file.write(row)\n\t\tconfig_file.close()\n\n\n\t\tself.labeling_tool.close()\n\t\tscale_factor = self.labeling_tool.scale_factor\n\t\tmy_gui = Labeling_Tool_GUI(scale_factor)\n\t\tself.close()\n\n\n\n\tdef text_line_enter(self):\n\t\tglobal my_gui\n\t\t# search for: self.tag_list = sorted([\"blurry\",\"covered\",\"noisy\"])\n\t\tif self.mode == \"change_window_size\":\n\t\t\tself.check_new_size()\n\t\telif self.mode == \"change_margin_sizem\":\n\t\t\tself.change_margin()\n\t\telif self.mode == \"add_new_tag\":\n\t\t\t# filepath = os.getcwd() + os.sep + os.path.basename(__file__)\n\t\t\tself.add_tag()\n\t\t\t\"\"\"\n\t\t\tconfig_file = open(self.config_path, 'r', encoding=\"utf-8\")\n\t\t\tconfig_file = open(filepath, 'r').read().splitlines()\n\n\t\t\tcurrent_tags = self.labeling_tool.tag_list\n\t\t\tprint(\"current_tags\", current_tags)\n\t\t\tprint(\"type(this_file)\", type(this_file))\n\t\t\tprint(\"this_file[:10]\", this_file[:10])\n\t\t\t\"\"\"\n\tdef ok_clicked(self):\n\t\tglobal my_gui\n\t\tif self.mode == \"change_window_size\":\n\t\t\tself.check_new_size()\n\t\telif self.mode == \"change_margin_size\":\n\t\t\tself.change_margin()\n\t\telif self.mode == \"add_new_tag\":\n\t\t\tpass\n\n\n", "description": "\n\t\t\tconfig_file = open(self.config_path, 'r', encoding=\"utf-8\")\n\t\t\tconfig_file = open(filepath, 'r').read().splitlines()\n\n\t\t\tcurrent_tags = self.labeling_tool.tag_list\n\t\t\tprint(\"current_tags\", current_tags)\n\t\t\tprint(\"type(this_file)\", type(this_file))\n\t\t\tprint(\"this_file[:10]\", this_file[:10])\n\t\t\t", "category": "graphics", "imports": ["import sys", "import os", "import glob", "import csv", "import numpy as np", "import cv2", "import darkdetect", "from PyQt5.QtWidgets import *", "from PyQt5 import uic, QtCore", "from PyQt5.QtGui import *", "from PyQt5.QtCore import *"]}, {"term": "class", "name": "GraphicsScene", "data": "class GraphicsScene(QGraphicsScene):\n\tdef __init__(self, scene_width, scene_height):\n\t\tsuper(GraphicsScene, self).__init__()\n\n\t\tself.main_window = None\n\t\tself.scene_width, self.scene_height = scene_width, scene_height\n\t\t# self.cur_class_color = (0, 163, 232)\n\t\tself.cur_class = 0\n\t\t\"\"\"\n\t\tself.class_colors = {(0, 163, 232):0,\n\t\t\t\t\t\t\t (0, 200, 0):1,\n\t\t\t\t\t\t\t (232, 163, 0):2,\n\t\t\t\t\t\t\t (200, 0, 0):3\n\t\t\t\t\t\t\t }\n\t\t\"\"\"\n\t\tself.class_colors = [(0, 163, 232),\n\t\t\t\t\t\t\t (0, 200, 0),\n\t\t\t\t\t\t\t (232, 163, 0),\n\t\t\t\t\t\t\t (200, 0, 0)\n\t\t\t\t\t\t\t ]\n\n\t\t# These values will be pointers to values in the GUI. So, there should be no two different tag-lists\n\t\tself.chk_box_list = None\n\t\tself.tag_list = None\n\t\tself.combo_box = None\n\n\t\t# These values will change during the normal usage, but should be reset if we save all the labels.\n\t\tself.is_classifing = True  # True => Classification Mode; False => Tagging Mode\n\t\tself.temp_coord = []\n\t\tself.coord_list = []\n\t\tself.highlighted_person_id_in_coord_list = None\n\t\tself.w_key_is_pressed = False\n\t\tself.h_key_is_pressed = False\n\t\tself.m_key_is_pressed = False\n\t\tself.drag_on = False\n\n\t\tself.circle_radius = 4.0\n\t\tself.pen_width = 2.0\n\t\tself.pen_width_highlighting = 4\n\t\tself.pointPressed = QPointF()\n\t\tself.pointReleased = QPointF()\n\n\t\t# how much should the width and height increase or decrease if we change the width of height with mouse wheel\n\t\tself.step_width = 1.0\n\n\t\tself.m_originalX = 0\n\t\tself.m_originalY = 0\n\t\tself.m_moving = False\n\n\t\tself.start_x = 0\n\t\tself.start_y = 0\n\t\tself.end_x = scene_width\n\t\tself.end_y = scene_height\n\t\tself.setSceneRect(self.start_x, self.start_y, self.end_x, self.end_y)\n\t\t\"\"\"\n\t\tpixmap = QPixmap(100, 100)\n\t\tpixmap.fill(QtCore.Qt.red)\n\n\t\tself.pixmap_item = self.addPixmap(pixmap)\n\t\t\n\t\t# random position\n\t\t# self.pixmap_item.setPos(*random.sample(range(-100, 100), 2))\n\t\t\"\"\"\n\n\n\n\n\n\tdef reset_values(self):\n\t\tself.is_classifing = True  # True => Classification Mode; False => Tagging Mode\n\t\tself.temp_coord = []\n\t\tself.coord_list = []\n\t\tself.highlighted_person_id_in_coord_list = None\n\t\tself.w_key_is_pressed = False\n\t\tself.h_key_is_pressed = False\n\t\tself.m_key_is_pressed = False\n\t\tself.strg_key_is_pressed = False\n\n\t\tself.pointPressed = QPointF()\n\t\tself.pointReleased = QPointF()\n\n\t\tself.setSceneRect(self.start_x, self.start_y, self.end_x, self.end_y)\n\n\t\tself.update()\n\n\n\n\tdef set_checkboxes(self, marked_person_id):\n\t\tused_tags = []\n\t\tfor idx, elem in enumerate(self.coord_list):\n\t\t\tif idx == marked_person_id:\n\t\t\t\tif len(elem) == 2:\n\t\t\t\t\t# Uncheck all checkboxes\n\t\t\t\t\tfor chk_box in self.chk_box_list:\n\t\t\t\t\t\tchk_box.setChecked(False)\n\t\t\t\telse:\n\t\t\t\t\tcls, coord, tags = elem\n\t\t\t\t\tfor chk_box in self.chk_box_list:\n\t\t\t\t\t\tif chk_box.text() in tags:\n\t\t\t\t\t\t\tchk_box.setChecked(True)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tchk_box.setChecked(False)\n\n\n\n\t\treturn used_tags\n\n\tdef combo_box_method(self):\n\t\t\"\"\"\n\t\tIf we select a bounding box, then this method changes the current chosen person class\n\t\tin the combo_box to the class of the selected person. So, with this method the user\n\t\tget the class-information of the current selected person.\n\n\t\t:return:\n\t\t\"\"\"\n\t\tif not self.highlighted_person_id_in_coord_list is None:\n\t\t\tperson_data = self.coord_list[self.highlighted_person_id_in_coord_list]\n\t\t\tprint(\"person_data =\", person_data)\n\t\t\tself.combo_box.setCurrentIndex(person_data[0])\n\n\n\tdef repaint(self):\n\n\t\tfor elem in self.items():\n\t\t\tif isinstance(elem, QGraphicsRectItem) or isinstance(elem, QGraphicsEllipseItem):\n\t\t\t\tself.removeItem(elem)\n\n\t\tfor idx, elem in enumerate(self.coord_list):\n\t\t\tif len(elem) == 2:\n\t\t\t\tcls, coord = elem\n\t\t\telse:\n\t\t\t\tcls, coord, tags = elem\n\n\t\t\tstart_x = coord[0][0]\n\t\t\tstart_y = coord[0][1]\n\t\t\twidth = coord[1][0] - start_x\n\t\t\theight = coord[1][1] - start_y\n\t\t\tself.cur_class = cls\n\t\t\tif idx == self.highlighted_person_id_in_coord_list:\n\t\t\t\tself.addEllipse(round(start_x - (self.circle_radius / 2.0),0), round(start_y - (self.circle_radius / 2.0),0), self.circle_radius, self.circle_radius, self.get_pen(is_highlighted=True))\n\t\t\t\tself.addEllipse(round(start_x+width - (self.circle_radius / 2.0),0), round(start_y+height - (self.circle_radius / 2.0),0), self.circle_radius, self.circle_radius, self.get_pen(is_highlighted=True))\n\t\t\t\tself.addRect(start_x, start_y, width, height, self.get_pen(is_highlighted=True))\n\t\t\telse:\n\t\t\t\tself.addEllipse(round(start_x - (self.circle_radius / 2.0),0), round(start_y - (self.circle_radius / 2.0),0), self.circle_radius, self.circle_radius, self.get_pen(is_highlighted=False))\n\t\t\t\tself.addEllipse(round(start_x+width - (self.circle_radius / 2.0),0), round(start_y+height - (self.circle_radius / 2.0),0), self.circle_radius, self.circle_radius, self.get_pen(is_highlighted=False))\n\t\t\t\tself.addRect(start_x, start_y, width, height, self.get_pen(is_highlighted=False))\n\n\n\n\tdef get_pen(self, is_highlighted=False):\n\t\tc1, c2, c3 = self.class_colors[self.cur_class][0], self.class_colors[self.cur_class][1], self.class_colors[self.cur_class][2]\n\n\t\tif is_highlighted:\n\t\t\treturn QPen(QColor(c1, c2, c3), self.pen_width_highlighting)\n\t\telse:\n\t\t\treturn QPen(QColor(c1, c2, c3), self.pen_width)\n\n\tdef get_nearest_Box(self):\n\t\tx_mouse,y_mouse = self.pointPressed\n\n\t\tmin_dist = 10 ** 100\n\t\tmin_coordinates = None\n\t\tmin_elem_QT_item = None\n\n\t\tfor idx, elem in enumerate(self.items()):\n\t\t\tif isinstance(elem, QGraphicsRectItem):\n\t\t\t\tprint(\"get_nearest_Box -> elem ->\", elem)\n\t\t\t\t\"\"\"\n\t\t\t\tx_box is the x-coordinate of the rectangle's left edge\n\t\t\t\t\t-> see: https://doc.qt.io/qt-5/qrectf.html#x\n\t\t\t\ty_box is the y-coordinate of the rectangle's top edge\n\t\t\t\t\t-> see: https://doc.qt.io/qt-5/qrectf.html#y\n\t\t\t\t\"\"\"\n\t\t\t\tx_box, y_box, w_box, h_box = elem.rect().x(), elem.rect().y(), elem.rect().width(), elem.rect().height()\n\t\t\t\tprint(\"x_box, y_box, w_box, h_box =\", x_box, y_box, w_box, h_box)\n\t\t\t\tx_center = int(x_box + (w_box / 2.0))\n\t\t\t\ty_center = int(y_box + (h_box / 2.0))\n\t\t\t\tcur_dist = np.sqrt((x_center - x_mouse) ** 2 + (y_center - y_mouse) ** 2)\n\t\t\t\tif cur_dist < min_dist:\n\t\t\t\t\tmin_dist = cur_dist\n\t\t\t\t\tmin_elem_QT_item = elem\n\t\t\t\t\tmin_coordinates = (x_box, y_box, x_box+w_box, y_box+h_box)\n\t\t\t\t\t# min_idx = idx\n\n\n\t\tprint(\"get_nearest_Box -> min_dist ->\", min_dist)\n\t\tprint(\"get_nearest_Box -> min_coordinates (before) ->\", min_coordinates)\n\t\tmin_coordinates_copy = [round(coord,0) for coord in min_coordinates]\n\t\tcircle_elements = []\n\t\tprint(\"get_nearest_Box -> min_coordinates_copy (before, after) ->\", min_coordinates_copy)\n\t\tfor idx, elem in enumerate(self.items()):\n\t\t\tif isinstance(elem, QGraphicsEllipseItem):\n\t\t\t\t# print(\"elem.ellipse() =\", elem.rect())\n\t\t\t\tx_circ, y_circ = elem.rect().x(), elem.rect().y()\n\t\t\t\t# print(\"elem.ellipse() -> x_circ, y_circ =\", x_circ, y_circ)\n\t\t\t\tprint(\"elem.ellipse() -> x_circ+self.circle_radius/2.0 =\", x_circ+self.circle_radius/2.0)\n\t\t\t\tprint(\"elem.ellipse() -> y_circ+self.circle_radius/2.0 =\", y_circ+self.circle_radius/2.0)\n\t\t\t\tif round(min_coordinates[0],0) == round(x_circ+(self.circle_radius/2.0),0) and round(min_coordinates[1],0) == round(y_circ+(self.circle_radius/2.0),0):\n\t\t\t\t\tmin_coordinates = (-1, -1, min_coordinates[2], min_coordinates[3])\n\t\t\t\t\tcircle_elements.append(elem)\n\t\t\t\tif round(min_coordinates[2],0) == round(x_circ+(self.circle_radius/2.0),0) and round(min_coordinates[3],0) == round(y_circ+(self.circle_radius/2.0),0):\n\t\t\t\t\tmin_coordinates = (min_coordinates[0], min_coordinates[1], -1, -1)\n\t\t\t\t\tcircle_elements.append(elem)\n\t\tprint(\"get_nearest_Box -> min_coordinates (after) ->\", min_coordinates)\n\n\t\tidx_min_elem_coord_list = None\n\t\tmin_coordinates = min_coordinates_copy\n\t\tif not min_elem_QT_item is None:\n\t\t\tfor idx, elem in enumerate(self.coord_list):\n\t\t\t\tprint(\"elem[1] =\", elem[1])\n\t\t\t\telem = [(round(coord[0],0), round(coord[1],0)) for coord in elem[1]]\n\t\t\t\tprint(\"get_nearest_Box -> elem =?= min_coordinates ->\", elem, min_coordinates)\n\t\t\t\tif int(elem[0][0]) == int(min_coordinates[0]) and int(elem[0][1]) == int(min_coordinates[1]) and int(elem[1][0]) == int(min_coordinates[2]) and int(elem[1][1]) == int(min_coordinates[3]):\n\t\t\t\t\tidx_min_elem_coord_list = idx\n\t\t\t\t\tbreak\n\n\t\treturn min_elem_QT_item, idx_min_elem_coord_list, circle_elements\n\n\tdef delete_nearest_Box(self):\n\t\tprint(\"self.coord_list [before]=\", self.coord_list)\n\t\tprint(\"self.pointPressed =\", self.pointPressed)\n\t\tmin_elem_QT_item, idx_min_elem_coord_list, circle_elements = self.get_nearest_Box()\n\t\tprint(\"self.coord_list =\", self.coord_list)\n\t\tprint(\"min_elem_QT_item, idx_min_elem_coord_list, circle_elements =\", min_elem_QT_item, idx_min_elem_coord_list, circle_elements)\n\t\tprint(\"circle_elements =\", circle_elements)\n\t\tif not min_elem_QT_item is None:\n\t\t\tself.removeItem(min_elem_QT_item)\n\t\t\tif circle_elements[0] is None:\n\t\t\t\tprint(\"circle_elements[0] is None:\")\n\t\t\telse:\n\t\t\t\tprint(\"len(self.items()) [before]\", len(self.items()))\n\t\t\t\tself.removeItem(circle_elements[0])\n\t\t\t\tprint(\"len(self.items()) [after]\", len(self.items()))\n\t\t\tif circle_elements[1] is None:\n\t\t\t\tprint(\"circle_elements[0] is None:\")\n\t\t\telse:\n\t\t\t\tprint(\"len(self.items()) [before]\", len(self.items()))\n\t\t\t\tself.removeItem(circle_elements[1])\n\t\t\t\tprint(\"len(self.items()) [after]\", len(self.items()))\n\t\t\tdel self.coord_list[idx_min_elem_coord_list]\n\n\t\tprint(\"self.coord_list [after]=\", self.coord_list)\n\n\n\n\n\tdef reorder_circles(self):\n\t\t\"\"\"\n\t\tThe idea of this function is, that the user has four possibilities to draw a box\n\t\t\t* top-left - bottom-right\n\t\t\t* bottom-right - top-left\n\t\t\t* top-right - bottom-left\n\t\t\t* bottom-left - top-right\n\t\tSo, self.temp_coord would not be consistent. To be consistent we reorder the self.temp_coord\n\t\tas top-left - bottom-right. We also delete the circles and draw them in the new order.\n\t\t:return:\n\t\t\"\"\"\n\t\told_temp_coord = self.temp_coord.copy()\n\t\tprint(\"old_temp_coord =\", old_temp_coord)\n\t\t# Make sure, that the coordinates in self.temp_coord are ordered top-left and bottom-right\n\t\tx_left = round(min(self.temp_coord[0][0], self.temp_coord[1][0]),0)\n\t\ty_top = round(min(self.temp_coord[0][1], self.temp_coord[1][1]),0)\n\t\tx_right = round(max(self.temp_coord[0][0], self.temp_coord[1][0]),0)\n\t\ty_bottom = round(max(self.temp_coord[0][1], self.temp_coord[1][1]),0)\n\t\tself.temp_coord = [(x_left, y_top),(x_right,y_bottom)]\n\n\t\t# Delete the circles\n\t\tfor elem in self.items():\n\t\t\tif isinstance(elem, QGraphicsEllipseItem):\n\t\t\t\tx_circ, y_circ = elem.rect().x(), elem.rect().y()\n\t\t\t\tif old_temp_coord[0][0] == round(x_circ + self.circle_radius / 2.0, 0) and old_temp_coord[0][1] == round(y_circ + self.circle_radius / 2.0, 0):\n\t\t\t\t\told_temp_coord = [(-1, -1), (old_temp_coord[1][0], old_temp_coord[1][1])]\n\t\t\t\t\tself.removeItem(elem)\n\t\t\t\tif old_temp_coord[1][0] == round(x_circ + self.circle_radius / 2.0, 0) and old_temp_coord[1][1] == round(y_circ + self.circle_radius / 2.0, 0):\n\t\t\t\t\told_temp_coord = [(old_temp_coord[0][0], old_temp_coord[0][1]), (-1, -1)]\n\t\t\t\t\tself.removeItem(elem)\n\t\tprint(\"self.temp_coord =\", self.temp_coord)\n\t\t# Draw the Circles in the new order\n\t\tpen = self.get_pen()\n\t\tself.addEllipse(round(x_left - self.circle_radius / 2.0, 0), round(y_top - self.circle_radius / 2.0, 0), self.circle_radius, self.circle_radius, pen)\n\t\tself.addEllipse(round(x_right - self.circle_radius / 2.0, 0), round(y_bottom - self.circle_radius / 2.0, 0), self.circle_radius, self.circle_radius, pen)\n\n\tdef mousePressEvent(self, event):\n\t\tif event.buttons() == QtCore.Qt.LeftButton and self.is_classifing and not self.drag_on:  # left button pressed\n\t\t\tprint(\"type(event) =\", type(event))\n\t\t\t# self.pointPressed = (event.scenePos().x(), event.scenePos().y())\n\t\t\tself.pointPressed = (max(min(event.scenePos().x(), self.scene_width),0), max(min(event.scenePos().y(), self.scene_height),0))\n\t\t\tself.temp_coord.append(self.pointPressed)\n\t\t\tpen = self.get_pen()\n\t\t\t# brush = QBrush(QColor(self.class_colors_GS[self.cur_class_GS]))\n\n\n\t\t\t# TODO: Draw a circle for the current point\n\t\t\t# ellipse = self.addellipse(10, 10, 200, 200)\n\t\t\tx = float(self.pointPressed[0])\n\t\t\ty = float(self.pointPressed[1])\n\n\t\t\tself.addEllipse(round(x-(self.circle_radius/2.0),0), round(y-(self.circle_radius/2.0),0), self.circle_radius, self.circle_radius, pen)\n\n\t\t\tprint(\"self.temp_coord =\", self.temp_coord)\n\t\t\tprint(\"self.coord_list =\", self.coord_list)\n\t\t\tif len(self.temp_coord) == 2:\n\t\t\t\t# First, delete the circles which correspond to this box and draw two new circles top-left and bottom-right\n\t\t\t\tself.reorder_circles()\n\n\t\t\t\t# TODO: Draw Bounding Box\n\t\t\t\tstart_x = round(float(min(self.temp_coord[0][0], self.temp_coord[1][0])),0)\n\t\t\t\tstart_y = round(float(min(self.temp_coord[0][1], self.temp_coord[1][1])),0)\n\t\t\t\twidth = round(float(max(self.temp_coord[0][0], self.temp_coord[1][0]) - min(self.temp_coord[0][0], self.temp_coord[1][0])),0)\n\t\t\t\theight = round(float(max(self.temp_coord[0][1], self.temp_coord[1][1]) - min(self.temp_coord[0][1], self.temp_coord[1][1])),0)\n\t\t\t\tprint(\"start_x, start_y, width, height =\", start_x, start_y, width, height)\n\t\t\t\t# self.addRect(self.temp_coord[0][0], self.temp_coord[0][1], width, height, pen, brush)\n\t\t\t\t# path = QPainterPath()\n\t\t\t\t# path.addRect(start_x, start_y, width, height)\n\t\t\t\t# self.addPath(path, pen)\n\t\t\t\tself.addRect(start_x, start_y, width, height, pen)\n\n\t\t\t\t# self.addRect(self.temp_coord[0][0], self.temp_coord[0][1], width, height, pen, brush)\n\t\t\t\tprint(\"self.temp_coord (before) =\", self.temp_coord)\n\t\t\t\tself.temp_coord = [(round(coord[0],0), round(coord[1],0)) for coord in self.temp_coord]\n\t\t\t\tprint(\"self.temp_coord (after) =\", self.temp_coord)\n\t\t\t\tself.coord_list.append([self.cur_class, self.temp_coord])\n\t\t\t\tself.temp_coord = []\n\t\telif event.buttons () == QtCore.Qt.RightButton and self.is_classifing: # right click\n\t\t\tprint(\"Right click\")\n\t\t\tself.pointPressed = (event.scenePos().x(), event.scenePos().y())\n\t\t\tself.delete_nearest_Box()\n\t\t\tself.repaint()\n\t\telif event.buttons() == QtCore.Qt.LeftButton and not self.is_classifing:  # left button pressed\n\t\t\t# ToDo: Find the nearest Person and highlight this person by increasing the box-thickness\n\t\t\tself.pointPressed = (event.scenePos().x(), event.scenePos().y())\n\t\t\tprint(\"len(self.items()) =\", len(self.items()))\n\t\t\tmin_elem_QT_item, idx_min_elem_coord_list, circle_elements = self.get_nearest_Box()\n\t\t\tself.highlighted_person_id_in_coord_list = idx_min_elem_coord_list\n\t\t\tprint(\"len(self.items()) =\", len(self.items()))\n\n\t\t\tself.set_checkboxes(idx_min_elem_coord_list)\n\t\t\tself.combo_box_method()\n\n\t\t\t# cls, coord = self.coord_list[idx_min_elem_coord_list]\n\t\t\t# self.cur_class = cls\n\n\t\t\tself.repaint()\n\n\n\n\t\t\t\"\"\"\n\t\t\tfor elem in self.items():\n\t\t\t\tif isinstance(elem, QRect):\n\t\t\t\t\telem.setPen(self.get_pen(is_highlighted=False))\n\t\t\t\"\"\"\n\n\t\t\t\"\"\"\n\t\t\tif self.last_marked_elem_QT is None:\n\t\t\t\tmin_elem_QT_item.setPen(self.get_pen(is_highlighted=True))\n\t\t\t\t# self.removeItem(min_elem_QT_item)\n\t\t\t\t# print(\"min_elem_QT_item =\", type(min_elem_QT_item))\n\t\t\t\t# print(\"min_elem_QT_item =\", min_elem_QT_item.rect())\n\t\t\t\tprint(\"min_elem_QT_item =\", type(self))\n\t\t\telse:\n\t\t\t\tself.cur_class = self.last_marked_elem_cls\n\t\t\t\t\n\t\t\t\"\"\"\n\n\t\t\"\"\"\n\t\telif event.buttons() == QtCore.Qt.MidButton:\n\t\t\tself.m_originalX = event.x()\n\t\t\tself.m_originalY = event.y()\n\t\t\tself.m_moving = True\n\t\t\tprint(\"self.m_originalX, self.m_originalX, self.m_moving =\", self.m_originalX, self.m_originalY, self.m_moving)\n\t\t\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\t\t# print('pointPressed: {}'.format(self.pointPressed))\n\n\t\t\"\"\"\n\t\titems = self.items(event.scenePos())\n\t\tfor item in items:\n\t\t\tprint(\"item =\", item)\n\t\t\tif item is self.pixmap_item:\n\t\t\t\tprint(item.mapFromScene(event.scenePos()))\n\t\t\"\"\"\n\n\t\t# super(GraphicsScene, self).mousePressEvent(event)\n\t\"\"\"\n\tdef mouseReleaseEvent(self, event):\n\t\tif event.buttons() == QtCore.Qt.MidButton:\n\t\t\tself.m_moving = False\n\t\"\"\"\n\n\t# This Method prints the mouse position without click (just hovering)\n\tdef mouseMoveEvent(self, event):\n\t\t# print(\"Mouse Position \", event.scenePos())\n\t\t# print(\"self.hasFocus() =\", self.hasFocus())\n\t\t# print(\"self.stickyFocus() =\", self.stickyFocus())\n\t\t# print(\"event.buttonDownScenePos(QtCore.Qt.MidButton) \", event.buttonDownScenePos(QtCore.Qt.MidButton))\n\t\t# print(\"self.m_key_is_pressed =\", self.m_key_is_pressed)\n\t\t# print(\"self.main_window.text_edit.hasFocus() =\", self.main_window.text_edit.hasFocus())\n\t\tself.main_window.setFocus()\n\t\tif event.scenePos().x() < 0 or event.scenePos().y() < 0 or self.scene_width < event.scenePos().x() or self.scene_height < event.scenePos().y():\n\t\t\ttry:\n\t\t\t\t# print(\"mouseMoveEvent [GraphicsScene] -> \", event.scenePos().x(), event.scenePos().y())\n\t\t\t\tself.views()[0].fitInView()\n\t\t\texcept Exception as err:\n\t\t\t\tprint(\"err =\", err)\n\n\n\t\tif self.m_key_is_pressed:\n\t\t# if True:\n\t\t\t# if self.mouse_wheel_pressed:\n\t\t\tself.pointPressed = (event.scenePos().x(), event.scenePos().y())\n\t\t\tmin_elem_QT_item, idx_min_elem_coord_list, circle_elements = self.get_nearest_Box()\n\t\t\tprint(\"min_elem_QT_item, idx_min_elem_coord_list, circle_elements =\", min_elem_QT_item, idx_min_elem_coord_list, circle_elements)\n\t\t\tprint(\"self.pointPressed =\", self.pointPressed)\n\t\t\tcoord = self.coord_list[idx_min_elem_coord_list][1]\n\n\t\t\twidth = coord[1][0] - coord[0][0]\n\t\t\theight = coord[1][1] - coord[0][1]\n\t\t\t# x_center = coord[0][0] + width / 2.0\n\t\t\t# y_center = coord[0][1] + height / 2.0\n\n\t\t\tx_center_new = event.scenePos().x()\n\t\t\ty_center_new = event.scenePos().y()\n\n\t\t\tx_left = x_center_new - width / 2.0\n\t\t\tx_right = x_center_new + width / 2.0\n\t\t\ty_top = y_center_new - height / 2.0\n\t\t\ty_bottom = y_center_new + height / 2.0\n\n\t\t\ttoo_left = x_left < 0\n\t\t\ttoo_right = x_right > self.width()\n\t\t\ttoo_above = y_top < 0\n\t\t\ttoo_below = y_bottom > self.height()\n\n\t\t\tif not (too_left or too_right or too_above or too_below):\n\t\t\t\tself.coord_list[idx_min_elem_coord_list][1] = [(x_left, y_top), (x_right, y_bottom)]\n\t\t\tself.repaint()\n\n\t\t\t# self.repaint()\n\t\tif self.m_moving:\n\t\t\t\"\"\"\n\t\t\ttry:\n\t\t\t\tprint(\"here------------------\")\n\t\t\t\tprint(\"self.m_originalX, self.m_originalY =\", self.m_originalX, self.m_originalY)\n\t\t\t\toldp = self.views()[0].mapToScene(self.m_originalX, self.m_originalY)\n\t\t\t\tprint(\"len(self.views()) =\", len( self.views()))\n\t\t\t\tnewp = self.views()[0].mapToScene(event.scenePos().x(), event.scenePos().y())\n\t\t\t\ttranslation = 0.01 * (newp - oldp)\n\t\t\t\tprint(\"translation.x(), translation.y() =\", translation.x(), translation.y())\n\t\t\t\t# print(\"len(self.views()) =\", len(self.views()))\n\t\t\t\t# print(\"self.views()[0] =\", self.views()[0])\n\t\t\t\t# temp_view = QGraphicsView(self.views()[0])\n\n\t\t\t\t# print(self.views()[0]._zoom)\n\n\n\t\t\t\tself.views()[0].translate(translation.x(), translation.y())\n\n\n\n\t\t\t\t# self.views()[0] = temp_view\n\t\t\t\tprint(\"hallo\")\n\n\t\t\t\tself.m_originalX = event.scenePos().x()\n\t\t\t\tself.m_originalY = event.scenePos().y()\n\t\t\texcept Exception as err:\n\t\t\t\t# logf.write(str(err))\n\t\t\t\tprint(\"Error:\", err)\n\t\t\t# self.update()\n\t\t\t\"\"\"\n\n\n\t\"\"\"\n\t# This works\n\tdef keyPressEvent(self, event):\n\t\tif not event.isAutoRepeat():\n\t\t\tif event.key() == Qt.Key_W:\n\t\t\t\tself.w_key_is_pressed = True\n\t\t\telif event.key() == Qt.Key_H:\n\t\t\t\tself.h_key_is_pressed = True\n\t\t\telif event.key() == Qt.Key_Z:\n\t\t\t\tself.strg_key_is_pressed = True\n\t\t\telif event.key() == Qt.Key_M:\n\t\t\t\tself.m_key_is_pressed = True\n\n\n\n\t\t# print(\"self.m_key_is_pressed =\", self.m_key_is_pressed)\n\t\t# print(\"self.w_key_is_pressed =\", self.w_key_is_pressed)\n\t\t# print(\"self.h_key_is_pressed =\", self.h_key_is_pressed)\n\t\tsuper(GraphicsScene, self).keyPressEvent(event)\n\n\tdef keyReleaseEvent(self, event):\n\t\tif not event.isAutoRepeat():\n\t\t\tif event.key() == Qt.Key_W:\n\t\t\t\tself.w_key_is_pressed = False\n\t\t\telif event.key() == Qt.Key_H:\n\t\t\t\tself.h_key_is_pressed = False\n\t\t\telif event.key() == Qt.Key_M:\n\t\t\t\tself.m_key_is_pressed = False\n\t\t\t# print(\"self.m_key_is_pressed =\", self.m_key_is_pressed)\n\n\n\t\t# print(\"self.w_key_is_pressed =\", self.w_key_is_pressed)\n\t\t# print(\"self.h_key_is_pressed =\", self.h_key_is_pressed)\n\t\tsuper(GraphicsScene, self).keyReleaseEvent(event)\n\t\"\"\"\n\n\n\tdef change_width_or_height(self, increasing):\n\t\tmin_elem_QT_item, idx_min_elem_coord_list, circle_elements = self.get_nearest_Box()\n\t\tcoord = self.coord_list[idx_min_elem_coord_list][1]\n\n\t\ttoo_wide = (coord[0][0] - self.step_width) < 0 or self.width() < (coord[1][0] + self.step_width)\n\t\ttoo_small_width = (coord[1][0] - self.step_width) - (coord[0][0] + self.step_width) <= 0\n\t\ttoo_high = (coord[0][1] - self.step_width) < 0 or self.height() < (coord[1][1] + self.step_width)\n\t\ttoo_small_height = (coord[1][1] - self.step_width) - (coord[0][1] + self.step_width) <= 0\n\t\tprint(\"too_wide =\", too_wide)\n\t\tprint(\"too_small_width =\", too_small_width)\n\t\tprint(\"too_high =\", too_high)\n\t\tprint(\"too_small_height =\", too_small_height)\n\t\tif self.w_key_is_pressed and increasing and not too_wide:\n\t\t\tself.coord_list[idx_min_elem_coord_list][1] = [(self.coord_list[idx_min_elem_coord_list][1][0][0] - self.step_width, self.coord_list[idx_min_elem_coord_list][1][0][1]),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   (self.coord_list[idx_min_elem_coord_list][1][1][0] + self.step_width, self.coord_list[idx_min_elem_coord_list][1][1][1])]\n\t\telif self.w_key_is_pressed and not increasing and not too_small_width:\n\t\t\tself.coord_list[idx_min_elem_coord_list][1] = [(self.coord_list[idx_min_elem_coord_list][1][0][0] + self.step_width, self.coord_list[idx_min_elem_coord_list][1][0][1]),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   (self.coord_list[idx_min_elem_coord_list][1][1][0] - self.step_width, self.coord_list[idx_min_elem_coord_list][1][1][1])]\n\t\tif self.h_key_is_pressed and increasing and not too_high:\n\t\t\tself.coord_list[idx_min_elem_coord_list][1] = [(self.coord_list[idx_min_elem_coord_list][1][0][0], self.coord_list[idx_min_elem_coord_list][1][0][1] - self.step_width),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   (self.coord_list[idx_min_elem_coord_list][1][1][0], self.coord_list[idx_min_elem_coord_list][1][1][1] + self.step_width)]\n\t\telif self.h_key_is_pressed and not increasing and not too_small_height:\n\t\t\tself.coord_list[idx_min_elem_coord_list][1] = [(self.coord_list[idx_min_elem_coord_list][1][0][0], self.coord_list[idx_min_elem_coord_list][1][0][1] + self.step_width),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   (self.coord_list[idx_min_elem_coord_list][1][1][0], self.coord_list[idx_min_elem_coord_list][1][1][1] - self.step_width)]\n\t\tself.repaint()\n\n\tdef wheelEvent(self, event):\n\t\tprint(\"event =\", event.delta()/120)\n\t\tself.pointPressed = (event.scenePos().x(), event.scenePos().y())\n\t\tprint(\"self.pointPressed =\", self.pointPressed)\n\t\tprint(\"self.self.w_key_is_pressed or self.h_key_is_pressed =\", self.w_key_is_pressed or self.h_key_is_pressed)\n\t\tincreasing = event.delta() > 0\n\t\tif self.w_key_is_pressed or self.h_key_is_pressed:\n\t\t\tself.change_width_or_height(increasing)\n\n\t\"\"\"\n\t\tdef mousePressEvent(self, event):\n\t\tprint(event)\n\t\tif event.button() == QtCore.Qt.MidButton:\n\t\t\tself.m_originalX = event.x()\n\t\t\tself.m_originalY = event.y()\n\t\t\tself.m_moving = True\n\t\t\tprint(\"self.m_originalX, self.m_originalX, self.m_moving =\", self.m_originalX, self.m_originalY, self.m_moving)\n\n\tdef mouseReleaseEvent(self, event):\n\t\tif event.button() == QtCore.Qt.MidButton:\n\t\t\tself.m_moving = False\n\n\n\tdef mouseMoveEvent(self, event: QMouseEvent):\n\t\t# print(\"type(event) =\", type(event))\n\t\tif self.m_moving:\n\t\t\tprint(\"here------------------\")\n\t\t\toldp = self.mapToScene(self.m_originalX, self.m_originalY)\n\t\t\tnewp = self.mapToScene(event.pos())\n\t\t\ttranslation = newp - oldp\n\t\t\tprint(\"translation.x(), translation.y() =\", translation.x(), translation.y())\n\t\t\tself.translate(translation.x(), translation.y())\n\n\t\t\tself.m_originalX = event.x()\n\t\t\tself.m_originalY = event.y()\n\n\t\t\tself.update()\n\t\"\"\"\n\n\n\n\n", "description": "\n\t\tself.class_colors = {(0, 163, 232):0,\n\t\t\t\t\t\t\t (0, 200, 0):1,\n\t\t\t\t\t\t\t (232, 163, 0):2,\n\t\t\t\t\t\t\t (200, 0, 0):3\n\t\t\t\t\t\t\t }\n\t\t", "category": "graphics", "imports": ["import sys", "import os", "import glob", "import csv", "import numpy as np", "import cv2", "import darkdetect", "from PyQt5.QtWidgets import *", "from PyQt5 import uic, QtCore", "from PyQt5.QtGui import *", "from PyQt5.QtCore import *"]}], [{"term": "class", "name": "classRender:", "data": "class Render:\n\tdef __init__(self):\n\n\t\t# Configuration file\n\t\tdir = os.path.dirname(__file__)\n\t\tfilename = os.path.join(dir, '../config/matrix_options.ini')\n\n\t\t# Configuration for the matrix\n\t\tconfig = configparser.ConfigParser()\n\t\tconfig.read(filename)\n\n\t\tself.options = RGBMatrixOptions()\n\t\tself.options.gpio_slowdown = int(config['DEFAULT']['gpio_slowdown'])\n\t\tself.options.rows = int(config['DEFAULT']['rows'])\n\t\tself.options.cols = int(config['DEFAULT']['columns'])\n\t\tself.options.drop_privileges = int(config['DEFAULT']['drop_privileges'])\n\t\tself.options.hardware_mapping = config['DEFAULT']['hardware_mapping']\n\t\tself.options.row_address_type = int(config['DEFAULT']['row_address_type'])\n\t\tself.options.brightness = int(config['DEFAULT']['brightness'])\n\t\t#self.options.panel_type = 'FM6126A'\n\n\t\tself.path = '/home/pi/NBA-scoreboard/scoreboard/'\n\n\t\tself.font = graphics.Font()\n\t\tself.font.LoadFont(\"/home/pi/NBA-scoreboard/Minimal-Mono-Bold.bdf\")\n\t\tself.font2 = graphics.Font()\n\t\tself.font2.LoadFont(\"/home/pi/NBA-scoreboard/rpi-rgb-led-matrix/fonts/8x13B.bdf\")\n\t\tself.font3 = graphics.Font()\n\t\tself.font3.LoadFont(\"/home/pi/NBA-scoreboard/rpi-rgb-led-matrix/fonts/9x18B.bdf\")\n\t\tself.font4 = graphics.Font()\n\t\tself.font4.LoadFont(\"/home/pi/NBA-scoreboard/rpi-rgb-led-matrix/fonts/5x8.bdf\")\n\t\tself.team_colors = {'ATL': [[225, 58, 62], [255, 255, 255]], 'BOS': [[0, 131, 72], [255, 205, 112]], 'BKN': [[100, 100, 100], [0, 0, 0]], 'CHA': [[29, 17, 96], [0, 140, 168]], 'CHI': [[206, 17, 65], [0, 0, 0]], 'CLE': [[134, 0, 56], [253, 187, 48]], 'DAL': [[0, 125, 197], [196, 206, 211]], 'DEN': [[77, 144, 205], [253, 185, 39]], 'DET': [[237, 23, 76], [0, 107, 182]], 'GSW': [[253, 185, 39], [0, 107, 182]], 'HOU': [[206, 17, 65], [196, 206, 211]], 'LAL': [[253, 185, 39], [85, 37, 130]], 'MEM': [[15, 88, 108], [190, 212, 233]], 'MIA': [[152, 0, 46], [0, 0, 0]], 'MIL': [[0, 71, 27], [240, 235, 210]], 'MIN': [[0, 80, 131], [0, 169, 79]], 'NOP': [[0, 43, 92], [227, 24, 55]], 'NYK': [[0, 107, 182], [245, 132, 38]], 'OKC': [[0, 125, 195], [240, 81, 51]], 'ORL': [[0, 125, 197], [0, 0, 0]], 'PHI': [[237, 23, 76], [0, 107, 182]], 'PHX': [[229, 96, 32], [29, 17, 96]], 'POR': [[224, 58, 62], [186, 195, 201]], 'SAC': [[114, 76, 159], [200, 200, 200]], 'SAS': [[186, 195, 201], [0, 0, 0]], 'TOR': [[206, 17, 65], [0, 0, 0]], 'UTA': [[0, 43, 92], [249, 160, 27]], 'WAS': [[0, 43, 92], [227, 24, 55]], 'IND': [[255, 198, 51], [0, 39, 93]], 'LAC': [[237, 23, 76], [0, 107, 182]]}\n\n\tdef Render_Games(self, printer=False):\n\t\tmatrix = RGBMatrix(options=self.options)\n\t\tdate_range = []\n\t\tdisp_live_odds = True\n\t\ttry:\n\t\t\tfor day in os.listdir(self.path):\n\t\t\t\tif day=='.DS_Store':\n\t\t\t\t\tcontinue\n\t\t\t\tif day == 'DataToday.json':\n\t\t\t\t\twith open(self.path + day) as file:\n\t\t\t\t\t\tgame_data = json.load(file)\n\n\t\texcept:\n\t\t\tprint('Error loading spreads data.')\n\t\t\tgame_data = {}\n\n\t\ttry:\n\t\t\twith open(self.path + 'NBASpreads.json', 'r') as file:\n\t\t\t\tspreads_data = json.load(file)\n\t\t\twith open(self.path + 'NBASpreadsLive.json', 'r') as file:\n\t\t\t\tspreads_data_live = json.load(file)\n\n\t\texcept:\n\t\t\tprint('Error loading spreads data.')\n\t\t\tspreads_data = {}\n\n\t\tcanvas = matrix.CreateFrameCanvas()\n\t\tif game_data == []:\n\t\t\tprint('no games')\n\t\t\tgraphics.DrawText(canvas, self.font, (128-(13*8))/2+1, 29, graphics.Color(150,150,150), 'NO GAMES')\n\t\t\tgraphics.DrawText(canvas, self.font, (127-13*5)/2+2, 48, graphics.Color(150,150,150), 'TODAY')\n\n\t\t\t # NBA Logo\n\t\t\tfor line in range(38+10,52+10):\n\t\t\t\tgraphics.DrawLine(canvas, 116+4, line, 119+4, line, graphics.Color(0, 0, 255))\n\t\t\t\tgraphics.DrawLine(canvas, 120+4, line, 121+4, line, graphics.Color(255, 0, 0))\n\t\t\tfor line in range(41+10,45+10):\n\t\t\t\tgraphics.DrawLine(canvas, 116+4, line, 116+4, line, graphics.Color(150, 150, 150))\n\t\t\tfor line in range(40+10,46+10):\n\t\t\t\tgraphics.DrawLine(canvas, 117+4, line, 117+4, line, graphics.Color(150, 150, 150))\n\t\t\tfor line in range(39+10,47+10):\n\t\t\t\tgraphics.DrawLine(canvas, 118+4, line, 118+4, line, graphics.Color(150, 150, 150))\n\t\t\tfor line in range(38+10,49+10):\n\t\t\t\tgraphics.DrawLine(canvas, 119+4, line, 119+4, line, graphics.Color(150, 150, 150))\n\t\t\tfor line in range(43+10,44+10):\n\t\t\t\tgraphics.DrawLine(canvas, 119+4, line, 119+4, line, graphics.Color(255, 0, 0))\n\t\t\tfor line in range(41+10,46+10):\n\t\t\t\tgraphics.DrawLine(canvas, 120+4, line, 120+4, line, graphics.Color(150, 150, 150))\n\t\t\tfor line in range(48+10,52+10):\n\t\t\t\tgraphics.DrawLine(canvas, 120+4, line, 120+4, line, graphics.Color(150, 150, 150))\n\t\t\tfor line in range(45+10,46+10):\n\t\t\t\tgraphics.DrawLine(canvas, 121+4, line, 121+4, line, graphics.Color(150, 150, 150))\n\t\t\tcanvas = matrix.SwapOnVSync(canvas)\n\t\t\ttime.sleep(3600*2)\n\t\tfor game in game_data:\n\t\t\thometeam = game['homeTeam']['teamTricode']\n\t\t\tawayteam = game['awayTeam']['teamTricode']\n\n\t\t\thome = (game['homeTeam']['teamCity'] + '-' + game['homeTeam']['teamName']).replace(' ', '-').lower()\n\t\t\taway = (game['awayTeam']['teamCity'] + '-' + game['awayTeam']['teamName']).replace(' ', '-').lower()\n\t\t\tif home == 'la-clippers':\n\t\t\t\thome = 'l-a-clippers'\n\t\t\tif away == 'la-clippers':\n\t\t\t\taway = 'l-a-clippers'\n\n\t\t\tgamelink = r'/basketball/nba/{0}-{1}-{2}'.format(away, home, game['gameCode'][0:game['gameCode'].find(r'/')])\n\t\t\tprint(gamelink)\n\n\t\t\ttry:\n\t\t\t\tif disp_live_odds == True and game['gameStatus'] == 2:\n\t\t\t\t\tspread = spreads_data_live[gamelink]['spread']\n\t\t\t\t\tover_under = spreads_data_live[gamelink]['over_under']\n\t\t\t\telse:\n\t\t\t\t\tspread = spreads_data[gamelink]['spread']\n\t\t\t\t\tover_under = spreads_data[gamelink]['over_under']\n\n\t\t\texcept KeyError:\n\t\t\t\tspread = ''\n\t\t\t\tover_under = ''\n\n\t\t\tposx = 5\n\t\t\tlen1 = 0\n\t\t\twhile True:\n\t\t\t\tfor line in range(0,64):\n\t\t\t\t\tgraphics.DrawLine(canvas, 0, line, 128, line, graphics.Color(0, 0, 0)) #clearing matrix\n\n\t\t\t\tfor line in range(20,38): #team color square\n\t\t\t\t\tgraphics.DrawLine(canvas, 0, line, 39, line, graphics.Color(self.team_colors[hometeam][0][0], self.team_colors[hometeam][0][1], self.team_colors[hometeam][0][2]))\n\t\t\t\tfor line in range(0,18): #team color square\n\t\t\t\t\tgraphics.DrawLine(canvas, 0, line, 39, line, graphics.Color(self.team_colors[awayteam][0][0], self.team_colors[awayteam][0][1], self.team_colors[awayteam][0][2]))\n\n\t\t\t\thomescore = game['homeTeam']['score']\n\t\t\t\tawayscore = game['awayTeam']['score']\n\t\t\t\tif game['gameStatus'] != 1: #white square for score\n\t\t\t\t\tfor line in range(20,38):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 40, line, 79, line, graphics.Color(255, 255, 255))\n\t\t\t\t\tfor line in range(0,18):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 40, line, 79, line, graphics.Color(255, 255, 255))\n\n\t\t\t\t\t\t # NBA Logo\n\t\t\t\t\tfor line in range(38,52):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 116, line, 119, line, graphics.Color(0, 0, 255))\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 120, line, 121, line, graphics.Color(255, 0, 0))\n\t\t\t\t\tfor line in range(41,45):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 116, line, 116, line, graphics.Color(255, 255, 255))\n\t\t\t\t\tfor line in range(40,46):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 117, line, 117, line, graphics.Color(255, 255, 255))\n\t\t\t\t\tfor line in range(39,47):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 118, line, 118, line, graphics.Color(255, 255, 255))\n\t\t\t\t\tfor line in range(38,49):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 119, line, 119, line, graphics.Color(255, 255, 255))\n\t\t\t\t\tfor line in range(43,44):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 119, line, 119, line, graphics.Color(255, 0, 0))\n\t\t\t\t\tfor line in range(41,46):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 120, line, 120, line, graphics.Color(255, 255, 255))\n\t\t\t\t\tfor line in range(48,52):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 120, line, 120, line, graphics.Color(255, 255, 255))\n\t\t\t\t\tfor line in range(45,46):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 121, line, 121, line, graphics.Color(255, 255, 255))\n\n\t\t\t\t\tif spread != \"\":\n\t\t\t\t\t\tif (homescore-awayscore) >= float(spread)*(-1):\n\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font2, 127 - len(str(over_under))*8, 14, graphics.Color(0, 0, 255), over_under)\n\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font2, 127 - len(str(spread))*8, 34, graphics.Color(0, 0, 255), spread)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\taway_spread = float(spread)*(-1)\n\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font2, 127 - len(str(over_under))*8, 34, graphics.Color(0, 0, 255), over_under)\n\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font2, 127 - len(str(away_spread))*8, 14, graphics.Color(0, 0, 255), str(away_spread))\n\n\t\t\t\t\telse:\n\t\t\t\t\t\tgraphics.DrawText(canvas, self.font2, 127 - len(str(over_under))*8, 14, graphics.Color(0, 0, 255), over_under)\n\t\t\t\t\t\tgraphics.DrawText(canvas, self.font2, 127 - len(str(spread))*8, 34, graphics.Color(0, 0, 255), spread)\n\n\t\t\t\telse:\n\t\t\t\t\tgraphics.DrawText(canvas, self.font2, 127 - len(str(over_under))*8, 14, graphics.Color(0, 0, 255), over_under)\n\t\t\t\t\tgraphics.DrawText(canvas, self.font2, 127 - len(str(spread))*8, 34, graphics.Color(0, 0, 255), spread)\n\n\t\t\t\tgraphics.DrawText(canvas, self.font, 2, 36, graphics.Color(self.team_colors[hometeam][1][0], self.team_colors[hometeam][1][1], self.team_colors[hometeam][1][2]), hometeam)\n\t\t\t\tgraphics.DrawText(canvas, self.font, 2, 16, graphics.Color(self.team_colors[awayteam][1][0], self.team_colors[awayteam][1][1], self.team_colors[awayteam][1][2]), awayteam)\n\n\t\t\t\ttimeremaining = game['gameStatusText']\n\t\t\t\tif timeremaining[0] == 'Q' and timeremaining[3] == '0':\n\t\t\t\t\ttimeremaining = timeremaining[:3] + timeremaining[4:]\n\t\t\t\t\tif timeremaining[0] == 'Q' and timeremaining[3] == '0':\n\t\t\t\t\t\ttimeremaining = timeremaining[:3] + timeremaining[4:]\n\t\t\t\tif timeremaining[1] == '1':\n\t\t\t\t\ttimeremaining = '1ST' + timeremaining[2:]\n\t\t\t\tif timeremaining[1] == '2':\n\t\t\t\t\ttimeremaining = '2ND' + timeremaining[2:]\n\t\t\t\tif timeremaining[1] == '3':\n\t\t\t\t\ttimeremaining = '3RD' + timeremaining[2:]\n\t\t\t\tif timeremaining[1] == '4':\n\t\t\t\t\ttimeremaining = '4TH' + timeremaining[2:]\n\t\t\t\tif timeremaining[1] == '5':\n\t\t\t\t\ttimeremaining = '1ST OT' + timeremaining[2:]\n\t\t\t\tif timeremaining[1] == '6':\n\t\t\t\t\ttimeremaining = '2ND OT' + timeremaining[2:]\n\t\t\t\tif timeremaining[1] == '7':\n\t\t\t\t\ttimeremaining = '3RD OT' + timeremaining[2:]\n\t\t\t\tif timeremaining[1] == '8':\n\t\t\t\t\ttimeremaining = '4TH OT' + timeremaining[2:]\n\t\t\t\tif timeremaining == 'Half':\n\t\t\t\t\ttimeremaining = 'HALFTIME'\n\n\t\t\t\ttimeremaining = timeremaining.upper()\n\n\t\t\t\tif game['gameStatus'] == 2: #GAME IS LIVE\n\t\t\t\t\tgraphics.DrawText(canvas, self.font, 75 - len(str(awayscore))*11, 16, graphics.Color(0, 0, 0), str(awayscore))\n\t\t\t\t\tgraphics.DrawText(canvas, self.font, 75 - len(str(homescore))*11, 36, graphics.Color(0, 0, 0), str(homescore))\n\t\t\t\t\tif (game['gameStatusText'][0] == 'Q' and game['gameStatusText'][1] >= '4') and (game['gameStatusText'][3] == '0' and game['gameStatusText'][4] <= '4'): #Q4 or OT < 5min remaining\n\t\t\t\t\t\tif homescore > awayscore:\n\t\t\t\t\t\t\tif (homescore - awayscore) <= 10: #close game\n\t\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 51, graphics.Color(255, 255, 255), timeremaining) #bright quarter and time remaining\n\t\t\t\t\t\t\t\tfor line in range(54,56):\n\t\t\t\t\t\t\t\t\tgraphics.DrawLine(canvas, 0, line, 127, line, graphics.Color(255, 0, 0)) #red line at bottom of screen\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 52, graphics.Color(200, 200, 200), timeremaining)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tif (awayscore - homescore) <= 10: #close game\n\t\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 51, graphics.Color(255, 255, 255), timeremaining) #bright quarter and time remaining\n\t\t\t\t\t\t\t\tfor line in range(54,56):\n\t\t\t\t\t\t\t\t\tgraphics.DrawLine(canvas, 0, line, 127, line, graphics.Color(255, 0, 0)) #red line at bottom of screen\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 52, graphics.Color(200, 200, 200), timeremaining)\n\t\t\t\t\telse: #not a close game or not under 4min\n\t\t\t\t\t\tif timeremaining[1] == '1':\n\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 52, graphics.Color(200, 200, 200), timeremaining) #56\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 52, graphics.Color(200, 200, 200), timeremaining)\n\n\n\n\t\t\t\tif game['gameStatus'] == 3: #GAME IS FINISHED\n\t\t\t\t\tif homescore < awayscore:\n\t\t\t\t\t\tfor line in range(20,38):\n\t\t\t\t\t\t\tgraphics.DrawLine(canvas, 40, line, 79, line, graphics.Color(75, 75, 75))\n\t\t\t\t\telse:\n\t\t\t\t\t\tfor line in range(0,18):\n\t\t\t\t\t\t\tgraphics.DrawLine(canvas, 40, line, 79, line, graphics.Color(75, 75, 75))\n\n\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 52, graphics.Color(200, 200, 200), game['gameStatusText'].upper())\n\t\t\t\t\tgraphics.DrawText(canvas, self.font, 75 - len(str(awayscore))*11, 16, graphics.Color(0, 0, 0), str(awayscore))\n\t\t\t\t\tgraphics.DrawText(canvas, self.font, 75 - len(str(homescore))*11, 36, graphics.Color(0, 0, 0), str(homescore))\n\n\n\n\t\t\t\tif game['gameStatus'] == 1: #GAME IS UPCOMING\n\t\t\t\t\tawayrecord = str(game['awayTeam']['wins']) + '-' + str(game['awayTeam']['losses'])\n\t\t\t\t\thomerecord = str(game['homeTeam']['wins']) + '-' + str(game['homeTeam']['losses'])\n\t\t\t\t\tgraphics.DrawText(canvas, self.font2, 42, 14, graphics.Color(200, 200, 200), awayrecord) #away team record\n\t\t\t\t\tgraphics.DrawText(canvas, self.font2, 42, 34, graphics.Color(200, 200, 200), homerecord) #home team record\n\t\t\t\t\tif game['gameStatusText'] != 'PPD': #upcoming game\n\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 56, graphics.Color(200, 200, 200), game['gameStatusText'][0:game['gameStatusText'].find('ET')].upper() + 'ET')\n\t\t\t\t\tif game['gameStatusText'] == 'PPD': #postponed game\n\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 56, graphics.Color(200, 200, 200), 'POSTPONED')\n\t\t\t\t\t# NBA Logo\n\t\t\t\t\tfor line in range(44,58):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 116, line, 119, line, graphics.Color(0, 0, 255))\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 120, line, 121, line, graphics.Color(255, 0, 0))\n\t\t\t\t\tfor line in range(47,51):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 116, line, 116, line, graphics.Color(255, 255, 255))\n\t\t\t\t\tfor line in range(46,52):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 117, line, 117, line, graphics.Color(255, 255, 255))\n\t\t\t\t\tfor line in range(45,53):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 118, line, 118, line, graphics.Color(255, 255, 255))\n\t\t\t\t\tfor line in range(44,55):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 119, line, 119, line, graphics.Color(255, 255, 255))\n\t\t\t\t\tfor line in range(49,50):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 119, line, 119, line, graphics.Color(255, 0, 0))\n\t\t\t\t\tfor line in range(47,52):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 120, line, 120, line, graphics.Color(255, 255, 255))\n\t\t\t\t\tfor line in range(54,58):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 120, line, 120, line, graphics.Color(255, 255, 255))\n\t\t\t\t\tfor line in range(51,52):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 121, line, 121, line, graphics.Color(255, 255, 255))\n\n\n\t\t\t\thomeleadername = game['gameLeaders']['homeLeaders']['name']\n\t\t\t\tawayleadername = game['gameLeaders']['awayLeaders']['name']\n\t\t\t\tif game['gameStatus'] != 1 and homeleadername is not None and awayleadername is not None:\n\t\t\t\t\thomeleaderpoints = game['gameLeaders']['homeLeaders']['points']\n\t\t\t\t\thomeleaderrebounds = game['gameLeaders']['homeLeaders']['rebounds']\n\t\t\t\t\thomeleaderassists = game['gameLeaders']['homeLeaders']['assists']\n\t\t\t\t\tdef findhomelastname(homeleadername,n):\n\t\t\t\t\t\t#Using ' ' as a separator, All_words is a list of all the words in the String\n\t\t\t\t\t\tAll_words=homeleadername.split(\" \")\n\t\t\t\t\t\treturn All_words[n-1]\n\t\t\t\t\thomeleaderlastname = findhomelastname(homeleadername,2)\n\t\t\t\t\thomestatline = homeleadername[0] + '.'+ str(homeleaderlastname) + ' ' + str(homeleaderpoints) + '-' + str(homeleaderrebounds) + '-' + str(homeleaderassists)\n\t\t\t\t\tawayleaderpoints = game['gameLeaders']['awayLeaders']['points']\n\t\t\t\t\tawayleaderrebounds = game['gameLeaders']['awayLeaders']['rebounds']\n\t\t\t\t\tawayleaderassists = game['gameLeaders']['awayLeaders']['assists']\n\t\t\t\t\tdef findawaylastname(awayleadername,n):\n\t\t\t\t\t\t#Using ' ' as a separator, All_words is a list of all the words in the String\n\t\t\t\t\t\tAll_words2=awayleadername.split(\" \")\n\t\t\t\t\t\treturn All_words2[n-1]\n\t\t\t\t\tawayleaderlastname = findawaylastname(awayleadername,2)\n\t\t\t\t\tawaystatline = awayleadername[0] + '.' + str(awayleaderlastname) + ' ' + str(awayleaderpoints) + '-' + str(awayleaderrebounds) + '-' + str(awayleaderassists)\n\n\t\t\t\t\tfor line in range(56,64): #statline background\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 0, line, 127, line, graphics.Color(255, 255, 255))\n\n\t\t\t\t\tlen1 = graphics.DrawText(canvas, self.font4, posx, 63, graphics.Color(0, 0, 0), awaystatline.upper() + '  ' + homestatline.upper())\n\t\t\t\t\tif len1 <= canvas.width:\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tposx -= 1\n\t\t\t\t\t\tif (posx == canvas.width - len1 - 2):\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\ttime.sleep(0.04)\n\t\t\t\t\t\tcanvas = matrix.SwapOnVSync(canvas)\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\n\n\n\t\t\tif (posx == canvas.width - len1 - 2):\n\t\t\t\ttime.sleep(2)\n\t\t\t\tcanvas = matrix.SwapOnVSync(canvas)\n\t\t\telse:\n\t\t\t\tcanvas = matrix.SwapOnVSync(canvas)\n", "description": null, "category": "graphics", "imports": ["from rgbmatrix import graphics, RGBMatrix, RGBMatrixOptions", "import os", "import json", "import datetime as dt", "import time", "import sys", "import signal", "import configparser"]}], [{"term": "class", "name": "GhostSprite", "data": "class GhostSprite(mazesprite.MazeSprite):\r\n\t\"\"\"A base class for all ghost sprites.\"\"\"\r\n\tdef __init__(self, graphics, navigator):\r\n\t\tself.color = self.get_color()\r\n\t\tself.is_scared = False\r\n\t\tmazesprite.MazeSprite.__init__(self, graphics, navigator)\r\n\r\n\tdef get_color():\r\n\t\t\"\"\"Indicates the color of this ghost.\"\"\"\r\n\t\tpass\r\n\tdef get_hunting_frames(self, graphics):\r\n\t\t\"\"\"Returns the images to use when in hunt mode.\"\"\"\r\n\t\tpass\r\n\tdef get_startup_position(self):\r\n\t\t\"\"\"Returns the tile position where this ghost should be when the game starts.\"\"\"\r\n\t\tpass\r\n\tdef get_startup_direction(self):\r\n\t\t\"\"\"Returns the direction the sprite should be facing when the game starts.\"\"\"\r\n\t\tpass\r\n\r\n\tdef load_frames(self, graphics):\r\n\t\t\"\"\"This sets the frames properties to contain the appropriate image sets.\"\"\"\r\n\t\tself.hunting_frames = self.get_hunting_frames(graphics)\r\n\t\tself.scared_frames = self.get_scared_frames(graphics)\r\n\t\tself.eyesonly_frames = self.get_eyesonly_frames(graphics)\r\n\t\tself.set_all_frames(self.hunting_frames)\r\n\r\n\tdef set_all_frames(self, frames):\r\n\t\t\"\"\"Sets the framesets for all 4 directions to the specified single set of frames.\r\n\t\tWe can do this with ghosts because right now they only have a single sprite\r\n\t\timage.  IF they had different images for up, down, left and right we'd have to\r\n\t\taddress them individually.\"\"\"\r\n\t\tself.up_frames = frames\r\n\t\tself.down_frames = frames\r\n\t\tself.left_frames = frames\r\n\t\tself.right_frames = frames\r\n\t\tself.frames = frames\r\n\r\n\t\tself.direction_frames = {\r\n\t\t\t\"up\": self.up_frames,\r\n\t\t\t\"down\": self.down_frames,\r\n\t\t\t\"left\": self.left_frames,\r\n\t\t\t\"right\": self.right_frames\r\n\t\t}\r\n\r\n\tdef get_scared_frames(self, graphics):\r\n\t\t\"\"\"Returns the frameset with 'scared' ghost images. \"\"\"\r\n\t\treturn [graphics.img_ghost_duress]\r\n\r\n\tdef get_eyesonly_frames(self, graphics):\r\n\t\t\"\"\"Returns the frameset with 'eyes only' ghost images.\"\"\"\r\n\t\treturn [graphics.img_ghost_eyesonly]\r\n\r\n\r\n\t# This overrides the get_speed() method in the mazesprite class, which GobblerSprite inherits.\r\n\tdef get_speed(self):\r\n\t\t\"\"\"Returns the number of pixels that the sprite will move at a time.\"\"\"\r\n\t\treturn gamedata.GameData.GOBBLER_SPEED\r\n\r\n\tdef run_away(self):\r\n\t\t\"\"\"Puts this ghost in 'scared' mode.\"\"\"\r\n\t\tself.is_scared = True\r\n\t\t#self.frames = self.scared_frames\r\n\t\tself.set_all_frames(self.scared_frames)\r\n\t\t# I need to slow down the ghosts when they're scared\r\n\t\t# but messing with the speed causes all kinds of\r\n\t\t# problems with running through walls.\r\n\t\t#self.speed = self.get_speed() // 2\r\n\r\n\tdef hunt(self):\r\n\t\t\"\"\"Puts this ghost in 'hunt' mode.\"\"\"\r\n\t\tself.is_scared = False\r\n\t\tself.set_all_frames(self.hunting_frames)\r\n\r\n", "description": "A base class for all ghost sprites.", "category": "graphics", "imports": ["from directions import *\r", "import gamedata\r", "import mazesprite\r"]}, {"term": "class", "name": "YellowGhostSprite", "data": "class YellowGhostSprite(GhostSprite):\r\n\t\"\"\"Represent's the yellow ghost's graphics, animation and behaviors.\"\"\"\r\n\tdef __init__(self, graphics, navigator):\r\n\t\tGhostSprite.__init__(self, graphics, navigator)\r\n\r\n\tdef get_color(self):\r\n\t\treturn \"Yellow\"\r\n\r\n\tdef get_hunting_frames(self, graphics):\r\n\t\treturn [graphics.img_ghost_yellow]\r\n\r\n\tdef get_startup_position(self):\r\n\t\treturn gamedata.GameData.YELLOW_GHOST_STARTUP_POSITION\r\n\r\n\tdef get_startup_direction(self):\r\n\t\treturn gamedata.GameData.YELLOW_GHOST_STARTUP_DIRECTION\r\n\r\n", "description": "Represent's the yellow ghost's graphics, animation and behaviors.", "category": "graphics", "imports": ["from directions import *\r", "import gamedata\r", "import mazesprite\r"]}, {"term": "class", "name": "PinkGhostSprite", "data": "class PinkGhostSprite(GhostSprite):\r\n\t\"\"\"Represent's the pink ghost's graphics, animation and behaviors.\"\"\"\r\n\tdef __init__(self, graphics, navigator):\r\n\t\tGhostSprite.__init__(self, graphics, navigator)\r\n\r\n\tdef get_color(self):\r\n\t\treturn \"Pink\"\r\n\r\n\tdef get_hunting_frames(self, graphics):\r\n\t\treturn [graphics.img_ghost_pink]\r\n\r\n\tdef get_startup_position(self):\r\n\t\treturn gamedata.GameData.PINK_GHOST_STARTUP_POSITION\r\n\r\n\tdef get_startup_direction(self):\r\n\t\treturn gamedata.GameData.PINK_GHOST_STARTUP_DIRECTION\r\n\r\n", "description": "Represent's the pink ghost's graphics, animation and behaviors.", "category": "graphics", "imports": ["from directions import *\r", "import gamedata\r", "import mazesprite\r"]}, {"term": "class", "name": "CyanGhostSprite", "data": "class CyanGhostSprite(GhostSprite):\r\n\t\"\"\"Represent's the cyan ghost's graphics, animation and behaviors.\"\"\"\r\n\tdef __init__(self, graphics, navigator):\r\n\t\tGhostSprite.__init__(self, graphics, navigator)\r\n\r\n\tdef get_color(self):\r\n\t\treturn \"Cyan\"\r\n\r\n\tdef get_hunting_frames(self, graphics):\r\n\t\treturn [graphics.img_ghost_cyan]\r\n\r\n\tdef get_startup_position(self):\r\n\t\treturn gamedata.GameData.CYAN_GHOST_STARTUP_POSITION\r\n\r\n\tdef get_startup_direction(self):\r\n\t\treturn gamedata.GameData.CYAN_GHOST_STARTUP_DIRECTION\r\n\r\n", "description": "Represent's the cyan ghost's graphics, animation and behaviors.", "category": "graphics", "imports": ["from directions import *\r", "import gamedata\r", "import mazesprite\r"]}, {"term": "class", "name": "RedGhostSprite", "data": "class RedGhostSprite(GhostSprite):\r\n\t\"\"\"Represent's the red ghost's graphics, animation and behaviors.\"\"\"\r\n\tdef __init__(self, graphics, navigator):\r\n\t\tGhostSprite.__init__(self, graphics, navigator)\r\n\r\n\tdef get_color(self):\r\n\t\treturn \"Red\"\r\n\r\n\tdef get_hunting_frames(self, graphics):\r\n\t\treturn [graphics.img_ghost_red]\r\n\r\n\tdef get_startup_position(self):\r\n\t\treturn gamedata.GameData.RED_GHOST_STARTUP_POSITION\r\n\r\n\tdef get_startup_direction(self):\r\n\t\treturn gamedata.GameData.RED_GHOST_STARTUP_DIRECTION\r\n", "description": "Represent's the red ghost's graphics, animation and behaviors.", "category": "graphics", "imports": ["from directions import *\r", "import gamedata\r", "import mazesprite\r"]}], [], [], [{"term": "def", "name": "v0_write_handler", "data": "def v0_write_handler(value):\t\n\tglobal source\n\tif value:\n\t\tsource = not source\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "import time", "from requests import get", "import json", "import bme280_v2 as bme", "import BlynkLib", "from subprocess import call"]}, {"term": "def", "name": "v1_write_handler", "data": "def v1_write_handler(value):\t\n\tglobal reading\t\n\tvalue = int(value[0])\n\tif value == 0:\n\t\treading = 'temp'\n\telif value == 1:\n\t\treading = 'humid'\n\telif value == 2:\n\t\treading = 'pressure'\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "import time", "from requests import get", "import json", "import bme280_v2 as bme", "import BlynkLib", "from subprocess import call"]}, {"term": "def", "name": "v2_write_handler", "data": "def v2_write_handler(value): \n\tcall(\"systemctl poweroff -i\",shell=True)\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "import time", "from requests import get", "import json", "import bme280_v2 as bme", "import BlynkLib", "from subprocess import call"]}, {"term": "class", "name": "RunMatrix", "data": "class RunMatrix(SampleBase):\n\tdef __init__(self, *args, **kwargs):\n\t\tsuper(RunMatrix, self).__init__(*args, **kwargs)\t \n\t  \n\tdef run(self):\n\t\toffscreen_canvas = self.matrix.CreateFrameCanvas()\t\t\n\t\tfont1 = graphics.Font()\n\t\tfont1.LoadFont(\"../../../fonts/5x8.bdf\")\n\t\tfont2 = graphics.Font()\n\t\tfont2.LoadFont(\"../../../fonts/4x6.bdf\")\n\t\tcanvas = self.matrix\n\t\tcanvas.brightness = 60\n\t\t\n\t\t# Y Position of Text\n\t\tpos_y = 30\t\t\n\t\t# Use to Move Sun/Snow Icon Up/Down\n\t\tsun_y = 2;\n\t\tsnow_y = 2;\n\n\t\t# Waco ID: id=4739526\t\t\n\t\turl = 'https://api.openweathermap.org/data/2.5/weather?id=4739526&units=imperial&APPID=hidden'\n\t\t\t\t\t \n\t\twhile True:\t\t\t\n\t\t\tblynk.run()\t\t\t\n\t\t\toffscreen_canvas.Clear()\t\t\t\n\t\t\t\t\n\t\t\t# Get Weather Data from OpenWeatherMap\n\t\t\tresponse = get(url)\n\t\t\t# Converts Json Data to Python Dictionary\n\t\t\tweather = json.loads(response.text)\n\t\t\t\n\t\t\t# Get Readings From Sensor\n\t\t\ttemp,pressure,humidity = bme.readBME280All()\n\t\t\ttemp = int(temp*9/5+32)\n\t\t\tpressure = int(pressure)\n\t\t\thumidity = int(humidity)\n\t\t\tcorrection = 0\t\t   \n\t\t\t\t\n\t\t\tif reading == 'temp': # if temp is selected by blynk button\n\t\t\t\tif source == False: # if we wamt outside (internet) readings\n\t\t\t\t\ttemp = int((weather[\"main\"][\"temp\"])) # Temp data from internet\t\t\t   \n\t\t\t\tmy_text = str(temp) + u\"\\u00b0\" + \"F\" # make usable by drawText()\n\t\t\t\tunit_len = 9\n\t\t\t\tdigit_len = len(str(temp))\n\t\t\telif reading == 'humid':\n\t\t\t\tif source == False:\n\t\t\t\t\thumidity = int((weather[\"main\"][\"humidity\"]))\n\t\t\t\tmy_text = str(humidity) + \"%\"\n\t\t\t\tunit_len = 4\n\t\t\t\tdigit_len = len(str(humidity))\n\t\t\t\ttextColor = cyan\n\t\t\telif reading == 'pressure':\n\t\t\t\tif source == False:\n\t\t\t\t\tpressure = int((weather[\"main\"][\"pressure\"]))\n\t\t\t\t\tcorrection = 1\n\t\t\t\tmy_text = str(round(pressure*.0009869,1)) + \"atm\"\n\t\t\t\tunit_len = 14\n\t\t\t\tdigit_len = len(str(pressure))-correction\t\t\t  \n\t\t\t\ttextColor = orange\n\t\t\t\n\t\t\t# For Centering Temp on Matrix\t\t   \n\t\t\treading_len = digit_len*5 + unit_len\t\t   \n\t\t\tpos_x = (32-reading_len)/2\n\t\t\t\n\t\t\t# Temp Color\n\t\t\tif reading == 'temp':\n\t\t\t\tif 83<=temp<100:\n\t\t\t\t  val=255-((temp-83)*255)/17\n\t\t\t\t  textColor = graphics.Color(255,val,0)\n\t\t\t\telif 66<=temp<83:\n\t\t\t\t  val=((temp-66)*255)/17\n\t\t\t\t  textColor = graphics.Color(val,255,0)\n\t\t\t\telif 49<=temp<66:\n\t\t\t\t  val=255-((temp-49)*255)/17\t\t\t  \n\t\t\t\t  textColor = graphics.Color(0,255,val)\n\t\t\t\telif 32=100: \n\t\t\t\t   textColor = graphics.Color(255,0,0)\t\t\t  \n\t\t\t\telif temp<=32:  \n\t\t\t\t  textColor = graphics.Color(0,0,255)\t\t\t \n\t\t\t\n\t\t\t# Print Data to Matrix\n\t\t\tgraphics.DrawText(offscreen_canvas, font1, pos_x, pos_y, textColor, my_text)\t\t\t\n\t\t\toffscreen_canvas = self.matrix.SwapOnVSync(offscreen_canvas)\n\n\t\t\tif weather[\"weather\"][0][\"main\"] in cloud:  #ideally there would be functions for these\n\t\t\t\t## Cloud Icon\n\t\t\t\t# Outer Edge\n\t\t\t\tgraphics.DrawLine(canvas,7,13,23,13,medGray)\n\t\t\t\tgraphics.DrawLine(canvas,6,12,6,11,medGray)\n\t\t\t\tgraphics.DrawLine(canvas,7,10,7,9,medGray)\n\t\t\t\tgraphics.DrawLine(canvas,8,8,9,8,medGray)\n\t\t\t\tgraphics.DrawLine(canvas,10,7,10,6,medGray)\n\t\t\t\tgraphics.DrawLine(canvas,11,5,11,5,medGray)\n\t\t\t\tgraphics.DrawLine(canvas,12,4,14,4,medGray)\n\t\t\t\tgraphics.DrawLine(canvas,15,5,16,6,medGray)\n\t\t\t\tgraphics.DrawLine(canvas,17,5,19,5,medGray)\n\t\t\t\tgraphics.DrawLine(canvas,20,6,21,7,medGray)\n\t\t\t\tgraphics.DrawLine(canvas,21,8,21,9,medGray)\n\t\t\t\tgraphics.DrawLine(canvas,22,9,24,11,medGray)\n\t\t\t\tgraphics.DrawLine(canvas,24,12,24,12,medGray)\n\t\t\t\tgraphics.DrawLine(canvas,15,7,16,7,medGray)\n\t\t\t\t# Highlights\n\t\t\t\tgraphics.DrawLine(canvas,7,11,7,11,white)\n\t\t\t\tgraphics.DrawLine(canvas,8,9,9,9,white)\n\t\t\t\tgraphics.DrawLine(canvas,10,8,10,8,white)\n\t\t\t\tgraphics.DrawLine(canvas,10,10,10,10,white)\n\t\t\t\tgraphics.DrawLine(canvas,11,6,11,6,white)\n\t\t\t\tgraphics.DrawLine(canvas,12,5,14,5,white)\n\t\t\t\tgraphics.DrawLine(canvas,17,6,19,6,white)\n\t\t\t\tgraphics.DrawLine(canvas,20,7,20,7,white)\n\t\t\t\tgraphics.DrawLine(canvas,21,10,22,10,white)\n\t\t\t\tgraphics.DrawLine(canvas,23,11,23,11,white)\n\t\t\t\t# Fill\n\t\t\t\tgraphics.DrawLine(canvas,12,6,12,12,gray)\n\t\t\t\tgraphics.DrawLine(canvas,13,6,13,12,gray)\n\t\t\t\tgraphics.DrawLine(canvas,14,6,14,12,gray)\n\t\t\t\tgraphics.DrawLine(canvas,11,7,11,12,gray)\n\t\t\t\tgraphics.DrawLine(canvas,10,11,10,12,gray)\n\t\t\t\tgraphics.DrawLine(canvas,9,10,9,12,gray)\n\t\t\t\tgraphics.DrawLine(canvas,8,10,8,12,gray)\n\t\t\t\tgraphics.DrawLine(canvas,7,12,7,12,gray)\n\t\t\t\tgraphics.DrawLine(canvas,15,8,15,12,gray)\n\t\t\t\tgraphics.DrawLine(canvas,16,8,16,12,gray)\n\t\t\t\tgraphics.DrawLine(canvas,17,7,17,12,gray)\n\t\t\t\tgraphics.DrawLine(canvas,18,7,18,12,gray)\n\t\t\t\tgraphics.DrawLine(canvas,19,7,19,12,gray)\n\t\t\t\tgraphics.DrawLine(canvas,20,8,20,12,gray)\n\t\t\t\tgraphics.DrawLine(canvas,21,11,21,12,gray)\n\t\t\t\tgraphics.DrawLine(canvas,22,11,22,12,gray)\n\t\t\t\tgraphics.DrawLine(canvas,10,9,10,9,gray)\n\t\t\t\tgraphics.DrawLine(canvas,15,6,15,6,gray)\n\t\t\t\tgraphics.DrawLine(canvas,23,12,23,12,gray)\n\t\t\t   \n\t\t\t\tif weather[\"weather\"][0][\"main\"] in rain:\n\t\t\t\t\t# Rain Drops\n\t\t\t\t\tgraphics.DrawLine(canvas,9,16,9,17,purple)\n\t\t\t\t\tgraphics.DrawLine(canvas,15,16,15,17,purple)\n\t\t\t\t\tgraphics.DrawLine(canvas,21,16,21,17,purple)\n\t\t\t\t\tgraphics.DrawLine(canvas,12,15,12,16,purple)\n\t\t\t\t\tgraphics.DrawLine(canvas,18,15,18,16,purple)\n\t\t\t\t\n\t\t\t\telif weather[\"weather\"][0][\"main\"] in 'Thunderstorm':\n\t\t\t\t\t# Lightning Bolt\n\t\t\t\t\tgraphics.DrawLine(canvas,13,13,15,13,yellow)\n\t\t\t\t\tgraphics.DrawLine(canvas,14,14,11,17,yellow)\n\t\t\t\t\tgraphics.DrawLine(canvas,12,18,13,19,yellow)\n\t\t\t\t\tgraphics.DrawLine(canvas,12,20,12,20,yellow)\n\t\t\t\t\t\n\t\t\t\telif weather[\"weather\"][0][\"description\"] in 'few clouds':\n\t\t\t\t\t# Small Sun\n\t\t\t\t\tgraphics.DrawLine(canvas,19,4,21,6,orange)\n\t\t\t\t\tgraphics.DrawLine(canvas,20,4,21,5,orange)\n\t\t\t\t\tgraphics.DrawLine(canvas,20,3,22,5,orange)\n\t\t\t\t\tgraphics.DrawLine(canvas,21,3,22,4,orange)\n\t\t\t\t\n\t\t\telif weather[\"weather\"][0][\"main\"] in 'Clear':\n\t\t\t\tif weather[\"weather\"][0][\"icon\"][2] == 'd': #if daytime\n\t\t\t\t\tradius = 3\n\t\t\t\t\tcolor = orange\n\t\t\t\t\t# Diagonal Lines\n\t\t\t\t\tgraphics.DrawLine(canvas, 18, sun_y+11, 20, sun_y+13, orange)\n\t\t\t\t\tgraphics.DrawLine(canvas, 12, sun_y+11, 10, sun_y+13, orange)\n\t\t\t\t\tgraphics.DrawLine(canvas, 12, sun_y+5, 10, sun_y+3, orange)\n\t\t\t\t\tgraphics.DrawLine(canvas, 18, sun_y+5, 20, sun_y+3, orange)\n\t\t\t\t\t# Straight Lines\n\t\t\t\t\tgraphics.DrawLine(canvas, 20, sun_y+8, 21, sun_y+8, orange)\n\t\t\t\t\tgraphics.DrawLine(canvas, 10, sun_y+8, 9, sun_y+8, orange)\n\t\t\t\t\tgraphics.DrawLine(canvas, 15, sun_y+13, 15, sun_y+14, orange)\n\t\t\t\t\tgraphics.DrawLine(canvas, 15, sun_y+3, 15, sun_y+2, orange)\n\t\t\t\telse: #if night\n\t\t\t\t\tcolor = darkGray #Moon Color\n\t\t\t\t\tradius = 5 #Moon Size\n\t\t\t\t\tgraphics.DrawCircle(canvas, 15, sun_y+8, radius-3, color)\n\t\t\t\t\tgraphics.DrawCircle(canvas, 15, sun_y+8, radius-4, color)\n\t\t\t\t\tgraphics.DrawLine(canvas, 13, sun_y+4, 11, sun_y+6, color)\n\t\t\t\t\tgraphics.DrawLine(canvas, 17, sun_y+4, 19, sun_y+6, color)\n\t\t\t\t\tgraphics.DrawLine(canvas, 13, sun_y+12, 11, sun_y+10, color)\n\t\t\t\t\tgraphics.DrawLine(canvas, 17, sun_y+12, 19, sun_y+10, color) \n\t\t\t\t## Sun/Moon Icon\n\t\t\t\t# Circle and Circle Fill\n\t\t\t\tgraphics.DrawCircle(canvas, 15, sun_y+8, radius, color)\n\t\t\t\tgraphics.DrawCircle(canvas, 15, sun_y+8, radius-1, color)\n\t\t\t\tgraphics.DrawCircle(canvas, 15, sun_y+8, radius-2, color)\n\t\t\t\tgraphics.DrawLine(canvas, 16, sun_y+7, 14, sun_y+9, color)\n\t\t\t\tgraphics.DrawLine(canvas, 14, sun_y+7, 16, sun_y+9, color)\n\t\t\t\t\t\t\t\t\n\t\t\telif weather[\"weather\"][0][\"main\"] in 'Snow':\n\t\t\t\t#Snow Flake\n\t\t\t\tgraphics.DrawLine(canvas,16,snow_y+4,16,snow_y+12,cyan)\n\t\t\t\tgraphics.DrawLine(canvas,12,snow_y+8,20,snow_y+8,cyan)\n\t\t\t\tgraphics.DrawLine(canvas,13,snow_y+5,19,snow_y+11,cyan)\n\t\t\t\tgraphics.DrawLine(canvas,13,snow_y+11,19,snow_y+5,cyan)\n\t\t\t\tgraphics.DrawLine(canvas,13,snow_y+4,12,snow_y+5,cyan)\n\t\t\t\tgraphics.DrawLine(canvas,19,snow_y+4,20,snow_y+5,cyan)\n\t\t\t\tgraphics.DrawLine(canvas,12,snow_y+11,13,snow_y+12,cyan)\n\t\t\t\tgraphics.DrawLine(canvas,19,snow_y+12,20,snow_y+11,cyan)\n\n\t\t\t\tgraphics.DrawLine(canvas,15,snow_y+3,15,snow_y+3,cyan)\n\t\t\t\tgraphics.DrawLine(canvas,17,snow_y+3,17,snow_y+3,cyan)\n\t\t\t\t\n\t\t\t\t\n\t\t\t# Update Every 2 Seconds (interval arbitrary)\n\t\t\ttime.sleep(2)\n", "description": null, "category": "graphics", "imports": ["from samplebase import SampleBase", "from rgbmatrix import graphics", "import time", "from requests import get", "import json", "import bme280_v2 as bme", "import BlynkLib", "from subprocess import call"]}], [{"term": "class", "name": "Ui_Dialog", "data": "class Ui_Dialog(object):\n\tdef setupUi(self, Dialog):\n\t\tDialog.setObjectName(\"Dialog\")\n\t\tDialog.resize(1878, 1011)\n\t\tself.pushButton_8 = QtWidgets.QPushButton(Dialog)\n\t\tself.pushButton_8.setGeometry(QtCore.QRect(10, 20, 71, 21))\n\t\tself.pushButton_8.setObjectName(\"pushButton_8\")\n\t\tself.radioButton = QtWidgets.QRadioButton(Dialog)\n\t\tself.radioButton.setGeometry(QtCore.QRect(100, 20, 89, 16))\n\t\tself.radioButton.setObjectName(\"radioButton\")\n\t\tself.radioButton_2 = QtWidgets.QRadioButton(Dialog)\n\t\tself.radioButton_2.setGeometry(QtCore.QRect(200, 20, 89, 16))\n\t\tself.radioButton_2.setObjectName(\"radioButton_2\")\n\t\tself.pushButton_43 = QtWidgets.QPushButton(Dialog)\n\t\tself.pushButton_43.setGeometry(QtCore.QRect(450, 10, 111, 31))\n\t\tself.pushButton_43.setObjectName(\"pushButton_43\")\n\t\tself.pushButton_48 = QtWidgets.QPushButton(Dialog)\n\t\tself.pushButton_48.setGeometry(QtCore.QRect(330, 10, 111, 31))\n\t\tself.pushButton_48.setObjectName(\"pushButton_48\")\n\t\tself.pushButton_49 = QtWidgets.QPushButton(Dialog)\n\t\tself.pushButton_49.setGeometry(QtCore.QRect(570, 10, 111, 31))\n\t\tself.pushButton_49.setObjectName(\"pushButton_49\")\n\t\tself.pushButton_46 = QtWidgets.QPushButton(Dialog)\n\t\tself.pushButton_46.setGeometry(QtCore.QRect(810, 10, 111, 31))\n\t\tself.pushButton_46.setObjectName(\"pushButton_46\")\n\t\tself.pushButton_47 = QtWidgets.QPushButton(Dialog)\n\t\tself.pushButton_47.setGeometry(QtCore.QRect(690, 10, 111, 31))\n\t\tself.pushButton_47.setObjectName(\"pushButton_47\")\n\t\tself.spinBox = QtWidgets.QSpinBox(Dialog)\n\t\tself.spinBox.setGeometry(QtCore.QRect(1060, 20, 61, 21))\n\t\tself.spinBox.setPrefix(\"\")\n\t\tself.spinBox.setMinimum(0)\n\t\tself.spinBox.setMaximum(1)\n\t\tself.spinBox.setSingleStep(10)\n\t\tself.spinBox.setProperty(\"value\", 1)\n\t\tself.spinBox.setObjectName(\"spinBox\")\n\t\tself.pushButton_58 = QtWidgets.QPushButton(Dialog)\n\t\tself.pushButton_58.setGeometry(QtCore.QRect(930, 10, 111, 31))\n\t\tself.pushButton_58.setObjectName(\"pushButton_58\")\n\t\tself.gridLayoutWidget_17 = QtWidgets.QWidget(Dialog)\n\t\tself.gridLayoutWidget_17.setGeometry(QtCore.QRect(0, 60, 1871, 951))\n\t\tself.gridLayoutWidget_17.setObjectName(\"gridLayoutWidget_17\")\n\t\tself.gridLayout_9 = QtWidgets.QGridLayout(self.gridLayoutWidget_17)\n\t\tself.gridLayout_9.setContentsMargins(0, 0, 0, 0)\n\t\tself.gridLayout_9.setObjectName(\"gridLayout_9\")\n\t\tself.graphicsView_26 = PlotWidget(self.gridLayoutWidget_17)\n\t\tself.graphicsView_26.setObjectName(\"graphicsView_26\")\n\t\tself.gridLayout_9.addWidget(self.graphicsView_26, 2, 1, 1, 1)\n\t\tself.graphicsView_25 = PlotWidget(self.gridLayoutWidget_17)\n\t\tself.graphicsView_25.setObjectName(\"graphicsView_25\")\n\t\tself.gridLayout_9.addWidget(self.graphicsView_25, 2, 0, 1, 1)\n\t\tself.graphicsView_27 = PlotWidget(self.gridLayoutWidget_17)\n\t\tself.graphicsView_27.setObjectName(\"graphicsView_27\")\n\t\tself.gridLayout_9.addWidget(self.graphicsView_27, 2, 2, 1, 1)\n\t\tself.graphicsView_14 = PlotWidget(self.gridLayoutWidget_17)\n\t\tself.graphicsView_14.setObjectName(\"graphicsView_14\")\n\t\tself.gridLayout_9.addWidget(self.graphicsView_14, 0, 0, 1, 1)\n\t\tself.graphicsView_15 = PlotWidget(self.gridLayoutWidget_17)\n\t\tself.graphicsView_15.setObjectName(\"graphicsView_15\")\n\t\tself.gridLayout_9.addWidget(self.graphicsView_15, 1, 0, 1, 1)\n\t\tself.graphicsView_24 = PlotWidget(self.gridLayoutWidget_17)\n\t\tself.graphicsView_24.setObjectName(\"graphicsView_24\")\n\t\tself.gridLayout_9.addWidget(self.graphicsView_24, 1, 1, 1, 1)\n\t\tself.graphicsView_23 = PlotWidget(self.gridLayoutWidget_17)\n\t\tself.graphicsView_23.setObjectName(\"graphicsView_23\")\n\t\tself.gridLayout_9.addWidget(self.graphicsView_23, 0, 1, 1, 1)\n\t\tself.graphicsView_20 = PlotWidget(self.gridLayoutWidget_17)\n\t\tself.graphicsView_20.setObjectName(\"graphicsView_20\")\n\t\tself.gridLayout_9.addWidget(self.graphicsView_20, 1, 2, 1, 1)\n\t\tself.graphicsView_19 = PlotWidget(self.gridLayoutWidget_17)\n\t\tself.graphicsView_19.setObjectName(\"graphicsView_19\")\n\t\tself.gridLayout_9.addWidget(self.graphicsView_19, 0, 2, 1, 1)\n\n\t\tself.retranslateUi(Dialog)\n\t\tQtCore.QMetaObject.connectSlotsByName(Dialog)\n\n\tdef retranslateUi(self, Dialog):\n\t\t_translate = QtCore.QCoreApplication.translate\n\t\tDialog.setWindowTitle(_translate(\"Dialog\", \"Dialog\"))\n\t\tself.pushButton_8.setText(_translate(\"Dialog\", \"Mode\u00ef\u00bc\u0161\"))\n\t\tself.radioButton.setText(_translate(\"Dialog\", \"Auto Mode\"))\n\t\tself.radioButton_2.setText(_translate(\"Dialog\", \"Menu Mode\"))\n\t\tself.pushButton_43.setText(_translate(\"Dialog\", \"StopUpdate\"))\n\t\tself.pushButton_48.setText(_translate(\"Dialog\", \"StartUpdate\"))\n\t\tself.pushButton_49.setText(_translate(\"Dialog\", \"ClearUpdate\"))\n\t\tself.pushButton_46.setText(_translate(\"Dialog\", \"Export Figure\"))\n\t\tself.pushButton_47.setText(_translate(\"Dialog\", \"ExportData\"))\n", "description": null, "category": "graphics", "imports": ["from PyQt5 import QtCore, QtGui, QtWidgets", "from pyqtgraph import PlotWidget"]}], [{"term": "def", "name": "main", "data": "def main():\n\tgraphics = BreakoutGraphics()\n\t# Add animation loop here!\n\twhile True:\n\t\tif graphics.life == 0:\n\t\t\tgraphics.window.clear()\n\t\t\tgame_over = GLabel(\"Game Over\")\n\t\t\tgame_over.color = 'red'\n\t\t\tgame_over.font = '-60'\n\t\t\tgraphics.window.add(game_over, x=40, y=graphics.window.height/2)\n\t\t\tbreak\n\t\tif graphics.num_bricks == 0:\n\t\t\tgraphics.window.clear()\n\t\t\tgame_over = GLabel(\"You Win\")\n\t\t\tgame_over.color = 'red'\n\t\t\tgame_over.font = '-60'\n\t\t\tgraphics.window.add(game_over, x=60, y=graphics.window.height / 2)\n\t\tpause(FRAME_RATE)\n\t\tgraphics.ball.move(graphics.move_dx(), graphics.move_dy())\n\t\tgraphics.is_collision()\n\n\t\tif not graphics.ball_x_in_window():\n\t\t\tgraphics.move_dx(-1)\n\t\tif not graphics.ball_y_in_window():\n\t\t\tgraphics.move_dy(-1)\n\t\tgraphics.is_die()\n\n\n\n\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.graphics.gobjects import GOval, GRect, GLabel"]}], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis widget is an easy starting point for generating multi-panel figures.\n\tExample::\n\t\n\t\tw = pg.GraphicsLayoutWidget()\n\t\tp1 = w.addPlot(row=0, col=0)\n\t\tp2 = w.addPlot(row=0, col=1)\n\t\tv = w.addViewBox(row=1, col=0, colspan=2)\n\t\n\t=========  =================================================================\n\tparent\t (QWidget or None) The parent widget.\n\tshow\t   (bool) If True, then immediately show the widget after it is\n\t\t\t   created. If the widget has no parent, then it will be shown\n\t\t\t   inside a new window.\n\tsize\t   (width, height) tuple. Optionally resize the widget. Note: if\n\t\t\t   this widget is placed inside a layout, then this argument has no\n\t\t\t   effect.\n\ttitle\t  (str or None) If specified, then set the window title for this\n\t\t\t   widget.\n\tkargs\t  All extra arguments are passed to\n\t\t\t   :meth:`GraphicsLayout.__init__\n\t\t\t   `\n\t=========  =================================================================\n\t\t\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, show=False, size=None, title=None, **kargs):\n\t\tmkQApp()\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n\t\t\n\t\tif size is not None:\n\t\t\tself.resize(*size)\n\t\t\t\n\t\tif title is not None:\n\t\t\tself.setWindowTitle(title)\n\t\t\t\n\t\tif show is True:\n\t\t\tself.show()\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis widget is an easy starting point for generating multi-panel figures.\n\tExample::\n\t\n\t\tw = pg.GraphicsLayoutWidget()\n\t\tp1 = w.addPlot(row=0, col=0)\n\t\tp2 = w.addPlot(row=0, col=1)\n\t\tv = w.addViewBox(row=1, col=0, colspan=2)\n\t\n\t=========  =================================================================\n\tparent\t (QWidget or None) The parent widget.\n\tshow\t   (bool) If True, then immediately show the widget after it is\n\t\t\t   created. If the widget has no parent, then it will be shown\n\t\t\t   inside a new window.\n\tsize\t   (width, height) tuple. Optionally resize the widget. Note: if\n\t\t\t   this widget is placed inside a layout, then this argument has no\n\t\t\t   effect.\n\ttitle\t  (str or None) If specified, then set the window title for this\n\t\t\t   widget.\n\tkargs\t  All extra arguments are passed to\n\t\t\t   :meth:`GraphicsLayout.__init__\n\t\t\t   `\n\t=========  =================================================================\n\t\t\n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui, mkQApp", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [{"term": "def", "name": "main", "data": "def main():\n\t\"\"\"\n\tI use a class named BreakoutGraphics to construct this game.\n\tGame-ending conditions: player breaks all the bricks or player leaves zero live.\n\t\"\"\"\n\n\tgraphics = BreakoutGraphics()\n\n\t# Add animation loop here!\n\tdx = 0\n\tdy = 0\n\tlives = graphics.get_lives()\n\n\twhile True:\n\t\tif dy == 0 and graphics.game_has_started():\n\t\t\tgraphics.set_ball()\n\t\t\tdx = graphics.get_dx()\n\t\t\tdy = graphics.get_dy()\n\t\tpause(FRAME_RATE)\n\t\tgraphics.ball.move(dx, dy)\n\t\tif graphics.ball.x <= 0 or graphics.ball.x >= graphics.window.width-graphics.ball.width:\n\t\t\tdx = -dx\n\t\tif graphics.ball.y <= 0:\n\t\t\tdy = -dy\n\t\tif graphics.ball.y >= graphics.window.height-graphics.ball.height:\n\t\t\tlives -= 1\n\t\t\tgraphics.lives_label.text = \"Lives :\" + str(lives)\n\t\t\tif lives > 0:\n\t\t\t\tdx = 0\n\t\t\t\tdy = 0\n\t\t\t\tgraphics.reset_ball()\n\t\t\telse:\n\t\t\t\tgraphics.lose_game()\n\t\t\t\tbreak\n\t\tif graphics.collide():\n\t\t\tif graphics.is_paddle() and dy > 0:\n\t\t\t\tdy = -dy\n\t\t\telif not graphics.is_paddle():\n\t\t\t\tdy = -dy\n\t\t\t\tgraphics.brick_out()\n\t\tif graphics.win():\n\t\t\tgraphics.win_game()\n\t\t\tbreak\n\n", "description": "\n\tI use a class named BreakoutGraphics to construct this game.\n\tGame-ending conditions: player breaks all the bricks or player leaves zero live.\n\t", "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics_extension import BreakoutGraphics", "from campy.graphics.gobjects import GLabel"]}], [{"term": "class", "name": "BiosVfIntegratedGraphicsConsts", "data": "class BiosVfIntegratedGraphicsConsts():\n\tSUPPORTED_BY_DEFAULT_NO = \"no\"\n\tSUPPORTED_BY_DEFAULT_YES = \"yes\"\n\tVP_INTEGRATED_GRAPHICS_DISABLED = \"disabled\"\n\tVP_INTEGRATED_GRAPHICS_ENABLED = \"enabled\"\n\tVP_INTEGRATED_GRAPHICS_PLATFORM_DEFAULT = \"platform-default\"\n\tVP_INTEGRATED_GRAPHICS_PLATFORM_RECOMMENDED = \"platform-recommended\"\n\n", "description": null, "category": "graphics", "imports": ["import sys, os", "from ...ucsmo import ManagedObject", "from ...ucscoremeta import UcsVersion, MoPropertyMeta, MoMeta", "from ...ucsmeta import VersionMeta"]}, {"term": "class", "name": "BiosVfIntegratedGraphics", "data": "class BiosVfIntegratedGraphics(ManagedObject):\n\t\"\"\"This is BiosVfIntegratedGraphics class.\"\"\"\n\n\tconsts = BiosVfIntegratedGraphicsConsts()\n\tnaming_props = set([])\n\n\tmo_meta = MoMeta(\"BiosVfIntegratedGraphics\", \"biosVfIntegratedGraphics\", \"Integrated-Graphics\", VersionMeta.Version311e, \"InputOutput\", 0x3f, [], [\"admin\", \"ls-compute\", \"ls-config\", \"ls-server\", \"ls-server-policy\", \"pn-policy\"], [u'biosSettings', u'biosVProfile'], [], [None])\n\n\tprop_meta = {\n\t\t\"child_action\": MoPropertyMeta(\"child_action\", \"childAction\", \"string\", VersionMeta.Version311e, MoPropertyMeta.INTERNAL, 0x2, None, None, r\"\"\"((deleteAll|ignore|deleteNonPresent),){0,2}(deleteAll|ignore|deleteNonPresent){0,1}\"\"\", [], []), \n\t\t\"dn\": MoPropertyMeta(\"dn\", \"dn\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_ONLY, 0x4, 0, 256, None, [], []), \n\t\t\"prop_acl\": MoPropertyMeta(\"prop_acl\", \"propAcl\", \"ulong\", VersionMeta.Version311e, MoPropertyMeta.READ_ONLY, None, None, None, None, [], []), \n\t\t\"rn\": MoPropertyMeta(\"rn\", \"rn\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_ONLY, 0x8, 0, 256, None, [], []), \n\t\t\"sacl\": MoPropertyMeta(\"sacl\", \"sacl\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_ONLY, None, None, None, r\"\"\"((none|del|mod|addchild|cascade),){0,4}(none|del|mod|addchild|cascade){0,1}\"\"\", [], []), \n\t\t\"status\": MoPropertyMeta(\"status\", \"status\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_WRITE, 0x10, None, None, r\"\"\"((removed|created|modified|deleted),){0,3}(removed|created|modified|deleted){0,1}\"\"\", [], []), \n\t\t\"supported_by_default\": MoPropertyMeta(\"supported_by_default\", \"supportedByDefault\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_ONLY, None, None, None, None, [\"no\", \"yes\"], []), \n\t\t\"vp_integrated_graphics\": MoPropertyMeta(\"vp_integrated_graphics\", \"vpIntegratedGraphics\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_WRITE, 0x20, None, None, None, [\"disabled\", \"enabled\", \"platform-default\", \"platform-recommended\"], []), \n\t}\n\n\tprop_map = {\n\t\t\"childAction\": \"child_action\", \n\t\t\"dn\": \"dn\", \n\t\t\"propAcl\": \"prop_acl\", \n\t\t\"rn\": \"rn\", \n\t\t\"sacl\": \"sacl\", \n\t\t\"status\": \"status\", \n\t\t\"supportedByDefault\": \"supported_by_default\", \n\t\t\"vpIntegratedGraphics\": \"vp_integrated_graphics\", \n\t}\n\n\tdef __init__(self, parent_mo_or_dn, **kwargs):\n\t\tself._dirty_mask = 0\n\t\tself.child_action = None\n\t\tself.prop_acl = None\n\t\tself.sacl = None\n\t\tself.status = None\n\t\tself.supported_by_default = None\n\t\tself.vp_integrated_graphics = None\n\n\t\tManagedObject.__init__(self, \"BiosVfIntegratedGraphics\", parent_mo_or_dn, **kwargs)\n\n", "description": "This is BiosVfIntegratedGraphics class.", "category": "graphics", "imports": ["import sys, os", "from ...ucsmo import ManagedObject", "from ...ucscoremeta import UcsVersion, MoPropertyMeta, MoMeta", "from ...ucsmeta import VersionMeta"]}], [{"term": "class", "name": "BiosVfOnboardGraphicsConsts", "data": "class BiosVfOnboardGraphicsConsts():\n\tSUPPORTED_BY_DEFAULT_NO = \"no\"\n\tSUPPORTED_BY_DEFAULT_YES = \"yes\"\n\tVP_ONBOARD_GRAPHICS_DISABLED = \"disabled\"\n\tVP_ONBOARD_GRAPHICS_ENABLED = \"enabled\"\n\tVP_ONBOARD_GRAPHICS_PLATFORM_DEFAULT = \"platform-default\"\n\tVP_ONBOARD_GRAPHICS_PLATFORM_RECOMMENDED = \"platform-recommended\"\n\n", "description": null, "category": "graphics", "imports": ["import sys, os", "from ...ucsmo import ManagedObject", "from ...ucscoremeta import UcsVersion, MoPropertyMeta, MoMeta", "from ...ucsmeta import VersionMeta"]}, {"term": "class", "name": "BiosVfOnboardGraphics", "data": "class BiosVfOnboardGraphics(ManagedObject):\n\t\"\"\"This is BiosVfOnboardGraphics class.\"\"\"\n\n\tconsts = BiosVfOnboardGraphicsConsts()\n\tnaming_props = set([])\n\n\tmo_meta = MoMeta(\"BiosVfOnboardGraphics\", \"biosVfOnboardGraphics\", \"Onboard-Graphics\", VersionMeta.Version311e, \"InputOutput\", 0x3f, [], [\"admin\", \"ls-compute\", \"ls-config\", \"ls-server\", \"ls-server-policy\", \"pn-policy\"], [u'biosSettings', u'biosVProfile'], [], [None])\n\n\tprop_meta = {\n\t\t\"child_action\": MoPropertyMeta(\"child_action\", \"childAction\", \"string\", VersionMeta.Version311e, MoPropertyMeta.INTERNAL, 0x2, None, None, r\"\"\"((deleteAll|ignore|deleteNonPresent),){0,2}(deleteAll|ignore|deleteNonPresent){0,1}\"\"\", [], []), \n\t\t\"dn\": MoPropertyMeta(\"dn\", \"dn\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_ONLY, 0x4, 0, 256, None, [], []), \n\t\t\"prop_acl\": MoPropertyMeta(\"prop_acl\", \"propAcl\", \"ulong\", VersionMeta.Version311e, MoPropertyMeta.READ_ONLY, None, None, None, None, [], []), \n\t\t\"rn\": MoPropertyMeta(\"rn\", \"rn\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_ONLY, 0x8, 0, 256, None, [], []), \n\t\t\"sacl\": MoPropertyMeta(\"sacl\", \"sacl\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_ONLY, None, None, None, r\"\"\"((none|del|mod|addchild|cascade),){0,4}(none|del|mod|addchild|cascade){0,1}\"\"\", [], []), \n\t\t\"status\": MoPropertyMeta(\"status\", \"status\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_WRITE, 0x10, None, None, r\"\"\"((removed|created|modified|deleted),){0,3}(removed|created|modified|deleted){0,1}\"\"\", [], []), \n\t\t\"supported_by_default\": MoPropertyMeta(\"supported_by_default\", \"supportedByDefault\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_ONLY, None, None, None, None, [\"no\", \"yes\"], []), \n\t\t\"vp_onboard_graphics\": MoPropertyMeta(\"vp_onboard_graphics\", \"vpOnboardGraphics\", \"string\", VersionMeta.Version311e, MoPropertyMeta.READ_WRITE, 0x20, None, None, None, [\"disabled\", \"enabled\", \"platform-default\", \"platform-recommended\"], []), \n\t}\n\n\tprop_map = {\n\t\t\"childAction\": \"child_action\", \n\t\t\"dn\": \"dn\", \n\t\t\"propAcl\": \"prop_acl\", \n\t\t\"rn\": \"rn\", \n\t\t\"sacl\": \"sacl\", \n\t\t\"status\": \"status\", \n\t\t\"supportedByDefault\": \"supported_by_default\", \n\t\t\"vpOnboardGraphics\": \"vp_onboard_graphics\", \n\t}\n\n\tdef __init__(self, parent_mo_or_dn, **kwargs):\n\t\tself._dirty_mask = 0\n\t\tself.child_action = None\n\t\tself.prop_acl = None\n\t\tself.sacl = None\n\t\tself.status = None\n\t\tself.supported_by_default = None\n\t\tself.vp_onboard_graphics = None\n\n\t\tManagedObject.__init__(self, \"BiosVfOnboardGraphics\", parent_mo_or_dn, **kwargs)\n\n", "description": "This is BiosVfOnboardGraphics class.", "category": "graphics", "imports": ["import sys, os", "from ...ucsmo import ManagedObject", "from ...ucscoremeta import UcsVersion, MoPropertyMeta, MoMeta", "from ...ucsmeta import VersionMeta"]}], [{"term": "class", "name": "_CarEvent", "data": "class _CarEvent(AgentEvent, ABC):\n\tdef _animate_car(self,\n\t\t\t\t\t *,\n\t\t\t\t\t graphics_context: GraphicsContext,\n\t\t\t\t\t start_position: Vector,\n\t\t\t\t\t car_orientation: Orientation,\n\t\t\t\t\t move_direction: Orientation) -> Animation[Primitive]:\n\t\tdef generate_frame(t: float) -> Primitive:\n\t\t\tmoved_rect = rect.move(dx * t, dy * t)\n\t\t\treturn create_car(layer, color, moved_rect).transform(Vector2(0, 0), car_orientation.angle)\n\n\t\tlayer = graphics_context.object_layer\n\t\tcolor = Color(255, 0, 0)\n\t\trect = graphics_context.tile_rectangle(start_position)\n\t\twidth = rect.width\n\t\theight = rect.height\n\t\tdx, dy = Vector.from_orientation(move_direction)\n\t\tdx *= width\n\t\tdy *= height\n\t\treturn LinearAnimation(0, 1, 1).map(lambda delta: generate_frame(delta))\n\n", "description": null, "category": "graphics", "imports": ["from __future__ import annotations", "from abc import ABC, abstractmethod", "from typing import Any, Tuple, Optional", "from pygame import Color, Vector2", "from pysim.data import Vector", "from pysim.data.angle import Angle", "from pysim.data.orientation import Orientation", "from pysim.graphics.animations.animation import Animation", "from pysim.graphics.animations.constant import ConstantAnimation", "from pysim.graphics.animations.linear import LinearAnimation", "from pysim.graphics.context import GraphicsContext", "from pysim.graphics.primitives.car import create_car", "from pysim.graphics.primitives.primitive import Primitive", "from pysim.simulation.agent import AgentEvent", "from pysim.simulation.entity import EntityId", "from pysim.simulation.world import Agent"]}, {"term": "class", "name": "_MoveEvent", "data": "class _MoveEvent(_CarEvent, ABC):\n\t_origin: Vector\n\t_direction: Orientation\n\n\tdef __init__(self, agent_id: EntityId, origin: Vector, direction: Orientation):\n\t\tsuper().__init__(agent_id)\n\t\tself._origin = origin\n\t\tself._direction = direction\n\n", "description": null, "category": "graphics", "imports": ["from __future__ import annotations", "from abc import ABC, abstractmethod", "from typing import Any, Tuple, Optional", "from pygame import Color, Vector2", "from pysim.data import Vector", "from pysim.data.angle import Angle", "from pysim.data.orientation import Orientation", "from pysim.graphics.animations.animation import Animation", "from pysim.graphics.animations.constant import ConstantAnimation", "from pysim.graphics.animations.linear import LinearAnimation", "from pysim.graphics.context import GraphicsContext", "from pysim.graphics.primitives.car import create_car", "from pysim.graphics.primitives.primitive import Primitive", "from pysim.simulation.agent import AgentEvent", "from pysim.simulation.entity import EntityId", "from pysim.simulation.world import Agent"]}, {"term": "class", "name": "_ForwardEvent", "data": "class _ForwardEvent(_MoveEvent):\n\tdef _render_singleton_entity(self, graphics_context: GraphicsContext) -> Animation[Primitive]:\n\t\treturn self._animate_car(\n\t\t\tgraphics_context=graphics_context,\n\t\t\tstart_position=self._origin,\n\t\t\tcar_orientation=self._direction,\n\t\t\tmove_direction=self._direction\n\t\t)\n\n", "description": null, "category": "graphics", "imports": ["from __future__ import annotations", "from abc import ABC, abstractmethod", "from typing import Any, Tuple, Optional", "from pygame import Color, Vector2", "from pysim.data import Vector", "from pysim.data.angle import Angle", "from pysim.data.orientation import Orientation", "from pysim.graphics.animations.animation import Animation", "from pysim.graphics.animations.constant import ConstantAnimation", "from pysim.graphics.animations.linear import LinearAnimation", "from pysim.graphics.context import GraphicsContext", "from pysim.graphics.primitives.car import create_car", "from pysim.graphics.primitives.primitive import Primitive", "from pysim.simulation.agent import AgentEvent", "from pysim.simulation.entity import EntityId", "from pysim.simulation.world import Agent"]}, {"term": "class", "name": "_BackwardEvent", "data": "class _BackwardEvent(_MoveEvent):\n\tdef _render_singleton_entity(self, graphics_context: GraphicsContext) -> Animation[Primitive]:\n\t\treturn self._animate_car(\n\t\t\tgraphics_context=graphics_context,\n\t\t\tstart_position=self._origin,\n\t\t\tcar_orientation=self._direction,\n\t\t\tmove_direction=self._direction.turn_around()\n\t\t)\n\n", "description": null, "category": "graphics", "imports": ["from __future__ import annotations", "from abc import ABC, abstractmethod", "from typing import Any, Tuple, Optional", "from pygame import Color, Vector2", "from pysim.data import Vector", "from pysim.data.angle import Angle", "from pysim.data.orientation import Orientation", "from pysim.graphics.animations.animation import Animation", "from pysim.graphics.animations.constant import ConstantAnimation", "from pysim.graphics.animations.linear import LinearAnimation", "from pysim.graphics.context import GraphicsContext", "from pysim.graphics.primitives.car import create_car", "from pysim.graphics.primitives.primitive import Primitive", "from pysim.simulation.agent import AgentEvent", "from pysim.simulation.entity import EntityId", "from pysim.simulation.world import Agent"]}, {"term": "class", "name": "_TurnEvent", "data": "class _TurnEvent(_CarEvent, ABC):\n\t_origin: Vector\n\t_direction: Orientation\n\n\tdef __init__(self, agent_id: EntityId, origin: Vector, direction: Orientation):\n\t\tsuper().__init__(agent_id)\n\t\tself._origin = origin\n\t\tself._direction = direction\n\n\tdef _render_singleton_entity(self, graphics_context: GraphicsContext) -> Animation[Primitive]:\n\t\tdef generate_frame(angle: Angle) -> Primitive:\n\t\t\treturn create_car(layer, color, rect).transform(Vector2(0, 0), angle)\n\n\t\tlayer = graphics_context.object_layer\n\t\tcolor = Color(255, 0, 0)\n\t\trect = graphics_context.tile_rectangle(self._origin)\n\t\tstart_angle, end_angle = self.angle_animation_interval\n\t\treturn LinearAnimation(start_angle, end_angle, 1).map(generate_frame)\n\n\t@property\n\t@abstractmethod\n\tdef angle_animation_interval(self) -> Tuple[Angle, Angle]:\n\t\t...\n\n", "description": null, "category": "graphics", "imports": ["from __future__ import annotations", "from abc import ABC, abstractmethod", "from typing import Any, Tuple, Optional", "from pygame import Color, Vector2", "from pysim.data import Vector", "from pysim.data.angle import Angle", "from pysim.data.orientation import Orientation", "from pysim.graphics.animations.animation import Animation", "from pysim.graphics.animations.constant import ConstantAnimation", "from pysim.graphics.animations.linear import LinearAnimation", "from pysim.graphics.context import GraphicsContext", "from pysim.graphics.primitives.car import create_car", "from pysim.graphics.primitives.primitive import Primitive", "from pysim.simulation.agent import AgentEvent", "from pysim.simulation.entity import EntityId", "from pysim.simulation.world import Agent"]}, {"term": "class", "name": "_TurnRightEvent", "data": "class _TurnRightEvent(_TurnEvent):\n\t@property\n\tdef angle_animation_interval(self) -> Tuple[Angle, Angle]:\n\t\tstart = self._direction.angle\n\t\tend = start.turn_right()\n\t\treturn start, end\n\n", "description": null, "category": "graphics", "imports": ["from __future__ import annotations", "from abc import ABC, abstractmethod", "from typing import Any, Tuple, Optional", "from pygame import Color, Vector2", "from pysim.data import Vector", "from pysim.data.angle import Angle", "from pysim.data.orientation import Orientation", "from pysim.graphics.animations.animation import Animation", "from pysim.graphics.animations.constant import ConstantAnimation", "from pysim.graphics.animations.linear import LinearAnimation", "from pysim.graphics.context import GraphicsContext", "from pysim.graphics.primitives.car import create_car", "from pysim.graphics.primitives.primitive import Primitive", "from pysim.simulation.agent import AgentEvent", "from pysim.simulation.entity import EntityId", "from pysim.simulation.world import Agent"]}, {"term": "class", "name": "_TurnLeftEvent", "data": "class _TurnLeftEvent(_TurnEvent):\n\t@property\n\tdef angle_animation_interval(self) -> Tuple[Angle, Angle]:\n\t\tstart = self._direction.angle\n\t\tend = start.turn_left()\n\t\treturn start, end\n\n", "description": null, "category": "graphics", "imports": ["from __future__ import annotations", "from abc import ABC, abstractmethod", "from typing import Any, Tuple, Optional", "from pygame import Color, Vector2", "from pysim.data import Vector", "from pysim.data.angle import Angle", "from pysim.data.orientation import Orientation", "from pysim.graphics.animations.animation import Animation", "from pysim.graphics.animations.constant import ConstantAnimation", "from pysim.graphics.animations.linear import LinearAnimation", "from pysim.graphics.context import GraphicsContext", "from pysim.graphics.primitives.car import create_car", "from pysim.graphics.primitives.primitive import Primitive", "from pysim.simulation.agent import AgentEvent", "from pysim.simulation.entity import EntityId", "from pysim.simulation.world import Agent"]}, {"term": "class", "name": "_MovedEvent", "data": "class _MovedEvent(_CarEvent):\n\t__origin: Vector\n\t__move_direction: Orientation\n\n\tdef __init__(self, agent_id: EntityId, origin: Vector, car_orientation: Orientation, move_direction: Orientation):\n\t\tsuper().__init__(agent_id)\n\t\tself.__origin = origin\n\t\tself.__car_orientation = car_orientation\n\t\tself.__move_direction = move_direction\n\n\tdef _render_singleton_entity(self, graphics_context: GraphicsContext) -> Animation[Primitive]:\n\t\treturn self._animate_car(\n\t\t\tgraphics_context=graphics_context,\n\t\t\tstart_position=self.__origin,\n\t\t\tcar_orientation=self.__car_orientation,\n\t\t\tmove_direction=self.__move_direction\n\t\t)\n\n", "description": null, "category": "graphics", "imports": ["from __future__ import annotations", "from abc import ABC, abstractmethod", "from typing import Any, Tuple, Optional", "from pygame import Color, Vector2", "from pysim.data import Vector", "from pysim.data.angle import Angle", "from pysim.data.orientation import Orientation", "from pysim.graphics.animations.animation import Animation", "from pysim.graphics.animations.constant import ConstantAnimation", "from pysim.graphics.animations.linear import LinearAnimation", "from pysim.graphics.context import GraphicsContext", "from pysim.graphics.primitives.car import create_car", "from pysim.graphics.primitives.primitive import Primitive", "from pysim.simulation.agent import AgentEvent", "from pysim.simulation.entity import EntityId", "from pysim.simulation.world import Agent"]}, {"term": "class", "name": "CarAgent", "data": "class CarAgent(Agent):\n\tdef __init__(self, *, orientation: Orientation, identity: Optional[EntityId] = None):\n\t\tsuper().__init__(identity=identity or EntityId(), orientation=orientation)\n\n\tdef forward(self, position: Vector) -> AgentEvent:\n\t\treturn _ForwardEvent(self.identity, position, self.orientation)\n\n\tdef backward(self, position: Vector) -> AgentEvent:\n\t\treturn _BackwardEvent(self.identity, position, self.orientation)\n\n\tdef turn_left(self, position: Vector) -> AgentEvent:\n\t\tevent = _TurnLeftEvent(self.identity, position, self.orientation)\n\t\tself._orientation = self._orientation.turn_left()\n\t\treturn event\n\n\tdef turn_right(self, position: Vector) -> AgentEvent:\n\t\tevent = _TurnRightEvent(self.identity, position, self.orientation)\n\t\tself._orientation = self._orientation.turn_right()\n\t\treturn event\n\n\tdef is_movable(self) -> bool:\n\t\treturn True\n\n\tdef move(self, position: Vector, direction: Orientation) -> AgentEvent:\n\t\treturn _MovedEvent(self.identity, position, self._orientation, direction)\n\n\tdef render_idle(self, graphics_context: GraphicsContext, position: Vector) -> Animation[Primitive]:\n\t\tlayer = graphics_context.object_layer\n\t\tcolor = Color(255, 0, 0)\n\t\trect = graphics_context.tile_rectangle(position)\n\t\tprimitive = create_car(layer, color, rect).transform(Vector2(0, 0), self.orientation.angle)\n\t\treturn ConstantAnimation(primitive, 1)\n\n\tdef __eq__(self, other: Any) -> bool:\n\t\treturn isinstance(other, Agent) and self.identity == other.identity and self.orientation is other.orientation\n\n\tdef __copy__(self) -> Agent:\n\t\treturn CarAgent(identity=self.identity, orientation=self.orientation)\n\n\tdef __deepcopy__(self, memo: Any) -> Agent:\n\t\treturn self.__copy__()\n\n\tdef __str__(self) -> str:\n\t\treturn f\"Agent(id={self.identity}, orientation={self.orientation})\"\n", "description": null, "category": "graphics", "imports": ["from __future__ import annotations", "from abc import ABC, abstractmethod", "from typing import Any, Tuple, Optional", "from pygame import Color, Vector2", "from pysim.data import Vector", "from pysim.data.angle import Angle", "from pysim.data.orientation import Orientation", "from pysim.graphics.animations.animation import Animation", "from pysim.graphics.animations.constant import ConstantAnimation", "from pysim.graphics.animations.linear import LinearAnimation", "from pysim.graphics.context import GraphicsContext", "from pysim.graphics.primitives.car import create_car", "from pysim.graphics.primitives.primitive import Primitive", "from pysim.simulation.agent import AgentEvent", "from pysim.simulation.entity import EntityId", "from pysim.simulation.world import Agent"]}], [], [{"term": "def", "name": "setConfigOption", "data": "def setConfigOption(opt, value):\n\tif opt not in CONFIG_OPTIONS:\n\t\traise KeyError('Unknown configuration option \"%s\"' % opt)\n\tif opt == 'imageAxisOrder' and value not in ('row-major', 'col-major'):\n\t\traise ValueError('imageAxisOrder must be either \"row-major\" or \"col-major\"')\n\tCONFIG_OPTIONS[opt] = value\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "setConfigOptions", "data": "def setConfigOptions(**opts):\n\t\"\"\"Set global configuration options. \n\t\n\tEach keyword argument sets one global option. \n\t\"\"\"\n\tfor k,v in opts.items():\n\t\tsetConfigOption(k, v)\n", "description": "Set global configuration options. \n\t\n\tEach keyword argument sets one global option. \n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "getConfigOption", "data": "def getConfigOption(opt):\n\t\"\"\"Return the value of a single global configuration option.\n\t\"\"\"\n\treturn CONFIG_OPTIONS[opt]\n\n", "description": "Return the value of a single global configuration option.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "systemInfo", "data": "def systemInfo():\n\tprint(\"sys.platform: %s\" % sys.platform)\n\tprint(\"sys.version: %s\" % sys.version)\n\tfrom .Qt import VERSION_INFO\n\tprint(\"qt bindings: %s\" % VERSION_INFO)\n\t\n\tglobal __version__\n\trev = None\n\tif __version__ is None:  ## this code was probably checked out from bzr; look up the last-revision file\n\t\tlastRevFile = os.path.join(os.path.dirname(__file__), '..', '.bzr', 'branch', 'last-revision')\n\t\tif os.path.exists(lastRevFile):\n\t\t\twith open(lastRevFile, 'r') as fd:\n\t\t\t\trev = fd.read().strip()\n\t\n\tprint(\"pyqtgraph: %s; %s\" % (__version__, rev))\n\tprint(\"config:\")\n\timport pprint\n\tpprint.pprint(CONFIG_OPTIONS)\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "renamePyc", "data": "def renamePyc(startDir):\n\t### Used to rename orphaned .pyc files\n\t### When a python file changes its location in the repository, usually the .pyc file\n\t### is left behind, possibly causing mysterious and difficult to track bugs. \n\n\t### Note that this is no longer necessary for python 3.2; from PEP 3147:\n\t### \"If the py source file is missing, the pyc file inside __pycache__ will be ignored. \n\t### This eliminates the problem of accidental stale pyc file imports.\"\n\t\n\tprinted = False\n\tstartDir = os.path.abspath(startDir)\n\tfor path, dirs, files in os.walk(startDir):\n\t\tif '__pycache__' in path:\n\t\t\tcontinue\n\t\tfor f in files:\n\t\t\tfileName = os.path.join(path, f)\n\t\t\tbase, ext = os.path.splitext(fileName)\n\t\t\tpy = base + \".py\"\n\t\t\tif ext == '.pyc' and not os.path.isfile(py):\n\t\t\t\tif not printed:\n\t\t\t\t\tprint(\"NOTE: Renaming orphaned .pyc files:\")\n\t\t\t\t\tprinted = True\n\t\t\t\tn = 1\n\t\t\t\twhile True:\n\t\t\t\t\tname2 = fileName + \".renamed%d\" % n\n\t\t\t\t\tif not os.path.exists(name2):\n\t\t\t\t\t\tbreak\n\t\t\t\t\tn += 1\n\t\t\t\tprint(\"  \" + fileName + \"  ==>\")\n\t\t\t\tprint(\"  \" + name2)\n\t\t\t\tos.rename(fileName, name2)\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "fimportModules", "data": "#def importModules(path, globals, locals, excludes=()):\n\t#\"\"\"Import all modules residing within *path*, return a dict of name: module pairs.\n\t\n\t#Note that *path* MUST be relative to the module doing the import.\t\n\t#\"\"\"\n\t#d = os.path.join(os.path.split(globals['__file__'])[0], path)\n\t#files = set()\n\t#for f in frozenSupport.listdir(d):\n\t\t#if frozenSupport.isdir(os.path.join(d, f)) and f not in ['__pycache__', 'tests']:\n\t\t\t#files.add(f)\n\t\t#elif f[-3:] == '.py' and f != '__init__.py':\n\t\t\t#files.add(f[:-3])\n\t\t#elif f[-4:] == '.pyc' and f != '__init__.pyc':\n\t\t\t#files.add(f[:-4])\n\t\t\n\t#mods = {}\n\t#path = path.replace(os.sep, '.')\n\t#for modName in files:\n\t\t#if modName in excludes:\n\t\t\t#continue\n\t\t#try:\n\t\t\t#if len(path) > 0:\n\t\t\t\t#modName = path + '.' + modName\n\t\t\t#print( \"from .%s import * \" % modName)\n\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)\n\t\t\t#mods[modName] = mod\n\t\t#except:\n\t\t\t#import traceback\n\t\t\t#traceback.print_stack()\n\t\t\t#sys.excepthook(*sys.exc_info())\n\t\t\t#print(\"[Error importing module: %s]\" % modName)\n\t\t\t\n\t#return mods\n", "description": "Import all modules residing within *path*, return a dict of name: module pairs.\n\t\n\t#Note that *path* MUST be relative to the module doing the import.\t\n\t#", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "fimportAll", "data": "#def importAll(path, globals, locals, excludes=()):\n\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"\n\t#mods = importModules(path, globals, locals, excludes)\n\t#for mod in mods.values():\n\t\t#if hasattr(mod, '__all__'):\n\t\t\t#names = mod.__all__\n\t\t#else:\n\t\t\t#names = [n for n in dir(mod) if n[0] != '_']\n\t\t#for k in names:\n\t\t\t#if hasattr(mod, k):\n\t\t\t\t#globals[k] = getattr(mod, k)\n", "description": "Given a list of modules, import all names from each module into the global namespace.", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "cleanup", "data": "def cleanup():\n\tglobal _cleanupCalled\n\tif _cleanupCalled:\n\t\treturn\n\t\n\tif not getConfigOption('exitCleanup'):\n\t\treturn\n\t\n\tViewBox.quit()  ## tell ViewBox that it doesn't need to deregister views anymore.\n\t\n\t## Workaround for Qt exit crash:\n\t## ALL QGraphicsItems must have a scene before they are deleted.\n\t## This is potentially very expensive, but preferred over crashing.\n\t## Note: this appears to be fixed in PySide as of 2012.12, but it should be left in for a while longer..\n\tapp = QtGui.QApplication.instance()\n\tif app is None or not isinstance(app, QtGui.QApplication):\n\t\t# app was never constructed is already deleted or is an\n\t\t# QCoreApplication/QGuiApplication and not a full QApplication\n\t\treturn\n\timport gc\n\ts = QtGui.QGraphicsScene()\n\tfor o in gc.get_objects():\n\t\ttry:\n\t\t\tif isinstance(o, QtGui.QGraphicsItem) and isQObjectAlive(o) and o.scene() is None:\n\t\t\t\tif getConfigOption('crashWarning'):\n\t\t\t\t\tsys.stderr.write('Error: graphics item without scene. '\n\t\t\t\t\t\t'Make sure ViewBox.close() and GraphicsView.close() '\n\t\t\t\t\t\t'are properly called before app shutdown (%s)\\n' % (o,))\n\t\t\t\t\n\t\t\t\ts.addItem(o)\n\t\texcept (RuntimeError, ReferenceError):  ## occurs if a python wrapper no longer has its underlying C++ object\n\t\t\tcontinue\n\t_cleanupCalled = True\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "_connectCleanup", "data": "def _connectCleanup():\n\tglobal _cleanupConnected\n\tif _cleanupConnected:\n\t\treturn\n\tQtGui.QApplication.instance().aboutToQuit.connect(cleanup)\n\t_cleanupConnected = True\n\n", "description": null, "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "exit", "data": "def exit():\n\t\"\"\"\n\tCauses python to exit without garbage-collecting any objects, and thus avoids\n\tcalling object destructor methods. This is a sledgehammer workaround for \n\ta variety of bugs in PyQt and Pyside that cause crashes on exit.\n\t\n\tThis function does the following in an attempt to 'safely' terminate\n\tthe process:\n\t\n\t  * Invoke atexit callbacks\n\t  * Close all open file handles\n\t  * os._exit()\n\t\n\tNote: there is some potential for causing damage with this function if you\n\tare using objects that _require_ their destructors to be called (for example,\n\tto properly terminate log files, disconnect from devices, etc). Situations\n\tlike this are probably quite rare, but use at your own risk.\n\t\"\"\"\n\t\n\t## first disable our own cleanup function; won't be needing it.\n\tsetConfigOptions(exitCleanup=False)\n\t\n\t## invoke atexit callbacks\n\tatexit._run_exitfuncs()\n\t\n\t## close file handles\n\tif sys.platform == 'darwin':\n\t\tfor fd in range(3, 4096):\n\t\t\tif fd in [7]:  # trying to close 7 produces an illegal instruction on the Mac.\n\t\t\t\tcontinue\n\t\t\ttry:\n\t\t\t\tos.close(fd)\n\t\t\texcept OSError:\n\t\t\t\tpass\n\telse:\n\t\tos.closerange(3, 4096) ## just guessing on the maximum descriptor count..\n\n\tos._exit(0)\n\t\n", "description": "\n\tCauses python to exit without garbage-collecting any objects, and thus avoids\n\tcalling object destructor methods. This is a sledgehammer workaround for \n\ta variety of bugs in PyQt and Pyside that cause crashes on exit.\n\t\n\tThis function does the following in an attempt to 'safely' terminate\n\tthe process:\n\t\n\t  * Invoke atexit callbacks\n\t  * Close all open file handles\n\t  * os._exit()\n\t\n\tNote: there is some potential for causing damage with this function if you\n\tare using objects that _require_ their destructors to be called (for example,\n\tto properly terminate log files, disconnect from devices, etc). Situations\n\tlike this are probably quite rare, but use at your own risk.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "plot", "data": "def plot(*args, **kargs):\n\t\"\"\"\n\tCreate and return a :class:`PlotWidget ` \n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to plot data. (see :func:`PlotItem.plot() `)\n\t\"\"\"\n\tmkQApp()\n\tpwArgList = ['title', 'labels', 'name', 'left', 'right', 'top', 'bottom', 'background']\n\tpwArgs = {}\n\tdataArgs = {}\n\tfor k in kargs:\n\t\tif k in pwArgList:\n\t\t\tpwArgs[k] = kargs[k]\n\t\telse:\n\t\t\tdataArgs[k] = kargs[k]\n\twindowTitle = pwArgs.pop(\"title\", \"PlotWidget\")\n\tw = PlotWidget(**pwArgs)\n\tw.setWindowTitle(windowTitle)\n\tif len(args) > 0 or len(dataArgs) > 0:\n\t\tw.plot(*args, **dataArgs)\n\tplots.append(w)\n\tw.show()\n\treturn w\n", "description": "\n\tCreate and return a :class:`PlotWidget ` \n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to plot data. (see :func:`PlotItem.plot() `)\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "image", "data": "def image(*args, **kargs):\n\t\"\"\"\n\tCreate and return an :class:`ImageView ` \n\tWill show 2D or 3D image data.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to show data. (see :func:`ImageView.setImage() `)\n\t\"\"\"\n\tmkQApp()\n\tw = ImageView()\n\twindowTitle = kargs.pop(\"title\", \"ImageView\")\n\tw.setWindowTitle(windowTitle)\n\tw.setImage(*args, **kargs)\n\timages.append(w)\n\tw.show()\n", "description": "\n\tCreate and return an :class:`ImageView ` \n\tWill show 2D or 3D image data.\n\tAccepts a *title* argument to set the title of the window.\n\tAll other arguments are used to show data. (see :func:`ImageView.setImage() `)\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "dbg", "data": "def dbg(*args, **kwds):\n\t\"\"\"\n\tCreate a console window and begin watching for exceptions.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t\"\"\"\n\tmkQApp()\n\tfrom . import console\n\tc = console.ConsoleWidget(*args, **kwds)\n\tc.catchAllExceptions()\n\tc.show()\n\tglobal consoles\n\ttry:\n\t\tconsoles.append(c)\n\texcept NameError:\n\t\tconsoles = [c]\n\treturn c\n\n", "description": "\n\tCreate a console window and begin watching for exceptions.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}, {"term": "def", "name": "stack", "data": "def stack(*args, **kwds):\n\t\"\"\"\n\tCreate a console window and show the current stack trace.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t\"\"\"\n\tmkQApp()\n\tfrom . import console\n\tc = console.ConsoleWidget(*args, **kwds)\n\tc.setStack()\n\tc.show()\n\tglobal consoles\n\ttry:\n\t\tconsoles.append(c)\n\texcept NameError:\n\t\tconsoles = [c]\n\treturn c\n", "description": "\n\tCreate a console window and show the current stack trace.\n\t\n\tAll arguments are passed to :func:`ConsoleWidget.__init__() `.\n\t", "category": "graphics", "imports": ["### import all the goodies and add some helper functions for easy CLI use", "from .Qt import QtCore, QtGui, mkQApp", "from .Qt import exec_ as exec", "import numpy  ## pyqtgraph requires numpy", "\t\t\t  ## (import here to avoid massive error dump later on if numpy is not available)", "import os, sys", "\tfrom .Qt import VERSION_INFO", "\timport pprint", "\t### This eliminates the problem of accidental stale pyc file imports.\"", "## don't import the more complex systems--canvas, parametertree, flowchart, dockarea", "## these must be imported separately.", "#from . import frozenSupport", "#def importModules(path, globals, locals, excludes=()):", "\t#Note that *path* MUST be relative to the module doing the import.\t", "\t\t\t#print( \"from .%s import * \" % modName)", "\t\t\t#mod = __import__(modName, globals, locals, ['*'], 1)", "\t\t\t#import traceback", "\t\t\t#print(\"[Error importing module: %s]\" % modName)", "#def importAll(path, globals, locals, excludes=()):", "\t#\"\"\"Given a list of modules, import all names from each module into the global namespace.\"\"\"", "\t#mods = importModules(path, globals, locals, excludes)", "# Dynamic imports are disabled. This causes too many problems.", "#importAll('graphicsItems', globals(), locals())", "#importAll('widgets', globals(), locals(),", "from .graphicsItems.VTickGroup import * ", "from .graphicsItems.GraphicsWidget import * ", "from .graphicsItems.ScaleBar import * ", "from .graphicsItems.PlotDataItem import * ", "from .graphicsItems.GraphItem import * ", "from .graphicsItems.TextItem import * ", "from .graphicsItems.GraphicsLayout import * ", "from .graphicsItems.UIGraphicsItem import * ", "from .graphicsItems.GraphicsObject import * ", "from .graphicsItems.PlotItem import * ", "from .graphicsItems.ROI import * ", "from .graphicsItems.InfiniteLine import * ", "from .graphicsItems.HistogramLUTItem import * ", "from .graphicsItems.GridItem import * ", "from .graphicsItems.GradientLegend import * ", "from .graphicsItems.GraphicsItem import * ", "from .graphicsItems.BarGraphItem import * ", "from .graphicsItems.ViewBox import * ", "from .graphicsItems.ArrowItem import * ", "from .graphicsItems.ImageItem import * ", "from .graphicsItems.PColorMeshItem import * ", "from .graphicsItems.AxisItem import * ", "from .graphicsItems.DateAxisItem import *", "from .graphicsItems.LabelItem import * ", "from .graphicsItems.CurvePoint import * ", "from .graphicsItems.GraphicsWidgetAnchor import * ", "from .graphicsItems.PlotCurveItem import * ", "from .graphicsItems.ButtonItem import * ", "from .graphicsItems.GradientEditorItem import * ", "from .graphicsItems.ColorBarItem import * ", "from .graphicsItems.MultiPlotItem import * ", "from .graphicsItems.ErrorBarItem import * ", "from .graphicsItems.IsocurveItem import * ", "from .graphicsItems.LinearRegionItem import * ", "from .graphicsItems.FillBetweenItem import * ", "from .graphicsItems.LegendItem import * ", "from .graphicsItems.ScatterPlotItem import * ", "from .graphicsItems.ItemGroup import *", "from .graphicsItems.TargetItem import * ", "from .widgets.MultiPlotWidget import * ", "from .widgets.ScatterPlotWidget import * ", "from .widgets.ColorMapWidget import * ", "from .widgets.FileDialog import * ", "from .widgets.ValueLabel import * ", "from .widgets.HistogramLUTWidget import * ", "from .widgets.CheckTable import * ", "from .widgets.BusyCursor import * ", "from .widgets.PlotWidget import * ", "from .widgets.ComboBox import * ", "from .widgets.GradientWidget import * ", "from .widgets.DataFilterWidget import * ", "from .widgets.SpinBox import * ", "from .widgets.JoystickButton import * ", "from .widgets.GraphicsLayoutWidget import * ", "from .widgets.TreeWidget import * ", "from .widgets.PathButton import * ", "from .widgets.VerticalLabel import * ", "from .widgets.FeedbackButton import * ", "from .widgets.ColorButton import * ", "from .widgets.DataTreeWidget import * ", "from .widgets.DiffTreeWidget import * ", "from .widgets.GraphicsView import * ", "from .widgets.LayoutWidget import * ", "from .widgets.TableWidget import * ", "from .widgets.ProgressDialog import *", "from .widgets.GroupBox import GroupBox", "from .widgets.RemoteGraphicsView import RemoteGraphicsView", "from .imageview import *", "from .WidgetGroup import *", "from .Point import Point", "from .Vector import Vector", "from .SRTTransform import SRTTransform", "from .Transform3D import Transform3D", "from .SRTTransform3D import SRTTransform3D", "from .functions import *", "from .graphicsWindows import *", "from .SignalProxy import *", "from .colormap import *", "from .ptime import time", "from .Qt import isQObjectAlive", "from .ThreadsafeTimer import *", "# indirect imports used within library", "from .GraphicsScene import GraphicsScene", "from .util.cupy_helper import getCupy", "# indirect imports known to be used outside of the library", "from .metaarray import MetaArray", "from .ordereddict import OrderedDict", "import atexit", "\timport gc", "\tfrom . import console", "\tfrom . import console"]}], [{"term": "class", "name": "Representsanadjustablearrow-shapedlinecap.Thisclasscannotbeinherited.", "data": " Represents an adjustable arrow-shaped line cap. This class cannot be inherited.\n\n \n", "description": null, "category": "graphics", "imports": ["# no imports"]}, {"term": "class", "name": "DefinesablendpatternforaSystem.Drawing.Drawing2D.LinearGradientBrushobject.Thisclasscannotbeinherited.", "data": " Defines a blend pattern for a System.Drawing.Drawing2D.LinearGradientBrush object. This class cannot be inherited.\n\n \n", "description": null, "category": "graphics", "imports": ["# no imports"]}, {"term": "class", "name": "Definesarraysofcolorsandpositionsusedforinterpolatingcolorblendinginamulticolorgradient.Thisclasscannotbeinherited.", "data": " Defines arrays of colors and positions used for interpolating color blending in a multicolor gradient. This class cannot be inherited.\n\n \n", "description": null, "category": "graphics", "imports": ["# no imports"]}, {"term": "class", "name": "presentstheinternaldataofagraphicscontainer.ThisclassisusedwhensavingthestateofaSystem.Drawing.GraphicsobjectusingtheSystem.Drawing.Graphics.BeginContainerandSystem.Drawing.Graphics.EndContainer", "data": " \"\"\" Represents the internal data of a graphics container. This class is used when saving the state of a System.Drawing.Graphics object using the System.Drawing.Graphics.BeginContainer and System.Drawing.Graphics.EndContainer(System.Drawing.Drawing2D.GraphicsContainer) methods. This class cannot be inherited. \"\"\"\n", "description": " Represents the internal data of a graphics container. This class is used when saving the state of a System.Drawing.Graphics object using the System.Drawing.Graphics.BeginContainer and System.Drawing.Graphics.EndContainer(System.Drawing.Drawing2D.GraphicsContainer) methods. This class cannot be inherited. ", "category": "graphics", "imports": ["# no imports"]}, {"term": "class", "name": "Representsaseriesofconnectedlinesandcurves.Thisclasscannotbeinherited.", "data": " Represents a series of connected lines and curves. This class cannot be inherited.\n\n \n", "description": null, "category": "graphics", "imports": ["# no imports"]}, {"term": "class", "name": "ProvidestheabilitytoiteratethroughsubpathsinaSystem.Drawing.Drawing2D.GraphicsPathandtestthetypesofshapescontainedineachsubpath.Thisclasscannotbeinherited.", "data": " Provides the ability to iterate through subpaths in a System.Drawing.Drawing2D.GraphicsPath and test the types of shapes contained in each subpath. This class cannot be inherited.\n\n \n", "description": null, "category": "graphics", "imports": ["# no imports"]}, {"term": "class", "name": "\"\"\"RepresentsthestateofaSystem.Drawing.Graphicsobject.ThisobjectisreturnedbyacalltotheSystem.Drawing.Graphics.Savemethods.Thisclasscannotbeinherited.\"\"\"", "data": " \"\"\" Represents the state of a System.Drawing.Graphics object. This object is returned by a call to the System.Drawing.Graphics.Save methods. This class cannot be inherited. \"\"\"\n", "description": " Represents the state of a System.Drawing.Graphics object. This object is returned by a call to the System.Drawing.Graphics.Save methods. This class cannot be inherited. ", "category": "graphics", "imports": ["# no imports"]}, {"term": "class", "name": "Definesarectangularbrushwithahatchstyle,aforegroundcolor,andabackgroundcolor.Thisclasscannotbeinherited.", "data": " Defines a rectangular brush with a hatch style,a foreground color,and a background color. This class cannot be inherited.\n\n \n", "description": null, "category": "graphics", "imports": ["# no imports"]}, {"term": "class", "name": "EncapsulatesaSystem.Drawing.Brushwithalineargradient.Thisclasscannotbeinherited.", "data": " Encapsulates a System.Drawing.Brush with a linear gradient. This class cannot be inherited.\n\n \n", "description": null, "category": "graphics", "imports": ["# no imports"]}, {"term": "class", "name": "Encapsulatesa3-by-3affinematrixthatrepresentsageometrictransform.Thisclasscannotbeinherited.", "data": " Encapsulates a 3-by-3 affine matrix that represents a geometric transform. This class cannot be inherited.\n\n \n", "description": null, "category": "graphics", "imports": ["# no imports"]}, {"term": "class", "name": "ContainsthegraphicaldatathatmakesupaSystem.Drawing.Drawing2D.GraphicsPathobject.Thisclasscannotbeinherited.", "data": " Contains the graphical data that makes up a System.Drawing.Drawing2D.GraphicsPath object. This class cannot be inherited.\n\n \n", "description": null, "category": "graphics", "imports": ["# no imports"]}, {"term": "class", "name": "EncapsulatesaSystem.Drawing.BrushobjectthatfillstheinteriorofaSystem.Drawing.Drawing2D.GraphicsPathobjectwithagradient.Thisclasscannotbeinherited.", "data": " Encapsulates a System.Drawing.Brush object that fills the interior of a System.Drawing.Drawing2D.GraphicsPath object with a gradient. This class cannot be inherited.\n\n \n", "description": null, "category": "graphics", "imports": ["# no imports"]}], [{"term": "def", "name": "hexdarken", "data": "def hexdarken(hexcolour, factor=0.7):\n\t\"\"\" Take a passed hex colour and return an RGB colour that is\n\t\tslightly darker (if possible)\n\t\"\"\"\n\tc = colors.HexColor(hexcolour)\n\tfor a in ['red', 'green', 'blue']:\n\t\tsetattr(c, a, factor * getattr(c, a))\n\treturn c\n\n", "description": " Take a passed hex colour and return an RGB colour that is\n\t\tslightly darker (if possible)\n\t", "category": "graphics", "imports": ["from KGML_pathway import Pathway, Graphics", "import KGML_parser", "from reportlab.lib import pagesizes", "from reportlab.lib import colors", "from reportlab.lib.utils import ImageReader", "from reportlab.graphics.shapes import *", "from reportlab.pdfgen import canvas", "from itertools import chain", "import urllib2", "from PIL import Image", "import os", "import StringIO", "import tempfile", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:", "\tkgml_map.import_imagemap = True", "\tkgml_map.import_imagemap = True", "\tkgml_map.import_imagemap = True", "\tkgml_map.import_imagemap = True"]}, {"term": "def", "name": "get_temp_imagefilename", "data": "def get_temp_imagefilename(url):\n\t\"\"\" Create a new temporary file to hold the image file at the passed URL,\n\t\tand return the filename\n\t\"\"\"\n\timg = urllib2.urlopen(url).read()\n\tim = Image.open(StringIO.StringIO(img))\n\t#im.transpose(Image.FLIP_TOP_BOTTOM)\n\tf = tempfile.NamedTemporaryFile(delete=False, suffix='.png')\n\tfname = f.name\n\tf.close()\n\tim.save(fname, 'PNG')\n\treturn fname\n\n", "description": " Create a new temporary file to hold the image file at the passed URL,\n\t\tand return the filename\n\t", "category": "graphics", "imports": ["from KGML_pathway import Pathway, Graphics", "import KGML_parser", "from reportlab.lib import pagesizes", "from reportlab.lib import colors", "from reportlab.lib.utils import ImageReader", "from reportlab.graphics.shapes import *", "from reportlab.pdfgen import canvas", "from itertools import chain", "import urllib2", "from PIL import Image", "import os", "import StringIO", "import tempfile", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:", "\tkgml_map.import_imagemap = True", "\tkgml_map.import_imagemap = True", "\tkgml_map.import_imagemap = True", "\tkgml_map.import_imagemap = True"]}, {"term": "class", "name": "KGMLCanvas", "data": "class KGMLCanvas(object):\n\t\"\"\" Contains a Reportlab Canvas-based representation of a KGML pathway map\n\t\"\"\"\n\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,\n\t\t\t\t label_orthologs=True, label_reaction_entries=True,\n\t\t\t\t label_maps=True, show_maps=False, fontname='Helvetica',\n\t\t\t\t fontsize=6, draw_relations=True, show_orthologs=True,\n\t\t\t\t show_compounds=True, show_genes=True,\n\t\t\t\t margins=(0.02, 0.02)):\n\t\tself.pathway = pathway\n\t\t# Some settings - static for now, but manipulable later perhaps\n\t\tself.show_maps = show_maps\n\t\tself.show_orthologs = show_orthologs\n\t\tself.show_compounds = show_compounds\n\t\tself.show_genes = show_genes\n\t\tself.label_compounds = label_compounds\n\t\tself.label_orthologs = label_orthologs\n\t\tself.label_reaction_entries = label_reaction_entries\n\t\tself.label_maps = label_maps\n\t\tself.fontname = fontname\n\t\tself.fontsize = fontsize\n\t\tself.draw_relations = draw_relations\n\t\tself.non_reactant_transparency = 0.3\n\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL\n\t\t# percentage of canvas that will be margin in on either side in the\n\t\t# X and Y directions\n\t\tself.margins = margins\n\n\tdef draw(self, filename):\n\t\t\"\"\" Add the map elements to the drawing\n\t\t\"\"\"\n\t\t# Instantiate the drawing, first\n\t\t# size x_max, y_max for now - we can add margins, later\n\t\tif self.import_imagemap:\n\t\t\t# We're drawing directly on the image, so we set the canvas to the\n\t\t\t# same size as the image\n\t\t\tif os.path.isfile(self.pathway.image):\n\t\t\t\timfilename = self.pathway.image\n\t\t\telse:\n\t\t\t\timfilename = get_temp_imagefilename(self.pathway.image)\n\t\t\tim = Image.open(imfilename)\n\t\t\tcwidth, cheight = im.size\n\t\telse:\n\t\t\t# No image, so we set the canvas size to accommodate visible\n\t\t\t# elements\n\t\t\tcwidth, cheight = (self.pathway.bounds[1][0],\n\t\t\t\t\t\t\t   self.pathway.bounds[1][1])\n\t\t# Instantiate canvas\n\t\tself.drawing = \\\n\t\t\tcanvas.Canvas(filename, bottomup=0,\n\t\t\t\t\t\t  pagesize=(cwidth *\n\t\t\t\t\t\t\t\t\t(1 + 2 * self.margins[0]),\n\t\t\t\t\t\t\t\t\tcheight *\n\t\t\t\t\t\t\t\t\t(1 + 2 * self.margins[1])))\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\t\t# Transform the canvas to add the margins\n\t\tself.drawing.translate(self.margins[0] * self.pathway.bounds[1][0],\n\t\t\t\t\t\t\t   self.margins[1] * self.pathway.bounds[1][1])\n\t\t# Add the map image, if required\n\t\tif self.import_imagemap:\n\t\t\tself.drawing.saveState()\n\t\t\tself.drawing.scale(1, -1)\n\t\t\tself.drawing.translate(0, -cheight)\n\t\t\tself.drawing.drawImage(imfilename, 0, 0)\n\t\t\tself.drawing.restoreState()\n\t\t# Add the reactions, compounds and maps\n\t\t# Maps go on first, to be overlaid by more information.\n\t\t# By default, they're slightly transparent.\n\t\tif self.show_maps:\n\t\t\tself.__add_maps()\n\t\tself.__add_reaction_entries()\n\t\tif self.show_orthologs:\n\t\t\tself.__add_orthologs()\n\t\tif self.show_compounds:\n\t\t\tself.__add_compounds()\n\t\tif self.show_genes:\n\t\t\tself.__add_genes()\n\t\t# Write the pathway map to PDF\n\t\tself.drawing.save()\n\n\tdef __add_maps(self):\n\t\t\"\"\" Adds maps to the drawing of the map\n\n\t\t\tWe do this first, as they're regional labels to be overlaid by\n\t\t\tinformation.  Also, we want to set the colour to something subtle.\n\n\t\t\tWe're using Hex colours because that's what KGML uses, and\n\t\t\tReportlab doesn't mind.\n\t\t\"\"\"\n\t\tfor m in self.pathway.maps:\n\t\t\tfor g in m.graphics:\n\t\t\t\tself.drawing.setStrokeColor('#888888')\n\t\t\t\tself.drawing.setFillColor('#DDDDDD')\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_maps:\n\t\t\t\t\tself.drawing.setFillColor('#888888')\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_graphics(self, graphics):\n\t\t\"\"\" Adds the passed graphics object to the map\n\n\t\t\tAdd text, add after the graphics object, for\n\t\t\tsane Z-ordering\n\t\t\"\"\"\n\t\tif graphics.type == 'line':\n\t\t\tp = self.drawing.beginPath()\n\t\t\tx, y = graphics.coords[0]\n\t\t\t# There are optional settings for lines that aren't necessarily\n\t\t\t# part of the KGML DTD\n\t\t\tif graphics.width is not None:\n\t\t\t\tself.drawing.setLineWidth(graphics.width)\n\t\t\telse:\n\t\t\t\tself.drawing.setLineWidth(1)\n\t\t\tp.moveTo(x, y)\n\t\t\tfor (x, y) in graphics.coords:\n\t\t\t\tp.lineTo(x, y)\n\t\t\tself.drawing.drawPath(p)\n\t\t\tself.drawing.setLineWidth(1)\t\t# Return to default\n\t\t# KGML defines the (x, y) coordinates as the centre of the circle/\n\t\t# rectangle/roundrectangle, but Reportlab uses the co-ordinates of the\n\t\t# lower-left corner for rectangle/elif.\n\t\tif graphics.type == 'circle':\n\t\t\tself.drawing.circle(graphics.x, graphics.y, graphics.width*0.5,\n\t\t\t\t\t\t\t\tstroke=1, fill=1)\n\t\telif graphics.type == 'roundrectangle':\n\t\t\tself.drawing.roundRect(graphics.x - graphics.width * 0.5,\n\t\t\t\t\t\t\t\t   graphics.y - graphics.height * 0.5,\n\t\t\t\t\t\t\t\t   graphics.width, graphics.height,\n\t\t\t\t\t\t\t\t   min(graphics.width, graphics.height) * 0.1,\n\t\t\t\t\t\t\t\t   stroke=1, fill=1)\n\t\telif graphics.type == 'rectangle':\n\t\t\tself.drawing.rect(graphics.x - graphics.width * 0.5,\n\t\t\t\t\t\t\t  graphics.y - graphics.height * 0.5,\n\t\t\t\t\t\t\t  graphics.width, graphics.height,\n\t\t\t\t\t\t\t  stroke=1, fill=1)\n\n\tdef __add_labels(self, graphics):\n\t\t\"\"\" Adds labels for the passed graphics objects to the map\n\n\t\t\tWe don't check that the labels fit inside objects such as circles/\n\t\t\trectangles/roundrectangles\n\t\t\"\"\"\n\t\tif graphics.type == 'line':\n\t\t\t# We use the midpoint of the line - sort of - we take the median\n\t\t\t# line segment (list-wise, not in terms of length), and use the\n\t\t\t# midpoint of that line.  We could have other options here,\n\t\t\t# maybe even parameterising it to a proportion of the total line\n\t\t\t# length.\n\t\t\tmid_idx = len(graphics.coords) * 0.5\n\t\t\tif not int(mid_idx) == mid_idx:\n\t\t\t\tidx1, idx2 = int(mid_idx - 0.5), int(mid_idx + 0.5)\n\t\t\telse:\n\t\t\t\tidx1, idx2 = int(mid_idx - 1), int(mid_idx)\n\t\t\tx1, y1 = graphics.coords[idx1]\n\t\t\tx2, y2 = graphics.coords[idx2]\n\t\t\tx, y = 0.5 * (x1 + x2), 0.5 * (y1 + y2)\n\t\telif graphics.type == 'circle':\n\t\t\tx, y = graphics.x, graphics.y\n\t\telif graphics.type in ('rectangle', 'roundrectangle'):\n\t\t\tx, y = graphics.x, graphics.y\n\t\t# How big so we want the text, and how many characters?\n\t\tif graphics._parent.type == 'map':\n\t\t\ttext = graphics.name\n\t\t\tself.drawing.setFont(self.fontname, self.fontsize + 2)\n\t\telif len(graphics.name) < 15:\n\t\t\ttext = graphics.name\n\t\telse:\n\t\t\ttext = graphics.name[:12] + '...'\n\t\tself.drawing.drawCentredString(x, y, text)\n\t\tself.drawing.setFont(self.fontname, self.fontsize)\n\n\tdef __add_orthologs(self):\n\t\t\"\"\" Adds 'ortholog' Entry elements to the drawing of the map.\n\n\t\t\tIn KGML, these are typically line objects, so we render them\n\t\t\tbefore the compound circles to cover the unsightly ends/junctions\n\t\t\"\"\"\n\t\tfor ortholog in self.pathway.orthologs:\n\t\t\tfor g in ortholog.graphics:\n\t\t\t\tself.drawing.setStrokeColor(g.fgcolor)\n\t\t\t\tself.drawing.setFillColor(g.bgcolor)\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_orthologs:\n\t\t\t\t\t# We want the label colour to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(hexdarken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_reaction_entries(self):\n\t\t\"\"\" Adds Entry elements corresponding to Reactions to the drawing of\n\t\t\tthe map.\n\n\t\t\tIn KGML, these are typically line objects, so we render them\n\t\t\tbefore the compound circles to cover the unsightly ends/junctions\n\t\t\"\"\"\n\t\tfor reaction in self.pathway.reaction_entries:\n\t\t\tfor g in reaction.graphics:\n\t\t\t\tself.drawing.setStrokeColor(g.fgcolor)\n\t\t\t\tself.drawing.setFillColor(g.bgcolor)\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_reaction_entries:\n\t\t\t\t\t# We want the label colour to be slightly darker\n\t\t\t\t\t# (where possible), so it can be read\n\t\t\t\t\tself.drawing.setFillColor(hexdarken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_compounds(self):\n\t\t\"\"\" Adds compound elements to the drawing of the map\n\t\t\"\"\"\n\t\tfor compound in self.pathway.compounds:\n\t\t\tfor g in compound.graphics:\n\t\t\t\t# Modify transparency of compounds that don't participate\n\t\t\t\t# in reactions\n\t\t\t\tfillcolour = colors.HexColor(g.bgcolor)\n\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\tfillcolour.alpha *= self.non_reactant_transparency\n\t\t\t\tself.drawing.setStrokeColor(g.fgcolor)\n\t\t\t\tself.drawing.setFillColor(fillcolour)\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tif not compound.is_reactant:\n\t\t\t\t\t\tt = 0.3\n\t\t\t\t\telse:\n\t\t\t\t\t\tt = 1\n\t\t\t\t\tself.drawing.setFillColor(colors.Color(0.2, 0.2, 0.2, t))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_genes(self):\n\t\t\"\"\" Adds gene elements to the drawing of the map\n\t\t\"\"\"\n\t\tfor gene in self.pathway.genes:\n\t\t\tfor g in gene.graphics:\n\t\t\t\tfillcolour = colors.HexColor(g.bgcolor)\n\t\t\t\tself.drawing.setStrokeColor(g.fgcolor)\n\t\t\t\tself.drawing.setFillColor(fillcolour)\n\t\t\t\tself.__add_graphics(g)\n\t\t\t\tif self.label_compounds:\n\t\t\t\t\tself.drawing.setFillColor(hexdarken(g.fgcolor))\n\t\t\t\t\tself.__add_labels(g)\n\n\tdef __add_relations(self):\n\t\t\"\"\" Adds relations to the map\n\n\t\t\tThis is tricky. There is no defined graphic in KGML for a\n\t\t\trelation, and the corresponding entries are typically defined\n\t\t\tas objects 'to be connected somehow'.  KEGG uses KegSketch, which\n\t\t\tis not public, and most third-party software draws straight line\n\t\t\tarrows, with heads to indicate the appropriate direction\n\t\t\t(at both ends for reversible reactions), using solid lines for\n\t\t\tECrel relation types, and dashed lines for maplink relation types.\n\n\t\t\tThe relation has:\n\t\t\tentry1: 'from' node\n\t\t\tentry2: 'to' node\n\t\t\tsubtype: what the relation refers to\n\n\t\t\tTypically we have entry1 = map/ortholog; entry2 = map/ortholog,\n\t\t\tsubtype = compound\n\t\t\"\"\"\n\t\t# Dashed lines for maplinks, solid for everything else\n\t\tfor relation in list(self.pathway.relations):\n\t\t\tif relation.type == 'maplink':\n\t\t\t\tself.drawing.setDash(6, 3)\n\t\t\telse:\n\t\t\t\tself.drawing.setDash()\n\t\t\tfor s in relation.subtypes:\n\t\t\t\tsubtype = self.pathway.entries[s[1]]\n\t\t\t\t# Our aim is to draw an arrow from the entry1 object to the\n\t\t\t\t# entry2 object, via the subtype object.\n\t\t\t\t# 1) Entry 1 to subtype\n\t\t\t\tself.__draw_arrow(relation.entry1, subtype)\n\t\t\t\t# 2) subtype to Entry 2\n\t\t\t\tself.__draw_arrow(subtype, relation.entry2)\n\n\tdef __draw_arrow(self, g_from, g_to):\n\t\t\"\"\" Draws an arrow from the g_from Entry object to the g_to\n\t\t\tEntry object; both must have Graphics objects\n\t\t\"\"\"\n\t\t# Centre and bound co-ordinates for the from and two objects\n\t\tbounds_from, bounds_to = g_from.bounds, g_to.bounds\n\t\tcentre_from = (0.5 * (bounds_from[0][0] + bounds_from[1][0]),\n\t\t\t\t\t   0.5 * (bounds_from[0][1] + bounds_from[1][1]))\n\t\tcentre_to = (0.5 * (bounds_to[0][0] + bounds_to[1][0]),\n\t\t\t\t\t 0.5 * (bounds_to[0][1] + bounds_to[1][1]))\n\t\tp = self.drawing.beginPath()\n\t\t# If the 'from' and 'to' graphics are vertically-aligned, draw a line\n\t\t# from the 'from' to the 'to' entity\n\t\tif bounds_to[0][0] < centre_from[0] < bounds_to[1][0]:\n\t\t\tif centre_to[1] > centre_from[1]:  # to above from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point\n\t\t\telse:\t\t\t\t\t\t\t   # to below from\n\t\t\t\tp.moveTo(centre_from[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_from[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point\n\t\telif bounds_from[0][0] < centre_to[0] < bounds_from[1][0]:\n\t\t\tprint True, g_from.name, g_to.name, bounds_to, bounds_from\n\t\t\tif centre_to[1] > centre_from[1]:   # to above from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[1][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[0][1])\n\t\t\t\t# Draw arrow point\n\t\t\telse:\t\t\t\t\t\t\t   # to below from\n\t\t\t\tp.moveTo(centre_to[0], bounds_from[0][1])\n\t\t\t\tp.lineTo(centre_to[0], bounds_to[1][1])\n\t\t\t\t# Draw arrow point\n\t\tself.drawing.drawPath(p)\t# Draw arrow shaft\n\n", "description": " Contains a Reportlab Canvas-based representation of a KGML pathway map\n\t", "category": "graphics", "imports": ["from KGML_pathway import Pathway, Graphics", "import KGML_parser", "from reportlab.lib import pagesizes", "from reportlab.lib import colors", "from reportlab.lib.utils import ImageReader", "from reportlab.graphics.shapes import *", "from reportlab.pdfgen import canvas", "from itertools import chain", "import urllib2", "from PIL import Image", "import os", "import StringIO", "import tempfile", "\tdef __init__(self, pathway, import_imagemap=False, label_compounds=True,", "\t\tself.import_imagemap = import_imagemap  # Import the map .png from URL", "\t\tif self.import_imagemap:", "\t\tif self.import_imagemap:", "\tkgml_map.import_imagemap = True", "\tkgml_map.import_imagemap = True", "\tkgml_map.import_imagemap = True", "\tkgml_map.import_imagemap = True"]}], [{"term": "class", "name": "maintainingtemporarycompatibilitywithnon-splitmethodsandsubclassmodes.", "data": "maintaining temporary compatibility with non-split methods and subclass modes.\n", "description": null, "category": "graphics", "imports": ["# And several imports are needed to make this work, but they should be obvious"]}, {"term": "class", "name": "#Afterthat,we'llshowhowtodoitwithitssubclassselectMolsMode.", "data": "# After that, we'll show how to do it with its subclass selectMolsMode.\n", "description": null, "category": "graphics", "imports": ["# And several imports are needed to make this work, but they should be obvious"]}, {"term": "class", "name": "Select_basicGraphicsMode", "data": "class Select_basicGraphicsMode(basicGraphicsMode):\n\tdef __init__(self, glpane):\n\t\t\"\"\"\n\t\t\"\"\"\n\t\tbasicGraphicsMode.__init__(self, glpane)\n\t\t# Now do whatever might be needed to init the graphicsMode object,\n\t\t# or the graphicsMode-related attrs of the mixed object.\n\t\t#\n\t\t# (Similar comments apply as for Select_basicCommand.__init__, below,\n\t\t#  but note that for GraphicsModes, there is no Enter method.\n\t\t#  Probably we will need to add something like an Enter_graphicsMode\n\t\t#  method to the GraphicsMode API. In the meantime, the command's Enter\n\t\t#  method has to initialize the graphicsMode object's attrs (which are\n\t\t#  the graphics-related attrs of self, in the mixed case, but are\n\t\t#  referred to as self.graphicsMode.attr so this will work in the split\n\t\t#  case as well), which is a kluge.)\n\t\treturn\n\n\t# Now put all the methods from the \"graphics area half\" of the original\n\t# mode -- anything related to graphics, mouse events, cursors (for use in\n\t# graphics area), key bindings or context menu (for use in graphics area).\n\n\tdef Draw(self, args):\n\t\tpass\n\tdef someMouseMethod(self, args):\n\t\tpass\n\tdef someCursorMethod(self, args):\n\t\tpass\n\t# etc\n", "description": "\n\t\t", "category": "graphics", "imports": ["# And several imports are needed to make this work, but they should be obvious"]}, {"term": "class", "name": "Select_basicCommand", "data": "class Select_basicCommand(basicCommand):\n\tdef __init__(self, commandSequencer):\n\t\t\"\"\"\n\t\t...\n\t\t\"\"\"\n\t\tbasicCommand.__init__(self, commandSequencer)\n\t\t# Now do whatever might be needed to init the command object,\n\t\t# or in the mixed case, the command-related attrs of the mixed object.\n\t\t# That might be nothing, since most attrs can just be initialized in\n\t\t# Enter, since they should be reinitialized every time we enter the\n\t\t# command anyway.\n\t\t# (If it's nothing, we probably don't need this method, but it's ok\n\t\t#  to have it for clarity, especially if there is more than one\n\t\t#  superclass.)\n\t\treturn\n\t\n\t# Now put all the methods from the \"command half\" of the original\n\t# mode -- anything related to its property manager, its settings or\n\t# state, the model operations it does (unless those are so simple\n\t# that the mouse event bindings in the _GM half can do them directly\n\t# and the code is still clean, *and* no command-half subclass needs\n\t# to override them).\n\n\tdef Enter(self, args):\n\t\tpass\n\t# etc\n\n\t# Every method in the original mode goes into one of these halves,\n\t# or gets split into two methods (with different names), one for\n\t# each half. If a method gets split, old code that called it (perhaps\n\t# in other files) needs to call both split methods, or one of them\n\t# needs to call the other. This requires some thought in each case\n\t# when it has to be done.\n\n\tpass\n", "description": "\n\t\t...\n\t\t", "category": "graphics", "imports": ["# And several imports are needed to make this work, but they should be obvious"]}, {"term": "class", "name": "Select_GraphicsMode", "data": "class Select_GraphicsMode( Select_basicGraphicsMode):\n\t\"\"\"\n\tGlue class for GM-alone usage only\n\t\"\"\"\n\t# Imitate the init and property code in GraphicsMode, but don't inherit it.\n\t# (Remember to replace all the occurrences of its superclass with our own.)\n\t# (When this is later merged with its superclass, most of this can go away\n\t#  since we'll then be inheriting GraphicsMode here.)\n\n\t# (Or can we inherit GraphicsMode *after* the main superclass, and not have\n\t#  to do some of this? I don't know. ### find out! [I think I did this in PanLikeMode.]\n\t#  At least we'd probably still need this __init__ method.\n\t#  If this pattern works, then in *our* subclasses we'd instead post-inherit\n\t#  this class, Select_GraphicsMode.)\n\n\t\n\tdef __init__(self, command):\n\t\tself.command = command\n\t\tglpane = self.command.glpane \n\t\tSelect_basicGraphicsMode.__init__(self, glpane)\n\t\treturn\n\t\n\t# (the rest would come from GraphicsMode if post-inheriting it worked,\n\t#  or we could split it out of GraphicsMode as a post-mixin to use there and here)\n\n\tdef _get_commandSequencer(self):\n\t\treturn self.command.commandSequencer\n\n\tcommandSequencer = property(_get_commandSequencer)\n\n\tdef set_cmdname(self, name):\n\t\tself.command.set_cmdname(name)\n\t\treturn\n\n\tdef _get_hover_highlighting_enabled(self):\n\t\treturn self.command.hover_highlighting_enabled\n\n\tdef _set_hover_highlighting_enabled(self, val):\n\t\tself.command.hover_highlighting_enabled = val\n\n\thover_highlighting_enabled = property(_get_hover_highlighting_enabled, _set_hover_highlighting_enabled)\n\n\tpass\n", "description": "\n\tGlue class for GM-alone usage only\n\t", "category": "graphics", "imports": ["# And several imports are needed to make this work, but they should be obvious"]}, {"term": "class", "name": "Select_Command", "data": "class Select_Command( Select_basicCommand):\n\t\"\"\"\n\tGlue class for C-alone usage only\n\t\"\"\"\n\n\t# This is needed so the init code knows what kind of GM to make.\n\tGraphicsMode_class = Select_GraphicsMode\n\n\t# Imitate the init and property code in Command, but don't inherit it.\n\t# (Remember to replace all the occurrences of its superclass with our own.)\n\t# (When this is later merged with its superclass, most of this can go away\n\t#  since we'll then be inheriting Command here.)\n\n\t# (Or can we inherit Command *after* the main superclass, and not have\n\t#  to do some of this? I don't know. ### find out! [I think I did this in PanLikeMode.]\n\t#  At least we'd probably still need this __init__ method.\n\t#  If this pattern works, then in *our* subclasses we'd instead post-inherit\n\t#  this class, Select_Command.)\n\n\tdef __init__(self, commandSequencer):\n\t\tSelect_basicCommand.__init__(self, commandSequencer)\n\t\tself._create_GraphicsMode()\n\t\tself._post_init_modify_GraphicsMode()\n\t\treturn\n\t\n\t# (the rest would come from Command if post-inheriting it worked,\n\t#  or we could split it out of Command as a post-mixin to use there and here)\n\t\n\tdef _create_GraphicsMode(self):\n\t\tGM_class = self.GraphicsMode_class\n\t\tassert issubclass(GM_class, GraphicsMode_API)\n\t\targs = [self] \n\t\tkws = {} \n\t\tself.graphicsMode = GM_class(*args, **kws)\n\t\tpass\n\n\tdef _post_init_modify_GraphicsMode(self):\n\t\tpass\n\n\tpass\n", "description": "\n\tGlue class for C-alone usage only\n\t", "category": "graphics", "imports": ["# And several imports are needed to make this work, but they should be obvious"]}, {"term": "class", "name": "selectMode", "data": "class selectMode( Select_basicCommand, Select_basicGraphicsMode, anyMode): # might need more superclasses for isinstance?\n\t\"\"\"\n\tGlue class for mixed C/GM usage only\n\t\"\"\"\n\t# Imitate the init and property code in basicMode, but don't inherit it.\n\t# (Remember to replace all the occurrences of one of its two main\n\t#  superclasses with the corresponding one of our own.)\n\t\n\t# (When we no longer need the mixed-C/GM case, this class can be discarded.)\n\n\t# (Or can we inherit basicMode *after* the main superclasses, and not have\n\t#  to do some of this? I don't know. ### find out! [I think I did this in PanLikeMode.]\n\t#  At least we'd still need this __init__ method. )\n\n\tdef __init__(self, glpane):\n\t\tassert GLPANE_IS_COMMAND_SEQUENCER:\n\t\tcommandSequencer = glpane\n\t\t\n\t\tSelect_basicCommand.__init__(self, commandSequencer)\n\t\t\t# was just basicCommand in original\n\t\t\n\t\tSelect_basicGraphicsMode.__init__(self, glpane)\n\t\t\t# was just basicGraphicsMode in original\n\t\treturn\n\n\t# (the rest would come from basicMode if post-inheriting it worked,\n\t#  or we could split it out of basicMode as a post-mixin to use there and here)\n\t\n\tdef __get_command(self):\n\t\treturn self\n\n\tcommand = property(__get_command)\n\n\tdef __get_graphicsMode(self):\n\t\treturn self\n\n\tgraphicsMode = property(__get_graphicsMode)\n\n\tpass\n", "description": "\n\tGlue class for mixed C/GM usage only\n\t", "category": "graphics", "imports": ["# And several imports are needed to make this work, but they should be obvious"]}, {"term": "class", "name": "nselectMode.py", "data": "# and in selectMode.py (same name as original mode) we want class selectMode as above.\n", "description": null, "category": "graphics", "imports": ["# And several imports are needed to make this work, but they should be obvious"]}, {"term": "class", "name": "#butrevisingallsuperclassoccurrences:", "data": "# but revising all superclass occurrences:\n", "description": null, "category": "graphics", "imports": ["# And several imports are needed to make this work, but they should be obvious"]}], [{"term": "class", "name": "GraphicsLayoutWidget", "data": "class GraphicsLayoutWidget(GraphicsView):\n\t\"\"\"\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t\"\"\"\n\tdef __init__(self, parent=None, **kargs):\n\t\tGraphicsView.__init__(self, parent)\n\t\tself.ci = GraphicsLayout(**kargs)\n\t\tfor n in ['nextRow', 'nextCol', 'nextColumn', 'addPlot', 'addViewBox', 'addItem', 'getItem', 'addLayout', 'addLabel', 'removeItem', 'itemIndex', 'clear']:\n\t\t\tsetattr(self, n, getattr(self.ci, n))\n\t\tself.setCentralItem(self.ci)\n", "description": "\n\tConvenience class consisting of a :class:`GraphicsView \n\t` with a single :class:`GraphicsLayout\n\t` as its central item. \n\n\tThis class wraps several methods from its internal GraphicsLayout:\n\t:func:`nextRow `\n\t:func:`nextColumn `\n\t:func:`addPlot `\n\t:func:`addViewBox `\n\t:func:`addItem `\n\t:func:`getItem `\n\t:func:`addLabel `\n\t:func:`addLayout `\n\t:func:`removeItem `\n\t:func:`itemIndex `\n\t:func:`clear `\n\t", "category": "graphics", "imports": ["from ..Qt import QtGui", "from ..graphicsItems.GraphicsLayout import GraphicsLayout", "from .GraphicsView import GraphicsView"]}], [], [], [], [], [], [{"term": "class", "name": "GraphicsBindingsDocument", "data": "class GraphicsBindingsDocument(NSDocument):\n\tgraphicsView = objc.IBOutlet()\n\tshadowInspector = objc.IBOutlet()\n\tgraphicsController = objc.IBOutlet()\n\tgraphics = objc.ivar()\n\n\tdef init(self):\n\t\tself = super(GraphicsBindingsDocument, self).init()\n\t\tif self is None:\n\t\t\treturn None\n\t\tself.graphics = []  # NSMutableArray.array()\n\t\tself.bindings = []\n\t\treturn self\n\n\tdef windowNibName(self):\n\t\treturn \"GraphicsBindingsDocument\"\n\n\tdef makeBinding_fromObject_toObject_withKeyPath_options_(\n\t\tself, key, fromObject, toObject, withKeyPath, options\n\t):\n\t\tself.bindings.append((fromObject, key))\n\t\tfromObject.bind_toObject_withKeyPath_options_(\n\t\t\tkey, toObject, withKeyPath, options\n\t\t)\n\n\tdef windowControllerDidLoadNib_(self, controller):\n\t\tsuper(GraphicsBindingsDocument, self).windowControllerDidLoadNib_(controller)\n\n\t\t# we can't do these in IB at the moment, as\n\t\t# we don't have palette items for them\n\n\t\t# allow the shadow inspector (joystick) to handle multiple selections\n\t\toffsetOptions = {\"NSAllowsEditingMultipleValuesSelection\": True}\n\t\tangleOptions = {\n\t\t\t\"NSValueTransformerName\": \"RadiansToDegreesTransformer\",\n\t\t\t\"NSAllowsEditingMultipleValuesSelection\": True,\n\t\t}\n\n\t\tBINDINGS = [\n\t\t\t(\n\t\t\t\t\"graphics\",\n\t\t\t\tself.graphicsView,\n\t\t\t\tself.graphicsController,\n\t\t\t\t\"arrangedObjects\",\n\t\t\t\tNone,\n\t\t\t),\n\t\t\t(\n\t\t\t\t\"selectionIndexes\",\n\t\t\t\tself.graphicsView,\n\t\t\t\tself.graphicsController,\n\t\t\t\t\"selectionIndexes\",\n\t\t\t\tNone,\n\t\t\t),\n\t\t\t(\n\t\t\t\t\"offset\",\n\t\t\t\tself.shadowInspector,\n\t\t\t\tself.graphicsController,\n\t\t\t\t\"selection.shadowOffset\",\n\t\t\t\toffsetOptions,\n\t\t\t),\n\t\t\t(\n\t\t\t\t\"angle\",\n\t\t\t\tself.shadowInspector,\n\t\t\t\tself.graphicsController,\n\t\t\t\t\"selection.shadowAngle\",\n\t\t\t\tangleOptions,\n\t\t\t),\n\t\t]\n\t\tfor binding in BINDINGS:\n\t\t\tself.makeBinding_fromObject_toObject_withKeyPath_options_(*binding)\n\n\t\t# \"fake\" what should be set in IB if we had a palette...\n\t\tself.shadowInspector.maxOffset = 15\n\n\tdef close(self):\n\t\twhile self.bindings:\n\t\t\tobj, binding = self.bindings.pop()\n\t\t\tobj.unbind_(binding)\n\t\tsuper(GraphicsBindingsDocument, self).close()\n\n\tdef dataRepresentationOfType_(self, aType):\n\t\treturn NSKeyedArchiver.archivedDataWithRootObject_(self.graphics)\n\n\tdef loadDataRepresentation_ofType_(self, data, aType):\n\t\tself.graphics = NSKeyedUnarchiver.unarchiveObjectWithData_(data)\n\t\treturn True\n\n", "description": null, "category": "graphics", "imports": ["import objc", "from objc import super", "from PyObjCTools import AppHelper", "from RadiansToDegreesTransformer import RadiansToDegreesTransformer", "from Cocoa import NSDocument, NSValueTransformer, NSKeyedArchiver, NSKeyedUnarchiver"]}], [], [{"term": "class", "name": "classExplosion:", "data": "class Explosion:\n\n\tdef __init__(self, screen, pos, pic_scale, graphics_pic, active_sound=True, index=0):\n\t\tself.screen = screen\n\t\tself.pos = pos\n\t\tself.pic_scale = pic_scale\n\t\tself.actual_tick = 0\n\t\tself.actual_img_type = 0\n\t\tself.graphics_pic = graphics_pic\n\t\tself.to_remove = False\n\t\tif active_sound:\n\t\t\tsoundEffect.play('hit')\n\n\t\tself.explosion_img_list = self.graphics_pic.get_picture('explosion_red')\n\t\tif index == 1:\n\t\t\tself.explosion_img_list = self.graphics_pic.get_picture('explosion_red')\n\t\telif index == 2:\n\t\t\tself.explosion_img_list = self.graphics_pic.get_picture('explosion_green')\n\t\telif index == 3:\n\t\t\tself.explosion_img_list = self.graphics_pic.get_picture('explosion_blue')\n\t\telif index == 4:\n\t\t\tself.explosion_img_list = self.graphics_pic.get_picture('explosion_yellow')\n\n\tdef tick(self):\n\t\tself.actual_tick += 1\n\t\tif self.actual_tick == TICK_TO_CHANGE:\n\t\t\tself.actual_tick = 0\n\t\t\tself.actual_img_type += 1\n\n\tdef draw(self):\n\t\tif self.actual_img_type < self.explosion_img_list.__len__():\n\t\t\tpic_size = (self.explosion_img_list[self.actual_img_type].get_width(),\n\t\t\t\t\t\tself.explosion_img_list[self.actual_img_type].get_height())\n\t\t\texplosion_img = pygame.transform.scale(self.explosion_img_list[self.actual_img_type],\n\t\t\t\t\t\t\t\t\t\t\t\t   (int(pic_size[0] * self.pic_scale),\n\t\t\t\t\t\t\t\t\t\t\t\t\tint(pic_size[1] * self.pic_scale)))\n\t\t\tself.screen.blit(explosion_img,\n\t\t\t\t\t\t\t (self.pos[0] - pic_size[0] * self.pic_scale / 2,\n\t\t\t\t\t\t\t  self.pos[1] - pic_size[1] * self.pic_scale / 2))\n\t\telse:\n\t\t\tself.to_remove = True\n\n\tdef is_to_remove(self):\n\t\treturn self.to_remove\n", "description": null, "category": "graphics", "imports": ["import pygame", "from pygame.math import Vector2", "from sound_effects import soundEffect"]}], [], [{"term": "class", "name": "classRender:", "data": "class Render:\n\tdef __init__(self):\n\t\t# Configuration file\n\t\tdir = os.path.dirname(__file__)\n\t\tfilename = os.path.join(dir, '../config/matrix_options.ini')\n\n\t\t# Configuration for the matrix\n\t\tconfig = configparser.ConfigParser()\n\t\tconfig.read(filename)\n\n\t\tself.options = RGBMatrixOptions()\n\t\tself.options.rows = int(config['DEFAULT']['rows'])\n\t\tself.options.cols = int(config['DEFAULT']['columns'])\n\t\tself.options.chain_length = int(config['DEFAULT']['chain_length'])\n\t\tself.options.parallel = int(config['DEFAULT']['parallel'])\n\t\tself.options.hardware_mapping = config['DEFAULT']['hardware_mapping']\n\t\tself.options.gpio_slowdown = int(config['DEFAULT']['gpio_slowdown'])\n\t\t#self.options.brightness = int(config['DEFAULT']['brightness'])\n\t\tself.options.row_address_type = int(config['DEFAULT']['row_address_type'])\n\t\tself.options.drop_privileges = int(config['DEFAULT']['drop_privileges'])\n\n\t\tself.path = '/home/pi/NBA-scoreboard/scoreboard/'\n\n\t\tself.font = graphics.Font()\n\t\tself.font.LoadFont(\"/home/pi/NBA-scoreboard/rpi-rgb-led-matrix/fonts/6x12.bdf\")\n\t\tself.font2 = graphics.Font()\n\t\tself.font2.LoadFont(\"/home/pi/NBA-scoreboard/rpi-rgb-led-matrix/fonts/4x6.bdf\")\n\t\tself.font3 = graphics.Font()\n\t\tself.font3.LoadFont(\"/home/pi/NBA-scoreboard/rpi-rgb-led-matrix/fonts/5x8.bdf\")\n\t\tself.team_colors = {'ATL': [[225, 58, 62], [255, 255, 255]], 'BOS': [[0, 131, 72], [255, 205, 112]], 'BKN': [[100, 100, 100], [0, 0, 0]], 'CHA': [[29, 17, 96], [0, 140, 168]], 'CHI': [[206, 17, 65], [0, 0, 0]], 'CLE': [[134, 0, 56], [253, 187, 48]], 'DAL': [[0, 125, 197], [255, 255, 255]], 'DEN': [[77, 144, 205], [253, 185, 39]], 'DET': [[237, 23, 76], [0, 107, 182]], 'GSW': [[253, 185, 39], [0, 107, 182]], 'HOU': [[206, 17, 65], [196, 206, 211]], 'LAL': [[253, 185, 39], [85, 37, 130]], 'MEM': [[15, 88, 108], [190, 212, 233]], 'MIA': [[152, 0, 46], [0, 0, 0]], 'MIL': [[0, 71, 27], [240, 235, 210]], 'MIN': [[0, 80, 131], [0, 169, 79]], 'NOP': [[0, 43, 92], [227, 24, 55]], 'NYK': [[0, 107, 182], [245, 132, 38]], 'OKC': [[0, 125, 195], [240, 81, 51]], 'ORL': [[0, 125, 197], [0, 0, 0]], 'PHI': [[237, 23, 76], [0, 107, 182]], 'PHX': [[229, 96, 32], [29, 17, 96]], 'POR': [[224, 58, 62], [186, 195, 201]], 'SAC': [[114, 76, 159], [250, 250, 250]], 'SAS': [[186, 195, 201], [0, 0, 0]], 'TOR': [[206, 17, 65], [0, 0, 0]], 'UTA': [[0, 43, 92], [249, 160, 27]], 'WAS': [[0, 43, 92], [227, 24, 55]], 'IND': [[255, 198, 51], [0, 39, 93]], 'LAC': [[237, 23, 76], [0, 107, 182]]}\n\n\tdef Render_Games(self, printer=False):\n\t\tmatrix = RGBMatrix(options=self.options)\n\t\tdate_range = []\n\t\tdisp_live_odds = True\n\t\ttry:\n\t\t\tfor day in os.listdir(self.path):\n\t\t\t\tif day=='.DS_Store':\n\t\t\t\t\tcontinue\n\t\t\t\tif day == 'DataToday.json':\n\t\t\t\t\twith open(self.path + day) as file:\n\t\t\t\t\t\tgame_data = json.load(file)\n\n\t\texcept:\n\t\t\tprint('Error loading game data.')\n\t\t\tgame_data = {}\n\n\t\ttry:\n\t\t\twith open(self.path + 'NBASpreads.json', 'r') as file:\n\t\t\t\tspreads_data = json.load(file)\n\t\t\twith open(self.path + 'NBASpreadsLive.json', 'r') as file:\n\t\t\t\tspreads_data_live = json.load(file)\n\n\t\texcept:\n\t\t\tprint('Error loading spreads data.')\n\t\t\tspreads_data = {}\n\n\t\tcanvas = matrix.CreateFrameCanvas()\n\t\tcanvas2 = matrix.CreateFrameCanvas()\n\n\t\tif game_data == []:\n\t\t\tprint('no games')\n\t\t\tgraphics.DrawText(canvas, self.font, (63-6*7)/2-1, 14, graphics.Color(150,150,150), 'NO GAMES')\n\t\t\tgraphics.DrawText(canvas, self.font, (63-6*5)/2+2, 25, graphics.Color(150,150,150), 'TODAY')\n\n\t\t\t# NBA Logo\n\t\t\tfor line in range(20,30):\n\t\t\t\tgraphics.DrawLine(canvas, 58, line, 60, line, graphics.Color(0, 0, 255))\n\t\t\t\tgraphics.DrawLine(canvas, 60, line, 61, line, graphics.Color(255, 0, 0))\n\t\t\t\tgraphics.DrawLine(canvas, 60, line, 60, line, graphics.Color(255, 255, 255))\n\t\t\tfor line in range(22,26):\n\t\t\t\tgraphics.DrawLine(canvas, 58, line, 58, line, graphics.Color(255, 255, 255))\n\t\t\tfor line in range(21,27):\n\t\t\t\tgraphics.DrawLine(canvas, 59, line, 59, line, graphics.Color(255, 255, 255))\n\t\t\tfor line in range(24,26):\n\t\t\t\tgraphics.DrawLine(canvas, 61, line, 61, line, graphics.Color(255, 255, 255))\n\n\t\t\tcanvas = matrix.SwapOnVSync(canvas)\n\t\t\ttime.sleep(3600*2)\n\n\t\tfor game in game_data:\n\t\t\thometeam = game['homeTeam']['teamTricode']\n\t\t\tawayteam = game['awayTeam']['teamTricode']\n\n\t\t\tawayrecord = str(game['awayTeam']['wins']) + '-' + str(game['awayTeam']['losses'])\n\t\t\thomerecord = str(game['homeTeam']['wins']) + '-' + str(game['homeTeam']['losses'])\n\n\t\t\thome = (game['homeTeam']['teamCity'] + '-' + game['homeTeam']['teamName']).replace(' ', '-').lower()\n\t\t\taway = (game['awayTeam']['teamCity'] + '-' + game['awayTeam']['teamName']).replace(' ', '-').lower()\n\t\t\tif home == 'la-clippers':\n\t\t\t\thome = 'l-a-clippers'\n\t\t\tif away == 'la-clippers':\n\t\t\t\taway = 'l-a-clippers'\n\n\t\t\tgamelink = r'/basketball/nba/{0}-{1}-{2}'.format(away, home, game['gameCode'][0:game['gameCode'].find(r'/')])\n\t\t\tprint(awayteam,\"@\",hometeam)\n\n\t\t\ttry:\n\t\t\t\tif disp_live_odds == True and game['gameStatus'] == 2 and spreads_data_live is not None:\n\t\t\t\t\tspread = spreads_data_live[gamelink]['spread']\n\t\t\t\t\tover_under = spreads_data_live[gamelink]['over_under']\n\t\t\t\telse:\n\t\t\t\t\tspread = spreads_data[gamelink]['spread']\n\t\t\t\t\tover_under = spreads_data[gamelink]['over_under']\n\n\t\t\texcept KeyError:\n\t\t\t\tprint('No spreads for this game.')\n\t\t\t\tspread = ''\n\t\t\t\tover_under = ''\n\n\t\t\tfor line in range(0,32):\n\t\t\t\tgraphics.DrawLine(canvas, 0, line, 64, line, graphics.Color(0, 0, 0))\n\t\t\tfor line in range(10,19):\n\t\t\t\ttry:\n\t\t\t\t\tgraphics.DrawLine(canvas, 0, line, 18, line, graphics.Color(self.team_colors[hometeam][0][0], self.team_colors[hometeam][0][1], self.team_colors[hometeam][0][2]))\n\t\t\t\texcept:\n\t\t\t\t\tgraphics.DrawLine(canvas, 0, line, 18, line, graphics.Color(255, 0, 0))\n\t\t\tfor line in range(0,9):\n\t\t\t\ttry:\n\t\t\t\t\tgraphics.DrawLine(canvas, 0, line, 18, line, graphics.Color(self.team_colors[awayteam][0][0], self.team_colors[awayteam][0][1], self.team_colors[awayteam][0][2]))\n\t\t\t\texcept:\n\t\t\t\t\tgraphics.DrawLine(canvas, 0, line, 18, line, graphics.Color(0, 0, 255))\n\t\t\thomescore = game['homeTeam']['score']\n\t\t\tawayscore = game['awayTeam']['score']\n\n\t\t\tif game['gameStatus'] != 1: #not upcoming game\n\t\t\t\tfor line in range(10,19):\n\t\t\t\t\tgraphics.DrawLine(canvas, 19, line, 38, line, graphics.Color(255, 255, 255))\n\t\t\t\tfor line in range(0,9):\n\t\t\t\t\tgraphics.DrawLine(canvas, 19, line, 38, line, graphics.Color(255, 255, 255))\n\t\t\t\tif spread != \"\":\n\t\t\t\t\tif (homescore-awayscore) >= float(spread)*(-1):\n\t\t\t\t\t\tgraphics.DrawText(canvas, self.font2, 64 - len(str(over_under))*4, 7, graphics.Color(0, 0, 255), over_under)\n\t\t\t\t\t\tgraphics.DrawText(canvas, self.font2, 64 - len(str(spread))*4, 17, graphics.Color(0, 0, 255), spread)\n\t\t\t\t\telse:\n\t\t\t\t\t\taway_spread = float(spread)*(-1)\n\t\t\t\t\t\tgraphics.DrawText(canvas, self.font2, 64 - len(str(over_under))*4, 17, graphics.Color(0, 0, 255), over_under)\n\t\t\t\t\t\tgraphics.DrawText(canvas, self.font2, 64 - len(str(away_spread))*4, 7, graphics.Color(0, 0, 255), str(away_spread))\n\t\t\t\telse:\n\t\t\t\t\tgraphics.DrawText(canvas, self.font2, 64 - len(str(over_under))*4, 7, graphics.Color(0, 0, 255), over_under)\n\t\t\t\t\tgraphics.DrawText(canvas, self.font2, 64 - len(str(spread))*4, 17, graphics.Color(0, 0, 255), spread)\n\t\t\telse:\n\t\t\t\tgraphics.DrawText(canvas, self.font2, 64 - len(str(over_under))*4, 7, graphics.Color(0, 0, 255), over_under)\n\t\t\t\tgraphics.DrawText(canvas, self.font2, 64 - len(str(spread))*4, 17, graphics.Color(0, 0, 255), spread)\n\n\t\t\ttry:\n\t\t\t\tgraphics.DrawText(canvas, self.font, 1, 18, graphics.Color(self.team_colors[hometeam][1][0], self.team_colors[hometeam][1][1], self.team_colors[hometeam][1][2]), hometeam)\n\t\t\t\tgraphics.DrawText(canvas, self.font, 1, 8, graphics.Color(self.team_colors[awayteam][1][0], self.team_colors[awayteam][1][1], self.team_colors[awayteam][1][2]), awayteam)\n\t\t\texcept:\n\t\t\t\tgraphics.DrawText(canvas, self.font, 1, 18, graphics.Color(255, 255, 255), hometeam)\n\t\t\t\tgraphics.DrawText(canvas, self.font, 1, 8, graphics.Color(255, 255, 255), awayteam)\n\n\t\t\t# NBA Logo\n\t\t\tfor line in range(20,30):\n\t\t\t\tgraphics.DrawLine(canvas, 58, line, 60, line, graphics.Color(0, 0, 255))\n\t\t\t\tgraphics.DrawLine(canvas, 60, line, 61, line, graphics.Color(255, 0, 0))\n\t\t\t\tgraphics.DrawLine(canvas, 60, line, 60, line, graphics.Color(255, 255, 255))\n\t\t\tfor line in range(22,26):\n\t\t\t\tgraphics.DrawLine(canvas, 58, line, 58, line, graphics.Color(255, 255, 255))\n\t\t\tfor line in range(21,27):\n\t\t\t\tgraphics.DrawLine(canvas, 59, line, 59, line, graphics.Color(255, 255, 255))\n\t\t\tfor line in range(24,26):\n\t\t\t\tgraphics.DrawLine(canvas, 61, line, 61, line, graphics.Color(255, 255, 255))\n\n\t\t\tperiod = game['period']\n\t\t\ttimeremaining = game['gameStatusText']\n\t\t\tif timeremaining[0] == 'Q' or timeremaining[0] == 'O':\n\t\t\t\tif period <= 5 and timeremaining[3] == '0':\n\t\t\t\t\ttimeremaining = timeremaining[:3] + timeremaining[4:]\n\t\t\t\t\tif timeremaining[3] == '0':\n\t\t\t\t\t\ttimeremaining = timeremaining[:3] + timeremaining[4:]\n\t\t\t\tif period > 5 and timeremaining[4] == '0':\n\t\t\t\t\ttimeremaining = timeremaining[:4] + timeremaining[5:]\n\t\t\t\t\tif timeremaining[4] == '0':\n\t\t\t\t\t\ttimeremaining = timeremaining[:4] + timeremaining[5:]\n\t\t\t\tif period == 1:\n\t\t\t\t\ttimeremaining = '1ST' + timeremaining[2:]\n\t\t\t\tif period == 2:\n\t\t\t\t\ttimeremaining = '2ND' + timeremaining[2:]\n\t\t\t\tif period == 3:\n\t\t\t\t\ttimeremaining = '3RD' + timeremaining[2:]\n\t\t\t\tif period == 4:\n\t\t\t\t\ttimeremaining = '4TH' + timeremaining[2:]\n\t\t\t\tif period == 5:\n\t\t\t\t\ttimeremaining = 'OT ' + timeremaining[3:]\n\t\t\t\tif period == 6:\n\t\t\t\t\ttimeremaining = 'OT2' + timeremaining[3:]\n\t\t\t\tif period == 7:\n\t\t\t\t\ttimeremaining = 'OT3' + timeremaining[3:]\n\t\t\t\tif period == 8:\n\t\t\t\t\ttimeremaining = 'OT4' + timeremaining[3:]\n\t\t\tif timeremaining == 'Half':\n\t\t\t\ttimeremaining = 'HALFTIME'\n\n\t\t\ttimeremaining = timeremaining.upper()\n\n\t\t\tif game['gameStatus'] == 2: #game is live\n\t\t\t\tgraphics.DrawText(canvas, self.font, 35 - len(str(awayscore))*5, 8, graphics.Color(0, 0, 0), str(awayscore))\n\t\t\t\tgraphics.DrawText(canvas, self.font, 35 - len(str(homescore))*5, 18, graphics.Color(0, 0, 0), str(homescore))\n\t\t\t\tif ((period >= 4) and (game['gameStatusText'][3] == '0' and game['gameStatusText'][4] <= '4')) or period > 4: #Q4 or OT < 5min remaining\n\t\t\t\t\tif homescore > awayscore:\n\t\t\t\t\t\tif (homescore - awayscore) <= 10: #close game\n\t\t\t\t\t\t\tstart_time = time.time()\n\t\t\t\t\t\t\tseconds = 5\n\t\t\t\t\t\t\twhile True:\n\t\t\t\t\t\t\t\tcurrent_time = time.time()\n\t\t\t\t\t\t\t\telapsed_time = current_time - start_time\n\t\t\t\t\t\t\t\ti = 50\n\t\t\t\t\t\t\t\tfor line in range(0,100):\n\t\t\t\t\t\t\t\t\ti += 2\n\t\t\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 28, graphics.Color(i, i, i), timeremaining) #bright quarter and time remaining\n\t\t\t\t\t\t\t\t\tgraphics.DrawLine(canvas2, 0, 31, line, 31, graphics.Color(255, 0, 0)) #red line at bottom of screen\n\t\t\t\t\t\t\t\t\tcanvas2 = matrix.SwapOnVSync(canvas)\n\t\t\t\t\t\t\t\t\ttime.sleep(.008)\n\t\t\t\t\t\t\t\tfor line2 in range(0,100):\n\t\t\t\t\t\t\t\t\ti -= 2\n\t\t\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 28, graphics.Color(i, i, i), timeremaining) #bright quarter and time remaining\n\t\t\t\t\t\t\t\t\tgraphics.DrawLine(canvas2, 0, 31, line2, 31, graphics.Color(0, 0, 0)) #red line at bottom of screen\n\t\t\t\t\t\t\t\t\tcanvas2 = matrix.SwapOnVSync(canvas)\n\t\t\t\t\t\t\t\t\ttime.sleep(.008)\n\t\t\t\t\t\t\t\tif elapsed_time > seconds:\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tif timeremaining[0] == '1':\n\t\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 1, 28, graphics.Color(200, 200, 200), timeremaining)\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 28, graphics.Color(200, 200, 200), timeremaining)\n\t\t\t\t\telse:\n\t\t\t\t\t\tif (awayscore - homescore) <= 10: #close game\n\t\t\t\t\t\t\tstart_time = time.time()\n\t\t\t\t\t\t\tseconds = 5\n\t\t\t\t\t\t\twhile True:\n\t\t\t\t\t\t\t\tcurrent_time = time.time()\n\t\t\t\t\t\t\t\telapsed_time = current_time - start_time\n\t\t\t\t\t\t\t\ti = 50\n\t\t\t\t\t\t\t\tfor line in range(0,100):\n\t\t\t\t\t\t\t\t\ti += 2\n\t\t\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 28, graphics.Color(i, i, i), timeremaining) #pulse time remaining\n\t\t\t\t\t\t\t\t\tgraphics.DrawLine(canvas2, 0, 31, line, 31, graphics.Color(255, 0, 0)) #red line at bottom of screen\n\t\t\t\t\t\t\t\t\tcanvas2 = matrix.SwapOnVSync(canvas)\n\t\t\t\t\t\t\t\t\ttime.sleep(.008)\n\t\t\t\t\t\t\t\tfor line2 in range(0,100):\n\t\t\t\t\t\t\t\t\ti -= 2\n\t\t\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 28, graphics.Color(i, i, i), timeremaining) #pulse time remaining\n\t\t\t\t\t\t\t\t\tgraphics.DrawLine(canvas2, 0, 31, line2, 31, graphics.Color(0, 0, 0)) #red line at bottom of screen\n\t\t\t\t\t\t\t\t\tcanvas2 = matrix.SwapOnVSync(canvas)\n\t\t\t\t\t\t\t\t\ttime.sleep(.008)\n\t\t\t\t\t\t\t\tif elapsed_time > seconds:\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tif timeremaining[0] == '1':\n\t\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 1, 28, graphics.Color(200, 200, 200), timeremaining)\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 28, graphics.Color(200, 200, 200), timeremaining)\n\t\t\t\telse: #not a close game or not under 4min\n\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 28, graphics.Color(200, 200, 200), timeremaining)\n\n\t\t\tif game['gameStatus'] == 3: #finished game\n\t\t\t\tif homescore < awayscore:\n\t\t\t\t\tfor line in range(10,19):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 19, line, 38, line, graphics.Color(75, 75, 75))\n\t\t\t\telse:\n\t\t\t\t\tfor line in range(0,9):\n\t\t\t\t\t\tgraphics.DrawLine(canvas, 19, line, 38, line, graphics.Color(75, 75, 75))\n\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 28, graphics.Color(200, 200, 200), game['gameStatusText'].upper())\n\t\t\t\tgraphics.DrawText(canvas, self.font, 35 - len(str(awayscore))*5, 8, graphics.Color(0, 0, 0), str(awayscore))\n\t\t\t\tgraphics.DrawText(canvas, self.font, 35 - len(str(homescore))*5, 18, graphics.Color(0, 0, 0), str(homescore))\n\n\n\t\t\tif game['gameStatus'] == 1: #upcoming game\n\t\t\t\tgraphics.DrawText(canvas, self.font2, 21, 7, graphics.Color(200, 200, 200), awayrecord) #away team record\n\t\t\t\tgraphics.DrawText(canvas, self.font2, 21, 16, graphics.Color(200, 200, 200), homerecord) #home team record\n\t\t\t\tif game['gameStatusText'] != 'PPD': #upcoming game\n\t\t\t\t\tif game['gameStatusText'][0] == '1':\n\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 1, 28, graphics.Color(200, 200, 200), game['gameStatusText'][0:game['gameStatusText'].find('ET')].upper() + 'et'.upper())\n\t\t\t\t\telse:\n\t\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 28, graphics.Color(200, 200, 200), game['gameStatusText'][0:game['gameStatusText'].find('ET')].upper() + 'et'.upper())\n\t\t\t\tif game['gameStatusText'] == 'PPD': #postponed game\n\t\t\t\t\tgraphics.DrawText(canvas, self.font3, 2, 28, graphics.Color(200, 200, 200), 'POSTPONED')\n\n\n\t\t\tfor line in range(0,56):\n\t\t\t\tgraphics.DrawLine(canvas, 121, line, 125, line, graphics.Color(255, 0, 0))\n\n\n\t\t\tcanvas = matrix.SwapOnVSync(canvas)\n\t\t\ttime.sleep(5)\n", "description": null, "category": "graphics", "imports": ["from rgbmatrix import graphics, RGBMatrix, RGBMatrixOptions", "import os", "import json", "import datetime as dt", "import time", "import sys", "import signal", "import configparser"]}], [{"term": "def", "name": "op_setrgbcolor", "data": "def op_setrgbcolor(ip):\n\tblue = ip.op_stack.pop().value\n\tgreen = ip.op_stack.pop().value\n\tred = ip.op_stack.pop().value\n\tip.graphics_state.color_space = 'DeviceRGB'\n\tip.graphics_state.color = (red, green, blue)\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_setgray", "data": "def op_setgray(ip):\n\tgray = ip.op_stack.pop().value\n\tip.graphics_state.color_space = 'DeviceGray'\n\tip.graphics_state.color = (gray, gray, gray)\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_newpath", "data": "def op_newpath(ip):\n\tip.graphics_state.newpath()\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_moveto", "data": "def op_moveto(ip):\n\ty = ip.op_stack.pop().value\n\tx = ip.op_stack.pop().value\n\tip.graphics_state.moveto(x, y)\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_rmoveto", "data": "def op_rmoveto(ip):\n\ty = ip.op_stack.pop().value\n\tx = ip.op_stack.pop().value\n\tip.graphics_state.rmoveto(x, y)\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_lineto", "data": "def op_lineto(ip):\n\ty = ip.op_stack.pop().value\n\tx = ip.op_stack.pop().value\n\tip.graphics_state.lineto(x, y)\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_rlineto", "data": "def op_rlineto(ip):\n\ty = ip.op_stack.pop().value\n\tx = ip.op_stack.pop().value\n\tip.graphics_state.rlineto(x, y)\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_closepath", "data": "def op_closepath(ip):\n\tip.graphics_state.closepath()\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_stroke", "data": "def op_stroke(ip):\n\tip.page_device.stroke(ip.graphics_state)\n\tip.graphics_state.newpath()\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_fill", "data": "def op_fill(ip):\n\tip.page_device.fill(ip.graphics_state)\n\tip.graphics_state.newpath()\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_showpage", "data": "def op_showpage(ip):\n\tip.page_device.showpage(ip.graphics_state)\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_scale", "data": "def op_scale(ip):\n\tif ip.op_stack[-1].type == 'arraytype':\n\t\tmatrix = ip.op_stack.pop()\n\t\tsy = ip.op_stack.pop().value\n\t\tsx = ip.op_stack.pop().value\n\t\tip.op_stack.append(matrix)\n\t\tassert False\n\telse:\n\t\tsy = ip.op_stack.pop().value\n\t\tsx = ip.op_stack.pop().value\n\t\ta,b,c,d,tx,ty = ip.graphics_state.CTM\n\t\tip.graphics_state.CTM = [sx*a,sx*b,sy*c,sy*d,tx,ty]\n\t\tprint(f'scale {sx=} {sy=} -> {ip.graphics_state.CTM}')\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_translate", "data": "def op_translate(ip):\n\tif ip.op_stack[-1].type == 'arraytype':\n\t\tmatrix = ip.op_stack.pop()\n\t\tty = ip.op_stack.pop().value\n\t\ttx = ip.op_stack.pop().value\n\t\tip.op_stack.append(matrix)\n\t\tassert False\n\telse:\n\t\tty = ip.op_stack.pop().value\n\t\ttx = ip.op_stack.pop().value\n\t\ta,b,c,d,tx0,ty0 = ip.graphics_state.CTM\n\t\tip.graphics_state.CTM = [a,b,c,d,a*tx+c*ty+tx0, b*tx+d*ty+ty0]\n\t\tprint(f'translate {tx=} {ty=} -> {ip.graphics_state.CTM}')\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_transform", "data": "def op_transform(ip):\n\tif ip.op_stack[-1].type == 'arraytype':\n\t\tmatrix = ip.op_stack.pop()\n\t\ty = ip.op_stack.pop().value\n\t\tx = ip.op_stack.pop().value\n\t\tip.op_stack.append(x)\n\t\tip.op_stack.append(y)\n\t\tassert False\n\telse:\n\t\ty = ip.op_stack.pop().value\n\t\tx = ip.op_stack.pop().value\n\t\tx,y = ip.graphics_state.transform(x,y)\n\t\tip.op_stack.append(PSObject('realtype', x, True))\n\t\tip.op_stack.append(PSObject('realtype', y, True))\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_itransform", "data": "def op_itransform(ip):\n\tif ip.op_stack[-1].type == 'arraytype':\n\t\tmatrix = ip.op_stack.pop()\n\t\ty = ip.op_stack.pop().value\n\t\tx = ip.op_stack.pop().value\n\t\tip.op_stack.append(x)\n\t\tip.op_stack.append(y)\n\t\tassert False\n\telse:\n\t\ty = ip.op_stack.pop().value\n\t\tx = ip.op_stack.pop().value\n\t\tx,y = ip.graphics_state.itransform(x,y)\n\t\tip.op_stack.append(PSObject('realtype', x, True))\n\t\tip.op_stack.append(PSObject('realtype', y, True))\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_matrix", "data": "def op_matrix(ip):\n\tzero = PSObject('realtype', 0.0, True)\n\tone = PSObject('realtype', 1.0, True)\n\tip.op_stack.append(PSObject('arraytype', [one, zero, zero, one, zero, zero], True))\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_currentmatrix", "data": "def op_currentmatrix(ip):\n\tip.op_stack[-1].value = [PSObject('realtype', x, True) for x in ip.graphics_state.CTM]\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_setmatrix", "data": "def op_setmatrix(ip):\n\tmat = ip.op_stack.pop()\n\tip.graphics_state.CTM = [x.value for x in mat.value]\n\tprint(f'setmatrix -> {ip.graphics_state.CTM}')\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_gsave", "data": "def op_gsave(ip):\n\tip.gsave()\n\tprint('gsave !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_grestore", "data": "def op_grestore(ip):\n\tip.grestore()\n\tprint('restore !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}, {"term": "def", "name": "op_imagemask", "data": "def op_imagemask(ip):\n\td = ip.op_stack.pop()\n\tif d.type == 'dicttype':\n\t\traise NotImplementedError\n\telse:\n\t\tdatasrc = d\n\t\tmatrix = ip.op_stack.pop()\n\t\tpolarity = ip.op_stack.pop().value\n\t\theight = ip.op_stack.pop().value\n\t\twidth = ip.op_stack.pop().value\n\timagedata = ''\n\twhile True:\n\t\tip.execsub(iter(datasrc.value))\n\t\tret = ip.op_stack.pop().value\n\t\tif not ret:\n\t\t\tbreak\n\t\timagedata += ret\n\t\tif len(imagedata)*8 >= width*height:\n\t\t\tbreak\n\tip.page_device.imagemask((width, height), imagedata.encode('latin1'), polarity, [x.value for x in matrix.value], ip.graphics_state)\n", "description": null, "category": "graphics", "imports": ["from psobject import PSObject"]}], [], [], [{"term": "class", "name": "_SettingsCore", "data": "class _SettingsCore(object):\n\tonSettingsChanged = Event.Event()\n\n\tdef init(self):\n\t\tfrom account_helpers.settings_core import options, settings_storages, settings_constants\n\t\tfrom gui.shared.utils import graphics\n\t\tGAME = settings_constants.GAME\n\t\tTUTORIAL = settings_constants.TUTORIAL\n\t\tGRAPHICS = settings_constants.GRAPHICS\n\t\tSOUND = settings_constants.SOUND\n\t\tCONTROLS = settings_constants.CONTROLS\n\t\tAIM = settings_constants.AIM\n\t\tMARKERS = settings_constants.MARKERS\n\t\tOTHER = settings_constants.OTHER\n\t\tself.__serverSettings = ServerSettingsManager(self)\n\t\tself.interfaceScale = InterfaceScaleManager(self)\n\t\tVIDEO_SETTINGS_STORAGE = settings_storages.VideoSettingsStorage(self.serverSettings, self)\n\t\tGAME_SETTINGS_STORAGE = settings_storages.GameSettingsStorage(self.serverSettings, self)\n\t\tEXTENDED_GAME_SETTINGS_STORAGE = settings_storages.ExtendedGameSettingsStorage(self.serverSettings, self)\n\t\tTUTORIAL_SETTINGS_STORAGE = settings_storages.TutorialStorage(self.serverSettings, self)\n\t\tGAMEPLAY_SETTINGS_STORAGE = settings_storages.GameplaySettingsStorage(self.serverSettings, self)\n\t\tGRAPHICS_SETTINGS_STORAGE = settings_storages.GraphicsSettingsStorage(self.serverSettings, self)\n\t\tSOUND_SETTINGS_STORAGE = settings_storages.SoundSettingsStorage(self.serverSettings, self)\n\t\tKEYBOARD_SETTINGS_STORAGE = settings_storages.KeyboardSettingsStorage(self.serverSettings, self)\n\t\tCONTROLS_SETTINGS_STORAGE = settings_storages.ControlsSettingsStorage(self.serverSettings, self)\n\t\tAIM_SETTINGS_STORAGE = settings_storages.AimSettingsStorage(self.serverSettings, self)\n\t\tMARKERS_SETTINGS_STORAGE = settings_storages.MarkersSettingsStorage(self.serverSettings, self)\n\t\tMARK_ON_GUN_SETTINGS_STORAGE = settings_storages.MarksOnGunSettingsStorage(self.serverSettings, self)\n\t\tFOV_SETTINGS_STORAGE = settings_storages.FOVSettingsStorage(self.serverSettings, self)\n\t\tMESSENGER_SETTINGS_STORAGE = settings_storages.MessengerSettingsStorage(GAME_SETTINGS_STORAGE)\n\t\tEXTENDED_MESSENGER_SETTINGS_STORAGE = settings_storages.MessengerSettingsStorage(EXTENDED_GAME_SETTINGS_STORAGE)\n\t\tself.__storages = {'game': GAME_SETTINGS_STORAGE,\n\t\t 'extendedGame': EXTENDED_GAME_SETTINGS_STORAGE,\n\t\t 'gameplay': GAMEPLAY_SETTINGS_STORAGE,\n\t\t 'sound': SOUND_SETTINGS_STORAGE,\n\t\t 'keyboard': KEYBOARD_SETTINGS_STORAGE,\n\t\t 'controls': CONTROLS_SETTINGS_STORAGE,\n\t\t 'aim': AIM_SETTINGS_STORAGE,\n\t\t 'markers': MARKERS_SETTINGS_STORAGE,\n\t\t 'graphics': GRAPHICS_SETTINGS_STORAGE,\n\t\t 'video': VIDEO_SETTINGS_STORAGE,\n\t\t 'messenger': MESSENGER_SETTINGS_STORAGE,\n\t\t 'extendedMessenger': EXTENDED_MESSENGER_SETTINGS_STORAGE,\n\t\t 'marksOnGun': MARK_ON_GUN_SETTINGS_STORAGE,\n\t\t 'FOV': FOV_SETTINGS_STORAGE,\n\t\t 'tutorial': TUTORIAL_SETTINGS_STORAGE}\n\t\tself.isDeviseRecreated = False\n\t\tself.isChangesConfirmed = True\n\t\tself.__options = options.SettingsContainer(((GAME.REPLAY_ENABLED, options.ReplaySetting(GAME.REPLAY_ENABLED, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.ENABLE_SERVER_AIM, options.StorageAccountSetting(GAME.ENABLE_SERVER_AIM, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.MINIMAP_ALPHA, options.StorageAccountSetting(GAME.MINIMAP_ALPHA, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.ENABLE_POSTMORTEM, options.PostProcessingSetting(GAME.ENABLE_POSTMORTEM, 'mortem_post_effect', storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.ENABLE_POSTMORTEM_DELAY, options.PostMortemDelaySetting(GAME.ENABLE_POSTMORTEM_DELAY, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.SHOW_VEHICLES_COUNTER, options.StorageAccountSetting(GAME.SHOW_VEHICLES_COUNTER, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.SHOW_BATTLE_EFFICIENCY_RIBBONS, options.ExcludeInReplayAccountSetting(GAME.SHOW_BATTLE_EFFICIENCY_RIBBONS, storage=EXTENDED_GAME_SETTINGS_STORAGE)),\n\t\t (GAME.SHOW_MARKS_ON_GUN, options.ShowMarksOnGunSetting(GAME.SHOW_MARKS_ON_GUN, storage=MARK_ON_GUN_SETTINGS_STORAGE)),\n\t\t (GAME.DYNAMIC_CAMERA, options.DynamicCamera(GAME.DYNAMIC_CAMERA, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.SNIPER_MODE_STABILIZATION, options.SniperModeStabilization(GAME.SNIPER_MODE_STABILIZATION, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.ENABLE_OL_FILTER, options.MessengerSetting(GAME.ENABLE_OL_FILTER, storage=MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.ENABLE_SPAM_FILTER, options.MessengerSetting(GAME.ENABLE_SPAM_FILTER, storage=MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.SHOW_DATE_MESSAGE, options.MessengerDateTimeSetting(1, storage=MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.SHOW_TIME_MESSAGE, options.MessengerDateTimeSetting(2, storage=MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.INVITES_FROM_FRIENDS, options.MessengerSetting(GAME.INVITES_FROM_FRIENDS, storage=MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.RECEIVE_CLAN_INVITES_NOTIFICATIONS, options.ClansSetting(GAME.RECEIVE_CLAN_INVITES_NOTIFICATIONS, storage=EXTENDED_GAME_SETTINGS_STORAGE)),\n\t\t (GAME.RECEIVE_FRIENDSHIP_REQUEST, options.MessengerSetting(GAME.RECEIVE_FRIENDSHIP_REQUEST, storage=MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.RECEIVE_INVITES_IN_BATTLE, options.MessengerSetting(GAME.RECEIVE_INVITES_IN_BATTLE, storage=EXTENDED_MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.STORE_RECEIVER_IN_BATTLE, options.MessengerSetting(GAME.STORE_RECEIVER_IN_BATTLE, storage=MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.DISABLE_BATTLE_CHAT, options.MessengerSetting(GAME.DISABLE_BATTLE_CHAT, storage=MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.CHAT_CONTACTS_LIST_ONLY, options.MessengerSetting(GAME.CHAT_CONTACTS_LIST_ONLY, storage=EXTENDED_MESSENGER_SETTINGS_STORAGE)),\n\t\t (GAME.PLAYERS_PANELS_SHOW_LEVELS, options.PlayersPanelSetting(GAME.PLAYERS_PANELS_SHOW_LEVELS, 'players_panel', 'showLevels', storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.PLAYERS_PANELS_SHOW_TYPES, options.AccountDumpSetting(GAME.PLAYERS_PANELS_SHOW_TYPES, 'players_panel', 'showTypes')),\n\t\t (GAME.PLAYERS_PANELS_STATE, options.AccountDumpSetting(GAME.PLAYERS_PANELS_STATE, 'players_panel', 'state')),\n\t\t (GAME.SNIPER_MODE_SWINGING_ENABLED, options.SniperModeSwingingSetting()),\n\t\t (GAME.GAMEPLAY_CTF, options.GameplaySetting(GAME.GAMEPLAY_MASK, 'ctf', storage=GAMEPLAY_SETTINGS_STORAGE)),\n\t\t (GAME.GAMEPLAY_DOMINATION, options.GameplaySetting(GAME.GAMEPLAY_MASK, 'domination', storage=GAMEPLAY_SETTINGS_STORAGE)),\n\t\t (GAME.GAMEPLAY_ASSAULT, options.GameplaySetting(GAME.GAMEPLAY_MASK, 'assault', storage=GAMEPLAY_SETTINGS_STORAGE)),\n\t\t (GAME.GAMEPLAY_NATIONS, options.GameplaySetting(GAME.GAMEPLAY_MASK, 'nations', storage=GAMEPLAY_SETTINGS_STORAGE)),\n\t\t (GAME.LENS_EFFECT, options.LensEffectSetting(GAME.LENS_EFFECT, storage=GRAPHICS_SETTINGS_STORAGE)),\n\t\t (GAME.SHOW_VECTOR_ON_MAP, options.MinimapSetting(GAME.SHOW_VECTOR_ON_MAP, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.SHOW_SECTOR_ON_MAP, options.MinimapSetting(GAME.SHOW_SECTOR_ON_MAP, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GAME.SHOW_VEH_MODELS_ON_MAP, options.MinimapVehModelsSetting(GAME.SHOW_VEH_MODELS_ON_MAP, storage=GAME_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.MONITOR, options.MonitorSetting(storage=VIDEO_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.WINDOW_SIZE, options.WindowSizeSetting(storage=VIDEO_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.RESOLUTION, options.ResolutionSetting(storage=VIDEO_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.REFRESH_RATE, options.RefreshRateSetting(storage=VIDEO_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.FULLSCREEN, options.FullscreenSetting(storage=VIDEO_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.COLOR_BLIND, options.AccountDumpSetting(GRAPHICS.COLOR_BLIND, GRAPHICS.COLOR_BLIND)),\n\t\t (GRAPHICS.GRAPHICS_QUALITY_HD_SD, options.GraphicsQualityNote()),\n\t\t (GRAPHICS.GAMMA, options.GammaSetting()),\n\t\t (GRAPHICS.TRIPLE_BUFFERED, options.TripleBufferedSetting()),\n\t\t (GRAPHICS.VERTICAL_SYNC, options.VerticalSyncSetting()),\n\t\t (GRAPHICS.MULTISAMPLING, options.MultisamplingSetting()),\n\t\t (GRAPHICS.CUSTOM_AA, options.CustomAASetting()),\n\t\t (GRAPHICS.ASPECT_RATIO, options.AspectRatioSetting()),\n\t\t (GRAPHICS.FPS_PERFOMANCER, options.FPSPerfomancerSetting(GRAPHICS.FPS_PERFOMANCER, storage=GRAPHICS_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.DRR_AUTOSCALER_ENABLED, options.GraphicSetting(GRAPHICS.DRR_AUTOSCALER_ENABLED)),\n\t\t (GRAPHICS.DYNAMIC_RENDERER, options.DynamicRendererSetting()),\n\t\t (GRAPHICS.COLOR_FILTER_INTENSITY, options.ColorFilterIntensitySetting()),\n\t\t (GRAPHICS.COLOR_FILTER_IMAGES, options.ReadOnlySetting(lambda : graphics.getGraphicSettingImages(GRAPHICS.COLOR_GRADING_TECHNIQUE))),\n\t\t (GRAPHICS.FOV, options.FOVSetting(GRAPHICS.FOV, storage=FOV_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.DYNAMIC_FOV_ENABLED, options.DynamicFOVEnabledSetting(storage=FOV_SETTINGS_STORAGE)),\n\t\t (GRAPHICS.PRESETS, options.GraphicsPresetSetting()),\n\t\t (GRAPHICS.RENDER_PIPELINE, options.GraphicSetting(GRAPHICS.RENDER_PIPELINE)),\n\t\t (GRAPHICS.TEXTURE_QUALITY, options.TextureQualitySetting()),\n\t\t (GRAPHICS.DECALS_QUALITY, options.GraphicSetting(GRAPHICS.DECALS_QUALITY)),\n\t\t (GRAPHICS.OBJECT_LOD, options.GraphicSetting(GRAPHICS.OBJECT_LOD)),\n\t\t (GRAPHICS.FAR_PLANE, options.GraphicSetting(GRAPHICS.FAR_PLANE)),\n\t\t (GRAPHICS.TERRAIN_QUALITY, options.TerrainQualitySetting()),\n\t\t (GRAPHICS.SHADOWS_QUALITY, options.GraphicSetting(GRAPHICS.SHADOWS_QUALITY)),\n\t\t (GRAPHICS.LIGHTING_QUALITY, options.GraphicSetting(GRAPHICS.LIGHTING_QUALITY)),\n\t\t (GRAPHICS.SPEEDTREE_QUALITY, options.GraphicSetting(GRAPHICS.SPEEDTREE_QUALITY)),\n\t\t (GRAPHICS.FLORA_QUALITY, options.FloraQualitySetting()),\n\t\t (GRAPHICS.WATER_QUALITY, options.GraphicSetting(GRAPHICS.WATER_QUALITY)),\n\t\t (GRAPHICS.EFFECTS_QUALITY, options.GraphicSetting(GRAPHICS.EFFECTS_QUALITY)),\n\t\t (GRAPHICS.POST_PROCESSING_QUALITY, options.GraphicSetting(GRAPHICS.POST_PROCESSING_QUALITY)),\n\t\t (GRAPHICS.MOTION_BLUR_QUALITY, options.GraphicSetting(GRAPHICS.MOTION_BLUR_QUALITY)),\n\t\t (GRAPHICS.SNIPER_MODE_EFFECTS_QUALITY, options.GraphicSetting(GRAPHICS.SNIPER_MODE_EFFECTS_QUALITY)),\n\t\t (GRAPHICS.VEHICLE_DUST_ENABLED, options.GraphicSetting(GRAPHICS.VEHICLE_DUST_ENABLED)),\n\t\t (GRAPHICS.SNIPER_MODE_GRASS_ENABLED, options.GraphicSetting(GRAPHICS.SNIPER_MODE_GRASS_ENABLED)),\n\t\t (GRAPHICS.VEHICLE_TRACES_ENABLED, options.GraphicSetting(GRAPHICS.VEHICLE_TRACES_ENABLED)),\n\t\t (GRAPHICS.COLOR_GRADING_TECHNIQUE, options.GraphicSetting(GRAPHICS.COLOR_GRADING_TECHNIQUE)),\n\t\t (GRAPHICS.SEMITRANSPARENT_LEAVES_ENABLED, options.GraphicSetting(GRAPHICS.SEMITRANSPARENT_LEAVES_ENABLED)),\n\t\t (GRAPHICS.GRAPHICS_SETTINGS_LIST, options.ReadOnlySetting(lambda : graphics.GRAPHICS_SETTINGS.ALL())),\n\t\t (GRAPHICS.INTERFACE_SCALE, options.InterfaceScaleSetting(GRAPHICS.INTERFACE_SCALE)),\n\t\t (SOUND.MASTER, options.SoundSetting('master')),\n\t\t (SOUND.MUSIC, options.SoundSetting('music')),\n\t\t (SOUND.VOICE, options.SoundSetting('voice')),\n\t\t (SOUND.VEHICLES, options.SoundSetting('vehicles')),\n\t\t (SOUND.EFFECTS, options.SoundSetting('effects')),\n\t\t (SOUND.GUI, options.SoundSetting('gui')),\n\t\t (SOUND.AMBIENT, options.SoundSetting('ambient')),\n\t\t (SOUND.NATIONS_VOICES, options.AccountSetting('nationalVoices')),\n\t\t (SOUND.VOIP_MASTER_FADE, options.SoundSetting('masterFadeVivox')),\n\t\t (SOUND.VOIP_ENABLE, options.VOIPSetting(True)),\n\t\t (SOUND.VOIP_MASTER, options.VOIPMasterSoundSetting()),\n\t\t (SOUND.VOIP_MIC, options.VOIPMicSoundSetting(True)),\n\t\t (SOUND.CAPTURE_DEVICES, options.VOIPCaptureDevicesSetting()),\n\t\t (SOUND.VOIP_SUPPORTED, options.VOIPSupportSetting()),\n\t\t (SOUND.ALT_VOICES, options.AltVoicesSetting(SOUND.ALT_VOICES, storage=SOUND_SETTINGS_STORAGE)),\n\t\t (CONTROLS.MOUSE_ARCADE_SENS, options.MouseSensitivitySetting('arcade')),\n\t\t (CONTROLS.MOUSE_SNIPER_SENS, options.MouseSensitivitySetting('sniper')),\n\t\t (CONTROLS.MOUSE_STRATEGIC_SENS, options.MouseSensitivitySetting('strategic')),\n\t\t (CONTROLS.MOUSE_HORZ_INVERSION, options.MouseInversionSetting(CONTROLS.MOUSE_HORZ_INVERSION, 'horzInvert', storage=CONTROLS_SETTINGS_STORAGE)),\n\t\t (CONTROLS.MOUSE_VERT_INVERSION, options.MouseInversionSetting(CONTROLS.MOUSE_VERT_INVERSION, 'vertInvert', storage=CONTROLS_SETTINGS_STORAGE)),\n\t\t (CONTROLS.BACK_DRAFT_INVERSION, options.BackDraftInversionSetting(storage=CONTROLS_SETTINGS_STORAGE)),\n\t\t (CONTROLS.KEYBOARD, options.KeyboardSettings(storage=KEYBOARD_SETTINGS_STORAGE)),\n\t\t (AIM.ARCADE, options.AimSetting('arcade', storage=AIM_SETTINGS_STORAGE)),\n\t\t (AIM.SNIPER, options.AimSetting('sniper', storage=AIM_SETTINGS_STORAGE)),\n\t\t (MARKERS.ENEMY, options.VehicleMarkerSetting(MARKERS.ENEMY, storage=MARKERS_SETTINGS_STORAGE)),\n\t\t (MARKERS.DEAD, options.VehicleMarkerSetting(MARKERS.DEAD, storage=MARKERS_SETTINGS_STORAGE)),\n\t\t (MARKERS.ALLY, options.VehicleMarkerSetting(MARKERS.ALLY, storage=MARKERS_SETTINGS_STORAGE)),\n\t\t (OTHER.VIBRO_CONNECTED, options.ReadOnlySetting(lambda : VibroManager.g_instance.connect())),\n\t\t (OTHER.VIBRO_GAIN, options.VibroSetting('master')),\n\t\t (OTHER.VIBRO_ENGINE, options.VibroSetting('engine')),\n\t\t (OTHER.VIBRO_ACCELERATION, options.VibroSetting('acceleration')),\n\t\t (OTHER.VIBRO_SHOTS, options.VibroSetting('shots')),\n\t\t (OTHER.VIBRO_HITS, options.VibroSetting('hits')),\n\t\t (OTHER.VIBRO_COLLISIONS, options.VibroSetting('collisions')),\n\t\t (OTHER.VIBRO_DAMAGE, options.VibroSetting('damage')),\n\t\t (OTHER.VIBRO_GUI, options.VibroSetting('gui')),\n\t\t (TUTORIAL.CUSTOMIZATION, options.TutorialSetting(TUTORIAL.CUSTOMIZATION, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.TECHNICAL_MAINTENANCE, options.TutorialSetting(TUTORIAL.TECHNICAL_MAINTENANCE, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.PERSONAL_CASE, options.TutorialSetting(TUTORIAL.PERSONAL_CASE, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.RESEARCH, options.TutorialSetting(TUTORIAL.RESEARCH, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.RESEARCH_TREE, options.TutorialSetting(TUTORIAL.RESEARCH_TREE, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.MEDKIT_USED, options.TutorialSetting(TUTORIAL.MEDKIT_USED, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.REPAIRKIT_USED, options.TutorialSetting(TUTORIAL.REPAIRKIT_USED, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.FIRE_EXTINGUISHER_USED, options.TutorialSetting(TUTORIAL.FIRE_EXTINGUISHER_USED, storage=TUTORIAL_SETTINGS_STORAGE)),\n\t\t (TUTORIAL.WAS_QUESTS_TUTORIAL_STARTED, options.TutorialSetting(TUTORIAL.WAS_QUESTS_TUTORIAL_STARTED, storage=TUTORIAL_SETTINGS_STORAGE))))\n\t\tself.__options.init()\n\t\tAccountSettings.onSettingsChanging += self.__onAccountSettingsChanging\n\t\tself.interfaceScale.init()\n\t\tLOG_DEBUG('SettingsCore is initialized')\n\n\tdef fini(self):\n\t\tself.options.dump()\n\t\tself.__storages = None\n\t\tself.__options = None\n\t\tself.__serverSettings = None\n\t\tself.interfaceScale.fini()\n\t\tAccountSettings.onSettingsChanging -= self.__onAccountSettingsChanging\n\t\tAccountSettings.clearCache()\n\t\tLOG_DEBUG('SettingsCore is destroyed')\n\t\treturn\n\n\t@property\n\tdef options(self):\n\t\treturn self.__options\n\n\t@property\n\tdef storages(self):\n\t\treturn self.__storages\n\n\t@property\n\tdef serverSettings(self):\n\t\treturn self.__serverSettings\n\n\tdef packSettings(self, names):\n\t\treturn self.__options.pack(names)\n\n\tdef getSetting(self, name):\n\t\treturn self.__options.getSetting(name).get()\n\n\tdef getApplyMethod(self, diff):\n\t\treturn self.__options.getApplyMethod(diff)\n\n\tdef applySetting(self, key, value):\n\t\tif self.isSettingChanged(key, value):\n\t\t\tresult = self.__options.getSetting(key).apply(value)\n\t\t\tfrom account_helpers.settings_core import settings_constants\n\t\t\tif key in settings_constants.GRAPHICS.ALL():\n\t\t\t\tLOG_DEBUG('Apply graphic settings: ', {key: value})\n\t\t\t\tself.onSettingsChanged({key: value})\n\t\t\treturn result\n\t\telse:\n\t\t\treturn None\n\n\tdef previewSetting(self, name, value):\n\t\tif self.isSettingChanged(name, value):\n\t\t\tself.__options.getSetting(name).preview(value)\n\n\tdef applySettings(self, diff):\n\t\tself.__options.apply(diff)\n\t\tfrom account_helpers.settings_core import settings_constants\n\t\tgraphicsSettings = {k:v for k, v in diff.iteritems() if k in settings_constants.GRAPHICS.ALL()}\n\t\tif graphicsSettings:\n\t\t\tLOG_DEBUG('Apply graphic settings: ', graphicsSettings)\n\t\t\tself.onSettingsChanged(graphicsSettings)\n\n\tdef revertSettings(self):\n\t\tself.__options.revert()\n\n\tdef isSettingChanged(self, name, value):\n\t\treturn not self.__options.getSetting(name).isEqual(value)\n\n\tdef applyStorages(self, restartApproved):\n\t\tconfirmators = []\n\t\tfor storage in self.__storages.values():\n\t\t\tconfirmators.append(storage.apply(restartApproved))\n\n\t\treturn confirmators\n\n\t@process\n\tdef confirmChanges(self, confirmators):\n\t\tyield lambda callback: callback(None)\n\t\tfor confirmation, revert in confirmators:\n\t\t\tif confirmation is not None:\n\t\t\t\tisConfirmed = yield confirmation()\n\t\t\t\tif not isConfirmed:\n\t\t\t\t\tself.isChangesConfirmed = False\n\t\t\t\t\trevert()\n\n\t\treturn\n\n\tdef clearStorages(self):\n\t\tfor storage in self.__storages.values():\n\t\t\tstorage.clear()\n\n\tdef __onAccountSettingsChanging(self, key, value):\n\t\tLOG_DEBUG('Apply account setting: ', {key: value})\n\t\tself.onSettingsChanged({key: value})\n\n", "description": null, "category": "graphics", "imports": ["import Event", "from InterfaceScaleManager import InterfaceScaleManager", "from Vibroeffects import VibroManager", "from account_helpers.AccountSettings import AccountSettings", "from account_helpers.settings_core.ServerSettingsManager import ServerSettingsManager", "from adisp import process", "from debug_utils import LOG_DEBUG", "\t\tfrom account_helpers.settings_core import options, settings_storages, settings_constants", "\t\tfrom gui.shared.utils import graphics", "\t\t\tfrom account_helpers.settings_core import settings_constants", "\t\tfrom account_helpers.settings_core import settings_constants"]}], [{"term": "def", "name": "main", "data": "def main():\n\tprint(f'Health:{hp}')\n\tonmouseclicked(play)\n\tscore_label.font = '-25'\n\tgraphics.window.add(score_label)\n\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.graphics.gobjects import GLabel", "from campy.gui.events.mouse import onmouseclicked"]}, {"term": "def", "name": "play", "data": "def play(mouse):\n\tglobal is_playing\n\tglobal score\n\tglobal score_label\n\tglobal dx\n\tglobal dy\n\tglobal hp\n\tglobal time\n\tif not is_playing:\n\t\tis_playing = True\n\t\twhile is_playing:\n\t\t\tgraphics.ball.move(dx, dy)\n\t\t\tmaybe_object1 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y)\n\t\t\tmaybe_object2 = graphics.window.get_object_at(graphics.ball.x + graphics.ball.width, graphics.ball.y)\n\t\t\tmaybe_object3 = graphics.window.get_object_at(graphics.ball.x, graphics.ball.y + graphics.ball.height)\n\t\t\tmaybe_object4 = graphics.window.get_object_at(graphics.ball.x + graphics.ball.width, graphics.ball.y\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  + graphics.ball.height)\n\t\t\tif graphics.ball.x <= 0 or graphics.ball.x + graphics.ball.height >= graphics.window.width:\n\t\t\t\tdx = -dx\n\t\t\tif graphics.ball.y + graphics.ball.height <= 0:\n\t\t\t\tgraphics.ball.move(0,graphics.window.height)\n\t\t\t# if graphics.ball.y + graphics.ball.height >= graphics.window.height:\n\t\t\t#\t dy = -dy\n\t\t\tif maybe_object1 is not None and maybe_object1 is not score_label:\n\t\t\t\tif maybe_object1 is not graphics.paddle:\n\t\t\t\t\tscore += 1\n\t\t\t\t\tscore_label.text = 'Score:' + str(score)\n\t\t\t\t\tgraphics.window.remove(maybe_object1)\n\t\t\t\telse:\n\t\t\t\t\tgraphics.ball.move(0,-10)\n\t\t\t\tdy = -dy\n\t\t\t\tgraphics.window.add(score_label)\n\t\t\telif maybe_object2 is not None and maybe_object2 is not score_label:\n\t\t\t\tif maybe_object2 is not graphics.paddle:\n\t\t\t\t\tscore += 1\n\t\t\t\t\tscore_label.text = 'Score:' + str(score)\n\t\t\t\t\tgraphics.window.remove(maybe_object2)\n\t\t\t\telse:\n\t\t\t\t\tgraphics.ball.move(0,-10)\n\t\t\t\tdy = -dy\n\t\t\t\tgraphics.window.add(score_label)\n\t\t\telif maybe_object3 is not None and maybe_object3 is not score_label:\n\t\t\t\tif maybe_object3 is not graphics.paddle:\n\t\t\t\t\tscore += 1\n\t\t\t\t\tscore_label.text = 'Score:' + str(score)\n\t\t\t\t\tgraphics.window.remove(maybe_object3)\n\t\t\t\telse:\n\t\t\t\t\tgraphics.ball.move(0,-10)\n\t\t\t\tdy = -dy\n\t\t\t\tgraphics.window.add(score_label)\n\t\t\telif maybe_object4 is not None and maybe_object4 is not score_label:\n\t\t\t\tif maybe_object4 is not graphics.paddle:\n\t\t\t\t\tscore += 1\n\t\t\t\t\tscore_label.text = 'Score:' + str(score)\n\t\t\t\t\tgraphics.window.remove(maybe_object4)\n\t\t\t\telse:\n\t\t\t\t\tgraphics.ball.move(0,-10)\n\t\t\t\tdy = -dy\n\t\t\t\tgraphics.window.add(score_label)\n\t\t\tif graphics.ball.y >= graphics.window.height:\n\t\t\t\thp -= 1\n\t\t\t\tgraphics.ball.move(graphics.window.width / 2 - graphics.ball.width / 2 - graphics.ball.x,\n\t\t\t\t\t\t\t\t   -graphics.window.height / 2 - graphics.ball.height / 2)\n\t\t\t\tis_playing = False\n\t\t\t\tprint(f'Health:{hp}')\n\t\t\tif hp == 0:\n\t\t\t\tgraphics.window.clear()\n\t\t\t\tlose = GLabel(\"YOU LOSE!\", graphics.window.width/2-160, graphics.window.height/2+20)\n\t\t\t\tlose.font = '-40'\n\t\t\t\tprint(f'Score:{score}')\n\t\t\t\tprint(f'Playing Times:{time*FRAME_RATE/1000}(s)')\n\t\t\t\tgraphics.window.add(lose)\n\t\t\t\tbreak\n\t\t\tif score == 100:\n\t\t\t\tgraphics.window.clear()\n\t\t\t\tlose = GLabel(\"YOU WIN!\", graphics.window.width / 2 - 160, graphics.window.height / 2 + 20)\n\t\t\t\tlose.font = '-40'\n\t\t\t\tprint(f'Score:{score}')\n\t\t\t\tprint(f'Playing Times:{time * FRAME_RATE / 1000}(s)')\n\t\t\t\tgraphics.window.add(lose)\n\t\t\t\tbreak\n\t\t\tpause(FRAME_RATE)\n\t\t\ttime += 1\n\t\tis_playing = False\n\n", "description": null, "category": "graphics", "imports": ["from campy.gui.events.timer import pause", "from breakoutgraphics import BreakoutGraphics", "from campy.graphics.gobjects import GLabel", "from campy.gui.events.mouse import onmouseclicked"]}], [{"term": "def", "name": "mouse_event", "data": "def mouse_event(event_type, posx, posy):\n\tevent = CoreGraphics.CGEventCreateMouseEvent(\n\t\tNone,\n\t\tevent_type,\n\t\t(posx, posy),\n\t\tCoreGraphics.kCGMouseButtonLeft,\n\t)\n\tCoreGraphics.CGEventPost(CoreGraphics.kCGHIDEventTap, event)\n\n", "description": null, "category": "graphics", "imports": ["import sys", "import time", "from Quartz import CoreGraphics"]}, {"term": "def", "name": "mousemove", "data": "def mousemove(posx, posy):\n\tmouse_event(CoreGraphics.kCGEventMouseMoved, posx, posy)\n\n", "description": null, "category": "graphics", "imports": ["import sys", "import time", "from Quartz import CoreGraphics"]}, {"term": "def", "name": "mouseclick", "data": "def mouseclick(posx, posy):\n\tmouse_event(CoreGraphics.kCGEventLeftMouseDown, posx, posy)\n\ttime.sleep(0.1)\n\tmouse_event(CoreGraphics.kCGEventLeftMouseUp, posx, posy)\n\n", "description": null, "category": "graphics", "imports": ["import sys", "import time", "from Quartz import CoreGraphics"]}, {"term": "def", "name": "position", "data": "def position():\n\treturn CoreGraphics.CGEventGetLocation(CoreGraphics.CGEventCreate(None))\n\n", "description": null, "category": "graphics", "imports": ["import sys", "import time", "from Quartz import CoreGraphics"]}, {"term": "def", "name": "listener", "data": "def listener():\n\tkey_tap_event = CoreGraphics.CGEventTapCreate(\n\t\tCoreGraphics.kCGHIDEventTap,\n\t\tCoreGraphics.kCGHeadInsertEventTap,\n\t\tCoreGraphics.kCGEventTapOptionListenOnly,\n\t\tCoreGraphics.CGEventMaskBit(CoreGraphics.kCGEventKeyUp),\n\t\tNone, None,\n\t)\n\tkey_up_loop = CoreGraphics.CFMachPortCreateRunLoopSource(None, key_tap_event, 0)\n\tCoreGraphics.CFRelease(key_tap_event)\n\n\tCoreGraphics.CFRunLoopAddSource(\n\t\tCoreGraphics.CFRunLoopGetCurrent(),\n\t\tkey_up_loop,\n\t\tCoreGraphics.kCFRunLoopDefaultMode,\n\t)\n\tCoreGraphics.CFRelease(key_up_loop)\n\n", "description": null, "category": "graphics", "imports": ["import sys", "import time", "from Quartz import CoreGraphics"]}, {"term": "def", "name": "char_to_key_code", "data": "def char_to_key_code(char):\n\twith_shift = False\n\n\t# Letter\n\tif char.isalpha():\n\t\tif not char.islower():\n\t\t\twith_shift = True\n\t\t\tchar = char.lower()\n\n\tif char in SHIFT_CONVERSION_MAPPING:\n\t\twith_shift = True\n\t\tchar = SHIFT_CONVERSION_MAPPING[char]\n\tif char in KEY_CODE_MAPPING:\n\t\tchar_to_key_code = KEY_CODE_MAPPING[char]\n\telse:\n\t\tchar_to_key_code = ord(char)\n\treturn char_to_key_code, with_shift\n\n", "description": null, "category": "graphics", "imports": ["import sys", "import time", "from Quartz import CoreGraphics"]}, {"term": "def", "name": "key_press", "data": "def key_press(char):\n\tkey_code, with_shift = char_to_key_code(char)\n\n\ttime.sleep(0.0001)\n\n\tif with_shift:\n\t\tCoreGraphics.CGEventPost(\n\t\t\tCoreGraphics.kCGHIDEventTap,\n\t\t\tCoreGraphics.CGEventCreateKeyboardEvent(None, KEY_CODE_MAPPING['shift'], True),\n\t\t)\n\t\ttime.sleep(0.0001)\n\n\tCoreGraphics.CGEventPost(\n\t\tCoreGraphics.kCGHIDEventTap,\n\t\tCoreGraphics.CGEventCreateKeyboardEvent(None, key_code, True),\n\t)\n\ttime.sleep(0.0001)\n\n\tCoreGraphics.CGEventPost(\n\t\tCoreGraphics.kCGHIDEventTap,\n\t\tCoreGraphics.CGEventCreateKeyboardEvent(None, key_code, False),\n\t)\n\ttime.sleep(0.0001)\n\n\tif with_shift:\n\t\tCoreGraphics.CGEventPost(\n\t\t\tCoreGraphics.kCGHIDEventTap,\n\t\t\tCoreGraphics.CGEventCreateKeyboardEvent(None, KEY_CODE_MAPPING['shift'], False),\n\t\t)\n\t\ttime.sleep(0.0001)\n\n\n\n", "description": null, "category": "graphics", "imports": ["import sys", "import time", "from Quartz import CoreGraphics"]}]]